[
  {
    "language": "Scala",
    "code": "import java.util\nimport java.util.ArrayDeque\n\nobject Main extends App {\n  import scala.io.StdIn._\n  val Array(n, m, a) = readLine.trim.split(' ').map(_.toInt)\n  val state = Array.tabulate(n){_ => readLine.trim}\n  val emitter = (0 until n).collectFirst(y => (0 until m).find(x => state(y)(x) == 'S') match {case Some(x) => Coordinate(x, y)}).head\n  val goal = (0 until n).collectFirst(y => (0 until m).find(x => state(y)(x) == 'G') match {case Some(x) => Coordinate(x, y)}).head\n  val queue = new util.ArrayDeque[State]()\n  val reached = Array.fill(n){Array.fill(m){Array.fill(a + 1){Array.fill(a + 1){false}}}}\n  queue.add(State(emitter, a))\n  reached(emitter.y)(emitter.x)(a)(a) = true\n  while (!queue.isEmpty && queue.getFirst.position != goal) {\n    val current = queue.removeFirst()\n    //println(current)\n    for (forward <- current.succ if (0 until m).contains(forward.position.x) && (0 until n).contains(forward.position.y) && state(forward.position.y)(forward.position.x) != '#') {\n      if (!reached(forward.position.y)(forward.position.x)(forward.typeP)(forward.typeQ)) {\n        queue.addFirst(forward)\n        reached(forward.position.y)(forward.position.x)(forward.typeP)(forward.typeQ) = true\n      }\n      //println(s\"forward: $forward, state: ${state(forward.head.y)(forward.head.x)}\")\n    }\n    for (reflected <- current.reflect if (0 until m).contains(reflected.position.x) && (0 until n).contains(reflected.position.y) && state(reflected.position.y)(reflected.position.x) != '#') {\n      if (!reached(reflected.position.y)(reflected.position.x)(reflected.typeP)(reflected.typeQ)) {\n        queue.addLast(reflected)\n        reached(reflected.position.y)(reflected.position.x)(reflected.typeP)(reflected.typeQ) = true\n      }\n      //println(s\"reflected: $reflected\")\n    }\n  }\n  //println(if (!queue.isEmpty) queue.getFirst else None)\n  println(if (queue.isEmpty) -1 else 2 * a - queue.getFirst.restMirror)\n\n  case class State(typeP: Int, typeQ: Int, position: Coordinate, dir: Dir) {\n    def restMirror = typeP + typeQ\n    def succ: Option[State] = if (emitter == position && dir == Up) None else Some(copy(position = position.move(dir)))\n    def reflect: List[State] = List(useP, useQ).flatten\n    def useP: Option[State] = typeP match {\n      case 0 => None\n      case rest if position != emitter => Some(copy(typeP = rest - 1, dir = dir.reflect(TypeP)))\n      case _ => None\n    }\n    def useQ: Option[State] = typeQ match {\n      case 0 => None\n      case rest if position != emitter => Some(copy(typeQ = rest - 1, dir = dir.reflect(TypeQ)))\n      case _ => None\n    }\n  }\n  object State {\n    def apply(emitter: Coordinate, a: Int): State = State(a, a, emitter, Down)\n  }\n  case class Coordinate(x: Int, y: Int) {\n    def move(dir: Dir): Coordinate = dir match {\n      case Up => copy(y = y - 1)\n      case Right => copy(x = x + 1)\n      case Down => copy(y = y + 1)\n      case Left => copy(x = x - 1)\n    }\n    def -(that: Coordinate): Coordinate = Coordinate(x - that.x, y - that.y)\n    def direction(to: Coordinate): Option[Dir] = (to - this) match {\n      case Coordinate(0, dy) if dy > 0 => Some(Down)\n      case Coordinate(0, dy) if dy < 0 => Some(Up)\n      case Coordinate(dx, 0) if dx > 0 => Some(Right)\n      case Coordinate(dx, 0) if dx < 0 => Some(Left)\n      case _ => None\n    }\n  }\n  case class Laser(from: Coordinate, to: Coordinate) {\n    def hasIntersection(position: Coordinate): Boolean = from == position || to == position || ((from.direction(position), to.direction(position)) match {\n      case (Some(a), Some(b)) if a == b.reverse => true\n      case _ => false\n    })\n    def succ: Laser = Laser(from, to.move(from.direction(to).get))\n    def reflected(mirror: Mirror): Laser = Laser(to, to.move(from.direction(to).get.reflect(mirror)))\n  }\n  object Laser {\n    def fromEmitter(emitter: Coordinate): Laser = Laser(emitter, emitter.move(Down))\n  }\n  sealed trait Dir {\n    def toInt: Int = this match {\n      case Up => 0\n      case Right => 1\n      case Down => 2\n      case Left => 3\n    }\n    def reverse: Dir = Dir.fromInt(toInt + 2)\n    def reflect(mirror: Mirror): Dir = mirror.reflect(this)\n  }\n  object Dir {\n    def fromInt(value: Int): Dir = value & 3 match {\n      case 0 => Up\n      case 1 => Right\n      case 2 => Down\n      case 3 => Left\n    }\n  }\n  case object Up extends Dir\n  case object Right extends Dir\n  case object Down extends Dir\n  case object Left extends Dir\n  sealed trait Mirror {\n    def reflect(dir: Dir): Dir\n  }\n  case object TypeP extends Mirror {\n    override def reflect(dir: Dir): Dir = dir match {\n      case Up => Left\n      case Right => Down\n      case Down => Right\n      case Left => Up\n    }\n  }\n  case object TypeQ extends Mirror {\n    override def reflect(dir: Dir): Dir = dir match {\n      case Up => Right\n      case Right => Up\n      case Down => Left\n      case Left => Down\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct state{\n\tint x, y, p, q, dir;\n\tstate(int a, int b, int c, int d, int e){\n\t\tx = a, y = b, p = c, q = d, dir = e;\n\t}\n};\n\nint N, M, A;\nchar map[105][105];\nint sx, sy, gx, gy;\nbool used[105][105][15][15][4];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y, int p, int q, int dir)\n{\n\tused[x][y][p][q][dir] = true;\n\tif(map[x][y] == 'G') return;\n\t\n\tint np, nq, nx, ny;\n\tfor(int nd = 0; nd < 4; nd++){\n\t\tnp = p, nq = q;\n\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\tif(nx < 0 || nx >= M || ny < 0 || ny >= N) continue;\n\t\tif(map[nx][ny] == '#') continue;\n\t\tif((dir+4-nd) % 4 == 2) continue;\n\t\tif(dir != nd){\n\t\t\tif(map[nx][ny] == 'S') continue;\n\t\t\tif(dir/2 == nd/2) np++;\n\t\t\telse nq++;\n\t\t}\n\t\tif(np > A || nq > A) continue;\n\t\tif(used[nx][ny][np][nq][nd]) continue;\n\t\tdfs(nx, ny, np, nq, nd);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> A;\n\tfor(int y = 0; y < N; y++){\n\t\tfor(int x = 0; x < M; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'S') sx = x, sy = y;\n\t\t\tif(map[x][y] == 'G') gx = x, gy = y;\n\t\t}\n\t}\n\t\n\tif(sy == N-1 || map[sx][sy+1] == '#'){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsy++;\n\t\n\tfor(int x = 0; x < M; x++){\n\t\tfor(int y = 0; y < N; y++){\n\t\t\tfor(int p = 0; p <= A; p++){\n\t\t\t\tfor(int q = 0; q <= A; q++){\n\t\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\t\tused[x][y][p][q][d] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(sx, sy, 0, 0, 3);\n\t\n\tint ans = 1000;\n\tfor(int p = 0; p <= A; p++){\n\t\tfor(int q = 0; q <= A; q++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tif(used[gx][gy][p][q][d]){\n\t\t\t\t\tans = min(ans, p+q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans == 1000) ans = -1;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nint H, W, N, sx, sy, gx, gy, dp[109][109][12][12][4]; char c[109][109];\nqueue<tuple<int, int, int, int, int>>Q; bool used[109][109];\n\nint main() {\n\tcin >> H >> W >> N;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> c[i][j];\n\t\t\tif (c[i][j] == 'S') { c[i][j] = '.'; sx = i; sy = j; }\n\t\t\tif (c[i][j] == 'G') { c[i][j] = '.'; gx = i; gy = j; }\n\t\t}\n\t}\n\tif (c[sx + 1][sy] != '.') {\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\n\tused[sx + 1][sy] = true; queue<pair<int, int>>que; que.push(make_pair(sx + 1, sy));\n\n\twhile (!que.empty()) {\n\t\tint cx = que.front().first, cy = que.front().second; que.pop();\n\t\tint dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\tif (c[ex][ey] != '.' || (ex == sx && ey == sy && i == 0)) continue;\n\t\t\tif (used[ex][ey] == false) { used[ex][ey] = true; que.push(make_pair(ex, ey)); }\n\t\t}\n\t}\n\tif (used[gx][gy] == false) {\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++) { for (int k = 0; k < 144; k++) { for (int l = 0; l < 4; l++) { dp[i][j][k / 12][k % 12][l] = 0; } } } }\n\t\n\tdp[sx][sy][0][0][2] = 1; Q.push(make_tuple(sx, sy, 0, 0, 2));\n\n\twhile (!Q.empty()) {\n\t\tint px = get<0>(Q.front()), py = get<1>(Q.front()), a = get<2>(Q.front()), b = get<3>(Q.front()), dir = get<4>(Q.front()); Q.pop();\n\t\tint dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tx = px + dx[i], ty = py + dy[i];\n\t\t\tif (tx <= 0 || ty <= 0 || tx > H || ty > W || c[tx][ty] == '#') continue;\n\n\t\t\tbool flag = false;\n\t\t\tint pa = a, pb = b; if (i != dir) { if (i + dir == 3) pb++; else pa++; }\n\t\t\tif (i != dir && (i + dir) % 2 == 0) flag = true;\n\t\t\tif (i != dir && px == sx && py == sy) flag = true;\n\t\t\tif (tx == sx && ty == sy && i == 0) flag = true;\n\n\t\t\tif (flag == false && pa <= N && pb <= N && dp[tx][ty][pa][pb][i] == 0) {\n\t\t\t\tdp[tx][ty][pa][pb][i] = 1;\n\t\t\t\tQ.push(make_tuple(tx, ty, pa, pb, i));\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxn = (1 << 30);\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (dp[gx][gy][i][j][k] == 1) maxn = min(maxn, i + j);\n\t\t\t}\n\t\t}\n\t}\n\tif (maxn == (1 << 30)) maxn = -1;\n\tcout << maxn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,-1));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = -1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      if(dp[s.x][s.y]) continue;\n      dp[s.x][s.y] = true;\n\n      for(int i=0;i<4;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  int x, y, a, b, fr;\n  S(int x, int y, int a, int b, int fr) :\n    x(x), y(y), a(a), b(b), fr(fr) {}\n};\nbool insert(queue<S>& que, bool used[100][100][11][11][4], int x, int y, int a, int b, int fr){\n  if(used[y][x][a][b][fr]) return false;\n  used[y][x][a][b][fr] = true;\n  que.push(S(x, y, a, b, fr));\n  return true;\n}\nint tb[4][4] = {{-1, 0, 2, 1},\n                {0, -1, 1, 2},\n                {2, 1, -1, 0},\n                {1, 2, 0, -1}};\n\nint main(){\n  int H, W, A;\n  while(cin>>H>>W>>A){\n    bool used[100][100][11][11][4] = {};\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    queue<S> que;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == 'S'){\n        int r = 1;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          insert(que, used, nx, ny, 0, 0, r);\n        }\n      }\n    }\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(grid[s.y][s.x] == 'S' && s.fr == 3) continue;\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          switch(tb[s.fr][r]){\n            case -1:\n              insert(que, used, nx, ny, s.a, s.b, r);\n              break;\n            case 0:\n              if(s.a + 1 <= A && grid[s.y][s.x] == '.') insert(que, used, nx, ny, s.a + 1, s.b, r);\n              break;\n            case 1:\n              if(s.b + 1 <= A && grid[s.y][s.x] == '.') insert(que, used, nx, ny, s.a, s.b + 1, r);\n              break;\n            case 2:\n              break;\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'G')REP(r, 4)REP(a, A + 1)REP(b, A + 1)if(used[y][x][a][b][r]) ans = min(ans, a + b);\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nclass Data\n{\npublic:\n    int p, q, y, x, d;\n    Data(int p0, int q0, int y0, int x0, int d0){\n        p = p0;\n        q = q0;\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n    int toInt(){\n        return (((p * 11 + q) * 102 + y) * 102 + x) * 4 + d;\n    }\n};\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n\n    vector<string> s(h+2, string(w+2, '#'));\n    int sy, sx, gy, gx;\n    for(int i=1; i<=h; ++i){\n        for(int j=1; j<=w; ++j){\n            cin >> s[i][j];\n            if(s[i][j] == 'S'){\n                sy = i;\n                sx = j;\n            }\n            if(s[i][j] == 'G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n\n    vector<bool> check(11*11*102*102*4, false);\n    queue<Data> q;\n    Data d0(n, n, sy, sx, 1);\n    check[d0.toInt()] = true;\n    q.push(d0);\n\n    int ret = INT_MAX;\n    while(!q.empty()){\n        Data d = q.front();\n        q.pop();\n\n        if(d.y == gy && d.x == gx){\n            ret = min(ret, 2 * n - d.p - d.q);\n            continue;\n        }\n\n        for(int i=0; i<4; ++i){\n            Data d2 = d;\n            d2.y += dy[i];\n            d2.x += dx[i];\n            d2.d = i;\n            if(s[d2.y][d2.x] == '#')\n                continue;\n\n            if(d.d == i){\n                ;\n            }else if(abs(d.d - i) == 2){\n                continue;\n            }else if((dy[d2.d] + dx[d2.d]) * (dy[d.d] + dx[d.d]) == 1){\n                if(-- d2.p < 0)\n                    continue;\n            }else{\n                if(-- d2.q < 0)\n                    continue;\n            }\n\n            if(check[d2.toInt()])\n                continue;\n\n            check[d2.toInt()] = true;\n            q.push(d2);\n        }\n    }\n\n    if(ret == INT_MAX)\n        cout << -1 << endl;\n    else\n        cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2342.cc: Light Road\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 100;\nconst int MAX_A = 10;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Stat {\n  int d, x, y, di, p, q;\n  Stat() {}\n  Stat(int _d, int _x, int _y, int _di, int _p, int _q):\n    d(_d), x(_x), y(_y), di(_di), p(_p), q(_q) {}\n  bool operator<(const Stat &s) const { return d < s.d; }\n  bool operator>(const Stat &s) const { return d > s.d; }\n};\n\ntypedef vector<Stat> vs;\n\n/* global variables */\n\nstring flds[MAX_N];\nbool pm[4][4], qm[4][4];\nint dists[MAX_N][MAX_M][4][MAX_A + 1][MAX_A + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  pm[0][3] = pm[1][2] = pm[2][1] = pm[3][0] = true;\n  qm[0][1] = qm[1][0] = qm[2][3] = qm[3][2] = true;\n\n  int n, m, a;\n  cin >> n >> m >> a;\n\n  int sx, sy, gx, gy;\n  \n  for (int y = 0; y < n; y++) {\n    cin >> flds[y];\n    for (int x = 0; x < m; x++)\n      switch (flds[y][x]) {\n      case 'S': sx = x; sy = y; break;\n      case 'G': gx = x; gy = y; break;\n      }\n  }\n\n  memset(dists, -1, sizeof(dists));\n  dists[sy][sx][3][a][a] = 0;\n\n  priority_queue<Stat,vs,greater<Stat> > q;\n  q.push(Stat(0, sx, sy, 3, a, a));\n\n  int mind = INF;\n  \n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (u.d != dists[u.y][u.x][u.di][u.p][u.q]) continue;\n\n    if (u.x == gx && u.y == gy) {\n      mind = u.d;\n      break;\n    }\n\n    int rudi = (u.di + 2) % 4;\n    \n    for (int vdi = 0; vdi < 4; vdi++) {\n      if (vdi == rudi) continue;\n      if (u.x == sx && u.y == sy &&\n\t  (u.di != vdi || (u.d > 0 && (vdi == 1 || vdi == 3)))) continue;\n\n      int vx = u.x + dxs[vdi], vy = u.y + dys[vdi];\n      if (vx < 0 || vx >= m || vy < 0 || vy >= n || flds[vy][vx] == '#')\n\tcontinue;\n\n      int vd = u.d, vp = u.p, vq = u.q;\n      if (pm[u.di][vdi]) vd++, vp--;\n      else if (qm[u.di][vdi]) vd++, vq--;\n\n      if (vp >= 0 && vq >= 0 && dists[vy][vx][vdi][vp][vq] < 0) {\n\tdists[vy][vx][vdi][vp][vq] = vd;\n\tq.push(Stat(vd, vx, vy, vdi, vp, vq));\n      }\n    }\n  }\n\n  printf(\"%d\\n\", mind < INF ? mind : -1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<deque>\n\nusing namespace std;\n\nstruct S{\n  int y,x,d,p,q;\n};\n\nint main(){\n  int N,M,A;\n  cin>>N>>M>>A;\n  char g[100][100];\n  S is={0,0,2,0,0};\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      cin>>g[i][j];\n      if(g[i][j]=='S'){\n\tis.y=i;\n\tis.x=j;\n      }\n    }\n  }\n  static bool p[100][100][4][11][11];\n  deque<S> deq(1,is);\n  while(!deq.empty()){\n    S c=deq.front();\n    if(g[c.y][c.x]=='G')break;\n    deq.pop_front();\n    if(p[c.y][c.x][c.d][c.p][c.q]++)continue;\n    for(int i=0;i<((g[c.y][c.x]=='S')?1:3);i++){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      S n=c;\n      if(i==1){\n\tn.d^=1;\n\tn.p++;\n      }else if(i==2){\n\tn.d=3-n.d;\n\tn.q++;\n      }\n      n.y+=dy[n.d];\n      n.x+=dx[n.d];\n      if(0<=n.y&&n.y<N&&0<=n.x&&n.x<M&&n.p<=A&&n.q<=A&&g[c.y][c.x]!='#'&&!(g[c.y][c.x]=='S'&&n.d==0)){\n\tif(i==0){\n\t  deq.push_front(n);\n\t}else{\n\t  deq.push_back(n);\n\t}\n      }\n    }\n  }\n  cout<<(deq.empty()?-1:deq.front().p+deq.front().q)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  int sz = 0;\n  Graph G;\n  VI id(100*100*4*10*10*10, -1);\n  int sid = idx(sx,sy,2,0,0);\n  queue<tuple<int,int,int,int,int>> q;\n  q.push(make_tuple(0,0,sx,sy,2));\n  id[sid] = sz++;\n  G.PB(vector<Edge>());\n  \n  while(!q.empty()){\n\tint a1, a2, x, y, d;\n\ttie(a1,a2,x,y,d) = q.front(); q.pop();\n\n\tint fr = idx(x,y,d,a1,a2);\n\n\tif(a1 < A){\n\t  int to = idx(x,y,3-d,a1+1,a2);\n\t  if(id[to] < 0){\n\t\tid[to] = sz++;\n\t\tG.PB(vector<Edge>());\n\t\tq.push(make_tuple(a1+1,a2,x,y,3-d));\n\t  }\n\t  G[id[fr]].PB(Edge(id[to], 1));\n\t}\n\tif(a2 < A){\n\t  int to = idx(x,y,d-(d%2*2-1),a1,a2+1);\n\t  if(id[to] < 0){\n\t\tid[to] = sz++;\n\t\tG.PB(vector<Edge>());\n\t\tq.push(make_tuple(a1,a2+1,x,y,d-(d%2*2-1)));\n\t  }\n\t  G[id[fr]].PB(Edge(id[to], 1));\n\t}\n\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint to = idx(tx,ty,d,a1,a2);\n\tif(id[to] < 0){\n\t  id[to] = sz++;\n\t  G.PB(vector<Edge>());\n\t  q.push(make_tuple(a1,a2,tx,ty,d));\n\t}\n\tG[id[fr]].PB(Edge(id[to], 0));\n  }\n\n  VI dist(sz);\n  Dijkstra(G, dist, id[idx(sx,sy,2,0,0)]);\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tif(id[tid] >= 0)\n\t  ans = min(ans, dist[id[tid]]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, a;\n  cin >> n >> m >> a;\n  vector<string> s(n);\n  Dijkstra<ll> dijk(4 * (a + 1) * n * m);\n  int st = -1, go = -1;\n  REP(i, 0, n) {\n    cin >> s[i];\n    REP(j, 0, m) {\n      if (s[i][j] == 'S') {\n\tst = i * m + j;\n      }\n      if (s[i][j] == 'G') {\n\tgo = i * m + j;\n      }\n    }\n  }\n  int dx[4] = {1, 0, -1, 0};\n  int dy[4] = {0, 1, 0, -1};\n  REP(i, 0, n) {\n    REP(j, 0, m) {\n      int src = i * m + j;\n      if (s[i][j] == '#') { continue; }\n      REP(d, 0, 4) {\n\tint nx = i + dx[d];\n\tint ny = j + dy[d];\n\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) { continue; }\n\tint dst = nx * m + ny;\n\tREP(lv, 0, a + 1) {\n\t  dijk.add_edge(d * (a + 1) * n * m + lv * n * m + src,\n\t\t\td * (a + 1) * n * m + lv * n * m + dst,\n\t\t\t0);\n\t}\n      }\n    }\n  }\n  REP(v, 0, n * m) {\n    REP(lv, 0, a + 1) {\n      // 0 <-> 1 and 2 <-> 3, duplicate-side\n      if (lv < a) {\n\tREP(x, 0, 4) {\n\t  dijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t\t(x ^ 1) * (a + 1) * n * m + (lv + 1) * n * m + v,\n\t\t\t0);\n\t}\n      }\n      // 0 <-> 3 and 1 <-> 2, cost-side\n      REP(x, 0, 4) {\n\tdijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t      (3 - x) * (a + 1) * n * m + lv * n * m + v,\n\t\t      1);\n      }\n    }\n  }\n  ll mi = a + 2;\n  VL sol = dijk.solve(0 * (a + 1) * n * m + st);\n  REP(d, 0, 4) {\n    REP(i, 0, a + 1) {\n      mi = min(mi, i + sol[d * (a + 1) * n * m + i * n * m + go]);\n    }\n  }\n  cout << (mi == a + 2 ? -1 : mi) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n, m, a;\nstring s[100];\nint d[100][100][11][4];\n\nint main(){\n  cin >> n >> m >> a;\n  rep(i, n) cin >> s[i];\n  int sx, sy, gx, gy;\n  rep(i, n) rep(j, m){\n    if (s[i][j] == 'S') sx = i, sy = j;\n    if (s[i][j] == 'G') gx = i, gy = j;\n  }\n  queue<tuple<int, int, int, int>> q;\n  memset(d, -1, sizeof(d));\n  rep(i, 4){\n    d[sx][sy][0][i] = 0;\n    q.emplace(sx, sy, 0, i);\n  }\n  while (q.size()){\n    int x, y, c, dd;\n    tie(x, y, c, dd) = q.front(), q.pop();\n    rep(i, 4){\n      int nx = x + dx[i], ny = y + dy[i];\n      int nc = c + (dd != i), nd = i;\n      if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n      if (s[nx][ny] == '#') continue;\n      if (nc > a) continue;\n      if (d[nx][ny][nc][nd] != -1) continue;\n      d[nx][ny][nc][nd] = d[x][y][c][dd] + 1;\n      q.emplace(nx, ny, nc, nd);\n    }\n  }\n  int res = inf;\n  rep(i, a + 1) rep(j, 4){\n    if (d[gx][gy][i][j] == -1) continue;\n    chmin(res, i);\n  }\n  cout << (res == inf ? -1 : res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    //  if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(u.numR+u.numL,ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(memo[a][b][u.muki]>u.numL+u.numR){\n\t  memo[a][b][u.muki]=u.numL+u.numR;\n\t  Q.push(State(a,b,u.muki,u.numL,u.numR));\n\t}\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+1)%4]>u.numL+u.numR+1){\n\t    memo[a][b][(u.muki+1)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t    if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t  }\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+3)%4]>u.numR+u.numL+1){\n\t    memo[a][b][(u.muki+3)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t    if(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t  }\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  int x, y, a, b, fr;\n  S(int x, int y, int a, int b, int fr) :\n    x(x), y(y), a(a), b(b), fr(fr) {}\n};\nbool insert(queue<S>& que, bool used[100][100][11][11][4], int x, int y, int a, int b, int fr){\n  if(used[y][x][a][b][fr]) return false;\n  used[y][x][a][b][fr] = true;\n  que.push(S(x, y, a, b, fr));\n  return true;\n}\nint tb[4][4] = {{-1, 0, 2, 1},\n                {0, -1, 1, 2},\n                {2, 1, -1, 0},\n                {1, 2, 0, -1}};\n\nint main(){\n  int H, W, A;\n  while(cin>>H>>W>>A){\n    bool used[100][100][11][11][4] = {};\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    queue<S> que;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == 'S'){\n        int r = 1;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          insert(que, used, nx, ny, 0, 0, r);\n        }\n      }\n    }\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(grid[s.y][s.x] == 'S' && s.fr == 3) continue;\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          switch(tb[s.fr][r]){\n            case -1:\n              insert(que, used, nx, ny, s.a, s.b, r);\n              break;\n            case 0:\n              if(s.a + 1 <= A && grid[ny][nx] == '.') insert(que, used, nx, ny, s.a + 1, s.b, r);\n              break;\n            case 1:\n              if(s.b + 1 <= A && grid[ny][nx] == '.') insert(que, used, nx, ny, s.a, s.b + 1, r);\n              break;\n            case 2:\n              break;\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'G')REP(r, 4)REP(a, A + 1)REP(b, A + 1)if(used[y][x][a][b][r]) ans = min(ans, a + b);\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint N,M,A;\nstring s[111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)) dfs(ny,nx,d,p,q);\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  if(p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)) dfs(ny,nx,d,p,q);\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\tfor(int k=0;k<4;k++)\n\t  dfs(i,j,k,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint memo[102][102][4][11][11];\nint field[102][102];\nint A;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstruct aa {\n\tint y;\n\tint x;\n\tint way;\n\tint p;\n\tint q;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn 2*A-(l.p+l.q)> 2 * A - (r.p+r.q);\n\t}\n};\n\n\n\nint pc(const int way) {\n\tif (way == 0) {\n\t\treturn 3;\n\t}\n\telse if (way == 1) {\n\t\treturn 2;\n\t}\n\telse if (way == 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\nint qc(const int way) {\n\tif (way == 0) {\n\t\treturn 1;\n\t}\n\telse if (way == 1) {\n\t\treturn 0;\n\t}\n\telse if (way == 2) {\n\t\treturn 3;\n\t}\n\telse {\n\t\treturn 2;\n\t}\n}\nint main() {\n\tmemset(memo, -1, sizeof(memo));\n\tint N, M; cin >> N >> M >> A;\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[0][j] = 0;\n\t}\n\tint sx, sy;\n\tint gx, gy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfield[i][0] = 0;\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (st[j] == 'S') {\n\t\t\t\tsx = j + 1;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'G') {\n\t\t\t\tgx = j + 1;\n\t\t\t\tgy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfield[i][M+1] = 0;\n\t}\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[N+1][j] = 0;\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sy,sx,1,A,A });\n\tmemo[sy][sx][1][A][A] = 1;\n\t\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = A - atop.p + A - atop.q;\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tconst int nway = atop.way;\n\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q]<0) {\n\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q] = 1;\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tif (atop.y + dy[nway] == sy&&atop.x + dx[nway] == sx) {\n\t\t\t\t\t\tif (nway == 1 || nway == 3) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (atop.x == sx&&atop.y == sy)continue;\n\t\t{\n\t\t\tif (atop.p) {\n\t\t\t\tconst int nway = pc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] = 1;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tif (atop.y + dy[nway] == sy&&atop.x + dx[nway] == sx) {\n\t\t\t\t\t\t\tif (nway == 1 || nway == 3) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p-1, atop.q });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.q) {\n\t\t\t\tconst int nway = qc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] = 1;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tif (atop.y + dy[nway] == sy&&atop.x + dx[nway] == sx) {\n\t\t\t\t\t\t\tif (nway == 1 || nway == 3) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q-1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m, a; cin >> n >> m >> a;\n    vector<string> s(n);\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') si = i, sj = j;\n            if (s[i][j] == 'G') gi = i, gj = j;\n        }\n    }\n\n    if (n <= si+1 or s[si+1][sj] == '#') {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    using data = tuple<int,int,int,int,int>;\n\n    deque<data> deq;\n    deq.push_front(make_tuple(si+1,sj,0,a,a));\n\n    map<data,bool> used;\n\n    int dy[] = {1, 0, -1, 0},\n        dx[] = {0, -1, 0, 1};\n\n    while (!deq.empty()) {\n        int i, j, d, p, q;\n        tie(i,j,d,p,q) = deq.front();\n        deq.pop_front();\n\n        if (i == gi and j == gj) {\n            cout << 2*a - (p+q) << endl;\n            return 0;\n        }\n\n        for (int k = 0; k < 4; ++k) {\n            int y = i + dy[k], x = j + dx[k];\n            if (y < 0 or n <= y or x < 0 or m <= x\n                    or s[y][x] == '#') continue;\n            if (s[y][x] == 'S' and k == 2) continue;\n            if (d == k) {\n                auto tp = make_tuple(y,x,d,p,q);\n                if (!used[tp]) {\n                    deq.push_front(tp);\n                    used[tp] = true;\n                }\n            } else if ((d+1)%4 == k) {\n                if (s[i][j] == 'S') continue;\n                if (d & 1) {\n                    if (q == 0) continue;\n                    auto tp = make_tuple(y,x,k,p,q-1);\n                    if (!used[tp]) {\n                        deq.push_back(tp);\n                        used[tp] = true;\n                    }\n                } else {\n                    if (p == 0) continue;\n                    auto tp = make_tuple(y,x,k,p-1,q);\n                    if (!used[tp]) {\n                        deq.push_back(tp);\n                        used[tp] = true;\n                    }\n                }\n            } else if ((d+3)%4 == k) {\n                if (s[i][j] == 'S') continue;\n                if (d & 1) {\n                    if (p == 0) continue;\n                    auto tp = make_tuple(y,x,k,p-1,q);\n                    if (!used[tp]) {\n                        deq.push_back(tp);\n                        used[tp] = true;\n                    }\n                } else {\n                    if (q == 0) continue;\n                    auto tp = make_tuple(y,x,k,p,q-1);\n                    if (!used[tp]) {\n                        deq.push_back(tp);\n                        used[tp] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nclass State\n{\npublic:\n\tint x,y,d,p,q,c;\n\tState(int x, int y, int d, int p, int q, int c)\n\t\t:x(x),y(y),d(d),p(p),q(q),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint N,M,A;\nbool memo[100][100][4][15][15];\nstring field[100];\n\nbool invaild(int x, int y)\n{\n\tif(x<0||y<0||x>=M||y>=N) return true;\n\tif(field[y][x] == '#') return true;\n\t\n\treturn false;\n}\n\nbool newState(State& s)\n{\n\treturn !memo[s.x][s.y][s.d][s.p][s.q];\n}\n\nState straight(State s)\n{\n\t\n\tint tx = s.x + dx[s.d];\n\tint ty = s.y + dy[s.d];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,s.d,s.p,s.q,s.c);\n}\n\nState useP(State s)\n{\n\tif(s.p == 0) return s;\n\n\tint nd = (s.d+1)%2 + (s.d > 1? 2: 0);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p-1,s.q,s.c+1);\n}\n\nint refQ(int d)\n{\n\tif(d==0) return 3;\n\tif(d==3) return 0;\n\tif(d==1) return 2;\n\n\treturn 1;\n}\n\nState useQ(State s)\n{\n\tif(s.q == 0) return s;\n\n\tint nd = refQ(s.d);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p,s.q-1,s.c+1);\n}\n\n\n\nint solve()\n{\n\tmemset(memo, 0, sizeof(memo));\n\n\tint sx,sy;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<M; j++) {\n\t\tif(field[i][j]=='S') {\n\t\t\tsx = j;\n\t\t\tsy = i;\n\t\t}\n\t}\n\n\tfor(int i=0; i<=A; i++)\n\tfor(int j=0; j<=A; j++)\n\t\tmemo[sx][sy][2][i][j] = true;\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,A,A,0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(!newState(s)) continue;\n\t\tmemo[s.x][s.y][s.d][s.p][s.q] = true;\n\n\t\tif(field[s.y][s.x] == 'G') return s.c;\n\n\t\tState ns = straight(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useP(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useQ(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin >> N >> M >> A;\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\t\tcout << solve() << endl;\n\t\n\n}\n\n/*\n4 2 10\nG#\nS#\n..\n..\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int H, W, A;\n    vector<string> F;\n    void input() {\n        cin >> H >> W >> A;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n    }\n\n    struct S {\n        int p, q, y, x, dir;\n        S(int p, int q, int y, int x, int dir) : p(p), q(q), y(y), x(x), dir(dir) {}\n    };\n\n    void find_pos(int& y, int &x, char c) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == c) {\n                    y = i;\n                    x = j;\n                    return;\n                }\n            }\n        }\n        assert(0);\n    }\n\n    const int dy[] = {-1, 0, 1, 0};\n    const int dx[] = {0, 1, 0, -1};\n\n    const int INF = 1<<28;\n\n    bool valid_pos(int y, int x) {\n        if (y < 0 || y >= H) return false;\n        if (x < 0 || x >= W) return false;\n        if (F[y][x] == '#') return false;\n        return true;\n    }\n\n    void solve() {\n        int sy, sx; find_pos(sy, sx, 'S');\n        static bool D[11][11][101][101][4];\n        memset(D, 0, sizeof(D));\n        queue<S> Q;\n        Q.push(S(0, 0, sy, sx, 2));\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            const int y = c.y;\n            const int x = c.x;\n            for (int i = -1; i <= 1; i++) {\n                int np, nq;\n                if (c.dir % 2 == 0) {\n                    np = c.p + (i < 0); nq = c.q + (i > 0);\n                } else {\n                    np = c.p + (i > 0); nq = c.q + (i < 0);\n                }\n                int ny = y + dy[c.dir]; \n                int nx = x + dx[c.dir];\n                int ndir = (c.dir + i + 4) % 4;\n                if (np > A || nq > A) continue;\n                if (valid_pos(ny, nx)) {\n                    bool& next = D[np][nq][ny][nx][ndir];\n                    if (!next) {\n                        next = true;\n                        Q.push(S(np, nq, ny, nx, ndir));\n                    }\n                }\n            }\n        }\n\n        int gy, gx;\n        find_pos(gy, gx, 'G');\n        int ans = INF;\n        for (int i = 0; i <= A; i++) {\n            for (int j = 0; j <= A; j++) {\n                for (int k = 0; k < 4; k++) {\n                    if (D[i][j][gy][gx][k]) {\n                        ans = min(ans, i + j);\n                    }\n                }\n            }\n        }\n        cout << (ans == INF ? -1: ans) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef tuple< int, int, int, int, int, int > Pi;\nconst int vy[] = {1, 0, -1, 0}, vx[] = {0, 1, 0, -1};\n\nint v[100][100][11][11][4];\n\nint main()\n{\n  int N, M, A;\n  string S[100];\n\n  cin >> N >> M >> A;\n  for(int i = 0; i < N; i++) cin >> S[i];\n\n\n  int sy, sx;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < M; j++) {\n      if(S[i][j] == 'S') sy = i, sx = j;\n    }\n  }\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, sy, sx, A, A, 0);\n  fill_n(****v, 100 * 100 * 11 * 11 * 4, INF);\n  v[sy][sx][A][A][0] = 0;\n\n  auto isover = [&](int y, int x) -> bool\n  {\n    return (y < 0 || y >= N || x < 0 || x >= M || S[y][x] == '#');\n  };\n\n  while(!que.empty()) {\n    int y, x, latte, malta, dir, cost;\n    tie(cost, y, x, latte, malta, dir) = que.top();\n    que.pop();\n    if(S[y][x] == 'G') {\n      cout << cost << endl;\n      return (0);\n    }\n    if(v[y][x][latte][malta][dir] > cost) continue;\n    while(!isover(y + vy[dir], x + vx[dir])) {\n      y += vy[dir], x += vx[dir];\n      if(S[y][x] == 'S' && dir == 2) break;\n      if(S[y][x] == 'G') {\n        que.emplace(cost, y, x, latte, malta, dir);\n        break;\n      }\n      if(latte > 0) {\n        int beet = (dir + 1) % 4;\n        int ll = latte, rr = malta;\n        if(beet % 2 == 0) --ll;\n        else --rr;\n\n        if(cost + 1 < v[y][x][ll][rr][beet]) {\n          v[y][x][ll][rr][beet] = cost + 1;\n          que.emplace(cost + 1, y, x, ll, rr, beet);\n        }\n      }\n      if(malta > 0) {\n        int beet = (dir + 3) % 4;\n        int ll = latte, rr = malta;\n        if(beet % 2 == 1) --ll;\n        else --rr;\n        if(cost + 1 < v[y][x][ll][rr][beet]) {\n          v[y][x][ll][rr][beet] = cost + 1;\n          que.emplace(cost + 1, y, x, ll, rr, beet);\n        }\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && memo[a][b][u.muki]>memo[u.y][u.x][u.muki]){\n\tmemo[a][b][u.muki]=memo[u.y][u.x][u.muki];\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+1)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+1)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+3)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+3)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nchar g[100][128];\n\nint dp[11][100][100][4];\n\nenum{\n  LEFT = 0,\n  DOWN = 1,\n  RIGHT = 2,\n  UP = 3\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\ninline int encode(int a1, int a2, int x, int y, int dir){\n  return dir | (y << 2) | (x << (2 + 8)) | (a2 << (2 + 8 + 8)) | (a1 << (2 + 8 + 8 + 4));\n}\n\ninline void decode(int val, int &a1, int &a2, int &x, int &y, int &dir){\n  a1 = (val >> (2 + 8 + 8 + 4)) & ((1 << 4) - 1);\n  a2 = (val >> (2 + 8 + 8)) & ((1 << 4) - 1);\n  x = (val >> (2 + 8)) & ((1 << 8) - 1);\n  y = (val >> (2)) & ((1 << 8) - 1);\n  dir = val & ((1 << 2) - 1);\n}\n\nint main(){\n  int h, w, a; scanf(\"%d%d%d\", &h, &w, &a);\n  REP(i,h) scanf(\"%s\", g[i]);\n  memset(dp, -1, sizeof(dp));\n\n  priority_queue<int> pq;\n  REP(i,h) REP(j,w) if(g[i][j] == 'S'){\n    pq.push(encode(a, a, j, i, DOWN));\n  }\n\n  int ans = 100;\n  while(pq.size()){\n    int a1, a2, x, y, dir;\n    int d = pq.top(); pq.pop();\n    decode(d, a1, a2, x, y, dir);\n\n    // printf(\"a1=%d a2=%d x=%d y=%d dir=%d\\n\", a1, a2, x, y, dir);\n\n    if(dp[a2][y][x][dir] != -1) continue;\n    dp[a2][y][x][dir] = a1;\n\n    if(g[y][x] == 'G'){\n      ans = min(ans, (a - a1) + (a - a2));\n    }\n\n    REP(k,3){\n      int dd = (dir + k + 3) % 4;\n      int xx = x + dx[dd];\n      int yy = y + dy[dd];\n      if(g[y][x] == 'S' && k != 1) continue;\n      if(ISIN(xx, yy, w, h) && (g[yy][xx] != '#' || g[yy][xx] == 'S')){\n        int aa1 = a1;\n        int aa2 = a2;\n        if(k == 0){\n          // turn right\n          if(dir & 1) aa1--;\n          else aa2--;\n        }else if(k == 2){\n          // turn left\n          if(dir & 1) aa2--;\n          else aa1--;\n        }\n\n        if(aa1 >= 0 && aa2 >= 0){\n          if(dp[aa2][yy][xx][dd] == -1){\n            pq.push(encode(aa1, aa2, xx, yy, dd));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans == 100) puts(\"-1\");\n  else printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint m[4][4];\n\nint h, w, n;\nchar in[100][101];\nbool v[100][100][4][11][11];\n\nint main(){\n\tm[0][3] = m[1][2] = m[3][0] = m[2][1] = 1;\n\t\n\tcin >> h >> w >> n;\n\tint y, x;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t}\n\tpriority_queue<pair<int, pi> > Q;\n\trep(i, 4) Q.push(mp(0, mp(i * h * w + y * w + x, n * 11 + n)));\n\t\n\twhile(!Q.empty()){\n\t\tint co = -Q.top().first;\n\t\tint cd = Q.top().second.first / h / w;\n\t\ty = Q.top().second.first / w % h; x = Q.top().second.first % w;\n\t\tint p = Q.top().second.second / 11, q = Q.top().second.second % 11;\n\t\tQ.pop();\n\t\t\n\t\tif(v[y][x][cd][p][q]) continue;\n\t\tv[y][x][cd][p][q] = 1;\n\t\t\n\t\t//cerr<<y<<\" \"<<x<<\" \"<<cd<<\" \"<<p<<\" \"<<q<<\" \"<<co<<endl;\n\t\t\n\t\tif(in[y][x] == 'G'){\n\t\t\tcout << co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 4) if(d != (cd ^ 2)){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\tint np = p - 1 + m[cd][d], nq = q - m[cd][d], nc = co;\n\t\t\t\n\t\t\tif(d == cd) np = p, nq = q;\n\t\t\telse nc++;\n\t\t\tif(np < 0 || nq < 0) continue;\n\t\t\t\n\t\t\tif(!v[ny][nx][d][np][nq]) Q.push(mp(-nc, mp(d * h * w + ny * w + nx, np * 11 + nq)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)] == '#') return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][11][11][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(ans<=2*A-(p+q)||used[x][y][p][q][dir]++)return;\n  vector<int> X,Y,ch;\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')break;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\npii f(pii a, pii b, int x1, int x2){\n    b.first+=x1;\n    b.second+=x2;\n    \n    if(a.first>=b.first && a.second>=b.second)return b;\n    if(a.first<=b.first && a.second<=b.second)return a;\n    abort();\n}\n\nstruct state{\n    int y,x,dir,bs,s;\n};\n\nint main(){\n    int h,w,a;\n    cin>>h>>w>>a;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    pii s,g;\n    rep(i,h)rep(j,w){\n        if(vs[i][j]=='S')s = pii(i,j);\n        if(vs[i][j]=='G')g = pii(i,j);\n    }\n    \n    static int dp[101][101][4][11][11];\n    rep(i,101)rep(j,101)rep(k,4)rep(l,11)rep(m,11)dp[i][j][k][l][m] = INF;\n    dp[s.first][s.second][0][0][0] = 0;\n    \n    queue<state> que;\n    que.push(state{s.first, s.second, 0, 0, 0});\n    \n    // '\\', '/'\n    //テ、ツクツ? テ・ツ渉ウ, テ、ツクツ? テ・ツキツヲ\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    while(que.size()){\n        state q = que.front();\n        que.pop();\n        \n        for(int k = 1;;k++){\n            int ddy = q.y+dy[q.dir]*k;\n            int ddx = q.x+dx[q.dir]*k;\n            \n            if( q.dir == 2 && pii(ddy,ddx)==s)break;\n            if(pii(ddy,ddx)==s)continue;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            int bsnum,snum;\n            \n            //テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==0)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+3)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n            \n            //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==1)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+1)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    rep(i,4){\n        for(int k=1;;k++){\n            int y,x;\n            tie(y,x) = g;\n            int ddy = y+dy[i]*k;\n            int ddx = x+dx[i]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            rep(l,a+1){\n                rep(m,a+1){\n                    ans = min(ans, dp[ddy][ddx][(i+2)%4][l][m]);\n                }\n            }\n        }\n    }\n    if(ans>2*a)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};\n\nstruct node{\n  int x, y, p, q, dir, dis;\n  bool operator<(const node &n) const{ return dis > n.dis; }\n};\n\nstring s[105];\nint d[105][105][11][11][4];\n\nsigned main(void)\n{\n  int h, w, a;\n  cin >> h >> w >> a;\n  REP(i, h) cin >> s[i];\n  int sx, sy, gx, gy;\n  REP(i, h) REP(j, w) {\n    if(s[i][j] == 'S') sx = j, sy = i;\n    else if(s[i][j] == 'G') gx = j, gy = i;\n  }\n\n  memset(d, -1, sizeof(d));\n  priority_queue<node> que;\n  que.push((node){sx, sy, 0, 0, 2, 0});\n  while(que.size()) {\n    node v = que.top(); que.pop();\n    //cout << v.x << \" \" << v.y << \" \" << v.p << \" \" << v.q << \" \" << v.dir << \" \" << v.dis << endl;\n    if(v.x == gx && v.y == gy) {\n      cout << v.dis << endl;\n      return 0;\n    }\n    if(d[v.x][v.y][v.p][v.q][v.dir] >= 0) continue;\n    d[v.x][v.y][v.p][v.q][v.dir] = v.dis;\n    REP(i, 3) {\n      int di = (v.dir+i+3)%4;\n      //cout << \"d:\" << di << endl;\n      if(v.x == sx && v.y == sy && v.dis && dx[di] != 0) continue;\n      if(v.x == sx && v.y == sy && v.dir != di) continue;\n      bool isp = (v.dir+di) == 3, isq = (v.dir+di)%4 == 1;\n      //cout << \"p:\" << isp << \" q:\" << isq << \" \" << di << endl;\n      if(isp && v.p >= a) continue;\n      if(isq && v.q >= a) continue;\n    //  cout << dx[di] << \" \" << dy[di] << \" \" << endl;\n      int x = v.x + dx[di], y = v.y + dy[di];\n      //Anaconda3\\cout << i << \" \" << x << \" \" << y << \" \" << endl;\n      if(IN(0, w, x) && IN(0, h, y) && s[y][x] != '#') {\n        que.push((node){x, y, v.p+isp, v.q+isq, di, v.dis+isp+isq});\n        //cout << \"a\" << endl;\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={1,0,-1,0};\nconst int p[4]={3,2,1,0};\nconst int q[4]={1,0,3,2};\n\nstring board[110];\nint dist[100][100][4][11][11];\n\nint main(void){\n\tint n,m,a;\n\tcin >> n >> m >> a;\n\trep(i,n) cin >> board[i];\n\n\tint si=0,sj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='S') si=i,sj=j;\n\n\tint gi=0,gj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='G') gi=i,gj=j;\n\t\n\trep(i,n)rep(j,m)rep(d,4)rep(pi,a+1)rep(qi,a+1) dist[i][j][d][pi][qi]=100;\n\n\tusing state=tuple<int,int,int,int,int>;\n\t\n\tdeque<state> que;\n\tdist[si][sj][0][a][a]=0;\n\tque.push_back(state(si,sj,0,a,a));\n\n\twhile(!que.empty()){\n\t\tint ci,cj,d,pi,qi;\n\t\ttie(ci,cj,d,pi,qi)=que.front();\n\t\tque.pop_front();\n\n\t\t{\n\t\t\tconst int ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&(board[ni][nj]=='.'||board[ni][nj]=='S') && chmin(dist[ni][nj][d][pi][qi],dist[ci][cj][d][pi][qi])) \n\t\t\t\tque.push_front(state(ni,nj,d,pi,qi)); \t\n\t\t}\n\n\t\tif(!(ci==si&&cj==sj)&&!(ci==gi&&cj==gj)){\n\t\t\tif(pi>0){\n\t\t\t\tconst int nd=p[d],npi=pi-1,nqi=qi;\n\t\t\t\tif(chmin(dist[ci][cj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ci,cj,nd,npi,nqi));\n\t\t\t}\n\t\t\tif(qi>0){\n\t\t\t\tconst int nd=q[d],npi=pi,nqi=qi-1;\n\t\t\t\tif(chmin(dist[ci][cj][nd][npi][nqi],dist[ci][cj][n][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ci,cj,nd,npi,nqi));\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tint ans=100;\n\trep(d,4)rep(pi,a+1)rep(qi,a+1) chmin(ans,dist[gi][gj][d][pi][qi]);\n\tif(ans==100) ans=-1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 110;\nconst int pmax = 11;\nbool visit[sz][sz][pmax][pmax][4];\n\nint main(){\n  int N, M, P;\n  cin >> N >> M >> P;\n  vector<string> F(N + 2, string(M + 2, '#'));\n\n\n  queue<int> r_que;\n  queue<int> c_que;\n  queue<int> d_que;\n  queue<int> p_que;\n  queue<int> q_que;\n\n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, -1, 0, 1};\n\n  memset(visit, false, sizeof(visit));\n  \n  REP(i, N)REP(j, M){\n    cin >> F[i+1][j+1];\n    if(F[i+1][j+1] == 'S'){\n      r_que.push(i + 1);\n      c_que.push(j + 1);\n      p_que.push(P);\n      q_que.push(P);\n      d_que.push(0);\n      visit[i+1][j+1][P][P][0] = true;\n    }\n  }\n\n  int res = INF;\n  while(!r_que.empty()){\n    int r = r_que.front(); r_que.pop();\n    int c = c_que.front(); c_que.pop();\n    int d = d_que.front(); d_que.pop();\n    int p = p_que.front(); p_que.pop();\n    int q = q_que.front(); q_que.pop();\n    \n    if(F[r][c] == 'G'){\n      res = min(res, 2 * P - p - q);\n      continue;\n    }\n\n    int r2 = r + dr[d];\n    int c2 = c + dc[d];\n    \n    if(F[r2][c2] != '#'){\n      if(!visit[r2][c2][p][q][d]){\n        visit[r2][c2][p][q][d] = true;\n        r_que.push(r2);\n        c_que.push(c2);\n        p_que.push(p);\n        q_que.push(q);\n        d_que.push(d);\n      }\n      \n      if(F[r2][c2] == '.' && p > 0){\n        int d2 = d % 2 == 1 ? (d + 3) % 4 : (d + 1) % 4;\n        if(!visit[r2][c2][p-1][q][d2]){\n          visit[r2][c2][p-1][q][d2] = true;\n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p-1);\n          q_que.push(q);\n          d_que.push(d2);\n        }\n      }\n\n      if(F[r2][c2] == '.' && q > 0){\n        int d2 = d % 2 == 0 ? (d + 3) % 4 : (d + 1) % 4;\n        if(!visit[r2][c2][p][q-1][d2]){\n          visit[r2][c2][p][q-2][d2] = true;          \n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p);\n          q_que.push(q-1);\n          d_que.push(d2);\n        }\n      }\n    }\n  }\n  \n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct state {\n\tint x, y, used_p, dir, dist;\n\tstate(int x_, int y_, int u, int d, int d_):x(x_), y(y_), used_p(u),dir(d), dist(d_) {}\n\tbool operator>(const state &s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nconstexpr int MAX_SIZE = 100;\nconstexpr int MAX_A = 10;\n\nconstexpr int dx[4] = {0, 1, -1, 0};\nconstexpr int dy[4] = {1, 0, 0, -1};\n\nint h, w, a;\nstring field[MAX_SIZE];\nint dist[MAX_SIZE][MAX_SIZE][MAX_A + 1][4];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nint dijkstra(int sx, int sy, int gx, int gy) {\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INT_MAX);\n\n\tfor(int d = 0; d < 4; ++d) {\n\t\tconst int nx = sx + dx[d];\n\t\tconst int ny = sy + dy[d];\n\t\tif(!out(nx, ny) && field[ny][nx] != '#') {\n\t\t\tque.push({nx, ny, 0, d, 0});\n\t\t\tdist[nx][ny][0][d] = 0;\n\t\t}\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.x][s.y][s.used_p][s.dir] < s.dist) continue;\n\t\tif(s.x == gx && s.y == gy) return s.dist;\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tint next_dist = s.dist;\n\t\t\tint next_used_p = s.used_p;\n\t\t\tif(d == s.dir) {\n\t\t\t\t// do nothing\n\t\t\t}\n\t\t\telse if(d == (s.dir ^ 0x1)) { // type p mirror\n\t\t\t\tif(s.used_p == a) continue;\n\t\t\t\t++next_dist;\n\t\t\t\t++next_used_p;\n\t\t\t}\n\t\t\telse if(d == (s.dir ^ 0x2)) { // type q mirror\n\t\t\t\tif(s.dist - s.used_p == a) continue;\n\t\t\t\t++next_dist;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst int nx = s.x + dx[d];\n\t\t\tconst int ny = s.y + dy[d];\n\t\t\tif(out(nx, ny) || field[ny][nx] == '#') continue;\n\t\t\tif(dist[nx][ny][next_used_p][d] > next_dist) {\n\t\t\t\tdist[nx][ny][next_used_p][d] = next_dist;\n\t\t\t\tque.push({nx, ny, next_used_p, d, next_dist});\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> h >> w >> a;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tcin >> field[i];\n\t}\n\n\tint sx, sy, gx, gy;\n\tfor(int y = 0; y < h; ++y) {\n\t\tfor(int x = 0; x < w; ++x) {\n\t\t\tif(field[y][x] == 'S') {\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t}\n\t\t\telse if(field[y][x] == 'G') {\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dijkstra(sx, sy, gx, gy) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nbool dp[4][100][100][11][11];\nint grid[100][100];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint P[4] = { 1,0,3,2 };\nint Q[4] = { 3,2,1,0 };\nvoid solve(){\n    int n, m, a;\n    cin >> n >> m >> a;\n    pair<int, int> goal;\n    queue<tuple<int, int, int, int, int>> next;\n    REP(i, n) {\n        string s;\n        cin >> s;\n        REP(q, m) {\n            if (s[q] == '#') {\n                grid[i][q] = 1;\n            }\n            if (s[q] == 'S') {\n                grid[i][q] = 2;\n                if (i + 1 >= n) {\n                    cout << -1 << endl;\n                    return;\n                }\n                dp[0][i + 1][q][a][a] = 1;\n                next.push(make_tuple(0, i + 1, q, a, a));\n            }\n            if (s[q] == 'G') {\n                goal = mp(i, q);\n            }\n        }\n    }\n    while (next.empty() == false) {\n        auto verify = [n, m](int x, int y) {\n            if (x >= 0 && x < n && y >= 0 && y < m&&grid[x][y] != 1) return 1;\n            return 0;\n        };\n        tuple<int, int, int, int, int> now = next.front();\n        next.pop();\n        if (grid[get<1>(now)][get<2>(now)] == 1) continue;\n        if (grid[get<1>(now)][get<2>(now)] == 2 && get<0>(now) == 2) continue;\n        {\n            int x = get<1>(now) + dx[get<0>(now)];\n            int y = get<2>(now) + dy[get<0>(now)];\n            if(verify(x,y))\n            if (dp[get<0>(now)][x][y][get<3>(now)][get<4>(now)] == 0) {\n                dp[get<0>(now)][x][y][get<3>(now)][get<4>(now)] = 1;\n                next.push(make_tuple(get<0>(now), x, y, get<3>(now), get<4>(now)));\n            }\n        }\n        if (grid[get<1>(now)][get<2>(now)] == 2) continue;\n        if (get<3>(now) > 0) {\n            int t = P[get<0>(now)];\n            int x = get<1>(now) + dx[t];\n            int y = get<2>(now) + dy[t];\n            if (verify(x, y))\n                if (dp[t][x][y][get<3>(now) - 1][get<4>(now)] == 0) {\n                    dp[t][x][y][get<3>(now) - 1][get<4>(now)] = 1;\n                    next.push(make_tuple(t, x, y, get<3>(now) - 1, get<4>(now)));\n                }\n        }\n        if (get<4>(now) > 0) {\n            int t = Q[get<0>(now)];\n            int x = get<1>(now) + dx[t];\n            int y = get<2>(now) + dy[t];\n            if (verify(x, y))\n                if (dp[t][x][y][get<3>(now)][get<4>(now) - 1] == 0) {\n                    dp[t][x][y][get<3>(now)][get<4>(now) - 1] = 1;\n                    next.push(make_tuple(t, x, y, get<3>(now), get<4>(now) - 1));\n                }\n        }\n    }\n    int ans = 30;\n    REP(i, a + 1) {\n        REP(q, a + 1) {\n            REP(j, 4) {\n                if (dp[j][goal.first][goal.second][i][q]) {\n                    ans = min(ans, a - i + a - q);\n                }\n            }\n        }\n    }\n    if (ans == 30)ans = -1;\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\nchar map[100][101];\n\nstruct Data{\n\tDIR in_dir,out_dir;\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[21];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool canPut(Data data[21],int num_data,int row,int col){\n\n\tint start_row,start_col,next_row,next_col;\n\n\tfor(int i = 1; i < num_data; i++){\n\n\t\tstart_row = data[i-1].row;\n\t\tstart_col = data[i-1].col;\n\t\tnext_row = data[i].row;\n\t\tnext_col = data[i].col;\n\n\t\tswitch(data[i-1].out_dir){\n\t\tcase North:\n\t\t\tfor(int i = start_row; i >= next_row; i--){\n\t\t\t\tif(row == i && col == start_col){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase East:\n\t\t\tfor(int i = start_col; i <= next_col; i++){\n\t\t\t\tif(row == start_row && col == i){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase West:\n\t\t\tfor(int i = start_col; i >= next_col; i--){\n\t\t\t\tif(row == start_row && col == i){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase South:\n\t\t\tfor(int i = start_row; i <= next_row; i++){\n\t\t\t\tif(row == i && col == start_col){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn true;\n}\n\nvoid copyData(Info& to,Info from){\n\tfor(int k = 0; k < from.num_data;k++){\n\t\tto.data[k].row = from.data[k].row;\n\t\tto.data[k].col = from.data[k].col;\n\t\tto.data[k].mirror = from.data[k].mirror;\n\t\tto.data[k].in_dir = from.data[k].in_dir;\n\t\tto.data[k].out_dir = from.data[k].out_dir;\n\t}\n\tto.num_data = from.num_data;\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tif(i < H-1)minTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(rangeCheck(first.row,first.col) == false || map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\tfirst.data[0].row = first.row-1;\n\tfirst.data[0].col = first.col;\n\tfirst.data[0].out_dir = South;\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 1;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nDef d[110][110][11][4];\nclass DIJ{\n\tpublic:\n\tDef n,m,A;\n\tvs in;\n\tDIJ(Def size,Def w,vs fi,Def q){\n\t\tn=size;\n\t\tin=fi;\n\t\tm=w;\n\t\tA=q;\n\t}\n\tvoid dij(){\n\t\trep(i,110)rep(j,110)rep(l,11)rep(q,4)\n\t\t\td[i][j][l][q]=inf;\n\t\tint gx,gy;\n\t\tpriority_queue<tp>q;\n\t\trep(i,in.size())rep(j,in[0].size())\n\t\t\tif(in[i][j]=='G')gx=i,gy=j;\n\t\t\telse if(in[i][j]=='S'){\n\t\t\t\trep(l,4){\n\t\t\t\t\td[i][j][0][l]=0;\n\t\t\t\t\tq.push(tp(0,i,j,0,l));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,a,to;\n\t\t\ttie(cost,x,y,a,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][a][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tint na=a,nb=cost;\n\t\t\t\tint nto=k;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tif((to+2)%4==nto)continue;\n\t\t\t\tif(nto!=to){\n\t\t\t\t\tif(to%2){\n\t\t\t\t\t\tif((to+1)%4==nto)na++;\n\t\t\t\t\t\telse nb++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((to+1)%4==nto)nb++;\n\t\t\t\t\t\telse na++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(na>A||nb>A)continue;\n\t\t\t\tif(nb<d[nx][ny][na][nto]){\n\t\t\t\t\td[nx][ny][na][nto]=nb;\n\t\t\t\t\tq.push(tp(-nb,nx,ny,na,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,11)rep(j,4)if(d[gx][gy][i][j]!=inf){\n\t\t\tcmin(out,i+d[gx][gy][i][j]);\n\t\t}\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(n,m,in,k);\n\tdij.dij();\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/06/10  Problem: AOJ 2342 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\nがんばる(がんばるしかないので)\n\n----解説ここまで---- */\n\nstruct state {\n\tint y, x, dir, bs, s;\n\tstate() { y = x = dir = bs = s = 0; }\n\tstate(int a, int b, int c, int d, int e) :y(a), x(b), dir(c), bs(d), s(e) {}\n};\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint H, W, A;\n\tcin >> H >> W >> A;\n\tVS vs(H);\n\tFOR(i, 0, H) {\n\t\tcin >> vs[i];\n\t}\n\n\tPII S, T;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tif (vs[i][j] == 'S')S = PII(i, j);\n\t\t\tif (vs[i][j] == 'G')T = PII(i, j);\n\t\t}\n\t}\n\n\tstatic int dp[101][101][4][11][11];\n\tfill(****dp, ****dp + 101 * 101 * 4 * 11 * 11, INF);\n\tdp[S.first][S.second][0][0][0] = 0;\n\tqueue<state> que;\n\tque.push(state{ S.first, S.second, 0, 0, 0 });\n\n\tint dy[] = { 1,0,-1,0 };\n\tint dx[] = { 0,1,0,-1 };\n\twhile (!que.empty()) {\n\t\tstate q = que.front();\n\t\tque.pop();\n\n\t\tfor (int k = 1; k < 1000; k++) {\n\t\t\tint ny = q.y + dy[q.dir] * k;\n\t\t\tint nx = q.x + dx[q.dir] * k;\n\t\t\t// y : %2==0 , x: %2==1\n\n\t\t\tif (q.dir == 2 && PII(ny, nx) == S)break;\n\t\t\tif (PII(ny, nx) == S)continue;\n\n\t\t\tif (!(0 <= nx && nx < W && 0 <= ny  && ny < H))break;\n\t\t\t{\n\t\t\t\tif (vs[ny][nx] == '#')break;\n\n\t\t\t\tint bsnum, snum;\n\n\t\t\t\tif (q.dir % 2 == 0) {\n\t\t\t\t\tbsnum = 0, snum = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbsnum = 1, snum = 0;\n\t\t\t\t}\n\n\t\t\t\tif (q.bs + bsnum <= A && q.s + snum <= A) {\n\t\t\t\t\tif (dp[ny][nx][(q.dir + 3) % 4][q.bs + bsnum][q.s + snum] == INF) {\n\t\t\t\t\t\tdp[ny][nx][(q.dir + 3) % 4][q.bs + bsnum][q.s + snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n\t\t\t\t\t\tque.push(state{ ny, nx, (q.dir + 3) % 4, q.bs + bsnum, q.s + snum });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (q.dir % 2 == 1) {\n\t\t\t\t\tbsnum = 0, snum = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbsnum = 1, snum = 0;\n\t\t\t\t}\n\n\t\t\t\tif (q.bs + bsnum <= A && q.s + snum <= A) {\n\t\t\t\t\tif (dp[ny][nx][(q.dir + 1) % 4][q.bs + bsnum][q.s + snum] == INF) {\n\t\t\t\t\t\tdp[ny][nx][(q.dir + 1) % 4][q.bs + bsnum][q.s + snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n\t\t\t\t\t\tque.push(state{ ny, nx, (q.dir + 1) % 4, q.bs + bsnum, q.s + snum });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tFOR(i, 0, 4) {\n\t\tfor (int k = 1;; k++) {\n\t\t\tint ny = T.first + dy[i] * k;\n\t\t\tint nx = T.second + dx[i] * k;\n\n\t\t\tif (0 <= nx && nx < W && 0 <= ny  && ny < H) {\n\t\t\t\tif (vs[ny][nx] == '#')break;\n\n\t\t\t\tif (i == 0 && PII(ny, nx) == S)break;\n\t\t\t\t//debug(ans);\n\t\t\t\tFOR(l, 0, A + 1) {\n\t\t\t\t\tFOR(m, 0, A + 1) {\n\t\t\t\t\t\tans = min(ans, dp[ny][nx][(i + 2) % 4][l][m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug(ans);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tif (ans > 2 * A) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tpriority_queue<T, vector<T>, greater<T>> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)] == '#') return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(0, get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint c, y, x, p, q, d;\n\t\ttie(c,y,x,p,q,d) = que.top(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\tif(y == get<0>(g) and x == get<1>(g)) break;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\tint nc = c;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(nc,ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\nstruct Point{ int x, y, p, q, d; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tqueue<Point> q;\n\n\tdis[p.y][p.x][a][a][1] = 1;\n\tPoint tmp = Point{p.x, p.y, a, a, 1};\n\tq.push(tmp);\n\n\twhile(not q.empty()){\n\t\tPoint u = q.front(); q.pop();\n\t\t//cout << u.x << ' ' << u.y << ' ' << u.p << ' ' << u.q << ' ' << u.d << endl;\n\t\trep(i,4){\n\t\t\tif((u.d + 2) % 4 == i) continue;\n\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tnext.d = i;\n\t\t\tnext.p = u.p;\n\t\t\tnext.q = u.q;\n\t\t\tif(u.d == 0 || u.d == 2){\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(next.p < 0 || next.q < 0) continue;\n\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[next.y][next.x][next.p][next.q][next.d] && m[next.y][next.x] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[next.y][next.x][next.p][next.q][next.d] = 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[g.y][g.x][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tPoint s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = Point{j,i};\n\t\tif(m[i][j] == 'G') g = Point{j,i};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={1,0,-1,0};\nconst int p[4]={3,2,1,0};\nconst int q[4]={1,0,3,2};\n\nstring board[110];\nint dist[100][100][4][11][11];\n\nint main(void){\n\tint n,m,a;\n\tcin >> n >> m >> a;\n\trep(i,n) cin >> board[i];\n\n\tint si=0,sj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='S') si=i,sj=j;\n\n\tint gi=0,gj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='G') gi=i,gj=j;\n\t\n\trep(i,n)rep(j,m)rep(d,4)rep(pi,a+1)rep(qi,a+1) dist[i][j][d][pi][qi]=100;\n\n\tusing state=tuple<int,int,int,int,int>;\n\t\n\tdeque<state> que;\n\tdist[si][sj][0][a][a]=0;\n\tque.push_back(state(si,sj,0,a,a));\n\n\twhile(!que.empty()){\n\t\tint ci,cj,d,pi,qi;\n\t\ttie(ci,cj,d,pi,qi)=que.front();\n\t\tque.pop_front();\n\n\t\t{\n\t\t\tconst int ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][d][pi][qi],dist[ci][cj][d][pi][qi])) \n\t\t\t\tque.push_front(state(ni,nj,d,pi,qi)); \t\n\t\t}\n\n\t\tif(!(ci==si&&cj==sj)&&!(ci==gi&&cj==gj)){\n\t\t\tif(pi>0){\n\t\t\t\tconst int nd=p[d],npi=pi-1,nqi=qi;\n\t\t\t\tif(chmin(dist[ci][cj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ci,cj,nd,npi,nqi));\n\t\t\t}\n\t\t\tif(qi>0){\n\t\t\t\tconst int nd=q[d],npi=pi,nqi=qi-1;\n\t\t\t\tif(chmin(dist[ci][cj][nd][npi][nqi],dist[ci][cj][n][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ci,cj,nd,npi,nqi));\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tint ans=100;\n\trep(d,4)rep(pi,a+1)rep(qi,a+1) chmin(ans,dist[gi][gj][d][pi][qi]);\n\tif(ans==100) ans=-1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint d[4][11][100][100];\n\nint main() {\n    int N, M, A;\n    cin >> N >> M >> A;\n    vector<string> v(N);\n    int sy, sx, gy, gx;\n    for(int i=0; i<N; ++i) {\n        cin >> v[i];\n        for(int j=0; j<M; ++j) {\n            if(v[i][j] == 'S') {\n                sy = i;\n                sx = j;\n            }\n            if(v[i][j] == 'G') {\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    for(int i=0; i<4; ++i) {\n        for(int j=0; j<11; ++j) {\n            for(int k=0; k<100; ++k) {\n                for(int l=0; l<100; ++l) {\n                    d[i][j][k][l] = INF;\n                }\n            }\n        }\n    }\n    d[2][0][sy][sx] = 0;\n    using state = tuple<int, int, int, int, int>;\n    priority_queue<state, vector<state>, greater<state>> que;\n    que.push(make_tuple(0, 2, 0, sy, sx));\n    // 0: N, 1: E, 2: S, 3: W\n    // 0: straight, 1: right, 2: left\n    constexpr int dx[4][3] = {{0, 1, -1}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 0}};\n    constexpr int dy[4][3] = {{-1, 0, 0}, {0, 1, -1}, {1, 0, 0}, {0, -1, 1}};\n    constexpr int P[4][3] = {{0, 0, 1}, {0, 1, 0}, {0, 0, 1}, {0, 1, 0}};\n    constexpr int Q[4][3] = {{0, 1, 0}, {0, 0, 1}, {0, 1, 0}, {0, 0, 1}};\n    while(!que.empty()) {\n        int qcnt, dir, pcnt, y, x;\n        tie(qcnt, dir, pcnt, y, x) = que.top();\n        que.pop();\n        if(d[dir][pcnt][y][x] < qcnt) {\n            continue;\n        }\n        for(int i=-1; i<=1; ++i) {\n            if(y == sy && x == sx && i != 0) {\n                continue;\n            }\n            int j = (i + 3) % 3;\n            int nqc = d[dir][pcnt][y][x] + Q[dir][j], npc = pcnt + P[dir][j];\n            int ny = y + dy[dir][j], nx = x + dx[dir][j];\n            int nd = (dir + i + 4) % 4;\n            if(npc > A || nqc > A || ny < 0 || N <= ny || nx < 0 || M <= nx || v[ny][nx] == '#' || nd == 0 && v[ny][nx] == 'S') {\n                continue;\n            }\n            if(d[nd][npc][ny][nx] > nqc) {\n                d[nd][npc][ny][nx] = nqc;\n                que.push(make_tuple(d[nd][npc][ny][nx], nd, npc, ny, nx));\n            }\n        }\n    }\n    int res = INF;\n    for(int i=0; i<4; ++i) {\n        for(int j=0; j<11; ++j) {\n            res = min(res, d[i][j][gy][gx] + j);\n        }\n    }\n    cout << (res == INF ? -1 : res) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int i,j,dir,p,q;\n};\nbool operator<(const state& a,const state& b){\n  return a.p+a.q<b.p+b.q;\n};\n\nint n,m,a;\nint dist[111][111][5][11][11];\nstring s[111];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nbool valid(int i,int j){\n  return i>=0&&i<n&&j>=0&&j<m;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m>>a;\n  rep(i,n)cin>>s[i];\n  rep(i,111)rep(j,111)rep(k,5)rep(p,11)rep(q,11)dist[i][j][k][p][q]=INF;\n  priority_queue<state> que;\n  rep(i,n)rep(j,m){\n    if(s[i][j]=='S'){\n      que.push((state){i,j,3,a,a});\n    }\n  }\n  int res=INF;\n  while(que.size()){\n    state ns=que.top(); que.pop();\n    int i=ns.i,j=ns.j,dir=ns.dir,p=ns.p,q=ns.q;\n    if(dist[i][j][dir][p][q]!=INF)continue;\n    dist[i][j][dir][p][q]=p+q;\n    if(s[i][j]=='G'){\n      res=2*a-p-q;\n      break;\n    }\n    if(s[i][j]!='S'){\n      int ndir;\n      if(p>0){\n        if(dir==3||dir==0) ndir=3-dir;\n        else ndir=3-dir;\n        int ni=i+dy[ndir],nj=j+dx[ndir];\n        if(valid(ni,nj)&&s[ni][nj]!='#'){\n          que.push((state){ni,nj,ndir,p-1,q});\n        }\n      }\n      if(q>0){\n        if(dir==0||dir==1) ndir=1-dir;\n        else ndir=5-dir;\n        int ni=i+dy[ndir],nj=j+dx[ndir];\n        if(valid(ni,nj)&&s[ni][nj]!='#'){\n          que.push((state){ni,nj,ndir,p,q-1});\n        }\n      }\n    }\n    int ni=i+dy[dir],nj=j+dx[dir];\n    if(valid(ni,nj)&&s[ni][nj]!='#'){\n      que.push((state){ni,nj,dir,p,q});\n    }\n  }\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    //for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    q.push(make_tuple(S.first,S.second,1,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 110;\nconst int pmax = 11;\nbool visit[sz][sz][pmax][pmax][4];\n\n#define PUSH(r, c, p, q, d) do{                 \\\n    r_que.push(r);                              \\\n    c_que.push(c);                              \\\n    d_que.push(d);                              \\\n    p_que.push(p);                              \\\n    q_que.push(q);                              \\\n    visit[r][c][p][q][d] = true;                \\\n  }while(0)                                     \\\n\nint main(){\n  int N, M, P;\n  cin >> N >> M >> P;\n  vector<string> F(N + 2, string(M + 2, '#'));\n\n  queue<int> r_que;\n  queue<int> c_que;\n  queue<int> d_que;\n  queue<int> p_que;\n  queue<int> q_que;\n  \n  \n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, -1, 0, 1};\n  int pm[4] = {3, 2, 1, 0};     // /\n  int qm[4] = {1, 0, 3, 2};     // ＼\n  memset(visit, false, sizeof(visit));\n  \n  REP(i, N)REP(j, M){\n    cin >> F[i+1][j+1];\n    if(F[i+1][j+1] == 'S') PUSH(i+1, j+1, P, P, 0);\n  }\n\n  int res = INF;\n  while(!r_que.empty()){\n    int r = r_que.front(); r_que.pop();\n    int c = c_que.front(); c_que.pop();\n    int d = d_que.front(); d_que.pop();\n    int p = p_que.front(); p_que.pop();\n    int q = q_que.front(); q_que.pop();\n    \n    if(F[r][c] == 'G') res = min(res, 2 * P - p - q);\n    \n    int r2 = r + dr[d];\n    int c2 = c + dc[d];\n    \n    \n    if(F[r2][c2] != '#' && !visit[r2][c2][p][q][d]) PUSH(r2, c2, p, q, d);\n      \n    if(F[r2][c2] == '.' && p > 0 && !visit[r2][c2][p-1][q][pm[d]]){\n      PUSH(r2, c2, p-1, q, pm[d]);\n    }\n    \n    if(F[r2][c2] == '.' && q > 0 && !visit[r2][c2][p][q-1][qm[d]]){\n      PUSH(r2, c2, p, q-1, qm[d]);\n    }\n  }\n  \n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  REP(i,4) {\n    que.emplace(si, sj, i, 0, 0);\n    vis[si][sj][i][0][0] = true;\n  }\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int nd = dd[k][d];\n      if ((p == a && k == 1) || (q == a && k == 2)) continue;\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (t[ni][nj] == '#') continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][10][10][4];\n\nstruct Point{ int x, y, p, q, d; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tqueue<Point> q;\n\n\trep(i,4) {\n\t\tdis[p.y][p.x][a][a][i] = 1;\n\t\tPoint tmp = Point{p.x, p.y, a, a, i};\n\t\tq.push(tmp);\n\t}\n\n\twhile(not q.empty()){\n\t\tPoint u = q.front(); q.pop();\n\t\t//cout << u.x << ' ' << u.y << ' ' << u.p << ' ' << u.q << ' ' << u.d << endl;\n\t\trep(i,4){\n\t\t\tif((u.d + 2) % 4 == i) continue;\n\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tnext.d = i;\n\t\t\tnext.p = u.p;\n\t\t\tnext.q = u.q;\n\t\t\tif(u.d == 0 || u.d == 2){\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(next.p < 0 || next.q < 0) continue;\n\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[next.y][next.x][next.p][next.q][next.d] && m[next.y][next.x] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[next.y][next.x][next.p][next.q][next.d] = 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[g.y][g.x][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tPoint s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = Point{j,i};\n\t\tif(m[i][j] == 'G') g = Point{j,i};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nchar g[100][128];\n\nint dp[11][100][100][4];\n\nenum{\n  LEFT = 0,\n  DOWN = 1,\n  RIGHT = 2,\n  UP = 3\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\ninline int encode(int a1, int a2, int x, int y, int dir){\n  return dir | (y << 2) | (x << (2 + 8)) | (a2 << (2 + 8 + 8)) | (a1 << (2 + 8 + 8 + 4));\n}\n\ninline void decode(int val, int &a1, int &a2, int &x, int &y, int &dir){\n  a1 = (val >> (2 + 8 + 8 + 4)) & ((1 << 4) - 1);\n  a2 = (val >> (2 + 8 + 8)) & ((1 << 4) - 1);\n  x = (val >> (2 + 8)) & ((1 << 8) - 1);\n  y = (val >> (2)) & ((1 << 8) - 1);\n  dir = val & ((1 << 2) - 1);\n}\n\nint main(){\n  int h, w, a; scanf(\"%d%d%d\", &h, &w, &a);\n  REP(i,h) scanf(\"%s\", g[i]);\n  memset(dp, -1, sizeof(dp));\n\n  priority_queue<int> pq;\n  REP(i,h) REP(j,w) if(g[i][j] == 'S'){\n    pq.push(encode(a, a, j, i, DOWN));\n  }\n\n  int ans = 100;\n  while(pq.size()){\n    int a1, a2, x, y, dir;\n    int d = pq.top(); pq.pop();\n    decode(d, a1, a2, x, y, dir);\n\n    // printf(\"a1=%d a2=%d x=%d y=%d dir=%d\\n\", a1, a2, x, y, dir);\n\n    if(dp[a2][y][x][dir] != -1) continue;\n    dp[a2][y][x][dir] = a1;\n\n    if(g[y][x] == 'G'){\n      ans = min(ans, (a - a1) + (a - a2));\n    }\n\n    REP(k,3){\n      int dd = (dir + k + 3) % 4;\n      int xx = x + dx[dd];\n      int yy = y + dy[dd];\n      if(ISIN(xx, yy, w, h) && g[yy][xx] != '#'){\n        int aa1 = a1;\n        int aa2 = a2;\n        if(k == 0){\n          // turn left\n          if(dir == DOWN || dir == UP) aa1--;\n          else aa2--;\n        }else if(k == 2){\n          // turn right\n          if(dir == DOWN || dir == UP) aa2--;\n          else aa1--;\n        }\n\n        if(aa1 >= 0 && aa2 >= 0){\n          if(dp[aa2][yy][xx][dd] == -1){\n            pq.push(encode(aa1, aa2, xx, yy, dd));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans == 100) puts(\"-1\");\n  else printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,X;\nint d[100][100][4][11][11];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ad[4]={1,0,3,2},bd[4]={3,2,1,0};\nint inf=100;\nstring s[100];\ndeque<int> qx,qy,qd,qa,qb;\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nvoid pushf(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_front(x);\n\tqy.push_front(y);\n\tqd.push_front(z);\n\tqa.push_front(a);\n\tqb.push_front(b);\n\td[x][y][z][a][b]=c;\n}\nvoid pushb(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_back(x);\n\tqy.push_back(y);\n\tqd.push_back(z);\n\tqa.push_back(a);\n\tqb.push_back(b);\n\td[x][y][z][a][b]=c;\n}\nint main(){\n\tcin>>H>>W>>X;\n\trep(i,H) rep(j,W) rep(k,4) rep(a,X+1) rep(b,X+1) d[i][j][k][a][b]=inf;\n\trep(i,H) cin>>s[i];\n\tint sx,sy;\n\trep(i,H) rep(j,W) if(s[i][j]=='S') sx=i,sy=j;\n\tpushb(sx,sy,0,X,X,0);\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front(),di=qd.front(),a=qa.front(),b=qb.front();\n\t\tqx.pop_front(),qy.pop_front(),qd.pop_front(),qa.pop_front(),qb.pop_front();\n\t\tint c=d[x][y][di][a][b];\n\t\tif(s[x][y]=='G'){\n\t\t\tcout<<c<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\tif(is(nx,ny)) pushf(nx,ny,di,a,b,c);\n\t\tif(a) pushb(x,y,ad[di],a-1,b,c+1);\n\t\tif(b) pushb(x,y,bd[di],a,b-1,c+1);\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n    \n    bool operator < (const _State r)const{\n        return r.h == h? r.w == w? r.dir==dir? r.pq < pq: r.dir<dir: r.w < w:r.h < h;\n    }\n}State;\n\nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n\n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n\nint bfs(){\n    queue<State> que;\n    map<State, int> dist;\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s] = 0;\n    \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n            if(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n            for(int i=-1; i<2; i++){\n                if(nh == Sh && nw == Sw && i>=0) break;\n                \n                State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                \n                if(dist.find(v) == dist.end()){\n                    dist[v] = dist[u];\n                    if(i >= 0)\n                        dist[v]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v];\n                    //cout << v.h << \" \" << v.w << \" \" << dist[v] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n    \n    for(int i=0; i<N; i++) for(int j=0; j<M; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n    cout << bfs() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint memo[102][102][4][11][11];\nint field[102][102];\nint A;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstruct aa {\n\tint y;\n\tint x;\n\tint way;\n\tint p;\n\tint q;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn 2*A-(l.p+l.q)> 2 * A - (r.p+r.q);\n\t}\n};\n\n\n\nint pc(const int way) {\n\tif (way == 0) {\n\t\treturn 3;\n\t}\n\telse if (way == 1) {\n\t\treturn 2;\n\t}\n\telse if (way == 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\nint qc(const int way) {\n\tif (way == 0) {\n\t\treturn 1;\n\t}\n\telse if (way == 1) {\n\t\treturn 0;\n\t}\n\telse if (way == 2) {\n\t\treturn 3;\n\t}\n\telse {\n\t\treturn 2;\n\t}\n}\nint main() {\n\tmemset(memo, -1, sizeof(memo));\n\tint N, M; cin >> N >> M >> A;\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[0][j] = 0;\n\t}\n\tint sx, sy;\n\tint gx, gy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfield[i][0] = 0;\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (st[j] == 'S') {\n\t\t\t\tsx = j + 1;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'G') {\n\t\t\t\tgx = j + 1;\n\t\t\t\tgy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfield[i][M+1] = 0;\n\t}\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[N+1][j] = 0;\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sy,sx,1,A,A });\n\n\t\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = A - atop.p + A - atop.q;\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tconst int nway = atop.way;\n\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q]<0) {\n\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q] = 1;\n\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.p) {\n\t\t\t\tconst int nway = pc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p - 1, atop.q });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.q) {\n\t\t\t\tconst int nway = qc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q - 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 110;\nconst int pmax = 11;\nbool visit[sz][sz][pmax][pmax][4];\n\nint main(){\n  int N, M, P;\n  cin >> N >> M >> P;\n  vector<string> F(N + 2, string(M + 2, '#'));\n\n\n  queue<int> r_que;\n  queue<int> c_que;\n  queue<int> d_que;\n  queue<int> p_que;\n  queue<int> q_que;\n  \n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, -1, 0, 1};\n  int pm[4] = {3, 2, 1, 0};\n  int qm[4] = {1, 0, 3, 2};\n    \n\n  memset(visit, false, sizeof(visit));\n  \n  REP(i, N)REP(j, M){\n    cin >> F[i+1][j+1];\n    if(F[i+1][j+1] == 'S'){\n      r_que.push(i + 1);\n      c_que.push(j + 1);\n      p_que.push(P);\n      q_que.push(P);\n      d_que.push(0);\n      visit[i+1][j+1][P][P][0] = true;\n    }\n  }\n\n  int res = INF;\n  while(!r_que.empty()){\n    int r = r_que.front(); r_que.pop();\n    int c = c_que.front(); c_que.pop();\n    int d = d_que.front(); d_que.pop();\n    int p = p_que.front(); p_que.pop();\n    int q = q_que.front(); q_que.pop();\n    \n    if(F[r][c] == 'G'){\n      res = min(res, 2 * P - p - q);\n      continue;\n    }\n\n    int r2 = r + dr[d];\n    int c2 = c + dc[d];\n\n    \n    if(F[r2][c2] != '#'){\n      if(!visit[r2][c2][p][q][d]){\n        visit[r2][c2][p][q][d] = true;\n        r_que.push(r2);\n        c_que.push(c2);\n        p_que.push(p);\n        q_que.push(q);\n        d_que.push(d);\n      }\n      \n      if(F[r2][c2] == '.' && p > 0){\n        int d2 = pm[d];\n        if(!visit[r2][c2][p-1][q][d2]){\n          visit[r2][c2][p-1][q][d2] = true;\n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p-1);\n          q_que.push(q);\n          d_que.push(d2);\n        }\n      }\n\n      if(F[r2][c2] == '.' && q > 0){\n        int d2 = qm[d];\n        if(!visit[r2][c2][p][q-1][d2]){\n          visit[r2][c2][p][q-1][d2] = true;          \n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p);\n          q_que.push(q-1);\n          d_que.push(d2);\n        }\n      }\n    }\n  }\n  \n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\nint H, W, A;\nvector<string> s(H);\nint sx, sy, gx, gy;\nconst int MAX_V = 4*11*11*100*100;\nint d[MAX_V];\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nstruct Node {\n    int x, y, p, q, k, id;\n    Node(){}\n    Node(int _x, int _y, int _p, int _q, int _k) : x(_x), y(_y), p(_p), q(_q), k(_k), id(-1) {\n        if (!inside(x, y)) return;\n        if (p < 0 || q < 0) return;\n        if (s[x][y] == '#') return;\n        if (s[x][y] == 'S' && k == 2) return;\n        id = 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k;\n    }\n    Node(int _id) : id(_id) {\n        k = _id % 4; _id /= 4;\n        q = _id % 11; _id /= 11;\n        p = _id % 11; _id /= 11;\n        y = _id % 100; _id /= 100;\n        x = _id;\n        // output(x, y, p, q, k, id);\n        assert(id == 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k);\n    }\n    void print() {\n        output(x, y, p, q, k, id);\n    }\n};\n\nvoid dijkstra() {\n    using State = pair<int, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    fill(d, d + MAX_V, inf);\n\n    Node ns(sx, sy, A, A, 0);\n    d[ns.id] = 0;\n    pq.push(State(0, ns.id));\n\n    while (!pq.empty()) {\n        int cost, id;\n        tie(cost, id) = pq.top(); pq.pop();\n        if (d[id] < cost) continue;\n        Node u(id);\n\n        // output(\"---\");\n        // cout << cost << \" \";\n        // u.print();\n\n        int x = u.x;\n        int y = u.y;\n        int p = u.p;\n        int q = u.q;\n        int k = u.k;\n\n        vector<pair<Node, int>> cands; // v, cost(u->v)\n\n        if (k == 0) {\n            cands.emplace_back(Node(x, y - 1, p, q - 1, 3), 1);\n            cands.emplace_back(Node(x, y + 1, p - 1, q, 1), 1);\n            cands.emplace_back(Node(x + 1, y, p, q, 0), 0);\n        }\n        else if (k == 1) {\n            cands.emplace_back(Node(x - 1, y, p, q - 1, 2), 1);\n            cands.emplace_back(Node(x + 1, y, p - 1, q, 0), 1);\n            cands.emplace_back(Node(x, y + 1, p, q, 1), 0);\n        }\n        else if (k == 2) {\n            cands.emplace_back(Node(x, y - 1, p - 1, q, 3), 1);\n            cands.emplace_back(Node(x, y + 1, p, q - 1, 1), 1);\n            cands.emplace_back(Node(x - 1, y, p, q, 2), 0);\n        }\n        else if (k == 3) {\n            cands.emplace_back(Node(x - 1, y, p - 1, q, 2), 1);\n            cands.emplace_back(Node(x + 1, y, p, q - 1, 0), 1);\n            cands.emplace_back(Node(x, y - 1, p, q, 3), 0);\n        }\n\n        for (const auto& p : cands) {\n            Node v;\n            int c;\n            tie(v, c) = p;\n            if (v.id == -1) continue;\n            if (d[v.id] > d[u.id] + c) {\n                d[v.id] = d[u.id] + c;\n                pq.push(State(d[v.id], v.id));\n            }\n        }\n\n        // output(\"---\");\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W >> A;\n    s.resize(H);\n    rep(i, H) {\n        cin >> s[i];\n        rep(j, W) {\n            if (s[i][j] == 'S') {\n                sx = i; sy = j;\n            }\n            if (s[i][j] == 'G') {\n                gx = i; gy = j;\n            }\n        }\n    }\n\n    dijkstra();\n\n    int mi = inf;\n    rep(p, A + 1) {\n        rep(q, A + 1) {\n            rep(k, 4) {\n                Node u(gx, gy, p, q, k);\n                // cout << d[u.id] << \" \";\n                // u.print();\n                if (u.id == -1) continue;\n                mi = min(mi, d[u.id]);\n            }\n        }\n    }\n\n    cout << (mi == inf ? -1 : mi) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,-1));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = -1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      if(dp[s.x][s.y]) continue;\n      dp[s.x][s.y] = true;\n\n      for(int i=0;i<4;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 110;\nconst int pmax = 11;\nbool visit[sz][sz][pmax][pmax][4];\n\nint main(){\n  int N, M, P;\n  cin >> N >> M >> P;\n  vector<string> F(N + 2, string(M + 2, '#'));\n\n\n  queue<int> r_que;\n  queue<int> c_que;\n  queue<int> d_que;\n  queue<int> p_que;\n  queue<int> q_que;\n\n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, -1, 0, 1};\n  int pm[4] = {3, 2, 1, 0};\n  int qm[4] = {1, 0, 3, 2};\n    \n\n  memset(visit, false, sizeof(visit));\n  \n  REP(i, N)REP(j, M){\n    cin >> F[i+1][j+1];\n    if(F[i+1][j+1] == 'S'){\n      r_que.push(i + 1);\n      c_que.push(j + 1);\n      p_que.push(P);\n      q_que.push(P);\n      d_que.push(0);\n      visit[i+1][j+1][P][P][0] = true;\n    }\n  }\n\n  int res = INF;\n  while(!r_que.empty()){\n    int r = r_que.front(); r_que.pop();\n    int c = c_que.front(); c_que.pop();\n    int d = d_que.front(); d_que.pop();\n    int p = p_que.front(); p_que.pop();\n    int q = q_que.front(); q_que.pop();\n    \n    if(F[r][c] == 'G'){\n      res = min(res, 2 * P - p - q);\n      continue;\n    }\n\n    int r2 = r + dr[d];\n    int c2 = c + dc[d];\n\n    \n    if(F[r2][c2] != '#'){\n      if(!visit[r2][c2][p][q][d]){\n        visit[r2][c2][p][q][d] = true;\n        r_que.push(r2);\n        c_que.push(c2);\n        p_que.push(p);\n        q_que.push(q);\n        d_que.push(d);\n      }\n      \n      if(F[r2][c2] == '.' && p > 0){\n        int d2 = pm[d];\n        if(!visit[r2][c2][p-1][q][d2]){\n          visit[r2][c2][p-1][q][d2] = true;\n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p-1);\n          q_que.push(q);\n          d_que.push(d2);\n        }\n      }\n\n      if(F[r2][c2] == '.' && q > 0){\n        int d2 = qm[d];\n        if(!visit[r2][c2][p][q-1][d2]){\n          visit[r2][c2][p][q-2][d2] = true;          \n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p);\n          q_que.push(q-1);\n          d_que.push(d2);\n        }\n      }\n    }\n  }\n  \n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, A;\nchar S[200][200];\nll dp[100][100][4][11][11];\n\nconst ll INF = 1LL << 50;\nconst ll dy[4] = { -1, +0, +1, +0 };\nconst ll dx[4] = { +0, +1, +0, -1 };\n\nstruct state {\n  ll y, x, dir, p, q, dist;\n  bool operator<(const state &s) const {\n    return dist > s.dist;\n  }\n};\n\nint main(void) {\n  cin >> N >> M >> A;\n  REP(i, 0, N) REP(j, 0, M) cin >> S[i][j];\n\n  ll sy, sx, gy, gx;\n  REP(i, 0, N) REP(j, 0, M) {\n    if(S[i][j] == 'S') {\n      sy = i;\n      sx = j;\n    }\n    if(S[i][j] == 'G') {\n      gy = i;\n      gx = j;\n    }\n  }\n\n  REP(y, 0, N) REP(x, 0, M) REP(dir, 0, 4) REP(p, 0, A + 1) REP(q, 0, A + 1) dp[y][x][dir][p][q] = INF;\n\n  priority_queue<state> que;\n  if(sy + 1 < N) que.push((state) { sy + 1, sx, 2, 0, 0, 0 });\n\n  while(!que.empty()) {\n    state s = que.top();\n    que.pop();\n\n    ll y = s.y, x = s.x, dir = s.dir, p = s.p, q = s.q, dist = s.dist;\n\n    if(dp[y][x][dir][p][q] <= dist) continue;\n    dp[y][x][dir][p][q] = dist;\n\n    if(y == gy && x == gx) {\n      cout << dist << endl;\n      return 0;\n    }\n\n    REP(k, -1, 2) {\n      if(y == sy && x == sx && k != 0) continue;\n      if(y == sy && x == sx && dir % 2 == 0) continue;\n      ll ndir = (dir + k + 4) % 4;\n      ll ny = y + dy[ndir];\n      ll nx = x + dx[ndir];\n      ll np = p;\n      ll nq = q;\n      if(dir % 2 == 0) {\n        np += (k == -1 ? 1 : 0);\n        nq += (k == +1 ? 1 : 0);\n      } else {\n        np += (k == +1 ? 1 : 0);\n        nq += (k == -1 ? 1 : 0);\n      }\n      if(0 <= ny && ny < N && 0 <= nx && nx < M && S[ny][nx] != '#' && np <= A && nq <= A) {\n        que.push((state) { ny, nx, ndir, np, nq, np + nq });\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std ;\n\nint dx[] = {1 , 0 , -1 , 0} ;\nint dy[] = {0 , 1 , 0 , -1} ;\nint vis[110][110][11][11] ;\nchar map[111][111] ;\nint n , m , endx , endy , A , T;\ninline bool achi(int x,int y) {\n    if(x>=n || x<0 || y>=m || y < 0) return false ;\n    if(map[x][y] == '#' || map[x][y] == 'S') return false ;\n    return true ;\n}\n\nstruct Node{\n    int x,y,ua,ub,ol ;\n}start ;\n\nvoid in() {\n    for(int i = 0 ; i < n ; i++)\n    scanf(\"%s\",map[i]) ;\n    for(int i = 0 ; i < n ; i++)\n    for(int j = 0 ; j < m ; j++)\n    if(map[i][j] == 'S') start.x = i+1 , start.y = j ;\n    else if(map[i][j] == 'G') endx = i , endy = j ;\n}\n\nqueue<Node> q;\nvoid work() {\n    start.ua = start.ub = 0 ; start.ol = 0 ;\n    if(achi(start.x,start.y)) q.push(start) ;\n    while(!q.empty()) {\n        Node st = q.front() ; q.pop() ;\n        int x = st.x , y = st.y , ua = st.ua , ub = st.ub , ol = st.ol;\n        if(x==endx && y==endy) continue ;\n        for(int i = 0 ; i < 4 ; i++) {\n            int nx = x+dx[i] , ny = y+dy[i] , na=ua , nb=ub , nl=i ;\n            if(!achi(nx,ny)) continue ;\n            if((nl==0 && ol==2)||(nl==2 && ol==0)) continue ;\n            if((nl==1 && ol==3)||(nl==3 && ol==1)) continue ;\n            if(nl == ol) ;\n            else if((nl^1) == ol) na++ ;\n            else nb++ ;\n            if(na <= A && nb <= A && vis[nx][ny][na][nb] != T) {\n                q.push((Node){nx,ny,na,nb,nl}) ;\n                vis[nx][ny][na][nb] = T ;\n            }\n        }\n    }\n    int ans = 0x3f3f3f3f;\n    for(int i = 0 ; i <= A ; i++)\n    for(int j = 0 ; j <= A ; j++)\n    if(vis[endx][endy][i][j] == T) ans = min(ans , i+j) ;\n    if(ans != 0x3f3f3f3f) printf(\"%d\\n\",ans) ;\n    else printf(\"-1\\n\") ;\n}\n\nint main() {\n    //freopen(\"C.in\",\"r\",stdin) ;\n    while(~scanf(\"%d%d%d\",&n,&m,&A)) {\n        T++ ;\n        in() ;\n        work() ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\nchar map[100][101];\n\nstruct Data{\n\tDIR in_dir,out_dir;\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n//row,col???????????????????????????????????¢??°\nbool canPut(Data data[20],int num_data,int row,int col){\n\n\tbool FLG = true;\n\tbool block_FLG;\n\n\tfor(int i = 0; i < num_data; i++){\n\t\tif(data[i].row == row && data[i].col == col){\n\t\t\tFLG = false;\n\t\t\tbreak;\n\t\t}else if(data[i].row == row){\n\n\t\t\tif(col > data[i].col){\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = data[i].col; k <= col; k++){\n\t\t\t\t\tif(map[row][k] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tblock_FLG = true;\n\t\t\t\t\tfor(int a = 0; a < num_data; a++){\n\n\t\t\t\t\t\tif(i != a && data[a].row == row && data[a].col > data[i].col && data[a].col < col && data[a].out_dir == West){\n\t\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(block_FLG == true && data[i].in_dir == East){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = col; k <= data[i].col; k++){\n\t\t\t\t\tif(map[row][k] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tblock_FLG = true;\n\t\t\t\t\tfor(int a = 0; a < num_data; a++){\n\n\t\t\t\t\t\tif(i != a && data[a].row == row && data[a].col < data[i].col && data[a].col > col && data[a].out_dir == East){\n\t\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(block_FLG == true && data[i].in_dir == West){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(data[i].col == col){\n\n\t\t\t//map[row][col]???,map[data[i].row][data[i].col]??????????????????????????????????????????data[i]???????????¨???data[i]???in_dir????????´????????????????????????\n\t\t\tif(row > data[i].row){\n\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = data[i].row; k <= row; k++){\n\t\t\t\t\tif(map[k][col] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tblock_FLG = true;\n\t\t\t\t\tfor(int a = 0; a < num_data; a++){\n\n\t\t\t\t\t\tif(i != a && data[a].col == col && data[a].row > data[i].row && data[a].row < row && data[a].out_dir == North){\n\t\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(block_FLG && data[i].in_dir == South){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = row; k <= data[i].row; k++){\n\t\t\t\t\tif(map[k][col] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tblock_FLG = true;\n\t\t\t\t\tfor(int a = 0; a < num_data; a++){\n\n\t\t\t\t\t\tif(i != a && data[a].col == col && data[a].row < data[i].row && data[a].row > row && data[a].out_dir == South){\n\t\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(block_FLG == true && data[i].in_dir == North){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FLG;\n}\n\nvoid copyData(Info& to,Info from){\n\tfor(int k = 0; k < from.num_data;k++){\n\t\tto.data[k].row = from.data[k].row;\n\t\tto.data[k].col = from.data[k].col;\n\t\tto.data[k].mirror = from.data[k].mirror;\n\t\tto.data[k].in_dir = from.data[k].in_dir;\n\t\tto.data[k].out_dir = from.data[k].out_dir;\n\t}\n\tto.num_data = from.num_data;\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tif(i < H-1)minTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(rangeCheck(first.row,first.col) == false || map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tint xx = x + dx[DOWN];\n\t\tint yy = y + dy[DOWN];\n\n\t\tif (xx < 0 || W <= xx) return -1;\n\t\tif (yy < 0 || H <= yy) return -1;\n\t\tif (S[yy][xx] == '#') return -1;\n\n\t\tdone[yy][xx][DOWN][0][0] = true;\n\t\tque.push(make_pair(make_pair(yy * 1000 + xx, DOWN * 10000), 0));\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G') return c;\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\t\t\tif (S[yy][xx] == 'S') continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tswitch (dir)\n\t\t\t\t{\n\t\t\t\tcase UP:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RIGHT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOWN:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LEFT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (A < aa) continue;\n\t\t\t\tif (A < bb) continue;\n\t\t\t}\n\t\t\t\n\n\t\t\tif (done[yy][xx][dd][aa][bb]) continue;\n\n\t\t\tdone[y][x][dir][a][b] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n//00:00\n//00:35 WA\nint h,w,r;\nint gone[105][105][5][15][15]={};\nchar dat[105][105];\n\nstruct qd{\n\tint y,x,d;\n\tint a,b;\n\tbool operator<(qd v)const{\n\t\treturn (a+b)<(v.a+v.b);\n\t}\n\tbool operator>(qd v)const{\n\t\treturn (v<(*this));\n\t}\n};\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\n\nint sy,sx;\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&r);\n\treg(y,1,h)scanf(\"%s\",dat[y]+1);\n\treg(y,0,h+1)dat[y][0]=dat[y][w+1]='#';\n\treg(x,0,w+1)dat[0][x]=dat[h+1][x]='#';\n\t\n\treg(y,1,h)reg(x,1,w){\n\t\tif(dat[y][x]=='S'){\n\t\t\tsy=y; sx=x;\n\t\t}\n\t}\n\t\n\tpriority_queue<qd> que;\n\t\n\tqd da;\n\tda.d=1; da.x=sx; da.y=sy+1; da.a=da.b=r;\n\tque.push(da);\n\twhile(!que.empty()){\n\t\tqd da = que.top();\n\t\tque.pop();\n\t\tint x=da.x,y=da.y,d=da.d,a=da.a,b=da.b;\n\t\t//printf(\"%d %d %d | %d %d\\n\",y,x,d,a,b);\n\t\tif(gone[y][x][d][a][b])continue;\n\t\tgone[y][x][d][a][b] = 1;\n\t\tif(dat[y][x]=='G'){\n\t\t\tprintf(\"%d\\n\",r+r-da.a-da.b);\n\t\t\treturn 0;\n\t\t}\n\t\treg(i,-1,1){\n\t\t\tint td=(d+i+4)%4;\n\t\t\tint tx=x+dx[td],ty=y+dy[td];\n\t\t\t//printf(\"%d %d %d\\n\",ty,tx,td);\n\t\t\tif(dat[ty][tx]=='#')continue;\n\t\t\tif(dat[ty][tx]=='S')continue;\t\n\t\t\tif(i!=0 && dat[y][x]=='S')continue;\t\n\t\t\tqd db=da;\n\t\t\tdb.x=tx; db.y=ty; db.d=td;\n\t\t\tif(i!=0){\n\t\t\t\tif((td+(i>0?1:0))%2==0)db.a--;\n\t\t\t\telse db.b--;\n\t\t\t}\n\t\t\tif(db.a<0 ||db.b<0)continue;\n\t\t\tque.push(db);\n\t\t}\n\t}\n\t\n\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 101;\nconst int MAXW = 101;\nconst int MAXA = 11;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int P[] = {1,0,3,2};\nconst int Q[] = {3,2,1,0};\nint H, W, A;\nchar G[MAXH][MAXW];\nint vis[MAXH][MAXW][4][MAXA][MAXA];\n\nstruct State {\n  int i, j, d, a, b;\n};\n\nint dijkstra(int si, int sj, int gi, int gj) {\n  queue<State> que;\n  memset(vis, 0, sizeof(vis));\n  vis[si][sj][1][A][A] = true;\n  que.push((State){si, sj, 1,A, A});\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    do {\n      State t = s;\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#') break;\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(t.i == si && t.j == sj) break;\n      t.d = P[t.d];\n      if(--t.a < 0) break;\n      /*\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#') break;\n      */\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(t.i == si && t.j == sj) break;\n      t.d = Q[t.d]; \n      if(--t.b < 0) break;\n      /*\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#') break;\n      */\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n  }\n  int res = INF;\n  for(int a = 0; a <= A; ++a) {\n    for(int b = 0; b <= A; ++b) {\n      for(int k = 0; k < 4; ++k) {\n        if(vis[gi][gj][k][a][b]) {\n          res = min(res, A*2 - (a+b));\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nint main() {\n  cin >> H >> W >> A;\n  int si, sj, gi, gj;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n      if(G[i][j] == 'S') {\n        si = i; sj = j;\n      }\n      if(G[i][j] == 'G') {\n        gi = i; gj = j;\n      }\n    }\n  }\n  cout << dijkstra(si, sj, gi, gj) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(p+q>ans) return;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h) return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[ny][nx][np][nq][i] = 1;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\nchar map[100][101];\n\nstruct Data{\n\tDIR in_dir,out_dir;\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[21];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool canPut(Data data[21],int num_data,int row,int col){\n\n\tif(num_data == 1)return true;\n\n\tint start_row,start_col,next_row,next_col;\n\n\tfor(int i = 1; i < num_data; i++){\n\n\t\tstart_row = data[i-1].row;\n\t\tstart_col = data[i-1].col;\n\t\tnext_row = data[i].row;\n\t\tnext_col = data[i].col;\n\n\t\tswitch(data[i-1].out_dir){\n\t\tcase North:\n\t\t\tfor(int i = start_row; i >= next_row; i--){\n\t\t\t\tif(row == i && col == start_col){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase East:\n\t\t\tfor(int i = start_col; i <= next_col; i++){\n\t\t\t\tif(row == start_row && col == i){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase West:\n\t\t\tfor(int i = start_col; i >= next_col; i--){\n\t\t\t\tif(row == start_row && col == i){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase South:\n\t\t\tfor(int i = start_row; i <= next_row; i++){\n\t\t\t\tif(row == i && col == start_col){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn true;\n}\n\nvoid copyData(Info& to,Info from){\n\tfor(int k = 0; k < from.num_data;k++){\n\t\tto.data[k].row = from.data[k].row;\n\t\tto.data[k].col = from.data[k].col;\n\t\tto.data[k].mirror = from.data[k].mirror;\n\t\tto.data[k].in_dir = from.data[k].in_dir;\n\t\tto.data[k].out_dir = from.data[k].out_dir;\n\t}\n\tto.num_data = from.num_data;\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tif(i < H-1)minTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(rangeCheck(first.row,first.col) == false || map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\tfirst.data[0].row = first.row-1;\n\tfirst.data[0].col = first.col;\n\tfirst.data[0].out_dir = South;\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 1;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 1; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && p){\n    //G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    //G[x][y] = '.';\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && q){\n    //G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    //G[x][y] = '.';\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\n\nstruct Data{\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\tchar map[H][W+1];\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tminTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\t//?\\?\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n#define INF 100\nusing namespace std;\nstruct data{\n\tint x,y,p,q,dir;\n\tdata(){}\n\tdata(int yy,int xx,int dd,int pp,int qq){\n\t\tx=xx;\n\t\ty=yy;\n\t\tp=pp;\n\t\tq=qq;\n\t\tdir=dd;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn q>d.q;\n\t}\n};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint n,m,a;\nint fie[101][101];\nint dp[101][101][4][11];\nint sx,sy,gx,gy;\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tdp[i][j][k][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(sy,sx,1,0,0));\n\tdp[sy][sx][1][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.y][q.x][q.dir][q.p]<q.q)continue;\n\t\tif(0<=q.x+dx[q.dir] && q.x+dx[q.dir]<m && 0<=q.y+dy[q.dir] && q.y+dy[q.dir]<n){\n\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]!=-1 && dp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]>q.q){\n\t\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]==1 && dir==2)continue;\n\t\t\t\tdp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]=q.q;\n\t\t\t\tque.push(data(q.y+dy[q.dir],q.x+dx[q.dir],q.dir,q.p,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.p<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=3;\n\t\t\tif(q.dir==1)ndir=2;\n\t\t\tif(q.dir==2)ndir=1;\n\t\t\tif(q.dir==3)ndir=0;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p+1]>q.q){\n\t\t\t\tdp[q.y][q.x][ndir][q.p+1]=q.q;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p+1,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.q<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=1;\n\t\t\tif(q.dir==1)ndir=0;\n\t\t\tif(q.dir==2)ndir=3;\n\t\t\tif(q.dir==3)ndir=2;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p]>q.q+1){\n\t\t\t\tdp[q.y][q.x][ndir][q.p]=q.q+1;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p,q.q+1));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tres=min(res,dp[gy][gx][j][i]+i);\n\t\t}\n\t}\n\treturn res!=INF?res:-1;\n}\n\nint main(void){\n\tscanf(\"%d %d %d %d\",&n,&m,&a);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]=='S')sx=j,sy=i,fie[i][j]=1;\n\t\t\tif(str[j]=='G')gx=j,gy=i,fie[i][j]=2;\n\t\t\tif(str[j]=='#')fie[i][j]=-1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dijk());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct State {\n  // d:??\\??£???????????????\n  int y, x, d, p, q, cost;\n  State(){}\n  State(int y, int x, int d, int p, int q, int cost):\n    y(y), x(x), d(d), p(p), q(q), cost(cost){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint N, M, A;\nchar mas[101][101];\nint sy, sx, gy, gx;\nint mincost[4][11][11][101][101];\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\n\nint dijkstra() {\n  rep(i, 4) rep(j, 11) rep(k, 11) {\n    rep(y, 101) rep(x, 101) mincost[i][j][k][y][x] = inf;\n  }\n  priority_queue<State> que;\n  que.push(State(sy, sx, 0, A, A, 0));\n  mincost[0][A][A][sy][sx] = 0;\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    //cout<<s.y<<\" \"<<s.x<<\" \"<<s.d<<\" \"<<s.cost<<endl;\n    if(s.y == gy && s.x == gx) return s.cost;\n    if(mincost[s.d][s.p][s.q][s.y][s.x] < s.cost) continue;\n    if(s.y == sy && s.x == sx) {\n      int ny = s.y+dy[(s.d+2)%4], nx = s.x+dx[(s.d+2)%4];\n      if(in(ny, nx) && mas[ny][nx] != '#') {\n\tif(s.cost < mincost[s.d][s.p][s.q][ny][nx]) {\n\t  que.push(State(ny, nx, s.d, s.p, s.q, s.cost));\n\t  mincost[s.d][s.p][s.q][ny][nx] = s.cost;\n\t}\n      }\n      continue;\n    }\n    rep(i, 4) {\n      if(s.d == i) continue;\n      int np = s.p, nq = s.q, ncost = s.cost;\n      if(s.d == 0) {\n\tif(i == 1) nq--, ncost++;\n\telse if(i == 3) np--, ncost++;\n      } else if(s.d == 1) {\n\tif(i == 0) nq--, ncost++;\n\telse if(i == 2) np--, ncost++;\n      } else if(s.d == 2) {\n\tif(i == 1) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      } else if(s.d == 3) {\n\tif(i == 0) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      }\n      if(np < 0 || nq < 0) continue;\n      int ny = s.y+dy[i], nx = s.x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#') continue;\n      if(ncost < mincost[(s.d+2)%4][np][nq][ny][nx]) {\n\t//cout<<s.y<<\" \"<<s.x<<\" \"<<s.d<<\" \"<<ny<<\" \"<<nx<<\" \"<<(i+2)%4<<\" \"<<ncost<<endl;\n\tque.push(State(ny, nx, (s.d+2)%4, np, nq, ncost));\n\tmincost[(s.d+2)%4][np][nq][ny][nx] = ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> A;\n  rep(i, N) rep(j, M) {\n    cin >> mas[i][j];\n    if(mas[i][j] == 'S') sy = i, sx = j;\n    else if(mas[i][j] == 'G') gy = i, gx = j;\n  }\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  int sz = 0;\n  Graph G;\n  map<int,int> id;\n  int sid = idx(sx,sy+1,2,0,0);\n  queue<tuple<int,int,int,int,int>> q;\n  q.push(make_tuple(0,0,sx,sy+1,2));\n  id[sid] = sz++;\n  G.PB(vector<Edge>());\n  \n  while(!q.empty()){\n\tint a1, a2, x, y, d;\n\ttie(a1,a2,x,y,d) = q.front(); q.pop();\n\n\tint fr = idx(x,y,d,a1,a2);\n\tif(vs[y][x] != '.') continue;\n\n\tif(a1 < A){\n\t  int to = idx(x,y,3-d,a1+1,a2);\n\t  if(!id.count(to)){\n\t\tid[to] = sz++;\n\t\tG.PB(vector<Edge>());\n\t\tq.push(make_tuple(a1+1,a2,x,y,3-d));\n\t  }\n\t  G[id[fr]].PB(Edge(id[to], 1));\n\t}\n\tif(a2 < A){\n\t  int to = idx(x,y,d-(d%2*2-1),a1,a2+1);\n\t  if(!id.count(to)){\n\t\tid[to] = sz++;\n\t\tG.PB(vector<Edge>());\n\t\tq.push(make_tuple(a1,a2+1,x,y,d-(d%2*2-1)));\n\t  }\n\t  G[id[fr]].PB(Edge(id[to], 1));\n\t}\n\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint to = idx(tx,ty,d,a1,a2);\n\tif(!id.count(to)){\n\t  id[to] = sz++;\n\t  G.PB(vector<Edge>());\n\t  q.push(make_tuple(a1,a2,tx,ty,d));\n\t}\n\tG[id[fr]].PB(Edge(id[to], 0));\n  }\n\n  VI dist(sz);\n  Dijkstra(G, dist, id[sid]);\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tif(id.count(tid))\n\t  ans = min(ans, dist[id[tid]]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvector<int> v[100*100*11*11*4];\nbool d[100*100*11*11*4];\nstring vec[101];\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int dir){\n    if(i<0 || i>=n || j<0 || j>=m) return -1;\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+dir;\n  };\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i+1,j,0,0,0);\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  auto ok = [&](int i, int j, bool bs=true){\n    if(i<0 || i>=n || j<0 || j>=m) return false;\n    return (vec[i][j]=='.' || vec[i][j]=='G' || (bs && vec[i][j]=='S') );\n  };\n\n  rep(i,n)rep(j,m-1){\n    if( ok(i,j) && ok(i,j+1) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( ok(i,j,false) && ok(i+1,j,false) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        if(ok(i,j-1)) v[p].pb(f(i,j-1,x+1,y,3));\n        if(ok(i-1,j)) v[p+1].pb(f(i-1,j,x+1,y,2));\n        if(ok(i,j+1)) v[p+2].pb(f(i,j+1,x+1,y,1));\n        if(ok(i+1,j)) v[p+3].pb(f(i+1,j,x+1,y,0));\n      }\n      if(y<a){\n        if(ok(i,j+1)) v[p].pb(f(i,j+1,x,y+1,1));\n        if(ok(i+1,j)) v[p+1].pb(f(i+1,j,x,y+1,0));\n        if(ok(i,j-1)) v[p+2].pb(f(i,j-1,x,y+1,3));\n        if(ok(i-1,j)) v[p+3].pb(f(i-1,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  fill(d, d+(sizeof(d)), false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(to==-1) continue;\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n#define INF 100\nusing namespace std;\nstruct data{\n\tint x,y,p,q,dir;\n\tdata(){}\n\tdata(int yy,int xx,int dd,int pp,int qq){\n\t\tx=xx;\n\t\ty=yy;\n\t\tp=pp;\n\t\tq=qq;\n\t\tdir=dd;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn q>d.q;\n\t}\n};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint n,m,a;\nint fie[101][101];\nint dp[101][101][4][11];\nint sx,sy,gx,gy;\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tdp[i][j][k][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(sy,sx,1,0,0));\n\tdp[sy][sx][1][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.y][q.x][q.dir][q.p]<q.q)continue;\n\t\tif(0<=q.x+dx[q.dir] && q.x+dx[q.dir]<m && 0<=q.y+dy[q.dir] && q.y+dy[q.dir]<n){\n\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]!=-1 && dp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]>q.q){\n\t\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]==1 && q.dir==2)continue;\n\t\t\t\tdp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]=q.q;\n\t\t\t\tque.push(data(q.y+dy[q.dir],q.x+dx[q.dir],q.dir,q.p,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.p<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=3;\n\t\t\tif(q.dir==1)ndir=2;\n\t\t\tif(q.dir==2)ndir=1;\n\t\t\tif(q.dir==3)ndir=0;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p+1]>q.q){\n\t\t\t\tdp[q.y][q.x][ndir][q.p+1]=q.q;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p+1,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.q<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=1;\n\t\t\tif(q.dir==1)ndir=0;\n\t\t\tif(q.dir==2)ndir=3;\n\t\t\tif(q.dir==3)ndir=2;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p]>q.q+1){\n\t\t\t\tdp[q.y][q.x][ndir][q.p]=q.q+1;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p,q.q+1));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tres=min(res,dp[gy][gx][j][i]+i);\n\t\t}\n\t}\n\treturn res!=INF?res:-1;\n}\n\nint main(void){\n\tscanf(\"%d %d %d %d\",&n,&m,&a);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]=='S')sx=j,sy=i,fie[i][j]=1;\n\t\t\tif(str[j]=='G')gx=j,gy=i,fie[i][j]=2;\n\t\t\tif(str[j]=='#')fie[i][j]=-1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dijk());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[105];\nPII dp[105][105][4];\nsigned main(void)\n{\n  int h, w, a;\n  cin >> h >> w >> a;\n  REP(i, h) cin >> s[i];\n  int sx, sy, gx, gy;\n  REP(i, h) REP(j, w) {\n    if(s[i][j] == 'S') sx = j, sy = i;\n    else if(s[i][j] == 'G') gx = j, gy = i;\n  }\n\n  REP(i, h) REP(j, w) REP(k, 4) dp[i][j][k] = {INF, INF};\n\n  FOR(i, sy, h) {\n    if(s[i][sx] == '#') break;\n    dp[i][sx][0] = {0, 0};\n  }\n\n  REP(i, 2*a) {\n    REP(y, h) REP(x, w) REP(dir, 4) {\n      //????????????\n      if(dp[y][x][dir].first + dp[y][x][dir].second == i) {\n        if(dir == 0) {\n          //???????????????????????? typeQ\n          for(int j=x; j>=0; --j) {\n            if(s[y][j] == '#' || s[y][j] == 'S') break;\n            if(dp[y][j][1] == PII{INF, INF}) {\n              dp[y][j][1] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n          //???????????????????????? typeP\n          for(int j=x; j<w; ++j) {\n            if(s[y][j] == '#' || s[y][j] == 'S') break;\n            if(dp[y][j][3] == PII{INF, INF}) {\n              dp[y][j][3] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n        } else if(dir == 1) {\n          //???????????????????????? typeP\n          for(int j=y; j>=0; --j) {\n            if(s[j][x] == '#' || s[j][x] == 'S') break;\n            if(dp[j][x][2] == PII{INF, INF}) {\n              dp[j][x][2] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n          //???????????????????????? typeQ\n          for(int j=y; j<h; ++j) {\n            if(s[j][x] == '#' || s[j][x] == 'S') break;\n            if(dp[j][x][0] == PII{INF, INF}) {\n              dp[j][x][0] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n        } else if(dir == 2) {\n          //???????????????????????? typeP\n          for(int j=x; j>=0; --j) {\n            if(s[y][j] == '#' || s[y][j] == 'S') break;\n            if(dp[j][x][1] == PII{INF, INF}) {\n              dp[y][j][1] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n          //???????????????????????? typeQ\n          for(int j=x; j<w; ++j) {\n            if(s[y][j] == '#' || s[y][j] == 'S') break;\n            if(dp[j][x][3] == PII{INF, INF}) {\n              dp[y][j][3] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n        } else if(dir == 3) {\n          //???????????????????????? typeQ\n          for(int j=y; j>=0; --j) {\n            if(s[j][x] == '#' || s[j][x] == 'S') break;\n            if(dp[j][x][2] == PII{INF, INF}) {\n              dp[j][x][2] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n          //???????????????????????? typeP\n          for(int j=y; j<h; ++j) {\n            if(s[j][x] == '#' || s[j][x] == 'S') break;\n            if(dp[j][x][0] == PII{INF, INF}) {\n              dp[j][x][0] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /*REP(k, 4) {\n    REP(i, h) {\n      REP(j, w) {\n        cout << dp[i][j][k].first << \",\" << dp[i][j][k].second << \" \";\n      }\n      cout << endl;\n    }\n  }*/\n\n  int ret = INF;\n  REP(i, 4) {\n    if(dp[gy][gx][i].first <= a && dp[gy][gx][i].second <= a) {\n      ret = min(ret, dp[gy][gx][i].first + dp[gy][gx][i].second);\n    }\n  }\n\n  if(ret == INF) cout << -1 << endl;\n  else cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define rep(i,N) for(int i = 0 ; (i) < (int)(N) ; i++)\n\nstruct NODE{\n\tint x,y,dir;\n\tint P,Q;\n\tNODE(int x,int y,int dir,int P,int Q) : x(x) , y(y) , dir(dir) , P(P) , Q(Q) {}\n};\nchar c[110][110];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint memo[110][110][4][11][11];\nint main(){\n\tmemset(memo,-1,sizeof(memo));\n\tint H,W,A;\n\tcin >> H >> W >> A;\n\tint sx,sy,gx,gy;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] == 'S' ){\n\t\t\t\tsx = j , sy = i;\n\t\t\t}\n\t\t\tif( c[i][j] == 'G' ){\n\t\t\t\tgx = j , gy = i;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<NODE> Q;\n\t\n\tQ.push(NODE(sx,sy+1,0,A,A));\n\tmemo[sx][sy+1][0][A][A] = 0;\n\tint answer = 1e9;\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( q.x < 0 || q.x >= W || q.y >= H || q.y < 0 || c[q.y][q.x] == '#') continue;\n\t\tif( q.x == gx && q.y == gy ){\n\t\t\tanswer = min( answer , 2*A - q.P - q.Q );\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint pp = 0 , qq = 0;\n\t\t\tif( (q.dir+2)%4 == i ) continue;\n\t\t\tif( q.dir == 0 && i == 1 || q.dir == 1 && i == 0 || q.dir == 2 && i == 3 || q.dir == 3 && i == 2 ) pp = 1;\n\t\t\tif( q.dir == 0 && i == 3 || q.dir == 3 && i == 0 || q.dir == 2 && i == 1 || q.dir == 1 && i == 2 ) qq = 1;\n\t\t\tint nx = q.x + dx[i];\n\t\t\tint ny = q.y + dy[i];\n\t\t\tif( nx < 0 || nx >= W || ny >= H || ny < 0 || q.P-pp < 0 || q.Q-qq < 0 || c[ny][nx] == '#' || ~memo[nx][ny][i][q.P-pp][q.Q-qq] ) continue;\n\t\t\tmemo[nx][ny][i][q.P-pp][q.Q-qq] = 0;\n\t\t\t//cout << nx << \" \" << ny << \" \" << i << \" \" << q.P-pp << \" \" << q.Q-qq << endl;\n\t\t\tQ.push(NODE(nx,ny,i,q.P-pp,q.Q-qq));\n\t\t}\n\t\t\n\t}\n\t\n\tif( answer > 1e8 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << answer << endl;\n\t}\n\t\n};"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nDef d[110][110][11][4];\nclass DIJ{\n\tpublic:\n\tDef n,m,A;\n\tvs in;\n\tDIJ(Def size,Def w,vs fi,Def q){\n\t\tn=size;\n\t\tin=fi;\n\t\tm=w;\n\t\tA=q;\n\t}\n\tvoid dij(){\n\t\trep(i,110)rep(j,110)rep(l,11)rep(q,4)\n\t\t\td[i][j][l][q]=inf;\n\t\tint gx,gy;\n\t\tpriority_queue<tp>q;\n\t\trep(i,in.size())rep(j,in[0].size())\n\t\t\tif(in[i][j]=='G')gx=i,gy=j;\n\t\t\telse if(in[i][j]=='S'){\n\t\t\t\tif(i+1<n&&in[i+1][j]!='#'){\n\t\t\t\t\td[i+1][j][0][1]=0;\n\t\t\t\t\tq.push(tp(0,i+1,j,0,1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,a,to;\n\t\t\ttie(cost,x,y,a,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][a][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tint na=a,nb=cost;\n\t\t\t\tint nto=k;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tif((to+2)%4==nto)continue;\n\t\t\t\tif(nto!=to){\n\t\t\t\t\tif(to%2){\n\t\t\t\t\t\tif((to+1)%4==nto)na++;\n\t\t\t\t\t\telse nb++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((to+1)%4==nto)nb++;\n\t\t\t\t\t\telse na++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(na>A||nb>A)continue;\n\t\t\t\tif(nb<d[nx][ny][na][nto]){\n\t\t\t\t\td[nx][ny][na][nto]=nb;\n\t\t\t\t\tq.push(tp(-nb,nx,ny,na,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,11)rep(j,4)if(d[gx][gy][i][j]!=inf){\n\t\t\tcmin(out,i+d[gx][gy][i][j]);\n\t\t}\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(n,m,in,k);\n\tdij.dij();\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d=2,h,w,n,sx,sy,gx,gy,ans=-1;\nstring s[111];\nstruct T{\n    int y,x,d,l,r,cost;\n    T(int a,int b,int c,int f,int e,int w){y=a,x=b,d=c,l=f,r=e,cost=w;}\n};\nsigned main(){\n    cin>>h>>w>>n;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n        if(s[i][j]=='S')sy=i,sx=j;\n        if(s[i][j]=='G')gy=i,gx=j;\n    }\n    deque<T>q;\n    q.push_back(T(sy,sx,2,0,0,0));\n    while(!q.empty()){\n        T a=q.front();q.pop_front();\n        d=a.d;\n        if(s[a.y][a.x]=='G'){ans=a.cost;break;}\n        if(d==0&&s[a.y][a.x]=='S')continue;\n        int y=a.y+dy[d];\n        int x=a.x+dx[d];\n        if(y<0||x<0||y>=h||x>=w)continue;\n        if(s[y][x]=='#')continue;\n        if(1){\n            q.push_front(T(y,x,d,a.l,a.r,a.cost));\n        }\n        if(a.l<n){\n            q.push_back(T(y,x,3-d,a.l+1,a.r,a.cost+1));\n        }\n        if(a.r<n){\n            q.push_back(T(y,x,d^1,a.l,a.r+1,a.cost+1));\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Data{\n  int x,y,dir,P,Q,cost,px,py;\n  Data(int x=IINF,int y=IINF,int dir=IINF,int P=IINF,int Q=IINF,int cost=IINF,int px=IINF,int py=IINF):x(x),y(y),dir(dir),P(P),Q(Q),cost(cost),px(px),py(py){}\n  bool operator < (const Data& a)const{\n    return P+Q < a.P+a.Q;\n  }\n};\n\nint H,W,A,sp_x,sp_y;\nchar field[101][101];\nint mincost[101][101][11][11][4];\nint dx[] = {1,0,-1,0}; // 右、下、左、上\nint dy[] = {0,1,0,-1};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline int getType(int c_dir,int n_dir){\n  if( c_dir == 0 ){\n    if( n_dir == 3 ) return 0; // P -> 0, Q -> 1\n    if( n_dir == 1 ) return 1;\n  } else if( c_dir == 1 ){\n    if( n_dir == 2 ) return 0;\n    if( n_dir == 0 ) return 1;\n  } else if( c_dir == 2 ){\n    if( n_dir == 1 ) return 0;\n    if( n_dir == 3 ) return 1;\n  } else{\n    if( n_dir == 0 ) return 0;\n    if( n_dir == 2 ) return 1;\n  }\n  return -1;\n}\n\nint main(){\n  cin >> H >> W >> A;\n  rep(i,H)rep(j,W){\n    cin >> field[i][j];\n    if( field[i][j] == 'S' ) sp_x = j, sp_y = i;\n  }\n\n  rep(i,H)rep(j,W)rep(k,A+1)rep(l,A+1)rep(m,4)mincost[i][j][k][l][m] = IINF;\n  priority_queue<Data> Q;\n  if( isValid(sp_x+dx[1],sp_y+dy[1]) && field[sp_y+dy[1]][sp_x+dx[1]] != '#' ){\n    Q.push(Data(sp_x+dx[1],sp_y+dy[1],3,A,A,1,sp_x,sp_y));\n    mincost[sp_y][sp_x][A][A][3] = 1;\n  }\n  while(!Q.empty()){\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( field[y][x] == 'G' ){\n      cout << 2*A-(data.P+data.Q) << endl;\n      return 0;\n    }\n    rep(i,4){\n      if( i == data.dir ) continue;\n      int nx = x + dx[i], ny = y + dy[i];\n      if( field[ny][nx] == 'S' && i == 3 ) continue;\n      if(!isValid(nx,ny))continue;\n      if(field[ny][nx] == '#')continue;\n      int next_P = data.P, next_Q = data.Q;\n      int type = getType(data.dir,i);\n      if( type == 0 ) next_P--;\n      if( type == 1 ) next_Q--;\n      if( type != -1 && field[y][x] == 'S' ) continue;\n      if( next_P < 0 || next_Q < 0) continue;\n      if(mincost[ny][nx][next_P][next_Q][i] > data.cost+1){\n\tmincost[ny][nx][next_P][next_Q][i] = data.cost+1;\n\tQ.push(Data(nx,ny,(i+2)%4,next_P,next_Q,data.cost+1,x,y));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef tuple< int, int, int, int, int, int > Pi;\nconst int vy[] = {1, 0, -1, 0}, vx[] = {0, -1, 0, 1};\n\nint v[100][100][11][11][4];\n\nint main()\n{\n  int N, M, A;\n  string S[100];\n\n  cin >> N >> M >> A;\n  for(int i = 0; i < N; i++) cin >> S[i];\n\n\n  int sy, sx;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < M; j++) {\n      if(S[i][j] == 'S') sy = i, sx = j;\n    }\n  }\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, sy, sx, A, A, 0);\n  fill_n(****v, 100 * 100 * 11 * 11 * 4, INF);\n  v[sy][sx][A][A][0] = 0;\n\n  auto isover = [&](int y, int x) -> bool\n  {\n    return (y < 0 || y >= N || x < 0 || x >= M || S[y][x] == '#');\n  };\n\n  while(!que.empty()) {\n    int y, x, latte, malta, dir, cost;\n    tie(cost, y, x, latte, malta, dir) = que.top();\n    que.pop();\n    if(S[y][x] == 'G') {\n      cout << cost << endl;\n      return (0);\n    }\n    if(v[y][x][latte][malta][dir] > cost) continue;\n    for(int i = -1; i <= 1; i++) {\n      int beet = (dir + i + 4) % 4;\n      int ll = latte, rr = malta;\n      int ny = y + vy[beet], nx = x + vx[beet];\n      if(isover(ny, nx)) continue;\n      if(S[y][x] == 'S' && i != 0) continue;\n      if(S[ny][nx] == 'S' && beet == 2) continue;\n      if(i != 0) {\n        if((beet + (i == 1)) % 2 == 1) --ll;\n        else --rr;\n      }\n      if(ll >= 0 && rr >= 0 && cost + (i != 0) < v[ny][nx][ll][rr][beet]) {\n        v[ny][nx][ll][rr][beet] = cost + (i != 0);\n        que.emplace(cost + (i != 0), ny, nx, ll, rr, beet);\n      }\n    }\n  }\n  cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[100];\nbool vis[100][100][4][10][10];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.')\n      Q.push(state(cx,cy,~di&3,p-1,q));\n    \n    if(q && in[cx][cy]=='.')\n      Q.push(state(cx,cy,di^1,p,q-1));\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nclass State\n{\npublic:\n\tint x,y,d,p,q,c;\n\tState(int x, int y, int d, int p, int q, int c)\n\t\t:x(x),y(y),d(d),p(p),q(q),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint N,M,A;\nbool memo[100][100][4][15][15];\nstring field[100];\n\nbool invaild(int x, int y)\n{\n\tif(x<0||y<0||x>=M||y>=N) return true;\n\tif(field[y][x] == '#') return true;\n\t\n\treturn false;\n}\n\nbool newState(State& s)\n{\n\treturn !memo[s.x][s.y][s.d][s.p][s.q];\n}\n\nState straight(State s)\n{\n\t\n\tint tx = s.x + dx[s.d];\n\tint ty = s.y + dy[s.d];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,s.d,s.p,s.q,s.c);\n}\n\nState useP(State s)\n{\n\tif(s.p == 0) return s;\n\n\tint nd = (s.d+1)%2 + (s.d > 1? 2: 0);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p-1,s.q,s.c+1);\n}\n\nint refQ(int d)\n{\n\tif(d==0) return 3;\n\tif(d==3) return 0;\n\tif(d==1) return 2;\n\n\treturn 1;\n}\n\nState useQ(State s)\n{\n\tif(s.q == 0) return s;\n\n\tint nd = refQ(s.d);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p,s.q-1,s.c+1);\n}\n\n\n\nint solve()\n{\n\tmemset(memo, 0, sizeof(memo));\n\n\tint sx,sy;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<M; j++) {\n\t\tif(field[i][j]=='S') {\n\t\t\tsx = j;\n\t\t\tsy = i;\n\t\t}\n\t}\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,A,A,0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(!newState(s)) continue;\n\t\tmemo[s.x][s.y][s.d][s.p][s.q] = true;\n\n\t\tif(field[s.y][s.x] == 'G') return s.c;\n\n\t\tState ns = straight(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useP(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useQ(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\t\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\t\tcout << solve() << endl;\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\nint H, W, A;\nvector<string> s(H);\nint sx, sy, gx, gy;\nconst int MAX_V = 4*11*11*100*100;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nstruct Node {\n    int x, y, p, q, k, id;\n    Node(){}\n    Node(int _x, int _y, int _p, int _q, int _k) : x(_x), y(_y), p(_p), q(_q), k(_k), id(-1) {\n        if (!inside(x, y)) return;\n        if (p < 0 || q < 0) return;\n        if (s[x][y] == '#') return;\n        if (s[x][y] == 'S' && k == 2) return;\n        id = 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k;\n    }\n    Node(int _id) : id(_id) {\n        k = _id % 4; _id /= 4;\n        q = _id % 11; _id /= 11;\n        p = _id % 11; _id /= 11;\n        y = _id % 100; _id /= 100;\n        x = _id;\n        // output(x, y, p, q, k, id);\n        assert(id == 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k);\n    }\n    void print() {\n        output(x, y, p, q, k, id);\n    }\n};\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\n// directed\nvoid addEdge(Node u, Node v, int c) {\n    if (u.id == -1) return;\n    if (v.id == -1) return;\n    G[u.id].emplace_back(v.id, c);\n    // u.print();\n    // v.print();\n    // output(c);\n}\nvoid dijkstra() {\n    using State = pair<int, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    fill(d, d + MAX_V, inf);\n\n    Node ns(sx, sy, A, A, 0);\n    d[ns.id] = 0;\n    pq.push(State(0, ns.id));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n\n        int cost = p.first;\n        int id = p.second;\n        Node u(id);\n\n        // output(\"---\");\n        // cout << cost << \" \";\n        // u.print();\n\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            //\n            // Node x(e.to);\n            // cout << e.cost << \" \";\n            // x.print();\n\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(State(d[e.to], e.to));\n            }\n        }\n\n        // output(\"---\");\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W >> A;\n    s.resize(H);\n    rep(i, H) {\n        cin >> s[i];\n        rep(j, W) {\n            if (s[i][j] == 'S') {\n                sx = i; sy = j;\n            }\n            if (s[i][j] == 'G') {\n                gx = i; gy = j;\n            }\n        }\n    }\n\n    rep(x, H) {\n        rep(y, W) {\n            if (s[x][y] == '#') continue;\n            rep(p, A + 1) {\n                rep(q, A + 1) {\n                    rep(k, 4) {\n                        Node u(x, y, p, q, k);\n                        // u.print();\n                        if (k == 0) {\n                            addEdge(u, Node(x, y - 1, p, q - 1, 3), 1);\n                            addEdge(u, Node(x, y + 1, p - 1, q, 1), 1);\n                            addEdge(u, Node(x + 1, y, p, q, 0), 0);\n                        }\n                        else if (k == 1) {\n                            addEdge(u, Node(x - 1, y, p, q - 1, 2), 1);\n                            addEdge(u, Node(x + 1, y, p - 1, q, 0), 1);\n                            addEdge(u, Node(x, y + 1, p, q, 1), 0);\n                        }\n                        else if (k == 2) {\n                            addEdge(u, Node(x, y - 1, p - 1, q, 3), 1);\n                            addEdge(u, Node(x, y + 1, p, q - 1, 1), 1);\n                            addEdge(u, Node(x - 1, y, p, q, 2), 0);\n                        }\n                        else if (k == 3) {\n                            addEdge(u, Node(x - 1, y, p - 1, q, 2), 1);\n                            addEdge(u, Node(x + 1, y, p, q - 1, 0), 1);\n                            addEdge(u, Node(x, y - 1, p, q, 3), 0);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // rep(id, MAX_V) {\n    //     Node u(id);\n    //     output(\"---\");\n    //     u.print();\n    //     for (auto e : G[id]) {\n    //         Node v(e.to);\n    //         v.print();\n    //         cout << e.cost << endl;\n    //     }\n    //     output(\"---\");\n    // }\n\n    // cerr << \"hey!\" << endl;\n\n    dijkstra();\n\n    // cerr << \"hey!\" << endl;\n\n    int mi = inf;\n    rep(p, A + 1) {\n        rep(q, A + 1) {\n            rep(k, 4) {\n                Node u(gx, gy, p, q, k);\n                // cout << d[u.id] << \" \";\n                // u.print();\n                if (u.id == -1) continue;\n                mi = min(mi, d[u.id]);\n            }\n        }\n    }\n\n    cout << (mi == inf ? -1 : mi) << endl;\n\n    // rep(x, H) {\n    //     rep(y, W) {\n    //         rep(p, A + 1) {\n    //             rep(q, A + 1) {\n    //                 rep(k, 4) {\n    //                     Node u(x, y, p, q, k);\n    //                     output(x, y, p, q, k, \":\", d[u.id]);\n    //                 }\n    //             }\n    //         }\n    //     }\n    // }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nclass State\n{\npublic:\n\tint x,y,d,p,q,c;\n\tState(int x, int y, int d, int p, int q, int c)\n\t\t:x(x),y(y),d(d),p(p),q(q),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint N,M,A;\nbool memo[100][100][4][10][10];\nstring field[100];\n\nbool invaild(int x, int y)\n{\n\tif(x<0||y<0||x>=M||y>=N) return true;\n\tif(field[y][x] == '#') return true;\n\t\n\treturn false;\n}\n\nbool newState(State& s)\n{\n\treturn !memo[s.x][s.y][s.d][s.p][s.q];\n}\n\nState straight(State s)\n{\n\t\n\tint tx = s.x + dx[s.d];\n\tint ty = s.y + dy[s.d];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,s.d,s.p,s.q,s.c);\n}\n\nState useP(State s)\n{\n\tif(s.p == 0) return s;\n\n\tint nd = (s.d+1)%2 + (s.d > 1? 2: 0);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p-1,s.q,s.c+1);\n}\n\nint refQ(int d)\n{\n\tif(d==0) return 3;\n\tif(d==3) return 0;\n\tif(d==1) return 2;\n\n\treturn 1;\n}\n\nState useQ(State s)\n{\n\tif(s.q == 0) return s;\n\n\tint nd = refQ(s.d);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p,s.q-1,s.c+1);\n}\n\n\n\nint solve()\n{\n\tmemset(memo, 0, sizeof(memo));\n\n\tint sx,sy;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<M; j++) {\n\t\tif(field[i][j]=='S') {\n\t\t\tsx = j;\n\t\t\tsy = i;\n\t\t}\n\t}\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,A,A,0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(!newState(s)) continue;\n\t\tmemo[s.x][s.y][s.d][s.p][s.q] = true;\n\n\t\tif(field[s.y][s.x] == 'G') return s.c;\n\n\t\tState ns = straight(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useP(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useQ(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin >> N >> M >> A, (N||M||A)) {\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\t\tcout << solve() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i + 1 < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i+1,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    if(in[cx][cy] == 'S') continue;\n    if(in[cx][cy] == '#') continue;    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,-1));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100][15][15];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = -1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tint tmp_use_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tif(tmp_use_mirrors > A) continue;\n\n\tuse_mirrors = tmp_use_mirrors;\n\tbreak;\n      }\n\n      if(dp[s.x][s.y][s.P_reflect_count][s.Q_reflect_count]) continue;\n      dp[s.x][s.y][s.P_reflect_count][s.Q_reflect_count] = true;\n\n      for(int i=0;i<4;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.')\n      Q.push(state(cx,cy,~di&3,p-1,q));\n    \n    if(q && in[cx][cy]=='.')\n      Q.push(state(cx,cy,di^1,p,q-1));\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\npii f(pii a, pii b, int x1, int x2){\n    b.first+=x1;\n    b.second+=x2;\n    \n    if(a.first>=b.first && a.second>=b.second)return b;\n    if(a.first<=b.first && a.second<=b.second)return a;\n    abort();\n}\n\nstruct state{\n    int y,x,dir,bs,s;\n};\n\nint main(){\n    int h,w,a;\n    cin>>h>>w>>a;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    pii s,g;\n    rep(i,h)rep(j,w){\n        if(vs[i][j]=='S')s = pii(i,j);\n        if(vs[i][j]=='G')g = pii(i,j);\n    }\n    \n    static int dp[101][101][4][11][11];\n    rep(i,101)rep(j,101)rep(k,4)rep(l,11)rep(m,11)dp[i][j][k][l][m] = INF;\n    dp[s.first][s.second][0][0][0] = 0;\n    \n    queue<state> que;\n    que.push(state{s.first, s.second, 0, 0, 0});\n    \n    // '\\', '/'\n    //テ、ツクツ? テ・ツ渉ウ, テ、ツクツ? テ・ツキツヲ\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    while(que.size()){\n        state q = que.front();\n        que.pop();\n        \n        for(int k = 1;;k++){\n            int ddy = q.y+dy[q.dir]*k;\n            int ddx = q.x+dx[q.dir]*k;\n            \n            if(pii(ddy,ddx)==s)break;\n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            int bsnum,snum;\n            \n            //テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==0)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+3)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n            \n            //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==1)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+1)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    rep(i,4){\n        for(int k=1;;k++){\n            int y,x;\n            tie(y,x) = g;\n            int ddy = y+dy[i]*k;\n            int ddx = x+dx[i]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            rep(l,a+1){\n                rep(m,a+1){\n                    ans = min(ans, dp[ddy][ddx][(i+2)%4][l][m]);\n                }\n            }\n        }\n    }\n    if(ans>2*a)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 100;\nconst int W = 100;\nconst int A = 10;\nconst int INF = 1 << 29;\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\nconst int usep[4] = {3, 2, 1, 0};\nconst int useq[4] = {1, 0, 3, 2};\n\nstruct state{\n  int x, y, d, p, q;\n  state(int y=0, int x=0, int d=0, int p=0, int q=0):x(x),y(y),d(d),p(p),q(q){}\n  bool operator < (const state &s) const {\n    return (p+q) > (s.p+s.q);\n  }\n};\n\nint h, w, a, sy, sx, gy, gx;\nbool G[H][W];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return !G[y][x];\n}\n\nint solve(){\n  bool f[H][W][4][A+1][A+1];\n  priority_queue<state> pq;\n  state u, u2;\n\n  for(int i=0;i<h*w;i++) for(int j=0;j<4;j++) for(int k=0;k<=a;k++) for(int l=0;l<=a;l++) f[i/w][i%w][j][k][l] = false;\n  \n  /*\n  for(int i=0;i<4;i++) {\n    pq.push(state(sy, sx, i, 0, 0));\n    f[sy][sx][i][0][0] = true;\n  }\n  */\n  pq.push(state(sy, sx, 2, 0, 0));\n  f[sy][sx][2][0][0] = true;\n\n  while(!pq.empty()){\n    u = pq.top();\n    pq.pop();\n\n    if(u.y == gy && u.x == gx) return u.p + u.q;\n\n    u2 = state(u.y+dy[u.d], u.x+dx[u.d], u.d, u.p, u.q);\n    if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n      f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n      pq.push(u2);\n    }\n    \n    if(u.p < a){\n      u2 = u;\n      u2.d = usep[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.p++;\n      if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n\n    if(u.q < a){\n      u2 = u;\n      u2.d = useq[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.q++;\n      if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string str;\n  while(cin >> h >> w >> a){\n    for(int i=0;i<h;i++){\n      cin >> str;\n      for(int j=0;j<w;j++){\n        G[i][j] = false;\n        if(str[j] == 'S'){\n          sy = i;\n          sx = j;\n        } else if(str[j] == 'G'){\n          gy = i;\n          gx = j;\n        } else if(str[j] == '#'){\n          G[i][j] = true;\n        }\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.a<c&&!bfs[tr][tc][at.a+1][at.b][at.d^1]){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.b<c&&!bfs[tr][tc][at.a][at.b+1][at.d^2]){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint H, W, A, sx, sy, gx, gy, dx[] = { 0, 1, 0, -1 }, dy[] = { 1, 0, -1, 0 }; bool vis[109][109][4][15][15]; string s[109];\nvoid dfs(int x, int y, int dir, int mp, int mq) {\n\tvis[x][y][dir][mp][mq] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif ((i ^ 2) == dir) continue;\n\t\tint tx = x + dx[i], ty = y + dy[i], nmp = mp + ((i ^ 1) == dir), nmq = mq + ((i ^ 3) == dir);\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && s[tx][ty] != 'S' && nmp <= A && nmq <= A && !vis[tx][ty][i][nmp][nmq]) {\n\t\t\tdfs(tx, ty, i, nmp, nmq);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> H >> W >> A;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == 'S') sx = i, sy = j;\n\t\t\tif (s[i][j] == 'G') gx = i, gy = j;\n\t\t}\n\t}\n\tdfs(sx, sy, 1, 0, 0);\n\tint ret = 1 << 30;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j <= A; j++) {\n\t\t\tfor (int k = 0; k <= A; k++) {\n\t\t\t\tif (vis[gx][gy][i][j][k] && ret > j + k) ret = j + k;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ret == 1 << 30 ? -1 : ret) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n    int i,j;\n    int dir;\n    int p;\n    int q;\n    bool mir;\n};\nbool operator<(State lhs,State rhs){\n    return make_tuple(lhs.i,lhs.j,lhs.dir,lhs.p,lhs.q,lhs.mir)<make_tuple(rhs.i,rhs.j,rhs.dir,rhs.p,rhs.q,rhs.mir);\n}\nusing Field=vector<string>;\nint di[]={0,-1,0,1};\nint dj[]={1,0,-1,0};\nint pd[]={3,2,1,0};\nint qd[]={1,0,3,2};\n\nint main(){\n    int n,m,a;\n    cin>>n>>m>>a;\n    Field f(n);\n    for(int i=0;i<n;i++){\n        cin>>f[i];\n    }    \n    int inii=-1;\n    int inij=-1;\n    deque<State> que;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(f[i][j]=='S'){\n                que.push_back({i,j,3,a,a,true});\n                inii=i;\n                inij=j;\n            }\n        }\n    }\n    auto isRange=[&](int i,int j){\n        return 0<=i && i<n && 0<=j&& j<m && f[i][j]!='#';\n    };\n    \n    set<State> used;\n    while(!que.empty()){\n        auto st=que.front(); que.pop_front();\n        if(f[st.i][st.j]=='S' && st.dir==1) continue;\n        if(used.count(st)) continue;\n        used.insert(st);\n        if(f[st.i][st.j]=='G'){\n            cout<<a-st.p+a-st.q<<endl;\n            return 0;\n        }\n        if(isRange(st.i+di[st.dir],st.j+dj[st.dir])){\n            State to=st;\n            to.i+=di[st.dir];\n            to.j+=dj[st.dir];\n            to.mir=false;\n            que.push_front(to);\n        }\n        if(st.mir)  continue;\n        if(st.p>0){\n            State to=st;\n            to.p--;\n            to.dir=pd[to.dir];\n            to.mir=true;\n            que.push_back(to);\n        }\n        if(st.q>0){\n            State to=st;\n            to.q--;\n            to.dir=qd[to.dir];\n            to.mir=true;\n            que.push_back(to);\n        }\n    }\n    cout<<-1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    //for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    q.push(make_tuple(S.first,S.second,1,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][11][11][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  /*\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      cout << G[i][j];\n    }cout <<endl;\n  }cout << endl;\n  */\n  if(val >= 0) return val;\n  if(G[x][y] == 'G'){\n    return val = 0;\n  }\n  val = INF;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    char c = G[x][y];\n    if(G[x][y] != 'S') G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p > 0){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q > 0){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  //printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nDef d[110][110][11][4];\nclass DIJ{\n\tpublic:\n\tDef n,m,A;\n\tvs in;\n\tDIJ(Def size,Def w,vs fi,Def q){\n\t\tn=size;\n\t\tin=fi;\n\t\tm=w;\n\t\tA=q;\n\t}\n\tvoid dij(){\n\t\trep(i,110)rep(j,110)rep(l,11)rep(q,4)\n\t\t\td[i][j][l][q]=inf;\n\t\tint gx,gy;\n\t\tpriority_queue<tp>q;\n\t\trep(i,in.size())rep(j,in[0].size())\n\t\t\tif(in[i][j]=='G')gx=i,gy=j;\n\t\t\telse if(in[i][j]=='S'){\n\t\t\t\tif(i+1<n&&in[i+1][j]!='#'){\n\t\t\t\t\td[i+1][j][0][1]=0;\n\t\t\t\t\tq.push(tp(0,i+1,j,0,1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,a,to;\n\t\t\ttie(cost,x,y,a,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][a][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tint na=a,nb=cost;\n\t\t\t\tint nto=k;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tif(in[nx][ny]=='S')continue;\n\t\t\t\tif((to+2)%4==nto)continue;\n\t\t\t\tif(nto!=to){\n\t\t\t\t\tif(to%2){\n\t\t\t\t\t\tif((to+1)%4==nto)na++;\n\t\t\t\t\t\telse nb++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((to+1)%4==nto)nb++;\n\t\t\t\t\t\telse na++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(na>A||nb>A)continue;\n\t\t\t\tif(nb<d[nx][ny][na][nto]){\n\t\t\t\t\td[nx][ny][na][nto]=nb;\n\t\t\t\t\tq.push(tp(-nb,nx,ny,na,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,11)rep(j,4)if(d[gx][gy][i][j]!=inf){\n\t\t\tcmin(out,i+d[gx][gy][i][j]);\n\t\t}\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(n,m,in,k);\n\tdij.dij();\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(ans<1e9||used[x][y][p][q][dir]++)return;\n  \n  while(1){\n    x=x+dx[dir];\n    y=y+dy[dir];\n    if(x<0||y<0||x>=w||y>=h)return;\n    if(mp[y][x]=='#')return;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2);\n      if(dir==1)dfs(x,y,p-1,q,3);\n      if(dir==2)dfs(x,y,p-1,q,0);\n      if(dir==3)dfs(x,y,p-1,q,1);\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3);\n      if(dir==1)dfs(x,y,p,q-1,2);\n      if(dir==2)dfs(x,y,p,q-1,1);\n      if(dir==3)dfs(x,y,p,q-1,0);\n    }\n  }\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,-1));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\n\tuse_mirrors = min(s.P_reflect_count + s.Q_reflect_count,use_mirrors);\n      }\n\n      if(dp[s.x][s.y]) continue;\n      dp[s.x][s.y] = true;\n\n      for(int i=0;i<4;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint H, W, A;\nvector<string> s(H);\nint sx, sy, gx, gy;\nconst int MAX_V = 4*11*11*100*100;\nint d[MAX_V];\n\nconst int dx[4] = { 1, 0, -1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nstruct Node {\n    int x, y, p, q, k, id;\n    Node(){}\n    Node(int _x, int _y, int _p, int _q, int _k) : x(_x), y(_y), p(_p), q(_q), k(_k), id(-1) {\n        if (!inside(x, y)) return;\n        if (p < 0 || q < 0) return;\n        if (s[x][y] == '#') return;\n        if (s[x][y] == 'S' && k == 2) return;\n        id = 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k;\n    }\n    Node(int _id) : id(_id) {\n        k = _id % 4; _id /= 4;\n        q = _id % 11; _id /= 11;\n        p = _id % 11; _id /= 11;\n        y = _id % 100; _id /= 100;\n        x = _id;\n    }\n    void print() {\n        output(x, y, p, q, k, id);\n    }\n};\n\nint dijkstra() {\n    using State = pair<int, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    fill(d, d + MAX_V, inf);\n\n    Node ns(sx, sy, A, A, 0);\n    d[ns.id] = 0;\n    pq.push(State(0, ns.id));\n\n    while (!pq.empty()) {\n        int cost, id;\n        tie(cost, id) = pq.top(); pq.pop();\n        if (d[id] < cost) continue;\n        Node u(id);\n\n        int x = u.x;\n        int y = u.y;\n        int p = u.p;\n        int q = u.q;\n        int k = u.k;\n\n        if (x == gx && y == gy) {\n            return cost;\n        }\n\n        vector<pair<Node, int>> cands; // v, cost(u->v)\n\n        if (s[x][y] == 'S') {\n            cands.emplace_back(Node(x + dx[k], y + dy[k], p, q, k), 0);\n        }\n        else if (k == 0) {\n            cands.emplace_back(Node(x, y - 1, p, q - 1, 3), 1);\n            cands.emplace_back(Node(x, y + 1, p - 1, q, 1), 1);\n            cands.emplace_back(Node(x + 1, y, p, q, 0), 0);\n        }\n        else if (k == 1) {\n            cands.emplace_back(Node(x - 1, y, p, q - 1, 2), 1);\n            cands.emplace_back(Node(x + 1, y, p - 1, q, 0), 1);\n            cands.emplace_back(Node(x, y + 1, p, q, 1), 0);\n        }\n        else if (k == 2) {\n            cands.emplace_back(Node(x, y - 1, p - 1, q, 3), 1);\n            cands.emplace_back(Node(x, y + 1, p, q - 1, 1), 1);\n            cands.emplace_back(Node(x - 1, y, p, q, 2), 0);\n        }\n        else if (k == 3) {\n            cands.emplace_back(Node(x - 1, y, p - 1, q, 2), 1);\n            cands.emplace_back(Node(x + 1, y, p, q - 1, 0), 1);\n            cands.emplace_back(Node(x, y - 1, p, q, 3), 0);\n        }\n\n        for (const auto& p : cands) {\n            Node v;\n            int c;\n            tie(v, c) = p;\n            if (v.id == -1) continue;\n            if (d[v.id] > d[u.id] + c) {\n                d[v.id] = d[u.id] + c;\n                pq.push(State(d[v.id], v.id));\n            }\n        }\n    }\n\n    return -1;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W >> A;\n    s.resize(H);\n    rep(i, H) {\n        cin >> s[i];\n        rep(j, W) {\n            if (s[i][j] == 'S') {\n                sx = i; sy = j;\n            }\n            if (s[i][j] == 'G') {\n                gx = i; gy = j;\n            }\n        }\n    }\n\n    cout << dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct pos{\n  int y,x,p,q,d;\n  pos(int A=0,int B=0,int C=0,int D=0,int E=0):y(A),x(B),p(C),q(D),d(E){}\n};\n\nint h,w,a;\nstring g[100];\nint dis[100][100][11][11][4];\nint dy[] = {1,0,-1,0}, dx[] = {0,-1,0,1};\nconst int INF = (int)(1e8);\n\nint main(){\n  cin >> h >> w >> a;\n  rep(i,h)cin >> g[i];\n  \n  int sy,sx,gy,gx;\n  rep(i,h)rep(j,w){\n    rep(k,a+1)rep(l,a+1)rep(m,4)dis[i][j][k][l][m] = INF;\n    if(g[i][j] == 'S'){\n      sy = i; sx = j;\n    }else if(g[i][j] == 'G'){\n      gy = i; gx = j;\n    }\n  }\n\n  deque<pos> que;\n  if(sy+1<h){\n    que.push_back(pos(sy+1,sx,a,a,0));\n    dis[sy+1][sx][a][a][0] = 0;\n  }\n\n  int ans = -1;\n  while(que.size()){\n    pos P = que.front(); que.pop_front();\n    int y = P.y, x = P.x, p = P.p, q = P.q, d = P.d;\n    if(y==gy && x==gx){\n      ans = dis[y][x][p][q][d];\n      break;\n    }\n\n    if(g[y][x]=='#')continue;\n    int ty = y+dy[d], tx = x+dx[d];\n    if(ty>=0 && tx>=0 && ty<h && tx<w){\n      if(dis[ty][tx][p][q][d] == INF){\n\tdis[ty][tx][p][q][d] = dis[y][x][p][q][d];\n\tque.push_front(pos(ty,tx,p,q,d));\n      }\n    }\n\n    if(g[y][x]!='.')continue;\n    if(p){\n      int tp = p-1, tq = q, td = ((d&1)?(d+1)%4:(d+3)%4);\n      ty = y+dy[td]; tx = x+dx[td];\n      if(ty>=0 && tx>=0 && ty<h && tx<w){\n\tif(dis[ty][tx][tp][tq][td] > dis[y][x][p][q][d]+1){ \n\t  dis[ty][tx][tp][tq][td] = dis[y][x][p][q][d]+1;\n\t  que.push_back(pos(ty,tx,tp,tq,td));\n\t}\n      }\n    }\n\n    if(q){\n      int tp = p, tq = q-1, td = ((d&1)?(d+3)%4:(d+1)%4);\n      ty = y+dy[td]; tx = x+dx[td];\n      if(ty>=0 && tx>=0 && ty<h && tx<w){\n\tif(dis[ty][tx][tp][tq][td] > dis[y][x][p][q][d]+1){ \n\t  dis[ty][tx][tp][tq][td] = dis[y][x][p][q][d]+1;\n\t  que.push_back(pos(ty,tx,tp,tq,td));\n\t}\n      }\n    }\n  }\n  cout << ans << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n      ans=min(memo[u.y][u.x][u.muki],ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(memo[a][b][u.muki]>=u.numL+u.numR){\n\t  memo[a][b][u.muki]=u.numL+u.numR;\n\t  Q.push(State(a,b,u.muki,u.numL,u.numR));\n\t}\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+1)%4]>=u.numL+u.numR+1){\n\t    memo[a][b][(u.muki+1)%4]=u.numR+u.numL+1;\n\t    if(memo[a][b][(u.muki+1)%4]<ans){\n\t      if(((u.muki+1)%4)%2==0){\n\t\tif(u.numL+1<A)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t      }\n\t      if(((u.muki+1)%4)%2==1){\n\t\tif(u.numR+1<A)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+3)%4]>=u.numR+u.numL+1){\n\t    memo[a][b][(u.muki+3)%4]=u.numR+u.numL+1;\n\t    if(memo[a][b][(u.muki+3)%4]<ans){\n\t      if(((u.muki+3)%4)%2==0){\n\t\tif(u.numR+1<A)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t      }\n\t      if(((u.muki+3)%4)%2==1){\n\t\tif(u.numL+1<A)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(val != INF) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        char orig = board[x][y];\n        if(x != sx || y != sy) board[x][y] = '#';\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n        board[x][y] = orig;\n    }\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], INF);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h) return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool d[100*100*11*11*4];\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int dir){\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+dir;\n  };\n\n  int sx,sy,tx,ty;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      sx = i+1; sy = j;\n    }\n    if(vec[i][j]=='G') tx=i, ty=j;\n  }\n\n  auto ok = [&](int i, int j, int dir){//dbg(i,j,dir);\n    if(i<0 || i>=n || j<0 || j>=m) return false;\n    if(dir%2==0 && vec[i][j]=='S') return false;\n    return (vec[i][j]=='.' || vec[i][j]=='G' || vec[i][j]=='S' );\n  };\n\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,1,0,-1};\n  const int mirrx[] = {3,2,1,0};\n  const int mirry[] = {1,0,3,2};\n\n  int res = INF;\n\n  fill(d, d+(sizeof(d)), false);\n  queue<int> qx, qy, qi, qj, qd;\n  d[f(sx,sy,0,0,0)] = true;\n  qx.push(sx); qy.push(sy); qi.push(0); qj.push(0); qd.push(0);\n\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    int i = qi.front(); qi.pop();\n    int j = qj.front(); qj.pop();\n    int dir = qd.front(); qd.pop();\n\n    if(x==tx && y==ty){\n      res = min(res, i+j);\n      continue;\n    }\n\n    int nx,ny;\n\n    // ????????????\n    nx = x + dx[dir];\n    ny = y + dy[dir];\n    if(ok(nx, ny, dir)){\n      int z = f(nx, ny, i, j, dir);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i); qj.push(j); qd.push(dir);\n      }\n    }\n\n    if(vec[x][y]=='S') continue;\n\n    // mirror\n    nx = x + dx[mirrx[dir]];\n    ny = y + dy[mirrx[dir]];\n    if(i<a && ok(nx, ny, mirrx[dir])){\n      int z = f(nx, ny, i+1, j, mirrx[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i+1); qj.push(j); qd.push(mirrx[dir]);\n      }\n    }\n\n    nx = x + dx[mirry[dir]];\n    ny = y + dy[mirry[dir]];\n    if(j<a && ok(nx, ny, mirry[dir])){\n      int z = f(nx, ny, i, j+1, mirry[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i); qj.push(j+1); qd.push(mirry[dir]);\n      }\n    }\n  }\n\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<deque>\n\nusing namespace std;\n\nstruct S{\n  int y,x,d,p,q;\n  int code(){\n    return q+p*11+d*11*11+x*11*11*4+y*11*11*4*100;\n  }\n};\n\nint main(){\n  int N,M,A;\n  cin>>N>>M>>A;\n  char g[100][100];\n  S is={0,0,2,0,0};\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      cin>>g[i][j];\n      if(g[i][j]=='S'){\n\tis.y=i;\n\tis.x=j;\n      }\n    }\n  }\n  static bool p[100*100*4*11*11];\n  deque<S> deq(1,is);\n  while(!deq.empty()){\n    S c=deq.front();\n    if(g[c.y][c.x]=='G')break;\n    deq.pop_front();\n    if(p[c.code()]++)continue;\n    for(int i=0;i<3;i++){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      S n=c;\n      n.y+=dy[n.d];\n      n.x+=dx[n.d];\n      if(i==1){\n\tn.d^=1;\n\tn.p++;\n      }else if(i==2){\n\tn.d=3-n.d;\n\tn.q++;\n      }\n      if(0<=n.y&&n.y<N&&0<=n.x&&n.x<M&&n.p<=A&&n.q<=A&&g[c.y][c.x]!='#'){\n\tif(i==0){\n\t  deq.push_front(n);\n\t}else{\n\t  deq.push_back(n);\n\t}\n      }\n    }\n  }\n  cout<<(deq.empty()?-1:deq.front().p+deq.front().q)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<deque>\n\nusing namespace std;\n\nstruct S{\n  int y,x,d,p,q;\n  int code(){\n    return q+p*11+d*11*11+x*11*11*4+y*11*11*4*100;\n  }\n};\n\nint main(){\n  int N,M,A;\n  cin>>N>>M>>A;\n  char g[100][100];\n  S is={0,0,2,0,0};\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      cin>>g[i][j];\n      if(g[i][j]=='S'){\n\tis.y=i;\n\tis.x=j;\n      }\n    }\n  }\n  static bool p[100*100*4*11*11];\n  deque<S> deq(1,is);\n  while(!deq.empty()){\n    S c=deq.front();\n    if(g[c.y][c.x]=='G')break;\n    deq.pop_front();\n    if(p[c.code()]++)continue;\n    for(int i=0;i<3;i++){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      S n=c;\n      n.y+=dy[n.d];\n      n.x+=dx[n.d];\n      if(i==1){\n\tn.d^=1;\n\tn.p++;\n      }else if(i==2){\n\tn.d=3-n.d;\n\tn.q++;\n      }\n      if(0<=n.y&&n.y<N&&0<=n.x&&n.x<M&&n.p<=A&&n.q<=A&&g[c.y][c.x]!='#'&&!(g[c.y][c.x]=='S'&&n.d==0)){\n\tif(i==0){\n\t  deq.push_front(n);\n\t}else{\n\t  deq.push_back(n);\n\t}\n      }\n    }\n  }\n  cout<<(deq.empty()?-1:deq.front().p+deq.front().q)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[105];\nPII dp[105][105][4];\nsigned main(void)\n{\n  int h, w, a;\n  cin >> h >> w >> a;\n  REP(i, h) cin >> s[i];\n  int sx, sy, gx, gy;\n  REP(i, h) REP(j, w) {\n    if(s[i][j] == 'S') sx = j, sy = i;\n    else if(s[i][j] == 'G') gx = j, gy = i;\n  }\n\n  REP(i, h) REP(j, w) REP(k, 4) dp[i][j][k] = {INF, INF};\n\n  FOR(i, sy, h) {\n    if(s[i][sx] == '#') break;\n    dp[i][sx][0] = {0, 0};\n  }\n\n  REP(i, 2*a) {\n    REP(y, h) REP(x, w) REP(dir, 4) {\n      //????????????\n      if(dp[y][x][dir].first + dp[y][x][dir].second == i) {\n        if(dir == 0) {\n          //???????????????????????? typeQ\n          for(int j=x; j>=0; --j) {\n            if(s[y][j] == '#') break;\n            if(dp[y][j][1] == PII{INF, INF}) {\n              dp[y][j][1] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n          //???????????????????????? typeP\n          for(int j=x; j<w; ++j) {\n            if(s[y][j] == '#') break;\n            if(dp[y][j][3] == PII{INF, INF}) {\n              dp[y][j][3] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n        } else if(dir == 1) {\n          //???????????????????????? typeP\n          for(int j=y; j>=0; --j) {\n            if(s[j][x] == '#') break;\n            if(dp[j][x][2] == PII{INF, INF}) {\n              dp[j][x][2] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n          //???????????????????????? typeQ\n          for(int j=y; j<h; ++j) {\n            if(s[j][x] == '#') break;\n            if(dp[j][x][0] == PII{INF, INF}) {\n              dp[j][x][0] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n        } else if(dir == 2) {\n          //???????????????????????? typeP\n          for(int j=x; j>=0; --j) {\n            if(s[y][j] == '#') break;\n            dp[y][j][1] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n          }\n          //???????????????????????? typeQ\n          for(int j=x; j<w; ++j) {\n            if(s[y][j] == '#') break;\n            dp[y][j][3] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n          }\n        } else if(dir == 3) {\n          //???????????????????????? typeQ\n          for(int j=y; j>=0; --j) {\n            if(s[j][x] == '#') break;\n            if(dp[j][x][2] == PII{INF, INF}) {\n              dp[j][x][2] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n          //???????????????????????? typeP\n          for(int j=y; j<h; ++j) {\n            if(s[j][x] == '#') break;\n            if(dp[j][x][0] == PII{INF, INF}) {\n              dp[j][x][0] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n        }\n      }\n    }\n  }\n\n  int ret = INF;\n  REP(i, 4) {\n    if(dp[gy][gx][i].first <= a && dp[gy][gx][i].second <= a) {\n      ret = min(ret, dp[gy][gx][i].first + dp[gy][gx][i].second);\n    }\n  }\n\n  if(ret == INF) cout << -1 << endl;\n  else cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<1>(p) + 1 > h) return INF;\n\n\tdis[get<1>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<1>(p) + 1, get<0>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[ny][nx][np][nq][i] = 1;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct pos{\n  int y,x,p,q,d;\n  pos(int A=0,int B=0,int C=0,int D=0,int E=0):y(A),x(B),p(C),q(D),d(E){}\n};\n\nint h,w,a;\nstring g[100];\nint dis[100][100][11][11][4];\nint dy[] = {1,0,-1,0}, dx[] = {0,-1,0,1};\nconst int INF = (int)(1e8);\n\nint main(){\n  cin >> h >> w >> a;\n  rep(i,h)cin >> g[i];\n  \n  int sy,sx,gy,gx;\n  rep(i,h)rep(j,w){\n    rep(k,a+1)rep(l,a+1)rep(m,4)dis[i][j][k][l][m] = INF;\n    if(g[i][j] == 'S'){\n      sy = i; sx = j;\n    }else if(g[i][j] == 'G'){\n      gy = i; gx = j;\n    }\n  }\n\n  deque<pos> que;\n  if(sy+1<h){\n    que.push_back(pos(sy+1,sx,a,a,0));\n    dis[sy+1][sx][a][a][0] = 0;\n  }\n  rep(i,a+1)rep(j,a+1){\n    dis[sy][sx][i][j][2] = -1;\n  }\n\n  int ans = -1;\n  while(que.size()){\n    pos P = que.front(); que.pop_front();\n    int y = P.y, x = P.x, p = P.p, q = P.q, d = P.d;\n    if(y==gy && x==gx){\n      ans = dis[y][x][p][q][d];\n      break;\n    }\n\n    if(g[y][x]=='#')continue;\n    int ty = y+dy[d], tx = x+dx[d];\n    if(ty>=0 && tx>=0 && ty<h && tx<w){\n      if(dis[ty][tx][p][q][d] == INF){\n\tdis[ty][tx][p][q][d] = dis[y][x][p][q][d];\n\tque.push_front(pos(ty,tx,p,q,d));\n      }\n    }\n\n    if(g[y][x]!='.')continue;\n    if(p){\n      int tp = p-1, tq = q, td = ((d&1)?(d+1)%4:(d+3)%4);\n      ty = y+dy[td]; tx = x+dx[td];\n      if(ty>=0 && tx>=0 && ty<h && tx<w){\n\tif(dis[ty][tx][tp][tq][td] > dis[y][x][p][q][d]+1){ \n\t  dis[ty][tx][tp][tq][td] = dis[y][x][p][q][d]+1;\n\t  que.push_back(pos(ty,tx,tp,tq,td));\n\t}\n      }\n    }\n\n    if(q){\n      int tp = p, tq = q-1, td = ((d&1)?(d+3)%4:(d+1)%4);\n      ty = y+dy[td]; tx = x+dx[td];\n      if(ty>=0 && tx>=0 && ty<h && tx<w){\n\tif(dis[ty][tx][tp][tq][td] > dis[y][x][p][q][d]+1){ \n\t  dis[ty][tx][tp][tq][td] = dis[y][x][p][q][d]+1;\n\t  que.push_back(pos(ty,tx,tp,tq,td));\n\t}\n      }\n    }\n  }\n  cout << ans << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nvoid pr(int x,int y,int dir){\n  char ch[]={'V','^','>','<'};\n  char tmp=mp[y][x];\n  mp[y][x]=ch[dir];\n  for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  mp[y][x]=tmp;\n  cout<<\"------\"<<endl;\n}\n\n\nint ans=1e9;//,used[101][101][10][10][4];\nint used[101][101][2];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(2*A-(p+q)>=ans)return;\n  //if(used[x][y][p][q][dir]++)return;\n  \n  vector<int> X,Y,ch;\n\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')used[i][j][0]=1,dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int inf = 1e9;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint mincost[101][101][4][11][11];\nvoid initcost(){\n    REP(y,101) REP(x,101) REP(d,4) REP(p,11) REP(q,11){\n        mincost[y][x][d][p][q] = inf;\n    }\n}\n\n\nstruct info{\n    int y,x,d,p,q,c;\n    info(int y, int x, int d, int p, int q, int c)\n        :y(y),x(x),d(d),p(p),q(q),c(c){}\n    info(){}\n    bool operator<(const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int h,w,a;\n    cin >> h >> w >> a;\n    vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n    int sy,sx, gy,gx;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> field[i][j];\n            if(field[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(field[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    \n    priority_queue<info> wait;\n    for(int i=0; i<4; i++){\n        int ny = sy+dy[i], nx = sx+dx[i];\n        if(field[ny][nx] != '#'){\n            wait.push(info(ny, nx, i, a, a, 0));\n        }\n    }\n    initcost();\n\n    while(!wait.empty()){\n        info top = wait.top();\n        int y = top.y;\n        int x = top.x;\n        int d = top.d;\n        int p = top.p;\n        int q = top.q;\n        int c = top.c;\n        wait.pop();\n        if(field[y][x] == 'S' || field[y][x]=='G') continue;\n        if(c > mincost[y][x][d][p][q]) continue;\n\n        for(int i=0; i<4; i++){\n            int ny = y+dy[i];\n            int nx = x+dx[i];\n            int np = p;\n            int nq = q;\n            if(field[ny][nx] == '#') continue;\n            if((i+2)%4 == d) continue;\n            if((d+i)%4 == 1) np--;\n            if((d+i)%4 == 3) nq--;\n            if(np<0 || nq<0) continue;\n            if(c+1 < mincost[ny][nx][i][np][nq]){\n                wait.push(info(ny, nx, i, np, nq, c+1));\n                mincost[ny][nx][i][np][nq] = c+1;\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int d=0; d<4; d++){\n        for(int p=0; p<=10; p++){\n            for(int q=0; q<=10; q++){\n                if(mincost[gy][gx][d][p][q] != inf){\n                    ans = min(ans, a-p +a-q);\n                }\n            }\n        }\n    }\n    if(ans == inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define S second\n#define F first\n#define N 105\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\ntypedef pair<P,P1> P2;\nint n,m,a,d[N][N],sy,sx;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint dijkstra(){\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P2(P(0,2),P1(P(0,0),P(sy,sx))));\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    int cost=t.F.F,dir=t.F.S;\n    int pcnt=t.S.F.F,qcnt=t.S.F.S;\n    int y=t.S.S.F,x=t.S.S.S;\n    if(s[y][x]=='G')return cost;\n    if(d[y][x]<cost)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i],ncost=cost;\n      int npcnt=pcnt,nqcnt=qcnt;\n      if(ny<0||nx<0||n<=ny||m<=nx)continue;\n      if(s[ny][nx]=='#')continue;\n      if(i!=dir){\n\tncost++;\n\tint mindir=min(i,dir),maxdir=max(i,dir);\n\tif((mindir==0&&maxdir==1)||(mindir==2&&maxdir==3))npcnt++;\n\telse nqcnt++;\n      }\n      if(a<npcnt||a<nqcnt)continue;\n      if(d[ny][nx]>ncost){\n\td[ny][nx]=ncost;\n\tq.push(P2(P(ncost,i),P1(P(npcnt,nqcnt),P(ny,nx))));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>n>>m>>a;\n  for(int i=0;i<n;i++){\n    cin>>s[i];\n    for(int j=0;j<m;j++)\n      if(s[i][j]=='S')\n\tsy=i,sx=j;\n  }\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\nchar s[111];\nint cur,len;\n\nint shiki();\n\nint kazu()\n{\n  if( s[cur] == '(' ) {\n    cur += 1;\n    int s = shiki();\n    cur += 1;\n    return s;\n  } else {\n    int a = s[cur]-'0';\n    cur += 1;\n    while( isdigit(s[cur]) ) {\n      a *= 10;\n      a += s[cur]-'0';\n      cur += 1;\n    }\n    return a;\n  }\n}          \n\nint kou()\n{\n  int a = kazu();\n  while( s[cur] == '*' || s[cur] == '/' ) {\n    char o = s[cur]; cur += 1;\n    int b = kazu();\n    o=='*'?(a*=b):(a/=b);\n  }\n  return a;\n}\n\nint shiki()\n{\n  int a = kou();\n  while( s[cur] == '+' || s[cur] == '-' ) {\n    char o = s[cur]; cur += 1;\n    int b = kou();\n    if( o == '+' ) a += b;\n    else a -= b;\n  }\n  return a;\n}\n\nint parse()\n{\n  len = 0;\n  while( s[len] ) len++;\n  len--;\n  cur = 0;\n  return shiki();\n}\n\nint main(void)\n{\n  int n; scanf(\"%d\",&n);\n  while( n-- ) {\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",parse());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && p){\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = '.';\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && q){\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = '.';\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nint d[100][100][4][11][11];\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nchar mp[100][100];\nstruct status {\n\tint x, y, k, a, b;\n};\nvoid solve() {\n\tint n, m, a; cin >> n >> m >> a;\n\tint rx, ry;\n\tint gx, gy;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> mp[i][j];\n\t\t\tif (mp[i][j] == 'S') {\n\t\t\t\trx = i, ry = j; mp[i][j] = '.';\n\t\t\t}\n\t\t\tif (mp[i][j] == 'G') {\n\t\t\t\tgx = i, gy = j; mp[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\trep(k, 4) {\n\t\t\t\trep(l, a + 1) {\n\t\t\t\t\trep(x, a + 1) {\n\t\t\t\t\t\td[i][j][k][l][x] = mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<status> q;\n\trep(k, 1) {\n\t\td[rx][ry][2][0][0] = 0;\n\t\tq.push({ rx,ry,2,0,0 });\n\t}\n\twhile (!q.empty()) {\n\t\tstatus s = q.front(); q.pop();\n\t\tif (s.x == rx && s.y == ry && s.k == 0)continue;\n\t\tint nx = s.x + dx[s.k];\n\t\tint ny = s.y + dy[s.k];\n\t\tif (nx < 0 || ny < 0 || nx >= n || ny >= m)continue;\n\t\tif (mp[nx][ny] == '#')continue;\n\t\tint nd = d[s.x][s.y][s.k][s.a][s.b]+1;\n\t\tif (nd < d[nx][ny][s.k][s.a][s.b]) {\n\t\t\td[nx][ny][s.k][s.a][s.b] = nd;\n\t\t\tq.push({ nx,ny,s.k,s.a,s.b });\n\t\t}\n\t\tif (s.a < a) {\n\t\t\tint k = s.k;\n\t\t\tif (k < 2)k = 1 - k;\n\t\t\telse k = 5 - k;\n\t\t\tif (nd < d[nx][ny][k][s.a+1][s.b]) {\n\t\t\t\td[nx][ny][k][s.a+1][s.b] = nd;\n\t\t\t\tq.push({ nx,ny,k,s.a+1,s.b });\n\t\t\t}\n\t\t}\n\t\tif (s.b < a) {\n\t\t\tint k = s.k; k = 3 - k;\n\t\t\tif (nd < d[nx][ny][k][s.a][s.b+1]) {\n\t\t\t\td[nx][ny][k][s.a][s.b+1] = nd;\n\t\t\t\tq.push({ nx,ny,k,s.a,s.b+1 });\n\t\t\t}\n\t\t}\n\t}\n\tint ans = mod;\n\trep(i, 4) {\n\t\trep(j, a + 1) {\n\t\t\trep(k, a + 1) {\n\t\t\t\tif (d[gx][gy][i][j][k] < mod) {\n\t\t\t\t\tans = min(ans, j + k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == mod)ans = -1;\n\tcout << ans << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint H,W,A;\nint sy,sx;\nchar t[200][200];\nint d[200][200][11][4];\n\nint solve(){\n  memset(d,-1,sizeof(d));\n  queue<int> qy,qx,qa,qd;\n  qy.push(sy);\n  qx.push(sx);\n  qa.push(0);\n  qd.push(2);\n  d[sy][sx][0][2]=0;\n\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int a=qa.front();qa.pop();\n    int dir=qd.front();qd.pop();\n    int b=d[y][x][a][dir]-a;\n\n    if(t[y][x]=='_'&&dir==0)continue;\n    int ny=y,nx=x,na,nb;\n    while(1){\n      ny+=dy[dir];\n      nx+=dx[dir];\n      if(ny<0||nx<0)break;\n      if(ny>=H||nx>=W)break;\n      if(t[ny][nx]=='#')break;\n      //if(t[ny][nx]=='S')continue;\n      if(t[ny][nx]=='G')return d[y][x][a][dir];\n      for(int i=0;i<4;i++){\n        if(i==dir||i==(dir+2)%4)continue;\n\n        na=a,nb=b;\n        if(i%2==0&&i==(dir+1)%4)na=a+1;\n        else if(i%2==1&&i==(dir+3)%4)na=a+1;\n        else nb=b+1;\n        if(na>A||nb>A)continue;\n        \n        if(d[ny][nx][na][i]!=-1)continue;\n        d[ny][nx][na][i]=d[y][x][a][dir]+1;\n        qy.push(ny);\n        qx.push(nx);\n        qa.push(na);\n        qd.push(i);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='S'){\n        sy=i,sx=j;\n      }\n    }\n  }\n  for(int i=sy+1;i<H;i++){\n    if(t[i][sx]=='#')break;\n    t[i][sx]='_';\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\nstruct Point{ int x, y, p, q, d; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tqueue<Point> q;\n\n\trep(i,4) {\n\t\tdis[p.y][p.x][a][a][i] = 1;\n\t\tPoint tmp = Point{p.x, p.y, a, a, i};\n\t\tq.push(tmp);\n\t}\n\n\twhile(not q.empty()){\n\t\tPoint u = q.front(); q.pop();\n\t\t//cout << u.x << ' ' << u.y << ' ' << u.p << ' ' << u.q << ' ' << u.d << endl;\n\t\trep(i,4){\n\t\t\tif((u.d + 2) % 4 == i) continue;\n\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tnext.d = i;\n\t\t\tnext.p = u.p;\n\t\t\tnext.q = u.q;\n\t\t\tif(u.d == 0 || u.d == 2){\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(next.p < 0 || next.q < 0) continue;\n\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[next.y][next.x][next.p][next.q][next.d] && m[next.y][next.x] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[next.y][next.x][next.p][next.q][next.d] = 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[g.y][g.x][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tPoint s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = Point{j,i};\n\t\tif(m[i][j] == 'G') g = Point{j,i};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i,j,0,0,0);\n      v[s].pb(f(i+1,j,0,0,0));\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  rep(i,n)rep(j,m-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i][j+1]=='.' || vec[i][j+1]=='G') ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i+1][j]=='.' || vec[i+1][j]=='G') ){\n      rep(x,a+1)rep(y,a+1) for(int d=0;d<3;d+=2){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        v[p].pb(f(i,j,x+1,y,3));\n        v[p+1].pb(f(i,j,x+1,y,2));\n        v[p+2].pb(f(i,j,x+1,y,1));\n        v[p+3].pb(f(i,j,x+1,y,0));\n      }\n      if(y<a){\n        v[p].pb(f(i,j,x,y+1,1));\n        v[p+1].pb(f(i,j,x,y+1,0));\n        v[p+2].pb(f(i,j,x,y+1,3));\n        v[p+3].pb(f(i,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define rep(i,N) for(int i = 0 ; (i) < (int)(N) ; i++)\n\nstruct NODE{\n\tint x,y,dir;\n\tint P,Q;\n\tNODE(int x,int y,int dir,int P,int Q) : x(x) , y(y) , dir(dir) , P(P) , Q(Q) {}\n};\nchar c[110][110];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint memo[110][110][4][11][11];\nint main(){\n\tmemset(memo,-1,sizeof(memo));\n\tint H,W,A;\n\tcin >> H >> W >> A;\n\tint sx,sy,gx,gy;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] == 'S' ){\n\t\t\t\tsx = j , sy = i;\n\t\t\t}\n\t\t\tif( c[i][j] == 'G' ){\n\t\t\t\tgx = j , gy = i;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<NODE> Q;\n\t\n\trep(i,4){\n\t\tQ.push(NODE(sx,sy,i,A,A));\n\t\t//cout << sx << \" \" << sy << \" \" << i << \" \" << A << \" \" << A  << endl;\n\t\tmemo[sx][sy][i][A][A] = 0;\n\t}\n\tint answer = 1e9;\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\t//return 0;\n\t\t//cout << q.y << \" \" << q.x << \" \" << q.P << \" \" << q.Q << \"(\" << q.dir << \") [\" << memo[q.x][q.y][q.dir][q.P][q.Q] << endl;\n\t\tif( q.x == gx && q.y == gy ){\n\t\t\tanswer = min( answer , 2*A - q.P - q.Q );\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint pp = 0 , qq = 0;\n\t\t\tif( (q.dir+2)%4 == i ) continue;\n\t\t\tif( q.dir == 0 && i == 1 || q.dir == 1 && i == 0 || q.dir == 2 && i == 3 || q.dir == 3 && i == 2 ) pp = 1;\n\t\t\tif( q.dir == 0 && i == 3 || q.dir == 3 && i == 0 || q.dir == 2 && i == 1 || q.dir == 1 && i == 2 ) qq = 1;\n\t\t\tint nx = q.x + dx[i];\n\t\t\tint ny = q.y + dy[i];\n\t\t\tif( nx < 0 || nx >= W || ny >= H || ny < 0 || q.P-pp < 0 || q.Q-qq < 0 || c[ny][nx] == '#' || ~memo[nx][ny][i][q.P-pp][q.Q-qq] ) continue;\n\t\t\tmemo[nx][ny][i][q.P-pp][q.Q-qq] = 0;\n\t\t\t//cout << nx << \" \" << ny << \" \" << i << \" \" << q.P-pp << \" \" << q.Q-qq << endl;\n\t\t\tQ.push(NODE(nx,ny,i,q.P-pp,q.Q-qq));\n\t\t}\n\t\t\n\t}\n\t\n\tif( answer > 1e8 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << answer << endl;\n\t}\n\t\n};"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  // (num,x,y,dir,a1,a2)\n  priority_queue<tuple<int,int,int,int,int,int>, vector<tuple<int,int,int,int,int,int> >, greater<tuple<int,int,int,int,int,int> > > pq;\n  VI dist(idx(W,H,4,A+1,A+1)+1, INF);\n  pq.push(make_tuple(0,sx,sy+1,2,0,0));\n    \n  while(!pq.empty()){\n\tint num, x, y, d, a1, a2;\n\ttie(num,x,y,d,a1,a2) = pq.top(); pq.pop();\n\tif(x == gx && y == gy) break;\n\tint fr = idx(x,y,d,a1,a2);\n\tif(dist[fr] < num) continue;\n\n\t// ??????????????¨???\n\tif(vs[y][x] == '.'){\n\t  // /?????¢\n\t  if(a1 < A){\n\t\tint td = 3 - d;\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (tx == sx && ty >= sy && td == 0))){\n\t\t  int toid = idx(tx,ty,td,a1+1,a2);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1+1,a2));\n\t\t  }\n\t\t}\n\t  }\n\t  // \\?????¢\n\t  if(a2 < A){\n\t\tint td = d-(d%2*2-1);\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (tx == sx && ty >= sy && td == 0))){\n\t\t  int toid = idx(tx,ty,td,a1,a2+1);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1,a2+1));\n\t\t  }\n\t\t}\n\t  }\n\t}\n\n\t//??´???\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint toid = idx(tx,ty,d,a1,a2);\n\tif(dist[toid] > num){\n\t  dist[toid] = num;\n\t  pq.push(make_tuple(num,tx,ty,d,a1,a2));\n\t}\n  }\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tans = min(ans, dist[tid]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nclass Data\n{\npublic:\n    int p, q, y, x, d;\n    Data(int p0, int q0, int y0, int x0, int d0){\n        p = p0;\n        q = q0;\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n    int toInt(){\n        return (((p * 11 + q) * 102 + y) * 102 + x) * 4 + d;\n    }\n};\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n\n    vector<string> s(h+2, string(w+2, '#'));\n    int sy, sx, gy, gx;\n    for(int i=1; i<=h; ++i){\n        for(int j=1; j<=w; ++j){\n            cin >> s[i][j];\n            if(s[i][j] == 'S'){\n                sy = i;\n                sx = j;\n            }\n            if(s[i][j] == 'G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n\n    vector<bool> check(11*11*102*102*4, false);\n    queue<Data> q;\n    Data d0(n, n, sy, sx, 1);\n    check[d0.toInt()] = true;\n    q.push(d0);\n\n    int ret = INT_MAX;\n    while(!q.empty()){\n        Data d = q.front();\n        q.pop();\n\n        if(d.y == gy && d.x == gx){\n            ret = min(ret, 2 * n - d.p - d.q);\n            continue;\n        }\n\n        for(int i=0; i<4; ++i){\n            Data d2 = d;\n            d2.y += dy[i];\n            d2.x += dx[i];\n            d2.d = i;\n            if(s[d2.y][d2.x] == '#')\n                continue;\n            if(d.y == sy && d.x == sx && d.d != i) // generator の上に鏡を置くことは出来ない\n                continue;\n\n            if(d.d == i){\n                ;\n            }else if(abs(d.d - i) == 2){\n                continue;\n            }else if((dy[d2.d] + dx[d2.d]) * (dy[d.d] + dx[d.d]) == 1){\n                if(-- d2.p < 0)\n                    continue;\n            }else{\n                if(-- d2.q < 0)\n                    continue;\n            }\n\n            if(!check[d2.toInt()]){\n                check[d2.toInt()] = true;\n                q.push(d2);\n            }\n        }\n    }\n\n    if(ret == INT_MAX)\n        cout << -1 << endl;\n    else\n        cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<short,short,short,short,short,short> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, pair<int, int> s, pair<int, int> g){\n\t//if(s.first + 1 > h or m[s.first + 1][s.second] == '#') return INF;\n\n\tpriority_queue<T, vector<T>, greater<T>> que;\n\tdis[s.first + 1][s.second][a][a][1] = 1;\n\tque.push(T(0, s.first, s.second, a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint c, y, x, p, q, d;\n\t\ttie(c,y,x,p,q,d) = que.top(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\tif(y == g.first and x == g.second) break;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\tint nc = c;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(nc,ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tpair<int, int> s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = make_pair(i,j);\n\t\tif(m[i][j] == 'G') g = make_pair(i,j);\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  que.emplace(si, sj, 0, 0, 0);\n  vis[si][sj][0][0][0] = true;\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (np > a || nq > a) continue;\n      int nd = dd[k][d];\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      if (t[ni][nj] == '#' || (t[ni][nj] == 'S' && nd == 2)) continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#define MAX 1000000000\nusing namespace std;\n\n\nchar map[110][110];\n\nint mark[110][110][11][11][4];\n\nstruct node\n{\n\tint x,y,p,q,d;\n};\n\n\nint main()\n{\n\n\tnode ss,tt;\n\tint m,n,i,j,ii,jj,k,A,d;\n\tint sx,sy,ex,ey;\n\n\tint dir[4][2]={-1,0,0,1,1,0,0,-1};\n\tint Q[4]={1,0,3,2};\n\tint P[4]={3,2,1,0};\n\n\twhile(cin>>m>>n>>A)\n\t{\n\t\tfor(i=0;i<m;i++)\n\t\t\tscanf(\"%s\",map[i]);\n\n\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tfor(ii=0;ii<=A;ii++)\n\t\t\t\t\tfor(jj=0;jj<=A;jj++)\n\t\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t\t\tmark[i][j][ii][jj][k]=0;\n\n\t\tfor(i=0;i<m;i++)\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(map[i][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G')\n\t\t\t\t{\n\t\t\t\t\tex=i;\n\t\t\t\t\tey=j;\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor(i=0;i<=A;i++)\n\t\t\tfor(j=0;j<=A;j++)\n\t\t\t\tmark[sx][sy][i][j][0]=-1;\n\t//\tmark[sx][sy][A][A][0]=-1;\n\t\tmark[sx][sy][A][A][2]=true;\n\n\t\tnode ss;\n\t\tss.x=sx;\n\t\tss.y=sy;\n\t\tss.p=ss.q=A;\n\t\tss.d=2;\n\t\tqueue <node> q;\n\t\tq.push(ss);\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tss=q.front();\n\t\t\tq.pop();\n\t\t//\tcout<<ss.x<<\" \"<<ss.y<<\" \"<<ss.p<<\" \"<<ss.q<<\" \"<<ss.d<<endl;\n\n\t\t\ttt.x=ss.x+dir[ss.d][0];\n\t\t\ttt.y=ss.y+dir[ss.d][1];\n\t\t\ttt.p=ss.p;\n\t\t\ttt.q=ss.q;\n\t\t\ttt.d=ss.d;\n\t\t\tif(tt.x<0||tt.x==m||tt.y<0||tt.y==n)\n\t\t\t\tcontinue;\n\t\t\tif(map[tt.x][tt.y]=='#')\n\t\t\t\tcontinue;\n\t\t\tif(mark[tt.x][tt.y][tt.p][tt.q][tt.d]==-1)\n\t\t\t\tcontinue;\n\n\t\t\tif(!mark[tt.x][tt.y][tt.p][tt.q][tt.d])\n\t\t\t{\n\t\t\t\tmark[tt.x][tt.y][tt.p][tt.q][tt.d]=true;\n\t\t\t\tq.push(tt);\n\t\t\t}\n\n\t\t\tif(map[tt.x][tt.y]=='.')//canput mirror\n\t\t\t{\n\n\t\t\t//P\n\t\t\tif(tt.p)\n\t\t\t{\n\t\t\t\ttt.p--;\n\t\t\t\t\n\t\t\t\t\ttt.d=P[tt.d];\n\t\t\t\t\tif(!mark[tt.x][tt.y][tt.p][tt.q][tt.d])\n\t\t\t\t\t{\n\t\t\t\t\t\tmark[tt.x][tt.y][tt.p][tt.q][tt.d]=true;\n\t\t\t\t\t\tq.push(tt);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t}\n\n\t\t\t//Q\n\t\t\tif(tt.q)\n\t\t\t{\n\t\t\t\ttt.q--;\n\t\t\t\n\t\t\t\t\ttt.d=Q[tt.d];\n\t\t\t\t\tif(!mark[tt.x][tt.y][tt.p][tt.q][tt.d])\n\t\t\t\t\t{\n\t\t\t\t\t\tmark[tt.x][tt.y][tt.p][tt.q][tt.d]=true;\n\t\t\t\t\t\tq.push(tt);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\ttt.q=ss.q;\n\t\t\t}\n\n\t\t\t}\n\t\t\t\n\n\n\t\t}\n\n\t\tint ans=MAX;\n\n\t\tfor(i=0;i<=A;i++)\n\t\t\tfor(j=0;j<=A;j++)\n\t\t\t\tfor(d=0;d<4;d++)\n\t\t\t\t\tif(mark[ex][ey][i][j][d])\n\t\t\t\t\t\tans=min(ans,A-i+A-j);\n\n\t\tif(ans==MAX)\n\t\t\tans=-1;\n\t\tcout<<ans<<endl;\n\n\n\n\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define rep(i,N) for(int i = 0 ; (i) < (int)(N) ; i++)\n\nstruct NODE{\n\tint x,y,dir;\n\tint P,Q;\n\tNODE(int x,int y,int dir,int P,int Q) : x(x) , y(y) , dir(dir) , P(P) , Q(Q) {}\n};\nchar c[110][110];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint memo[110][110][4][11][11];\nint main(){\n\tmemset(memo,-1,sizeof(memo));\n\tint H,W,A;\n\tcin >> H >> W >> A;\n\tint sx,sy,gx,gy;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] == 'S' ){\n\t\t\t\tsx = j , sy = i;\n\t\t\t}\n\t\t\tif( c[i][j] == 'G' ){\n\t\t\t\tgx = j , gy = i;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<NODE> Q;\n\t\n\tQ.push(NODE(sx,sy+1,0,A,A));\n\tmemo[sx][sy+1][0][A][A] = 0;\n\tint answer = 1e9;\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\n\t\tif( q.x < 0 || q.x >= W || q.y >= H || q.y < 0 || c[q.y][q.x] == '#' || c[q.y][q.x] == 'S') continue;\n\t\tif( q.x == gx && q.y == gy ){\n\t\t\tanswer = min( answer , 2*A - q.P - q.Q );\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint pp = 0 , qq = 0;\n\t\t\tif( (q.dir+2)%4 == i ) continue;\n\t\t\tif( q.dir == 0 && i == 1 || q.dir == 1 && i == 0 || q.dir == 2 && i == 3 || q.dir == 3 && i == 2 ) pp = 1;\n\t\t\tif( q.dir == 0 && i == 3 || q.dir == 3 && i == 0 || q.dir == 2 && i == 1 || q.dir == 1 && i == 2 ) qq = 1;\n\t\t\tint nx = q.x + dx[i];\n\t\t\tint ny = q.y + dy[i];\n\t\t\tif( nx < 0 || nx >= W || ny >= H || ny < 0 || q.P-pp < 0 || q.Q-qq < 0 || c[ny][nx] == '#' || ~memo[nx][ny][i][q.P-pp][q.Q-qq] ) continue;\n\t\t\tmemo[nx][ny][i][q.P-pp][q.Q-qq] = 0;\n\t\t\t//cout << nx << \" \" << ny << \" \" << i << \" \" << q.P-pp << \" \" << q.Q-qq << endl;\n\t\t\tQ.push(NODE(nx,ny,i,q.P-pp,q.Q-qq));\n\t\t}\n\t\t\n\t}\n\t\n\tif( answer > 1e8 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << answer << endl;\n\t}\n\t\n};"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nvoid pr(int x,int y,int dir){\n  char ch[]={'V','^','>','<'};\n  char tmp=mp[y][x];\n  mp[y][x]=ch[dir];\n  for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  mp[y][x]=tmp;\n  cout<<\"------\"<<endl;\n}\n\n\nint ans=1e9;//,used[101][101][10][10][4];\nint used[101][101][2];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(2*A-(p+q)>=ans)return;\n  //if(used[x][y][p][q][dir]++)return;\n  cout<<y<<\" \"<<x<<endl;\n\n  vector<int> X,Y,ch;\n\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')used[i][j][0]=1,dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nDef d[110][110][11][4];\nclass DIJ{\n\tpublic:\n\tDef n,m,A;\n\tvs in;\n\tDIJ(Def size,Def w,vs fi,Def q){\n\t\tn=size;\n\t\tin=fi;\n\t\tm=w;\n\t\tA=q;\n\t}\n\tvoid dij(){\n\t\trep(i,110)rep(j,110)rep(l,11)rep(q,4)\n\t\t\td[i][j][l][q]=inf;\n\t\tint gx,gy;\n\t\tpriority_queue<tp>q;\n\t\trep(i,in.size())rep(j,in[0].size())\n\t\t\tif(in[i][j]=='G')gx=i,gy=j;\n\t\t\telse if(in[i][j]=='S'){\n\t\t\t\tif(i+1<n&&in[i+1][j]!='#'){\n\t\t\t\t\td[i+1][j][0][1]=0;\n\t\t\t\t\tq.push(tp(0,i+1,j,0,1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,a,to;\n\t\t\ttie(cost,x,y,a,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][a][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tint na=a,nb=cost;\n\t\t\t\tint nto=k;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tif(in[x][y]=='S'&&nto-to)continue;\n\t\t\t\tif(in[nx][ny]=='S'&&nto%2)continue;\n\t\t\t\tif((to+2)%4==nto)continue;\n\t\t\t\tif(nto!=to){\n\t\t\t\t\tif(to%2){\n\t\t\t\t\t\tif((to+1)%4==nto)na++;\n\t\t\t\t\t\telse nb++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((to+1)%4==nto)nb++;\n\t\t\t\t\t\telse na++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(na>A||nb>A)continue;\n\t\t\t\tif(nb<d[nx][ny][na][nto]){\n\t\t\t\t\td[nx][ny][na][nto]=nb;\n\t\t\t\t\tq.push(tp(-nb,nx,ny,na,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,11)rep(j,4)if(d[gx][gy][i][j]!=inf){\n\t\t\tcmin(out,i+d[gx][gy][i][j]);\n\t\t}\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(n,m,in,k);\n\tdij.dij();\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool memo[100][100][4][11][11];\nstruct p {\n\tint y, x, d, r, l;\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\tvector<string> b(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> b[i];\n\t}\n\tqueue<p> q;\n\tpii goal, start;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < M; j++) {\n\t\t\tif(b[i][j]=='S') {\n\t\t\t\tmemo[i][j][0][0][0] = true;\n\t\t\t\tq.push((p){i,j,0,0,0});\n\t\t\t\tstart=pii(i,j);\n\t\t\t}\n\t\t\tif(b[i][j]=='G') {\n\t\t\t\tgoal=pii(i,j);\n\t\t\t}\n\t\t}\n\t}\n\twhile(q.size()) {\n\t\tint dxy[] = {1,0,-1,0,1};\n\t\tp t = q.front(); q.pop();\n\t\t//cout << t.y << \" \" << t.x << \" \" << t.d << endl;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint nx, ny;\n\t\t\tny = t.y + dxy[i];\n\t\t\tnx = t.x + dxy[i+1];\n\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\t\t\tif(b[ny][nx] == '#') continue;\n\n\t\t\tif(ny==start.first && nx==start.second && i==2) continue;\n\n\t\t\tif(i==(t.d+2)%4) {\n\t\t\t\tcontinue; // turn\n\t\t\t}\n\t\t\telse if(i==t.d) {\n\t\t\t\t// go straight\n\t\t\t\tif(memo[ny][nx][i][t.r][t.l]) continue;\n\t\t\t\tmemo[ny][nx][i][t.r][t.l] = true;\n\t\t\t\tq.push((p){ny,nx,i,t.r,t.l});\n\t\t\t}\n\t\t\telse if(b[t.y][t.x] == '.') {\n\t\t\t\tif(i+t.d==3){\n\t\t\t\t\t// type P\n\t\t\t\t\tif(t.r+1 > A) continue;\n\t\t\t\t\tif(memo[ny][nx][i][t.r+1][t.l]) continue;\n\t\t\t\t\tmemo[ny][nx][i][t.r+1][t.l] = true;\n\t\t\t\t\tq.push((p){ny,nx,i,t.r+1,t.l});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// type Q\n\t\t\t\t\tif(t.l+1 > A) continue;\n\t\t\t\t\tif(memo[ny][nx][i][t.r][t.l+1]) continue;\n\t\t\t\t\tmemo[ny][nx][i][t.r][t.l+1] = true;\n\t\t\t\t\tq.push((p){ny,nx,i,t.r,t.l+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i <= A; i++) {\n\t\tfor(int j = 0; j <= A; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tif(memo[goal.first][goal.second][k][i][j]) {\n\t\t\t\t\tif(res+1) res = min(res, i+j);\n\t\t\t\t\telse res = i+j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, A;\nchar S[200][200];\nll dp[100][100][4][11][11];\n\nconst ll INF = 1LL << 50;\nconst ll dy[4] = { -1, +0, +1, +0 };\nconst ll dx[4] = { +0, +1, +0, -1 };\n\nstruct state {\n  ll y, x, dir, p, q, dist;\n  bool operator<(const state &s) const {\n    return dist > s.dist;\n  }\n};\n\nint main(void) {\n  cin >> N >> M >> A;\n  REP(i, 0, N) REP(j, 0, M) cin >> S[i][j];\n\n  ll sy, sx, gy, gx;\n  REP(i, 0, N) REP(j, 0, M) {\n    if(S[i][j] == 'S') {\n      sy = i;\n      sx = j;\n    }\n    if(S[i][j] == 'G') {\n      gy = i;\n      gx = j;\n    }\n  }\n\n  REP(y, 0, N) REP(x, 0, M) REP(dir, 0, 4) REP(p, 0, A + 1) REP(q, 0, A + 1) dp[y][x][dir][p][q] = INF;\n\n  priority_queue<state> que;\n  if(sy + 1 < N) que.push((state) { sy + 1, sx, 2, 0, 0, 0 });\n\n  while(!que.empty()) {\n    state s = que.top();\n    que.pop();\n\n    ll y = s.y, x = s.x, dir = s.dir, p = s.p, q = s.q, dist = s.dist;\n\n    if(dp[y][x][dir][p][q] <= dist) break;\n    dp[y][x][dir][p][q] = dist;\n\n    if(y == gy && x == gx) {\n      cout << dist << endl;\n      return 0;\n    }\n\n    REP(k, -1, 2) {\n      if(y == sy && x == sx && k != 0) continue;\n      ll ndir = (dir + k + 4) % 4;\n      ll ny = y + dy[ndir];\n      ll nx = x + dx[ndir];\n      ll np = p;\n      ll nq = q;\n      if(dir % 2 == 0) {\n        np += (k == -1 ? 1 : 0);\n        nq += (k == +1 ? 1 : 0);\n      } else {\n        np += (k == +1 ? 1 : 0);\n        nq += (k == -1 ? 1 : 0);\n      }\n      if(0 <= ny && ny < N && 0 <= nx && nx < M && S[ny][nx] != '#' && np <= A && nq <= A) {\n        que.push((state) { ny, nx, ndir, np, nq, np + nq });\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n#define INF 100\nusing namespace std;\nstruct data{\n\tint x,y,p,q,dir;\n\tdata(){}\n\tdata(int yy,int xx,int dd,int pp,int qq){\n\t\tx=xx;\n\t\ty=yy;\n\t\tp=pp;\n\t\tq=qq;\n\t\tdir=dd;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn q>d.q;\n\t}\n};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint n,m,a;\nint fie[101][101];\nint dp[101][101][4][11];\nint sx,sy,gx,gy;\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tdp[i][j][k][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(sy,sx,1,0,0));\n\tdp[sy][sx][1][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.y][q.x][q.dir][q.p]<q.q)continue;\n\t\tif(0<=q.x+dx[q.dir] && q.x+dx[q.dir]<m && 0<=q.y+dy[q.dir] && q.y+dy[q.dir]<n){\n\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]!=-1 && dp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]>q.q){\n\t\t\t\tdp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]=q.q;\n\t\t\t\tque.push(data(q.y+dy[q.dir],q.x+dx[q.dir],q.dir,q.p,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.p<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=3;\n\t\t\tif(q.dir==1)ndir=2;\n\t\t\tif(q.dir==2)ndir=1;\n\t\t\tif(q.dir==3)ndir=0;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p+1]>q.q){\n\t\t\t\tdp[q.y][q.x][ndir][q.p+1]=q.q;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p+1,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.q<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=1;\n\t\t\tif(q.dir==1)ndir=0;\n\t\t\tif(q.dir==2)ndir=3;\n\t\t\tif(q.dir==3)ndir=2;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p]>q.q+1){\n\t\t\t\tdp[q.y][q.x][ndir][q.p]=q.q+1;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p,q.q+1));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tres=min(res,dp[gy][gx][j][i]+i);\n\t\t}\n\t}\n\treturn res!=INF?res:-1;\n}\n\nint main(void){\n\tscanf(\"%d %d %d %d\",&n,&m,&a);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]=='S')sx=j,sy=i,fie[i][j]=-1;\n\t\t\tif(str[j]=='G')gx=j,gy=i,fie[i][j]=2;\n\t\t\tif(str[j]=='#')fie[i][j]=-1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dijk());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Data{\n  int x,y,dir,P,Q,cost;\n  Data(int x=IINF,int y=IINF,int dir=IINF,int P=IINF,int Q=IINF,int cost=IINF):x(x),y(y),dir(dir),P(P),Q(Q),cost(cost){}\n  bool operator < (const Data& a)const{\n    return P+Q < a.P+a.Q;\n  }\n};\n\nint H,W,A,sp_x,sp_y;\nchar field[101][101];\nint mincost[101][101][11][11][4];\nint dx[] = {1,0,-1,0}; // 右、下、左、上\nint dy[] = {0,1,0,-1};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline int getType(int c_dir,int n_dir){\n  if( c_dir == 0 ){\n    if( n_dir == 3 ) return 0; // P -> 0, Q -> 1\n    if( n_dir == 1 ) return 1;\n  } else if( c_dir == 1 ){\n    if( n_dir == 2 ) return 0;\n    if( n_dir == 0 ) return 1;\n  } else if( c_dir == 2 ){\n    if( n_dir == 1 ) return 0;\n    if( n_dir == 3 ) return 1;\n  } else{\n    if( n_dir == 0 ) return 0;\n    if( n_dir == 2 ) return 1;\n  }\n  return -1;\n}\n\nint main(){\n  cin >> H >> W >> A;\n  rep(i,H)rep(j,W){\n    cin >> field[i][j];\n    if( field[i][j] == 'S' ) sp_x = j, sp_y = i;\n  }\n\n  rep(i,H)rep(j,W)rep(k,A+1)rep(l,A+1)rep(m,4)mincost[i][j][k][l][m] = IINF;\n  priority_queue<Data> Q;\n  if( isValid(sp_x+dx[1],sp_y+dy[1]) && field[sp_y+dy[1]][sp_x+dx[1]] != '#' ){\n    Q.push(Data(sp_x+dx[1],sp_y+dy[1],3,A,A,1));\n    mincost[sp_y][sp_x][A][A][3] = 1;\n  }\n  while(!Q.empty()){\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    //cout << \"(\" << x << \",\" << y << \") \" << data.P << \",\" << data.Q << endl;\n    if( field[y][x] == 'G' ){\n      cout << 2*A-(data.P+data.Q) << endl;\n      return 0;\n    }\n    rep(i,4){\n      if( i == data.dir ) continue;\n      int nx = x + dx[i], ny = y + dy[i];\n      if( field[ny][nx] == 'S' ) continue;\n      if(!isValid(nx,ny))continue;\n      if(field[ny][nx] == '#')continue;\n      int next_P = data.P, next_Q = data.Q;\n      int type = getType(data.dir,i);\n      if( type == 0 ) next_P--;\n      if( type == 1 ) next_Q--;\n      if( next_P < 0 || next_Q < 0) continue;\n      if(mincost[ny][nx][next_P][next_Q][i] > data.cost+1){\n\tmincost[ny][nx][next_P][next_Q][i] = data.cost+1;\n\tQ.push(Data(nx,ny,(i+2)%4,next_P,next_Q,data.cost+1));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint H, W, A, sx, sy, gx, gy, dx[] = { 0, 1, 0, -1 }, dy[] = { 1, 0, -1, 0 }; bool vis[109][109][4][15][15]; string s[109];\nvoid dfs(int x, int y, int dir, int mp, int mq) {\n\tvis[x][y][dir][mp][mq] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif ((i ^ 2) == dir) continue;\n\t\tint tx = x + dx[i], ty = y + dy[i], nmp = mp + ((i ^ 1) == dir), nmq = mq + ((i ^ 3) == dir);\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && nmp <= A && nmq <= A && !vis[tx][ty][i][nmp][nmq]) {\n\t\t\tdfs(tx, ty, i, nmp, nmq);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> H >> W >> A;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == 'S') sx = i, sy = j;\n\t\t\tif (s[i][j] == 'G') gx = i, gy = j;\n\t\t}\n\t}\n\tif (sx + 1 == H || s[sx + 1][sy] == '#') cout << \"-1\\n\";\n\telse {\n\t\tdfs(sx + 1, sy, 1, 0, 0);\n\t\tint ret = 1 << 30;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j <= A; j++) {\n\t\t\t\tfor (int k = 0; k <= A; k++) {\n\t\t\t\t\tif (vis[gx][gy][i][j][k] && ret > j + k) ret = j + k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ret == 1 << 30 ? -1 : ret) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n}State;\n \nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n \n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n \nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n \nint dist[110][110][4][11][11];\n \nint bfs(){\n    queue<State> que;\n    //map<State, int> dist;\n    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n     \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n         \tif(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n            for(int i=-1; i<2; i++){\n                if(nh == Sh && nw == Sw && i>=0) break;\n                    State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                 \n                if(dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] < 0){\n                    dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] = dist[u.h][u.w][u.dir][u.pq[0]][u.pq[1]];\n                    if(i >= 0)\n                        dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]];\n                     \n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n \nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n     \n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n     \n    cout << bfs() << endl;\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    //for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    q.push(make_tuple(S.first,S.second,1,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(masu[i][j] == 'S' && (usedP|usedQ)) continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Data{\n  int x,y,dir,P,Q,cost;\n  Data(int x=IINF,int y=IINF,int dir=IINF,int P=IINF,int Q=IINF,int cost=IINF):x(x),y(y),dir(dir),P(P),Q(Q),cost(cost){}\n  bool operator < (const Data& a)const{\n    return P+Q < a.P+a.Q;\n  }\n};\n\nint H,W,A,sp_x,sp_y;\nchar field[101][101];\nint mincost[101][101][11][11][4];\nint dx[] = {1,0,-1,0}; // 右、下、左、上\nint dy[] = {0,1,0,-1};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline int getType(int c_dir,int n_dir){\n  if( c_dir == 0 ){\n    if( n_dir == 3 ) return 0; // P -> 0, Q -> 1\n    if( n_dir == 1 ) return 1;\n  } else if( c_dir == 1 ){\n    if( n_dir == 2 ) return 0;\n    if( n_dir == 0 ) return 1;\n  } else if( c_dir == 2 ){\n    if( n_dir == 1 ) return 0;\n    if( n_dir == 3 ) return 1;\n  } else{\n    if( n_dir == 0 ) return 0;\n    if( n_dir == 2 ) return 1;\n  }\n  return -1;\n}\n\nint main(){\n  cin >> H >> W >> A;\n  rep(i,H)rep(j,W){\n    cin >> field[i][j];\n    if( field[i][j] == 'S' ) sp_x = j, sp_y = i;\n  }\n\n  rep(i,H)rep(j,W)rep(k,A+1)rep(l,A+1)rep(m,4)mincost[i][j][k][l][m] = IINF;\n  priority_queue<Data> Q;\n  if( isValid(sp_x+dx[1],sp_y+dy[1]) && field[sp_y+dy[1]][sp_x+dx[1]] != '#' ){\n    Q.push(Data(sp_x+dx[1],sp_y+dy[1],3,A,A,1));\n    mincost[sp_y][sp_x][A][A][3] = 1;\n  }\n  while(!Q.empty()){\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    //cout << \"(\" << x << \",\" << y << \") \" << data.P << \",\" << data.Q << endl;\n    if( field[y][x] == 'G' ){\n      cout << 2*A-(data.P+data.Q) << endl;\n      return 0;\n    }\n    rep(i,4){\n      if( i == data.dir ) continue;\n      int nx = x + dx[i], ny = y + dy[i];\n      if( field[ny][nx] == 'S' && i == 3 ) continue;\n      if(!isValid(nx,ny))continue;\n      if(field[ny][nx] == '#')continue;\n      int next_P = data.P, next_Q = data.Q;\n      int type = getType(data.dir,i);\n      if( type == 0 ) next_P--;\n      if( type == 1 ) next_Q--;\n      if( next_P < 0 || next_Q < 0) continue;\n      if(mincost[ny][nx][next_P][next_Q][i] > data.cost+1){\n\tmincost[ny][nx][next_P][next_Q][i] = data.cost+1;\n\tQ.push(Data(nx,ny,(i+2)%4,next_P,next_Q,data.cost+1));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  int sz = 0;\n  Graph G;\n  map<int,int> id;\n  int sid = idx(sx,sy+1,2,0,0);\n  queue<tuple<int,int,int,int,int>> q;\n  q.push(make_tuple(0,0,sx,sy+1,2));\n  id[sid] = sz++;\n  G.PB(vector<Edge>());\n  \n  while(!q.empty()){\n\tint a1, a2, x, y, d;\n\ttie(a1,a2,x,y,d) = q.front(); q.pop();\n\n\tint fr = idx(x,y,d,a1,a2);\n\n\tif(vs[y][x] == '.'){\n\t  if(a1 < A){\n\t\tint td = 3 - d;\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#')){\n\t\t  int toid = idx(tx,ty,td,a1+1,a2);\n\t\t  if(!id.count(toid)){\n\t\t\tid[toid] = sz++;\n\t\t\tG.PB(vector<Edge>());\n\t\t\tq.push(make_tuple(a1+1,a2,tx,ty,td));\n\t\t  }\n\t\t  G[id[fr]].PB(Edge(id[toid], 1));\n\t\t}\n\t  }\n\t  if(a2 < A){\n\t\tint td = d-(d%2*2-1);\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#')){\n\t\t  int toid = idx(tx,ty,td,a1,a2+1);\n\t\t  if(!id.count(toid)){\n\t\t\tid[toid] = sz++;\n\t\t\tG.PB(vector<Edge>());\n\t\t\tq.push(make_tuple(a1,a2+1,tx,ty,td));\n\t\t  }\n\t\t  G[id[fr]].PB(Edge(id[toid], 1));\n\t\t}\n\t  }\n\t}\n\t\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint to = idx(tx,ty,d,a1,a2);\n\tif(!id.count(to)){\n\t  id[to] = sz++;\n\t  G.PB(vector<Edge>());\n\t  q.push(make_tuple(a1,a2,tx,ty,d));\n\t}\n\tG[id[fr]].PB(Edge(id[to], 0));\n  }\n\n  VI dist(sz);\n  Dijkstra(G, dist, id[sid]);\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tif(id.count(tid))\n\t  ans = min(ans, dist[id[tid]]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nchar g[100][128];\n\nint dp[11][100][100][4];\n\nenum{\n  LEFT = 0,\n  DOWN = 1,\n  RIGHT = 2,\n  UP = 3\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\ninline int encode(int a1, int a2, int x, int y, int dir){\n  return dir | (y << 2) | (x << (2 + 8)) | (a2 << (2 + 8 + 8)) | (a1 << (2 + 8 + 8 + 4));\n}\n\ninline void decode(int val, int &a1, int &a2, int &x, int &y, int &dir){\n  a1 = (val >> (2 + 8 + 8 + 4)) & ((1 << 4) - 1);\n  a2 = (val >> (2 + 8 + 8)) & ((1 << 4) - 1);\n  x = (val >> (2 + 8)) & ((1 << 8) - 1);\n  y = (val >> (2)) & ((1 << 8) - 1);\n  dir = val & ((1 << 2) - 1);\n}\n\nint main(){\n  int h, w, a; scanf(\"%d%d%d\", &h, &w, &a);\n  REP(i,h) scanf(\"%s\", g[i]);\n  memset(dp, -1, sizeof(dp));\n\n  priority_queue<int> pq;\n  REP(i,h) REP(j,w) if(g[i][j] == 'S'){\n    pq.push(encode(a, a, j, i, DOWN));\n  }\n\n  int ans = 100;\n  while(pq.size()){\n    int a1, a2, x, y, dir;\n    int d = pq.top(); pq.pop();\n    decode(d, a1, a2, x, y, dir);\n\n    // printf(\"a1=%d a2=%d x=%d y=%d dir=%d\\n\", a1, a2, x, y, dir);\n    if(g[y][x] == 'S' && dir == UP) continue;\n    if(dp[a2][y][x][dir] != -1) continue;\n    dp[a2][y][x][dir] = a1;\n\n    if(g[y][x] == 'G'){\n      ans = min(ans, (a - a1) + (a - a2));\n    }\n\n    REP(k,3){\n      int dd = (dir + k + 3) % 4;\n      int xx = x + dx[dd];\n      int yy = y + dy[dd];\n      if(g[y][x] == 'S' && k != 1) continue;\n      if(ISIN(xx, yy, w, h) && (g[yy][xx] != '#' || g[yy][xx] == 'S')){\n        int aa1 = a1;\n        int aa2 = a2;\n        if(k == 0){\n          // turn right\n          if(dir & 1) aa1--;\n          else aa2--;\n        }else if(k == 2){\n          // turn left\n          if(dir & 1) aa2--;\n          else aa1--;\n        }\n\n        if(aa1 >= 0 && aa2 >= 0){\n          if(dp[aa2][yy][xx][dd] == -1){\n            pq.push(encode(aa1, aa2, xx, yy, dd));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans == 100) puts(\"-1\");\n  else printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool visited[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint main() {\n    int N, M, A; scanf(\"%d%d%d\", &N, &M, &A);\n    int sx, sy, gx, gy;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    queue<Elem> que;\n    que.push(Elem{sx, sy, 0, 0, 0});\n\n    while(que.size()) {\n        Elem cur = que.front(); que.pop();\n        int nx, ny, na, nb, nd;\n\n        vector<int> dirs = {cur.dir, 3-cur.dir, cur.dir^1};\n        vector<int> use_a = {0, 1, 0};\n        vector<int> use_b = {0, 0, 1};\n\n        for(int k=0; k<3; k++) {\n            nd = dirs[k];\n            nx = cur.x + dx[ nd ];\n            ny = cur.y + dy[ nd ];\n            na = cur.a + use_a[k];\n            nb = cur.b + use_b[k];\n\n            if(cur.x == sx && cur.y == sy && k != 0) continue;\n            if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n            if(board[nx][ny] == '#') continue;\n            if(na > A || nb > A) continue;\n            if(visited[nx][ny][na][nb][nd]) continue;\n\n            visited[nx][ny][na][nb][nd] = true;\n            que.push(Elem{nx, ny, na, nb, nd});\n        }\n    }\n\n    int ans = INF;\n    for(int i=0; i<=A; i++) {\n        for(int j=0; j<=A; j++) {\n            for(int k=0; k<4; k++) {\n                if(!visited[gx][gy][i][j][k]) continue;\n                ans = min(ans, i + j);\n            }\n        }\n    }\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nchar g[100][128];\n\nint dp[11][100][100][4];\n\nenum{\n  LEFT = 0,\n  DOWN = 1,\n  RIGHT = 2,\n  UP = 3\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\ninline int encode(int a1, int a2, int x, int y, int dir){\n  return dir | (y << 2) | (x << (2 + 8)) | (a2 << (2 + 8 + 8)) | (a1 << (2 + 8 + 8 + 4));\n}\n\ninline void decode(int val, int &a1, int &a2, int &x, int &y, int &dir){\n  a1 = (val >> (2 + 8 + 8 + 4)) & ((1 << 4) - 1);\n  a2 = (val >> (2 + 8 + 8)) & ((1 << 4) - 1);\n  x = (val >> (2 + 8)) & ((1 << 8) - 1);\n  y = (val >> (2)) & ((1 << 8) - 1);\n  dir = val & ((1 << 2) - 1);\n}\n\nint main(){\n  int h, w, a; scanf(\"%d%d%d\", &h, &w, &a);\n  REP(i,h) scanf(\"%s\", g[i]);\n  memset(dp, -1, sizeof(dp));\n\n  priority_queue<int> pq;\n  REP(i,h) REP(j,w) if(g[i][j] == 'S'){\n    pq.push(encode(a, a, j, i, DOWN));\n  }\n\n  int ans = 100;\n  while(pq.size()){\n    int a1, a2, x, y, dir;\n    int d = pq.top(); pq.pop();\n    decode(d, a1, a2, x, y, dir);\n\n    // printf(\"a1=%d a2=%d x=%d y=%d dir=%d\\n\", a1, a2, x, y, dir);\n\n    if(dp[a2][y][x][dir] != -1) continue;\n    dp[a2][y][x][dir] = a1;\n\n    if(g[y][x] == 'G'){\n      ans = min(ans, (a - a1) + (a - a2));\n    }\n\n    REP(k,3){\n      int dd = (dir + k + 3) % 4;\n      int xx = x + dx[dd];\n      int yy = y + dy[dd];\n      if(g[y][x] == 'S' && k != 1) continue;\n      if(ISIN(xx, yy, w, h) && g[yy][xx] != '#'){\n        int aa1 = a1;\n        int aa2 = a2;\n        if(k == 0){\n          // turn left\n          if(dir == DOWN || dir == UP) aa1--;\n          else aa2--;\n        }else if(k == 2){\n          // turn right\n          if(dir == DOWN || dir == UP) aa2--;\n          else aa1--;\n        }\n\n        if(aa1 >= 0 && aa2 >= 0){\n          if(dp[aa2][yy][xx][dd] == -1){\n            pq.push(encode(aa1, aa2, xx, yy, dd));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans == 100) puts(\"-1\");\n  else printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\n\nstruct Data{\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\n\tvoid copy(bool arg_check[100][100]){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tcheck[i][k] = arg_check[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n\tbool check[100][100];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\tchar map[H][W+1];\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tminTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tfirst.check[i][k] = false;\n\t\t}\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={1,0,-1,0};\nconst int p[4]={3,2,1,0};\nconst int q[4]={1,0,3,2};\n\nstring board[110];\nint dist[100][100][4][11][11];\n\nint main(void){\n\tint n,m,a;\n\tcin >> n >> m >> a;\n\trep(i,n) cin >> board[i];\n\n\tint si=0,sj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='S') si=i,sj=j;\n\n\tint gi=0,gj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='G') gi=i,gj=j;\n\t\n\trep(i,n)rep(j,m)rep(d,4)rep(pi,a+1)rep(qi,a+1) dist[i][j][d][pi][qi]=100;\n\n\tusing state=tuple<int,int,int,int,int>;\n\t\n\tdeque<state> que;\n\tdist[si][sj][0][a][a]=0;\n\tque.push_back(state(si,sj,0,a,a));\n\n\twhile(!que.empty()){\n\t\tint ci,cj,d,pi,qi;\n\t\ttie(ci,cj,d,pi,qi)=que.front();\n\t\tque.pop_front();\n\n\t\tif(ci==si && cj == sj && d==2) continue;\n\t\t\n\t\t{\n\t\t\tconst int ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][d][pi][qi],dist[ci][cj][d][pi][qi])) \n\t\t\t\tque.push_front(state(ni,nj,d,pi,qi)); \t\n\t\t}\n\n\t\tif(board[ci][cj]=='.'){\n\t\t\tif(pi>0){\n\t\t\t\tconst int nd=p[d],npi=pi-1,nqi=qi,ni=ci+dy[nd],nj=cj+dx[nd];\n\t\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ni,nj,nd,npi,nqi));\n\t\t\t}\n\t\t\tif(qi>0){\n\t\t\t\tconst int nd=q[d],npi=pi,nqi=qi-1,ni=ci+dy[nd],nj=cj+dx[nd];\n\t\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1))\n\t\t\t\t\tque.push_back(state(ni,nj,nd,npi,nqi));\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tint ans=100;\n\trep(d,4)rep(pi,a+1)rep(qi,a+1) chmin(ans,dist[gi][gj][d][pi][qi]);\n\tif(ans==100) ans=-1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d=2,h,w,n,sx,sy,gx,gy,ans=-1;\nbool dp[111][111][4][11][11];\nstring s[111];\nstruct T{\n    int y,x,d,l,r,cost;\n    T(int a,int b,int c,int f,int e,int w){y=a,x=b,d=c,l=f,r=e,cost=w;}\n};\nsigned main(){\n    cin>>h>>w>>n;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n        if(s[i][j]=='S')sy=i,sx=j;\n        if(s[i][j]=='G')gy=i,gx=j;\n    }\n    deque<T>q;\n    q.push_back(T(sy,sx,2,0,0,0));\n    dp[sy][sx][2][0][0]=1;\n    while(!q.empty()){\n        T a=q.front();q.pop_front();\n        d=a.d;\n        if(s[a.y][a.x]=='G'){ans=a.cost;break;}\n        if(d==0&&s[a.y][a.x]=='S')continue;\n        int y=a.y+dy[d];\n        int x=a.x+dx[d];\n        if(y<0||x<0||y>=h||x>=w)continue;\n        if(s[y][x]=='#')continue;\n        if(1){\n            T t=T(y,x,d,a.l,a.r,a.cost);\n            if(dp[y][x][d][a.l][a.r+1])continue;\n            dp[y][x][d][a.l][a.r+1]=1;\n            q.push_front(t);\n        }\n        if(a.l<n){\n            T t=T(y,x,3-d,a.l+1,a.r,a.cost+1);\n            if(dp[y][x][3-d][a.l+1][a.r])continue;\n            dp[y][x][3-d][a.l+1][a.r]=1;\n            q.push_back(t);\n        }\n        if(a.r<n){\n            T t=T(y,x,d^1,a.l,a.r+1,a.cost+1);\n            if(dp[y][x][d^1][a.l][a.r+1])continue;\n            dp[y][x][d^1][a.l][a.r+1]=1;\n            q.push_back(t);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\nchar map[100][101];\n\nstruct Data{\n\tDIR in_dir,out_dir;\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n//row,col???????????????????????????????????¢??°\nbool canPut(Data data[20],int num_data,int row,int col){\n\n\tbool FLG = true;\n\tbool block_FLG;\n\n\tfor(int i = 0; i < num_data; i++){\n\t\tif(data[i].row == row && data[i].col == col){\n\t\t\tFLG = false;\n\t\t\tbreak;\n\t\t}else if(data[i].row == row){\n\n\t\t\tif(col > data[i].col){\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = data[i].col; k <= col; k++){\n\t\t\t\t\tif(map[row][k] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tif(data[i].in_dir == East){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = col; k <= data[i].col; k++){\n\t\t\t\t\tif(map[row][k] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tif(data[i].in_dir == West){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(data[i].col == col){\n\n\t\t\t//map[row][col]???,map[data[i].row][data[i].col]??????????????????????????????????????????data[i]???????????¨???data[i]???in_dir????????´????????????????????????\n\t\t\tif(row > data[i].row){\n\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = data[i].row; k <= row; k++){\n\t\t\t\t\tif(map[k][col] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\n\t\t\t\t\tif(data[i].in_dir == South){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = row; k <= data[i].row; k++){\n\t\t\t\t\tif(map[k][col] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tif(data[i].in_dir == North){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FLG;\n}\n\nvoid copyData(Info& to,Info from){\n\tfor(int k = 0; k < from.num_data;k++){\n\t\tto.data[k].row = from.data[k].row;\n\t\tto.data[k].col = from.data[k].col;\n\t\tto.data[k].mirror = from.data[k].mirror;\n\t\tto.data[k].in_dir = from.data[k].in_dir;\n\t\tto.data[k].out_dir = from.data[k].out_dir;\n\t}\n\tto.num_data = from.num_data;\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tif(i < H-1)minTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(rangeCheck(first.row,first.col) == false || map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n      ans=min(memo[u.y][u.x][u.muki],ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(memo[a][b][u.muki]>=u.numL+u.numR){\n\t  memo[a][b][u.muki]=u.numL+u.numR;\n\t  Q.push(State(a,b,u.muki,u.numL,u.numR));\n\t}\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+1)%4]>=u.numL+u.numR+1){\n\t    memo[a][b][(u.muki+1)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+1)%4)%2==0){\n\t      Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t    }\n\t    if(((u.muki+1)%4)%2==1){\n\t      Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t    }\n\t  }\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+3)%4]>=u.numR+u.numL+1){\n\t    memo[a][b][(u.muki+3)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+3)%4)%2==0){\n\t      Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t    }\n\t    if(((u.muki+3)%4)%2==1){\n\t      Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\ninline bool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\ninline int P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\ninline int Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(p+q>=ans) return;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n??\n//h, w, dir, P, Q\ntypedef struct _State{\n????????int h, w, dir;\n????????vector<int> pq;\n}State;\n??\nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n??\n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n??\nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n??\nint dist[110][110][4][11][11];\n??\nint bfs(){\n????????queue<State> que;\n????????//map<State, int> dist;\n????????memset(dist, -1, sizeof(dist));\n????????State s = State({Sh, Sw, 0, {A, A}});\n????????que.push(s);\n????????dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n??????????\n????????while(!que.empty()){\n????????????????State u = que.front(); que.pop();\n????????????????for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n\t\t\tif(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n????????????????????????for(int i=-1; i<2; i++){\n\t\t\t\tif(nh == Sh && nw == Sw && i>=0) break;\n                \n????????????????????????????????State v({nh, nw, u.dir, u.pq});\n????????????????????????????????if(i >= 0){\n????????????????????????????????????????if(u.pq[i] == 0) continue;\n????????????????????????????????????????v.pq[i]--;\n????????????????????????????????????????v.dir = table[i][u.dir];\n????????????????????????????????}\n??????????????????????????????????\n????????????????????????????????if(dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] < 0){\n????????????????????????????????????????dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] = dist[u.h][u.w][u.dir][u.pq[0]][u.pq[1]];\n????????????????????????????????????????if(i >= 0)\n????????????????????????????????????????????????dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]]++;\n????????????????????????????????????????if(v.h == Gh && v.w == Gw)\n????????????????????????????????????????????????return dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]];\n??????????????????????????????????????????\n????????????????????????????????????????//cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n????????????????????????????????????????que.push(v);\n????????????????????????????????}\n????????????????????????}\n????????????????}\n????????}\n????????return -1;\n}\n??\nint main(){\n????????cin >> N >> M >> A;\n????????field.resize(N);\n????????for(auto &s: field) cin >> s;\n??????????\n????????for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n????????????????if(field[i][j] == 'S')\n????????????????????????Sh = i, Sw = j;\n????????????????if(field[i][j] == 'G')\n????????????????????????Gh = i, Gw = j;\n????????}\n??????????\n????????cout << bfs() << endl;\n??????????\n????????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 100;\nconst int W = 100;\nconst int A = 10;\nconst int INF = 1 << 29;\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\nconst int usep[4] = {3, 2, 1, 0};\nconst int useq[4] = {1, 0, 3, 2};\n\nstruct state{\n  int x, y, d, p, q;\n  state(int y=0, int x=0, int d=0, int p=0, int q=0):x(x),y(y),d(d),p(p),q(q){}\n  bool operator < (const state &s) const {\n    return (p+q) > (s.p+s.q);\n  }\n};\n\nint h, w, a, sy, sx, gy, gx;\nbool G[H][W];\n\nbool check(int y, int x, int d){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return !G[y][x] && (y != sy || x != sx || d != 0);\n}\n\nint solve(){\n  bool f[H][W][4][A+1][A+1];\n  priority_queue<state> pq;\n  state u, u2;\n\n  for(int i=0;i<h*w;i++) for(int j=0;j<4;j++) for(int k=0;k<=a;k++) for(int l=0;l<=a;l++) f[i/w][i%w][j][k][l] = false;\n  \n  /*\n  for(int i=0;i<4;i++) {\n    pq.push(state(sy, sx, i, 0, 0));\n    f[sy][sx][i][0][0] = true;\n  }\n  */\n  pq.push(state(sy, sx, 2, 0, 0));\n  f[sy][sx][2][0][0] = true;\n\n  while(!pq.empty()){\n    u = pq.top();\n    pq.pop();\n\n    if(u.y == gy && u.x == gx) return u.p + u.q;\n\n    u2 = state(u.y+dy[u.d], u.x+dx[u.d], u.d, u.p, u.q);\n    if(check(u2.y, u2.x, u2.d) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n      f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n      pq.push(u2);\n    }\n    \n    if(u.p < a && (u.y != sy || u.x != sx)){\n      u2 = u;\n      u2.d = usep[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.p++;\n      if(check(u2.y, u2.x, u2.d) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n\n    if(u.q < a && (u.y != sy || u.x != sx)){\n      u2 = u;\n      u2.d = useq[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.q++;\n      if(check(u2.y, u2.x, u2.d) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string str;\n  while(cin >> h >> w >> a){\n    for(int i=0;i<h;i++){\n      cin >> str;\n      for(int j=0;j<w;j++){\n        G[i][j] = false;\n        if(str[j] == 'S'){\n          sy = i;\n          sx = j;\n          //G[i][j] = true;\n        } else if(str[j] == 'G'){\n          gy = i;\n          gx = j;\n        } else if(str[j] == '#'){\n          G[i][j] = true;\n        }\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\npii f(pii a, pii b, int x1, int x2){\n    b.first+=x1;\n    b.second+=x2;\n    \n    if(a.first>=b.first && a.second>=b.second)return b;\n    if(a.first<=b.first && a.second<=b.second)return a;\n    abort();\n}\n\nstruct state{\n    int y,x,dir,bs,s;\n};\n\nint main(){\n    int h,w,a;\n    cin>>h>>w>>a;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    pii s,g;\n    rep(i,h)rep(j,w){\n        if(vs[i][j]=='S')s = pii(i,j);\n        if(vs[i][j]=='G')g = pii(i,j);\n    }\n    \n    static int dp[101][101][4][11][11];\n    rep(i,101)rep(j,101)rep(k,4)rep(l,11)rep(m,11)dp[i][j][k][l][m] = INF;\n    dp[s.first][s.second][0][0][0] = 0;\n    \n    queue<state> que;\n    que.push(state{s.first, s.second, 0, 0, 0});\n    \n    // '\\', '/'\n    //テ、ツクツ? テ・ツ渉ウ, テ、ツクツ? テ・ツキツヲ\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    while(que.size()){\n        state q = que.front();\n        que.pop();\n        \n        for(int k = 1;;k++){\n            int ddy = q.y+dy[q.dir]*k;\n            int ddx = q.x+dx[q.dir]*k;\n            \n            if( q.dir == 2 && pii(ddy,ddx)==s)break;\n            if(pii(ddy,ddx)==s)continue;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            int bsnum,snum;\n            \n            //テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==0)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+3)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n            \n            //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==1)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+1)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    rep(i,4){\n        for(int k=1;;k++){\n            int y,x;\n            tie(y,x) = g;\n            int ddy = y+dy[i]*k;\n            int ddx = x+dx[i]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n\n            if( i == 0 && pii(ddy,ddx)==s)break;\n\n            rep(l,a+1){\n                rep(m,a+1){\n                    ans = min(ans, dp[ddy][ddx][(i+2)%4][l][m]);\n                }\n            }\n        }\n    }\n    if(ans>2*a)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\n\nstruct Data{\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\tchar map[H][W+1];\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tminTime[i+1][k][South][A][A] = 0;\n\t\t\t\tmap[i][k] = '#';\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\t//?\\?\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};\n\nstruct node{\n  int x, y, p, q, dir, dis;\n  bool operator<(const node &n) const{ return dis > n.dis; }\n};\n\nstring s[105];\nint d[105][105][11][11][4];\n\nsigned main(void)\n{\n  int h, w, a;\n  cin >> h >> w >> a;\n  REP(i, h) cin >> s[i];\n  int sx, sy, gx, gy;\n  REP(i, h) REP(j, w) {\n    if(s[i][j] == 'S') sx = j, sy = i;\n    else if(s[i][j] == 'G') gx = j, gy = i;\n  }\n\n  memset(d, -1, sizeof(d));\n  priority_queue<node> que;\n  que.push((node){sx, sy, 0, 0, 2, 0});\n  while(que.size()) {\n    node v = que.top(); que.pop();\n    //cout << v.x << \" \" << v.y << \" \" << v.p << \" \" << v.q << \" \" << v.dir << \" \" << v.dis << endl;\n    if(v.x == gx && v.y == gy) {\n      cout << v.dis << endl;\n      return 0;\n    }\n    if(d[v.x][v.y][v.p][v.q][v.dir] >= 0) continue;\n    d[v.x][v.y][v.p][v.q][v.dir] = v.dis;\n    REP(i, 3) {\n      int di = (v.dir+i+3)%4;\n      //cout << \"d:\" << di << endl;\n      if(v.x == sx && v.y == sy && v.dis && dy[di] != 0) continue;\n      if(v.x == sx && v.y == sy && v.dir != di) continue;\n      bool isp = (v.dir+di) == 3, isq = (v.dir+di)%4 == 1;\n      //cout << \"p:\" << isp << \" q:\" << isq << \" \" << di << endl;\n      if(isp && v.p >= a) continue;\n      if(isq && v.q >= a) continue;\n    //  cout << dx[di] << \" \" << dy[di] << \" \" << endl;\n      int x = v.x + dx[di], y = v.y + dy[di];\n      //Anaconda3\\cout << i << \" \" << x << \" \" << y << \" \" << endl;\n      if(IN(0, w, x) && IN(0, h, y) && s[y][x] != '#') {\n        que.push((node){x, y, v.p+isp, v.q+isq, di, v.dis+isp+isq});\n        //cout << \"a\" << endl;\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\nint H, W, A;\nvector<string> s(H);\nint sx, sy, gx, gy;\nconst int MAX_V = 4*11*11*100*100;\nint d[MAX_V];\n\nconst int dx[4] = { 1, 0, -1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nstruct Node {\n    int x, y, p, q, k, id;\n    Node(){}\n    Node(int _x, int _y, int _p, int _q, int _k) : x(_x), y(_y), p(_p), q(_q), k(_k), id(-1) {\n        if (!inside(x, y)) return;\n        if (p < 0 || q < 0) return;\n        if (s[x][y] == '#') return;\n        if (s[x][y] == 'S' && k == 2) return;\n        id = 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k;\n    }\n    Node(int _id) : id(_id) {\n        k = _id % 4; _id /= 4;\n        q = _id % 11; _id /= 11;\n        p = _id % 11; _id /= 11;\n        y = _id % 100; _id /= 100;\n        x = _id;\n        // output(x, y, p, q, k, id);\n        assert(id == 4*11*11*100*x + 4*11*11*y + 4*11*p + 4*q + k);\n    }\n    void print() {\n        output(x, y, p, q, k, id);\n    }\n};\n\nvoid dijkstra() {\n    using State = pair<int, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    fill(d, d + MAX_V, inf);\n\n    Node ns(sx, sy, A, A, 0);\n    d[ns.id] = 0;\n    pq.push(State(0, ns.id));\n\n    while (!pq.empty()) {\n        int cost, id;\n        tie(cost, id) = pq.top(); pq.pop();\n        if (d[id] < cost) continue;\n        Node u(id);\n\n        // output(\"---\");\n        // cout << cost << \" \";\n        // u.print();\n\n        int x = u.x;\n        int y = u.y;\n        int p = u.p;\n        int q = u.q;\n        int k = u.k;\n\n        vector<pair<Node, int>> cands; // v, cost(u->v)\n\n        if (s[x][y] == 'S') {\n            cands.emplace_back(Node(x + dx[k], y + dy[k], p, q, k), 0);\n        }\n        else if (k == 0) {\n            cands.emplace_back(Node(x, y - 1, p, q - 1, 3), 1);\n            cands.emplace_back(Node(x, y + 1, p - 1, q, 1), 1);\n            cands.emplace_back(Node(x + 1, y, p, q, 0), 0);\n        }\n        else if (k == 1) {\n            cands.emplace_back(Node(x - 1, y, p, q - 1, 2), 1);\n            cands.emplace_back(Node(x + 1, y, p - 1, q, 0), 1);\n            cands.emplace_back(Node(x, y + 1, p, q, 1), 0);\n        }\n        else if (k == 2) {\n            cands.emplace_back(Node(x, y - 1, p - 1, q, 3), 1);\n            cands.emplace_back(Node(x, y + 1, p, q - 1, 1), 1);\n            cands.emplace_back(Node(x - 1, y, p, q, 2), 0);\n        }\n        else if (k == 3) {\n            cands.emplace_back(Node(x - 1, y, p - 1, q, 2), 1);\n            cands.emplace_back(Node(x + 1, y, p, q - 1, 0), 1);\n            cands.emplace_back(Node(x, y - 1, p, q, 3), 0);\n        }\n\n        for (const auto& p : cands) {\n            Node v;\n            int c;\n            tie(v, c) = p;\n            if (v.id == -1) continue;\n\n            // cout << c << \" \";\n            // v.print();\n\n            if (d[v.id] > d[u.id] + c) {\n                d[v.id] = d[u.id] + c;\n                pq.push(State(d[v.id], v.id));\n            }\n        }\n\n        // output(\"---\");\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W >> A;\n    s.resize(H);\n    rep(i, H) {\n        cin >> s[i];\n        rep(j, W) {\n            if (s[i][j] == 'S') {\n                sx = i; sy = j;\n            }\n            if (s[i][j] == 'G') {\n                gx = i; gy = j;\n            }\n        }\n    }\n\n    dijkstra();\n\n    int mi = inf;\n    rep(p, A + 1) {\n        rep(q, A + 1) {\n            rep(k, 4) {\n                Node u(gx, gy, p, q, k);\n                // cout << d[u.id] << \" \";\n                // u.print();\n                if (u.id == -1) continue;\n                mi = min(mi, d[u.id]);\n            }\n        }\n    }\n\n    cout << (mi == inf ? -1 : mi) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define rep(i,N) for(int i = 0 ; (i) < (int)(N) ; i++)\n\nstruct NODE{\n\tint x,y,dir;\n\tint P,Q;\n\tNODE(int x,int y,int dir,int P,int Q) : x(x) , y(y) , dir(dir) , P(P) , Q(Q) {}\n};\nchar c[110][110];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint memo[110][110][4][11][11];\nint main(){\n\tmemset(memo,-1,sizeof(memo));\n\tint H,W,A;\n\tcin >> H >> W >> A;\n\tint sx,sy,gx,gy;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] == 'S' ){\n\t\t\t\tsx = j , sy = i;\n\t\t\t}\n\t\t\tif( c[i][j] == 'G' ){\n\t\t\t\tgx = j , gy = i;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<NODE> Q;\n\t\n\tQ.push(NODE(sx,sy,0,A,A));\n\tint answer = 1e9;\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( q.dir == 2 && c[q.y][q.x] == 'S' ) continue;\n\t\tif( q.x < 0 || q.x >= W || q.y >= H || q.y < 0 || c[q.y][q.x] == '#' || c[q.y][q.x] == '#') continue;\n\t\tif( q.x == gx && q.y == gy ){\n\t\t\tanswer = min( answer , 2*A - q.P - q.Q );\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint pp = 0 , qq = 0;\n\t\t\tif( q.dir != i && c[q.y][q.x] == 'S' ) continue;\n\t\t\tif( (q.dir+2)%4 == i ) continue;\n\t\t\tif( q.dir == 0 && i == 1 || q.dir == 1 && i == 0 || q.dir == 2 && i == 3 || q.dir == 3 && i == 2 ) pp = 1;\n\t\t\tif( q.dir == 0 && i == 3 || q.dir == 3 && i == 0 || q.dir == 2 && i == 1 || q.dir == 1 && i == 2 ) qq = 1;\n\t\t\tint nx = q.x + dx[i];\n\t\t\tint ny = q.y + dy[i];\n\t\t\tif( nx < 0 || nx >= W || ny >= H || ny < 0 || q.P-pp < 0 || q.Q-qq < 0 || c[ny][nx] == '#' || ~memo[nx][ny][i][q.P-pp][q.Q-qq] ) continue;\n\t\t\tmemo[nx][ny][i][q.P-pp][q.Q-qq] = 0;\n\t\t\t//cout << nx << \" \" << ny << \" \" << i << \" \" << q.P-pp << \" \" << q.Q-qq << endl;\n\t\t\tQ.push(NODE(nx,ny,i,q.P-pp,q.Q-qq));\n\t\t}\n\t\t\n\t}\n\t\n\tif( answer > 1e8 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << answer << endl;\n\t}\n\t\n};"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif(at.a<c){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif(at.b<c){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nvoid pr(int x,int y,int dir){\n  char ch[]={'V','^','>','<'};\n  char tmp=mp[y][x];\n  mp[y][x]=ch[dir];\n  for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  mp[y][x]=tmp;\n  cout<<\"------\"<<endl;\n}\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(2*A-(p+q)>=ans)return;\n  int &u=used[x][y][p][q][dir];\n  if(u!=-1&&u<=2*A-(p+q))return;\n  u=2*A-(p+q);\n\n  vector<int> X,Y,ch;\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')break;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)] == '#') return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\tif(y == get<0>(g) and x == get<1>(g)) break;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#define MAX 1000000000\nusing namespace std;\n\n\nchar map[110][110];\n\nint mark[110][110][11][11][4];\n\nstruct node\n{\n\tint x,y,p,q,d;\n};\n\n\nint main()\n{\n\n\tnode ss,tt;\n\tint m,n,i,j,ii,jj,k,A,d;\n\tint sx,sy,ex,ey;\n\n\tint dir[4][2]={-1,0,0,1,1,0,0,-1};\n\tint Q[4]={1,0,3,2};\n\tint P[4]={3,2,1,0};\n\n\twhile(cin>>m>>n>>A)\n\t{\n\t\tfor(i=0;i<m;i++)\n\t\t\tscanf(\"%s\",map[i]);\n\n\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tfor(ii=0;ii<=A;ii++)\n\t\t\t\t\tfor(jj=0;jj<=A;jj++)\n\t\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t\t\tmark[i][j][ii][jj][k]=0;\n\n\t\tfor(i=0;i<m;i++)\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(map[i][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G')\n\t\t\t\t{\n\t\t\t\t\tex=i;\n\t\t\t\t\tey=j;\n\t\t\t\t}\n\t\t\t}\n\n\t\tmark[sx][sy][A][A][0]=-1;\n\t\tmark[sx][sy][A][A][2]=true;\n\n\t\tnode ss;\n\t\tss.x=sx;\n\t\tss.y=sy;\n\t\tss.p=ss.q=A;\n\t\tss.d=2;\n\t\tqueue <node> q;\n\t\tq.push(ss);\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tss=q.front();\n\t\t\tq.pop();\n\t\t//\tcout<<ss.x<<\" \"<<ss.y<<\" \"<<ss.p<<\" \"<<ss.q<<\" \"<<ss.d<<endl;\n\n\t\t\ttt.x=ss.x+dir[ss.d][0];\n\t\t\ttt.y=ss.y+dir[ss.d][1];\n\t\t\ttt.p=ss.p;\n\t\t\ttt.q=ss.q;\n\t\t\ttt.d=ss.d;\n\t\t\tif(tt.x<0||tt.x==m||tt.y<0||tt.y==n)\n\t\t\t\tcontinue;\n\t\t\tif(map[tt.x][tt.y]=='#')\n\t\t\t\tcontinue;\n\t\t\tif(mark[tt.x][tt.y][tt.p][tt.q][tt.d]==-1)\n\t\t\t\tcontinue;\n\n\t\t\tif(!mark[tt.x][tt.y][tt.p][tt.q][tt.d])\n\t\t\t{\n\t\t\t\tmark[tt.x][tt.y][tt.p][tt.q][tt.d]=true;\n\t\t\t\tq.push(tt);\n\t\t\t}\n\n\t\t\t//P\n\t\t\tif(tt.p)\n\t\t\t{\n\t\t\t\ttt.p--;\n\t\t\t\t\n\t\t\t\t\ttt.d=P[tt.d];\n\t\t\t\t\tif(!mark[tt.x][tt.y][tt.p][tt.q][tt.d])\n\t\t\t\t\t{\n\t\t\t\t\t\tmark[tt.x][tt.y][tt.p][tt.q][tt.d]=true;\n\t\t\t\t\t\tq.push(tt);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t}\n\n\t\t\t//Q\n\t\t\tif(tt.q)\n\t\t\t{\n\t\t\t\ttt.q--;\n\t\t\t\n\t\t\t\t\ttt.d=Q[tt.d];\n\t\t\t\t\tif(!mark[tt.x][tt.y][tt.p][tt.q][tt.d])\n\t\t\t\t\t{\n\t\t\t\t\t\tmark[tt.x][tt.y][tt.p][tt.q][tt.d]=true;\n\t\t\t\t\t\tq.push(tt);\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\ttt.q=ss.q;\n\t\t\t}\n\n\t\t\t\n\n\n\t\t}\n\n\t\tint ans=MAX;\n\n\t\tfor(i=0;i<=A;i++)\n\t\t\tfor(j=0;j<=A;j++)\n\t\t\t\tfor(d=0;d<4;d++)\n\t\t\t\t\tif(mark[ex][ey][i][j][d])\n\t\t\t\t\t\tans=min(ans,A-i+A-j);\n\n\t\tif(ans==MAX)\n\t\t\tans=-1;\n\t\tcout<<ans<<endl;\n\n\n\n\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int i,j,dir,p,q;\n};\nbool operator<(const state& a,const state& b){\n  return a.p+a.q<b.p+b.q;\n};\n\nint n,m,a;\nint dist[111][111][5][11][11];\nstring s[111];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nbool valid(int i,int j){\n  return i>=0&&i<n&&j>=0&&j<m;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m>>a;\n  rep(i,n)cin>>s[i];\n  rep(i,111)rep(j,111)rep(k,5)rep(p,11)rep(q,11)dist[i][j][k][p][q]=INF;\n  priority_queue<state> que;\n  rep(i,n)rep(j,m){\n    if(s[i][j]=='S'){\n      if(valid(i+1,j)&&s[i+1][j]!='#')que.push((state){(int)(i+1),(int)j,3,a,a});\n    }\n  }\n  int res=INF;\n  while(que.size()){\n    state ns=que.top(); que.pop();\n    int i=ns.i,j=ns.j,dir=ns.dir,p=ns.p,q=ns.q;\n    if(s[i][j]=='S'&&(dir==1||dir==3))continue;\n    if(dist[i][j][dir][p][q]!=INF)continue;\n    dist[i][j][dir][p][q]=p+q;\n    if(s[i][j]=='G'){\n      res=2*a-p-q;\n      break;\n    }\n    int ndir;\n    if(s[i][j]!='S'){\n      if(p>0){\n        if(dir==3||dir==0) ndir=3-dir;\n        else ndir=3-dir;\n        int ni=i+dy[ndir],nj=j+dx[ndir];\n        if(valid(ni,nj)&&s[ni][nj]!='#'){\n          que.push((state){ni,nj,ndir,p-1,q});\n        }\n      }\n      if(q>0){\n        if(dir==0||dir==1) ndir=1-dir;\n        else ndir=5-dir;\n        int ni=i+dy[ndir],nj=j+dx[ndir];\n        if(valid(ni,nj)&&s[ni][nj]!='#'){\n          que.push((state){ni,nj,ndir,p,q-1});\n        }\n      }\n    }\n    int ni=i+dy[dir],nj=j+dx[dir];\n    if(valid(ni,nj)&&s[ni][nj]!='#'){\n      que.push((state){ni,nj,dir,p,q});\n    }\n  }\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    if(i<0 || i>=n || j<0 || j>=m) return -1;\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i+1,j,0,0,0);\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  auto ok = [&](int i, int j, bool bs=true){\n    if(i<0 || i>=n || j<0 || j>=m) return false;\n    return (vec[i][j]=='.' || vec[i][j]=='G' || (bs && vec[i][j]=='S') );\n  };\n\n  rep(i,n)rep(j,m-1){\n    if( ok(i,j) && ok(i,j+1) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( ok(i,j,false) && ok(i+1,j,false) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        if(ok(i,j-1)) v[p].pb(f(i,j-1,x+1,y,3));\n        if(ok(i-1,j)) v[p+1].pb(f(i-1,j,x+1,y,2));\n        if(ok(i,j+1)) v[p+2].pb(f(i,j+1,x+1,y,1));\n        if(ok(i+1,j)) v[p+3].pb(f(i+1,j,x+1,y,0));\n      }\n      if(y<a){\n        if(ok(i,j+1)) v[p].pb(f(i,j+1,x,y+1,1));\n        if(ok(i+1,j)) v[p+1].pb(f(i+1,j,x,y+1,0));\n        if(ok(i,j-1)) v[p+2].pb(f(i,j-1,x,y+1,3));\n        if(ok(i-1,j)) v[p+3].pb(f(i-1,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(to==-1) continue;\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.a<c&&!bfs[tr][tc][at.a+1][at.b][td]){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.b<c&&!bfs[tr][tc][at.a][at.b+1][td]){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i+1,j,0,0,0);\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  auto ok = [&](int i, int j){\n    return (vec[i][j]=='.' || vec[i][j]=='G' || vec[i][j]=='S');\n  };\n\n  rep(i,n)rep(j,m-1){\n    if( ok(i,j) && ok(i,j+1) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( ok(i,j) && ok(i+1,j) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        if(j>0) v[p].pb(f(i,j-1,x+1,y,3));\n        if(i>0) v[p+1].pb(f(i-1,j,x+1,y,2));\n        if(j<m-1) v[p+2].pb(f(i,j+1,x+1,y,1));\n        if(i<n-1) v[p+3].pb(f(i+1,j,x+1,y,0));\n      }\n      if(y<a){\n        if(j<m-1) v[p].pb(f(i,j+1,x,y+1,1));\n        if(i<n-1) v[p+1].pb(f(i+1,j,x,y+1,0));\n        if(j>0) v[p+2].pb(f(i,j-1,x,y+1,3));\n        if(i>0) v[p+3].pb(f(i-1,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  /*\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      cout << G[i][j];\n    }cout <<endl;\n  }cout << endl;\n  */\n  if(val >= 0) return val;\n  if(G[x][y] == 'G'){\n    return val = 0;\n  }\n  val = INF;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    if(G[x_][y_] == 'G') return val = 0;\n    char c = G[x][y];\n    if(G[x][y] != 'S') G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    if(G[x_][y_] == 'G') return val = 0;\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    if(G[x_][y_] == 'G') return val = 0;\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  //printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n, m, a;\nstring s[100];\nint d[100][100][11][4];\n\nint main(){\n  cin >> n >> m >> a;\n  rep(i, n) cin >> s[i];\n  int sx, sy, gx, gy;\n  rep(i, n) rep(j, m){\n    if (s[i][j] == 'S') sx = i, sy = j;\n    if (s[i][j] == 'G') gx = i, gy = j;\n  }\n  queue<tuple<int, int, int, int>> q;\n  memset(d, -1, sizeof(d));\n  rep(i, 4){\n    d[sx][sy][0][i] = 0;\n    q.emplace(sx, sy, 0, i);\n  }\n  while (q.size()){\n    int x, y, c, dd;\n    tie(x, y, c, dd) = q.front(), q.pop();\n    rep(i, 4){\n      int nx = x + dx[i], ny = y + dy[i];\n      int nc = c + (dd != i), nd = i;\n      if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n      if (s[nx][ny] == '#' && nc > c) continue;\n      if (nc > a) continue;\n      if (d[nx][ny][nc][nd] != -1) continue;\n      d[nx][ny][nc][nd] = d[x][y][c][dd] + 1;\n      q.emplace(nx, ny, nc, nd);\n    }\n  }\n  int res = inf;\n  rep(i, a + 1) rep(j, 4){\n    if (d[gx][gy][i][j] == -1) continue;\n    chmin(res, i);\n  }\n  cout << (res == inf ? -1 : res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nint dx[] = { 0, 1, 0, -1 }; // NESW\nint dy[] = { -1, 0, 1, 0 };\n\nint P[] = { 3, 2, 1, 0 };\nint Q[] = { 1, 0, 3, 2 };\n\nconst int N = 110;\nint dist[N][N][4][12];\nint n, m, a;\nvector<string> board;\npriority_queue<tuple<int, int, int, int, int>> pq;\n\nvoid enq(int r, int c, int dir, int p, int q){\n\tif (p > a || q > a) return;\n\tr += dy[dir], c += dx[dir];\n\tif (r < 0 || r >= n || c < 0 || c >= m) return;\n\tif (board[r][c] == '#') return;\n\tint d = p + q;\n\tif (dist[r][c][dir][p] <= d) return;\n\tdist[r][c][dir][p] = d;\n\tpq.emplace(-d, r, c, dir, p);\n};\n\n\nint main(){\n\tcin >> n >> m >> a;\n\n\tboard.resize(n);\n\trep(i, n) cin >> board[i];\n\n\tpair<int, int> start, goal;\n\trep(i, n) rep(j, m){\n\t\tif (board[i][j] == 'S') start = MP(i, j);\n\t\tif (board[i][j] == 'G') goal = MP(i, j);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tdist[start.first][start.second][2][0] = 0;\n\tpq.push(MT(0, start.first, start.second, 2, 0));\n\n\tint ans = -1;\n\twhile (!pq.empty()){\n\t\tauto state = pq.top();\n\t\tpq.pop();\n\t\tint d, r, c, dir, p, q;\n\t\ttie(d, r, c, dir, p) = state;\n\t\td = -d;\n\t\tq = d - p;\n\n\t\tif (dist[r][c][dir][p] < d) continue;\n\n\t\tif (MP(r, c) == goal){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (board[r][c] != 'S'){\n\t\t\tif (p < a) enq(r, c, P[dir], p + 1, q);\n\t\t\tif (q < a) enq(r, c, Q[dir], p, q + 1);\n\t\t}\n\t\tenq(r, c, dir, p, q);\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int i,j,dir,p,q;\n};\nbool operator<(const state& a,const state& b){\n  return a.p+a.q<b.p+b.q;\n};\n\nint n,m,a;\nint dist[111][111][5][11][11];\nstring s[111];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nbool valid(int i,int j){\n  return i>=0&&i<n&&j>=0&&j<m;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m>>a;\n  rep(i,n)cin>>s[i];\n  rep(i,111)rep(j,111)rep(k,5)rep(p,11)rep(q,11)dist[i][j][k][p][q]=INF;\n  priority_queue<state> que;\n  rep(i,n)rep(j,m){\n    if(s[i][j]=='S'){\n      if(valid(i+1,j)&&s[i+1][j]!='#')que.push((state){(int)(i+1),(int)j,3,a,a});\n    }\n  }\n  int res=INF;\n  while(que.size()){\n    state ns=que.top(); que.pop();\n    int i=ns.i,j=ns.j,dir=ns.dir,p=ns.p,q=ns.q;\n    if(dist[i][j][dir][p][q]!=INF)continue;\n    dist[i][j][dir][p][q]=p+q;\n    if(s[i][j]=='G'){\n      res=2*a-p-q;\n      break;\n    }\n    if(s[i][j]=='S')continue;\n    int ndir;\n    if(p>0){\n      if(dir==3||dir==0) ndir=3-dir;\n      else ndir=3-dir;\n      int ni=i+dy[ndir],nj=j+dx[ndir];\n      if(valid(ni,nj)&&s[ni][nj]!='#'){\n        que.push((state){ni,nj,ndir,p-1,q});\n      }\n    }\n    if(q>0){\n      if(dir==0||dir==1) ndir=1-dir;\n      else ndir=5-dir;\n      int ni=i+dy[ndir],nj=j+dx[ndir];\n      if(valid(ni,nj)&&s[ni][nj]!='#'){\n        que.push((state){ni,nj,ndir,p,q-1});\n      }\n    }\n    int ni=i+dy[dir],nj=j+dx[dir];\n    if(valid(ni,nj)&&s[ni][nj]!='#'){\n      que.push((state){ni,nj,dir,p,q});\n    }\n  }\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y, d, p, q, t;\n\tstate(int x, int y, int d, int p, int q, int t) : x(x), y(y), d(d), p(p), q(q), t(t) {};\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\n\tvs field(N+2);\n\tstring s;\n\tREP(i, M+2) {\n\t\ts += '#';\n\t}\n\tfield[0] = field[N+1] = s;\n\n\tREP(i, N) {\n\t\tcin >> s;\n\t\tfield[i+1] = '#' + s + '#';\n\t}\n\n\tint sx, sy, gx, gy;\n\tREP(i, N+2) {\n\t\tREP(j, M+2) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t\tif(field[i][j] == 'G') {\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<state> Q;\n\tif(field[sy+1][sx] == '#') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t} else {\n\t\tQ.push(state(sx, sy+1, 1, 0, 0, 0));\n\t}\n\n\tvvi turn(N+2, vi(M+2, INT_MAX));\n\tturn[sy+1][sx] = 0;\n\n\tbool goal = false;\n\tint ans = INT_MAX;\n\twhile(!Q.empty()) {\n\t\tstate st = Q.front();\n\t\tQ.pop();\n\t\tint cx = st.x;\n\t\tint cy = st.y;\n\n\t\tif(cx == gx && cy == gy) {\n\t\t\tif(max(st.p, st.q) <= A) {\n\t\t\t\tgoal = true;\n\t\t\t\tans = min(ans, st.p+st.q);\n\t\t\t}\n\t\t} else {\n\t\t\tREP(d, 4) {\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tif(turn[ny][nx] < st.t+1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((st.d+2)%4 == d) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cx == sx && cy == sy && st.d != d) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[ny][nx] != '#') {\n\t\t\t\t\tturn[ny][nx] = st.t+1;\n\t\t\t\t\tif(st.d != d) {\n\t\t\t\t\t\tif(st.d+d == 3) {\n\t\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p, st.q+1, st.t+1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p+1, st.q, st.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p, st.q, st.t+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(goal) {\n\t\tcout << ans << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && memo[a][b][u.muki]>memo[u.y][u.x][u.muki]){\n\tmemo[a][b][u.muki]=memo[u.y][u.x][u.muki];\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+1)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+1)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+3)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+3)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,-1));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100][15][15];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = -1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      if(dp[s.x][s.y][s.P_reflect_count][s.Q_reflect_count]) continue;\n      dp[s.x][s.y][s.P_reflect_count][s.Q_reflect_count] = true;\n\n      for(int i=0;i<4;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  int x, y, a, b, fr;\n  S(int x, int y, int a, int b, int fr) :\n    x(x), y(y), a(a), b(b), fr(fr) {}\n};\nbool insert(queue<S>& que, bool used[100][100][11][11][4], int x, int y, int a, int b, int fr){\n  if(used[y][x][a][b][fr]) return false;\n  used[y][x][a][b][fr] = true;\n  que.push(S(x, y, a, b, fr));\n  return true;\n}\nint tb[4][4] = {{-1, 0, 2, 1},\n                {0, -1, 1, 2},\n                {2, 1, -1, 0},\n                {1, 2, 0, -1}};\n\nint main(){\n  int H, W, A;\n  while(cin>>H>>W>>A){\n    bool used[100][100][11][11][4] = {};\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    queue<S> que;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == 'S'){\n        int r = 1;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          insert(que, used, nx, ny, 0, 0, r);\n        }\n      }\n    }\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          if(grid[ny][nx] == 'S' && r == 3) continue;\n          switch(tb[s.fr][r]){\n            case -1:\n              insert(que, used, nx, ny, s.a, s.b, r);\n              break;\n            case 0:\n              if(s.a + 1 <= A) insert(que, used, nx, ny, s.a + 1, s.b, r);\n              break;\n            case 1:\n              if(s.b + 1 <= A) insert(que, used, nx, ny, s.a, s.b + 1, r);\n              break;\n            case 2:\n              break;\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'G')REP(r, 4)REP(a, A + 1)REP(b, A + 1)if(used[y][x][a][b][r]) ans = min(ans, a + b);\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,-1,0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing State = tuple<int, int, int, int, int>;\nconst int N = 101;\nint min_q[N][N][4][11];\n\nint h, w, n;\nvector<string> field;\n\nbool is_p[4][4];\n\ninline bool check(int x, int y){\n    return 0 <= x and x < w and 0 <= y and y < h and field[y][x] != '#';\n}\n\nint main(void){\n    cin >> h >> w >> n;\n    field = vector<string>(h);\n    for(auto & e : field) cin >> e;\n\n    int sx, sy, tx, ty;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] == 'S') sx = x, sy = y, field[y][x] = '.';\n            if(field[y][x] == 'G') tx = x, ty = y, field[y][x] = '.';\n        }\n    }\n\n    rep(i, h) rep(j, w) rep(k, 4) rep(l, n + 1) min_q[i][j][k][l] = inf;\n    priority_queue<State, vector<State>, greater<State>> q;\n    rep(i, 4){\n        if(i != 3) continue;\n        int nx = sx + dx[i], ny = sy + dy[i];\n        if(not check(nx, ny)) continue;\n        q.push(State(0, nx, ny, i, 0));\n        min_q[ny][nx][i][0] = 0;\n    }\n\n    is_p[0][3] = true;\n    is_p[1][2] = true;\n    is_p[2][1] = true;\n    is_p[3][0] = true;\n\n    while(q.size()){\n        int x, y, di, up, uq;\n        tie(uq, x, y, di, up) = q.top(); q.pop();\n        \n        rep(ndi, 4){\n            int nx = x + dx[ndi], ny = y + dy[ndi];\n            if(not check(nx, ny)) continue;\n\n            int nup = up, nuq = uq;\n\n            if(ndi != di){\n                if((di + 2) % 2 == ndi) continue;\n                else if(is_p[di][ndi]){\n                    if(up == n) continue;\n                    nup++;\n                }\n                else {\n                    if(uq == n) continue;\n                    nuq++;\n                }\n            }\n\n            assert(field[ny][nx] != '#'); \n            if(not chmin(min_q[ny][nx][ndi][nup], nuq)) continue;\n            q.push(State(nuq, nx, ny, ndi, nup));\n        }\n    }\n\n    int res = inf;\n    rep(di, 4){\n        rep(up, n + 1){\n            chmin(res, up + min_q[ty][tx][di][up]);\n        }\n    }\n    if(res == inf){\n        res = -1;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\npll l[4] = {{0,1},{1,0},{0,1},{1,0}};\npll r[4] = {{1,0},{0,1},{1,0},{0,1}};\n\nbool visited[105][105][12][12][4]; // (i,j) (p,q) dir\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    pll S,G;\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items =tuple<ll,ll,ll,ll,ll>;\n    queue<items> q;\n    q.push(items(S.first,S.second,0,0,1));\n    while(q.size()){\n        ll y,x,P,Q,dir;\n        tie(y,x,P,Q,dir) = q.front(); q.pop();\n        if(P > A || Q > A) continue;\n        if(visited[y][x][P][Q][dir]) continue;\n        visited[y][x][P][Q][dir] = true;\n        if(masu[y][x] == '#') continue;\n        if(y < S.first && x == S.second && (P|Q)) continue;\n        \n        ll ny = y + dy[dir], nx =x + dx[dir];\n        q.push(items(ny,nx,P,Q,dir));\n        \n        if(masu[y][x] == 'S') continue;\n        \n        ll ndir = (dir+1)%4;\n        ny = y + dy[ndir]; nx =x + dx[ndir];\n        q.push(items(ny,nx,P+r[dir].first,Q+r[dir].second,ndir));\n        \n        ndir = (dir-1+4)%4;\n        ny = y + dy[ndir]; nx =x + dx[ndir];\n        q.push(items(ny,nx,P+l[dir].first,Q+l[dir].second,ndir));\n    }\n    \n    for(ll i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(visited[G.first][G.second][i][j][k]) res = min(res,i+j);\n            }\n        }\n    }\n    return res==INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, a;\n  cin >> n >> m >> a;\n  vector<string> s(n);\n  Dijkstra<ll> dijk(4 * (a + 1) * n * m);\n  int st = -1, go = -1;\n  REP(i, 0, n) {\n    cin >> s[i];\n    REP(j, 0, m) {\n      if (s[i][j] == 'S') {\n\tst = i * m + j;\n      }\n      if (s[i][j] == 'G') {\n\tgo = i * m + j;\n      }\n    }\n  }\n  int dx[4] = {1, 0, -1, 0};\n  int dy[4] = {0, 1, 0, -1};\n  REP(i, 0, n) {\n    REP(j, 0, m) {\n      int src = i * m + j;\n      if (s[i][j] == '#') { continue; }\n      REP(d, 0, 4) {\n\tif (src == st && d == 2) { continue; }\n\tint nx = i + dx[d];\n\tint ny = j + dy[d];\n\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) { continue; }\n\tint dst = nx * m + ny;\n\tREP(lv, 0, a + 1) {\n\t  dijk.add_edge(d * (a + 1) * n * m + lv * n * m + src,\n\t\t\td * (a + 1) * n * m + lv * n * m + dst,\n\t\t\t0);\n\t}\n      }\n    }\n  }\n  REP(v, 0, n * m) {\n    if (v == st) { continue; }\n    REP(lv, 0, a + 1) {\n      // 0 <-> 1 and 2 <-> 3, duplicate-side\n      if (lv < a) {\n\tREP(x, 0, 4) {\n\t  dijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t\t(x ^ 1) * (a + 1) * n * m + (lv + 1) * n * m + v,\n\t\t\t0);\n\t}\n      }\n      // 0 <-> 3 and 1 <-> 2, cost-side\n      REP(x, 0, 4) {\n\tdijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t      (3 - x) * (a + 1) * n * m + lv * n * m + v,\n\t\t      1);\n      }\n    }\n  }\n  ll mi = 2 * a + 1;\n  VL sol = dijk.solve(0 * (a + 1) * n * m + st);\n  REP(d, 0, 4) {\n    REP(i, 0, a + 1) {\n      mi = min(mi, i + sol[d * (a + 1) * n * m + i * n * m + go]);\n    }\n  }\n  cout << (mi == 2 * a + 1 ? -1 : mi) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nint dis[N][N][15][15][4];\n\nstruct T{\n\tint c, y, x, p, q, d;\n\tT(int c, int y, int x, int p, int q, int d) : c(c),y(y),x(x),p(p),q(q),d(d) {}\n\tvoid tie(int& C, int& Y, int& X, int& P, int& Q, int& D){\n\t\tC=c;Y=y;X=x;P=p;Q=q;D=d;\n\t}\n\n\tbool operator < ( const T &right ) const {\n\t\treturn c < right.c;\n\t}\n\tbool operator > ( const T &right ) const {\n\t\treturn c > right.c;\n\t}\n};\n\n//typedef tuple<int,int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, pair<int, int> s, pair<int, int> g){\n\tmemset(dis, -1, sizeof(dis));\n\tdis[s.first][s.second][a][a][1] = 0;\n\n\tpriority_queue<T, vector<T>, greater<T>> que;\n\tque.push(T(0, s.first, s.second, a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint c, y, x, p, q, d;\n\t\tT tmp = que.top(); que.pop();\n\t\ttmp.tie(c,y,x,p,q,d);\n\t\tdis[y][x][p][q][d] = c;\n\t\tif(y == g.first and x == g.second) return dis[y][x][p][q][d];\n\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\tint nc = c;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\n\t\t\tif(m[y][x] == 'S' and d != i) continue;\n\t\t\tif(m[ny][nx] == 'S' and i % 2 == 1) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(dis[ny][nx][np][nq][i] == -1 && m[ny][nx] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(nc,ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tpair<int, int> s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = make_pair(i,j);\n\t\tif(m[i][j] == 'G') g = make_pair(i,j);\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i,j,0,0,0);\n      v[s].pb(f(i+1,j,0,0,0));\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  rep(i,n)rep(j,m-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i][j+1]=='.' || vec[i][j+1]=='G') ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i+1][j]=='.' || vec[i+1][j]=='G') ){\n      rep(x,a+1)rep(y,a+1) for(int d=0;d<3;d+=2){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        v[p].pb(f(i,j,x+1,y,3));\n        v[p+1].pb(f(i,j,x+1,y,2));\n        v[p+2].pb(f(i,j,x+1,y,1));\n        v[p+3].pb(f(i,j,x+1,y,0));\n      }\n      if(y<a){\n        v[p].pb(f(i,j,x,y+1,1));\n        v[p+1].pb(f(i,j,x,y+1,0));\n        v[p+2].pb(f(i,j,x,y+1,3));\n        v[p+3].pb(f(i,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res>2*a) cout << -1 << endl;\n  else cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h) return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tif(i != 1)continue;\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[ny][nx][np][nq][i] = 1;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\nchar map[100][101];\n\nstruct Data{\n\tDIR in_dir,out_dir;\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n//row,col???????????????????????????????????¢??°\nbool canPut(Data data[20],int num_data,int row,int col){\n\n\tbool FLG = true;\n\tbool block_FLG;\n\n\tfor(int i = 0; i < num_data; i++){\n\t\tif(data[i].row == row && data[i].col == col){\n\t\t\tFLG = false;\n\t\t\tbreak;\n\t\t}else if(data[i].row == row){\n\n\t\t\tif(col > data[i].col){\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = data[i].col; k <= col; k++){\n\t\t\t\t\tif(map[row][k] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tif(data[i].in_dir == East){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = col; k <= data[i].col; k++){\n\t\t\t\t\tif(map[row][k] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tif(data[i].in_dir == West){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(data[i].col == col){\n\n\t\t\t//map[row][col]???,map[data[i].row][data[i].col]??????????????????????????????????????????data[i]???????????¨???data[i]???in_dir????????´????????????????????????\n\t\t\tif(row > data[i].row){\n\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = data[i].row; k <= row; k++){\n\t\t\t\t\tif(map[k][col] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\n\t\t\t\t\tif(data[i].in_dir == South){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tblock_FLG = true;\n\t\t\t\tfor(int k = row; k <= data[i].row; k++){\n\t\t\t\t\tif(map[k][col] == '#'){\n\t\t\t\t\t\tblock_FLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(block_FLG){\n\t\t\t\t\tif(data[i].in_dir == North){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FLG;\n}\n\nvoid copyData(Info& to,Info from){\n\tfor(int k = 0; k < from.num_data;k++){\n\t\tto.data[k].row = from.data[k].row;\n\t\tto.data[k].col = from.data[k].col;\n\t\tto.data[k].mirror = from.data[k].mirror;\n\t\tto.data[k].in_dir = from.data[k].in_dir;\n\t\tto.data[k].out_dir = from.data[k].out_dir;\n\t}\n\tto.num_data = from.num_data;\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tminTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = South;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = West;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = North;\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = East;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = South;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = East;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tcanPut(Q.front().data,Q.front().num_data,Q.front().row,Q.front().col) == true &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tcopyData(new_info,Q.front());\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.data[new_info.num_data].in_dir = North;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].out_dir = West;\n\t\t\t\t\t\tnew_info.num_data++;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,X;\nint d[100][100][4][11][11];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ad[4]={1,0,3,2},bd[4]={3,2,1,0};\nint inf=100;\nstring s[100];\ndeque<int> qx,qy,qd,qa,qb;\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nvoid pushf(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_front(x);\n\tqy.push_front(y);\n\tqd.push_front(z);\n\tqa.push_front(a);\n\tqb.push_front(b);\n\td[x][y][z][a][b]=c;\n}\nvoid pushb(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_back(x);\n\tqy.push_back(y);\n\tqd.push_back(z);\n\tqa.push_back(a);\n\tqb.push_back(b);\n\td[x][y][z][a][b]=c;\n}\nint main(){\n\tcin>>H>>W>>X;\n\trep(i,H) rep(j,W) rep(k,4) rep(a,X+1) rep(b,X+1) d[i][j][k][a][b]=inf;\n\trep(i,H) cin>>s[i];\n\tint sx,sy;\n\trep(i,H) rep(j,W) if(s[i][j]=='S') sx=i,sy=j;\n\tpushb(sx,sy,0,X,X,0);\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front(),di=qd.front(),a=qa.front(),b=qb.front();\n\t\tqx.pop_front(),qy.pop_front(),qd.pop_front(),qa.pop_front(),qb.pop_front();\n\t\tif(x==sx&&y==sy&&di==2) continue;\n\t\tint c=d[x][y][di][a][b];\n\t\tif(s[x][y]=='G'){\n\t\t\tcout<<c<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\tif(is(nx,ny)) pushf(nx,ny,di,a,b,c);\n\t\tif(a) pushb(x,y,ad[di],a-1,b,c+1);\n\t\tif(b) pushb(x,y,bd[di],a,b-1,c+1);\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,-1,0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing State = tuple<int, int, int, int, int>;\nconst int N = 101;\nint min_q[N][N][4][11];\n\nint h, w, n;\nvector<string> field;\n\nbool is_p[4][4];\n\ninline bool check(int x, int y){\n    return 0 <= x and x < w and 0 <= y and y < h and field[y][x] != '#';\n}\n\nint main(void){\n    cin >> h >> w >> n;\n    field = vector<string>(h);\n    for(auto & e : field) cin >> e;\n\n    int sx, sy, tx, ty;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] == 'S') sx = x, sy = y, field[y][x] = '.';\n            if(field[y][x] == 'G') tx = x, ty = y, field[y][x] = '.';\n        }\n    }\n\n    rep(i, h) rep(j, w) rep(k, 4) rep(l, n + 1) min_q[i][j][k][l] = inf;\n    priority_queue<State, vector<State>, greater<State>> q;\n    rep(i, 4){\n        if(i != 3) continue;\n        int nx = sx + dx[i], ny = sy + dy[i];\n        if(not check(nx, ny)) continue;\n        q.push(State(0, nx, ny, i, 0));\n        min_q[ny][nx][i][0] = 0;\n    }\n\n    is_p[0][3] = true;\n    is_p[1][2] = true;\n    is_p[2][1] = true;\n    is_p[3][0] = true;\n\n    while(q.size()){\n        int x, y, di, up, uq;\n        tie(uq, x, y, di, up) = q.top(); q.pop();\n\n        if(x == sx and y == sy and di % 2 == 1) continue;\n        \n        rep(ndi, 4){\n            int nx = x + dx[ndi], ny = y + dy[ndi];\n            if(not check(nx, ny)) continue;\n\n            int nup = up, nuq = uq;\n\n            if(ndi != di){\n                if(x == sx and y == sy) continue;\n                if((di + 2) % 2 == ndi) continue;\n                else if(is_p[di][ndi]){\n                    if(up == n) continue;\n                    nup++;\n                }\n                else {\n                    if(uq == n) continue;\n                    nuq++;\n                }\n            }\n\n            assert(field[ny][nx] != '#'); \n            if(not chmin(min_q[ny][nx][ndi][nup], nuq)) continue;\n            q.push(State(nuq, nx, ny, ndi, nup));\n        }\n    }\n\n    int res = inf;\n    rep(di, 4){\n        rep(up, n + 1){\n            chmin(res, up + min_q[ty][tx][di][up]);\n        }\n    }\n    if(res == inf){\n        res = -1;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int inf = 1e9;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint mincost[101][101][4][11][11];\nvoid initcost(){\n    REP(y,101) REP(x,101) REP(d,4) REP(p,11) REP(q,11){\n        mincost[y][x][d][p][q] = inf;\n    }\n}\n\n\nstruct info{\n    int y,x,d,p,q,c;\n    info(int y, int x, int d, int p, int q, int c)\n        :y(y),x(x),d(d),p(p),q(q),c(c){}\n    info(){}\n    bool operator<(const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int h,w,a;\n    cin >> h >> w >> a;\n    vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n    int sy,sx, gy,gx;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> field[i][j];\n            if(field[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(field[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    \n    priority_queue<info> wait;\n    if(field[sy+1][sx]!='#'){\n        wait.push(info(sy+1, sx, 1, a, a, 0));\n    }\n    initcost();\n\n    while(!wait.empty()){\n        info top = wait.top();\n        int y = top.y;\n        int x = top.x;\n        int d = top.d;\n        int p = top.p;\n        int q = top.q;\n        int c = top.c;\n        wait.pop();\n        if(field[y][x]=='G') continue;\n        if(c > mincost[y][x][d][p][q]) continue;\n\n        for(int i=0; i<4; i++){\n            int ny = y+dy[i];\n            int nx = x+dx[i];\n            int np = p;\n            int nq = q;\n            if(field[ny][nx] == '#') continue;\n            if(field[ny][nx] == 'S' && i!=d) continue;\n            if((i+2)%4 == d) continue;\n            if((d+i)%4 == 1) np--;\n            if((d+i)%4 == 3) nq--;\n            if(np<0 || nq<0) continue;\n            if(c+1 < mincost[ny][nx][i][np][nq]){\n                wait.push(info(ny, nx, i, np, nq, c+1));\n                mincost[ny][nx][i][np][nq] = c+1;\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int d=0; d<4; d++){\n        for(int p=0; p<=10; p++){\n            for(int q=0; q<=10; q++){\n                if(mincost[gy][gx][d][p][q] != inf){\n                    ans = min(ans, a-p +a-q);\n                }\n            }\n        }\n    }\n    if(ans == inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nchar g[100][128];\n\nint dp[11][100][100][4];\n\nenum{\n  LEFT = 0,\n  DOWN = 1,\n  RIGHT = 2,\n  UP = 3\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\ninline int encode(int a1, int a2, int x, int y, int dir){\n  return dir | (y << 2) | (x << (2 + 8)) | (a2 << (2 + 8 + 8)) | (a1 << (2 + 8 + 8 + 4));\n}\n\ninline void decode(int val, int &a1, int &a2, int &x, int &y, int &dir){\n  a1 = (val >> (2 + 8 + 8 + 4)) & ((1 << 4) - 1);\n  a2 = (val >> (2 + 8 + 8)) & ((1 << 4) - 1);\n  x = (val >> (2 + 8)) & ((1 << 8) - 1);\n  y = (val >> (2)) & ((1 << 8) - 1);\n  dir = val & ((1 << 2) - 1);\n}\n\nint main(){\n  int h, w, a; scanf(\"%d%d%d\", &h, &w, &a);\n  REP(i,h) scanf(\"%s\", g[i]);\n  memset(dp, -1, sizeof(dp));\n\n  priority_queue<int> pq;\n  REP(i,h) REP(j,w) if(g[i][j] == 'S'){\n    REP(k,4) pq.push(encode(a, a, j, i, k));\n  }\n\n  int ans = 100;\n  while(pq.size()){\n    int a1, a2, x, y, dir;\n    int d = pq.top(); pq.pop();\n    decode(d, a1, a2, x, y, dir);\n\n    // printf(\"a1=%d a2=%d x=%d y=%d dir=%d\\n\", a1, a2, x, y, dir);\n\n    if(dp[a2][y][x][dir] != -1) continue;\n    dp[a2][y][x][dir] = a1;\n\n    if(g[y][x] == 'G'){\n      ans = min(ans, (a - a1) + (a - a2));\n    }\n\n    REP(k,3){\n      int dd = (dir + k + 3) % 4;\n      int xx = x + dx[dd];\n      int yy = y + dy[dd];\n      if(ISIN(xx, yy, w, h) && g[yy][xx] != '#'){\n        int aa1 = a1;\n        int aa2 = a2;\n        if(k == 0){\n          // turn left\n          if(dir == DOWN || dir == UP) aa1--;\n          else aa2--;\n        }else if(k == 2){\n          // turn right\n          if(dir == DOWN || dir == UP) aa2--;\n          else aa1--;\n        }\n\n        if(aa1 >= 0 && aa2 >= 0){\n          if(dp[aa2][yy][xx][dd] == -1){\n            pq.push(encode(aa1, aa2, xx, yy, dd));\n          }\n        }\n      }\n    }\n  }\n\n  if(ans == 100) puts(\"-1\");\n  else printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(val != INF) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(x == gx && y == gy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        char orig = board[x][y];\n        board[x][y] = '#';\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n        board[x][y] = orig;\n    }\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], INF);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i + 1 < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i+1,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    if(in[cx][cy] == 'S') continue;\n    if(in[cx][cy] == '#') continue;    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={1,0,-1,0};\nconst int p[4]={3,2,1,0};\nconst int q[4]={1,0,3,2};\n\nstring board[110];\nint dist[100][100][4][11][11];\n\nint main(void){\n\tint n,m,a;\n\tcin >> n >> m >> a;\n\trep(i,n) cin >> board[i];\n\n\tint si=0,sj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='S') si=i,sj=j;\n\n\tint gi=0,gj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='G') gi=i,gj=j;\n\t\n\trep(i,n)rep(j,m)rep(d,4)rep(pi,a+1)rep(qi,a+1) dist[i][j][d][pi][qi]=100;\n\n\tusing state=tuple<int,int,int,int,int>;\n\t\n\tdeque<state> que;\n\tdist[si][sj][0][a][a]=0;\n\tque.push_back(state(si,sj,0,a,a));\n\n\twhile(!que.empty()){\n\t\tint ci,cj,d,pi,qi;\n\t\ttie(ci,cj,d,pi,qi)=que.front();\n\t\tque.pop_front();\n\n\t\t{\n\t\t\tconst int ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&(board[ni][nj]=='.'||board[ni][nj]=='G') && chmin(dist[ni][nj][d][pi][qi],dist[ci][cj][d][pi][qi])) \n\t\t\t\tque.push_front(state(ni,nj,d,pi,qi)); \t\n\t\t}\n\n\t\tif(!(ci==si&&cj==sj)&&!(ci==gi&&cj==gj)){\n\t\t\tif(pi>0){\n\t\t\t\tconst int nd=p[d],npi=pi-1,nqi=qi;\n\t\t\t\tif(chmin(dist[ci][cj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ci,cj,nd,npi,nqi));\n\t\t\t}\n\t\t\tif(qi>0){\n\t\t\t\tconst int nd=q[d],npi=pi,nqi=qi-1;\n\t\t\t\tif(chmin(dist[ci][cj][nd][npi][nqi],dist[ci][cj][n][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ci,cj,nd,npi,nqi));\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tint ans=100;\n\trep(d,4)rep(pi,a+1)rep(qi,a+1) chmin(ans,dist[gi][gj][d][pi][qi]);\n\tif(ans==100) ans=-1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct state{\n\tint x, y, p, q, dir;\n\tstate(int a, int b, int c, int d, int e){\n\t\tx = a, y = b, p = c, q = d, dir = e;\n\t}\n};\n\nint N, M, A;\nchar map[105][105];\nint sx, sy, gx, gy;\nbool used[105][105][15][15][4];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y, int p, int q, int dir)\n{\n\tused[x][y][p][q][dir] = true;\n\tif(map[x][y] == 'G') return;\n\t\n\tint np, nq, nx, ny;\n\tfor(int nd = 0; nd < 4; nd++){\n\t\tnp = p, nq = q;\n\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\tif(nx < 0 || nx >= M || ny < 0 || ny >= N) continue;\n\t\tif(map[nx][ny] == '#' || map[nx][ny] == 'S') continue;\n\t\tif((dir+4-nd) % 4 == 2) continue;\n\t\tif(dir != nd){\n\t\t\tif(dir/2 == nd/2) np++;\n\t\t\telse nq++;\n\t\t}\n\t\tif(np > A || nq > A) continue;\n\t\tif(used[nx][ny][np][nq][nd]) continue;\n\t\tdfs(nx, ny, np, nq, nd);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> A;\n\tfor(int y = 0; y < N; y++){\n\t\tfor(int x = 0; x < M; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'S') sx = x, sy = y;\n\t\t\tif(map[x][y] == 'G') gx = x, gy = y;\n\t\t}\n\t}\n\t\n\tif(sy == N-1 || map[sx][sy+1] == '#'){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsy++;\n\t\n\tfor(int x = 0; x < M; x++){\n\t\tfor(int y = 0; y < N; y++){\n\t\t\tfor(int p = 0; p <= A; p++){\n\t\t\t\tfor(int q = 0; q <= A; q++){\n\t\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\t\tused[x][y][p][q][d] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(sx, sy, 0, 0, 3);\n\t\n\tint ans = 1000;\n\tfor(int p = 0; p <= A; p++){\n\t\tfor(int q = 0; q <= A; q++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tif(used[gx][gy][p][q][d]){\n\t\t\t\t\tans = min(ans, p+q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans == 1000) ans = -1;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n\nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k) {\n                for (int l = 0; l <= a; ++l) {\n                    dist[i][j][k][l] = 100;\n                }\n            }\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    dist[si][sj][1][0] = 0;\n    qi.push_back(si);\n    qj.push_back(sj);\n    qd.push_back(1);\n    qm.push_back(0);\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        if (pi == si && pj == sj && pd == 3) continue;\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        if (pi == si && pj == sj || pi == gi && pj == gj) continue;\n\n        {\n            int td = pd ^ 1;\n            int ti = pi + d[td], tj = pj + d[td + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && pm < a && dist[ti][tj][td][pm + 1] > dis) {\n                dist[ti][tj][td][pm + 1] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            int ti = pi + d[td], tj = pj + d[td + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][td][pm] > dis + 1) {\n                dist[ti][tj][td][pm] = dis + 1;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(td);\n                qm.push_front(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j <= a; ++j) {\n            ans = min(ans, dist[gi][gj][i][j] + j);\n        }\n    }\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool memo[100][100][4][11][11];\nstruct p {\n\tint y, x, d, r, l;\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\tvector<string> b(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> b[i];\n\t}\n\tqueue<p> q;\n\tpii goal, start;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < M; j++) {\n\t\t\tif(b[i][j]=='S') {\n\t\t\t\tmemo[i][j][0][0][0] = true;\n\t\t\t\tq.push((p){i,j,0,0,0});\n\t\t\t\tstart=pii(i,j);\n\t\t\t}\n\t\t\tif(b[i][j]=='G') {\n\t\t\t\tgoal=pii(i,j);\n\t\t\t}\n\t\t}\n\t}\n\twhile(q.size()) {\n\t\tint dxy[] = {1,0,-1,0,1};\n\t\tp t = q.front(); q.pop();\n\t\t//cout << t.y << \" \" << t.x << \" \" << t.d << endl;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint nx, ny;\n\t\t\tny = t.y + dxy[i];\n\t\t\tnx = t.x + dxy[i+1];\n\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\t\t\tif(b[ny][nx] == '#') continue;\n\n\t\t\tif(ny==start.first && nx==start.second && i==2) continue;\n\n\t\t\tif(i==(t.d+2)%4) {\n\t\t\t\tcontinue; // turn\n\t\t\t}\n\t\t\telse if(i==t.d) {\n\t\t\t\t// go straight\n\t\t\t\tif(memo[ny][nx][i][t.r][t.l]) continue;\n\t\t\t\tmemo[ny][nx][i][t.r][t.l] = true;\n\t\t\t\tq.push((p){ny,nx,i,t.r,t.l});\n\t\t\t}\n\t\t\telse if(b[t.y][t.x] == '.') {\n\t\t\t\tif(i+t.d==3){\n\t\t\t\t\t// type P\n\t\t\t\t\tif(t.r+1 > A) continue;\n\t\t\t\t\tif(memo[ny][nx][i][t.r+1][t.l]) continue;\n\t\t\t\t\tmemo[ny][nx][i][t.r+1][t.l] = true;\n\t\t\t\t\tq.push((p){ny,nx,i,t.r+1,t.l});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// type Q\n\t\t\t\t\tif(t.l+1 > A) continue;\n\t\t\t\t\tif(memo[ny][nx][i][t.r][t.l+1]) continue;\n\t\t\t\t\tmemo[ny][nx][i][t.r][t.l+1] = true;\n\t\t\t\t\tq.push((p){ny,nx,i,t.r,t.l+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i <= A; i++) {\n\t\tfor(int j = 0; j <= A; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tif(memo[goal.first][goal.second][k][i][j]) {\n\t\t\t\t\tif(res+1) res = min(res, i+j);\n\t\t\t\t\telse res = i+j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<short,short,short,short,short,short> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, pair<int, int> s, pair<int, int> g){\n\t//if(s.first + 1 > h or m[s.first + 1][s.second] == '#') return INF;\n\n\tpriority_queue<T, vector<T>, greater<T>> que;\n\tdis[s.first][s.second][a][a][1] = 1;\n\tque.push(T(0, s.first, s.second, a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint c, y, x, p, q, d;\n\t\ttie(c,y,x,p,q,d) = que.top(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\tif(y == g.first and x == g.second) break;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\tint nc = c;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(nc,ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tpair<int, int> s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = make_pair(i,j);\n\t\tif(m[i][j] == 'G') g = make_pair(i,j);\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,-1,0,1};\n\nconst int INF = 123;\nint d[100][100][4][11];\n\nstruct State{\n    int y,x,dir,p;\n};\n\nint main(){\n    int h,w,a;\n    cin >>h >>w >>a;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    pair<int,int> start,goal;\n    rep(i,h)rep(j,w){\n        if(s[i][j] == 'S') start = {i,j};\n        if(s[i][j] == 'G') goal = {i,j};\n    }\n\n    auto ok = [&](int y, int x){\n        return (0<=y && y<h && 0<=x && x<w && s[y][x]!='#');\n    };\n\n    rep(i,100)rep(j,100)rep(k,4)rep(l,11) d[i][j][k][l] = INF;\n\n    queue<State> que;\n    if(ok(start.fi+1, start.se)){\n        d[start.fi+1][start.se][3][0] = 0;\n        que.push({start.fi+1, start.se, 3, 0});\n    }\n\n    while(!que.empty()){\n        State c = que.front();\n        que.pop();\n\n        int D = d[c.y][c.x][c.dir][c.p];\n        State t;\n\n        // 鏡を使わず直進\n        t = c;\n        t.y += dy[t.dir];\n        t.x += dx[t.dir];\n        if(ok(t.y,t.x) && d[t.y][t.x][t.dir][t.p] > D){\n            d[t.y][t.x][t.dir][t.p] = D;\n            que.push(t);\n        }\n\n        // type-P mirror\n        if(t.p<a){\n            t = c;\n            t.dir = 3-t.dir;\n            t.y += dy[t.dir];\n            t.x += dx[t.dir];\n            ++t.p;\n            if(ok(t.y,t.x) && d[t.y][t.x][t.dir][t.p] > D){\n                d[t.y][t.x][t.dir][t.p] = D;\n                que.push(t);\n            }\n        }\n\n        // type-Q mirror\n        if(D<a){\n            t = c;\n            t.dir ^= 1;\n            t.y += dy[t.dir];\n            t.x += dx[t.dir];\n            if(ok(t.y,t.x) && d[t.y][t.x][t.dir][t.p] > D+1){\n                d[t.y][t.x][t.dir][t.p] = D+1;\n                que.push(t);\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,4)rep(j,a+1) ans = min(ans, d[goal.fi][goal.se][i][j]+j);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\tfor(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][i]=1;\n\t\tQ.push(wolf(sr,sc,0,0,i));\n\t}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif(at.a<c){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif(at.b<c){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, a;\n  cin >> n >> m >> a;\n  vector<string> s(n);\n  Dijkstra<ll> dijk(4 * (a + 1) * n * m);\n  int st = -1, go = -1;\n  REP(i, 0, n) {\n    cin >> s[i];\n    REP(j, 0, m) {\n      if (s[i][j] == 'S') {\n\tst = i * m + j;\n      }\n      if (s[i][j] == 'G') {\n\tgo = i * m + j;\n      }\n    }\n  }\n  int dx[4] = {1, 0, -1, 0};\n  int dy[4] = {0, 1, 0, -1};\n  REP(i, 0, n) {\n    REP(j, 0, m) {\n      int src = i * m + j;\n      if (s[i][j] == '#') { continue; }\n      REP(d, 0, 4) {\n\tint nx = i + dx[d];\n\tint ny = j + dy[d];\n\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) { continue; }\n\tint dst = nx * m + ny;\n\tREP(lv, 0, a + 1) {\n\t  dijk.add_edge(d * (a + 1) * n * m + lv * n * m + src,\n\t\t\td * (a + 1) * n * m + lv * n * m + dst,\n\t\t\t0);\n\t}\n      }\n    }\n  }\n  REP(v, 0, n * m) {\n    REP(lv, 0, a + 1) {\n      // 0 <-> 1 and 2 <-> 3, duplicate-side\n      if (lv < a) {\n\tREP(x, 0, 4) {\n\t  dijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t\t(x ^ 1) * (a + 1) * n * m + (lv + 1) * n * m + v,\n\t\t\t0);\n\t}\n      }\n      // 0 <-> 3 and 1 <-> 2, cost-side\n      REP(x, 0, 4) {\n\tdijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t      (3 - x) * (a + 1) * n * m + lv * n * m + v,\n\t\t      1);\n      }\n    }\n  }\n  ll mi = a + 2;\n  VL sol = dijk.solve(0 * (a + 1) * n * m + st);\n  REP(d, 0, 4) {\n    REP(i, 0, a + 1) {\n      mi = min(mi, i + sol[d * (a + 1) * n * m + i * n * m + go]);\n    }\n  }\n  cout << (mi == a + 2 ? -1 : mi) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\tfor(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][i]=1;\n\t\tQ.push(wolf(sr,sc,0,0,i));\n\t}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif(at.a<c){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif(at.b<c){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint memo[102][102][4][11][11];\nint field[102][102];\nint A;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstruct aa {\n\tint y;\n\tint x;\n\tint way;\n\tint p;\n\tint q;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn 2*A-(l.p+l.q)> 2 * A - (r.p+r.q);\n\t}\n};\n\n\n\nint pc(const int way) {\n\tif (way == 0) {\n\t\treturn 3;\n\t}\n\telse if (way == 1) {\n\t\treturn 2;\n\t}\n\telse if (way == 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\nint qc(const int way) {\n\tif (way == 0) {\n\t\treturn 1;\n\t}\n\telse if (way == 1) {\n\t\treturn 0;\n\t}\n\telse if (way == 2) {\n\t\treturn 3;\n\t}\n\telse {\n\t\treturn 2;\n\t}\n}\nint main() {\n\tmemset(memo, -1, sizeof(memo));\n\tint N, M; cin >> N >> M >> A;\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[0][j] = 0;\n\t}\n\tint sx, sy;\n\tint gx, gy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfield[i][0] = 0;\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (st[j] == 'S') {\n\t\t\t\tsx = j + 1;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse if (st[j] == 'G') {\n\t\t\t\tgx = j + 1;\n\t\t\t\tgy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfield[i][M+1] = 0;\n\t}\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[N+1][j] = 0;\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sy,sx,1,A,A });\n\tmemo[sy][sx][1][A][A] = 1;\n\t\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = A - atop.p + A - atop.q;\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tconst int nway = atop.way;\n\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q]<0) {\n\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q] = 1;\n\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.p) {\n\t\t\t\tconst int nway = pc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p - 1, atop.q });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.q) {\n\t\t\t\tconst int nway = qc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q - 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool d[100*100*4];\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  // auto f = [&](int i, int j, int x, int y, int dir){\n  //   return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+dir;\n  // };\n  auto f = [&](int i, int j, int dir){\n    return (i*m+j)*4+dir;\n  };\n\n  int sx,sy,tx,ty;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      sx = i+1; sy = j;\n    }\n    if(vec[i][j]=='G') tx=i, ty=j;\n  }\n\n  auto ok = [&](int i, int j, int dir){//dbg(i,j,dir);\n    if(i<0 || i>=n || j<0 || j>=m) return false;\n    if(dir%2==0 && vec[i][j]=='S') return false;\n    return (vec[i][j]=='.' || vec[i][j]=='G' || vec[i][j]=='S' );\n  };\n\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,1,0,-1};\n  const int mirrx[] = {3,2,1,0};\n  const int mirry[] = {1,0,3,2};\n\n  int res = INF;\n\n  fill(d, d+(sizeof(d)), false);\n  queue<int> qx, qy, qi, qj, qd;\n  d[f(sx,sy,0)] = true;\n  qx.push(sx); qy.push(sy); qi.push(0); qj.push(0); qd.push(0);\n\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    int i = qi.front(); qi.pop();\n    int j = qj.front(); qj.pop();\n    int dir = qd.front(); qd.pop();\n\n    if(x==tx && y==ty){\n      res = min(res, i+j);\n      continue;\n    }\n\n    int nx,ny;\n\n    // ????????????\n    nx = x + dx[dir];\n    ny = y + dy[dir];\n    if(ok(nx, ny, dir)){\n      int z = f(nx, ny, dir);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i); qj.push(j); qd.push(dir);\n      }\n    }\n\n    if(vec[x][y]=='S') continue;\n\n    // mirror\n    nx = x + dx[mirrx[dir]];\n    ny = y + dy[mirrx[dir]];\n    if(i<a && ok(nx, ny, mirrx[dir])){\n      int z = f(nx, ny, mirrx[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i+1); qj.push(j); qd.push(mirrx[dir]);\n      }\n    }\n\n    nx = x + dx[mirry[dir]];\n    ny = y + dy[mirry[dir]];\n    if(j<a && ok(nx, ny, mirry[dir])){\n      int z = f(nx, ny, mirry[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i); qj.push(j+1); qd.push(mirry[dir]);\n      }\n    }\n  }\n\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\n\nstruct Data{\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\n\tvoid copy(bool arg_check[100][100]){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tcheck[i][k] = arg_check[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n\tbool check[100][100];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\tchar map[H][W+1];\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tif(i < H-1)\tminTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tfirst.check[i][k] = false;\n\t\t}\n\t}\n\n\tif(first.row >= H || map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int H, W, A;\n    vector<string> F;\n    void input() {\n        cin >> H >> W >> A;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n    }\n\n    struct S {\n        int p, q, y, x, dir;\n        S(int p, int q, int y, int x, int dir) : p(p), q(q), y(y), x(x), dir(dir) {}\n    };\n\n    void find_pos(int& y, int &x, char c) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == c) {\n                    y = i;\n                    x = j;\n                    return;\n                }\n            }\n        }\n        assert(0);\n    }\n\n    const int dy[] = {-1, 0, 1, 0};\n    const int dx[] = {0, 1, 0, -1};\n\n    const int INF = 1<<28;\n\n    bool valid_pos(int y, int x) {\n        if (y < 0 || y >= H) return false;\n        if (x < 0 || x >= W) return false;\n        if (F[y][x] == '#') return false;\n        return true;\n    }\n\n    void solve() {\n        int sy, sx; find_pos(sy, sx, 'S');\n        static bool D[11][11][101][101][4];\n        memset(D, 0, sizeof(D));\n        queue<S> Q;\n        Q.push(S(0, 0, sy, sx, 2));\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            const int y = c.y;\n            const int x = c.x;\n            if (F[y][x] == 'S' && c.dir == 0) continue;\n            for (int i = -1; i <= 1; i++) {\n                int np, nq;\n                if (c.dir % 2 == 0) {\n                    np = c.p + (i < 0); nq = c.q + (i > 0);\n                } else {\n                    np = c.p + (i > 0); nq = c.q + (i < 0);\n                }\n                int ny = y + dy[c.dir]; \n                int nx = x + dx[c.dir];\n                int ndir = (c.dir + i + 4) % 4;\n                if (np > A || nq > A) continue;\n                if (valid_pos(ny, nx)) {\n                    bool& next = D[np][nq][ny][nx][ndir];\n                    if (!next) {\n                        next = true;\n                        Q.push(S(np, nq, ny, nx, ndir));\n                    }\n                }\n            }\n        }\n\n        int gy, gx;\n        find_pos(gy, gx, 'G');\n        int ans = INF;\n        for (int i = 0; i <= A; i++) {\n            for (int j = 0; j <= A; j++) {\n                for (int k = 0; k < 4; k++) {\n                    if (D[i][j][gy][gx][k]) {\n                        ans = min(ans, i + j);\n                    }\n                }\n            }\n        }\n        cout << (ans == INF ? -1: ans) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W,A;\n\nstruct Data{\n\tshort row,col;\n\tchar mirror;\n};\n\nstruct Info{\n\tvoid set(DIR arg_dir,short arg_row,short arg_col,short arg_rest_P,short arg_rest_Q,short arg_time){\n\t\tdir = arg_dir;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\trest_P = arg_rest_P;\n\t\trest_Q = arg_rest_Q;\n\t\ttime = arg_time;\n\t}\n\n\tvoid copy(bool arg_check[100][100]){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tcheck[i][k] = arg_check[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tDIR dir;\n\tshort row,col,rest_P,rest_Q,time,num_data;\n\tData data[20];\n\tbool check[100][100];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tInfo first;\n\n\tscanf(\"%d %d %d\",&H,&W,&A);\n\tchar map[H][W+1];\n\n\tint***** minTime = new int****[H];\n\tfor(int a = 0; a < H; a++){\n\t\tminTime[a] = new int***[W];\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tminTime[a][b]  = new int**[4];\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tminTime[a][b][c] = new int*[A+1];\n\t\t\t\tfor(int d = 0; d <= A; d++){\n\t\t\t\t\tminTime[a][b][c][d] = new int[A+1];\n\t\t\t\t\tfor(int e = 0; e <= A; e++)minTime[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tfirst.set(South,i+1,k,A,A,0);\n\t\t\t\tminTime[i+1][k][South][A][A] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tfirst.check[i][k] = false;\n\t\t}\n\t}\n\n\tif(map[first.row][first.col] == '#'){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\n\tint ans = BIG_NUM;\n\tfirst.num_data = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tshort next_row,next_col;\n\tchar mirror;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().row][Q.front().col] == 'G'){\n\t\t\tans = min(ans,(A-Q.front().rest_P)+(A-Q.front().rest_Q));\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > minTime[Q.front().row][Q.front().col][Q.front().dir][Q.front().rest_P][Q.front().rest_Q]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < Q.front().num_data; i++){\n\t\t\t\tif(Q.front().data[i].row == Q.front().row && Q.front().data[i].col == Q.front().col){\n\t\t\t\t\tmirror = Q.front().data[i].mirror;\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(FLG){\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase North:\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase East:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][North][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(North,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\tnext_col = Q.front().col;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][South][Q.front().rest_P][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(South,next_row,next_col,Q.front().rest_P,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col+1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_P > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][East][Q.front().rest_P-1][Q.front().rest_Q] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(East,next_row,next_col,Q.front().rest_P-1,Q.front().rest_Q,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'P';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tnext_col = Q.front().col-1;\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && Q.front().rest_Q > 0 && map[Q.front().row][Q.front().col] != 'S' &&\n\t\t\t\t\t\t\tQ.front().check[Q.front().row][Q.front().col] == false &&\n\t\t\t\t\t\t\t minTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] > Q.front().time+1){\n\t\t\t\t\t\tminTime[next_row][next_col][West][Q.front().rest_P][Q.front().rest_Q-1] = Q.front().time+1;\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tnew_info.set(West,next_row,next_col,Q.front().rest_P,Q.front().rest_Q-1,Q.front().time+1);\n\t\t\t\t\t\tfor(int k = 0; k < Q.front().num_data;k++){\n\t\t\t\t\t\t\tnew_info.data[k].row = Q.front().data[k].row;\n\t\t\t\t\t\t\tnew_info.data[k].col = Q.front().data[k].col;\n\t\t\t\t\t\t\tnew_info.data[k].mirror = Q.front().data[k].mirror;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_info.num_data = Q.front().num_data;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].row = Q.front().row;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].col = Q.front().col;\n\t\t\t\t\t\tnew_info.data[new_info.num_data].mirror = 'Q';\n\t\t\t\t\t\tnew_info.num_data++;\n\n\t\t\t\t\t\tnew_info.copy(Q.front().check);\n\t\t\t\t\t\tnew_info.check[Q.front().row][Q.front().col] = true;\n\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<1>(p) + 1 > h) return INF;\n\n\tdis[get<1>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<1>(p) + 1, get<0>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[ny][nx][np][nq][i] = 1;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool memo[100][100][4][11][11];\nstruct p {\n\tint y, x, d, r, l;\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\tvector<string> b(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> b[i];\n\t}\n\tqueue<p> q;\n\tpii goal;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < M; j++) {\n\t\t\tif(b[i][j]=='S') {\n\t\t\t\tmemo[i][j][0][0][0] = true;\n\t\t\t\tq.push((p){i,j,0,0,0});\n\t\t\t}\n\t\t\tif(b[i][j]=='G') {\n\t\t\t\tgoal=pii(i,j);\n\t\t\t}\n\t\t}\n\t}\n\twhile(q.size()) {\n\t\tint dxy[] = {1,0,-1,0,1};\n\t\tp t = q.front(); q.pop();\n\t\t//cout << t.y << \" \" << t.x << \" \" << t.d << endl;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint nx, ny;\n\t\t\tny = t.y + dxy[i];\n\t\t\tnx = t.x + dxy[i+1];\n\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\t\t\tif(b[ny][nx] == '#') continue;\n\n\t\t\tif(i==(t.d+2)%4) {\n\t\t\t\tcontinue; // turn\n\t\t\t}\n\t\t\telse if(i==t.d) {\n\t\t\t\t// go straight\n\t\t\t\tif(memo[ny][nx][i][t.r][t.l]) continue;\n\t\t\t\tmemo[ny][nx][i][t.r][t.l] = true;\n\t\t\t\tq.push((p){ny,nx,i,t.r,t.l});\n\t\t\t}\n\t\t\telse if(b[t.y][t.x] == '.') {\n\t\t\t\tif(i+t.d==3){\n\t\t\t\t\t// type P\n\t\t\t\t\tif(t.r+1 > A) continue;\n\t\t\t\t\tif(memo[ny][nx][i][t.r+1][t.l]) continue;\n\t\t\t\t\tmemo[ny][nx][i][t.r+1][t.l] = true;\n\t\t\t\t\tq.push((p){ny,nx,i,t.r+1,t.l});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// type Q\n\t\t\t\t\tif(t.l+1 > A) continue;\n\t\t\t\t\tif(memo[ny][nx][i][t.r][t.l+1]) continue;\n\t\t\t\t\tmemo[ny][nx][i][t.r][t.l+1] = true;\n\t\t\t\t\tq.push((p){ny,nx,i,t.r,t.l+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = -1;\n\tfor(int i = 0; i <= A; i++) {\n\t\tfor(int j = 0; j <= A; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tif(memo[goal.first][goal.second][k][i][j]) {\n\t\t\t\t\tif(res+1) res = min(res, i+j);\n\t\t\t\t\telse res = i+j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint N,M,A;\nstring s[111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)) dfs(ny,nx,d,p,q);\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  if(p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)) dfs(ny,nx,d,p,q);\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct P {\n  int x,y,p,q,z;\n};\n \nint d[101][101][15][15][4];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n \nbool check(int n, int m, int x, int y) {\n  return (x>=0&&x<n&&y>=0&&y<m);\n}\n \nint main() {\n  int n,m,k,INF=1<<29;\n  cin >> n >> m >> k;\n  string s[n];\n  int gx,gy,sx,sy;\n  for(int i=0; i<n; i++) {\n    cin >> s[i];\n    for(int j=0; j<m; j++) {\n      if(s[i][j]=='G') {\n    gx=i;gy=j;\n      }\n      if(s[i][j]=='S') {\n    sx=i;sy=j;\n      }\n    }\n  }\n  for(int i=0; i<101; i++)for(int j=0;j<101;j++)for(int ii=0; ii<15;ii++)for(int iii=0;iii<15;iii++)for(int jj=0;jj<4;jj++) d[i][j][ii][iii][jj]=INF;\n  d[sx][sy][k][k][2]=0;\n   \n  deque<P> que;\n  que.push_back((P){sx,sy,k,k,2});\n  while(!que.empty()) {\n    P t=que.front();que.pop_front();\n    int nx=t.x,ny=t.y;\n    if(s[nx][ny]=='G' || (s[nx][ny]=='S'&&t.z==0)) continue;\n    int x=nx+dx[t.z],y=ny+dy[t.z];\n    if(check(n,m,x,y) && s[x][y]!='#') {\n      if(d[x][y][t.p][t.q][t.z]>d[nx][ny][t.p][t.q][t.z]) {\n        que.push_front((P){x,y,t.p,t.q,t.z});\n        d[x][y][t.p][t.q][t.z]=d[nx][ny][t.p][t.q][t.z];\n      }\n    }\n    if(s[nx][ny]=='S') continue;\n    int a=1;\n    if(t.z%2) a=3;\n    if(t.p) {\n      x=nx+dx[(t.z+a)%4],y=ny+dy[(t.z+a)%4];\n      if(check(n,m,x,y) && s[x][y]!='#') {\n        if(d[x][y][t.p-1][t.q][(t.z+a)%4]>d[nx][ny][t.p][t.q][t.z]+1) {\n          que.push_back((P){x,y,t.p-1,t.q,(t.z+a)%4});\n          d[x][y][t.p-1][t.q][(t.z+a)%4]=d[nx][ny][t.p][t.q][t.z]+1;\n        }\n      }\n    }\n    a=(a+2)%4;\n    if(t.q) {\n      x=nx+dx[(t.z+a)%4],y=ny+dy[(t.z+a)%4];\n      if(check(n,m,x,y) && s[x][y]!='#') {\n        if(d[x][y][t.p][t.q-1][(t.z+a)%4]>d[nx][ny][t.p][t.q][t.z]+1) {\n          que.push_back((P){x,y,t.p,t.q-1,(t.z+a)%4});\n          d[x][y][t.p][t.q-1][(t.z+a)%4]=d[nx][ny][t.p][t.q][t.z]+1;\n        }\n      }\n    }\n  }\n  int ans=INF;\n  for(int i=0; i<=k; i++) {\n    for(int j=0; j<=k; j++) {\n      for(int l=0; l<4; l++) ans=min(ans,d[gx][gy][i][j][l]);\n    }\n  }\n  if(ans==INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct state{\n\tint x, y, p, q, dir;\n\tstate(int a, int b, int c, int d, int e){\n\t\tx = a, y = b, p = c, q = d, dir = e;\n\t}\n};\n\nint N, M, A;\nchar map[105][105];\nint sx, sy, gx, gy;\nbool used[105][105][15][15][4];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y, int p, int q, int dir)\n{\n\tused[x][y][p][q][dir] = true;\n\tif(map[x][y] == 'G') return;\n\t\n\tint np, nq, nx, ny;\n\tfor(int nd = 0; nd < 4; nd++){\n\t\tnp = p, nq = q;\n\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\tif(nx < 0 || nx >= M || ny < 0 || ny >= N) continue;\n\t\tif(map[nx][ny] == '#') continue;\n\t\tif(nd == 1 && map[nx][ny] == 'S') continue;\n\t\tif((dir+4-nd) % 4 == 2) continue;\n\t\tif(dir != nd){\n\t\t\tif(map[nx][ny] == 'S') continue;\n\t\t\tif(dir/2 == nd/2) np++;\n\t\t\telse nq++;\n\t\t}\n\t\tif(np > A || nq > A) continue;\n\t\tif(used[nx][ny][np][nq][nd]) continue;\n\t\tdfs(nx, ny, np, nq, nd);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> A;\n\tfor(int y = 0; y < N; y++){\n\t\tfor(int x = 0; x < M; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'S') sx = x, sy = y;\n\t\t\tif(map[x][y] == 'G') gx = x, gy = y;\n\t\t}\n\t}\n\t\n\tif(sy == N-1 || map[sx][sy+1] == '#'){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsy++;\n\t\n\tfor(int x = 0; x < M; x++){\n\t\tfor(int y = 0; y < N; y++){\n\t\t\tfor(int p = 0; p <= A; p++){\n\t\t\t\tfor(int q = 0; q <= A; q++){\n\t\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\t\tused[x][y][p][q][d] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(sx, sy, 0, 0, 3);\n\t\n\tint ans = 1000;\n\tfor(int p = 0; p <= A; p++){\n\t\tfor(int q = 0; q <= A; q++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tif(used[gx][gy][p][q][d]){\n\t\t\t\t\tans = min(ans, p+q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans == 1000) ans = -1;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint H,W,A;\nint sy,sx;\nchar t[200][200];\nint d[200][200][11][4];\n\nint solve(){\n  memset(d,-1,sizeof(d));\n  queue<int> qy,qx,qa,qd;\n  qy.push(sy);\n  qx.push(sx);\n  qa.push(0);\n  qd.push(2);\n  d[sy][sx][0][2]=0;\n\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int a=qa.front();qa.pop();\n    int dir=qd.front();qd.pop();\n    int b=d[y][x][a][dir]-a;\n\n    if(t[y][x]=='_'&&dir==0)continue;\n    int ny=y,nx=x,na,nb;\n    while(1){\n      ny+=dy[dir];\n      nx+=dx[dir];\n      if(ny<0||nx<0)break;\n      if(ny>=H||nx>=W)break;\n      if(t[ny][nx]=='#')break;\n      if(t[ny][nx]=='S')continue;\n      \n      if(t[ny][nx]=='G')return d[y][x][a][dir];\n      for(int i=0;i<4;i++){\n        if(i==dir||i==(dir+2)%4)continue;\n\n        na=a,nb=b;\n        if(i%2==0&&i==(dir+1)%4)na=a+1;\n        else if(i%2==1&&i==(dir+3)%4)na=a+1;\n        else nb=b+1;\n        if(na>A||nb>A)continue;\n        \n        if(d[ny][nx][na][i]!=-1)continue;\n        d[ny][nx][na][i]=d[y][x][a][dir]+1;\n        qy.push(ny);\n        qx.push(nx);\n        qa.push(na);\n        qd.push(i);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='S'){\n        sy=i,sx=j;\n      }\n    }\n  }\n  for(int i=sy+1;i<H;i++){\n    if(t[i][sx]=='#'||t[i][sx]=='G')break;\n    t[i][sx]='_';\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct stat{\n\tint y,x,dir,n1,n2; // n1, n2 : 鏡 /, \\ の残り枚数\n};\n\nint main(){\n\tint h,w,n; scanf(\"%d%d%d\",&h,&w,&n);\n\tchar B[100][101];\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) if(B[i][j]=='S') sx=j, sy=i;\n\n\tstatic int dp[100][100][4][11][11];\n\tmemset(dp,-1,sizeof dp);\n\tdp[sy][sx][3][n][n]=0;\n\trep(n1,n+1) rep(n2,n+1) dp[sy][sx][1][n1][n2]=777;\n\n\tint ans=-1;\n\tqueue<stat> Q;\n\tQ.push((stat){sy,sx,3,n,n});\n\twhile(!Q.empty()){\n\t\tint y=Q.front().y,x=Q.front().x,dir=Q.front().dir,n1=Q.front().n1,n2=Q.front().n2;\n\t\tQ.pop();\n\n\t\tif(B[y][x]=='G'){ ans=dp[y][x][dir][n1][n2]; break; }\n\n\t\tint y2=y+dy[dir],x2=x+dx[dir],dir2;\n\t\tif(y2<0 || h<=y2 || x2<0 || w<=x2 || B[y2][x2]=='#') continue;\n\n\t\t// 鏡を置かない\n\t\tdir2=dir;\n\t\tif(dp[y2][x2][dir2][n1][n2]==-1){\n\t\t\tdp[y2][x2][dir2][n1][n2]=dp[y][x][dir][n1][n2];\n\t\t\tQ.push((stat){y2,x2,dir2,n1,n2});\n\t\t}\n\n\t\t// 鏡 / を置く\n\t\tdir2=dir^1;\n\t\tif(n1>0 && dp[y2][x2][dir2][n1-1][n2]==-1){\n\t\t\tdp[y2][x2][dir2][n1-1][n2]=dp[y][x][dir][n1][n2]+1;\n\t\t\tQ.push((stat){y2,x2,dir2,n1-1,n2});\n\t\t}\n\n\t\t// 鏡 \\ を置く\n\t\tdir2=3-dir;\n\t\tif(n2>0 && dp[y2][x2][dir2][n1][n2-1]==-1){\n\t\t\tdp[y2][x2][dir2][n1][n2-1]=dp[y][x][dir][n1][n2]+1;\n\t\t\tQ.push((stat){y2,x2,dir2,n1,n2-1});\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct state {\n\tint x, y, d;\n\n\tstate(int x, int y, int d) : x(x), y(y), d(d) {};\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\t\n\tvs field(N+2);\n\tstring tmp;\n\tREP(i, M+2) {\n\t\tfield[0] += '#';\n\t\tfield[N+1] += '#';\n\t}\n\n\tREP(i, N) {\n\t\tcin >> tmp;\n\t\tfield[i+1] = '#' + tmp + '#';\n\t}\n\n\tint sx, sy, gx, gy;\n\tFOR(i, 1, N) {\n\t\tFOR(j, 1, M) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t\tif(field[i][j] == 'G') {\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<state> Q;\n\tQ.push(state(sx, sy, 0));\n\tvvi typeP(N+2, vi(M+2, INT_MAX));\n\tvvi typeQ(N+2, vi(M+2, INT_MAX));\n\n\ttypeP[sy][sx] = 0;\n\ttypeQ[sy][sx] = 0;\n\n\twhile(!Q.empty()) {\n\t\tstate st = Q.front();\n\t\tQ.pop();\n\n\t\tREP(d, 4) {\n\t\t\tif(field[st.y+dy[d]][st.x+dx[d]] != '#') {\n\t\t\t\tif(st.y == sy && st.x == sx) {\n\t\t\t\t\ttypeP[st.y+dy[d]][st.x+dx[d]] = 0;\n\t\t\t\t\ttypeQ[st.y+dy[d]][st.x+dx[d]] = 0;\n\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], d));\n\t\t\t\t} else {\n\t\t\t\t\tint p = typeP[st.y][st.x];\n\t\t\t\t\tint\tq = typeQ[st.y][st.x];\n\t\t\t\t\tif((st.d+d)%2) {\n\t\t\t\t\t\tif(st.d+d == 3) {\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p < typeP[st.y+dy[d]][st.x+dx[d]] && q < typeQ[st.y+dy[d]][st.x+dx[d]]) {\n\t\t\t\t\t\ttypeP[st.y+dy[d]][st.x+dx[d]] = p;\n\t\t\t\t\t\ttypeQ[st.y+dy[d]][st.x+dx[d]] = q;\n\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(typeP[gy][gx] <= A && typeQ[gy][gx] <= A) {\n\t\tcout << typeP[gy][gx]+typeQ[gy][gx] << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct stat{\n\tint y,x,dir,n1,n2; // n1, n2 : 鏡 /, \\ の残り枚数\n};\n\nint main(){\n\tint h,w,n; scanf(\"%d%d%d\",&h,&w,&n);\n\tchar B[100][101];\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) if(B[i][j]=='S') sx=j, sy=i;\n\n\tstatic int dp[100][100][4][11][11];\n\tmemset(dp,-1,sizeof dp);\n\tdp[sy][sx][3][n][n]=0;\n\trep(n1,n+1) rep(n2,n+1) dp[sy][sx][1][n1][n2]=777;\n\n\tint ans=-1;\n\tqueue<stat> Q;\n\tQ.push((stat){sy,sx,3,n,n});\n\twhile(!Q.empty()){\n\t\tint y=Q.front().y,x=Q.front().x,dir=Q.front().dir,n1=Q.front().n1,n2=Q.front().n2;\n\t\tQ.pop();\n\n\t\tif(B[y][x]=='G'){ ans=dp[y][x][dir][n1][n2]; break; }\n\n\t\tint y2=y+dy[dir],x2=x+dx[dir],dir2;\n\t\tif(y2<0 || h<=y2 || x2<0 || w<=x2 || B[y2][x2]=='#') continue;\n\n\t\t// 鏡を置かない\n\t\tdir2=dir;\n\t\tif(dp[y2][x2][dir2][n1][n2]==-1){\n\t\t\tdp[y2][x2][dir2][n1][n2]=dp[y][x][dir][n1][n2];\n\t\t\tQ.push((stat){y2,x2,dir2,n1,n2});\n\t\t}\n\n\t\t// 鏡 / を置く\n\t\tdir2=dir^1;\n\t\tif(n1>0 && dp[y2][x2][dir2][n1-1][n2]==-1){\n\t\t\tdp[y2][x2][dir2][n1-1][n2]=dp[y][x][dir][n1][n2]+1;\n\t\t\tQ.push((stat){y2,x2,dir2,n1-1,n2});\n\t\t}\n\n\t\t// 鏡 \\ を置く\n\t\tdir2=3-dir;\n\t\tif(n2>0 && dp[y2][x2][dir2][n1][n2-1]==-1){\n\t\t\tdp[y2][x2][dir2][n1][n2-1]=dp[y][x][dir][n1][n2]+1;\n\t\t\tQ.push((stat){y2,x2,dir2,n1,n2-1});\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  // (num,x,y,dir,a1,a2)\n  priority_queue<tuple<int,int,int,int,int,int>, vector<tuple<int,int,int,int,int,int> >, greater<tuple<int,int,int,int,int,int> > > pq;\n  VI dist(idx(W,H,4,A+1,A+1)+1, INF);\n  pq.push(make_tuple(0,sx,sy+1,2,0,0));\n  dist[idx(sx,sy+1,2,0,0)] = 0;\n    \n  while(!pq.empty()){\n\tint num, x, y, d, a1, a2;\n\ttie(num,x,y,d,a1,a2) = pq.top(); pq.pop();\n\tif(x == gx && y == gy) break;\n\tint fr = idx(x,y,d,a1,a2);\n\tif(dist[fr] < num) continue;\n\n\t// ??????????????¨???\n\tif(vs[y][x] == '.'){\n\t  // /?????¢\n\t  if(a1 < A){\n\t\tint td = 3 - d;\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (tx == sx && ty >= sy && td == 0))){\n\t\t  int toid = idx(tx,ty,td,a1+1,a2);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1+1,a2));\n\t\t  }\n\t\t}\n\t  }\n\t  // \\?????¢\n\t  if(a2 < A){\n\t\tint td = d-(d%2*2-1);\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (tx == sx && ty >= sy && td == 0))){\n\t\t  int toid = idx(tx,ty,td,a1,a2+1);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1,a2+1));\n\t\t  }\n\t\t}\n\t  }\n\t}\n\n\t//??´???\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint toid = idx(tx,ty,d,a1,a2);\n\tif(dist[toid] > num){\n\t  dist[toid] = num;\n\t  pq.push(make_tuple(num,tx,ty,d,a1,a2));\n\t}\n  }\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tans = min(ans, dist[tid]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n#define INF 100\nusing namespace std;\nstruct data{\n\tint x,y,p,q,dir;\n\tdata(){}\n\tdata(int yy,int xx,int dd,int pp,int qq){\n\t\tx=xx;\n\t\ty=yy;\n\t\tp=pp;\n\t\tq=qq;\n\t\tdir=dd;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn q>d.q;\n\t}\n};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint n,m,a;\nint fie[101][101];\nint dp[101][101][4][11];\nint sx,sy,gx,gy;\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tdp[i][j][k][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(sy,sx,1,0,0));\n\tdp[sy][sx][1][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.y][q.x][q.dir][q.p]<q.q)continue;\n\t\tif(0<=q.x+dx[q.dir] && q.x+dx[q.dir]<m && 0<=q.y+dy[q.dir] && q.y+dy[q.dir]<n){\n\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]!=-1 && dp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]>q.q){\n\t\t\t\tdp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]=q.q;\n\t\t\t\tque.push(data(q.y+dy[q.dir],q.x+dx[q.dir],q.dir,q.p,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.p<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=3;\n\t\t\tif(q.dir==1)ndir=2;\n\t\t\tif(q.dir==2)ndir=1;\n\t\t\tif(q.dir==3)ndir=0;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p+1]>q.q){\n\t\t\t\tdp[q.y][q.x][ndir][q.p+1]=q.q;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p+1,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.q<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=1;\n\t\t\tif(q.dir==1)ndir=0;\n\t\t\tif(q.dir==2)ndir=3;\n\t\t\tif(q.dir==3)ndir=2;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p]>q.q+1){\n\t\t\t\tdp[q.y][q.x][ndir][q.p]=q.q+1;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p,q.q+1));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tres=min(res,dp[gy][gx][j][i]+i);\n\t\t}\n\t}\n\treturn res!=INF?res:-1;\n}\n\nint main(void){\n\tscanf(\"%d %d %d %d\",&n,&m,&a);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]=='S')sx=j,sy=i,fie[i][j]=1;\n\t\t\tif(str[j]=='G')gx=j,gy=i,fie[i][j]=2;\n\t\t\tif(str[j]=='#')fie[i][j]=-1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dijk());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint dp[111][111][4][11][11];\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nstruct st{\n  int y,x,d,p,q;\n  st(){}\n  st(int y,int x,int d,int p,int q):y(y),x(x),d(d),p(p),q(q){}\n};\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  int ans=A*2+1;\n  int sy,sx;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S') sy=i,sx=j;\n  memset(dp,-1,sizeof(dp));\n  int ax[]={0,1,0,-1};\n  int ay[]={-1,0,1,0};\n  deque<st> dq;\n  dq.push_back(st(sy,sx,2,0,0));\n  dp[sy][sx][2][0][0]=0;\n  while(!dq.empty()){\n    st r=dq.front();dq.pop_front();\n    int y=r.y,x=r.x,d=r.d,p=r.p,q=r.q;\n    //cout<<y<<\" \"<<x<<\" \"<<d<<\" \"<<p<<\" \"<<q<<endl;\n    if(p+q>=ans) break;\n    if(s[y][x]=='G'){\n      ans=min(ans,p+q);\n      break;\n    }\n    if(s[y][x]=='S'&&d==0) continue;\n    {\n      int ny=y+ay[d],nx=x+ax[d],nd=d;\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p][q]<0||\n\t   dp[ny][nx][nd][p][q]>dp[y][x][d][p][q]){\n\t  dp[ny][nx][nd][p][q]=dp[y][x][d][p][q];\n\t  dq.push_front(st(ny,nx,nd,p,q));\n\t}\n      }\n    }\n    if(s[y][x]!='S'&&p<A){\n      int nd=P(d);\n      int ny=y+ay[nd],nx=x+ax[nd];\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p+1][q]<0||\n\t   dp[ny][nx][nd][p+1][q]>dp[y][x][d][p][q]+1){\n\t  dp[ny][nx][nd][p+1][q]=dp[y][x][d][p][q]+1;\n\t  //cout<<p+1<<\" \"<<q<<endl;\n\t  dq.push_back(st(ny,nx,nd,p+1,q));\n\t}\n      }\n    }\n    if(s[y][x]!='S'&&q<A){\n      int nd=Q(d);\n      int ny=y+ay[nd],nx=x+ax[nd];\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p][q+1]<0||\n\t   dp[ny][nx][nd][p][q+1]>dp[y][x][d][p][q]+1){\n\t  dp[ny][nx][nd][p][q+1]=dp[y][x][d][p][q]+1;\n\t  dq.push_back(st(ny,nx,nd,p,q+1));\n\t}\n      }\n    }\n  }\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint m[4][4];\n\nint h, w, n;\nchar in[100][101];\nbool v[100][100][4][11][11];\n\nint main(){\n\tm[0][3] = m[1][2] = m[3][0] = m[2][1] = 1;\n\t\n\tcin >> h >> w >> n;\n\tint y, x;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t}\n\tpriority_queue<pair<int, pi> > Q;\n\trep(i, 4) Q.push(mp(0, mp(i * h * w + y * w + x, n * 11 + n)));\n\t\n\twhile(!Q.empty()){\n\t\tint co = -Q.top().first;\n\t\tint cd = Q.top().second.first / h / w;\n\t\ty = Q.top().second.first / w % h; x = Q.top().second.first % w;\n\t\tint p = Q.top().second.second / 11, q = Q.top().second.second % 11;\n\t\tQ.pop();\n\t\t\n\t\tif(v[y][x][cd][p][q]) continue;\n\t\tv[y][x][cd][p][q] = 1;\n\t\t\n\t\t//cerr<<y<<\" \"<<x<<\" \"<<cd<<\" \"<<p<<\" \"<<q<<\" \"<<co<<endl;\n\t\t\n\t\tif(in[y][x] == 'G'){\n\t\t\tcout << co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 4) if(d != (cd ^ 2)){\n\t\t\tif(co && in[y][x] == 'S' && dy[d]) continue;\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\tint np = p - 1 + m[cd][d], nq = q - m[cd][d], nc = co;\n\t\t\t\n\t\t\tif(d == cd) np = p, nq = q;\n\t\t\telse nc++;\n\t\t\tif(np < 0 || nq < 0) continue;\n\t\t\t\n\t\t\tif(!v[ny][nx][d][np][nq]) Q.push(mp(-nc, mp(d * h * w + ny * w + nx, np * 11 + nq)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n\nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k) {\n                for (int l = 0; l <= a; ++l) {\n                    dist[i][j][k][l] = 100;\n                }\n            }\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    dist[si][sj][1][0] = 0;\n    qi.push_back(si);\n    qj.push_back(sj);\n    qd.push_back(1);\n    qm.push_back(0);\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        {\n            int td = pd ^ 1;\n            if (pm < a && dist[pi][pj][td][pm + 1] > dis) {\n                dist[pi][pj][td][pm + 1] = dis;\n                qi.push_front(pi);\n                qj.push_front(pj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            if (dist[pi][pj][td][pm] > dis + 1) {\n                dist[pi][pj][td][pm] = dis + 1;\n                qi.push_back(pi);\n                qj.push_back(pj);\n                qd.push_back(td);\n                qm.push_back(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j <= a; ++j) {\n            ans = min(ans, dist[gi][gj][i][j] + j);\n        }\n    }\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nclass State\n{\npublic:\n\tint x,y,d,p,q,c;\n\tState(int x, int y, int d, int p, int q, int c)\n\t\t:x(x),y(y),d(d),p(p),q(q),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint N,M,A;\nbool memo[100][100][4][15][15];\nstring field[100];\n\nbool invaild(int x, int y)\n{\n\tif(x<0||y<0||x>=M||y>=N) return true;\n\tif(field[y][x] == '#') return true;\n\t\n\treturn false;\n}\n\nbool newState(State& s)\n{\n\treturn !memo[s.x][s.y][s.d][s.p][s.q];\n}\n\nState straight(State s)\n{\n\t\n\tint tx = s.x + dx[s.d];\n\tint ty = s.y + dy[s.d];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,s.d,s.p,s.q,s.c);\n}\n\nState useP(State s)\n{\n\tif(s.p == 0) return s;\n\n\tint nd = (s.d+1)%2 + (s.d > 1? 2: 0);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p-1,s.q,s.c+1);\n}\n\nint refQ(int d)\n{\n\tif(d==0) return 3;\n\tif(d==3) return 0;\n\tif(d==1) return 2;\n\n\treturn 1;\n}\n\nState useQ(State s)\n{\n\tif(s.q == 0) return s;\n\n\tint nd = refQ(s.d);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p,s.q-1,s.c+1);\n}\n\n\n\nint solve()\n{\n\tmemset(memo, 0, sizeof(memo));\n\n\tint sx,sy;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<M; j++) {\n\t\tif(field[i][j]=='S') {\n\t\t\tsx = j;\n\t\t\tsy = i;\n\t\t}\n\t}\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,A,A,0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(!newState(s)) continue;\n\t\tmemo[s.x][s.y][s.d][s.p][s.q] = true;\n\n\t\tif(field[s.y][s.x] == 'G') return s.c;\n\n\t\tState ns = straight(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useP(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useQ(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin >> N >> M >> A;\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\t\tcout << solve() << endl;\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100];\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si+1,sj,2,0,0));\n  memo[si+1][sj]=true;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    if(map[u.y][u.x]=='#')break;\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && !memo[a][b]){\n\tmemo[a][b]=true;\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && !memo[a][b]){\n\t  memo[a][b]=true;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && !memo[a][b]){\n\t  memo[a][b]=true;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t  if(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tint xx = x + dx[DOWN];\n\t\tint yy = y + dy[DOWN];\n\n\t\tif (xx < 0 || W <= xx) return -1;\n\t\tif (yy < 0 || H <= yy) return -1;\n\t\tif (S[yy][xx] == '#') return -1;\n\n\t\tdone[yy][xx][0][0][0] = true;\n\t\tque.push(make_pair(make_pair(yy * 1000 + xx, DOWN * 10000), 0));\n\n\t\t/*done[y][x][0][0][0] = true;\n\t\tque.push(make_pair(make_pair(y * 1000 + x, DOWN * 10000), 0));*/\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G')\n\t\t{\n\t\t\treturn c;\n\t\t}\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\n\t\t\tif (S[y][x] == 'S' && i == 1) continue;\n\t\t\tif (S[y][x] == 'S' && i == 3) continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tswitch (dir)\n\t\t\t\t{\n\t\t\t\tcase UP:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RIGHT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOWN:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LEFT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (A < aa) continue;\n\t\t\t\tif (A < bb) continue;\n\t\t\t}\n\t\t\t\n\n\t\t\t//if (done[yy][xx][dd][aa][bb]) continue;\n\t\t\tif (done[yy][xx][0][0][0]) continue;\n\n\t\t\tdone[y][x][0][0][0] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint m[4][4];\n\nint h, w, n;\nchar in[100][101];\nbool v[100][100][4][11][11];\n\nint main(){\n\tm[0][3] = m[1][2] = m[3][0] = m[2][1] = 1;\n\t\n\tcin >> h >> w >> n;\n\tint y, x;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t}\n\tpriority_queue<pair<int, pi> > Q;\n\tQ.push(mp(0, mp(2 * h * w + y * w + x, n * 11 + n)));\n\t\n\twhile(!Q.empty()){\n\t\tint co = -Q.top().first;\n\t\tint cd = Q.top().second.first / h / w;\n\t\ty = Q.top().second.first / w % h; x = Q.top().second.first % w;\n\t\tint p = Q.top().second.second / 11, q = Q.top().second.second % 11;\n\t\tQ.pop();\n\t\t\n\t\tif(v[y][x][cd][p][q]) continue;\n\t\tv[y][x][cd][p][q] = 1;\n\t\t\n\t\t//cerr<<y<<\" \"<<x<<\" \"<<cd<<\" \"<<p<<\" \"<<q<<\" \"<<co<<endl;\n\t\t\n\t\tif(in[y][x] == 'G'){\n\t\t\tcout << co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 4) if(d != (cd ^ 2)){\n\t\t\tif(co && in[y][x] == 'S' && dy[d]) continue;\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\tint np = p - 1 + m[cd][d], nq = q - m[cd][d], nc = co;\n\t\t\t\n\t\t\tif(d == cd) np = p, nq = q;\n\t\t\telse nc++;\n\t\t\tif(np < 0 || nq < 0) continue;\n\t\t\t\n\t\t\tif(!v[ny][nx][d][np][nq]) Q.push(mp(-nc, mp(d * h * w + ny * w + nx, np * 11 + nq)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    q.push(make_tuple(S.first,S.second,1,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if((usedP|usedQ) && masu[i][j] == 'S' && (dir&1)) continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        if(masu[i][j] == 'S') continue;\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y, d, p, q, t;\n\tstate(int x, int y, int d, int p, int q, int t) : x(x), y(y), d(d), p(p), q(q), t(t) {};\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\n\tvs field(N+2);\n\tstring s;\n\tREP(i, M+2) {\n\t\ts += '#';\n\t}\n\tfield[0] = field[N+1] = s;\n\n\tREP(i, N) {\n\t\tcin >> s;\n\t\tfield[i+1] = '#' + s + '#';\n\t}\n\n\tint sx, sy, gx, gy;\n\tREP(i, N+2) {\n\t\tREP(j, M+2) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t\tif(field[i][j] == 'G') {\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<state> Q;\n\tif(field[sy+1][sx] == '#') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t} else {\n\t\tQ.push(state(sx, sy+1, 1, 0, 0, 1));\n\t}\n\n\tvvi turn(N+2, vi(M+2, INT_MAX));\n\tturn[sy][sx] = 0;\n\tturn[sy+1][sx] = 1;\n\n\tbool goal = false;\n\tint ans = INT_MAX;\n\twhile(!Q.empty()) {\n\t\tstate st = Q.front();\n\t\tQ.pop();\n\t\tint cx = st.x;\n\t\tint cy = st.y;\n\n\t\tif(cx == gx && cy == gy) {\n\t\t\tif(max(st.p, st.q) <= A) {\n\t\t\t\tgoal = true;\n\t\t\t\tans = min(ans, st.p+st.q);\n\t\t\t}\n\t\t} else {\n\t\t\tREP(d, 4) {\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tif(turn[ny][nx] < st.t+1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[ny][nx] != '#') {\n\t\t\t\t\tturn[ny][nx] = st.t+1;\n\t\t\t\t\tif(st.d != d) {\n\t\t\t\t\t\tif(st.d+d == 3) {\n\t\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p, st.q+1, st.t+1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p+1, st.q, st.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p, st.q, st.t+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(goal) {\n\t\tcout << ans << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,-1,0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing State = tuple<int, int, int, int, int>;\nconst int N = 101;\nint min_q[N][N][4][11];\n\nint h, w, n;\nvector<string> field;\n\nbool is_p[4][4];\n\ninline bool check(int x, int y){\n    return 0 <= x and x < w and 0 <= y and y < h and field[y][x] != '#';\n}\n\nint main(void){\n    cin >> h >> w >> n;\n    field = vector<string>(h);\n    for(auto & e : field) cin >> e;\n\n    int sx, sy, tx, ty;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] == 'S') sx = x, sy = y, field[y][x] = '.';\n            if(field[y][x] == 'G') tx = x, ty = y, field[y][x] = '.';\n        }\n    }\n\n    rep(i, h) rep(j, w) rep(k, 4) rep(l, n + 1) min_q[i][j][k][l] = inf;\n    priority_queue<State, vector<State>, greater<State>> q;\n    rep(i, 4){\n        if(i != 3) continue;\n        int nx = sx + dx[i], ny = sy + dy[i];\n        if(not check(nx, ny)) continue;\n        q.push(State(0, nx, ny, i, 0));\n        min_q[ny][nx][i][0] = 0;\n    }\n\n    is_p[0][3] = true;\n    is_p[1][2] = true;\n    is_p[2][1] = true;\n    is_p[3][0] = true;\n\n    while(q.size()){\n        int x, y, di, up, uq;\n        tie(uq, x, y, di, up) = q.top(); q.pop();\n\n        if(x == sx and y == sy and di % 2 == 1) continue;\n        \n        rep(ndi, 4){\n            int nx = x + dx[ndi], ny = y + dy[ndi];\n            if(not check(nx, ny)) continue;\n\n            int nup = up, nuq = uq;\n\n            if(ndi != di){\n                if((di + 2) % 2 == ndi) continue;\n                else if(is_p[di][ndi]){\n                    if(up == n) continue;\n                    nup++;\n                }\n                else {\n                    if(uq == n) continue;\n                    nuq++;\n                }\n            }\n\n            assert(field[ny][nx] != '#'); \n            if(not chmin(min_q[ny][nx][ndi][nup], nuq)) continue;\n            q.push(State(nuq, nx, ny, ndi, nup));\n        }\n    }\n\n    int res = inf;\n    rep(di, 4){\n        rep(up, n + 1){\n            chmin(res, up + min_q[ty][tx][di][up]);\n        }\n    }\n    if(res == inf){\n        res = -1;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n\nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k) {\n                for (int l = 0; l <= a; ++l) {\n                    dist[i][j][k][l] = 100;\n                }\n            }\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    dist[si][sj][1][0] = 0;\n    qi.push_back(si);\n    qj.push_back(sj);\n    qd.push_back(1);\n    qm.push_back(0);\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        if (pi == si && pj == sj && pd == 3) continue;\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        {\n            int td = pd ^ 1;\n            if (pm < a && dist[pi][pj][td][pm + 1] > dis) {\n                dist[pi][pj][td][pm + 1] = dis;\n                qi.push_front(pi);\n                qj.push_front(pj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            if (dist[pi][pj][td][pm] > dis + 1) {\n                dist[pi][pj][td][pm] = dis + 1;\n                qi.push_back(pi);\n                qj.push_back(pj);\n                qd.push_back(td);\n                qm.push_back(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j <= a; ++j) {\n            ans = min(ans, dist[gi][gj][i][j] + j);\n        }\n    }\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\nint h, w, a;\nchar m[N][N];\nint dis[N][N][10][10][4];\n\nstruct Point{ int x, y, p, q, d; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tqueue<Point> q;\n\tmemset(dis, -1, sizeof(dis));\n\n\trep(i,4) {\n\t\tdis[p.y][p.x][a][a][i] = 0;\n\t\tPoint tmp = Point{p.x, p.y, a, a, i};\n\t\tq.push(tmp);\n\t}\n\n\twhile(not q.empty()){\n\t\tPoint u = q.front(); q.pop();\n\t\t//cout << u.x << ' ' << u.y << ' ' << u.p << ' ' << u.q << ' ' << u.d << endl;\n\t\trep(i,4){\n\t\t\tif((u.d + 2) % 4 == i) continue;\n\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tnext.d = i;\n\t\t\tif(u.d == 0 || u.d == 2){\n\t\t\t\tif(u.d == i){\n\t\t\t\t\tnext.p = u.p;\n\t\t\t\t\tnext.q = u.q;\n\t\t\t\t}else if((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t\tnext.q = u.q;\n\t\t\t\t}else{\n\t\t\t\t\tnext.p = u.p;\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(u.d == i){\n\t\t\t\t\tnext.p = u.p;\n\t\t\t\t\tnext.q = u.q;\n\t\t\t\t}else if((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p;\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}else{\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t\tnext.q = u.q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(next.p < 0 || next.q < 0) continue;\n\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(dis[next.y][next.x][next.p][next.q][next.d] == -1 && m[next.y][next.x] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[next.y][next.x][next.p][next.q][next.d] = dis[u.y][u.x][u.p][u.q][u.d] + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[g.y][g.x][i][j][k] == -1) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tPoint s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = Point{j,i};\n\t\tif(m[i][j] == 'G') g = Point{j,i};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tdone[y][x][2][0][0] = true;\n\t\tque.push(make_pair(make_pair(y * 1000 + x, 2 * 10000), 0));\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G') return c;\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tint flag = (i / 2 + dir / 2) % 2;\n\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\taa++;\n\t\t\t\t\tif (A < aa) continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbb++;\n\t\t\t\t\tif (A < bb) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\tif (done[yy][xx][dd][aa][bb]) continue;\n\n\t\t\tdone[y][x][dir][a][b] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n}State;\n\nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n\n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n\nint dist[310][310][4][11][11];\n\nint bfs(){\n    queue<State> que;\n    //map<State, int> dist;\n    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n    \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n            for(int i=-1; i<2; i++){\n                State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                \n                if(dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] < 0){\n                    dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] = dist[u.h][u.w][u.dir][u.pq[0]][u.pq[1]];\n                    if(i >= 0)\n                        dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]];\n                    \n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n    \n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n    \n    cout << bfs() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nbool ok[111][111][11][11][4];\n\nstruct Dat\n{\n\tint x, y, p, q, dir;\n};\n\nbool update(Dat dat)\n{\n\tif (ok[dat.x][dat.y][dat.p][dat.q][dat.dir]) return false;\n\tok[dat.x][dat.y][dat.p][dat.q][dat.dir] = true;\n\treturn true;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tMS(ok, false);\n\tint h, w, a; cin >> h >> w >> a;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tqueue<Dat> que;\n\tint sx, sy, gx, gy;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == 'S')\n\t\t{\n\t\t\tsx = i, sy = j;\n\t\t\tfld[i][j] = '.';\n\t\t\tDat tmp{ i,j,0,0,3 };\n\t\t\tupdate(tmp);\n\t\t\tque.push(tmp);\n\t\t}\n\t\tif(fld[i][j] == 'G')\n\t\t{ \n\t\t\tfld[i][j] = '.';\n\t\t\tgx = i, gy = j;\n\t\t}\n\t}\n\tint ans = INF;\n\twhile (que.size())\n\t{\n\t\tDat t = que.front();\n\t\tque.pop();\n\t\tint x = t.x, y = t.y, p = t.p, q = t.q, dir = t.dir;\n\t\tif (x == gx&&y == gy)\n\t\t{\n\t\t\tchmin(ans, p + q);\n\t\t\tcontinue;\n\t\t}\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\tif (nx == sx && ny == sy && (dir == 0 || dir == 3)) continue;\n\t\tif (dir == 0)\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 0;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 1;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 2;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t\telse if (dir == 1)\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 1;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 0;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 3;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t\telse if (dir == 2)\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 2;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 3;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 0;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 3;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 2;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 1;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t}\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,4));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100][10];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.x][s.y][s.prev_dir]) continue;\n      dp[s.x][s.y][s.prev_dir] = true;\n\n      // printf(\"x:%d y:%d prev:%d\\n\",s.x,s.y,s.prev_dir);\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(s.prev_dir == 4 && i != 2) continue;\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\tif(stage[s.y][s.x] == 'S'){\n\t  if(s.prev_dir != 4 && s.prev_dir != i){\n\t    continue;\n\t  }\n\t}\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tif(s.prev_dir == (i + 2) % 4) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  que.emplace(si, sj, 0, 0, 0);\n  vis[si][sj][0][0][0] = true;\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (np > a || nq > a) continue;\n      int nd = dd[k][d];\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      if (t[ni][nj] == '#') continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    //for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    q.push(make_tuple(S.first,S.second,1,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(masu[i][j] == 'S') continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  int &u=used[x][y][p][q][dir];\n  if(ans<=2*A-(p+q)||(u!=-1&&u<=2*A-(p+q)))return;\n  u=2*A-(p+q);\n  \n  vector<int> X,Y,ch;\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')break;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[105];\nPII dp[105][105][4];\nsigned main(void)\n{\n  int h, w, a;\n  cin >> h >> w >> a;\n  REP(i, h) cin >> s[i];\n  int sx, sy, gx, gy;\n  REP(i, h) REP(j, w) {\n    if(s[i][j] == 'S') sx = j, sy = i;\n    else if(s[i][j] == 'G') gx = j, gy = i;\n  }\n\n  REP(i, h) REP(j, w) REP(k, 4) dp[i][j][k] = {INF, INF};\n\n  FOR(i, sy, h) {\n    if(s[i][sx] != '.') break;\n    dp[i][sx][0] = {0, 0};\n  }\n\n  REP(i, 2*a) {\n    REP(y, h) REP(x, w) REP(dir, 4) {\n      //????????????\n      if(dp[y][x][dir].first + dp[y][x][dir].second == i) {\n        if(dir == 0) {\n          //???????????????????????? typeQ\n          for(int j=x; j>=0; --j) {\n            if(s[y][j] != '.') break;\n            if(dp[y][j][1] == PII{INF, INF}) {\n              dp[y][j][1] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n          //???????????????????????? typeP\n          for(int j=x; j<w; ++j) {\n            if(s[y][j] != '.') break;\n            if(dp[y][j][3] == PII{INF, INF}) {\n              dp[y][j][3] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n        } else if(dir == 1) {\n          //???????????????????????? typeP\n          for(int j=y; j>=0; --j) {\n            if(s[j][x] != '.') break;\n            if(dp[j][x][2] == PII{INF, INF}) {\n              dp[j][x][2] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n          //???????????????????????? typeQ\n          for(int j=y; j<h; ++j) {\n            if(s[j][x] != '.') break;\n            if(dp[j][x][0] == PII{INF, INF}) {\n              dp[j][x][0] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n        } else if(dir == 2) {\n          //???????????????????????? typeP\n          for(int j=x; j>=0; --j) {\n            if(s[y][j] != '.') break;\n            dp[y][j][1] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n          }\n          //???????????????????????? typeQ\n          for(int j=x; j<w; ++j) {\n            if(s[y][j] != '.') break;\n            dp[y][j][3] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n          }\n        } else if(dir == 3) {\n          //???????????????????????? typeQ\n          for(int j=y; j>=0; --j) {\n            if(s[j][x] != '.') break;\n            if(dp[j][x][2] == PII{INF, INF}) {\n              dp[j][x][2] = {dp[y][x][dir].first, dp[y][x][dir].second+1};\n            }\n          }\n          //???????????????????????? typeP\n          for(int j=y; j<h; ++j) {\n            if(s[j][x] != '.') break;\n            if(dp[j][x][0] == PII{INF, INF}) {\n              dp[j][x][0] = {dp[y][x][dir].first+1, dp[y][x][dir].second};\n            }\n          }\n        }\n      }\n    }\n  }\n\n  int ret = INF;\n  REP(i, 4) {\n    if(dp[gy][gx][i].first <= a && dp[gy][gx][i].second <= a) {\n      ret = min(ret, dp[gy][gx][i].first + dp[gy][gx][i].second);\n    }\n  }\n\n  if(ret == INF) cout << -1 << endl;\n  else cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct node{\n    int x, y, dir, p, q;\n    node(){}\n    node(int _x, int _y, int _dir, int _p, int _q){\n        x = _x; y = _y; dir = _dir; p = _p; q = _q;\n    }\n    bool operator < (const node &a) const{\n        return p + q < a.p + a.q;\n    }\n};\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nconst int inf = 111111;\nbool f[111][111][4][11][11];\nchar map[111][111];\nint n, m, tot, sx, sy;\nqueue<node> Q;\n\nbool isValid(node t) {\n    if (t.x < 0 || t.x >= n || t.y < 0 || t.y >= m || map[t.x][t.y] == '#') return false;\n    if (t.p > tot || t.q > tot || !f[t.x][t.y][t.dir][t.p][t.q]) return false;\n    return true;\n}\n\nint main(){\n    while (scanf(\"%d %d %d\", &n, &m, &tot) == 3){\n        for (int i=0; i<n; ++i){\n            scanf(\"%s\", map[i]);\n            for (int j=0; j<m; ++j)\n                if (map[i][j] == 'S'){\n                    sx = i; sy = j;\n                }\n        }\n        int ans = inf;\n        while (!Q.empty()) Q.pop();\n        memset(f, true, sizeof(f));\n        f[sx][sy][0][0][0] = false;\n        Q.push(node(sx, sy, 0, 0, 0));\n        while (!Q.empty()){\n            node t = Q.front(); Q.pop();\n            if (map[t.x][t.y] == 'S' && t.dir == 2) continue;\n            if (map[t.x][t.y] == 'G') ans = min(ans, t.p + t.q);\n            int up = map[t.x][t.y] == 'S' ? 1 : 3;\n            for (int k = 0; k < 3; ++k){\n                node nx = t;\n                if (k == 1){\n                    nx.dir ^= 1;\n                    nx.p++;\n                } else if (k == 2){\n                    nx.dir = 3 - nx.dir;\n                    nx.q++;\n                }\n                nx.x += dx[nx.dir];\n                nx.y += dy[nx.dir];\n                if (isValid(nx)){\n                    f[nx.x][nx.y][nx.dir][nx.p][nx.q] = false;\n                    Q.push(nx);\n                }\n            }\n        }\n        if (ans == inf) ans = -1;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif((tr!=sr||tc!=sc)&&!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.a<c&&!bfs[tr][tc][at.a+1][at.b][at.d^1]){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.b<c&&!bfs[tr][tc][at.a][at.b+1][at.d^2]){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w,m;cin>>h>>w>>m && h|w|m;){\n\t\tvector<string> grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tstatic int vis[100][100][4][11][11];\n\t\tmemset(vis,0,sizeof vis);\n\t\t\n\t\tconst int di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\t\n\t\tqueue<tuple<int,int,int,int,int>> q; // (i,j,dir,used p,used q)\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\tq.emplace(i+1,j,1,0,0);\n\t\t\n\t\twhile(q.size()){\n\t\t\tint ci,cj,cd,cp,cq; tie(ci,cj,cd,cp,cq)=q.front(); q.pop();\n\t\t\tif(ci<0 || h<=ci || cj<0 || w<=cj ||\n\t\t\t   grid[ci][cj]=='#' || cp>m || cq>m || vis[ci][cj][cd][cp][cq])\n\t\t\t\tcontinue;\n\t\t\tif(grid[ci][cj]=='S' && cd==0) continue; // Sを北向きに通過することはできない\n\t\t\tvis[ci][cj][cd][cp][cq]=1;\n\t\t\t\n\t\t\tq.emplace(ci+di[cd],cj+dj[cd],cd,cp,cq);\n\t\t\tif(grid[ci][cj]=='S') continue;\n\t\t\tint nd=3-cd; q.emplace(ci+di[nd],cj+dj[nd],nd,cp+1,cq);\n\t\t\tnd=(cd+2)%4; q.emplace(ci+di[nd],cj+dj[nd],nd,cp,cq+1);\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='G')\n\t\t\trep(d,4) rep(p,m+1) rep(q,m+1) if(vis[i][j][d][p][q])\n\t\t\t\tres=min(res,p+q);\n\t\tcout<<(res<INF?res:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint memo[102][102][4][11][11];\nint field[102][102];\nint A;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstruct aa {\n\tint y;\n\tint x;\n\tint way;\n\tint p;\n\tint q;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn 2*A-(l.p+l.q)> 2 * A - (r.p+r.q);\n\t}\n};\n\n\n\nint pc(const int way) {\n\tif (way == 0) {\n\t\treturn 3;\n\t}\n\telse if (way == 1) {\n\t\treturn 2;\n\t}\n\telse if (way == 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\nint qc(const int way) {\n\tif (way == 0) {\n\t\treturn 1;\n\t}\n\telse if (way == 1) {\n\t\treturn 0;\n\t}\n\telse if (way == 2) {\n\t\treturn 3;\n\t}\n\telse {\n\t\treturn 2;\n\t}\n}\nint main() {\n\tmemset(memo, -1, sizeof(memo));\n\tint N, M; cin >> N >> M >> A;\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[0][j] = 0;\n\t}\n\tint sx, sy;\n\tint gx, gy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfield[i][0] = 0;\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (st[j] == 'S') {\n\t\t\t\tsx = j + 1;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'G') {\n\t\t\t\tgx = j + 1;\n\t\t\t\tgy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfield[i][M+1] = 0;\n\t}\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[N+1][j] = 0;\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tque.push(aa{ sy,sx,i,A,A });\n\n\t}\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = A - atop.p + A - atop.q;\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tconst int nway = atop.way;\n\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q]<0) {\n\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q] = 1;\n\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.p) {\n\t\t\t\tconst int nway = pc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p - 1, atop.q });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.q) {\n\t\t\t\tconst int nway = qc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q - 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint H, W, A, sx, sy, gx, gy, dx[] = { 0, 1, 0, -1 }, dy[] = { 1, 0, -1, 0 }; bool vis[109][109][4][15][15]; string s[109];\nvoid dfs(int x, int y, int dir, int mp, int mq) {\n\tvis[x][y][dir][mp][mq] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif ((i ^ 2) == dir) continue;\n\t\tif ((s[x][y] == 'S' || s[x][y] == 'G') && i != dir) continue;\n\t\tint tx = x + dx[i], ty = y + dy[i], nmp = mp + ((i ^ 1) == dir), nmq = mq + ((i ^ 3) == dir);\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && nmp <= A && nmq <= A && !vis[tx][ty][i][nmp][nmq]) {\n\t\t\tdfs(tx, ty, i, nmp, nmq);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> H >> W >> A;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == 'S') sx = i, sy = j;\n\t\t\tif (s[i][j] == 'G') gx = i, gy = j;\n\t\t}\n\t}\n\tdfs(sx, sy, 1, 0, 0);\n\tint ret = 1 << 30;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j <= A; j++) {\n\t\t\tfor (int k = 0; k <= A; k++) {\n\t\t\t\tif (vis[gx][gy][i][j][k] && ret > j + k) ret = j + k;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ret == 1 << 30 ? -1 : ret) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)] == '#') return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\tif(y == get<0>(g) and x == get<1>(g)) break;\n\t\tdis[y][x][p][q][d] = 1;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(~val) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    val = INF;\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        char orig = board[x][y];\n        if(x != sx || y != sy) board[x][y] = '#';\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n        board[x][y] = orig;\n    }\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], -1);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint N,M,A;\nbool dp[100][100][11][11][4];\nstring s[100];\nint dx[4]={0,-1,0,1},dy[4]={1,0,-1,0};\nmain()\n{\n\tcin>>N>>M>>A;\n\tdeque<pair<pair<int,int>,pair<pair<int,int>,int> > >Q;\n\tint gx,gy;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>s[i];\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=0;j<M;j++)\n\t\t{\n\t\t\tif(s[i][j]=='S'&&i+1<N&&s[i+1][j]!='#')\n\t\t\t{\n\t\t\t\tdp[i+1][j][A][A][3]=true;\n\t\t\t\tQ.push_back(make_pair(make_pair(i+1,j),make_pair(make_pair(A,A),3)));\n\t\t\t}\n\t\t\telse if(s[i][j]=='G')\n\t\t\t{\n\t\t\t\tgx=i;\n\t\t\t\tgy=j;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front().first.first,y=Q.front().first.second;\n\t\tint a=Q.front().second.first.first,b=Q.front().second.first.second;\n\t\tint dir=Q.front().second.second;\n\t\tQ.pop_front();\n\t\tif(x==gx&&y==gy)\n\t\t{\n\t\t\tcout<<2*A-a-b<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int r=-1;r<=1;r++)\n\t\t{\n\t\t\tif(s[x][y]!='.'&&r!=0)continue;\n\t\t\tint nr=(dir+r+4)%4;\n\t\t\tint tx=x+dx[nr],ty=y+dy[nr];\n\t\t\tint na=a-(dir%2==0?r==-1:r==1);\n\t\t\tint nb=b-(dir%2==0?r==1:r==-1);\n\t\t\tif(0<=tx&&tx<N&&0<=ty&&ty<M&&0<=na&&0<=nb&&s[tx][ty]!='#')\n\t\t\t{\n\t\t\t\tif(!dp[tx][ty][na][nb][nr]&&(s[tx][ty]!='S'||nr%2!=1))\n\t\t\t\t{\n\t\t\t\t\tdp[tx][ty][na][nb][nr]=true;\n\t\t\t\t\tif(r==0)Q.push_front(make_pair(make_pair(tx,ty),make_pair(make_pair(na,nb),nr)));\n\t\t\t\t\telse Q.push_back(make_pair(make_pair(tx,ty),make_pair(make_pair(na,nb),nr)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct state{\n\tint x, y, p, q, dir;\n\tstate(int a, int b, int c, int d, int e){\n\t\tx = a, y = b, p = c, q = d, dir = e;\n\t}\n};\n\nint N, M, A;\nchar map[105][105];\nint sx, sy, gx, gy;\nbool used[105][105][15][15][4];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y, int p, int q, int dir)\n{\n\tused[x][y][p][q][dir] = true;\n\tif(map[x][y] == 'G') return;\n\t\n\tint np, nq, nx, ny;\n\tfor(int nd = 0; nd < 4; nd++){\n\t\tnp = p, nq = q;\n\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\tif(nx < 0 || nx >= M || ny < 0 || ny >= N) continue;\n\t\tif(map[nx][ny] == '#') continue;\n\t\tif(nd == 1 && map[nx][ny] == 'S') continue;\n\t\tif((dir+4-nd) % 4 == 2) continue;\n\t\tif(dir != nd){\n\t\t\tif(map[x][y] == 'S') continue;\n\t\t\tif(dir/2 == nd/2) np++;\n\t\t\telse nq++;\n\t\t}\n\t\tif(np > A || nq > A) continue;\n\t\tif(used[nx][ny][np][nq][nd]) continue;\n\t\tdfs(nx, ny, np, nq, nd);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> A;\n\tfor(int y = 0; y < N; y++){\n\t\tfor(int x = 0; x < M; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'S') sx = x, sy = y;\n\t\t\tif(map[x][y] == 'G') gx = x, gy = y;\n\t\t}\n\t}\n\t\n\tif(sy == N-1 || map[sx][sy+1] == '#'){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsy++;\n\t\n\tfor(int x = 0; x < M; x++){\n\t\tfor(int y = 0; y < N; y++){\n\t\t\tfor(int p = 0; p <= A; p++){\n\t\t\t\tfor(int q = 0; q <= A; q++){\n\t\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\t\tused[x][y][p][q][d] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(sx, sy, 0, 0, 3);\n\t\n\tint ans = 1000;\n\tfor(int p = 0; p <= A; p++){\n\t\tfor(int q = 0; q <= A; q++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tif(used[gx][gy][p][q][d]){\n\t\t\t\t\tans = min(ans, p+q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans == 1000) ans = -1;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,memo[u.y][u.y][u.muki]);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && memo[a][b][u.muki]>memo[u.y][u.x][u.muki]){\n\tmemo[a][b][u.muki]=memo[u.y][u.x][u.muki];\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+1)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+1)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+3)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+3)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Sta{\n\tint x, y, p, q, dir;\n};\n\nconst int MAXN = 105;\nconst int MAXA = 12;\nconst int Way[4][2] = {\n\t{-1,  0},\n\t{ 0,  1},\n\t{ 1,  0},\n\t{ 0, -1}\n};\n\nqueue<Sta> Que;\nint N, M, A, sx, sy, ex, ey;\nchar Gr[MAXN][MAXN];\nbool mark[MAXN][MAXN][MAXA][MAXA][4];\n\nbool check(int x, int y){\n\treturn (x >= 0 && x < N && y >= 0 && y < M);\n}\n\nint updateSta(Sta x){\n\tif(mark[x.x][x.y][x.p][x.q][x.dir]) return 0;\n\tmark[x.x][x.y][x.p][x.q][x.dir] = true;\n\tQue.push(x);\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &M, &A);\n\tfor(int i = 0; i < N; ++i)\n\t\tscanf(\"%s\", Gr[i]);\n\tmemset(mark, false, sizeof(mark));\n\tfor(int i = 0; i < N; ++i)\n\t\tfor(int j = 0; j < M; ++j)\n\t\t\tif(Gr[i][j] == 'S'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}else if(Gr[i][j] == 'G'){\n\t\t\t\tex = i;\n\t\t\t\tey = j;\n\t\t\t}\n\tint initx = sx + Way[2][0];\n\tint inity = sy + Way[2][1];\n\tif(!check(initx, inity)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif(Gr[initx][inity] == 'G'){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(Gr[initx][inity] == '#'){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tSta initSta;\n\tinitSta.x = initx; initSta.y = inity;\n\tinitSta.p = 0; initSta.q = 0;\n\tinitSta.dir = 0;\n\tupdateSta(initSta);\n\tint ans = -1;\n\twhile(!Que.empty()){\n\t\tSta x = Que.front();\n//\t\tprintf(\"Head Sta x = %d, y = %d, p = %d, q = %d, dir = %d\\n\", x.x, x.y, x.p, x.q, x.dir);\n\t\tQue.pop();\n\t\tint nowx = x.x;\n\t\tint nowy = x.y;\n\t\tif(nowx == ex && nowy == ey){\n\t\t\tif(ans == -1) ans = x.p + x.q;\n\t\t\telse ans = min(ans, x.p + x.q);\n\t\t\tcontinue;\n\t\t}\n\t\tint nowp = x.p;\n\t\tint nowq = x.q;\n\t\tint nowdir = x.dir;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tif(i == nowdir) continue;\n\t\t\tint newx = nowx + Way[i][0];\n\t\t\tint newy = nowy + Way[i][1];\n\t\t\tif(!check(newx, newy) || Gr[newx][newy] == '#') continue;\n\t\t\tSta newSta;\n\t\t\tnewSta.x = newx;\n\t\t\tnewSta.y = newy;\n\t\t\tnewSta.p = nowp;\n\t\t\tnewSta.q = nowq;\n\t\t\tnewSta.dir = (i + 2) % 4;\n\t\t\tif(i == (nowdir + 2) % 4){\n\t\t\t\tupdateSta(newSta);\n\t\t\t}else{\n\t\t\t\tif((i + nowdir) != 3){\n\t\t\t\t\tif(newSta.p == A) continue;\n\t\t\t\t\tnewSta.p++;\n\t\t\t\t\tupdateSta(newSta);\n\t\t\t\t}else{\n\t\t\t\t\tif(newSta.q == A) continue;\n\t\t\t\t\tnewSta.q++;\n\t\t\t\t\tupdateSta(newSta);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 100;\nconst int W = 100;\nconst int A = 10;\nconst int INF = 1 << 29;\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\nconst int usep[4] = {3, 2, 1, 0};\nconst int useq[4] = {1, 0, 3, 2};\n\nstruct state{\n  int x, y, d, p, q;\n  state(int y=0, int x=0, int d=0, int p=0, int q=0):x(x),y(y),d(d),p(p),q(q){}\n  bool operator < (const state &s) const {\n    return (p+q) > (s.p+s.q);\n  }\n};\n\nint h, w, a, sy, sx, gy, gx;\nbool G[H][W];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return !G[y][x];\n}\n\nint solve(){\n  bool f[H][W][4][A+1][A+1];\n  priority_queue<state> pq;\n  state u, u2;\n\n  for(int i=0;i<h*w;i++) for(int j=0;j<4;j++) for(int k=0;k<=a;k++) for(int l=0;l<=a;l++) f[i/w][i%w][j][k][l] = false;\n  for(int i=0;i<4;i++) {\n    pq.push(state(sy, sx, i, 0, 0));\n    f[sy][sx][i][0][0] = true;\n  }\n\n  while(!pq.empty()){\n    u = pq.top();\n    pq.pop();\n\n    if(u.y == gy && u.x == gx) return u.p + u.q;\n\n    u2 = state(u.y+dy[u.d], u.x+dx[u.d], u.d, u.p, u.q);\n    if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n      f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n      pq.push(u2);\n    }\n    \n    if(u.p < a){\n      u2 = u;\n      u2.d = usep[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.p++;\n      if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n\n    if(u.q < a){\n      u2 = u;\n      u2.d = useq[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.q++;\n      if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string str;\n  while(cin >> h >> w >> a){\n    for(int i=0;i<h;i++){\n      cin >> str;\n      for(int j=0;j<w;j++){\n        G[i][j] = false;\n        if(str[j] == 'S'){\n          sy = i;\n          sx = j;\n        } else if(str[j] == 'G'){\n          gy = i;\n          gx = j;\n        } else if(str[j] == '#'){\n          G[i][j] = true;\n        }\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si+1][sj][0]=0;\n  memo[si+1][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && memo[a][b][u.muki]>memo[u.y][u.x][u.muki]){\n\tmemo[a][b][u.muki]=memo[u.y][u.x][u.muki];\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+1)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+1)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+3)%4]>memo[u.y][u.x][u.muki]+1){\n\t  memo[a][b][(u.muki+3)%4]=memo[u.y][u.x][u.muki]+1;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nclass Data\n{\npublic:\n    int p, q, y, x, d;\n    Data(int p0, int q0, int y0, int x0, int d0){\n        p = p0;\n        q = q0;\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n    int toInt(){\n        return (((p * 11 + q) * 102 + y) * 102 + x) * 4 + d;\n    }\n};\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n\n    vector<string> s(h+2, string(w+2, '#'));\n    int sy, sx, gy, gx;\n    for(int i=1; i<=h; ++i){\n        for(int j=1; j<=w; ++j){\n            cin >> s[i][j];\n            if(s[i][j] == 'S'){\n                sy = i;\n                sx = j;\n            }\n            if(s[i][j] == 'G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n\n    vector<bool> check(11*11*102*102*4, false);\n    queue<Data> q;\n    for(int i=0; i<4; ++i){\n        Data d(n, n, sy, sx, i);\n        check[d.toInt()] = true;\n        q.push(d);\n    }\n\n    int ret = INT_MAX;\n    while(!q.empty()){\n        Data d = q.front();\n        q.pop();\n\n        if(d.y == gy && d.x == gx){\n            ret = min(ret, 2 * n - d.p - d.q);\n            continue;\n        }\n\n        for(int i=0; i<4; ++i){\n            Data d2 = d;\n            d2.y += dy[i];\n            d2.x += dx[i];\n            d2.d = i;\n            if(s[d2.y][d2.x] == '#')\n                continue;\n\n            if(d.d == i){\n                ;\n            }else if(abs(d.d - i) == 2){\n                continue;\n            }else if((dy[d2.d] + dx[d2.d]) * (dy[d.d] + dx[d.d]) == 1){\n                if(-- d2.p < 0)\n                    continue;\n            }else{\n                if(-- d2.q < 0)\n                    continue;\n            }\n\n            if(check[d2.toInt()])\n                continue;\n\n            check[d2.toInt()] = true;\n            q.push(d2);\n        }\n    }\n\n    if(ret == INT_MAX)\n        cout << -1 << endl;\n    else\n        cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_H 100\n#define MAX_W 100\n#define MAX_A 10\n\nstruct State{\n  int m,x,y,p,q,d;\n  State(int m,int x,int y,int p,int q,int d) :\n    m(m),x(x),y(y),p(p),q(q),d(d) {}\n};\n\nint H,W,A;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nbool visited[MAX_H][MAX_W][MAX_A][MAX_A][4];\n\ninline bool canMove(int x,int y){\n  if(0 <= x && x < W && 0 <= y && y < H\n     && field[y][x] != '#' && field[y][x] != 'S'){\n    return true;\n  }\n  return false;\n}\n\nint bfs(int sx,int sy,int gx,int gy){\n  deque<State> Q;\n  Q.push_back(State(0,sx,sy,A,A,3));\n  visited[sy][sx][A][A][3] = true;\n  \n  while(!Q.empty()){\n    State s = Q.front(); Q.pop_front();\n    int x = s.x, y = s.y;\n    if(x == gx && y == gy){ return s.m; }\n    int nx = x+dx[s.d], ny = y+dy[s.d];\n    if(canMove(nx,ny) && !visited[ny][nx][s.p][s.q][s.d]){\n      visited[ny][nx][s.p][s.q][s.d] = true;\n      Q.push_front(State(s.m,nx,ny,s.p,s.q,s.d));\n    }\n    if(s.p > 0 && field[y][x] == '.'){\n      int ndir = (s.d & 1 ? s.d+3 : s.d+1)%4;\n      if(!visited[y][x][s.p-1][s.q][ndir]){\n        visited[y][x][s.p-1][s.q][ndir] = true;\n        Q.push_back(State(s.m+1,x,y,s.p-1,s.q,ndir));\n      }\n    }\n    if(s.q > 0 && field[y][x] == '.'){\n      int ndir = (s.d & 1 ? s.d+1 : s.d+3)%4;\n      if(!visited[y][x][s.p][s.q-1][ndir]){\n        visited[y][x][s.p][s.q-1][ndir] = true;\n        Q.push_back(State(s.m+1,x,y,s.p,s.q-1,ndir));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  cin >> H >> W >> A;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){\n        sx = j; sy = i;\n      }else if(field[i][j] == 'G'){\n        gx = j; gy = i;\n      }\n    }\n  }\n  cout << bfs(sx,sy,gx,gy) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Sta{\n\tint x, y, p, q, dir;\n};\n\nconst int MAXN = 105;\nconst int MAXA = 12;\nconst int Way[4][2] = {\n\t{-1,  0},\n\t{ 0,  1},\n\t{ 1,  0},\n\t{ 0, -1}\n};\n\nqueue<Sta> Que;\nint N, M, A, sx, sy, ex, ey;\nchar Gr[MAXN][MAXN];\nbool mark[MAXN][MAXN][MAXA][MAXA][4];\n\nbool check(int x, int y){\n\treturn (x >= 0 && x < N && y >= 0 && y < M);\n}\n\nint updateSta(Sta x){\n\tif(mark[x.x][x.y][x.p][x.q][x.dir]) return 0;\n\tmark[x.x][x.y][x.p][x.q][x.dir] = true;\n\tQue.push(x);\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &M, &A);\n\tfor(int i = 0; i < N; ++i)\n\t\tscanf(\"%s\", Gr[i]);\n\tmemset(mark, false, sizeof(mark));\n\tfor(int i = 0; i < N; ++i)\n\t\tfor(int j = 0; j < M; ++j)\n\t\t\tif(Gr[i][j] == 'S'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}else if(Gr[i][j] == 'G'){\n\t\t\t\tex = i;\n\t\t\t\tey = j;\n\t\t\t}\n\tint initx = sx + Way[2][0];\n\tint inity = sy + Way[2][1];\n\tif(!check(initx, inity)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif(Gr[initx][inity] == 'G'){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(Gr[initx][inity] == '#'){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tSta initSta;\n\tinitSta.x = initx; initSta.y = inity;\n\tinitSta.p = 0; initSta.q = 0;\n\tinitSta.dir = 0;\n\tupdateSta(initSta);\n\tint ans = -1;\n\twhile(!Que.empty()){\n\t\tSta x = Que.front();\n//\t\tprintf(\"Head Sta x = %d, y = %d, p = %d, q = %d, dir = %d\\n\", x.x, x.y, x.p, x.q, x.dir);\n\t\tQue.pop();\n\t\tint nowx = x.x;\n\t\tint nowy = x.y;\n\t\tif(nowx == ex && nowy == ey){\n\t\t\tif(ans == -1) ans = x.p + x.q;\n\t\t\telse ans = min(ans, x.p + x.q);\n\t\t\tcontinue;\n\t\t}\n\t\tint nowp = x.p;\n\t\tint nowq = x.q;\n\t\tint nowdir = x.dir;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tif(i == nowdir) continue;\n\t\t\tint newx = nowx + Way[i][0];\n\t\t\tint newy = nowy + Way[i][1];\n\t\t\tif(!check(newx, newy) || Gr[newx][newy] == '#' || Gr[newx][newy] == 'S') continue;\n\t\t\tSta newSta;\n\t\t\tnewSta.x = newx;\n\t\t\tnewSta.y = newy;\n\t\t\tnewSta.p = nowp;\n\t\t\tnewSta.q = nowq;\n\t\t\tnewSta.dir = (i + 2) % 4;\n\t\t\tif(i == (nowdir + 2) % 4){\n\t\t\t\tupdateSta(newSta);\n\t\t\t}else{\n\t\t\t\tif((i + nowdir) != 3){\n\t\t\t\t\tif(newSta.p == A) continue;\n\t\t\t\t\tnewSta.p++;\n\t\t\t\t\tupdateSta(newSta);\n\t\t\t\t}else{\n\t\t\t\t\tif(newSta.q == A) continue;\n\t\t\t\t\tnewSta.q++;\n\t\t\t\t\tupdateSta(newSta);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  vis[si][sj][0][0][0] = true;\n  if (si<n-1 && t[si][sj] != '#') {\n    que.emplace(si+1, sj, 0, 0, 0);\n    vis[si+1][sj][0][0][0] = true;\n  }\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (np > a || nq > a) continue;\n      int nd = dd[k][d];\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      if (t[ni][nj] == '#' || (k && t[i][j] == 'S' && nd == 2)) continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n    \n    bool operator < (const _State r)const{\n        return r.h == h? r.w == w? r.dir==dir? r.pq < pq: r.dir<dir: r.w < w:r.h < h;\n    }\n}State;\n\nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n\n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n\n//int dist[310][310][4][11][11];\n\nint bfs(){\n    queue<State> que;\n    map<State, int> dist;\n//    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s] = 0;\n//    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n    \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n            if(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n            for(int i=-1; i<2; i++){\n                if(nh == Sh && nw == Sw && i>=0) break;\n                \n                State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                \n                if(dist.find(v) == dist.end()){\n                    dist[v] = dist[u];\n                    if(i >= 0)\n                        dist[v]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v];\n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n    \n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n    \n    cout << bfs() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,4));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\n\tuse_mirrors = min(s.P_reflect_count + s.Q_reflect_count,use_mirrors);\n      }\n\n      if(dp[s.x][s.y]) continue;\n      dp[s.x][s.y] = true;\n\n      for(int i=0;i<4;i++){\n\tif(s.prev_dir == 4 && i != 2) continue;\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n//00:00\nint h,w,r;\nint gone[105][105][5][15][15]={};\nchar dat[105][105];\n\nstruct qd{\n\tint y,x,d;\n\tint a,b;\n\tbool operator<(qd v)const{\n\t\treturn (a+b)<(v.a+v.b);\n\t}\n\tbool operator>(qd v)const{\n\t\treturn (v<(*this));\n\t}\n};\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\n\nint sy,sx;\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&r);\n\treg(y,1,h)scanf(\"%s\",dat[y]+1);\n\treg(y,0,h+1)dat[y][0]=dat[y][w+1]='#';\n\treg(x,0,w+1)dat[0][x]=dat[h+1][x]='#';\n\t\n\treg(y,1,h)reg(x,1,w){\n\t\tif(dat[y][x]=='S'){\n\t\t\tsy=y; sx=x;\n\t\t}\n\t}\n\t\n\tpriority_queue<qd> que;\n\t\n\tqd da;\n\tda.d=1; da.x=sx; da.y=sy+1; da.a=da.b=r;\n\tque.push(da);\n\twhile(!que.empty()){\n\t\tqd da = que.top();\n\t\tque.pop();\n\t\tint x=da.x,y=da.y,d=da.d,a=da.a,b=da.b;\n\t\t//printf(\"%d %d %d | %d %d\\n\",y,x,d,a,b);\n\t\tif(gone[y][x][d][a][b])continue;\n\t\tgone[y][x][d][a][b] = 1;\n\t\tif(dat[y][x]=='G'){\n\t\t\tprintf(\"%d\\n\",r+r-da.a-da.b);\n\t\t\treturn 0;\n\t\t}\n\t\treg(i,-1,1){\n\t\t\tint td=(d+i+4)%4;\n\t\t\tint tx=x+dx[td],ty=y+dy[td];\n\t\t\t//printf(\"%d %d %d\\n\",ty,tx,td);\n\t\t\tif(dat[ty][tx]=='#')continue;\n\t\t\tif(i!=0 && dat[y][x]=='S')continue;\t\n\t\t\tqd db=da;\n\t\t\tdb.x=tx; db.y=ty; db.d=td;\n\t\t\tif(i!=0){\n\t\t\t\tif((td+(i>0?1:0))%2==0)db.a--;\n\t\t\t\telse db.b--;\n\t\t\t}\n\t\t\tif(db.a<0 ||db.b<0)continue;\n\t\t\tque.push(db);\n\t\t}\n\t}\n\t\n\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,-1,0,1};\n\nconst int INF = 123;\nint d[100][100][4][11];\n\nstruct State{\n    int y,x,dir,p;\n};\n\nint main(){\n    int h,w,a;\n    cin >>h >>w >>a;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    pair<int,int> start,goal;\n    rep(i,h)rep(j,w){\n        if(s[i][j] == 'S') start = {i,j};\n        if(s[i][j] == 'G') goal = {i,j};\n    }\n\n    auto ok = [&](int y, int x){\n        return (0<=y && y<h && 0<=x && x<w && s[y][x]!='#');\n    };\n\n    rep(i,100)rep(j,100)rep(k,4)rep(l,11) d[i][j][k][l] = INF;\n\n    queue<State> que;\n    if(ok(start.fi+1, start.se)){\n        d[start.fi+1][start.se][3][0] = 0;\n        que.push({start.fi+1, start.se, 3, 0});\n    }\n\n    while(!que.empty()){\n        State c = que.front();\n        que.pop();\n\n        // printf(\"( %d %d %d %d)\\n\", c.y,c.x,c.dir,c.p);\n\n        int D = d[c.y][c.x][c.dir][c.p];\n        State t;\n\n        // 鏡を使わず直進\n        t = c;\n        t.y += dy[t.dir];\n        t.x += dx[t.dir];\n        if(ok(t.y,t.x) && d[t.y][t.x][t.dir][t.p] > D){\n            if(!(t.y==start.fi && t.x==start.se && t.dir==1)){\n                d[t.y][t.x][t.dir][t.p] = D;\n                que.push(t);\n            }\n        }\n\n        // type-P mirror\n        if(t.p<a && s[c.y][c.x]=='.'){\n            t = c;\n            t.dir = 3-t.dir;\n            t.y += dy[t.dir];\n            t.x += dx[t.dir];\n            ++t.p;\n            if(ok(t.y,t.x) && d[t.y][t.x][t.dir][t.p] > D){\n                if(!(t.y==start.fi && t.x==start.se && t.dir==1)){\n                    d[t.y][t.x][t.dir][t.p] = D;\n                    que.push(t);\n                }\n            }\n        }\n\n        // type-Q mirror\n        if(D<a && s[c.y][c.x]=='.'){\n            t = c;\n            t.dir ^= 1;\n            t.y += dy[t.dir];\n            t.x += dx[t.dir];\n            if(ok(t.y,t.x) && d[t.y][t.x][t.dir][t.p] > D+1){\n                if(!(t.y==start.fi && t.x==start.se && t.dir==1)){\n                    d[t.y][t.x][t.dir][t.p] = D+1;\n                    que.push(t);\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,4)rep(j,a+1) ans = min(ans, d[goal.fi][goal.se][i][j]+j);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(val != INF) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        char orig = board[x][y];\n        if(x != sx && y != sy) board[x][y] = '#';\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n        board[x][y] = orig;\n    }\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], INF);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint dp[11][11][4][111][111];\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nstruct st{\n  int y,x,d,p,q;\n  st(){}\n  st(int y,int x,int d,int p,int q):y(y),x(x),d(d),p(p),q(q){}\n};\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  int ans=A*2+1;\n  int sy,sx;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S') sy=i,sx=j;\n  memset(dp,-1,sizeof(dp));\n  int ax[]={0,1,0,-1};\n  int ay[]={-1,0,1,0};\n  deque<st> dq;\n  dq.push_back(st(sy,sx,2,0,0));\n  dp[sy][sx][2][0][0]=0;\n  while(!dq.empty()){\n    st r=dq.front();dq.pop_front();\n    int y=r.y,x=r.x,d=r.d,p=r.p,q=r.q;\n    //cout<<y<<\" \"<<x<<\" \"<<d<<\" \"<<p<<\" \"<<q<<endl;\n    if(p+q>=ans) break;\n    if(s[y][x]=='G'){\n      ans=min(ans,p+q);\n      break;\n    }\n    if(s[y][x]=='S'&&d==0) continue;\n    {\n      int ny=y+ay[d],nx=x+ax[d],nd=d;\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p][q]<0||\n\t   dp[ny][nx][nd][p][q]>dp[y][x][d][p][q]){\n\t  dp[ny][nx][nd][p][q]=dp[y][x][d][p][q];\n\t  dq.push_front(st(ny,nx,nd,p,q));\n\t}\n      }\n    }\n    if(s[y][x]!='S'&&p<A){\n      int nd=P(d);\n      int ny=y+ay[nd],nx=x+ax[nd];\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p+1][q]<0||\n\t   dp[ny][nx][nd][p+1][q]>dp[y][x][d][p][q]+1){\n\t  dp[ny][nx][nd][p+1][q]=dp[y][x][d][p][q]+1;\n\t  //cout<<p+1<<\" \"<<q<<endl;\n\t  dq.push_back(st(ny,nx,nd,p+1,q));\n\t}\n      }\n    }\n    if(s[y][x]!='S'&&q<A){\n      int nd=Q(d);\n      int ny=y+ay[nd],nx=x+ax[nd];\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p][q+1]<0||\n\t   dp[ny][nx][nd][p][q+1]>dp[y][x][d][p][q]+1){\n\t  dp[ny][nx][nd][p][q+1]=dp[y][x][d][p][q]+1;\n\t  dq.push_back(st(ny,nx,nd,p,q+1));\n\t}\n      }\n    }\n  }\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100];\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si+1,sj,2,0,0));\n  memo[si+1][sj]=true;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && !memo[a][b]){\n\tmemo[a][b]=true;\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && !memo[a][b]){\n\t  memo[a][b]=true;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && !memo[a][b]){\n\t  memo[a][b]=true;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t  if(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define S second\n#define F first\n#define N 105\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\ntypedef pair<P,P1> P2;\nint n,m,a,d[N][N],sy,sx;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint dijkstra(){\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P2(P(0,2),P1(P(0,0),P(sy,sx))));\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    int cost=t.F.F,dir=t.F.S;\n    int pcnt=t.S.F.F,qcnt=t.S.F.S;\n    int y=t.S.S.F,x=t.S.S.S;\n    if(s[y][x]=='G')return cost;\n    if(d[y][x]<cost)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i],ncost=cost;\n      int npcnt=pcnt,nqcnt=qcnt;\n      if(ny<0||nx<0||n<=ny||m<=nx)continue;\n      if(s[ny][nx]=='#')continue;\n      if(i!=dir){\n\tif(s[y][x]=='S')continue;\n\tncost++;\n\tint mindir=min(i,dir),maxdir=max(i,dir);\n\tif((mindir==0&&maxdir==1)||(mindir==2&&maxdir==3))npcnt++;\n\telse if((mindir==0&&maxdir==3)||(mindir==1&&maxdir==2)) nqcnt++;\n\telse continue;\n      }\n      if(a<npcnt||a<nqcnt)continue;\n      while(1){\n\tif(ny<0||nx<0||n<=ny||m<=nx)break;\n\tif(s[ny][nx]=='#')break;\n\tif(d[ny][nx]>ncost){\n\t  d[ny][nx]=ncost;\n\t  q.push(P2(P(ncost,i),P1(P(npcnt,nqcnt),P(ny,nx))));\n\t}\n\tny+=dy[i],nx+=dx[i];\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>n>>m>>a;\n  for(int i=0;i<n;i++){\n    cin>>s[i];\n    for(int j=0;j<m;j++)\n      if(s[i][j]=='S')\n\tsy=i,sx=j;\n  }\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define S second\n#define F first\n#define N 105\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\ntypedef pair<P,P1> P2;\nint n,m,a,d[N][N],sy,sx;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint dijkstra(){\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P2(P(0,2),P1(P(0,0),P(sy,sx))));\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    int cost=t.F.F,dir=t.F.S;\n    int pcnt=t.S.F.F,qcnt=t.S.F.S;\n    int y=t.S.S.F,x=t.S.S.S;\n    if(s[y][x]=='G')return cost;\n    if(d[y][x]<cost)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i],ncost=cost;\n      int npcnt=pcnt,nqcnt=qcnt;\n      if(ny<0||nx<0||n<=ny||m<=nx)continue;\n      if(s[ny][nx]=='#')continue;\n      if(i!=dir){\n\tncost++;\n\tint mindir=min(i,dir),maxdir=max(i,dir);\n\tif((mindir==0&&maxdir==1)||(mindir==2&&maxdir==3))npcnt++;\n\telse if((mindir==0&&maxdir==3)||(mindir==1&&maxdir==2)) nqcnt++;\n\telse continue;\n      }\n      if(a<npcnt||a<nqcnt)continue;\n      if(d[ny][nx]>ncost){\n\td[ny][nx]=ncost;\n\tq.push(P2(P(ncost,i),P1(P(npcnt,nqcnt),P(ny,nx))));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>n>>m>>a;\n  for(int i=0;i<n;i++){\n    cin>>s[i];\n    for(int j=0;j<m;j++)\n      if(s[i][j]=='S')\n\tsy=i,sx=j;\n  }\n  cout<<dijkstra()<<endl;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++)\n      cout<<d[i][j]<<' ';\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, A;\nchar S[200][200];\nll dp[100][100][4][11][11];\n\nconst ll INF = 1LL << 50;\nconst ll dy[4] = { -1, +0, +1, +0 };\nconst ll dx[4] = { +0, +1, +0, -1 };\n\nstruct state {\n  ll y, x, dir, p, q, dist;\n  bool operator<(const state &s) const {\n    return dist > s.dist;\n  }\n};\n\nint main(void) {\n  cin >> N >> M >> A;\n  REP(i, 0, N) REP(j, 0, M) cin >> S[i][j];\n\n  ll sy, sx, gy, gx;\n  REP(i, 0, N) REP(j, 0, M) {\n    if(S[i][j] == 'S') {\n      sy = i;\n      sx = j;\n    }\n    if(S[i][j] == 'G') {\n      gy = i;\n      gx = j;\n    }\n  }\n\n  REP(y, 0, N) REP(x, 0, M) REP(dir, 0, 4) REP(p, 0, A + 1) REP(q, 0, A + 1) dp[y][x][dir][p][q] = INF;\n\n  priority_queue<state> que;\n  if(sy + 1 < N) que.push((state) { sy + 1, sx, 2, 0, 0, 0 });\n\n  while(!que.empty()) {\n    state s = que.top();\n    que.pop();\n\n    ll y = s.y, x = s.x, dir = s.dir, p = s.p, q = s.q, dist = s.dist;\n\n    if(dp[y][x][dir][p][q] <= dist) continue;\n    dp[y][x][dir][p][q] = dist;\n\n    if(y == gy && x == gx) {\n      cout << dist << endl;\n      return 0;\n    }\n\n    REP(k, -1, 2) {\n      if(y == sy && x == sx && k != 0) continue;\n      ll ndir = (dir + k + 4) % 4;\n      ll ny = y + dy[ndir];\n      ll nx = x + dx[ndir];\n      ll np = p;\n      ll nq = q;\n      if(dir % 2 == 0) {\n        np += (k == -1 ? 1 : 0);\n        nq += (k == +1 ? 1 : 0);\n      } else {\n        np += (k == +1 ? 1 : 0);\n        nq += (k == -1 ? 1 : 0);\n      }\n      if(0 <= ny && ny < N && 0 <= nx && nx < M && S[ny][nx] != '#' && np <= A && nq <= A) {\n        que.push((state) { ny, nx, ndir, np, nq, np + nq });\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  vis[si][sj][0][0][0] = true;\n  if (si<n-1 && t[si][sj] != '#') {\n    que.emplace(si+1, sj, 0, 0, 0);\n    vis[si+1][sj][0][0][0] = true;\n  }\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (np > a || nq > a) continue;\n      int nd = dd[k][d];\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      if (t[ni][nj] == '#' || (t[i][j] == 'S' && nd == 2)) continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <iostream>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\nint n,m;\nchar g[111][111];\n\nint dp[101][101][101][11][4];\n\nstruct node\n{\n\tint x,y,first,use,dir;\n\tnode(){}\n\tnode(int a,int b,int c,int d,int e)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t\tfirst=c;\n\t\tuse=d;\n\t\tdir=e;\n\t}\n};\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool isin(int x,int y)\n{\n\treturn x>=1&&x<=n&&y>=1&&y<=m&&g[x][y]!='#';\n}\n\nint mp[4][4];\nqueue <node> Q;\n\nint wherex[111],wherey[111];\nint to[111][111];\n\nint main()\n{\n\tmemset(mp,-1,sizeof(mp));\n\tmp[0][1]=0;mp[0][3]=1;\n\tmp[1][0]=0;mp[1][2]=1;\n\tmp[2][3]=0;mp[2][1]=1;\n\tmp[3][2]=0;mp[3][0]=1;\n\tint a;\n\twhile(~scanf(\"%d %d %d\",&n,&m,&a))\n\t{\n\t\tfor(int i=1;i<=n;i++)scanf(\"%s\",g[i]+1);\n\t\tmemset(to,0,sizeof(to));\n\t\tint cnt=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tif(g[i][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tif(i+1<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j][0][0][0]=0;\n\t\t\t\t\t\tQ.push(node(i+1,j,0,0,0));\n\t\t\t\t\t\tfor(int k=i+1;k<=n;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\twherex[cnt]=k;\n\t\t\t\t\t\t\twherey[cnt]=j;\n\t\t\t\t\t\t\tto[k][j]=cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tint ans=-1;\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tnode now=Q.front();\n\t\t\tQ.pop();\n\t\t\tint val=dp[now.x][now.y][now.first][now.use][now.dir];\n\t\t\tif(g[now.x][now.y]=='G')\n\t\t\t{\n\t\t\t\tif(ans==-1||ans>val+now.use)\n\t\t\t\t{\n\t\t\t\t\tans=val+now.use;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)if(mp[now.dir][i]!=-1)\n\t\t\t{\n\t\t\t\tint nxx=now.x+dx[i];\n\t\t\t\tint nxy=now.y+dy[i];\n\t\t\t\tif(now.first&&wherex[now.first]==nxx&&wherey[now.first]==nxy)continue;\n\t\t\t\tint use=mp[now.dir][i];\n\t\t\t\tif(isin(nxx,nxy))\n\t\t\t\t{\n\t\t\t\t\tif(now.use+use<=a)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nxval=val+(!use);\n\t\t\t\t\t\tif(nxval>a)continue;\n\t\t\t\t\t\tint nxfirst=now.first;\n\t\t\t\t\t\tif(nxfirst==0)nxfirst=to[nxx][nxy];\n\t\t\t\t\t\tint &nx=dp[nxx][nxy][nxfirst][now.use+use][i];\n\t\t\t\t\t\tif(nx==-1||nx>nxval)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnx=nxval;\n\t\t\t\t\t\t\tQ.push(node(nxx,nxy,nxfirst,now.use+use,i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nxx=now.x+dx[now.dir];\n\t\t\tint nxy=now.y+dy[now.dir];\n\t\t\tif(isin(nxx,nxy))\n\t\t\t{\n\t\t\t\tint &nx=dp[nxx][nxy][now.first][now.use][now.dir];\n\t\t\t\tif(nx==-1||nx>val)\n\t\t\t\t{\n\t\t\t\t\tnx=val;\n\t\t\t\t\tQ.push(node(nxx,nxy,now.first,now.use,now.dir));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nvoid pr(int x,int y,int dir){\n  char ch[]={'V','^','>','<'};\n  char tmp=mp[y][x];\n  mp[y][x]=ch[dir];\n  for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  mp[y][x]=tmp;\n  cout<<\"------\"<<endl;\n}\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(2*A-(p+q)>=ans)return;\n  if(used[x][y][p][q][dir]++)return;\n  \n  vector<int> X,Y,ch;\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')break;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\npii f(pii a, pii b, int x1, int x2){\n    b.first+=x1;\n    b.second+=x2;\n    \n    if(a.first>=b.first && a.second>=b.second)return b;\n    if(a.first<=b.first && a.second<=b.second)return a;\n    abort();\n}\n\nstruct state{\n    int y,x,dir,bs,s;\n};\n\nint main(){\n    int h,w,a;\n    cin>>h>>w>>a;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    pii s,g;\n    rep(i,h)rep(j,w){\n        if(vs[i][j]=='S')s = pii(i,j);\n        if(vs[i][j]=='G')g = pii(i,j);\n    }\n    \n    static int dp[101][101][4][11][11];\n    rep(i,101)rep(j,101)rep(k,4)rep(l,11)rep(m,11)dp[i][j][k][l][m] = INF;\n    dp[s.first][s.second][0][0][0] = 0;\n    \n    queue<state> que;\n    que.push(state{s.first, s.second, 0, 0, 0});\n    \n    // '\\', '/'\n    //テ、ツクツ? テ・ツ渉ウ, テ、ツクツ? テ・ツキツヲ\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    while(que.size()){\n        state q = que.front();\n        que.pop();\n        \n        for(int k = 1;;k++){\n            int ddy = q.y+dy[q.dir]*k;\n            int ddx = q.x+dx[q.dir]*k;\n            \n            if( q.dir == 0 && pii(ddy,ddx)==s)break;\n            if(pii(ddy,ddx)==s)continue;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            int bsnum,snum;\n            \n            //テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==0)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+3)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n            \n            //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==1)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+1)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    rep(i,4){\n        for(int k=1;;k++){\n            int y,x;\n            tie(y,x) = g;\n            int ddy = y+dy[i]*k;\n            int ddx = x+dx[i]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            rep(l,a+1){\n                rep(m,a+1){\n                    ans = min(ans, dp[ddy][ddx][(i+2)%4][l][m]);\n                }\n            }\n        }\n    }\n    if(ans>2*a)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(u.numL+u.numR,ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && memo[a][b][u.muki]>u.numL+u.numR){\n\tmemo[a][b][u.muki]=u.numL+u.numR;\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+1)%4]>u.numL+u.numR+1){\n\t  memo[a][b][(u.muki+1)%4]=u.numL+u.numR+1;\n\t  if(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t  if(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#' && memo[a][b][(u.muki+3)%4]>u.numL+u.numR+1){\n\t  memo[a][b][(u.muki+3)%4]=u.numL+u.numR+1;\n\t  if(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(tr==sr&&tc==sc&&at.d==3)continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.a<c&&!bfs[tr][tc][at.a+1][at.b][at.d^1]){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.b<c&&!bfs[tr][tc][at.a][at.b+1][at.d^2]){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    if(map[u.y][u.x]=='G'){\n      if(u.numL+u.numR>A*2-1)continue;\n      ans=min(memo[u.y][u.x][u.muki],ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(memo[a][b][u.muki]>u.numL+u.numR){\n\t  memo[a][b][u.muki]=u.numL+u.numR;\n\t  Q.push(State(a,b,u.muki,u.numL,u.numR));\n\t}\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+1)%4]>u.numL+u.numR+1){\n\t    memo[a][b][(u.muki+1)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+1)%4)%2==0){\n\t      Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t    }\n\t    if(((u.muki+1)%4)%2==1){\n\t      Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t    }\n\t  }\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+3)%4]>u.numR+u.numL+1){\n\t    memo[a][b][(u.muki+3)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+3)%4)%2==0){\n\t      Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t    }\n\t    if(((u.muki+3)%4)%2==1){\n\t      Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nclass State\n{\npublic:\n\tint x,y,d,p,q,c;\n\tState(int x, int y, int d, int p, int q, int c)\n\t\t:x(x),y(y),d(d),p(p),q(q),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint N,M,A;\nbool memo[100][100][4][10][10];\nstring field[100];\n\nbool invaild(int x, int y)\n{\n\tif(x<0||y<0||x>=M||y>=N) return true;\n\tif(field[y][x] == '#') return true;\n\t\n\treturn false;\n}\n\nbool newState(State& s)\n{\n\treturn !memo[s.x][s.y][s.d][s.p][s.q];\n}\n\nState straight(State s)\n{\n\t\n\tint tx = s.x + dx[s.d];\n\tint ty = s.y + dy[s.d];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,s.d,s.p,s.q,s.c);\n}\n\nState useP(State s)\n{\n\tif(s.p == 0) return s;\n\n\tint nd = (s.d+1)%2 + (s.d > 1? 2: 0);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p-1,s.q,s.c+1);\n}\n\nint refQ(int d)\n{\n\tif(d==0) return 3;\n\tif(d==3) return 0;\n\tif(d==1) return 2;\n\n\treturn 1;\n}\n\nState useQ(State s)\n{\n\tif(s.q == 0) return s;\n\n\tint nd = refQ(s.d);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p,s.q-1,s.c+1);\n}\n\n\n\nint solve()\n{\n\tmemset(memo, 0, sizeof(memo));\n\n\tint sx,sy;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<M; j++) {\n\t\tif(field[i][j]=='S') {\n\t\t\tsx = j;\n\t\t\tsy = i;\n\t\t}\n\t}\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,A,A,0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(!newState(s)) continue;\n\t\tmemo[s.x][s.y][s.d][s.p][s.q] = true;\n\n\t\tif(field[s.y][s.x] == 'G') return s.c;\n\n\t\tState ns = straight(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useP(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tns = useQ(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\t\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\t\tcout << solve() << endl;\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  int x, y, a, b, fr;\n  S(int x, int y, int a, int b, int fr) :\n    x(x), y(y), a(a), b(b), fr(fr) {}\n};\nbool insert(queue<S>& que, bool used[100][100][11][11][4], int x, int y, int a, int b, int fr){\n  if(used[y][x][a][b][fr]) return false;\n  used[y][x][a][b][fr] = true;\n  que.push(S(x, y, a, b, fr));\n  return true;\n}\nint tb[4][4] = {{-1, 0, 2, 1},\n                {0, -1, 1, 2},\n                {2, 1, -1, 0},\n                {1, 2, 0, -1}};\n\nint main(){\n  int H, W, A;\n  while(cin>>H>>W>>A){\n    bool used[100][100][11][11][4] = {};\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    queue<S> que;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == 'S'){\n        int r = 1;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          insert(que, used, nx, ny, 0, 0, r);\n        }\n      }\n    }\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          switch(tb[s.fr][r]){\n            case -1:\n              insert(que, used, nx, ny, s.a, s.b, r);\n              break;\n            case 0:\n              if(s.a + 1 <= A) insert(que, used, nx, ny, s.a + 1, s.b, r);\n              break;\n            case 1:\n              if(s.b + 1 <= A) insert(que, used, nx, ny, s.a, s.b + 1, r);\n              break;\n            case 2:\n              break;\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'G')REP(r, 4)REP(a, A + 1)REP(b, A + 1)if(used[y][x][a][b][r]) ans = min(ans, a + b);\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i + 1 < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i+1,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    if(in[cx][cy] == 'S') continue;\n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef tuple< int, int, int, int, int, int > Pi;\nconst int vy[] = {1, 0, -1, 0}, vx[] = {0, -1, 0, 1};\n\nint v[100][100][11][11][4];\n\nint main()\n{\n  int N, M, A;\n  string S[100];\n\n  cin >> N >> M >> A;\n  for(int i = 0; i < N; i++) cin >> S[i];\n\n\n  int sy, sx;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < M; j++) {\n      if(S[i][j] == 'S') sy = i, sx = j;\n    }\n  }\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, sy, sx, A, A, 0);\n  fill_n(****v, 100 * 100 * 11 * 11 * 4, INF);\n  v[sy][sx][A][A][0] = 0;\n\n  auto isover = [&](int y, int x) -> bool\n  {\n    return (y < 0 || y >= N || x < 0 || x >= M || S[y][x] == '#');\n  };\n\n  while(!que.empty()) {\n    int y, x, latte, malta, dir, cost;\n    tie(cost, y, x, latte, malta, dir) = que.top();\n    que.pop();\n    if(S[y][x] == 'G') {\n      cout << cost << endl;\n      return (0);\n    }\n    if(v[y][x][latte][malta][dir] > cost) continue;\n    for(int i = -1; i <= 1; i++) {\n      int beet = (dir + i + 4) % 4;\n      int ll = latte, rr = malta;\n      int ny = y + vy[beet], nx = x + vx[beet];\n      if(isover(ny, nx)) continue;\n      if(S[ny][nx] == 'S' && beet == 2) continue;\n      if(i != 0) {\n        if((beet + (i == 1)) % 2 == 1) --ll;\n        else --rr;\n      }\n      if(ll >= 0 && rr >= 0 && cost + (i != 0) < v[ny][nx][ll][rr][beet]) {\n        v[ny][nx][ll][rr][beet] = cost + (i != 0);\n        que.emplace(cost + (i != 0), ny, nx, ll, rr, beet);\n      }\n    }\n  }\n  cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n//00:00\n//00:35 WA\nint h,w,r;\nint gone[105][105][5][15][15]={};\nchar dat[105][105];\n\nstruct qd{\n\tint y,x,d;\n\tint a,b;\n\tbool operator<(qd v)const{\n\t\treturn (a+b)<(v.a+v.b);\n\t}\n\tbool operator>(qd v)const{\n\t\treturn (v<(*this));\n\t}\n};\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\n\nint sy,sx;\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&r);\n\treg(y,1,h)scanf(\"%s\",dat[y]+1);\n\treg(y,0,h+1)dat[y][0]=dat[y][w+1]='#';\n\treg(x,0,w+1)dat[0][x]=dat[h+1][x]='#';\n\t\n\treg(y,1,h)reg(x,1,w){\n\t\tif(dat[y][x]=='S'){\n\t\t\tsy=y; sx=x;\n\t\t}\n\t}\n\t\n\tpriority_queue<qd> que;\n\t\n\tqd da;\n\tda.d=1; da.x=sx; da.y=sy+1; da.a=da.b=r;\n\tque.push(da);\n\twhile(!que.empty()){\n\t\tqd da = que.top();\n\t\tque.pop();\n\t\tint x=da.x,y=da.y,d=da.d,a=da.a,b=da.b;\n\t\t//printf(\"%d %d %d | %d %d\\n\",y,x,d,a,b);\n\t\tif(gone[y][x][d][a][b])continue;\n\t\tgone[y][x][d][a][b] = 1;\n\t\tif(dat[y][x]=='S' && d==3)continue;\n\t\tif(dat[y][x]=='G'){\n\t\t\tprintf(\"%d\\n\",r+r-da.a-da.b);\n\t\t\treturn 0;\n\t\t}\n\t\treg(i,-1,1){\n\t\t\tint td=(d+i+4)%4;\n\t\t\tint tx=x+dx[td],ty=y+dy[td];\n\t\t\t//printf(\"%d %d %d\\n\",ty,tx,td);\n\t\t\tif(dat[ty][tx]=='#')continue;\n\t\t\tif(i!=0 && dat[y][x]=='S')continue;\t\n\t\t\tqd db=da;\n\t\t\tdb.x=tx; db.y=ty; db.d=td;\n\t\t\tif(i!=0){\n\t\t\t\tif((td+(i>0?1:0))%2==0)db.a--;\n\t\t\t\telse db.b--;\n\t\t\t}\n\t\t\tif(db.a<0 ||db.b<0)continue;\n\t\t\tque.push(db);\n\t\t}\n\t}\n\t\n\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nbool ok[111][111][11][11][4];\n\nstruct Dat\n{\n\tint x, y, p, q, dir;\n};\n\nbool update(Dat dat)\n{\n\tif (ok[dat.x][dat.y][dat.p][dat.q][dat.dir]) return false;\n\tok[dat.x][dat.y][dat.p][dat.q][dat.dir] = true;\n\treturn true;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tMS(ok, false);\n\tint h, w, a; cin >> h >> w >> a;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tqueue<Dat> que;\n\tint gx, gy;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == 'S')\n\t\t{\n\t\t\tfld[i][j] = '.';\n\t\t\tREP(k, 4)\n\t\t\t{\n\t\t\t\tDat tmp{ i,j,0,0,k };\n\t\t\t\tupdate(tmp);\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t\tif(fld[i][j] == 'G')\n\t\t{ \n\t\t\tfld[i][j] = '.';\n\t\t\tgx = i, gy = j;\n\t\t}\n\t}\n\tint ans = INF;\n\twhile (que.size())\n\t{\n\t\tDat t = que.front();\n\t\tque.pop();\n\t\tint x = t.x, y = t.y, p = t.p, q = t.q, dir = t.dir;\n\t\tif (x == gx&&y == gy)\n\t\t{\n\t\t\tchmin(ans, p + q);\n\t\t\tcontinue;\n\t\t}\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\tif (dir == 0)\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 0;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 1;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 2;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t\telse if (dir == 1)\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 1;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 0;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 3;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t\telse if (dir == 2)\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 2;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 3;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 0;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = 3;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\tDat ndat2 = ndat;\n\t\t\tndat2.p++;\n\t\t\tndat2.dir = 2;\n\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\tDat ndat3 = ndat;\n\t\t\tndat3.q++;\n\t\t\tndat3.dir = 1;\n\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t}\n\t}\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define oo 10000\n#define N 110\nusing namespace std;\n\nstruct node\n{\n\tint x,y,p,q,dir;\n\n\tnode (){}\n\tnode (int a,int b,int c,int d,int e):x(a),y(b),p(c),q(d),dir(e){}\n};\n\nchar dp[N][N][12][12][4];\nqueue<node>que;\nchar map[N][N];\nint mx[4]={-1,0,1,0},my[4]={0,1,0,-1};\nint n,m,a;\n\nbool in_range(int x,int y) {return (x>=0&&x<n&&y>=0&&y<m);}\n\nint main()\n{\n\tint i,j,k,sx,sy,ex,ey,ans,tx,ty;\n\tnode u,v;\n\n\tscanf(\"%d%d%d\",&n,&m,&a);\n\tfor (i=0;i<n;i++)\n\t\tscanf(\"%s\",map[i]);\n\tfor (i=0;i<n;i++)\n\t\tfor (j=0;j<m;j++)\n\t\t{\n\t\t\tif (map[i][j]=='S') {sx=i;sy=j;}\n\t\t\tif (map[i][j]=='G') {ex=i;ey=j;}\n\t\t}\n\n\n\ttx=sx; ty=sy;\n\ttx+=mx[2]; ty+=my[2];\n\tif (!in_range(tx,ty)||map[sx][sy]=='#')\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\tans=oo;\n    while (in_range(tx,ty)&&map[tx][ty]!='#')\n    {\n        memset(dp,0,sizeof(dp));\n        dp[tx][ty][0][0][2]=1;\n        que.push(node(tx,ty,0,0,2));\n        while (!que.empty())\n        {\n            u=que.front(); que.pop();\n            if(u.x>=sx&& u.x <= tx && u.y == ty && u.dir == 0) continue;\n            v=u;\n            v.x+=mx[u.dir]; v.y+=my[u.dir];\n            if (in_range(v.x,v.y)&&map[v.x][v.y]!='#')\n            {\n                if (dp[v.x][v.y][v.p][v.q][v.dir]==0)\n                {\n                    dp[v.x][v.y][v.p][v.q][v.dir]=1;\n                    que.push(v);\n                }\n            }\n\n            if (map[u.x][u.y]=='.')\n            {\n                v=u;\n                v.dir=(v.dir+1)%4;\n                if (u.dir%2==0)\n                    v.q++;\n                else\n                    v.p++;\n                v.x+=mx[v.dir]; v.y+=my[v.dir];\n                if (v.q<=a&&v.p<=a&&in_range(v.x,v.y)&&map[v.x][v.y]!='#')\n                {\n                    if (dp[v.x][v.y][v.p][v.q][v.dir]==0)\n                    {\n                        dp[v.x][v.y][v.p][v.q][v.dir]=1;\n                        que.push(v);\n                    }\n                }\n\n                v=u;\n                v.dir=(v.dir+3)%4;\n                if (u.dir%2==0)\n                    v.p++;\n                else\n                    v.q++;\n                v.x+=mx[v.dir]; v.y+=my[v.dir];\n                if (v.q<=a&&v.p<=a&&in_range(v.x,v.y)&&map[v.x][v.y]!='#')\n                {\n                    if (dp[v.x][v.y][v.p][v.q][v.dir]==0)\n                    {\n                        dp[v.x][v.y][v.p][v.q][v.dir]=1;\n                        que.push(v);\n                    }\n                }\n            }\n        }\n\n        for (i=0;i<=a;i++)\n            for (j=0;j<=a;j++)\n            for (k=0;k<4;k++)\n                if (dp[ex][ey][i][j][k])\n                {\n                    if (k==0&&ey==sy&&ex>=sx&&ex<=tx) continue;\n                    ans=min(ans,i+j);\n                }\n\n        tx+=mx[2]; ty+=my[2];\n\t}\n\n\tif (ans==oo)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct state {\n\tint x, y, used_p, dir, dist;\n\tstate(int x_, int y_, int u, int d, int d_):x(x_), y(y_), used_p(u),dir(d), dist(d_) {}\n\tbool operator>(const state &s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nconstexpr int MAX_SIZE = 100;\nconstexpr int MAX_A = 10;\n\nconstexpr int dx[4] = {0, 1, -1, 0};\nconstexpr int dy[4] = {1, 0, 0, -1};\n\nint h, w, a;\nstring field[MAX_SIZE];\nint dist[MAX_SIZE][MAX_SIZE][MAX_A + 1][4];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nint dijkstra(int sx, int sy, int gx, int gy) {\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INT_MAX);\n\n\tif(!out(sx, sy + 1) && field[sy + 1][sx] != '#') {\n\t\tque.push({sx, sy + 1, 0, 0, 0});\n\t\tdist[sx][sy + 1][0][0] = 0;\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.x][s.y][s.used_p][s.dir] < s.dist) continue;\n\t\tif(s.x == sx && s.y == sy && s.dir == 3) continue;\n\t\tif(s.x == gx && s.y == gy) return s.dist;\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tint next_dist = s.dist;\n\t\t\tint next_used_p = s.used_p;\n\n\t\t\tif(s.x == sx && s.y == sy) {\n\t\t\t\tif(d != s.dir) continue;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif(d == s.dir) {\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t\telse if(d == (s.dir ^ 0x1)) { // type p mirror\n\t\t\t\t\tif(s.used_p == a) continue;\n\t\t\t\t\t++next_dist;\n\t\t\t\t\t++next_used_p;\n\t\t\t\t}\n\t\t\t\telse if(d == (s.dir ^ 0x2)) { // type q mirror\n\t\t\t\t\tif(s.dist - s.used_p == a) continue;\n\t\t\t\t\t++next_dist;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst int nx = s.x + dx[d];\n\t\t\tconst int ny = s.y + dy[d];\n\t\t\tif(out(nx, ny) || field[ny][nx] == '#') continue;\n\t\t\tif(dist[nx][ny][next_used_p][d] > next_dist) {\n\t\t\t\tdist[nx][ny][next_used_p][d] = next_dist;\n\t\t\t\tque.push({nx, ny, next_used_p, d, next_dist});\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> h >> w >> a;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tcin >> field[i];\n\t}\n\n\tint sx, sy, gx, gy;\n\tfor(int y = 0; y < h; ++y) {\n\t\tfor(int x = 0; x < w; ++x) {\n\t\t\tif(field[y][x] == 'S') {\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t}\n\t\t\telse if(field[y][x] == 'G') {\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dijkstra(sx, sy, gx, gy) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int H, W, A;\n    vector<string> F;\n    void input() {\n        cin >> H >> W >> A;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n    }\n\n    struct S {\n        int p, q, y, x, dir;\n        S(int p, int q, int y, int x, int dir) : p(p), q(q), y(y), x(x), dir(dir) {}\n    };\n\n    void find_pos(int& y, int &x, char c) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == c) {\n                    y = i;\n                    x = j;\n                    return;\n                }\n            }\n        }\n        assert(0);\n    }\n\n    const int dy[] = {-1, 0, 1, 0};\n    const int dx[] = {0, 1, 0, -1};\n\n    const int INF = 1<<28;\n\n    bool valid_pos(int y, int x) {\n        if (y < 0 || y >= H) return false;\n        if (x < 0 || x >= W) return false;\n        if (F[y][x] == '#') return false;\n        if (F[y][x] == 'S') return false;\n        return true;\n    }\n\n    void solve() {\n        int sy, sx; find_pos(sy, sx, 'S');\n        static bool D[11][11][101][101][4];\n        memset(D, 0, sizeof(D));\n        queue<S> Q;\n        Q.push(S(0, 0, sy, sx, 2));\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            const int y = c.y;\n            const int x = c.x;\n            for (int i = -1; i <= 1; i++) {\n                int np, nq;\n                if (c.dir % 2 == 0) {\n                    np = c.p + (i < 0); nq = c.q + (i > 0);\n                } else {\n                    np = c.p + (i > 0); nq = c.q + (i < 0);\n                }\n                int ny = y + dy[c.dir]; \n                int nx = x + dx[c.dir];\n                int ndir = (c.dir + i + 4) % 4;\n                if (np > A || nq > A) continue;\n                if (valid_pos(ny, nx)) {\n                    bool& next = D[np][nq][ny][nx][ndir];\n                    if (!next) {\n                        next = true;\n                        Q.push(S(np, nq, ny, nx, ndir));\n                    }\n                }\n            }\n        }\n\n        int gy, gx;\n        find_pos(gy, gx, 'G');\n        int ans = INF;\n        for (int i = 0; i <= A; i++) {\n            for (int j = 0; j <= A; j++) {\n                for (int k = 0; k < 4; k++) {\n                    if (D[i][j][gy][gx][k]) {\n                        ans = min(ans, i + j);\n                    }\n                }\n            }\n        }\n        cout << (ans == INF ? -1: ans) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n// nesw\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nstruct state {\n\tint x, y, d, p, q;\n\tstate(int x, int y, int d, int p, int q) : x(x), y(y), d(d), p(p), q(q) {};\n};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\tvs field(N);\n\tint sx, sy, gx, gy;\n\tREP(i, N) {\n\t\tcin >> field[i];\n\t\tREP(j, M) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\tif(field[i][j] == 'G') {\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vvvvi> visited(N, vvvvi(M, vvvi(4, vvi(A+1, vi(A+1)))));\n\tstack<state> S;\n\tS.push(state(sx, sy, 2, 0, 0));\n\tvisited[sy][sx][2][0][0] = 1;\n\tint ans = INF;\n\twhile(!S.empty()) {\n\t\tstate st = S.top();\n\t\tS.pop();\n\n\t\tif(st.x == gx && st.y == gy) {\n\t\t\tans = min(ans, st.p+st.q);\n\t\t}\n\n\t\tif(st.x == sx && st.y == sy && st.d == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tREP(d, 4) {\n\t\t\tif(abs(st.d-d) == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint nx = st.x+dx[d];\n\t\t\tint ny = st.y+dy[d];\n\t\t\tint np = st.p;\n\t\t\tint nq = st.q;\n\t\t\tif(nx < 0 || M <= nx || ny < 0 || N <= ny || field[ny][nx] == '#') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(st.d == d) {\n\t\t\t\t\n\t\t\t} else if(st.d+d == 3) {\n\t\t\t\tnp++;\n\t\t\t} else {\n\t\t\t\tnq++;\n\t\t\t}\n\n\t\t\tif(A < np || A < nq) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(!visited[ny][nx][d][np][nq]) {\n\t\t\t\tvisited[ny][nx][d][np][nq] = 1;\n\t\t\t\tS.push(state(nx, ny, d, np, nq));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans == INF) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, A;\nchar S[200][200];\nll dp[100][100][4][11][11];\n\nconst ll INF = 1LL << 50;\nconst ll dy[4] = { -1, +0, +1, +0 };\nconst ll dx[4] = { +0, +1, +0, -1 };\n\nstruct state {\n  ll y, x, dir, p, q, dist;\n  bool operator<(const state &s) const {\n    return dist > s.dist;\n  }\n};\n\nint main(void) {\n  cin >> N >> M >> A;\n  REP(i, 0, N) REP(j, 0, M) cin >> S[i][j];\n\n  ll sy, sx, gy, gx;\n  REP(i, 0, N) REP(j, 0, M) {\n    if(S[i][j] == 'S') {\n      sy = i;\n      sx = j;\n    }\n    if(S[i][j] == 'G') {\n      gy = i;\n      gx = j;\n    }\n  }\n\n  REP(y, 0, N) REP(x, 0, M) REP(dir, 0, 4) REP(p, 0, A + 1) REP(q, 0, A + 1) dp[y][x][dir][p][q] = INF;\n\n  priority_queue<state> que;\n  if(sy + 1 < N && S[sy + 1][sx] != '#') {\n    que.push((state) { sy + 1, sx, 2, 0, 0, 0 });\n  }\n\n  while(!que.empty()) {\n    state s = que.top();\n    que.pop();\n\n    ll y = s.y, x = s.x, dir = s.dir, p = s.p, q = s.q, dist = s.dist;\n\n    if(dp[y][x][dir][p][q] <= dist) continue;\n    dp[y][x][dir][p][q] = dist;\n\n    if(y == gy && x == gx) {\n      cout << dist << endl;\n      return 0;\n    }\n\n    REP(k, -1, 2) {\n      if(y == sy && x == sx && k != 0) continue;\n      if(y == sy && x == sx && dir % 2 == 0) continue;\n      ll ndir = (dir + k + 4) % 4;\n      ll ny = y + dy[ndir];\n      ll nx = x + dx[ndir];\n      ll np = p;\n      ll nq = q;\n      if(dir % 2 == 0) {\n        np += (k == -1 ? 1 : 0);\n        nq += (k == +1 ? 1 : 0);\n      } else {\n        np += (k == +1 ? 1 : 0);\n        nq += (k == -1 ? 1 : 0);\n      }\n      if(0 <= ny && ny < N && 0 <= nx && nx < M && S[ny][nx] != '#' && np <= A && nq <= A) {\n        que.push((state) { ny, nx, ndir, np, nq, np + nq });\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\ninline bool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\ninline int P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\ninline int Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(p+q>=ans) return;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n\nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k) {\n                for (int l = 0; l <= a; ++l) {\n                    dist[i][j][k][l] = 100;\n                }\n            }\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    for (int i = 0; i < 4; ++i) {\n        dist[si][sj][i][0] = 0;\n        qi.push_back(si);\n        qj.push_back(sj);\n        qd.push_back(i);\n        qm.push_back(0);\n    }\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        {\n            int td = pd ^ 1;\n            if (pm < a && dist[pi][pj][td][pm + 1] > dis) {\n                dist[pi][pj][td][pm + 1] = dis;\n                qi.push_front(pi);\n                qj.push_front(pj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            if (dist[pi][pj][td][pm] > dis + 1) {\n                dist[pi][pj][td][pm] = dis + 1;\n                qi.push_back(pi);\n                qj.push_back(pj);\n                qd.push_back(td);\n                qm.push_back(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j <= a; ++j) {\n            ans = min(ans, dist[gi][gj][i][j] + j);\n        }\n    }\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 110;\nconst int pmax = 11;\nbool visit[sz][sz][pmax][pmax][4];\n\n#define PUSH(r, c, p, q, d) do{                 \\\n    r_que.push(r);                              \\\n    c_que.push(c);                              \\\n    d_que.push(d);                              \\\n    p_que.push(p);                              \\\n    q_que.push(q);                              \\\n    visit[r][c][p][q][d] = true;                \\\n  }while(0)                                     \\\n\nint main(){\n  int N, M, P;\n  cin >> N >> M >> P;\n  vector<string> F(N + 2, string(M + 2, '#'));\n\n  queue<int> r_que;\n  queue<int> c_que;\n  queue<int> d_que;\n  queue<int> p_que;\n  queue<int> q_que;\n  \n  \n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, -1, 0, 1};\n  int pm[4] = {3, 2, 1, 0};     // /\n  int qm[4] = {1, 0, 3, 2};     // ＼\n  memset(visit, false, sizeof(visit));\n  \n  REP(i, N)REP(j, M){\n    cin >> F[i+1][j+1];\n    if(F[i+1][j+1] == 'S') PUSH(i+1, j+1, P, P, 0);\n  }\n\n  int res = INF;\n  while(!r_que.empty()){\n    int r = r_que.front(); r_que.pop();\n    int c = c_que.front(); c_que.pop();\n    int d = d_que.front(); d_que.pop();\n    int p = p_que.front(); p_que.pop();\n    int q = q_que.front(); q_que.pop();\n    \n    if(F[r][c] == 'G') res = min(res, 2 * P - p - q);\n    \n    int r2 = r + dr[d];\n    int c2 = c + dc[d];\n    \n    \n    if(F[r2][c2] != '#' && !visit[r2][c2][p][q][d]){\n      if(F[r2][c2] != 'S' || d != 2){\n        PUSH(r2, c2, p, q, d);\n      }\n    }\n      \n    if(F[r2][c2] == '.' && p > 0 && !visit[r2][c2][p-1][q][pm[d]]){\n      PUSH(r2, c2, p-1, q, pm[d]);\n    }\n    \n    if(F[r2][c2] == '.' && q > 0 && !visit[r2][c2][p][q-1][qm[d]]){\n      PUSH(r2, c2, p, q-1, qm[d]);\n    }\n  }\n  \n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int inf = 1e9;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint mincost[101][101][4][11][11];\nvoid initcost(){\n    REP(y,101) REP(x,101) REP(d,4) REP(p,11) REP(q,11){\n        mincost[y][x][d][p][q] = inf;\n    }\n}\n\n\nstruct info{\n    int y,x,d,p,q,c;\n    info(int y, int x, int d, int p, int q, int c)\n        :y(y),x(x),d(d),p(p),q(q),c(c){}\n    info(){}\n    bool operator<(const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int h,w,a;\n    cin >> h >> w >> a;\n    vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n    int sy,sx, gy,gx;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> field[i][j];\n            if(field[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(field[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    \n    priority_queue<info> wait;\n    if(field[sy+1][sx]!='#'){\n        wait.push(info(sy+1, sx, 1, a, a, 0));\n    }\n    initcost();\n    mincost[sy+1][sx][1][a][a] = 0;\n\n    while(!wait.empty()){\n        info top = wait.top();\n        int y = top.y;\n        int x = top.x;\n        int d = top.d;\n        int p = top.p;\n        int q = top.q;\n        int c = top.c;\n        wait.pop();\n        if(field[y][x]=='G') continue;\n        if(c > mincost[y][x][d][p][q]) continue;\n\n        for(int i=0; i<4; i++){\n            int ny = y+dy[i];\n            int nx = x+dx[i];\n            int np = p;\n            int nq = q;\n            if(field[ny][nx] == '#') continue;\n            if(field[ny][nx] == 'S' && i==3) continue;\n            if(field[y][x] == 'S' && (i!=d)) continue;\n            if((i+2)%4 == d) continue;\n            if((d+i)%4 == 1) np--;\n            if((d+i)%4 == 3) nq--;\n            if(np<0 || nq<0) continue;\n            if(c+1 < mincost[ny][nx][i][np][nq]){\n                wait.push(info(ny, nx, i, np, nq, c+1));\n                mincost[ny][nx][i][np][nq] = c+1;\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int d=0; d<4; d++){\n        for(int p=0; p<=10; p++){\n            for(int q=0; q<=10; q++){\n                if(mincost[gy][gx][d][p][q] != inf){\n                    ans = min(ans, a-p +a-q);\n                }\n            }\n        }\n    }\n    if(ans == inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define oo 10000\n#define N 110\nusing namespace std;\n\nstruct node\n{\n\tint x,y,p,q,dir;\n\n\tnode (){}\n\tnode (int a,int b,int c,int d,int e):x(a),y(b),p(c),q(d),dir(e){}\n};\n\nchar dp[N][N][12][12][4];\nqueue<node>que;\nchar map[N][N];\nint mx[4]={-1,0,1,0},my[4]={0,1,0,-1};\nint n,m,a;\n\nbool in_range(int x,int y) {return (x>=0&&x<n&&y>=0&&y<m);}\n\nint main()\n{\n\tint i,j,k,sx,sy,ex,ey,ans,tx,ty;\n\tnode u,v;\n\n\tscanf(\"%d%d%d\",&n,&m,&a);\n\tfor (i=0;i<n;i++)\n\t\tscanf(\"%s\",map[i]);\n\tfor (i=0;i<n;i++)\n\t\tfor (j=0;j<m;j++)\n\t\t{\n\t\t\tif (map[i][j]=='S') {sx=i;sy=j;}\n\t\t\tif (map[i][j]=='G') {ex=i;ey=j;}\n\t\t}\n\n\n\ttx=sx; ty=sy;\n\ttx+=mx[2]; ty+=my[2];\n\tif (!in_range(sx,sy)||map[sx][sy]=='#')\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\tans=oo;\n    while (in_range(tx,ty)&&map[tx][ty]!='#')\n    {\n        memset(dp,0,sizeof(dp));\n        dp[tx][ty][0][0][2]=1;\n        que.push(node(tx,ty,0,0,2));\n        while (!que.empty())\n        {\n            u=que.front(); que.pop();\n            if(u.x == tx && u.y == ty && u.dir == 0) continue;\n            v=u;\n            v.x+=mx[u.dir]; v.y+=my[u.dir];\n            if (in_range(v.x,v.y)&&map[v.x][v.y]!='#')\n            {\n                if (dp[v.x][v.y][v.p][v.q][v.dir]==0)\n                {\n                    dp[v.x][v.y][v.p][v.q][v.dir]=1;\n                    que.push(v);\n                }\n            }\n\n            if (map[u.x][u.y]=='.')\n            {\n                v=u;\n                v.dir=(v.dir+1)%4;\n                if (u.dir%2==0)\n                    v.q++;\n                else\n                    v.p++;\n                v.x+=mx[v.dir]; v.y+=my[v.dir];\n                if (v.q<=a&&v.p<=a&&in_range(v.x,v.y)&&map[v.x][v.y]!='#')\n                {\n                    if (dp[v.x][v.y][v.p][v.q][v.dir]==0)\n                    {\n                        dp[v.x][v.y][v.p][v.q][v.dir]=1;\n                        que.push(v);\n                    }\n                }\n\n                v=u;\n                v.dir=(v.dir+3)%4;\n                if (u.dir%2==0)\n                    v.p++;\n                else\n                    v.q++;\n                v.x+=mx[v.dir]; v.y+=my[v.dir];\n                if (v.q<=a&&v.p<=a&&in_range(v.x,v.y)&&map[v.x][v.y]!='#')\n                {\n                    if (dp[v.x][v.y][v.p][v.q][v.dir]==0)\n                    {\n                        dp[v.x][v.y][v.p][v.q][v.dir]=1;\n                        que.push(v);\n                    }\n                }\n            }\n        }\n\n        for (i=0;i<=a;i++)\n            for (j=0;j<=a;j++)\n            for (k=0;k<4;k++)\n                if (dp[ex][ey][i][j][k])\n                    ans=min(ans,i+j);\n\n        tx+=mx[2]; ty+=my[2];\n\t}\n\n\n\n\n\n\tif (ans==oo)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    if(i<0 || i>=n || j<0 || j>=m) return -1;\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i+1,j,0,0,0);\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  auto ok = [&](int i, int j){\n    return (vec[i][j]=='.' || vec[i][j]=='G' || vec[i][j]=='S');\n  };\n\n  rep(i,n)rep(j,m-1){\n    if( ok(i,j) && ok(i,j+1) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( ok(i,j) && ok(i+1,j) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        v[p].pb(f(i,j-1,x+1,y,3));\n        v[p+1].pb(f(i-1,j,x+1,y,2));\n        v[p+2].pb(f(i,j+1,x+1,y,1));\n        v[p+3].pb(f(i+1,j,x+1,y,0));\n      }\n      if(y<a){\n        v[p].pb(f(i,j+1,x,y+1,1));\n        v[p+1].pb(f(i+1,j,x,y+1,0));\n        v[p+2].pb(f(i,j-1,x,y+1,3));\n        v[p+3].pb(f(i-1,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(to==-1) continue;\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    Q.pop();\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(memo[u.y][u.x][u.muki],ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(memo[a][b][u.muki]>=u.numL+u.numR){\n\t  memo[a][b][u.muki]=u.numL+u.numR;\n\t  Q.push(State(a,b,u.muki,u.numL,u.numR));\n\t}\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+1)%4]>=u.numL+u.numR+1){\n\t    memo[a][b][(u.muki+1)%4]=u.numR+u.numL+1;\n\t    if(memo[a][b][(u.muki+1)%4]<ans){\n\t      if(((u.muki+1)%4)%2==0){\n\t\tif(u.numL<A)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t      }\n\t      if(((u.muki+1)%4)%2==1){\n\t\tif(u.numR<A)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+3)%4]>=u.numR+u.numL+1){\n\t    memo[a][b][(u.muki+3)%4]=u.numR+u.numL+1;\n\t    if(memo[a][b][(u.muki+3)%4]<ans){\n\t      if(((u.muki+3)%4)%2==0){\n\t\tif(u.numR<A)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t      }\n\t      if(((u.muki+3)%4)%2==1){\n\t\tif(u.numL<A)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P {\n  int x,y,p,q,z;\n};\n\nint d[101][101][15][15][4];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nbool check(int n, int m, int x, int y) {\n  return (x>=0&&x<n&&y>=0&&y<m);\n}\n\nint main() {\n  int n,m,k,INF=1<<29;\n  cin >> n >> m >> k;\n  string s[n];\n  int gx,gy,sx,sy;\n  for(int i=0; i<n; i++) {\n    cin >> s[i];\n    for(int j=0; j<m; j++) {\n      if(s[i][j]=='G') {\n\tgx=i;gy=j;\n      }\n      if(s[i][j]=='S') {\n\tsx=i;sy=j;\n      }\n    }\n  }\n  for(int i=0; i<101; i++)for(int j=0;j<101;j++)for(int ii=0; ii<15;ii++)for(int iii=0;iii<15;iii++)for(int jj=0;jj<4;jj++) d[i][j][ii][iii][jj]=INF;\n  d[sx][sy][k][k][2]=0;\n  \n  deque<P> que;\n  que.push_back((P){sx,sy,k,k,2});\n  while(!que.empty()) {\n    P t=que.front();que.pop_front();\n    int nx=t.x,ny=t.y;\n    if(s[nx][ny]=='G') continue;\n    int x=nx+dx[t.z],y=ny+dy[t.z];\n    if(check(n,m,x,y) && s[x][y]!='#') {\n      if(d[x][y][t.p][t.q][t.z]>d[nx][ny][t.p][t.q][t.z]) {\n\tque.push_front((P){x,y,t.p,t.q,t.z});\n\td[x][y][t.p][t.q][t.z]=d[nx][ny][t.p][t.q][t.z];\n      }\n    }\n    if(s[nx][ny]=='S') continue;\n    int a=1;\n    if(t.z%2) a=3;\n    if(t.p) {\n      x=nx+dx[(t.z+a)%4],y=ny+dy[(t.z+a)%4];\n      if(check(n,m,x,y) && s[x][y]!='#') {\n\tif(d[x][y][t.p-1][t.q][(t.z+a)%4]>d[nx][ny][t.p][t.q][t.z]+1) {\n\t  que.push_back((P){x,y,t.p-1,t.q,(t.z+a)%4});\n\t  d[x][y][t.p-1][t.q][(t.z+a)%4]=d[nx][ny][t.p][t.q][t.z]+1;\n\t}\n      }\n    }\n    a=(a+2)%4;\n    if(t.q) {\n      x=nx+dx[(t.z+a)%4],y=ny+dy[(t.z+a)%4];\n      if(check(n,m,x,y) && s[x][y]!='#') {\n\tif(d[x][y][t.p][t.q-1][(t.z+a)%4]>d[nx][ny][t.p][t.q][t.z]+1) {\n\t  que.push_back((P){x,y,t.p,t.q-1,(t.z+a)%4});\n\t  d[x][y][t.p][t.q-1][(t.z+a)%4]=d[nx][ny][t.p][t.q][t.z]+1;\n\t}\n      }\n    }\n  }\n  int ans=INF;\n  for(int i=0; i<=k; i++) {\n    for(int j=0; j<=k; j++) {\n      for(int l=0; l<4; l++) ans=min(ans,d[gx][gy][i][j][l]);\n    }\n  }\n  if(ans==INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n}State;\n \nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n \n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n \nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n \nint dist[310][310][4][11][11];\n \nint bfs(){\n    queue<State> que;\n    //map<State, int> dist;\n    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n     \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n         \tif(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n            for(int i=-1; i<2; i++){\n                if(nh == Sh && nw == Sw && i>=0) break;\n                    State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                 \n                if(dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] < 0){\n                    dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] = dist[u.h][u.w][u.dir][u.pq[0]][u.pq[1]];\n                    if(i >= 0)\n                        dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]];\n                     \n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n \nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n     \n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n     \n    cout << bfs() << endl;\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(~val) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    val = INF;\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n    }\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], -1);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100];\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj]=true;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#' && !memo[a][b]){\n\tmemo[a][b]=true;\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    a=u.y+Y[(u.muki+1)%4];\n    b=u.x+X[(u.muki+1)%4];\n    if(in(a,b)){\n      if(map[a][b]!='#' && !memo[a][b]){\n\tmemo[a][b]=true;\n\tif(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\tif(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n      }\n    }\n    a=u.y+Y[(u.muki+3)%4];\n    b=u.x+X[(u.muki+3)%4];\n    if(in(a,b)){\n      if(map[a][b]!='#' && !memo[a][b]){\n\tmemo[a][b]=true;\n\tif(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tint xx = x + dx[DOWN];\n\t\tint yy = y + dy[DOWN];\n\n\t\tif (xx < 0 || W <= xx) return -1;\n\t\tif (yy < 0 || H <= yy) return -1;\n\t\tif (S[yy][xx] == '#') return -1;\n\n\t\tdone[yy][xx][0][0][0] = true;\n\t\tque.push(make_pair(make_pair(yy * 1000 + xx, DOWN * 10000), 0));\n\n\t\t/*done[y][x][0][0][0] = true;\n\t\tque.push(make_pair(make_pair(y * 1000 + x, DOWN * 10000), 0));*/\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G')\n\t\t{\n\t\t\treturn c;\n\t\t}\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\n\t\t\tif (S[y][x] == 'S' && i == 1) continue;\n\t\t\tif (S[y][x] == 'S' && i == 3) continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tswitch (dir)\n\t\t\t\t{\n\t\t\t\tcase UP:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RIGHT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOWN:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LEFT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (A < aa) continue;\n\t\t\t\tif (A < bb) continue;\n\t\t\t}\n\t\t\t\n\n\t\t\t//if (done[yy][xx][dd][aa][bb]) continue;\n\t\t\tif (done[yy][xx][0][0][0]) continue;\n\n\t\t\tdone[y][x][0][0][0] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct State {\n  // d:??\\??£???????????????\n  int y, x, d, p, q, cost;\n  State(){}\n  State(int y, int x, int d, int p, int q, int cost):\n    y(y), x(x), d(d), p(p), q(q), cost(cost){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint N, M, A;\nchar mas[101][101];\nint sy, sx, gy, gx;\nint mincost[4][11][11][101][101];\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\n\nint dijkstra() {\n  rep(i, 4) rep(j, 11) rep(k, 11) {\n    rep(y, 101) rep(x, 101) mincost[i][j][k][y][x] = inf;\n  }\n  priority_queue<State> que;\n  rep(i, 4) {\n    int ny = sy+dy[i], nx = sx+dx[i];\n    if(in(ny, nx) && mas[ny][nx] == '.') {\n      que.push(State(ny, nx, (i+2)%4, A, A, 0));\n      mincost[(i+2)%4][A][A][sy][sx] = 0;\n    }\n  }\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(s.y == gy && s.x == gx) return s.cost;\n    if(mincost[s.d][s.p][s.q][s.y][s.x] < s.cost) continue;\n    rep(i, 4) {\n      if(s.d == i) continue;\n      int np = s.p, nq = s.q, ncost = s.cost;\n      if(s.d == 0) {\n\tif(i == 1) nq--, ncost++;\n\telse if(i == 3) np--, ncost++;\n      } else if(s.d == 1) {\n\tif(i == 0) nq--, ncost++;\n\telse if(i == 2) np--, ncost++;\n      } else if(s.d == 2) {\n\tif(i == 1) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      } else if(s.d == 3) {\n\tif(i == 0) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      }\n      if(np < 0 || nq < 0) continue;\n      int ny = s.y+dy[i], nx = s.x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#') continue;\n      if(ncost < mincost[(i+2)%4][np][nq][ny][nx]) {\n\tque.push(State(ny, nx, (i+2)%4, np, nq, ncost));\n\tmincost[(i+2)%4][np][nq][ny][nx] = ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> A;\n  rep(i, N) rep(j, M) {\n    cin >> mas[i][j];\n    if(mas[i][j] == 'S') sy = i, sx = j;\n    else if(mas[i][j] == 'G') gy = i, gx = j;\n  }\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nbool ok[111][111][11][11][4];\n\nstruct Dat\n{\n\tint x, y, p, q, dir;\n};\n\nbool update(Dat dat)\n{\n\tif (ok[dat.x][dat.y][dat.p][dat.q][dat.dir]) return false;\n\tok[dat.x][dat.y][dat.p][dat.q][dat.dir] = true;\n\treturn true;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tMS(ok, false);\n\tint h, w, a; cin >> h >> w >> a;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tqueue<Dat> que;\n\tint sx, sy, gx, gy;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == 'S')\n\t\t{\n\t\t\tsx = i, sy = j;\n\t\t\tfld[i][j] = '.';\n\t\t\tDat tmp{ i,j,0,0,3 };\n\t\t\tupdate(tmp);\n\t\t\tque.push(tmp);\n\t\t}\n\t\tif(fld[i][j] == 'G')\n\t\t{ \n\t\t\tfld[i][j] = '.';\n\t\t\tgx = i, gy = j;\n\t\t}\n\t}\n\tint ans = INF;\n\twhile (que.size())\n\t{\n\t\tDat t = que.front();\n\t\tque.pop();\n\t\tint x = t.x, y = t.y, p = t.p, q = t.q, dir = t.dir;\n\t\tif (x == gx&&y == gy)\n\t\t{\n\t\t\tchmin(ans, p + q);\n\t\t\tcontinue;\n\t\t}\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\tif (nx == sx && ny == sy)\n\t\t{\n\t\t\tif(dir == 0 || dir == 3) continue;\n\t\t\tint np, nq, ndir;\n\t\t\tnp = p, nq = q, ndir = dir;\n\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\tif (update(ndat)) que.push(ndat);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dir == 0)\n\t\t\t{\n\t\t\t\tint np, nq, ndir;\n\t\t\t\tnp = p, nq = q, ndir = 0;\n\t\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\t\tDat ndat2 = ndat;\n\t\t\t\tndat2.p++;\n\t\t\t\tndat2.dir = 1;\n\t\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\t\tDat ndat3 = ndat;\n\t\t\t\tndat3.q++;\n\t\t\t\tndat3.dir = 2;\n\t\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t\t}\n\t\t\telse if (dir == 1)\n\t\t\t{\n\t\t\t\tint np, nq, ndir;\n\t\t\t\tnp = p, nq = q, ndir = 1;\n\t\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\t\tDat ndat2 = ndat;\n\t\t\t\tndat2.p++;\n\t\t\t\tndat2.dir = 0;\n\t\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\t\tDat ndat3 = ndat;\n\t\t\t\tndat3.q++;\n\t\t\t\tndat3.dir = 3;\n\t\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t\t}\n\t\t\telse if (dir == 2)\n\t\t\t{\n\t\t\t\tint np, nq, ndir;\n\t\t\t\tnp = p, nq = q, ndir = 2;\n\t\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\t\tDat ndat2 = ndat;\n\t\t\t\tndat2.p++;\n\t\t\t\tndat2.dir = 3;\n\t\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\t\tDat ndat3 = ndat;\n\t\t\t\tndat3.q++;\n\t\t\t\tndat3.dir = 0;\n\t\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint np, nq, ndir;\n\t\t\t\tnp = p, nq = q, ndir = 3;\n\t\t\t\tDat ndat{ nx,ny,np,nq,ndir };\n\t\t\t\tif (update(ndat)) que.push(ndat);\n\t\t\t\tDat ndat2 = ndat;\n\t\t\t\tndat2.p++;\n\t\t\t\tndat2.dir = 2;\n\t\t\t\tif (ndat2.p <= a && update(ndat2)) que.push(ndat2);\n\t\t\t\tDat ndat3 = ndat;\n\t\t\t\tndat3.q++;\n\t\t\t\tndat3.dir = 1;\n\t\t\t\tif (ndat3.q <= a && update(ndat3)) que.push(ndat3);\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint m[4][4];\n\nint h, w, n;\nchar in[100][101];\nbool v[100][100][4][11][11];\n\nint main(){\n\tm[0][3] = m[1][2] = m[3][0] = m[2][1] = 1;\n\t\n\tcin >> h >> w >> n;\n\tint y, x;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t}\n\tpriority_queue<pair<int, pi> > Q;\n\tQ.push(mp(0, mp(2 * h * w + y * w + x, n * 11 + n)));\n\t\n\twhile(!Q.empty()){\n\t\tint co = -Q.top().first;\n\t\tint cd = Q.top().second.first / h / w;\n\t\ty = Q.top().second.first / w % h; x = Q.top().second.first % w;\n\t\tint p = Q.top().second.second / 11, q = Q.top().second.second % 11;\n\t\tQ.pop();\n\t\t\n\t\tif(v[y][x][cd][p][q]) continue;\n\t\tv[y][x][cd][p][q] = 1;\n\t\t\n\t\t//cerr<<y<<\" \"<<x<<\" \"<<cd<<\" \"<<p<<\" \"<<q<<\" \"<<co<<endl;\n\t\t\n\t\tif(in[y][x] == 'G'){\n\t\t\tcout << co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 4) if(d != (cd ^ 2)){\n\t\t\tif(in[y][x] == 'S' && cd != d) continue;\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\tint np = p - 1 + m[cd][d], nq = q - m[cd][d], nc = co;\n\t\t\t\n\t\t\tif(d == cd) np = p, nq = q;\n\t\t\telse nc++;\n\t\t\tif(np < 0 || nq < 0) continue;\n\t\t\t\n\t\t\tif(!v[ny][nx][d][np][nq]) Q.push(mp(-nc, mp(d * h * w + ny * w + nx, np * 11 + nq)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][11][11][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  /*\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      cout << G[i][j];\n    }cout <<endl;\n  }cout << endl;\n  */\n  if(val >= 0) return val;\n  if(G[x][y] == 'G'){\n    return val = 0;\n  }\n  val = INF;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    char c = G[x][y];\n    if(G[x][y] != 'S') G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p > 0){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q > 0){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  //printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\nstruct Point{ int x, y, p, q, d; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tqueue<Point> q;\n\n\tif(p.y + 1 > h) return INF;\n\n\tdis[p.y + 1][p.x][a][a][1] = 1;\n\tPoint tmp = Point{p.x, p.y + 1, a, a, 1};\n\tq.push(tmp);\n\n\twhile(not q.empty()){\n\t\tPoint u = q.front(); q.pop();\n\t\t//cout << u.x << ' ' << u.y << ' ' << u.p << ' ' << u.q << ' ' << u.d << endl;\n\t\trep(i,4){\n\t\t\tif((u.d + 2) % 4 == i) continue;\n\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tnext.d = i;\n\t\t\tnext.p = u.p;\n\t\t\tnext.q = u.q;\n\t\t\tif(u.d == 0 || u.d == 2){\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(next.p < 0 || next.q < 0) continue;\n\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[next.y][next.x][next.p][next.q][next.d] && m[next.y][next.x] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[next.y][next.x][next.p][next.q][next.d] = 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[g.y][g.x][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tPoint s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = Point{j,i};\n\t\tif(m[i][j] == 'G') g = Point{j,i};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={1,0,-1,0};\nconst int p[4]={3,2,1,0};\nconst int q[4]={1,0,3,2};\n\nstring board[110];\nint dist[100][100][4][11][11];\n\nint main(void){\n\tint n,m,a;\n\tcin >> n >> m >> a;\n\trep(i,n) cin >> board[i];\n\n\tint si=0,sj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='S') si=i,sj=j;\n\n\tint gi=0,gj=0;\n\trep(i,n)rep(j,m) if(board[i][j]=='G') gi=i,gj=j;\n\t\n\trep(i,n)rep(j,m)rep(d,4)rep(pi,a+1)rep(qi,a+1) dist[i][j][d][pi][qi]=100;\n\n\tusing state=tuple<int,int,int,int,int>;\n\t\n\tdeque<state> que;\n\tdist[si][sj][0][a][a]=0;\n\tque.push_back(state(si,sj,0,a,a));\n\n\twhile(!que.empty()){\n\t\tint ci,cj,d,pi,qi;\n\t\ttie(ci,cj,d,pi,qi)=que.front();\n\t\tque.pop_front();\n\n\t\t{\n\t\t\tconst int ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][d][pi][qi],dist[ci][cj][d][pi][qi])) \n\t\t\t\tque.push_front(state(ni,nj,d,pi,qi)); \t\n\t\t}\n\n\t\tif(board[ci][cj]=='.'){\n\t\t\tif(pi>0){\n\t\t\t\tconst int nd=p[d],npi=pi-1,nqi=qi,ni=ci+dy[nd],nj=cj+dx[nd];\n\t\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1)) \n\t\t\t\t\tque.push_back(state(ni,nj,nd,npi,nqi));\n\t\t\t}\n\t\t\tif(qi>0){\n\t\t\t\tconst int nd=q[d],npi=pi,nqi=qi-1,ni=ci+dy[nd],nj=cj+dx[nd];\n\t\t\t\t// cerr << ni << \" \" << nj << \" \" << nd << \" \" << npi << \" \" << nqi << endl;\n\t\t\t\t// cerr  << board[ci][cj] << \" \" << board[ni][nj] << endl;\n\t\t\t\t// cerr << dist[ni][nj][nd][npi][nqi] << endl;\n\t\t\t\tif(0<=ni&&ni<n&&0<=nj&&nj<m&&board[ni][nj]!='#' && chmin(dist[ni][nj][nd][npi][nqi],dist[ci][cj][d][pi][qi]+1))\n\t\t\t\t\tque.push_back(state(ni,nj,nd,npi,nqi));\n\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tint ans=100;\n\trep(d,4)rep(pi,a+1)rep(qi,a+1) chmin(ans,dist[gi][gj][d][pi][qi]);\n\tif(ans==100) ans=-1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct stat{\n\tint y,x,dir,n1,n2; // n1, n2 : 鏡 /, \\ の残り枚数\n};\n\nint main(){\n\tint h,w,n; scanf(\"%d%d%d\",&h,&w,&n);\n\tchar B[100][101];\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) if(B[i][j]=='S') sx=j, sy=i;\n\n\tstatic int dp[100][100][4][11][11];\n\tmemset(dp,-1,sizeof dp);\n\tdp[sy][sx][3][n][n]=0;\n\n\tint ans=-1;\n\tqueue<stat> Q;\n\tQ.push((stat){sy,sx,3,n,n});\n\twhile(!Q.empty()){\n\t\tint y=Q.front().y,x=Q.front().x,dir=Q.front().dir,n1=Q.front().n1,n2=Q.front().n2;\n\t\tQ.pop();\n\n\t\tif(B[y][x]=='G'){ ans=dp[y][x][dir][n1][n2]; break; }\n\n\t\tint y2=y+dy[dir],x2=x+dx[dir],dir2;\n\t\tif(y2<0 || h<=y2 || x2<0 || w<=x2 || B[y2][x2]=='#') continue;\n\n\t\t// 鏡を置かない\n\t\tdir2=dir;\n\t\tif(dp[y2][x2][dir2][n1][n2]==-1){\n\t\t\tdp[y2][x2][dir2][n1][n2]=dp[y][x][dir][n1][n2];\n\t\t\tQ.push((stat){y2,x2,dir2,n1,n2});\n\t\t}\n\n\t\t// 鏡 / を置く\n\t\tdir2=dir^1;\n\t\tif(n1>0 && dp[y2][x2][dir2][n1-1][n2]==-1){\n\t\t\tdp[y2][x2][dir2][n1-1][n2]=dp[y][x][dir][n1][n2]+1;\n\t\t\tQ.push((stat){y2,x2,dir2,n1-1,n2});\n\t\t}\n\n\t\t// 鏡 \\ を置く\n\t\tdir2=3-dir;\n\t\tif(n2>0 && dp[y2][x2][dir2][n1][n2-1]==-1){\n\t\t\tdp[y2][x2][dir2][n1][n2-1]=dp[y][x][dir][n1][n2]+1;\n\t\t\tQ.push((stat){y2,x2,dir2,n1,n2-1});\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  /*\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      cout << G[i][j];\n    }cout <<endl;\n  }cout << endl;\n  */\n  if(val >= 0) return val;\n  if(G[x][y] == 'G'){\n    return val = 0;\n  }\n  val = INF;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    if(G[x_][y_] == 'G') return val = 0;\n    char c = G[x][y];\n    if(G[x][y] != 'S') G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    if(G[x_][y_] == 'G') return val = 1;\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    if(G[x_][y_] == 'G') return val = 1;\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  //printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef tuple< int, int, int, int, int, int > Pi;\nconst int vy[] = {1, 0, -1, 0}, vx[] = {0, -1, 0, 1};\n\nint v[100][100][11][11][4];\n\nint main()\n{\n  int N, M, A;\n  string S[100];\n\n  cin >> N >> M >> A;\n  for(int i = 0; i < N; i++) cin >> S[i];\n\n\n  int sy, sx;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < M; j++) {\n      if(S[i][j] == 'S') sy = i, sx = j;\n    }\n  }\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, sy, sx, A, A, 0);\n  fill_n(****v, 100 * 100 * 11 * 11 * 4, INF);\n  v[sy][sx][A][A][0] = 0;\n\n  auto isover = [&](int y, int x) -> bool\n  {\n    return (y < 0 || y >= N || x < 0 || x >= M || S[y][x] == '#');\n  };\n\n  while(!que.empty()) {\n    int y, x, latte, malta, dir, cost;\n    tie(cost, y, x, latte, malta, dir) = que.top();\n    que.pop();\n    if(S[y][x] == 'G') {\n      cout << cost << endl;\n      return (0);\n    }\n    if(v[y][x][latte][malta][dir] > cost) continue;\n    for(int i = -1; i <= 1; i++) {\n      int beet = (dir + i + 4) % 4;\n      int ll = latte, rr = malta;\n      int ny = y + vy[beet], nx = x + vx[beet];\n      if(S[y][x] == 'S' && i != 0) continue;\n      if(isover(ny, nx)) continue;\n      if(i != 0) {\n        if((beet + (i == 1)) % 2 == 1) --ll;\n        else --rr;\n      }\n      if(ll >= 0 && rr >= 0 && cost + (i != 0) < v[ny][nx][ll][rr][beet]) {\n        v[ny][nx][ll][rr][beet] = cost + (i != 0);\n        que.emplace(cost + (i != 0), ny, nx, ll, rr, beet);\n      }\n    }\n  }\n  cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nchar dx[] = {1, 0, -1, 0};\nchar dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tchar x, y, d, p, q, t;\n\tstate(char x, char y, char d, char p, char q, char t) : x(x), y(y), d(d), p(p), q(q), t(t) {};\n};\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\n\tvs field(N+2);\n\tstring s;\n\tREP(i, M+2) {\n\t\ts += '#';\n\t}\n\tfield[0] = field[N+1] = s;\n\n\tREP(i, N) {\n\t\tcin >> s;\n\t\tfield[i+1] = '#' + s + '#';\n\t}\n\n\tchar sx, sy, gx, gy;\n\tREP(i, N+2) {\n\t\tREP(j, M+2) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t\tif(field[i][j] == 'G') {\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<state> Q;\n\tif(field[sy+1][sx] == '#') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t} else {\n\t\tQ.push(state(sx, sy+1, 1, 0, 0, 0));\n\t}\n\n\tvvi turn(N+2, vi(M+2, INT_MAX));\n\tturn[sy+1][sx] = 0;\n\n\tbool goal = false;\n\tint ans = INT_MAX;\n\twhile(!Q.empty()) {\n\t\tstate st = Q.front();\n\t\tQ.pop();\n\t\tchar cx = st.x;\n\t\tchar cy = st.y;\n\n\t\tif(cx == gx && cy == gy) {\n\t\t\tif(max(st.p, st.q) <= A) {\n\t\t\t\tgoal = true;\n\t\t\t\tans = min(ans, st.p+st.q);\n\t\t\t}\n\t\t} else {\n\t\t\tREP(d, 4) {\n\t\t\t\tchar nx = cx + dx[d];\n\t\t\t\tchar ny = cy + dy[d];\n\t\t\t\tif(turn[ny][nx] < st.t+1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((st.d+2)%4 == d) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cx == sx && cy == sy && st.d != d) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[ny][nx] != '#') {\n\t\t\t\t\tturn[ny][nx] = st.t+1;\n\t\t\t\t\tif(st.d != d) {\n\t\t\t\t\t\tif(st.d+d == 3) {\n\t\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p, st.q+1, st.t+1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p+1, st.q, st.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tQ.push(state(nx, ny, d, st.p, st.q, st.t+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(goal) {\n\t\tcout << ans << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(p+q>=ans) return;\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(s[y][x]=='S') return;\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Data{\n  int x,y,dir,P,Q,cost;\n  Data(int x=IINF,int y=IINF,int dir=IINF,int P=IINF,int Q=IINF,int cost=IINF):x(x),y(y),dir(dir),P(P),Q(Q),cost(cost){}\n  bool operator < (const Data& a)const{\n    return P+Q > a.P+a.Q;\n  }\n};\n\nint H,W,A,sp_x,sp_y;\nchar field[101][101];\nint mincost[101][101][11][11][4];\nint dx[] = {1,0,-1,0}; // 右、下、左、上\nint dy[] = {0,1,0,-1};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline int getType(int c_dir,int n_dir){\n  if( c_dir == 0 ){\n    if( n_dir == 3 ) return 0; // P -> 0, Q -> 1\n    if( n_dir == 1 ) return 1;\n  } else if( c_dir == 1 ){\n    if( n_dir == 2 ) return 0;\n    if( n_dir == 0 ) return 1;\n  } else if( c_dir == 2 ){\n    if( n_dir == 1 ) return 0;\n    if( n_dir == 3 ) return 1;\n  } else{\n    if( n_dir == 0 ) return 0;\n    if( n_dir == 2 ) return 1;\n  }\n  return -1;\n}\n\nint main(){\n  cin >> H >> W >> A;\n  rep(i,H)rep(j,W){\n    cin >> field[i][j];\n    if( field[i][j] == 'S' ) sp_x = j, sp_y = i;\n  }\n\n  rep(i,H)rep(j,W)rep(k,A+1)rep(l,A+1)rep(m,4)mincost[i][j][k][l][m] = IINF;\n  rep(i,4)mincost[sp_y][sp_x][A][A][i] = 0;\n  priority_queue<Data> Q;\n  if( isValid(sp_x+dx[1],sp_y+dy[1]) && field[sp_y+dy[1]][sp_x+dx[1]] != '#' ){\n    Q.push(Data(sp_x+dx[1],sp_y+dy[1],1,A,A,1));\n  }\n  while(!Q.empty()){\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( field[y][x] == 'G' ){\n      cout << 2*A-(data.P+data.Q) << endl;\n      return 0;\n    }\n    rep(i,4){\n      if( i == ( data.dir + 2 ) % 4 ) continue;\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!isValid(nx,ny))continue;\n      if(field[ny][nx] == '#')continue;\n      int next_P = data.P, next_Q = data.Q;\n      int type = getType(data.dir,i);\n      if( type == 0 ) next_P--;\n      if( type == 1 ) next_Q--;\n      if( next_P < 0 || next_Q < 0) continue;\n      if(mincost[ny][nx][next_P][next_Q][i] > data.cost+1){\n\tmincost[ny][nx][next_P][next_Q][i] = data.cost+1;\n\tQ.push(Data(nx,ny,i,next_P,next_Q,data.cost+1));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, a;\n  cin >> n >> m >> a;\n  vector<string> s(n);\n  Dijkstra<ll> dijk(4 * (a + 1) * n * m);\n  int st = -1, go = -1;\n  REP(i, 0, n) {\n    cin >> s[i];\n    REP(j, 0, m) {\n      if (s[i][j] == 'S') {\n\tst = i * m + j;\n      }\n      if (s[i][j] == 'G') {\n\tgo = i * m + j;\n      }\n    }\n  }\n  int dx[4] = {1, 0, -1, 0};\n  int dy[4] = {0, 1, 0, -1};\n  REP(i, 0, n) {\n    REP(j, 0, m) {\n      int src = i * m + j;\n      if (s[i][j] == '#') { continue; }\n      REP(d, 0, 4) {\n\tif (src == st && d != 0) { continue; }\n\tint nx = i + dx[d];\n\tint ny = j + dy[d];\n\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) { continue; }\n\tint dst = nx * m + ny;\n\tREP(lv, 0, a + 1) {\n\t  dijk.add_edge(d * (a + 1) * n * m + lv * n * m + src,\n\t\t\td * (a + 1) * n * m + lv * n * m + dst,\n\t\t\t0);\n\t}\n      }\n    }\n  }\n  REP(v, 0, n * m) {\n    if (v == st) { continue; }\n    REP(lv, 0, a + 1) {\n      // 0 <-> 1 and 2 <-> 3, duplicate-side\n      if (lv < a) {\n\tREP(x, 0, 4) {\n\t  dijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t\t(x ^ 1) * (a + 1) * n * m + (lv + 1) * n * m + v,\n\t\t\t0);\n\t}\n      }\n      // 0 <-> 3 and 1 <-> 2, cost-side\n      REP(x, 0, 4) {\n\tdijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t      (3 - x) * (a + 1) * n * m + lv * n * m + v,\n\t\t      1);\n      }\n    }\n  }\n  ll mi = a + 2;\n  VL sol = dijk.solve(0 * (a + 1) * n * m + st);\n  REP(d, 0, 4) {\n    REP(i, 0, a + 1) {\n      mi = min(mi, i + sol[d * (a + 1) * n * m + i * n * m + go]);\n    }\n  }\n  cout << (mi == a + 2 ? -1 : mi) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nDef d[110][110][11][4];\nclass DIJ{\n\tpublic:\n\tDef n,m,A;\n\tvs in;\n\tDIJ(Def size,Def w,vs fi,Def q){\n\t\tn=size;\n\t\tin=fi;\n\t\tm=w;\n\t\tA=q;\n\t}\n\tvoid dij(){\n\t\trep(i,110)rep(j,110)rep(l,11)rep(q,4)\n\t\t\td[i][j][l][q]=inf;\n\t\tint gx,gy;\n\t\tpriority_queue<tp>q;\n\t\trep(i,in.size())rep(j,in[0].size())\n\t\t\tif(in[i][j]=='G')gx=i,gy=j;\n\t\t\telse if(in[i][j]=='S'){\n\t\t\t\tif(i+1<n)d[i+1][j][0][1]=0;\n\t\t\t\tif(i+1<n)q.push(tp(0,i+1,j,0,1));\n\t\t\t}\n\t\t\t\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,a,to;\n\t\t\ttie(cost,x,y,a,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][a][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tint na=a,nb=cost;\n\t\t\t\tint nto=k;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tif((to+2)%4==nto)continue;\n\t\t\t\tif(nto!=to){\n\t\t\t\t\tif(to%2){\n\t\t\t\t\t\tif((to+1)%4==nto)na++;\n\t\t\t\t\t\telse nb++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((to+1)%4==nto)nb++;\n\t\t\t\t\t\telse na++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(na>A||nb>A)continue;\n\t\t\t\tif(nb<d[nx][ny][na][nto]){\n\t\t\t\t\td[nx][ny][na][nto]=nb;\n\t\t\t\t\tq.push(tp(-nb,nx,ny,na,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,11)rep(j,4)if(d[gx][gy][i][j]!=inf){\n\t\t\tcmin(out,i+d[gx][gy][i][j]);\n\t\t}\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(n,m,in,k);\n\tdij.dij();\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][11][11][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  /*\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j){\n      cout << G[i][j];\n    }cout <<endl;\n  }cout << endl;\n  */\n  if(val >= 0) return val;\n  if(G[x][y] == 'G'){\n    return val = 0;\n  }\n  val = INF;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    char c = G[x][y];\n    if(G[x][y] != 'S') G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p > 0){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q > 0){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  //printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  int sz = 0;\n  Graph G;\n  map<int,int> id;\n  int sid = idx(sx,sy,2,0,0);\n  queue<tuple<int,int,int,int,int>> q;\n  q.push(make_tuple(0,0,sx,sy,2));\n  id[sid] = sz++;\n  G.PB(vector<Edge>());\n  \n  while(!q.empty()){\n\tint a1, a2, x, y, d;\n\ttie(a1,a2,x,y,d) = q.front(); q.pop();\n\n\tint fr = idx(x,y,d,a1,a2);\n\n\tif(a1 < A){\n\t  int to = idx(x,y,3-d,a1+1,a2);\n\t  if(!id.count(to)){\n\t\tid[to] = sz++;\n\t\tG.PB(vector<Edge>());\n\t\tq.push(make_tuple(a1+1,a2,x,y,3-d));\n\t  }\n\t  G[id[fr]].PB(Edge(id[to], 1));\n\t}\n\tif(a2 < A){\n\t  int to = idx(x,y,d-(d%2*2-1),a1,a2+1);\n\t  if(!id.count(to)){\n\t\tid[to] = sz++;\n\t\tG.PB(vector<Edge>());\n\t\tq.push(make_tuple(a1,a2+1,x,y,d-(d%2*2-1)));\n\t  }\n\t  G[id[fr]].PB(Edge(id[to], 1));\n\t}\n\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint to = idx(tx,ty,d,a1,a2);\n\tif(!id.count(to)){\n\t  id[to] = sz++;\n\t  G.PB(vector<Edge>());\n\t  q.push(make_tuple(a1,a2,tx,ty,d));\n\t}\n\tG[id[fr]].PB(Edge(id[to], 0));\n  }\n\n  VI dist(sz);\n  Dijkstra(G, dist, id[idx(sx,sy,2,0,0)]);\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tif(id.count(tid))\n\t  ans = min(ans, dist[id[tid]]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n\nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k) {\n                for (int l = 0; l <= a; ++l) {\n                    dist[i][j][k][l] = 100;\n                }\n            }\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    dist[si][sj][1][0] = 0;\n    qi.push_back(si);\n    qj.push_back(sj);\n    qd.push_back(1);\n    qm.push_back(0);\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        if (pi == si && pj == sj && pd == 3) continue;\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        if (pi == si && pj == sj || pi == gi && pj == gj) continue;\n\n        {\n            int td = pd ^ 1;\n            int ti = pi + d[td], tj = pj + d[td + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && pm < a && dist[ti][tj][td][pm + 1] > dis) {\n                dist[ti][tj][td][pm + 1] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            int ti = pi + d[td], tj = pj + d[td + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dis < a && dist[ti][tj][td][pm] > dis + 1) {\n                dist[ti][tj][td][pm] = dis + 1;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(td);\n                qm.push_front(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j <= a; ++j) {\n            ans = min(ans, dist[gi][gj][i][j] + j);\n        }\n    }\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(ans<1e9||used[x][y][p][q][dir])return;\n  \n  while(1){\n    x=x+dx[dir];\n    y=y+dy[dir];\n    if(x<0||y<0||x>=w||y>=h)return;\n    if(mp[y][x]=='#')return;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    int ch=mp[y][x];\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2);\n      if(dir==1)dfs(x,y,p-1,q,3);\n      if(dir==2)dfs(x,y,p-1,q,0);\n      if(dir==3)dfs(x,y,p-1,q,1);\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3);\n      if(dir==1)dfs(x,y,p,q-1,2);\n      if(dir==2)dfs(x,y,p,q-1,1);\n      if(dir==3)dfs(x,y,p,q-1,0);\n    }\n    mp[y][x]=ch;\n  }\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MAXH = 101;\nconst int MAXW = 101;\nconst int MAXA = 11;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int P[] = {1,0,3,2};\nconst int Q[] = {3,2,1,0};\nint H, W, A;\nchar G[MAXH][MAXW];\nint vis[MAXH][MAXW][4][MAXA][MAXA];\n \nstruct State {\n  int i, j, d, a, b;\n};\n \nint dijkstra(int si, int sj, int gi, int gj) {\n  queue<State> que;\n  memset(vis, 0, sizeof(vis));\n  vis[si][sj][1][A][A] = true;\n  que.push((State){si, sj, 1,A, A});\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    do {\n      State t = s;\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#' || G[t.i][t.j] == 'S') break;\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(t.i == si && t.j == sj) break;\n      t.d = P[t.d];\n      if(--t.a < 0) break;\n\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#' || G[t.i][t.j] == 'S') break;\n\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(t.i == si && t.j == sj) break;\n      t.d = Q[t.d]; \n      if(--t.b < 0) break;\n\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#' || G[t.i][t.j] == 'S') break;\n\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n  }\n  int res = INF;\n  for(int a = 0; a <= A; ++a) {\n    for(int b = 0; b <= A; ++b) {\n      for(int k = 0; k < 4; ++k) {\n        if(vis[gi][gj][k][a][b]) {\n          res = min(res, A*2 - (a+b));\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n \nint main() {\n  cin >> H >> W >> A;\n  int si, sj, gi, gj;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n      if(G[i][j] == 'S') {\n        si = i; sj = j;\n      }\n      if(G[i][j] == 'G') {\n        gi = i; gj = j;\n      }\n    }\n  }\n  cout << dijkstra(si, sj, gi, gj) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nstruct None{};\nstruct Elm {\n  int r, c, p, q, dir;\n};\nint n, m, a;\nvi dr = {1, 0, -1, 0};\nvi dc = {0, -1, 0, 1};\nvector<vector<vector<vector<vector<bool>>>>> dp;\nvoid dfs(int r, int c, int p, int q, int dir, vector<vector<char>> &g, vector<vector<bool>> &sel) {\n  if(dp[r][c][p][q][dir]) return;\n  dp[r][c][p][q][dir] = true;\n  int nr = r + dr[dir], nc = c + dc[dir];\n  if(0 <= nr && nr < n && 0 <= nc && nc < m && g[nr][nc] != '#') {\n    bool psel = sel[r][c];\n    sel[r][c] = true;\n    dfs(nr, nc, p, q, dir, g, sel);\n    sel[r][c] = psel;\n  }\n  if(g[r][c] != 'S' && ((dir%2 && q < a) || (!(dir%2) && p < a))) {\n    int ndir = (dir + 3) % 4;\n    int nr = r + dr[ndir], nc = c + dc[ndir];\n    int np = p + !(dir%2);\n    int nq = q + dir%2;\n    if(0 <= nr && nr < n && 0 <= nc && nc < m && g[nr][nc] != '#' && !sel[r][c]) {\n      bool psel = sel[r][c];\n      sel[r][c] = true;\n      char prev = g[r][c];\n      g[r][c] = '#';\n      dfs(nr, nc, np, nq, ndir, g, sel);\n      g[r][c] = prev;\n      sel[r][c] = psel;\n    }\n  }\n  if(g[r][c] != 'S' && ((dir%2 && p < a) || (!(dir%2) && q < a))) {\n    int ndir = (dir + 1) % 4;\n    int nr = r + dr[ndir], nc = c + dc[ndir];\n    int np = p + dir%2;\n    int nq = q + !(dir%2);\n    if(0 <= nr && nr < n && 0 <= nc && nc < m && g[nr][nc] != '#' && !sel[r][c]) {\n      bool psel = sel[r][c];\n      sel[r][c] = true;\n      char prev = g[r][c];\n      g[r][c] = '#';\n      dfs(nr, nc, np, nq, ndir, g, sel);\n      g[r][c] = prev;\n      sel[r][c] = psel;\n    }\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  cin >> n >> m >> a;\n  vector<vector<char>> g(n, vector<char>(m));\n  P st = {-1, -1}, gl = {-1, -1};\n  for(int i=0;i<(n);++i) {\n    for(int j=0;j<(m);++j) {\n      cin >> g[i][j];\n      if(g[i][j] == 'S') {\n        st = {i, j};\n      }\n      if(g[i][j] == 'G') {\n        gl = {i, j};\n      }\n    }\n  }\n  dp.resize(n,\n    vector<vector<vector<vector<bool>>>>(m,\n      vector<vector<vector<bool>>>(a+1,\n        vector<vector<bool>>(a+1,\n          vector<bool>(4, false)))));\n  vector<vector<bool>> sel(n, vector<bool>(m));\n  dfs(st.first, st.second, 0, 0, 0, g, sel);\n  int mi = INF;\n  for(int i=0;i<(a+1);++i) {\n    for(int j=0;j<(a+1);++j) {\n      for(int k=0;k<(4);++k) {\n        if(dp[gl.first][gl.second][i][j][k]) chmin(mi, i+j);\n      }\n    }\n  }\n  cout << (mi == INF ? -1 : mi) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    q.push(make_tuple(S.first,S.second,1,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(masu[i][j] == 'S' && (usedP|usedQ)) continue;\n        if((usedP|usedQ) && j==S.second && (dir == 1 || dir == 3)) continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2342.cc: Light Road\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 100;\nconst int MAX_A = 10;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Stat {\n  int d, x, y, di, p, q;\n  Stat() {}\n  Stat(int _d, int _x, int _y, int _di, int _p, int _q):\n    d(_d), x(_x), y(_y), di(_di), p(_p), q(_q) {}\n  bool operator<(const Stat &s) const { return d < s.d; }\n  bool operator>(const Stat &s) const { return d > s.d; }\n};\n\ntypedef vector<Stat> vs;\n\n/* global variables */\n\nstring flds[MAX_N];\nbool pm[4][4], qm[4][4];\nint dists[MAX_N][MAX_M][4][MAX_A + 1][MAX_A + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  pm[0][3] = pm[1][2] = pm[2][1] = pm[3][0] = true;\n  qm[0][1] = qm[1][0] = qm[2][3] = qm[3][2] = true;\n\n  int n, m, a;\n  cin >> n >> m >> a;\n\n  int sx, sy, gx, gy;\n  \n  for (int y = 0; y < n; y++) {\n    cin >> flds[y];\n    for (int x = 0; x < m; x++)\n      switch (flds[y][x]) {\n      case 'S': sx = x; sy = y; break;\n      case 'G': gx = x; gy = y; break;\n      }\n  }\n\n  memset(dists, -1, sizeof(dists));\n  dists[sy][sx][3][a][a] = 0;\n\n  priority_queue<Stat,vs,greater<Stat> > q;\n  q.push(Stat(0, sx, sy, 3, a, a));\n\n  int mind = INF;\n  \n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (u.d != dists[u.y][u.x][u.di][u.p][u.q]) continue;\n\n    if (u.x == gx && u.y == gy) {\n      mind = u.d;\n      break;\n    }\n\n    int rudi = (u.di + 2) % 4;\n    \n    for (int vdi = 0; vdi < 4; vdi++) {\n      if (vdi == rudi) continue;\n\n      int vx = u.x + dxs[vdi], vy = u.y + dys[vdi];\n      if (u.x == sx && u.y == sy &&\n\t  (u.di != vdi || (u.d > 0 && vdi == 3))) continue;\n      if (vx < 0 || vx >= m || vy < 0 || vy >= n || flds[vy][vx] == '#')\n\tcontinue;\n\n      int vd = u.d, vp = u.p, vq = u.q;\n      if (pm[u.di][vdi]) vd++, vp--;\n      else if (qm[u.di][vdi]) vd++, vq--;\n\n      if (vp >= 0 && vq >= 0 && dists[vy][vx][vdi][vp][vq] < 0) {\n\tdists[vy][vx][vdi][vp][vq] = vd;\n\tq.push(Stat(vd, vx, vy, vdi, vp, vq));\n      }\n    }\n  }\n\n  printf(\"%d\\n\", mind < INF ? mind : -1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool d[100*100*11*11*4];\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int dir){\n    if(i<0 || i>=n || j<0 || j>=m) return -1;\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+dir;\n  };\n\n  int sx,sy,tx,ty;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      sx = i+1; sy = j;\n    }\n    if(vec[i][j]=='G') tx=i, ty=j;\n  }\n\n  auto ok = [&](int i, int j, bool dir=-1){\n    if(i<0 || i>=n || j<0 || j>=m) return false;\n    if(dir%2==0 && vec[i][j]=='S') return false;\n    return (vec[i][j]=='.' || vec[i][j]=='G' || vec[i][j]=='S' );\n  };\n\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,1,0,-1};\n  const int mirrx[] = {3,2,1,0};\n  const int mirry[] = {1,0,3,2};\n\n  int res = INF;\n\n  fill(d, d+(sizeof(d)), false);\n  queue<int> qx, qy, qi, qj, qd;\n  d[f(sx,sy,0,0,0)] = true;\n  qx.push(sx); qy.push(sy); qi.push(0); qj.push(0); qd.push(0);\n\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    int i = qi.front(); qi.pop();\n    int j = qj.front(); qj.pop();\n    int dir = qd.front(); qd.pop();\n//dbg(x,y,i,j,dir);\n    if(x==tx && y==ty){\n      res = min(res, i+j);\n      continue;\n    }\n\n    int nx,ny;\n\n    // ????????????\n    nx = x + dx[dir];\n    ny = y + dy[dir];\n    if(ok(nx, ny, dir)){\n      int z = f(nx, ny, i, j, dir);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i); qj.push(j); qd.push(dir);\n      }\n    }\n\n    if(vec[x][y]=='S') continue;\n\n    // mirror\n    nx = x + dx[mirrx[dir]];\n    ny = y + dy[mirrx[dir]];\n    if(i<a && ok(nx, ny, mirrx[dir])){\n      int z = f(nx, ny, i+1, j, mirrx[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i+1); qj.push(j); qd.push(mirrx[dir]);\n      }\n    }\n\n    nx = x + dx[mirry[dir]];\n    ny = y + dy[mirry[dir]];\n    if(j<a && ok(nx, ny, mirry[dir])){\n      int z = f(nx, ny, i, j+1, mirry[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.push(nx); qy.push(ny); qi.push(i); qj.push(j+1); qd.push(mirry[dir]);\n      }\n    }\n  }\n\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nclass State\n{\npublic:\n\tint x,y,d,p,q,c;\n\tState(int x, int y, int d, int p, int q, int c)\n\t\t:x(x),y(y),d(d),p(p),q(q),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint N,M,A;\nbool memo[100][100][4][15][15];\nstring field[100];\n\nbool invaild(int x, int y)\n{\n\tif(x<0||y<0||x>=M||y>=N) return true;\n\tif(field[y][x] == '#') return true;\n\t\n\treturn false;\n}\n\nbool newState(State& s)\n{\n\treturn !memo[s.x][s.y][s.d][s.p][s.q];\n}\n\nState straight(State s)\n{\n\t\n\tint tx = s.x + dx[s.d];\n\tint ty = s.y + dy[s.d];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,s.d,s.p,s.q,s.c);\n}\n\nState useP(State s)\n{\n\tif(s.p == 0) return s;\n\n\tint nd = (s.d+1)%2 + (s.d > 1? 2: 0);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p-1,s.q,s.c+1);\n}\n\nint refQ(int d)\n{\n\tif(d==0) return 3;\n\tif(d==3) return 0;\n\tif(d==1) return 2;\n\n\treturn 1;\n}\n\nState useQ(State s)\n{\n\tif(s.q == 0) return s;\n\n\tint nd = refQ(s.d);\n\tint tx = s.x + dx[nd];\n\tint ty = s.y + dy[nd];\n\n\tif(invaild(tx,ty)) return s;\n\n\treturn State(tx,ty,nd,s.p,s.q-1,s.c+1);\n}\n\n\n\nint solve()\n{\n\tmemset(memo, 0, sizeof(memo));\n\n\tint sx,sy;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<M; j++) {\n\t\tif(field[i][j]=='S') {\n\t\t\tsx = j;\n\t\t\tsy = i;\n\t\t}\n\t}\n\n\tfor(int i=0; i<=A; i++)\n\tfor(int j=0; j<=A; j++)\n\t\tmemo[sx][sy][2][i][j] = true;\n\n\tpriority_queue<State> q;\n\tq.push(State(sx,sy,0,A,A,0));\n\n\twhile(!q.empty()) {\n\t\tState s=q.top(); q.pop();\n\t\tif(!newState(s)) continue;\n\t\tmemo[s.x][s.y][s.d][s.p][s.q] = true;\n\n\t\tif(field[s.y][s.x] == 'G') return s.c;\n\n\t\tState ns = straight(s);\n\t\tif(newState(ns)) q.push(ns);\n\n\t\tif(s.x != sx || s.y != sy) {\n\t\t\tns = useP(s);\n\t\t\tif(newState(ns)) q.push(ns);\n\n\t\t\tns = useQ(s);\n\t\t\tif(newState(ns)) q.push(ns);\n\t\t}\n\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin >> N >> M >> A;\n\tfor(int i=0; i<N; i++)\n\t\tcin >> field[i];\n\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint N,M,A;\nstring s[111];\nbool used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]=1;\n      dfs(ny,nx,d,p,q);\n      used[y][x]=0;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]=1;\n      dfs(ny,nx,d,p,q);\n      used[y][x]=0;\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<deque>\n\nusing namespace std;\n\nstruct S{\n  int y,x,d,p,q;\n  int code(){\n    return q+p*11+d*11*11+x*11*11*4+y*11*11*4*100;\n  }\n};\n\nint main(){\n  int N,M,A;\n  cin>>N>>M>>A;\n  char g[100][100];\n  S is={0,0,2,0,0};\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      cin>>g[i][j];\n      if(g[i][j]=='S'){\n\tis.y=i;\n\tis.x=j;\n      }\n    }\n  }\n  static bool p[100*100*4*11*11];\n  deque<S> deq(1,is);\n  while(!deq.empty()){\n    S c=deq.front();\n    if(g[c.y][c.x]=='G')break;\n    deq.pop_front();\n    if(p[c.code()]++)continue;\n    for(int i=0;i<3;i++){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      S n=c;\n      if(i==1){\n\tn.d^=1;\n\tn.p++;\n      }else if(i==2){\n\tn.d=3-n.d;\n\tn.q++;\n      }\n      n.y+=dy[n.d];\n      n.x+=dx[n.d];\n      if(0<=n.y&&n.y<N&&0<=n.x&&n.x<M&&n.p<=A&&n.q<=A&&g[c.y][c.x]!='#'){\n\tif(i==0){\n\t  deq.push_front(n);\n\t}else{\n\t  deq.push_back(n);\n\t}\n      }\n    }\n  }\n  cout<<(deq.empty()?-1:deq.front().p+deq.front().q)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tint xx = x + dx[DOWN];\n\t\tint yy = y + dy[DOWN];\n\n\t\tif (xx < 0 || W <= xx) return -1;\n\t\tif (yy < 0 || H <= yy) return -1;\n\t\tif (S[yy][xx] == '#') return -1;\n\n\t\tdone[y][x][0][0][0] = true;\n\t\tdone[yy][xx][0][0][0] = true;\n\t\tque.push(make_pair(make_pair(yy * 1000 + xx, DOWN * 10000), 0));\n\n\t\t/*done[y][x][0][0][0] = true;\n\t\tque.push(make_pair(make_pair(y * 1000 + x, DOWN * 10000), 0));*/\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G')\n\t\t{\n\t\t\treturn c;\n\t\t}\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\n\t\t\tif (S[y][x] == 'S' && i == 1) continue;\n\t\t\tif (S[y][x] == 'S' && i == 3) continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tswitch (dir)\n\t\t\t\t{\n\t\t\t\tcase UP:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RIGHT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOWN:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LEFT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (A < aa) continue;\n\t\t\t\tif (A < bb) continue;\n\t\t\t}\n\t\t\t\n\n\t\t\t//if (done[yy][xx][dd][aa][bb]) continue;\n\t\t\tif (done[yy][xx][dir][0][0]) continue;\n\n\t\t\tdone[y][x][dir][0][0] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(ans<1e9||used[x][y][p][q][dir]++)return;\n  \n  while(1){\n    x=x+dx[dir];\n    y=y+dy[dir];\n    if(x<0||y<0||x>=w||y>=h)return;\n    if(mp[y][x]=='#'||mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2);\n      if(dir==1)dfs(x,y,p-1,q,3);\n      if(dir==2)dfs(x,y,p-1,q,0);\n      if(dir==3)dfs(x,y,p-1,q,1);\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3);\n      if(dir==1)dfs(x,y,p,q-1,2);\n      if(dir==2)dfs(x,y,p,q-1,1);\n      if(dir==3)dfs(x,y,p,q-1,0);\n    }\n  }\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=105,INF=1<<30;\nint H,W,K,sh,sw,gh,gw;\nchar S[MAX][MAX];\nshort can[MAX][MAX][MAX][11][4];\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nstruct dat{\n    int h;\n    int w;\n    int x;\n    int b;\n    int dir;\n};\n\nvoid BFS(){\n    deque<dat> deq;\n    can[sh][sw][H+1][0][1]=0;\n    deq.push_front({sh,sw,H+1,0,1});\n    \n    while(!deq.empty()){\n        auto u=deq.front();deq.pop_front();\n        int h=u.h,w=u.w,x=u.x,b=u.b,dir=u.dir;\n        if(h<0||h>=H||w<0||w>=W) continue;\n        short a=can[h][w][x][b][dir];\n        if(a>K||b>K) continue;\n        if(S[h][w]=='#') continue;\n        if((a||b)&&x==H+1) continue;\n        if(w==sw&&x!=H+1&&sh<=h&&h<=x&&dir==3) continue;\n        \n        if(h+dh[dir]>=0&&w+dw[dir]>=0&&chmin(can[h+dh[dir]][w+dw[dir]][x][b][dir],a)) deq.push_front({h+dh[dir],w+dw[dir],x,b,dir});\n        \n        if(h==sh&&w==sw) continue;\n        if(h==gh&&w==gw) continue;\n        \n        for(int k=0;k<4;k++){\n            if((k&1)==(dir&1)) continue;\n            \n            if(dir/2==k/2){\n                if(x==H+1&&w==sw){\n                    if(chmin(can[h][w][h][b][k],short(a+1))){\n                        deq.push_back({h,w,h,b,k});\n                    }\n                }else{\n                    if(chmin(can[h][w][x][b][k],short(a+1))){\n                        deq.push_back({h,w,x,b,k});\n                    }\n                }\n            }\n            else{\n                if(x==H+1&&w==sw){\n                    if(chmin(can[h][w][h][b+1][k],short(a))){\n                        deq.push_front({h,w,h,b+1,k});\n                    }\n                }else{\n                    if(chmin(can[h][w][x][b+1][k],short(a))){\n                        deq.push_front({h,w,x,b+1,k});\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>H>>W>>K;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n            if(S[i][j]=='S'){\n                sh=i;\n                sw=j;\n            }\n            if(S[i][j]=='G'){\n                gh=i;\n                gw=j;\n            }\n        }\n    }\n    \n    for(int i=0;i<=H;i++){\n        for(int j=0;j<=W;j++){\n            for(int k=0;k<=H+1;k++){\n                for(int b=0;b<11;b++){\n                    for(int l=0;l<4;l++){\n                        can[i][j][k][b][l]=100;\n                    }\n                }\n            }\n        }\n    }\n    \n    BFS();\n    \n    int ans=INF;\n    \n    for(int k=0;k<=H+1;k++){\n        for(int b=0;b<=K;b++){\n            for(int l=0;l<4;l++){\n                if(can[gh][gw][k][b][l]<=K){\n                    chmin(ans,b+can[gh][gw][k][b][l]);\n                }\n            }\n        }\n    }\n    \n    if(ans>2*K) ans=-1;\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<short,short,short,short,short,short> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tpriority_queue<T, vector<T>, greater<T>> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)] == '#') return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(0, get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint c, y, x, p, q, d;\n\t\ttie(c,y,x,p,q,d) = que.top(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\tif(y == get<0>(g) and x == get<1>(g)) break;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\tint nc = c;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(nc,ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nchar ba[100][100];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct P {\n  int y, x;\n  int d;\n  int a, b;\n  P(int y, int x, int d, int a, int b) : y(y),x(x),a(a),b(b),d(d) {}\n};\n\nbool ok[100][100][4][10][10];\n\nint main() {\n  int h, w, A;\n  while(cin>>h>>w>>A) {\n    int sx, sy;\n    int gx, gy;\n    REP(i,h) REP(j, w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == 'S') {\n        sy = i;\n        sx = j;\n      } else if (ba[i][j] == 'G') {\n        gy = i;\n        gx = j;\n      }\n    }\n    queue<P> Q;\n    memset(ok, 0, sizeof(ok));\n    Q.push(P(sy,sx,1,A, A));\n    bool hoge = 0;\n    while(!Q.empty()) {\n      P p = Q.front(); Q.pop();\n      if (ok[p.y][p.x][p.d][p.a][p.b]) continue;\n      ok[p.y][p.x][p.d][p.a][p.b] = 1;\n\n      //cout << p.x << \" \" << p.y << \" \" << p.d << \" \" << p.a << \" \" <<p.b << endl;\n      int yy = p.y + dy[p.d];\n      int xx = p.x + dx[p.d];\n      if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n        Q.push(P(yy,xx,p.d,p.a,p.b));\n\n      if (ba[p.y][p.x] == 'S') continue;\n      \n      if (p.a) {\n        int yy, xx;\n        int dd;\n        if (p.d % 2) {\n          dd = (p.d+3)%4;\n        } else {\n          dd = (p.d+1)%4;\n        }\n        yy = p.y + dy[dd];\n        xx = p.x + dx[dd];\n        if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n          Q.push(P(yy,xx,dd,p.a-1,p.b));\n      }\n      if (p.b) {\n        int yy, xx;\n        int dd;\n        if (p.d % 2) {\n          dd = (p.d+1)%4;\n        } else {\n          dd = (p.d+3)%4;\n        }\n        yy = p.y + dy[dd];\n        xx = p.x + dx[dd];\n        if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n          Q.push(P(yy,xx,dd,p.a,p.b-1));\n      }\n    }\n    int ans = -1;\n    REP(i, 4) {\n      REP(j, A+1) {\n        REP(k, A+1) {\n          if (ok[gy][gx][i][j][k]) {\n            if (ans == -1) ans = A*2-(j+k);\n            else ans = min(ans, A*2-(j+k));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint H, W, A, sx, sy, gx, gy, dx[] = { 0, 1, 0, -1 }, dy[] = { 1, 0, -1, 0 }; bool vis[109][109][4][15][15]; string s[109];\nvoid dfs(int x, int y, int dir, int mp, int mq) {\n\tvis[x][y][dir][mp][mq] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif ((i ^ 2) == dir) continue;\n\t\tif (s[x][y] == 'S' && i != dir) continue;\n\t\tint tx = x + dx[i], ty = y + dy[i], nmp = mp + ((i ^ 1) == dir), nmq = mq + ((i ^ 3) == dir);\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && (s[tx][ty] != 'S' || i != 3) && nmp <= A && nmq <= A && !vis[tx][ty][i][nmp][nmq]) {\n\t\t\tdfs(tx, ty, i, nmp, nmq);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> H >> W >> A;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == 'S') sx = i, sy = j;\n\t\t\tif (s[i][j] == 'G') gx = i, gy = j;\n\t\t}\n\t}\n\tdfs(sx, sy, 1, 0, 0);\n\tint ret = 1 << 30;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j <= A; j++) {\n\t\t\tfor (int k = 0; k <= A; k++) {\n\t\t\t\tif (vis[gx][gy][i][j][k] && ret > j + k) ret = j + k;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ret == 1 << 30 ? -1 : ret) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(~val) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    val = INF;\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        char orig = board[x][y];\n        if(k != 0) board[x][y] = '#';\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n        board[x][y] = orig;\n    }\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], -1);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(ans<1e9||used[x][y][p][q][dir]++)return;\n  \n  while(1){\n    x=x+dx[dir];\n    y=y+dy[dir];\n    if(x<0||y<0||x>=w||y>=h)return;\n    if(mp[y][x]=='#'||mp[y][x]=='S')return;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2);\n      if(dir==1)dfs(x,y,p-1,q,3);\n      if(dir==2)dfs(x,y,p-1,q,0);\n      if(dir==3)dfs(x,y,p-1,q,1);\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3);\n      if(dir==1)dfs(x,y,p,q-1,2);\n      if(dir==2)dfs(x,y,p,q-1,1);\n      if(dir==3)dfs(x,y,p,q-1,0);\n    }\n  }\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0};\n\nstruct node{\n  int x, y, p, q, dir, dis;\n  bool operator<(const node &n) const{ return dis > n.dis; }\n};\n\nstring s[105];\nint d[105][105][11][11][4];\n\nsigned main(void)\n{\n  int h, w, a;\n  cin >> h >> w >> a;\n  REP(i, h) cin >> s[i];\n  int sx, sy, gx, gy;\n  REP(i, h) REP(j, w) {\n    if(s[i][j] == 'S') sx = j, sy = i;\n    else if(s[i][j] == 'G') gx = j, gy = i;\n  }\n\n  memset(d, -1, sizeof(d));\n  priority_queue<node> que;\n  que.push((node){sx, sy, 0, 0, 0, 0});\n  while(que.size()) {\n    node v = que.top(); que.pop();\n    //cout << v.x << \" \" << v.y << \" \" << v.p << \" \" << v.q << \" \" << v.dir << \" \" << v.dis << endl;\n    if(v.x == gx && v.y == gy) {\n      cout << v.dis << endl;\n      return 0;\n    }\n    if(d[v.x][v.y][v.p][v.q][v.dir] >= 0) continue;\n    d[v.x][v.y][v.p][v.q][v.dir] = v.dis;\n    REP(i, 3) {\n      int d = (v.dir+i+3)%4;\n      if(v.x == sx && v.y == sy && v.dis && dx[d]) continue;\n      if(v.x == sx && v.y == sy && v.dir != d) continue;\n      bool isp = (v.dir+d) == 3, isq = (v.dir+d)%4 == 1;\n      if(isp && v.p >= a) continue;\n      if(isq && v.q >= a) continue;\n      int x = v.x + dx[d], y = v.y + dy[d];\n      //cout << i << \" \" << x << \" \" << y << \" \" << s[y][x] << \" \" << w << \" \" << h << endl;\n      if(IN(0, w, x) && IN(0, h, y) && s[y][x] != '#') {\n        que.push((node){x, y, v.p+isp, v.q+isq, d, v.dis+isp+isq});\n        //cout << \"a\" << endl;\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = '.';\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = '.';\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n    \n    bool operator < (const _State r)const{\n        return r.h == h? r.w == w? r.dir==dir? r.pq < pq: r.dir<dir: r.w < w:r.h < h;\n    }\n}State;\n\nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n\n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n\n//int dist[310][310][4][11][11];\n\nint bfs(){\n    queue<State> que;\n    map<State, int> dist;\n//    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s] = 0;\n//    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n    \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n            if(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n            for(int i=-1; i<2; i++){\n                State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                \n                if(dist.find(v) == dist.end()){\n                    dist[v] = dist[u];\n                    if(i >= 0)\n                        dist[v]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v];\n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n    \n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n    \n    cout << bfs() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n    \n    bool operator < (const _State r)const{\n        return r.h == h? r.w == w? r.dir==dir? r.pq < pq: r.dir<dir: r.w < w:r.h < h;\n    }\n}State;\n\nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n\n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n\nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n\n//int dist[310][310][4][11][11];\n\nint bfs(){\n    queue<State> que;\n    map<State, int> dist;\n//    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s] = 0;\n//    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n    \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n            for(int i=-1; i<2; i++){\n                State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                \n                if(dist.find(v) == dist.end()){\n                    dist[v] = dist[u];\n                    if(i >= 0)\n                        dist[v]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v];\n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n    \n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n    \n    cout << bfs() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nstruct Sta{\n\tint x, y, p, q, dir;\n};\n\nconst int MAXN = 105;\nconst int MAXA = 12;\nconst int Way[4][2] = {\n\t{-1,  0},\n\t{ 0,  1},\n\t{ 1,  0},\n\t{ 0, -1}\n};\n\nqueue<Sta> Que;\nint N, M, A, sx, sy, ex, ey, ans;\nchar Gr[MAXN][MAXN];\nbool mark[MAXN][MAXN][MAXA][MAXA][4];\nPII mirror[MAXN][MAXN];\n\nbool check(int x, int y){\n\treturn (x >= 0 && x < N && y >= 0 && y < M);\n}\n\nint dfs(int x, int y, int p, int q, int dir){\n\tif(mark[x][y][p][q][dir]) return 0;\n\tif(x == ex && y == ey){\n\t\tif(ans == -1) ans = p + q;\n\t\telse ans = min(ans, p + q);\n\t\treturn 0;\n\t}\n\tmark[x][y][p][q][dir] = true;\n\tfor(int i = 0; i < 4; ++i){\n\t\tif(i == dir) continue;\n\t\tint newx = x + Way[i][0];\n\t\tint newy = y + Way[i][1];\n\t\tif(!check(newx, newy) || Gr[newx][newy] == '#') continue;\n\t\tif(i == (dir + 2) % 4){\n\t\t\tdfs(newx, newy, p, q, (i + 2) % 4);\n\t\t}else{\n\t\t\tbool flag = false;\n\t\t\tif(Gr[x][y] == 'S') continue;\n\t\t\tif(mirror[x][y].first != -1){\n\t\t\t\tif(!(mirror[x][y] == PII(dir, i) || mirror[x][y] == PII(i, dir))) continue;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif((i + dir) != 3){\n\t\t\t\tif(p == A) continue;\n\t\t\t\tmirror[x][y] = PII(dir, i);\n\t\t\t\tint cnt;\n\t\t\t\tif(flag) cnt = 0;\n\t\t\t\telse cnt = 1;\n\t\t\t\tdfs(newx, newy, p + cnt, q, (i + 2) % 4);\n\t\t\t\tif(!flag) mirror[x][y] = PII(-1, -1);\n\t\t\t}else{\n\t\t\t\tif(q == A) continue;\n\t\t\t\tmirror[x][y] = PII(dir, i);\n\t\t\t\tint cnt;\n\t\t\t\tif(flag) cnt = 0;\n\t\t\t\telse cnt = 1;\n\t\t\t\tdfs(newx, newy, p, q + cnt, (i + 2) % 4);\n\t\t\t\tif(!flag) mirror[x][y] = PII(-1, -1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &M, &A);\n\tfor(int i = 0; i < N; ++i)\n\t\tscanf(\"%s\", Gr[i]);\n\tmemset(mark, false, sizeof(mark));\n\tfor(int i = 0; i < N; ++i)\n\t\tfor(int j = 0; j < M; ++j)\n\t\t\tif(Gr[i][j] == 'S'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}else if(Gr[i][j] == 'G'){\n\t\t\t\tex = i;\n\t\t\t\tey = j;\n\t\t\t}\n\tint initx = sx + Way[2][0];\n\tint inity = sy + Way[2][1];\n\tif(!check(initx, inity)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif(Gr[initx][inity] == 'G'){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(Gr[initx][inity] == '#'){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tans = -1;\n\tmemset(mirror, 255, sizeof(mirror));\n\tdfs(initx, inity, 0, 0, 0);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nint dx[] = { 0, 1, 0, -1 }; // NESW\nint dy[] = { -1, 0, 1, 0 };\n\nint P[] = { 3, 2, 1, 0 };\nint Q[] = { 1, 0, 3, 2 };\n\nconst int N = 110;\nint dist[N][N][4][12];\nint n, m, a;\nvector<string> board;\npriority_queue<tuple<int, int, int, int, int>> pq;\n\nvoid enq(int r, int c, int dir, int p, int q){\n\tif (p > a || q > a) return;\n\tr += dy[dir], c += dx[dir];\n\tif (r < 0 || r >= n || c < 0 || c >= m) return;\n\tif (board[r][c] == '#') return;\n\tif (board[r][c] == 'S' && dir == 0) return;\n\tint d = p + q;\n\tif (dist[r][c][dir][p] <= d) return;\n\tdist[r][c][dir][p] = d;\n\tpq.emplace(-d, r, c, dir, p);\n};\n\n\nint main(){\n\tcin >> n >> m >> a;\n\n\tboard.resize(n);\n\trep(i, n) cin >> board[i];\n\n\tpair<int, int> start, goal;\n\trep(i, n) rep(j, m){\n\t\tif (board[i][j] == 'S') start = MP(i, j);\n\t\tif (board[i][j] == 'G') goal = MP(i, j);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tdist[start.first][start.second][2][0] = 0;\n\tpq.push(MT(0, start.first, start.second, 2, 0));\n\n\tint ans = -1;\n\twhile (!pq.empty()){\n\t\tauto state = pq.top();\n\t\tpq.pop();\n\t\tint d, r, c, dir, p, q;\n\t\ttie(d, r, c, dir, p) = state;\n\t\td = -d;\n\t\tq = d - p;\n\n\t\tif (dist[r][c][dir][p] < d) continue;\n\n\t\tif (MP(r, c) == goal){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (board[r][c] != 'S'){\n\t\t\tenq(r, c, P[dir], p + 1, q);\n\t\t\tenq(r, c, Q[dir], p, q + 1);\n\t\t}\n\t\tenq(r, c, dir, p, q);\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 100;\nconst int W = 100;\nconst int A = 10;\nconst int INF = 1 << 29;\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\nconst int usep[4] = {3, 2, 1, 0};\nconst int useq[4] = {1, 0, 3, 2};\n\nstruct state{\n  int x, y, d, p, q;\n  state(int y=0, int x=0, int d=0, int p=0, int q=0):x(x),y(y),d(d),p(p),q(q){}\n  bool operator < (const state &s) const {\n    return (p+q) > (s.p+s.q);\n  }\n};\n\nint h, w, a, sy, sx, gy, gx;\nbool G[H][W];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return !G[y][x];\n}\n\nint solve(){\n  bool f[H][W][4][A+1][A+1];\n  priority_queue<state> pq;\n  state u, u2;\n\n  for(int i=0;i<h*w;i++) for(int j=0;j<4;j++) for(int k=0;k<=a;k++) for(int l=0;l<=a;l++) f[i/w][i%w][j][k][l] = false;\n  \n  /*\n  for(int i=0;i<4;i++) {\n    pq.push(state(sy, sx, i, 0, 0));\n    f[sy][sx][i][0][0] = true;\n  }\n  */\n  pq.push(state(sy, sx, 2, 0, 0));\n  f[sy][sx][2][0][0] = true;\n\n  while(!pq.empty()){\n    u = pq.top();\n    pq.pop();\n\n    if(u.y == gy && u.x == gx) return u.p + u.q;\n\n    u2 = state(u.y+dy[u.d], u.x+dx[u.d], u.d, u.p, u.q);\n    if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n      f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n      pq.push(u2);\n    }\n    \n    if(u.p < a){\n      u2 = u;\n      u2.d = usep[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.p++;\n      if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n\n    if(u.q < a){\n      u2 = u;\n      u2.d = useq[u.d];\n      u2.y += dy[u2.d];\n      u2.x += dx[u2.d];\n      u2.q++;\n      if(check(u2.y, u2.x) && !f[u2.y][u2.x][u2.d][u2.p][u2.q]) {\n        f[u2.y][u2.x][u2.d][u2.p][u2.q] = true;\n        pq.push(u2);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string str;\n  while(cin >> h >> w >> a){\n    for(int i=0;i<h;i++){\n      cin >> str;\n      for(int j=0;j<w;j++){\n        G[i][j] = false;\n        if(str[j] == 'S'){\n          sy = i;\n          sx = j;\n          G[i][j] = true;\n        } else if(str[j] == 'G'){\n          gy = i;\n          gx = j;\n        } else if(str[j] == '#'){\n          G[i][j] = true;\n        }\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tdone[y][x][2][0][0] = true;\n\t\tque.push(make_pair(make_pair(y * 1000 + x, 2 * 10000), 0));\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G') return c;\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tswitch (dir)\n\t\t\t\t{\n\t\t\t\tcase UP:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RIGHT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOWN:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LEFT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (A < aa) continue;\n\t\t\t\tif (A < bb) continue;\n\t\t\t}\n\t\t\t\n\n\t\t\tif (done[yy][xx][dd][aa][bb]) continue;\n\n\t\t\tdone[y][x][dir][a][b] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(p+q>=ans) return;\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(s[y][x]=='S') return;\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n#define INF 100\nusing namespace std;\nstruct data{\n\tint x,y,p,q,dir;\n\tdata(){}\n\tdata(int yy,int xx,int dd,int pp,int qq){\n\t\tx=xx;\n\t\ty=yy;\n\t\tp=pp;\n\t\tq=qq;\n\t\tdir=dd;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn q>d.q;\n\t}\n};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint n,m,a;\nint fie[101][101];\nint dp[101][101][4][11];\nint sx,sy,gx,gy;\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<=a;l++){\n\t\t\t\t\tdp[i][j][k][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(sy,sx,1,0,0));\n\tdp[sy][sx][1][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.y][q.x][q.dir][q.p]<q.q)continue;\n\t\tif(0<=q.x+dx[q.dir] && q.x+dx[q.dir]<m && 0<=q.y+dy[q.dir] && q.y+dy[q.dir]<n){\n\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]!=-1 && dp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]>q.q){\n\t\t\t\tif(fie[q.y+dy[q.dir]][q.x+dx[q.dir]]==1 && q.dir==3)continue;\n\t\t\t\tdp[q.y+dy[q.dir]][q.x+dx[q.dir]][q.dir][q.p]=q.q;\n\t\t\t\tque.push(data(q.y+dy[q.dir],q.x+dx[q.dir],q.dir,q.p,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.p<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=3;\n\t\t\tif(q.dir==1)ndir=2;\n\t\t\tif(q.dir==2)ndir=1;\n\t\t\tif(q.dir==3)ndir=0;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p+1]>q.q){\n\t\t\t\tdp[q.y][q.x][ndir][q.p+1]=q.q;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p+1,q.q));\n\t\t\t}\n\t\t}\n\t\tif(q.q<a){\n\t\t\tint ndir=-1;\n\t\t\tif(q.dir==0)ndir=1;\n\t\t\tif(q.dir==1)ndir=0;\n\t\t\tif(q.dir==2)ndir=3;\n\t\t\tif(q.dir==3)ndir=2;\n\t\t\tif(fie[q.y][q.x]==0 && dp[q.y][q.x][ndir][q.p]>q.q+1){\n\t\t\t\tdp[q.y][q.x][ndir][q.p]=q.q+1;\n\t\t\t\tque.push(data(q.y,q.x,ndir,q.p,q.q+1));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tres=min(res,dp[gy][gx][j][i]+i);\n\t\t}\n\t}\n\treturn res!=INF?res:-1;\n}\n\nint main(void){\n\tscanf(\"%d %d %d %d\",&n,&m,&a);\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(str[j]=='S')sx=j,sy=i,fie[i][j]=1;\n\t\t\tif(str[j]=='G')gx=j,gy=i,fie[i][j]=2;\n\t\t\tif(str[j]=='#')fie[i][j]=-1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dijk());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nclass Data\n{\npublic:\n    int p, q, y, x, d;\n    Data(int p0, int q0, int y0, int x0, int d0){\n        p = p0;\n        q = q0;\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n    int toInt(){\n        return (((p * 11 + q) * 102 + y) * 102 + x) * 4 + d;\n    }\n};\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n\n    vector<string> s(h+2, string(w+2, '#'));\n    int sy, sx, gy, gx;\n    for(int i=1; i<=h; ++i){\n        for(int j=1; j<=w; ++j){\n            cin >> s[i][j];\n            if(s[i][j] == 'S'){\n                sy = i;\n                sx = j;\n            }\n            if(s[i][j] == 'G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n\n    vector<bool> check(11*11*102*102*4, false);\n    queue<Data> q;\n    Data d0(n, n, sy, sx, 1);\n    check[d0.toInt()] = true;\n    q.push(d0);\n\n    int ret = INT_MAX;\n    while(!q.empty()){\n        Data d = q.front();\n        q.pop();\n\n        if(d.y == gy && d.x == gx){\n            ret = min(ret, 2 * n - d.p - d.q);\n            continue;\n        }\n\n        for(int i=0; i<4; ++i){\n            Data d2 = d;\n            d2.y += dy[i];\n            d2.x += dx[i];\n            d2.d = i;\n            if(s[d2.y][d2.x] == '#')               // 進行方向に壁\n                continue;\n            if(d.y == sy && d.x == sx && d.d != i) // generator の上に鏡を置くことは出来ない\n                continue;\n            if(d.y == sy && d.x == sx && d.d == 3) // どのように鏡をおいても、generator を上向きに通過することは出来ない\n                continue;\n\n            if(d.d == i){                                               // そのまま直進\n                ;\n            }else if(abs(d.d - i) == 2){                                // 逆向きには戻れない\n                continue;\n            }else if((dy[d2.d] + dx[d2.d]) * (dy[d.d] + dx[d.d]) == 1){ // Pの鏡を使用\n                if(-- d2.p < 0)\n                    continue;\n            }else{                                                      // Qの鏡を使用\n                if(-- d2.q < 0)\n                    continue;\n            }\n\n            if(!check[d2.toInt()]){\n                check[d2.toInt()] = true;\n                q.push(d2);\n            }\n        }\n    }\n\n    if(ret == INT_MAX)\n        cout << -1 << endl;\n    else\n        cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll dx[4] = {0, 1, 0, -1};\nconst ll dy[4] = {-1, 0, 1, 0};\n\nP cost(ll d1, ll d2) {\n    if (d1 == d2) return {0, 0};\n    if ((d1 + 2)%4 == d2) return {linf, linf};\n    if ((d2 % 2) ^ ((d1+1)%4 == d2)) return {1, 0};\n    return {0, 1};\n}\n\nstruct Node {\n    ll x, y, dir, p, q;\n    ll cost;\n};\nbool operator>(const Node& n1, const Node& n2) {\n    return n1.cost > n2.cost;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll h, w, A; cin >> h >> w >> A;\n    vector<string> m(h); cin >> m;\n    ll sx = -1, sy = -1;\n    ll gx = -1, gy = -1;\n    rep(y, h) rep(x, w) {\n        if (m[y][x] == 'S') {\n            sx = x, sy = y;\n        }\n        if (m[y][x] == 'G') {\n            gx = x, gy = y;\n        }\n    }\n    vector<vector<vector<vector<vector<ll>>>>> dist(h,\n        vector<vector<vector<vector<ll>>>>(w,\n            vector<vector<vector<ll>>>(4,\n                vector<vector<ll>>(A+1, vector<ll>(A+1, linf))\n            )));\n    dist[sy][sx][2][0][0] = 0;\n    priority_queue<Node, vector<Node>, greater<Node>> Q; Q.push({sx, sy, 2, 0, 0, 0});\n    auto inRange = [&](ll x, ll y) {\n        return 0 <= x && x < w && 0 <= y && y < h;\n    };\n    while ( !Q.empty() ) {\n        Node node = Q.top(); Q.pop();\n        ll x = node.x, y = node.y;\n        ll dir = node.dir, p = node.p, q = node.q;\n        // cout << x << \" \" << y << \" \" << dir << \" \" << p << \" \" << q << endl;\n        if (node.cost > dist[y][x][dir][p][q]) continue;\n        rep(d, 4) {\n            P c = cost(dir, d);\n            ll np = p + c.first, nq = q + c.second;\n            if (np > A || nq > A) continue;\n            ll dc = c.first + c.second;\n            ll nx = d == dir ? x + dx[d] : x;\n            ll ny = d == dir ? y + dy[d] : y;\n            // cout << \"!\" << nx << \" \" << ny << \" \" << d << endl;\n            if ((d == 0 || d != dir) && x == sx && y == sy) continue;\n            if (!inRange(nx, ny)) continue;\n            if (m[ny][nx] == '#') continue;\n            if (dist[y][x][dir][p][q] + dc < dist[ny][nx][d][np][nq]) {\n                dist[ny][nx][d][np][nq] = dist[y][x][dir][p][q] + dc;\n                Q.push({nx, ny, d, np, nq, dist[ny][nx][d][np][nq]});\n            }\n        }\n    }\n    ll ans = linf;\n    rep(d, 4) rep(p, A+1) rep(q, A+1) {\n        // if (dist[gy][gx][d][p][q] >= 0) {\n        chmin(ans, dist[gy][gx][d][p][q]);\n        // }\n    }\n    if (ans == linf) ans = -1;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(p+q>=ans) return;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/**\n * Dijkstra's algorithm.\n * First, call add_edge() to add edges.\n * Second, call solve() to calculate the length of the shortest path from source to each vertex.\n * Header requirement: algorithm, queue, vector\n * Verified by AtCoder ARC026-C (http://arc026.contest.atcoder.jp/submissions/604231)\n */\n template<class Len = int>\nclass Dijkstra {\nprivate:\n  int n;\n  std::vector<std::vector<std::pair<int, Len> > > edges;\npublic:\n  /**\n   * n: the number of vertices\n   */\n  Dijkstra(int n) : n(n), edges(n) {}\n  /*\n   * from: the source of edge to add\n   * to: the target of edge to add\n   * cost: the cost of edge to add\n   */\n  void add_edge(int from, int to, Len cost) {\n    edges[from].push_back(std::pair<int, Len>(to, cost));\n  }\n  /*\n   * This function returns an array consisting of the distances from vertex source.\n   */\n  std::vector<Len> solve(int source) {\n    const Len inf = 1e16;\n    typedef std::pair<Len, int> pi;\n    std::vector<Len> d(n, inf);\n    std::priority_queue<pi, std::vector<pi>, std::greater<pi> > que;\n    que.push(pi(0, source));\n    while (!que.empty()) {\n      pi p = que.top(); que.pop();\n      int idx = p.second;\n      if (d[idx] <= p.first) {\n\tcontinue;\n      }\n      d[idx] = p.first;\n      for(int j = 0; j < edges[idx].size(); ++j) {\n\tque.push(pi(p.first + edges[idx][j].second, edges[idx][j].first));\n      }\n    }\n    return d;\n  }\n};\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, a;\n  cin >> n >> m >> a;\n  vector<string> s(n);\n  Dijkstra<ll> dijk(4 * (a + 1) * n * m);\n  int st = -1, go = -1;\n  REP(i, 0, n) {\n    cin >> s[i];\n    REP(j, 0, m) {\n      if (s[i][j] == 'S') {\n\tst = i * m + j;\n      }\n      if (s[i][j] == 'G') {\n\tgo = i * m + j;\n      }\n    }\n  }\n  int dx[4] = {1, 0, -1, 0};\n  int dy[4] = {0, 1, 0, -1};\n  REP(i, 0, n) {\n    REP(j, 0, m) {\n      int src = i * m + j;\n      if (s[i][j] == '#') { continue; }\n      REP(d, 0, 4) {\n\tif (src == st && d != 0) { continue; }\n\tint nx = i + dx[d];\n\tint ny = j + dy[d];\n\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) { continue; }\n\tint dst = nx * m + ny;\n\tREP(lv, 0, a + 1) {\n\t  dijk.add_edge(d * (a + 1) * n * m + lv * n * m + src,\n\t\t\td * (a + 1) * n * m + lv * n * m + dst,\n\t\t\t0);\n\t}\n      }\n    }\n  }\n  REP(v, 0, n * m) {\n    if (v == st) { continue; }\n    REP(lv, 0, a + 1) {\n      // 0 <-> 1 and 2 <-> 3, duplicate-side\n      if (lv < a) {\n\tREP(x, 0, 4) {\n\t  dijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t\t(x ^ 1) * (a + 1) * n * m + (lv + 1) * n * m + v,\n\t\t\t0);\n\t}\n      }\n      // 0 <-> 3 and 1 <-> 2, cost-side\n      REP(x, 0, 4) {\n\tdijk.add_edge(x * (a + 1) * n * m + lv * n * m + v,\n\t\t      (3 - x) * (a + 1) * n * m + lv * n * m + v,\n\t\t      1);\n      }\n    }\n  }\n  ll mi = a + 2;\n  VL sol = dijk.solve(0 * (a + 1) * n * m + st);\n  REP(d, 0, 4) {\n    REP(i, 0, a + 1) {\n      mi = min(mi, i + sol[d * (a + 1) * n * m + i * n * m + go]);\n    }\n  }\n  cout << (mi == a + 2 ? -1 : mi) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2342>\n 問題文============================================================\n \n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// (P,Q)\npii mirrorr[4] = {{1,0},{0,1},{1,0},{0,1}};\npii mirrorl[4] = {{0,1},{1,0},{0,1},{1,0}};\n\nbool dist[110][110][4][12][12]; // dist[i][j][dir][usedP][usedQ]\nll solve(){\n    ll res = INF;\n    ll N,M,A; cin >> N >> M >> A;\n    pii S,G;\n    vector<vector<char>> masu(N+2,vector<char>(M+2,'#'));\n    for(int i = 1; i <= N;i++){\n        for(int j = 1; j <= M;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == 'S') S = {i,j};\n            if(masu[i][j] == 'G') G = {i,j};\n        }\n    }\n    \n    using items = tuple<int,int,int,int,int>;\n    queue<items> q;\n    //for(int i = 0; i < 4;i++){ q.push(make_tuple(S.first,S.second,i,0,0));}\n    q.push(make_tuple(S.first,S.second,0,0,0));\n    while(q.size()){\n        auto item = q.front(); q.pop();\n        int i,j,dir,usedP,usedQ;\n        tie(i,j,dir,usedP,usedQ) = item;\n        if(masu[i][j] == '#') continue;\n        if(usedP > A || usedQ > A) continue;\n        if(dist[i][j][dir][usedP][usedQ]) continue;\n        dist[i][j][dir][usedP][usedQ] = true;\n        \n        int ny,nx;\n        ny = i + dy[dir]; nx = j + dx[dir];\n        q.push(make_tuple(ny,nx,dir,usedP,usedQ));\n        \n        ny = i + dy[(dir+1)%4]; nx = j + dx[(dir+1)%4];\n        q.push(make_tuple(ny,nx,(dir+1)%4,usedP+mirrorr[dir].first,usedQ+mirrorr[dir].second));\n        \n        ny = i + dy[(dir-1+4)%4]; nx = j + dx[(dir-1+4)%4];\n        q.push(make_tuple(ny,nx,(dir-1+4)%4,usedP+mirrorl[dir].first,usedQ+mirrorl[dir].second));\n    }\n    \n    for(int i = 0; i <= A;i++){\n        for(int j = 0; j <= A;j++){\n            for(int k = 0; k < 4;k++){\n                if(dist[G.first][G.second][k][i][j]){\n                    res = min(res,(ll)i+j);\n                }\n            }\n        }\n    }\n    return res == INF?-1:res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  int x, y, a, b, fr;\n  S(int x, int y, int a, int b, int fr) :\n    x(x), y(y), a(a), b(b), fr(fr) {}\n};\nbool insert(queue<S>& que, bool used[100][100][11][11][4], int x, int y, int a, int b, int fr){\n  if(used[y][x][a][b][fr]) return false;\n  used[y][x][a][b][fr] = true;\n  que.push(S(x, y, a, b, fr));\n  return true;\n}\nint tb[4][4] = {{-1, 0, 2, 1},\n                {0, -1, 1, 2},\n                {2, 1, -1, 0},\n                {1, 2, 0, -1}};\n\nint main(){\n  int H, W, A;\n  while(cin>>H>>W>>A){\n    bool used[100][100][11][11][4] = {};\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    queue<S> que;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == 'S'){\n        REP(r, 4){\n          int nx = x + dx[r];\n          int ny = y + dy[r];\n          if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n            insert(que, used, nx, ny, 0, 0, r);\n          }\n        }\n      }\n    }\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        if(valid(nx, ny, W, H) && grid[ny][nx] != '#'){\n          switch(tb[s.fr][r]){\n            case -1:\n              insert(que, used, nx, ny, s.a, s.b, r);\n              break;\n            case 0:\n              if(s.a + 1 <= A) insert(que, used, nx, ny, s.a + 1, s.b, r);\n              break;\n            case 1:\n              if(s.b + 1 <= A) insert(que, used, nx, ny, s.a, s.b + 1, r);\n              break;\n            case 2:\n              break;\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'G')REP(r, 4)REP(a, A + 1)REP(b, A + 1)if(used[y][x][a][b][r]) ans = min(ans, a + b);\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<1>(p) + 1 > h) return INF;\n\n\tdis[get<1>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<1>(p) + 1, get<0>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' && (m[ny][nx] != 'S' or d == i) && not (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[ny][nx][np][nq][i] = 1;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[110][110][15][15][4];\nchar board[110][110];\n\nconst int INF = 1 << 28;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Elem {\n    int x, y, a, b, dir;\n};\n\nint N, M, A;\nint sx, sy, gx, gy;\nint dfs(int x, int y, int a, int b, int dir) {\n    int& val = dp[x][y][a][b][dir];\n\n    if(val != INF) return val;\n    if(x == gx && y == gy) return val = 0;\n\n    int nx, ny, na, nb, nd;\n    vector<int> dirs = {dir, 3-dir, dir^1};\n    vector<int> use_a = {0, 1, 0};\n    vector<int> use_b = {0, 0, 1};\n\n    for(int k=0; k<3; k++) {\n        nd = dirs[k];\n        nx = x + dx[ nd ];\n        ny = y + dy[ nd ];\n        na = a + use_a[k];\n        nb = b + use_b[k];\n\n        if(x == sx && y == sy && k != 0) continue;\n        if(x == gx && y == gy && k != 0) continue;\n        if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;\n        if(board[nx][ny] == '#') continue;\n        if(na > A || nb > A) continue;\n\n        char orig = board[x][y];\n        if(k != 0) board[x][y] = '#';\n        val = min(val, dfs(nx, ny, na, nb, nd) + (k != 0));\n        board[x][y] = orig;\n    }\n    // printf(\"x = %d, y = %d, a = %d, b = %d, dir = %d, dp = %d\\n\", x, y, a, b, dir, val);\n    return val;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &A);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(board[i][j] == 'S') sx = i, sy = j;\n            if(board[i][j] == 'G') gx = i, gy = j;\n        }\n    }\n\n    fill(dp[0][0][0][0], dp[110][0][0][0], INF);\n    int ans = dfs(sx, sy, 0, 0, 0);\n    if(ans == INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  int &u=used[x][y][p][q][dir];\n  if(ans<=2*A-(p+q)||(u!=-1&&u<=2*A-(p+q)))return;\n  u=2*A-(p+q);\n  \n  vector<int> X,Y,ch;\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')break;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define S second\n#define F first\n#define N 105\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\ntypedef pair<P,P1> P2;\nint n,m,a,d[N][N],sy,sx;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint dijkstra(){\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P2(P(0,2),P1(P(0,0),P(sy,sx))));\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    int cost=t.F.F,dir=t.F.S;\n    int pcnt=t.S.F.F,qcnt=t.S.F.S;\n    int y=t.S.S.F,x=t.S.S.S;\n    if(s[y][x]=='G')return cost;\n    if(d[y][x]<cost)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i],ncost=cost;\n      int npcnt=pcnt,nqcnt=qcnt;\n      if(ny<0||nx<0||n<=ny||m<=nx)continue;\n      if(s[ny][nx]=='#')continue;\n      if(i!=dir){\n\tncost++;\n\tint mindir=min(i,dir),maxdir=max(i,dir);\n\tif((mindir==0&&maxdir==1)||(mindir==2&&maxdir==3))npcnt++;\n\telse if((mindir==0&&maxdir==3)||(mindir==1&&maxdir==2)) nqcnt++;\n\telse continue;\n      }\n      if(a<npcnt||a<nqcnt)continue;\n      if(d[ny][nx]>ncost){\n\td[ny][nx]=ncost;\n\tq.push(P2(P(ncost,i),P1(P(npcnt,nqcnt),P(ny,nx))));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>n>>m>>a;\n  for(int i=0;i<n;i++){\n    cin>>s[i];\n    for(int j=0;j<m;j++)\n      if(s[i][j]=='S')\n\tsy=i,sx=j;\n  }\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x;\n  int y;\n  int dir;\n  int cost;\n  int l;\n  int r;\n  Point() {;}\n  Point(int x, int y, int dir, int cost, int l, int r) :\n    x(x), y(y), dir(dir), cost(cost), l(l), r(r) {;}\n  bool operator<(const Point &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nint h, w, k;\nchar field[110][110];\nbool visit[110][110][4][11][11];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool OK(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h || field[y][x] == '#') { return false; }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &k) > 0) {\n    MEMSET(visit, false);\n    int sx, sy;\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 'S') { sx = x; sy = y; }\n      }\n    }\n    priority_queue<Point> que;\n    if (OK(sx, sy + 1)) {\n      que.push(Point(sx, sy + 1, 1, 0, k, k));\n    }\n    REP(i, 11) REP(j, 11) { visit[sy][sx][3][i][j] = true; }\n    while (!que.empty()) {\n      Point p = que.top();\n      que.pop();\n      if (visit[p.y][p.x][p.dir][p.l][p.r]) { continue; }\n      visit[p.y][p.x][p.dir][p.l][p.r] = true;\n      if (field[p.y][p.x] == 'G') {\n        printf(\"%d\\n\", p.cost);\n        goto next;\n      }\n      do {\n        int nx = p.x + dx[p.dir];\n        int ny = p.y + dy[p.dir];\n        if (!OK(nx, ny)) { continue; }\n        que.push(Point(nx, ny, p.dir, p.cost, p.l, p.r));\n      } while (false);\n      if (field[p.y][p.x] != 'S') {\n        do {\n          int ndir = p.dir ^ 1;\n          int nx = p.x + dx[ndir];\n          int ny = p.y + dy[ndir];\n          if (p.l == 0) { continue; }\n          if (!OK(nx, ny)) { continue; }\n          que.push(Point(nx, ny, ndir, p.cost + 1, p.l - 1, p.r));\n        } while (false);\n        do {\n          int ndir = p.dir ^ 3;\n          int nx = p.x + dx[ndir];\n          int ny = p.y + dy[ndir];\n          if (p.r == 0) { continue; }\n          if (!OK(nx, ny)) { continue; }\n          que.push(Point(nx, ny, ndir, p.cost + 1, p.l, p.r - 1));\n        } while (false);\n      }\n    }\n    puts(\"-1\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\n\n\n\n\n\nstruct Comp {\n\tbool operator() (pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nenum { UP = 0, RIGHT, DOWN, LEFT };\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\n\n\n\n\n\nint H, W, A;\nstring S[100];\n\n\n\n\n\nbool done[100][100][4][11][11];\n\nll solve()\n{\n\trep(y, 0, H) rep(x, 0, W) rep(dir, 0, 4) rep(a, 0, A + 1) rep(b, 0, A + 1) done[y][x][dir][a][b] = false;\n\n\tpriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, Comp> que;\n\t\n\trep(y, 0, H) rep(x, 0, W) if (S[y][x] == 'S')\n\t{\n\t\tint xx = x + dx[DOWN];\n\t\tint yy = y + dy[DOWN];\n\n\t\tif (xx < 0 || W <= xx) return -1;\n\t\tif (yy < 0 || H <= yy) return -1;\n\t\tif (S[yy][xx] == '#') return -1;\n\n\t\tdone[yy][xx][DOWN][0][0] = true;\n\t\tque.push(make_pair(make_pair(yy * 1000 + xx, DOWN * 10000), 0));\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint y = q.first.first / 1000;\n\t\tint x = q.first.first % 1000;\n\t\tint dir = q.first.second / 10000;\n\t\tint a = (q.first.second % 10000) / 100;\n\t\tint b = q.first.second % 100;\n\n\t\t//printf(\"[%d][%d][%d][%d][%d]\\n\", y, x, dir, a, b);\n\n\t\tint c = q.second;\n\n\t\tif (S[y][x] == 'G') return c;\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tif (i == 2) continue;\n\n\t\t\tint dd = (dir + i) % 4;\n\n\t\t\tint yy = y + dy[dd];\n\t\t\tint xx = x + dx[dd];\n\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (S[yy][xx] == '#') continue;\n\t\t\t\n\t\t\tint aa = a;\n\t\t\tint bb = b;\n\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tswitch (dir)\n\t\t\t\t{\n\t\t\t\tcase UP:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RIGHT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\taa++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbb++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOWN:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LEFT:\n\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\tbb++;\n\t\t\t\t\telse\n\t\t\t\t\t\taa++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (A < aa) continue;\n\t\t\t\tif (A < bb) continue;\n\t\t\t}\n\t\t\t\n\n\t\t\tif (done[yy][xx][dd][aa][bb]) continue;\n\n\t\t\tdone[y][x][dir][a][b] = true;\n\t\t\tque.push(make_pair(make_pair(yy * 1000 + xx, dd * 10000 + aa * 100 + bb), aa + bb));\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W >> A)\n\t{\n\t\tif (H == 0) return 0;\n\n\t\trep(i, 0, H) cin >> S[i];\n\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct stat{\n\tint y,x,dir,n1,n2; // n1, n2 : 鏡 /, \\ の残り枚数\n};\n\nint main(){\n\tint h,w,n; scanf(\"%d%d%d\",&h,&w,&n);\n\tchar B[100][101];\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) if(B[i][j]=='S') sx=j, sy=i;\n\n\tstatic int dp[100][100][4][11][11];\n\tmemset(dp,-1,sizeof dp);\n\tdp[sy][sx][3][n][n]=0;\n\trep(n1,n+1) rep(n2,n+1) dp[sy][sx][1][n1][n2]=777;\n\n\tqueue<stat> Q;\n\tQ.push((stat){sy,sx,3,n,n});\n\twhile(!Q.empty()){\n\t\tint y=Q.front().y,x=Q.front().x,dir=Q.front().dir,n1=Q.front().n1,n2=Q.front().n2;\n\t\tQ.pop();\n\n\t\tif(B[y][x]=='G'){ printf(\"%d\\n\",dp[y][x][dir][n1][n2]); return 0; }\n\n\t\tint y2=y+dy[dir],x2=x+dx[dir];\n\t\twhile(0<=y2 && y2<h && 0<=x2 && x2<w && B[y2][x2]!='#' && dp[y2][x2][dir][n1][n2]==-1){\n\t\t\tdp[y2][x2][dir][n1][n2]=dp[y][x][dir][n1][n2];\n\n\t\t\tif(B[y2][x2]=='G'){ printf(\"%d\\n\",dp[y2][x2][dir][n1][n2]); return 0; }\n\n\t\t\t// 鏡 / を置く\n\t\t\tint dir2=dir^1;\n\t\t\tif(n1>0 && dp[y2][x2][dir2][n1-1][n2]==-1){\n\t\t\t\tdp[y2][x2][dir2][n1-1][n2]=dp[y][x][dir][n1][n2]+1;\n\t\t\t\tQ.push((stat){y2,x2,dir2,n1-1,n2});\n\t\t\t}\n\n\t\t\t// 鏡 \\ を置く\n\t\t\tdir2=3-dir;\n\t\t\tif(n2>0 && dp[y2][x2][dir2][n1][n2-1]==-1){\n\t\t\t\tdp[y2][x2][dir2][n1][n2-1]=dp[y][x][dir][n1][n2]+1;\n\t\t\t\tQ.push((stat){y2,x2,dir2,n1,n2-1});\n\t\t\t}\n\n\t\t\ty2+=dy[dir];\n\t\t\tx2+=dx[dir];\n\t\t}\n\t}\n\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint m[4][4];\n\nint h, w, n;\nchar in[100][101];\nbool v[100][100][4][11][11];\n\nint main(){\n\tm[0][3] = m[1][2] = m[3][0] = m[2][1] = 1;\n\t\n\tcin >> h >> w >> n;\n\tint y, x;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t}\n\tpriority_queue<pair<int, pi> > Q;\n\tQ.push(mp(0, mp(2 * h * w + y * w + x, n * 11 + n)));\n\t\n\twhile(!Q.empty()){\n\t\tint co = -Q.top().first;\n\t\tint cd = Q.top().second.first / h / w;\n\t\ty = Q.top().second.first / w % h; x = Q.top().second.first % w;\n\t\tint p = Q.top().second.second / 11, q = Q.top().second.second % 11;\n\t\tQ.pop();\n\t\t\n\t\tif(v[y][x][cd][p][q]) continue;\n\t\tv[y][x][cd][p][q] = 1;\n\t\t\n\t\t//cerr<<y<<\" \"<<x<<\" \"<<cd<<\" \"<<p<<\" \"<<q<<\" \"<<co<<endl;\n\t\t\n\t\tif(in[y][x] == 'G'){\n\t\t\tcout << co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 4) if(d != (cd ^ 2)){\n\t\t\tif(in[y][x] == 'S' && cd != d) continue;\n\t\t\tif(in[y][x] == 'S' && co && dy[d]) continue;\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\tint np = p - 1 + m[cd][d], nq = q - m[cd][d], nc = co;\n\t\t\t\n\t\t\tif(d == cd) np = p, nq = q;\n\t\t\telse nc++;\n\t\t\tif(np < 0 || nq < 0) continue;\n\t\t\t\n\t\t\tif(!v[ny][nx][d][np][nq]) Q.push(mp(-nc, mp(d * h * w + ny * w + nx, np * 11 + nq)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define pf(a) push_front((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nbool d[100*100*4];\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  auto f = [&](int i, int j, int dir){\n    return (i*m+j)*4+dir;\n  };\n\n  int sx,sy,tx,ty;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      sx = i+1; sy = j;\n    }\n    if(vec[i][j]=='G') tx=i, ty=j;\n  }\n\n  auto ok = [&](int i, int j, int dir){//dbg(i,j,dir);\n    if(i<0 || i>=n || j<0 || j>=m) return false;\n    if(dir%2==0 && vec[i][j]=='S') return false;\n    return (vec[i][j]=='.' || vec[i][j]=='G' || vec[i][j]=='S' );\n  };\n\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,1,0,-1};\n  const int mirrx[] = {3,2,1,0};\n  const int mirry[] = {1,0,3,2};\n\n  int res = INF;\n\n  fill(d, d+(sizeof(d)), false);\n  deque<int> qx, qy, qi, qj, qd;\n  d[f(sx,sy,0)] = true;\n  qx.pb(sx); qy.pb(sy); qi.pb(0); qj.pb(0); qd.pb(0);\n\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop_front();\n    int y = qy.front(); qy.pop_front();\n    int i = qi.front(); qi.pop_front();\n    int j = qj.front(); qj.pop_front();\n    int dir = qd.front(); qd.pop_front();\n\n    if(x==tx && y==ty){\n      res = min(res, i+j);\n      continue;\n    }\n\n    int nx,ny;\n\n    // ????????????\n    nx = x + dx[dir];\n    ny = y + dy[dir];\n    if(ok(nx, ny, dir)){\n      int z = f(nx, ny, dir);\n      if(!d[z]){\n        d[z] = true;\n        qx.pf(nx); qy.pf(ny); qi.pf(i); qj.pf(j); qd.pf(dir);\n      }\n    }\n\n    if(vec[x][y]=='S') continue;\n\n    // mirror\n    nx = x + dx[mirrx[dir]];\n    ny = y + dy[mirrx[dir]];\n    if(i<a && ok(nx, ny, mirrx[dir])){\n      int z = f(nx, ny, mirrx[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.pb(nx); qy.pb(ny); qi.pb(i+1); qj.pb(j); qd.pb(mirrx[dir]);\n      }\n    }\n\n    nx = x + dx[mirry[dir]];\n    ny = y + dy[mirry[dir]];\n    if(j<a && ok(nx, ny, mirry[dir])){\n      int z = f(nx, ny, mirry[dir]);\n      if(!d[z]){\n        d[z] = true;\n        qx.pb(nx); qy.pb(ny); qi.pb(i); qj.pb(j+1); qd.pb(mirry[dir]);\n      }\n    }\n  }\n\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n\nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k) {\n                for (int l = 0; l <= a; ++l) {\n                    dist[i][j][k][l] = 100;\n                }\n            }\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    dist[si][sj][1][0] = 0;\n    qi.push_back(si);\n    qj.push_back(sj);\n    qd.push_back(1);\n    qm.push_back(0);\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && !(s[ti][tj] == 'S' && pd == 3) && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        {\n            int td = pd ^ 1;\n            if (pm < a && dist[pi][pj][td][pm + 1] > dis) {\n                dist[pi][pj][td][pm + 1] = dis;\n                qi.push_front(pi);\n                qj.push_front(pj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            if (dist[pi][pj][td][pm] > dis + 1) {\n                dist[pi][pj][td][pm] = dis + 1;\n                qi.push_back(pi);\n                qj.push_back(pj);\n                qd.push_back(td);\n                qm.push_back(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j <= a; ++j) {\n            ans = min(ans, dist[gi][gj][i][j] + j);\n        }\n    }\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std ;\n\nint dx[] = {1 , 0 , -1 , 0} ;\nint dy[] = {0 , 1 , 0 , -1} ;\nint vis[110][110][11][11] ;\nchar map[111][111] ;\nint n , m , endx , endy , A , T;\ninline bool achi(int x,int y) {\n    if(x>=n || x<0 || y>=m || y < 0) return false ;\n    if(map[x][y] == '#' || map[x][y] == 'S') return false ;\n    return true ;\n}\n\nstruct Node{\n    int x,y,ua,ub,ol ;\n}start ;\n\nvoid in() {\n    for(int i = 0 ; i < n ; i++)\n    scanf(\"%s\",map[i]) ;\n    for(int i = 0 ; i < n ; i++)\n    for(int j = 0 ; j < m ; j++)\n    if(map[i][j] == 'S') start.x = i+1 , start.y = j ;\n    else if(map[i][j] == 'G') endx = i , endy = j ;\n}\n\nqueue<Node> q;\nvoid work() {\n    start.ua = start.ub = 0 ; start.ol = 0 ;\n    if(achi(start.x,start.y)) { q.push(start) ; vis[start.x][start.y][0][0]=T ;}\n    while(!q.empty()) {\n        Node st = q.front() ; q.pop() ;\n        int x = st.x , y = st.y , ua = st.ua , ub = st.ub , ol = st.ol;\n        if(x==endx && y==endy) continue ;\n        for(int i = 0 ; i < 4 ; i++) {\n            int nx = x+dx[i] , ny = y+dy[i] , na=ua , nb=ub , nl=i ;\n            if(!achi(nx,ny)) continue ;\n            if((nl==0 && ol==2)||(nl==2 && ol==0)) continue ;\n            if((nl==1 && ol==3)||(nl==3 && ol==1)) continue ;\n            if(nl == ol) ;\n            else if((nl^1) == ol) na++ ;\n            else nb++ ;\n            if(na <= A && nb <= A && vis[nx][ny][na][nb] != T) {\n                q.push((Node){nx,ny,na,nb,nl}) ;\n                vis[nx][ny][na][nb] = T ;\n            }\n        }\n    }\n    int ans = 0x3f3f3f3f;\n    for(int i = 0 ; i <= A ; i++)\n    for(int j = 0 ; j <= A ; j++)\n    if(vis[endx][endy][i][j] == T) ans = min(ans , i+j) ;\n    if(ans != 0x3f3f3f3f) printf(\"%d\\n\",ans) ;\n    else printf(\"-1\\n\") ;\n}\n\nint main() {\n    //freopen(\"C.in\",\"r\",stdin) ;\n    while(~scanf(\"%d%d%d\",&n,&m,&A)) {\n        T++ ;\n        in() ;\n        work() ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nDef d[110][110][11][4];\nclass DIJ{\n\tpublic:\n\tDef n,m,A;\n\tvs in;\n\tDIJ(Def size,Def w,vs fi,Def q){\n\t\tn=size;\n\t\tin=fi;\n\t\tm=w;\n\t\tA=q;\n\t}\n\tvoid dij(){\n\t\trep(i,110)rep(j,110)rep(l,11)rep(q,4)\n\t\t\td[i][j][l][q]=inf;\n\t\tint gx,gy;\n\t\tpriority_queue<tp>q;\n\t\trep(i,in.size())rep(j,in[0].size())\n\t\t\tif(in[i][j]=='G')gx=i,gy=j;\n\t\t\telse if(in[i][j]=='S'){\n\t\t\t\td[i][j][0][1]=0;\n\t\t\t\tq.push(tp(0,i,j,0,1));\n\t\t\t}\n\t\t\t\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,a,to;\n\t\t\ttie(cost,x,y,a,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][a][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tint na=a,nb=cost;\n\t\t\t\tint nto=k;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tif((to+2)%4==nto)continue;\n\t\t\t\tif(nto!=to){\n\t\t\t\t\tif(to%2){\n\t\t\t\t\t\tif((to+1)%4==nto)na++;\n\t\t\t\t\t\telse nb++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((to+1)%4==nto)nb++;\n\t\t\t\t\t\telse na++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(na>A||nb>A)continue;\n\t\t\t\tif(nb<d[nx][ny][na][nto]){\n\t\t\t\t\td[nx][ny][na][nto]=nb;\n\t\t\t\t\tq.push(tp(-nb,nx,ny,na,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,11)rep(j,4)if(d[gx][gy][i][j]!=inf){\n\t\t\tcmin(out,i+d[gx][gy][i][j]);\n\t\t}\n\t\tif(out==inf)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(n,m,in,k);\n\tdij.dij();\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <iostream>\n#include <cstdlib>\n#include <sstream>\n#define ll long long\nusing namespace std;\n\nconst int dir[4][2] = {0,-1,1,0,0,1,-1,0};\nbool vis[110][110][6][15];\nint ans,sti,stj,edi,edj;\nint n,m,A;\nint d[110][110][6][15];\nconst int inf = 1000000000;\nchar g[110][110];\nqueue< pair< pair<int,int>, pair<int,int> > > que;\nvoid spfa()\n{\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            for (int k = 0; k < 4; k++)\n                for (int l = 0; l <= A; l++) {\n                    d[i][j][k][l] = inf;\n                    vis[i][j][k][l] = false;\n                }\n    while (!que.empty()) que.pop();\n        d[sti][stj][4][0] = 0;\n        vis[sti][stj][4][0] = true;\n        que.push(make_pair(make_pair(sti,stj),make_pair(4,0)));\n  //  cout<<vis[1][0][1][0]<<endl;\n    while (!que.empty()) {\n        pair< pair<int,int>, pair<int,int> > u = que.front();\n        que.pop();\n        int i = u.first.first;\n        int j = u.first.second;\n        int k = u.second.first;\n        int dd = u.second.second;\n        int dis = d[i][j][k][dd];\n        vis[i][j][k][dd] = false;\n      //  cout<<i<<' '<<j<<' '<<k<<' '<<dd<<' '<<dis<<endl;\n        if (i == edi && j == edj) {\n            ans = min(ans, dis + dd);\n        }\n        for (int kk = 0; kk < 4; kk++) {\n            int ni = i + dir[kk][0];\n            int nj = j + dir[kk][1];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && g[ni][nj] !='#') {\n                int nd,ndis;\n                if (k == 4 || kk == k) {\n                    nd = dd;\n                    ndis = dis;\n                   // cout<<i<<' '<<j<<' '<<k<<endl;\n                }\n                else\n                if (kk + k == 3) {\n                    nd = dd + 1;\n                    ndis = dis;\n                }\n                else\n                if (kk + k == 5 || kk + k == 1) {\n                    nd = dd;\n                    ndis = dis + 1;\n                }\n                else continue;\n                if (nd > A || ndis > A) continue;\n            //    cout<<i<<' '<<j<<' '<<k<<' '<<ni<<' '<<nj<<' '<<kk<<'x'<<nd<<' '<<ndis<<endl;\n                if (d[ni][nj][kk][nd] > ndis) {\n                 //   cout<<ni<<' '<<nj<<' '<<kk<<'y'<<nd<<' '<<ndis<<' '<<d[ni][nj][kk][nd]<<endl;\n                    d[ni][nj][kk][nd] = ndis;\n                  // cout<<ni<<' '<<nj<<' '<<kk<<'y'<<nd<<' '<<ndis<<' '<<d[ni][nj][kk][nd]<<endl;\n                    if (!vis[ni][nj][kk][nd]) {\n                        vis[ni][nj][kk][nd] = true;\n                        que.push(make_pair(make_pair(ni,nj),make_pair(kk,nd)));\n                    }\n                }\n              //  cout<<vis[1][0][1][0]<<endl;\n            }\n        }\n    }\n}\nint main()\n{\n  //  for (int k = 0; k < 4; k++)\n   // cout<<dir[k][0]<<' '<<dir[k][1]<<endl;\n    while (scanf(\"%d%d%d\",&n,&m,&A)!=EOF) {\n        ans = inf;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                scanf(\" %c\",&g[i][j]);\n                if (g[i][j] == 'S') {\n                    sti = i;\n                    stj = j;\n                }\n                if (g[i][j] == 'G') {\n                    edi = i;\n                    edj = j;\n                }\n            }\n        //cout<<sti<<' '<<stj<<' '<<edi<<' '<<edj<<endl;\n        spfa();\n        if (ans == inf) ans = -1;\n        printf(\"%d\\n\",ans);\n    }\n}\n/*\n(x1|x2)\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint dp[111][111][4][11][11];\nint d=2,h,w,n,sx,sy,gx,gy,ans=-1;\nstring s[111];\nstruct T{\n    int y,x,d,l,r,cost;\n    T(int a,int b,int c,int f,int e,int w){y=a,x=b,d=c,l=f,r=e,cost=w;}\n};\nsigned main(){\n    cin>>h>>w>>n;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n        if(s[i][j]=='S')sy=i,sx=j;\n        if(s[i][j]=='G')gy=i,gx=j;\n    }\n    deque<T>q;\n    q.push_back(T(sy,sx,2,0,0,0));\n    dp[sy][sx][2][0][0]=1;\n    while(!q.empty()){cout<<q.size()<<endl;\n        T a=q.front();q.pop_front();\n        d=a.d;\n        if(s[a.y][a.x]=='G'){ans=a.cost;break;}\n        if(d==0&&s[a.y][a.x]=='S')continue;\n        int y=a.y+dy[d];\n        int x=a.x+dx[d];\n        if(y<0||x<0||y>=h||x>=w)continue;\n        if(s[y][x]=='#')continue;\n        if(1){\n            q.push_front(T(y,x,d,a.l,a.r,a.cost));\n        }\n        if(a.l<n){\n            q.push_back(T(y,x,3-d,a.l+1,a.r,a.cost+1));\n        }\n        if(a.r<n){\n            q.push_back(T(y,x,d^1,a.l,a.r+1,a.cost+1));\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nint ans=1e9,used[101][101][10][10][4];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(ans<1e9||used[x][y][p][q][dir]++)return;\n  \n  while(1){\n    x=x+dx[dir];\n    y=y+dy[dir];\n    if(x<0||y<0||x>=w||y>=h)return;\n    if(mp[y][x]=='#')return;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    int ch=mp[y][x];\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2);\n      if(dir==1)dfs(x,y,p-1,q,3);\n      if(dir==2)dfs(x,y,p-1,q,0);\n      if(dir==3)dfs(x,y,p-1,q,1);\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3);\n      if(dir==1)dfs(x,y,p,q-1,2);\n      if(dir==2)dfs(x,y,p,q-1,1);\n      if(dir==3)dfs(x,y,p,q-1,0);\n    }\n    mp[y][x]=ch;\n  }\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n//00:00\n//00:35 WA\nint h,w,r;\nint gone[105][105][5][15][15]={};\nchar dat[105][105];\n\nstruct qd{\n\tint y,x,d;\n\tint a,b;\n\tbool operator<(qd v)const{\n\t\treturn (a+b)<(v.a+v.b);\n\t}\n\tbool operator>(qd v)const{\n\t\treturn (v<(*this));\n\t}\n};\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\n\nint sy,sx;\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&r);\n\treg(y,1,h)scanf(\"%s\",dat[y]+1);\n\treg(y,0,h+1)dat[y][0]=dat[y][w+1]='#';\n\treg(x,0,w+1)dat[0][x]=dat[h+1][x]='#';\n\t\n\treg(y,1,h)reg(x,1,w){\n\t\tif(dat[y][x]=='S'){\n\t\t\tsy=y; sx=x;\n\t\t}\n\t}\n\t\n\tpriority_queue<qd> que;\n\t\n\tqd da;\n\tda.d=1; da.x=sx; da.y=sy+1; da.a=da.b=r;\n\tque.push(da);\n\twhile(!que.empty()){\n\t\tqd da = que.top();\n\t\tque.pop();\n\t\tint x=da.x,y=da.y,d=da.d,a=da.a,b=da.b;\n\t\t//printf(\"%d %d %d | %d %d\\n\",y,x,d,a,b);\n\t\tif(gone[y][x][d][a][b])continue;\n\t\tgone[y][x][d][a][b] = 1;\n\t\tif(dat[y][x]=='S' && d==3)continue;\n\t\tif(dat[y][x]=='#')continue;\n\t\tif(dat[y][x]=='G'){\n\t\t\tprintf(\"%d\\n\",r+r-da.a-da.b);\n\t\t\treturn 0;\n\t\t}\n\t\treg(i,-1,1){\n\t\t\tint td=(d+i+4)%4;\n\t\t\tint tx=x+dx[td],ty=y+dy[td];\n\t\t\t//printf(\"%d %d %d\\n\",ty,tx,td);\n\t\t\tif(dat[ty][tx]=='#')continue;\n\t\t\tif(i!=0 && dat[y][x]=='S')continue;\t\n\t\t\tqd db=da;\n\t\t\tdb.x=tx; db.y=ty; db.d=td;\n\t\t\tif(i!=0){\n\t\t\t\tif((td+(i>0?1:0))%2==0)db.a--;\n\t\t\t\telse db.b--;\n\t\t\t}\n\t\t\tif(db.a<0 ||db.b<0)continue;\n\t\t\tque.push(db);\n\t\t}\n\t}\n\t\n\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i + 1 < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i+1,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    if(in[cx][cy] == 'S' && di==3) continue;\n    if(in[cx][cy] == '#') continue;    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      assert(0 <= nd && nd  < 4);\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      assert(0 <= nd && nd  < 4);\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count;\n  int life;\n  map<int,bool> P_mirror;//2->3, 3->2, 1->0, 0->1\n  map<int,bool> Q_mirror;//2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1),life(0) {}\n  State(int _x,int _y,int _p,int _q,int _d,\n\tmap<int,bool>& _P_mirror,map<int,bool>& _Q_mirror,int _l) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d),life(_l) {\n    P_mirror = _P_mirror;\n    Q_mirror = _Q_mirror;\n  }\n\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d),life(0) { }\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nbool check(int x,int y,int gx,int gy,int dir,\n\t   map<int,bool>& P_mirror,map<int,bool>& Q_mirror,\n\t   int life,\n\t   char stage[100][100],int W,int H){\n  if(x == gx && y == gy && life == 0) return true;\n\n  bool res = false;\n  int dx = x + tx[dir];\n  int dy = y + ty[dir];\n  if(dx < 0 || dy < 0 || dx >= W || dy >= H) return false;\n  if(stage[dy][dx] == '#') return false;\n\n  int next_dir = dir;\n  if(P_mirror.find(dy*W+dx) != P_mirror.end()){\n    if(dir == 0) next_dir = 3;\n    if(dir == 1) next_dir = 2;\n    if(dir == 2) next_dir = 1;\n    if(dir == 3) next_dir = 0;\n  }\n\n  if(Q_mirror.find(dy*W+dx) != Q_mirror.end()){\n    if(dir == 0) next_dir = 1;\n    if(dir == 1) next_dir = 0;\n    if(dir == 2) next_dir = 3;\n    if(dir == 3) next_dir = 2;\n  }\n\n  res |= check(dx,dy,gx,gy,next_dir,P_mirror,Q_mirror,life-1,stage,W,H);\n     \n  return res;\n}\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,4));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100][10];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.x][s.y][s.prev_dir]) continue;\n      dp[s.x][s.y][s.prev_dir] = true;\n\n      // printf(\"x:%d y:%d prev:%d\\n\",s.x,s.y,s.prev_dir);\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\tif(!check(s.x,s.y,sx,sy,(s.prev_dir+2) % 4,\n\t\t  s.P_mirror,s.Q_mirror,s.life,stage,W,H)) continue;\n\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(s.prev_dir == 4 && i != 2) continue;\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\tif(stage[s.y][s.x] == 'S'){\n\t  if(s.prev_dir != 4 && s.prev_dir != i){\n\t    continue;\n\t  }\n\t}\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\n\tmap<int,bool> P_mirror = s.P_mirror;\n\tmap<int,bool> Q_mirror = s.Q_mirror;\n\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t  P_mirror[s.y*W+s.x] = true;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t  Q_mirror[s.y*W+s.x] = true;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tif(s.prev_dir == (i + 2) % 4) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i,P_mirror,Q_mirror,s.life+1));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100][4];\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      for(int k=0;k<4;k++)memo[i][j][k]=inf;\n    }\n  }\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  memo[si][sj][0]=0;\n  memo[si][sj][2]=0;\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n      ans=min(memo[u.y][u.x][u.muki],ans);\n      continue;\n    }\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(memo[a][b][u.muki]>=u.numL+u.numR){\n\t  memo[a][b][u.muki]=u.numL+u.numR;\n\t  Q.push(State(a,b,u.muki,u.numL,u.numR));\n\t}\n      }\n    }\n    if(u.y==si && u.x==sj){}\n    else {\n      a=u.y+Y[(u.muki+1)%4];\n      b=u.x+X[(u.muki+1)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+1)%4]>=u.numL+u.numR+1){\n\t    memo[a][b][(u.muki+1)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+1)%4)%2==0){\n\t      if(u.numL<A)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\t    }\n\t    if(((u.muki+1)%4)%2==1){\n\t      if(u.numR<A)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n\t    }\n\t  }\n\t}\n      }\n      a=u.y+Y[(u.muki+3)%4];\n      b=u.x+X[(u.muki+3)%4];\n      if(in(a,b)){\n\tif(map[a][b]!='#'){\n\t  if(memo[a][b][(u.muki+3)%4]>=u.numR+u.numL+1){\n\t    memo[a][b][(u.muki+3)%4]=u.numR+u.numL+1;\n\t    if(((u.muki+3)%4)%2==0){\n\t      if(u.numR<A)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\t    }\n\t    if(((u.muki+3)%4)%2==1){\n\t      if(u.numL<A)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint memo[102][102][4][11][11];\nint field[102][102];\nint A;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstruct aa {\n\tint y;\n\tint x;\n\tint way;\n\tint p;\n\tint q;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn 2*A-(l.p+l.q)> 2 * A - (r.p+r.q);\n\t}\n};\n\n\n\nint pc(const int way) {\n\tif (way == 0) {\n\t\treturn 3;\n\t}\n\telse if (way == 1) {\n\t\treturn 2;\n\t}\n\telse if (way == 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\nint qc(const int way) {\n\tif (way == 0) {\n\t\treturn 1;\n\t}\n\telse if (way == 1) {\n\t\treturn 0;\n\t}\n\telse if (way == 2) {\n\t\treturn 3;\n\t}\n\telse {\n\t\treturn 2;\n\t}\n}\nint main() {\n\tmemset(memo, -1, sizeof(memo));\n\tint N, M; cin >> N >> M >> A;\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[0][j] = 0;\n\t}\n\tint sx, sy;\n\tint gx, gy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfield[i][0] = 0;\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (st[j] == 'S') {\n\t\t\t\tsx = j + 1;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'G') {\n\t\t\t\tgx = j + 1;\n\t\t\t\tgy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfield[i][M+1] = 0;\n\t}\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[N+1][j] = 0;\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sy,sx,1,A,A });\n\n\t\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = A - atop.p + A - atop.q;\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tconst int nway = atop.way;\n\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q]<0) {\n\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q] = 1;\n\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.p) {\n\t\t\t\tconst int nway = pc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p - 1, atop.q });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.q) {\n\t\t\t\tconst int nway = qc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] = 1;\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q - 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\nstruct Point{ int x, y, p, q, d; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tqueue<Point> q;\n\n\tif(p.y - 1 > h) return INF;\n\n\tdis[p.y + 1][p.x][a][a][1] = 1;\n\tPoint tmp = Point{p.x, p.y, a, a, 1};\n\tq.push(tmp);\n\n\twhile(not q.empty()){\n\t\tPoint u = q.front(); q.pop();\n\t\t//cout << u.x << ' ' << u.y << ' ' << u.p << ' ' << u.q << ' ' << u.d << endl;\n\t\trep(i,4){\n\t\t\tif((u.d + 2) % 4 == i) continue;\n\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tnext.d = i;\n\t\t\tnext.p = u.p;\n\t\t\tnext.q = u.q;\n\t\t\tif(u.d == 0 || u.d == 2){\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((u.d + 1) % 4 == i){\n\t\t\t\t\tnext.q = u.q - 1;\n\t\t\t\t}else if((u.d - 1 + 4) % 4 == i){\n\t\t\t\t\tnext.p = u.p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(next.p < 0 || next.q < 0) continue;\n\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[next.y][next.x][next.p][next.q][next.d] && m[next.y][next.x] != '#'){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tdis[next.y][next.x][next.p][next.q][next.d] = 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[g.y][g.x][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tPoint s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = Point{j,i};\n\t\tif(m[i][j] == 'G') g = Point{j,i};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int i,j,dir,p,q;\n};\nbool operator<(const state& a,const state& b){\n  return a.p+a.q<b.p+b.q;\n};\n\nint n,m,a;\nint dist[111][111][5][11][11];\nstring s[111];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nbool valid(int i,int j){\n  return i>=0&&i<n&&j>=0&&j<m;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m>>a;\n  rep(i,n)cin>>s[i];\n  rep(i,111)rep(j,111)rep(k,5)rep(p,11)rep(q,11)dist[i][j][k][p][q]=INF;\n  priority_queue<state> que;\n  rep(i,n)rep(j,m){\n    if(s[i][j]=='S'){\n      que.push((state){(int)i,(int)j,3,a,a});\n    }\n  }\n  int res=INF;\n  while(que.size()){\n    state ns=que.top(); que.pop();\n    int i=ns.i,j=ns.j,dir=ns.dir,p=ns.p,q=ns.q;\n    if(dist[i][j][dir][p][q]!=INF)continue;\n    dist[i][j][dir][p][q]=p+q;\n    if(s[i][j]=='G'){\n      res=2*a-p-q;\n      break;\n    }\n    if(s[i][j]!='S'){\n      int ndir;\n      if(p>0){\n        if(dir==3||dir==0) ndir=3-dir;\n        else ndir=3-dir;\n        int ni=i+dy[ndir],nj=j+dx[ndir];\n        if(valid(ni,nj)&&s[ni][nj]!='#'){\n          que.push((state){ni,nj,ndir,p-1,q});\n        }\n      }\n      if(q>0){\n        if(dir==0||dir==1) ndir=1-dir;\n        else ndir=5-dir;\n        int ni=i+dy[ndir],nj=j+dx[ndir];\n        if(valid(ni,nj)&&s[ni][nj]!='#'){\n          que.push((state){ni,nj,ndir,p,q-1});\n        }\n      }\n    }\n    int ni=i+dy[dir],nj=j+dx[dir];\n    if(valid(ni,nj)&&s[ni][nj]!='#'){\n      que.push((state){ni,nj,dir,p,q});\n    }\n  }\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_H 100\n#define MAX_W 100\n#define MAX_A 10\n\nstruct State{\n  int m,x,y,p,q,d;\n  State(int m,int x,int y,int p,int q,int d) :\n    m(m),x(x),y(y),p(p),q(q),d(d) {}\n};\n\nint H,W,A;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nbool visited[MAX_H][MAX_W][MAX_A][MAX_A][4];\n\ninline bool canMove(int x,int y){\n  if(0 <= x && x < W && 0 <= y && y < H\n     && field[y][x] != '#'){\n    return true;\n  }\n  return false;\n}\n\nint bfs(int sx,int sy,int gx,int gy){\n  deque<State> Q;\n  Q.push_back(State(0,sx,sy,A,A,3));\n  visited[sy][sx][A][A][3] = true;\n  \n  while(!Q.empty()){\n    State s = Q.front(); Q.pop_front();\n    int x = s.x, y = s.y;\n    if(x == gx && y == gy){ return s.m; }\n    int nx = x+dx[s.d], ny = y+dy[s.d];\n    if(canMove(nx,ny) && !visited[ny][nx][s.p][s.q][s.d]){\n      visited[ny][nx][s.p][s.q][s.d] = true;\n      Q.push_front(State(s.m,nx,ny,s.p,s.q,s.d));\n    }\n    if(s.p > 0 && field[y][x] == '.'){\n      int ndir = (s.d & 1 ? s.d+3 : s.d+1)%4;\n      if(!visited[y][x][s.p-1][s.q][ndir]){\n        visited[y][x][s.p-1][s.q][ndir] = true;\n        Q.push_back(State(s.m+1,x,y,s.p-1,s.q,ndir));\n      }\n    }\n    if(s.q > 0 && field[y][x] == '.'){\n      int ndir = (s.d & 1 ? s.d+1 : s.d+3)%4;\n      if(!visited[y][x][s.p][s.q-1][ndir]){\n        visited[y][x][s.p][s.q-1][ndir] = true;\n        Q.push_back(State(s.m+1,x,y,s.p,s.q-1,ndir));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  cin >> H >> W >> A;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){\n        sx = j; sy = i;\n      }else if(field[i][j] == 'G'){\n        gx = j; gy = i;\n      }\n    }\n  }\n  cout << bfs(sx,sy,gx,gy) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint n,m,a;\nint endx,endy;\nint ans=0x3f3f3f3f;\nchar map1[100+10][100+10];\nint dp[100+10][100+10][5][15];//蝨ィ縲ゅ?縲ゆス咲スョ 蜈臥コソ譛晏髄荳コ縲ゅ?縲?蜑ゥ菴?.荳ェQ髟懷ュ? 逧?園譛蛾復蟄壬謨ー \nbool vis[100+10][100+10][5][15];\nint dfs(int x,int y,int tow,int lastq)//0:down  1:left   2:right   3:up\n{\n    if(map1[x][y]=='#')return -1;\n    int &ret=dp[x][y][tow][lastq];\n    if(vis[x][y][tow][lastq])return ret;\n    vis[x][y][tow][lastq]=true;\n    if(x>0)\n    {\n        if(tow==0)ret=max(ret,dfs(x-1,y,0,lastq));\n        else if(tow==1&&lastq<a&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x-1,y,0,lastq+1));\n        else if(tow==2&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x-1,y,0,lastq)-1);\n    }\n    if(x<n-1)\n    {\n        if(tow==3)ret=max(ret,dfs(x+1,y,3,lastq));\n        else if(tow==1&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x+1,y,3,lastq)-1);\n        else if(tow==2&&lastq<a&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x+1,y,3,lastq+1));\n    }\n    if(y>0)\n    {\n        if(tow==2)ret=max(ret,dfs(x,y-1,2,lastq));\n        else if(tow==0&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x,y-1,2,lastq)-1);\n        else if(tow==3&&lastq<a&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x,y-1,2,lastq+1));\n    }\n    if(y<m-1)\n    {\n        if(tow==1)ret=max(ret,dfs(x,y+1,1,lastq));\n        else if(tow==0&&lastq<a&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x,y+1,1,lastq+1));\n        else if(tow==3&&map1[x][y]!='S'&&map1[x][y]!='G')ret=max(ret,dfs(x,y+1,1,lastq)-1);\n    }\n    return ret;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&a)!=EOF)\n    {\n    memset(vis,0,sizeof(vis));\n    memset(dp,-1,sizeof(dp));\n    ans=0x3f3f3f3f;\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%s\",map1[i]);\n        for(int j=0;j<m;j++)\n        {\n            if(map1[i][j]=='S')dp[i][j][0][a]=a;\n            else if(map1[i][j]=='G')endx=i,endy=j;\n        }\n    }\n    for(int i=0;i<4;i++)\n    {\n        for(int j=0;j<=a;j++)\n        {\n            int ret=dfs(endx,endy,i,j);\n            if(ret>=0)\n            {\n                ans=min(ans,a+a-ret-j);\n            }\n        }\n    }\n    if(ans!=0x3f3f3f3f)printf(\"%d\\n\",ans);\n    else printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,A;\nstring s[111];\nint dp[11][11][4][111][111];\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nstruct st{\n  int y,x,d,p,q;\n  st(){}\n  st(int y,int x,int d,int p,int q):y(y),x(x),d(d),p(p),q(q){}\n};\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  int ans=A*2+1;\n  int sy,sx;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S') sy=i,sx=j;\n  memset(dp,-1,sizeof(dp));\n  int ax[]={0,1,0,-1};\n  int ay[]={-1,0,1,0};\n  deque<st> dq;\n  dq.push_back(st(sy,sx,2,0,0));\n  dp[sy][sx][2][0][0]=0;\n  while(!dq.empty()){\n    st r=dq.front();dq.pop_front();\n    int y=r.y,x=r.x,d=r.d,p=r.p,q=r.q;\n    //cout<<y<<\" \"<<x<<\" \"<<d<<\" \"<<p<<\" \"<<q<<endl;\n    if(p+q>=ans) break;\n    if(s[y][x]=='G'){\n      ans=min(ans,p+q);\n      break;\n    }\n    {\n      int ny=y+ay[d],nx=x+ax[d],nd=d;\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p][q]<0||\n\t   dp[ny][nx][nd][p][q]>dp[y][x][d][p][q]){\n\t  dp[ny][nx][nd][p][q]=dp[y][x][d][p][q];\n\t  dq.push_front(st(ny,nx,nd,p,q));\n\t}\n      }\n    }\n    if(s[y][x]=='S'&&d==0) continue;\n    if(s[y][x]!='S'&&p<A){\n      int nd=P(d);\n      int ny=y+ay[nd],nx=x+ax[nd];\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p+1][q]<0||\n\t   dp[ny][nx][nd][p+1][q]>dp[y][x][d][p][q]+1){\n\t  dp[ny][nx][nd][p+1][q]=dp[y][x][d][p][q]+1;\n\t  //cout<<p+1<<\" \"<<q<<endl;\n\t  dq.push_back(st(ny,nx,nd,p+1,q));\n\t}\n      }\n    }\n    if(s[y][x]!='S'&&q<A){\n      int nd=Q(d);\n      int ny=y+ay[nd],nx=x+ax[nd];\n      if(in(ny,nx)&&s[ny][nx]!='#'){\n\tif(dp[ny][nx][nd][p][q+1]<0||\n\t   dp[ny][nx][nd][p][q+1]>dp[y][x][d][p][q]+1){\n\t  dp[ny][nx][nd][p][q+1]=dp[y][x][d][p][q]+1;\n\t  dq.push_back(st(ny,nx,nd,p,q+1));\n\t}\n      }\n    }\n  }\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nchar ba[100][100];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct P {\n  int y, x;\n  int d;\n  int a, b;\n  P(int y, int x, int d, int a, int b) : y(y),x(x),a(a),b(b),d(d) {}\n};\n\nbool ok[100][100][4][11][11];\n\nint main() {\n  int h, w, A;\n  while(cin>>h>>w>>A) {\n    int sx, sy;\n    int gx, gy;\n    REP(i,h) REP(j, w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == 'S') {\n        sy = i;\n        sx = j;\n      } else if (ba[i][j] == 'G') {\n        gy = i;\n        gx = j;\n      }\n    }\n    queue<P> Q;\n    memset(ok, 0, sizeof(ok));\n    Q.push(P(sy,sx,1,A, A));\n    bool hoge = 0;\n    while(!Q.empty()) {\n      P p = Q.front(); Q.pop();\n      if (ok[p.y][p.x][p.d][p.a][p.b]) continue;\n      ok[p.y][p.x][p.d][p.a][p.b] = 1;\n\n      //cout << p.x << \" \" << p.y << \" \" << p.d << \" \" << p.a << \" \" <<p.b << endl;\n      int yy = p.y + dy[p.d];\n      int xx = p.x + dx[p.d];\n      if (ba[p.y][p.x] == 'S' && p.d == 3) continue;\n      if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n        Q.push(P(yy,xx,p.d,p.a,p.b));\n\n      if (ba[p.y][p.x] == 'S') continue;\n      \n      if (p.a) {\n        int yy, xx;\n        int dd;\n        if (p.d % 2) {\n          dd = (p.d+3)%4;\n        } else {\n          dd = (p.d+1)%4;\n        }\n        yy = p.y + dy[dd];\n        xx = p.x + dx[dd];\n        if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n          Q.push(P(yy,xx,dd,p.a-1,p.b));\n      }\n      if (p.b) {\n        int yy, xx;\n        int dd;\n        if (p.d % 2) {\n          dd = (p.d+1)%4;\n        } else {\n          dd = (p.d+3)%4;\n        }\n        yy = p.y + dy[dd];\n        xx = p.x + dx[dd];\n        if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n          Q.push(P(yy,xx,dd,p.a,p.b-1));\n      }\n    }\n    int ans = -1;\n    REP(i, 4) {\n      REP(j, A+1) {\n        REP(k, A+1) {\n          if (ok[gy][gx][i][j][k]) {\n            //cout << i << \",\" << j <<\",\" << k << endl;\n            if (ans == -1) ans = A*2-(j+k);\n            else ans = min(ans, A*2-(j+k));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  // (num,x,y,dir,a1,a2)\n  priority_queue<tuple<int,int,int,int,int,int>, vector<tuple<int,int,int,int,int,int> >, greater<tuple<int,int,int,int,int,int> > > pq;\n  VI dist(idx(W,H,4,A+1,A+1)+1, INF);\n\n  if(sy + 1 < H && vs[sy+1][sx] != '#'){\n\tpq.push(make_tuple(0,sx,sy+1,2,0,0));\n\tdist[idx(sx,sy+1,2,0,0)] = 0;\n  }\n    \n  while(!pq.empty()){\n\tint num, x, y, d, a1, a2;\n\ttie(num,x,y,d,a1,a2) = pq.top(); pq.pop();\n\tif(x == gx && y == gy) break;\n\tint fr = idx(x,y,d,a1,a2);\n\tif(dist[fr] < num) continue;\n\n\t// ??????????????¨???\n\tif(vs[y][x] == '.'){\n\t  // /?????¢\n\t  if(a1 < A){\n\t\tint td = 3 - d;\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (tx == sx && ty >= sy && td == 0))){\n\t\t  int toid = idx(tx,ty,td,a1+1,a2);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1+1,a2));\n\t\t  }\n\t\t}\n\t  }\n\t  // \\?????¢\n\t  if(a2 < A){\n\t\tint td = d-(d%2*2-1);\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (tx == sx && ty >= sy && td == 0))){\n\t\t  int toid = idx(tx,ty,td,a1,a2+1);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1,a2+1));\n\t\t  }\n\t\t}\n\t  }\n\t}\n\n\t//??´???\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint toid = idx(tx,ty,d,a1,a2);\n\tif(dist[toid] > num){\n\t  dist[toid] = num;\n\t  pq.push(make_tuple(num,tx,ty,d,a1,a2));\n\t}\n  }\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tans = min(ans, dist[tid]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[100];\nbool vis[100][100][4][10][10];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.')\n      Q.push(state(cx,cy,~di&3,p-1,q));\n    \n    if(q && in[cx][cy]=='.')\n      Q.push(state(cx,cy,di^1,p,q-1));\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return a >= 0 && a < x;}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy, gx, gy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n      if(G[i][j] == 'G'){\n        gx = i;\n        gy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  cout << (dfs(sx, sy, 0, A, A) == INF ? -1 : 0) << endl;\n    \n                                                 return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing State = tuple<int, int, int, int, int>;\nconst int N = 101;\nint min_q[N][N][4][11];\n\nint h, w, n;\nvector<string> field;\n\nbool is_p[4][4];\n\ninline bool check(int x, int y){\n    return 0 <= x and x < w and 0 <= y and y < h and field[y][x] != '#';\n}\n\nint main(void){\n    cin >> h >> w >> n;\n    field = vector<string>(h);\n    for(auto & e : field) cin >> e;\n\n    int sx, sy, tx, ty;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] == 'S') sx = x, sy = y, field[y][x] = '.';\n            if(field[y][x] == 'G') tx = x, ty = y, field[y][x] = '.';\n        }\n    }\n\n    rep(i, h) rep(j, w) rep(k, 4) rep(l, n + 1) min_q[i][j][k][l] = inf;\n    priority_queue<State, vector<State>, greater<State>> q;\n    rep(i, 4){\n        int nx = sx + dx[i], ny = sy + dy[i];\n        if(not check(nx, ny)) continue;\n        q.push(State(0, nx, ny, i, 0));\n        min_q[ny][nx][i][0] = 0;\n    }\n\n    is_p[0][3] = true;\n    is_p[1][2] = true;\n    is_p[2][1] = true;\n    is_p[3][0] = true;\n\n    while(q.size()){\n        int x, y, di, up, uq;\n        tie(uq, x, y, di, up) = q.top(); q.pop();\n        \n        rep(ndi, 4){\n            int nx = x + dx[ndi], ny = y + dy[ndi];\n            if(not check(nx, ny)) continue;\n\n            int nup = up, nuq = uq;\n\n            if(ndi != di){\n                if((di + 2) % 2 == ndi) continue;\n                else if(is_p[di][ndi]){\n                    if(up == n) continue;\n                    nup++;\n                }\n                else {\n                    if(uq == n) continue;\n                    nuq++;\n                }\n            }\n\n            assert(field[ny][nx] != '#'); \n            if(not chmin(min_q[ny][nx][ndi][nup], nuq)) continue;\n            q.push(State(nuq, nx, ny, ndi, nup));\n        }\n    }\n\n    int res = inf;\n    rep(di, 4){\n        rep(up, n + 1){\n            chmin(res, up + min_q[ty][tx][di][up]);\n        }\n    }\n    if(res == inf){\n        res = -1;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    if(i<0 || i>=n || j<0 || j>=m) return -1;\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i+1,j,0,0,0);\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  auto ok = [&](int i, int j, bool bs){\n    return (vec[i][j]=='.' || vec[i][j]=='G' || (bs && vec[i][j]=='S') );\n  };\n\n  rep(i,n)rep(j,m-1){\n    if( ok(i,j,true) && ok(i,j+1,true) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( ok(i,j,false) && ok(i+1,j,false) ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        v[p].pb(f(i,j-1,x+1,y,3));\n        v[p+1].pb(f(i-1,j,x+1,y,2));\n        v[p+2].pb(f(i,j+1,x+1,y,1));\n        v[p+3].pb(f(i+1,j,x+1,y,0));\n      }\n      if(y<a){\n        v[p].pb(f(i,j+1,x,y+1,1));\n        v[p+1].pb(f(i+1,j,x,y+1,0));\n        v[p+2].pb(f(i,j-1,x,y+1,3));\n        v[p+3].pb(f(i-1,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(to==-1) continue;\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nstring in[110];\nbool vis[110][110][4][12][12];\n\n\nint main(){\n  int n,m,a;\n  cin >> n >> m >> a;\n  for(int i = 0; i < n; ++i)\n    cin >> in[i];\n  struct state{\n    int cx,cy,dir,p,q;\n    state(int _x,int _y, int _d, int _p, int _q):\n      cx(_x),cy(_y),dir(_d),p(_p),q(_q)\n    {}\n  };\n  \n  queue<state> Q;\n  for(int i = 0; i + 1 < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(in[i][j] == 'S')\n        Q.push(state(i+1,j,1,a,a));\n\n  int ans = 1000000;\n  \n  while(!Q.empty()){\n    state cst = Q.front();Q.pop();\n    int cx = cst.cx;\n    int cy = cst.cy;\n    int di = cst.dir;\n    int p = cst.p;\n    int q = cst.q;\n    if(vis[cx][cy][di][p][q]) continue;\n    vis[cx][cy][di][p][q] = 1;\n    //cout << cx << \" \"  << cy << \" \" << di << \" \" << p << \" \" << q << endl;\n    if(in[cx][cy] == 'S') continue;\n    if(in[cx][cy] == '#') continue;    \n    if(in[cx][cy] == 'G')\n      ans = min(ans, 2*a-(p+q));\n    \n    {\n      int nx = cx + dx[di];\n      int ny = cy + dy[di];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,di,p,q));\n    }\n\n    if(p && in[cx][cy]=='.'){\n      int nd = di^3;\n      assert(0 <= nd && nd  < 4);\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p-1,q));\n    }\n    \n    if(q && in[cx][cy]=='.'){\n      int nd = di^1;\n      assert(0 <= nd && nd  < 4);\n      int nx = cx + dx[nd];\n      int ny = cy + dy[nd];\n      if(min(nx,ny)>=0 && nx < n && ny < m &&\n         in[nx][ny] != '#')\n        Q.push(state(nx,ny,nd,p,q-1));\n    }\n  }\n  \n  if(ans > 2*a) ans = -1;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n//h, w, dir, P, Q\ntypedef struct _State{\n    int h, w, dir;\n    vector<int> pq;\n}State;\n \nint N, M, A;\nint Sh, Sw, Gh, Gw;\nvector<string> field;\n \n//south is 0\nint dh[] = {1, -1, 0, 0};\nint dw[] = {0, 0, 1, -1};\n \nint table[2][4] = {{2, 3, 0, 1}, {3, 2, 1, 0}};\n \nint dist[110][110][4][11][11];\n \nint bfs(){\n    queue<State> que;\n    //map<State, int> dist;\n    memset(dist, -1, sizeof(dist));\n    State s = State({Sh, Sw, 0, {A, A}});\n    que.push(s);\n    dist[s.h][s.w][s.dir][s.pq[0]][s.pq[1]] = 0;\n     \n    while(!que.empty()){\n        State u = que.front(); que.pop();\n        for(int nh=u.h+dh[u.dir], nw=u.w+dw[u.dir]; 0<=nh&&nh<N && 0<=nw&&nw<M && field[nh][nw]!='#'; nh+=dh[u.dir], nw+=dw[u.dir]){\n         \tif(nh == Sh && nw == Sw && u.dir == 1) break;\n            \n            for(int i=-1; i<2; i++){\n                if(nh == Sh && nw == Sw && i>=0) break;\n                    State v({nh, nw, u.dir, u.pq});\n                if(i >= 0){\n                    if(u.pq[i] == 0) continue;\n                    v.pq[i]--;\n                    v.dir = table[i][u.dir];\n                }\n                 \n                if(dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] < 0){\n                    dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] = dist[u.h][u.w][u.dir][u.pq[0]][u.pq[1]];\n                    if(i >= 0)\n                        dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]]++;\n                    if(v.h == Gh && v.w == Gw)\n                        return dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]];\n                     \n                    //cout << v.h << \" \" << v.w << \" \" << dist[v.h][v.w][v.dir][v.pq[0]][v.pq[1]] << endl;\n                    que.push(v);\n                }\n            }\n        }\n    }\n    return -1;\n}\n \nint main(){\n    cin >> N >> M >> A;\n    field.resize(N);\n    for(auto &s: field) cin >> s;\n     \n    for(int i=0; i<N; i++) for(int j=0; j<M; j++){\n        if(field[i][j] == 'S')\n            Sh = i, Sw = j;\n        if(field[i][j] == 'G')\n            Gh = i, Gw = j;\n    }\n     \n    cout << bfs() << endl;\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.a<c){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif((tr!=sr||tc!=sc)&&at.b<c){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 110;\nconst int pmax = 11;\nbool visit[sz][sz][pmax][pmax][4];\n\nint main(){\n  int N, M, P;\n  cin >> N >> M >> P;\n  vector<string> F(N + 2, string(M + 2, '#'));\n\n\n  queue<int> r_que;\n  queue<int> c_que;\n  queue<int> d_que;\n  queue<int> p_que;\n  queue<int> q_que;\n\n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, -1, 0, 1};\n\n  memset(visit, false, sizeof(visit));\n  \n  REP(i, N)REP(j, M){\n    cin >> F[i+1][j+1];\n    if(F[i+1][j+1] == 'S'){\n      r_que.push(i + 1);\n      c_que.push(j + 1);\n      p_que.push(P);\n      q_que.push(P);\n      d_que.push(0);\n      visit[i+1][j+1][P][P][0] = true;\n    }\n  }\n\n  int res = INF;\n  while(!r_que.empty()){\n    int r = r_que.front(); r_que.pop();\n    int c = c_que.front(); c_que.pop();\n    int d = d_que.front(); d_que.pop();\n    int p = p_que.front(); p_que.pop();\n    int q = q_que.front(); q_que.pop();\n    if(F[r][c] == 'G'){\n      res = min(res, 2 * P - p - q);\n      continue;\n    }\n\n    int r2 = r + dr[d];\n    int c2 = c + dc[d];\n    \n    if(F[r2][c2] != '#'){\n      if(!visit[r2][c2][p][q][d]){\n        r_que.push(r2);\n        c_que.push(c2);\n        p_que.push(p);\n        q_que.push(q);\n        d_que.push(d);\n      }\n\n      if(F[r2][c2] == '.' && p > 0){\n        int d2 = d % 2 == 1 ? (d + 3) % 4 : (d + 1) % 4;\n        if(!visit[r2][c2][p-1][q][d2]){\n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p-1);\n          q_que.push(q);\n          d_que.push(d2);\n        }\n      }\n\n      if(F[r2][c2] == '.' && q > 0){\n        int d2 = d % 2 == 0 ? (d + 3) % 4 : (d + 1) % 4;\n        if(!visit[r2][c2][p][q-1][d2]){\n          r_que.push(r2);\n          c_que.push(c2);\n          p_que.push(p);\n          q_que.push(q-1);\n          d_que.push(d2);\n        }\n      }\n    }\n  }\n  \n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct state{\n\tint x, y, p, q, dir;\n\tstate(int a, int b, int c, int d, int e){\n\t\tx = a, y = b, p = c, q = d, dir = e;\n\t}\n};\n\nint N, M, A;\nchar map[105][105];\nint sx, sy, gx, gy;\nbool used[105][105][15][15][4];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y, int p, int q, int dir)\n{\n\tused[x][y][p][q][dir] = true;\n\tif(map[x][y] == 'G') return;\n\t\n\tint np, nq, nx, ny;\n\tfor(int nd = 0; nd < 4; nd++){\n\t\tnp = p, nq = q;\n\t\tnx = x + dx[nd], ny = y + dy[nd];\n\t\tif(nx < 0 || nx >= M || ny < 0 || ny >= N) continue;\n\t\tif(map[nx][ny] == '#') continue;\n\t\tif((dir+4-nd) % 4 == 2) continue;\n\t\tif(dir != nd){\n\t\t\tif(dir/2 == nd/2) np++;\n\t\t\telse nq++;\n\t\t}\n\t\tif(np > A || nq > A) continue;\n\t\tif(used[nx][ny][np][nq][nd]) continue;\n\t\tdfs(nx, ny, np, nq, nd);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> A;\n\tfor(int y = 0; y < N; y++){\n\t\tfor(int x = 0; x < M; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'S') sx = x, sy = y;\n\t\t\tif(map[x][y] == 'G') gx = x, gy = y;\n\t\t}\n\t}\n\t\n\tif(sy == N-1 || map[sx][sy+1] == '#'){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsy++;\n\t\n\tfor(int x = 0; x < M; x++){\n\t\tfor(int y = 0; y < N; y++){\n\t\t\tfor(int p = 0; p <= A; p++){\n\t\t\t\tfor(int q = 0; q <= A; q++){\n\t\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\t\tused[x][y][p][q][d] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(sx, sy, 0, 0, 3);\n\t\n\tint ans = 1000;\n\tfor(int p = 0; p <= A; p++){\n\t\tfor(int q = 0; q <= A; q++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tif(used[gx][gy][p][q][d]){\n\t\t\t\t\tans = min(ans, p+q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans == 1000) ans = -1;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n// nesw\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nstruct state {\n\tint x, y, d, p, q;\n\tstate(int x, int y, int d, int p, int q) : x(x), y(y), d(d), p(p), q(q) {};\n};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\nint main() {\n\tint N, M, A;\n\tcin >> N >> M >> A;\n\tvs field(N);\n\tint sx, sy, gx, gy;\n\tREP(i, N) {\n\t\tcin >> field[i];\n\t\tREP(j, M) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\tif(field[i][j] == 'G') {\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(sy == N-1) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<vvvvi> visited(N, vvvvi(M, vvvi(4, vvi(A+1, vi(A+1)))));\n\tstack<state> S;\n\tS.push(state(sx, sy, 2, 0, 0));\n\tvisited[sy][sx][2][0][0] = 1;\n\tint ans = INF;\n\twhile(!S.empty()) {\n\t\tstate st = S.top();\n\t\tS.pop();\n\n\t\tif(st.x == gx && st.y == gy) {\n\t\t\tans = min(ans, st.p+st.q);\n\t\t}\n\n\t\tif(st.x == sx && st.y == sy && st.d == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tREP(d, 4) {\n\t\t\tif(abs(st.d-d) == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint nx = st.x+dx[d];\n\t\t\tint ny = st.y+dy[d];\n\t\t\tint np = st.p;\n\t\t\tint nq = st.q;\n\t\t\tif(nx < 0 || M <= nx || ny < 0 || N <= ny || field[ny][nx] == '#') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(st.d == d) {\n\t\t\t\t\n\t\t\t} else if(st.d+d == 3) {\n\t\t\t\tif(st.x == sx && st.y == sy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnp++;\n\t\t\t} else {\n\t\t\t\tif(st.x == sx && st.y == sy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnq++;\n\t\t\t}\n\n\t\t\tif(A < np || A < nq) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(!visited[ny][nx][d][np][nq]) {\n\t\t\t\tvisited[ny][nx][d][np][nq] = 1;\n\t\t\t\tS.push(state(nx, ny, d, np, nq));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans == INF) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nint H,W,A;\nchar F[110][110];\nint vis[110][110][11][11][4] = {};\nint dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\nstruct state{\n    int x,y,p,q,d;\n    bool in(){\n        return 1<=x && x<=H && 1<=y && y<=W;\n    }\n};\n\nint main(){\n    cin >> H >> W >> A;\n    int sx,sy,gx,gy;\n    for(int i=0;i<=H+1;i++) for(int j=0;j<=W+1;j++) F[i][j] = '#';\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++){\n        cin >> F[i][j];\n        if(F[i][j]=='S'){\n            sx = i; sy = j;\n        }\n        if(F[i][j]=='G'){\n            gx = i; gy = j;\n        }\n    }\n    queue<state> Q;\n    vis[sx][sy][A][A][0] = 1;\n    Q.push({sx,sy,A,A,0});\n    while(!Q.empty()){\n        state now = Q.front(); Q.pop();\n        //cerr << now.x << \" \" << now.y << \" \" << now.d << endl;\n        assert(F[now.x][now.y]!='#');\n        if(now.d==0){\n            for(int j=0;j<=1;j++){\n                if(now.x==sx && now.y==sy && j==0) continue;\n                if(j==1 && F[now.x+1][now.y]=='#') continue;\n                for(int i=-1;i<=1;i++){\n                    state ne = now;\n                    ne.x += j; ne.y += i;\n                    if(!ne.in() || F[ne.x][ne.y]=='#') continue;\n                    if(i==-1){ne.q--; ne.d = 3;}\n                    if(i==1){ne.p--; ne.d = 1;}\n                    if(ne.q>=0 && ne.p>=0 && !vis[ne.x][ne.y][ne.p][ne.q][ne.d]){\n                        vis[ne.x][ne.y][ne.p][ne.q][ne.d] = 1;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }else if(now.d==1){\n            for(int j=0;j<=1;j++){\n                if(j==1 && F[now.x][now.y+1]=='#') continue;\n                for(int i=-1;i<=1;i++){\n                    if(now.x==sx && now.y==sy && i!=0) continue;\n                    state ne = now;\n                    ne.x += i; ne.y += j;\n                    if(!ne.in() || F[ne.x][ne.y]=='#') continue;\n                    if(i==-1){ne.q--; ne.d = 2;}\n                    if(i==1){ne.p--; ne.d = 0;}\n                    if(ne.q>=0 && ne.p>=0 && !vis[ne.x][ne.y][ne.p][ne.q][ne.d]){\n                        vis[ne.x][ne.y][ne.p][ne.q][ne.d] = 1;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }else if(now.d==2){\n            if(now.x==sx && now.y==sy) continue;\n            for(int j=-1;j<=0;j++){\n                if(j==-1 && F[now.x-1][now.y]=='#') continue;\n                for(int i=-1;i<=1;i++){\n                    state ne = now;\n                    ne.x += j; ne.y += i;\n                    if(!ne.in() || F[ne.x][ne.y]=='#') continue;\n                    if(i==-1){ne.p--; ne.d = 3;}\n                    if(i==1){ne.q--; ne.d = 1;}\n                    if(ne.q>=0 && ne.p>=0 && !vis[ne.x][ne.y][ne.p][ne.q][ne.d]){\n                        vis[ne.x][ne.y][ne.p][ne.q][ne.d] = 1;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }else{\n            for(int j=-1;j<=0;j++){\n                for(int i=-1;i<=1;i++){\n                    if(now.x==sx && now.y==sy && i!=0) continue;\n                    if(j==-1 && F[now.x][now.y-1]=='#') continue;\n                    state ne = now;\n                    ne.x += i; ne.y += j;\n                    if(!ne.in() || F[ne.x][ne.y]=='#') continue;\n                    if(i==-1){ne.p--; ne.d = 2;}\n                    if(i==1){ne.q--; ne.d = 0;}\n                    if(ne.q>=0 && ne.p>=0 && !vis[ne.x][ne.y][ne.p][ne.q][ne.d]){\n                        vis[ne.x][ne.y][ne.p][ne.q][ne.d] = 1;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }\n    }\n    int inf = 1e9,ans = inf;\n    for(int i=0;i<=A;i++) for(int j=0;j<=A;j++) for(int k=0;k<4;k++){\n        if(vis[gx][gy][i][j][k]) ans = min(ans,2*A-i-j);\n    }\n    cout << (ans!=inf? ans:-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return a >= 0 && a < x;}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] == '.'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, A;\nchar S[200][200];\nll dp[100][100][4][11][11];\n\nconst ll INF = 1LL << 50;\nconst ll dy[4] = { -1, +0, +1, +0 };\nconst ll dx[4] = { +0, +1, +0, -1 };\n\nstruct state {\n  ll y, x, dir, p, q, dist;\n  bool operator<(const state &s) const {\n    return dist > s.dist;\n  }\n};\n\nint main(void) {\n  cin >> N >> M >> A;\n  REP(i, 0, N) REP(j, 0, M) cin >> S[i][j];\n\n  ll sy, sx, gy, gx;\n  REP(i, 0, N) REP(j, 0, M) {\n    if(S[i][j] == 'S') {\n      sy = i;\n      sx = j;\n    }\n    if(S[i][j] == 'G') {\n      gy = i;\n      gx = j;\n    }\n  }\n\n  REP(y, 0, N) REP(x, 0, M) REP(dir, 0, 4) REP(p, 0, A + 1) REP(q, 0, A + 1) dp[y][x][dir][p][q] = INF;\n\n  priority_queue<state> que;\n  que.push((state) { sy, sx, 2, 0, 0, 0 });\n\n  while(!que.empty()) {\n    state s = que.top();\n    que.pop();\n\n    ll y = s.y, x = s.x, dir = s.dir, p = s.p, q = s.q, dist = s.dist;\n\n    if(dp[y][x][dir][p][q] <= dist) break;\n    dp[y][x][dir][p][q] = dist;\n\n    if(y == gy && x == gx) {\n      cout << dist << endl;\n      return 0;\n    }\n\n    REP(k, -1, 2) {\n      ll ndir = (dir + k + 4) % 4;\n      ll ny = y + dy[ndir];\n      ll nx = x + dx[ndir];\n      ll np = p;\n      ll nq = q;\n      if(dir % 2 == 0) {\n        np += (k == -1 ? 1 : 0);\n        nq += (k == +1 ? 1 : 0);\n      } else {\n        np += (k == +1 ? 1 : 0);\n        nq += (k == -1 ? 1 : 0);\n      }\n      if(0 <= ny && ny < N && 0 <= nx && nx < M && (S[ny][nx] == '.' || S[ny][nx] == 'G') && np <= A && nq <= A) {\n        que.push((state) { ny, nx, ndir, np, nq, np + nq });\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 101;\nconst int MAXW = 101;\nconst int MAXA = 11;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int P[] = {1,0,3,2};\nconst int Q[] = {3,2,1,0};\nint H, W, A;\nchar G[MAXH][MAXW];\nint vis[MAXH][MAXW][4][MAXA][MAXA];\n\nstruct State {\n  int i, j, d, a, b;\n};\n\nint dijkstra(int si, int sj, int gi, int gj) {\n  queue<State> que;\n  memset(vis, 0, sizeof(vis));\n  vis[si][sj][1][A][A] = true;\n  que.push((State){si, sj, 1,A, A});\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    do {\n      State t = s;\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#') break;\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(t.i == si && t.j == sj) break;\n      t.d = P[t.d];\n      if(--t.a < 0) break;\n\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#') break;\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(t.i == si && t.j == sj) break;\n      t.d = Q[t.d]; \n      if(--t.b < 0) break;\n\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#') break;\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n  }\n  int res = INF;\n  for(int a = 0; a <= A; ++a) {\n    for(int b = 0; b <= A; ++b) {\n      for(int k = 0; k < 4; ++k) {\n        if(vis[gi][gj][k][a][b]) {\n          res = min(res, A*2 - (a+b));\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nint main() {\n  cin >> H >> W >> A;\n  int si, sj, gi, gj;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n      if(G[i][j] == 'S') {\n        si = i; sj = j;\n      }\n      if(G[i][j] == 'G') {\n        gi = i; gj = j;\n      }\n    }\n  }\n  cout << dijkstra(si, sj, gi, gj) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int inf = 1e9;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint mincost[101][101][4][11][11];\nvoid initcost(){\n    REP(y,101) REP(x,101) REP(d,4) REP(p,11) REP(q,11){\n        mincost[y][x][d][p][q] = inf;\n    }\n}\n\n\nstruct info{\n    int y,x,d,p,q,c;\n    info(int y, int x, int d, int p, int q, int c)\n        :y(y),x(x),d(d),p(p),q(q),c(c){}\n    info(){}\n    bool operator<(const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int h,w,a;\n    cin >> h >> w >> a;\n    vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n    int sy,sx, gy,gx;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> field[i][j];\n            if(field[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(field[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    \n    priority_queue<info> wait;\n    if(field[sy+1][sx]!='#'){\n        wait.push(info(sy+1, sx, 1, a, a, 0));\n    }\n    initcost();\n\n    while(!wait.empty()){\n        info top = wait.top();\n        int y = top.y;\n        int x = top.x;\n        int d = top.d;\n        int p = top.p;\n        int q = top.q;\n        int c = top.c;\n        wait.pop();\n        if(field[y][x]=='G') continue;\n        if(c > mincost[y][x][d][p][q]) continue;\n\n        for(int i=0; i<4; i++){\n            int ny = y+dy[i];\n            int nx = x+dx[i];\n            int np = p;\n            int nq = q;\n            if(field[ny][nx] == '#' || field[ny][nx] == 'S') continue;\n            if((i+2)%4 == d) continue;\n            if((d+i)%4 == 1) np--;\n            if((d+i)%4 == 3) nq--;\n            if(np<0 || nq<0) continue;\n            if(c+1 < mincost[ny][nx][i][np][nq]){\n                wait.push(info(ny, nx, i, np, nq, c+1));\n                mincost[ny][nx][i][np][nq] = c+1;\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int d=0; d<4; d++){\n        for(int p=0; p<=10; p++){\n            for(int q=0; q<=10; q++){\n                if(mincost[gy][gx][d][p][q] != inf){\n                    ans = min(ans, a-p +a-q);\n                }\n            }\n        }\n    }\n    if(ans == inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e9;\n\nbool in_range(int a, int x){ return a >= 0 && a < x;}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy, gx, gy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n      if(G[i][j] == 'G'){\n        gx = i;\n        gy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i,j,0,0,0);\n      v[s].pb(f(i+1,j,0,0,0));\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  rep(i,n)rep(j,m-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i][j+1]=='.' || vec[i][j+1]=='G') ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i+1][j]=='.' || vec[i+1][j]=='G') ){\n      rep(x,a+1)rep(y,a+1) for(int d=0;d<3;d+=2){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        v[p].pb(f(i,j,x+1,y,1));\n        v[p+1].pb(f(i,j,x+1,y,0));\n        v[p+2].pb(f(i,j,x+1,y,3));\n        v[p+3].pb(f(i,j,x+1,y,2));\n      }\n      if(y<a){\n        v[p].pb(f(i,j,x,y+1,3));\n        v[p+1].pb(f(i,j,x,y+1,2));\n        v[p+2].pb(f(i,j,x,y+1,1));\n        v[p+3].pb(f(i,j,x,y+1,0));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res>2*a) cout << -1 << endl;\n  else cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count;\n  map<int,bool> P_mirror;//2->3, 3->2, 1->0, 0->1\n  map<int,bool> Q_mirror;//2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d,\n\tmap<int,bool>& _P_mirror,map<int,bool>& _Q_mirror) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {\n    P_mirror = _P_mirror;\n    Q_mirror = _Q_mirror;\n  }\n\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) { }\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nbool check(int x,int y,int gx,int gy,int dir,\n\t   map<int,bool>& P_mirror,map<int,bool>& Q_mirror,\n\t   char stage[100][100],int W,int H){\n  if(x == gx && y == gy) return true;\n\n  bool res = false;\n  int dx = x + tx[dir];\n  int dy = y + ty[dir];\n  if(dx < 0 || dy < 0 || dx >= W || dy >= H) return false;\n  if(stage[dy][dx] == '#') return false;\n\n  map<int,bool>::iterator it;\n  int next_dir = dir;\n  if((it = P_mirror.find(dy*W+dx)) != P_mirror.end()){\n    if(dir == 0) next_dir = 3;\n    if(dir == 1) next_dir = 2;\n    if(dir == 2) next_dir = 1;\n    if(dir == 3) next_dir = 0;\n  }\n\n  if((it = Q_mirror.find(dy*W+dx)) != Q_mirror.end()){\n    if(dir == 0) next_dir = 1;\n    if(dir == 1) next_dir = 0;\n    if(dir == 2) next_dir = 3;\n    if(dir == 3) next_dir = 2;\n  }\n\n  res |= check(dx,dy,gx,gy,next_dir,P_mirror,Q_mirror,stage,W,H);\n     \n  return res;\n}\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,4));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100][10];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.x][s.y][s.prev_dir]) continue;\n      dp[s.x][s.y][s.prev_dir] = true;\n\n      // printf(\"x:%d y:%d prev:%d\\n\",s.x,s.y,s.prev_dir);\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\tif(!check(s.x,s.y,sx,sy,s.prev_dir,\n\t\t  s.P_mirror,s.Q_mirror,stage,W,H)) continue;\n\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(s.prev_dir == 4 && i != 2) continue;\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\tif(stage[s.y][s.x] == 'S'){\n\t  if(s.prev_dir != 4 && s.prev_dir != i){\n\t    continue;\n\t  }\n\t}\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\n\tmap<int,bool> P_mirror = s.P_mirror;\n\tmap<int,bool> Q_mirror = s.Q_mirror;\n\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t  P_mirror[dy*W+dx];\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t  Q_mirror[dy*W+dx];\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tif(s.prev_dir == (i + 2) % 4) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i,P_mirror,Q_mirror));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\npii f(pii a, pii b, int x1, int x2){\n    b.first+=x1;\n    b.second+=x2;\n    \n    if(a.first>=b.first && a.second>=b.second)return b;\n    if(a.first<=b.first && a.second<=b.second)return a;\n    abort();\n}\n\nstruct state{\n    int y,x,dir,bs,s;\n};\n\nint main(){\n    int h,w,a;\n    cin>>h>>w>>a;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    pii s,g;\n    rep(i,h)rep(j,w){\n        if(vs[i][j]=='S')s = pii(i,j);\n        if(vs[i][j]=='G')g = pii(i,j);\n    }\n    \n    static int dp[101][101][4][11][11];\n    rep(i,101)rep(j,101)rep(k,4)rep(l,11)rep(m,11)dp[i][j][k][l][m] = INF;\n    rep(i,4) dp[s.first][s.second][i][0][0] = 0;\n    \n    queue<state> que;\n    rep(i,4) que.push(state{s.first, s.second, (int)i, 0, 0});\n    \n    // '\\', '/'\n    //テ、ツクツ? テ・ツ渉ウ, テ、ツクツ? テ・ツキツヲ\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    while(que.size()){\n        state q = que.front();\n        que.pop();\n        \n        for(int k = 1;;k++){\n            int ddy = q.y+dy[q.dir]*k;\n            int ddx = q.x+dx[q.dir]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            int bsnum,snum;\n            \n            //テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==0)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+3)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n            \n            //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==1)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+1)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    rep(i,4){\n        for(int k=1;;k++){\n            int y,x;\n            tie(y,x) = g;\n            int ddy = y+dy[i]*k;\n            int ddx = x+dx[i]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            rep(l,a+1){\n                rep(m,a+1){\n                    ans = min(ans, dp[ddy][ddx][(i+2)%4][l][m]);\n                }\n            }\n        }\n    }\n    if(ans>2*a)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tpriority_queue<T, vector<T>, greater<T>> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)] == '#') return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(0, get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint c, y, x, p, q, d;\n\t\ttie(c,y,x,p,q,d) = que.top(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\tif(y == get<0>(g) and x == get<1>(g)) break;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\tint nc = c;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(nc,ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n \nusing namespace std;\n \n#define MAX_H 100\n#define MAX_W 100\n#define MAX_A 10\n \nstruct State{\n    int m,x,y,p,q,d;\n    State(int m,int x,int y,int p,int q,int d) :\n\tm(m),x(x),y(y),p(p),q(q),d(d) {}\n};\n \nint H,W,A;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nbool visited[MAX_H][MAX_W][MAX_A][MAX_A][4];\n \ninline bool canMove(int x,int y,int d){\n    if(0 <= x && x < W && 0 <= y && y < H){\n\tif(field[y][x] == 'S' && d == 1){\n\t    return false;\n\t}else if(field[y][x] != '#'){\n\t    return true;\n\t}\n    }\n    return false;\n}\n \nint bfs(int sx,int sy,int gx,int gy){\n    deque<State> Q;\n    Q.push_back(State(0,sx,sy,A,A,3));\n    visited[sy][sx][A][A][3] = true;\n   \n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop_front();\n\tint x = s.x, y = s.y;\n\tif(x == gx && y == gy) return s.m;\n\tint nx = x+dx[s.d], ny = y+dy[s.d];\n\tif(canMove(nx,ny,s.d) && !visited[ny][nx][s.p][s.q][s.d]){\n\t    visited[ny][nx][s.p][s.q][s.d] = true;\n\t    Q.push_front(State(s.m,nx,ny,s.p,s.q,s.d));\n\t}\n\tif(s.p > 0 && field[y][x] == '.'){\n\t    int ndir = (s.d & 1 ? s.d+3 : s.d+1)%4;\n\t    if(!visited[y][x][s.p-1][s.q][ndir]){\n\t\tvisited[y][x][s.p-1][s.q][ndir] = true;\n\t\tQ.push_back(State(s.m+1,x,y,s.p-1,s.q,ndir));\n\t    }\n\t}\n\tif(s.q > 0 && field[y][x] == '.'){\n\t    int ndir = (s.d & 1 ? s.d+1 : s.d+3)%4;\n\t    if(!visited[y][x][s.p][s.q-1][ndir]){\n\t\tvisited[y][x][s.p][s.q-1][ndir] = true;\n\t\tQ.push_back(State(s.m+1,x,y,s.p,s.q-1,ndir));\n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    int sx,sy,gx,gy;\n    cin >> H >> W >> A;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> field[i][j];\n\t    if(field[i][j] == 'S'){\n\t\tsx = j; sy = i;\n\t    }else if(field[i][j] == 'G'){\n\t\tgx = j; gy = i;\n\t    }\n\t}\n    }\n    cout << bfs(sx,sy,gx,gy) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#'){\n    char c = G[x][y];\n    if(G[x][y] != 'S') G[x][y] = '#';\n    val = min(val, dfs(x_, y_, d, p, q));\n    G[x][y] = c;\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<deque>\n\nusing namespace std;\n\nstruct S{\n  int y,x,d,p,q;\n};\n\nint main(){\n  int N,M,A;\n  cin>>N>>M>>A;\n  char g[100][100];\n  S is={0,0,2,0,0};\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      cin>>g[i][j];\n      if(g[i][j]=='S'){\n\tis.y=i;\n\tis.x=j;\n      }\n    }\n  }\n  static bool p[100][100][4][11][11];\n  deque<S> deq(1,is);\n  while(!deq.empty()){\n    S c=deq.front();\n    if(g[c.y][c.x]=='G')break;\n    deq.pop_front();\n    if(p[c.y][c.x][c.d][c.p][c.q]++)continue;\n    for(int i=0;i<3;i++){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      S n=c;\n      n.y+=dy[n.d];\n      n.x+=dx[n.d];\n      if(i==1){\n\tn.d^=1;\n\tn.p++;\n      }else if(i==2){\n\tn.d=3-n.d;\n\tn.q++;\n      }\n      if(0<=n.y&&n.y<N&&0<=n.x&&n.x<M&&n.p<=A&&n.q<=A&&g[c.y][c.x]!='#'&&!(g[c.y][c.x]=='S'&&n.d==0)){\n\tif(i==0){\n\t  deq.push_front(n);\n\t}else{\n\t  deq.push_back(n);\n\t}\n      }\n    }\n  }\n  cout<<(deq.empty()?-1:deq.front().p+deq.front().q)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w,m;cin>>h>>w>>m;){\n\t\tvector<string> grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tstatic int vis[100][100][4][11][11];\n\t\tmemset(vis,0,sizeof(vis));\n\t\t\n\t\tqueue<tuple<int,int,int,int,int>> q; // (i,j,dir,used p,used q)\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\trep(k,4) q.emplace(i,j,k,0,0);\n\t\t\n\t\twhile(q.size()){\n\t\t\tint ci,cj,cd,cp,cq; tie(ci,cj,cd,cp,cq)=q.front(); q.pop();\n\t\t\tif(ci<0 || h<=ci || cj<0 || w<=cj ||\n\t\t\t   grid[ci][cj]=='#' || cp>m || cq>m || vis[ci][cj][cd][cp][cq])\n\t\t\t\tcontinue;\n\t\t\tvis[ci][cj][cd][cp][cq]=1;\n\t\t\t\n\t\t\tconst int di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\t\tq.emplace(ci+di[cd],cj+dj[cd],cd,cp,cq);\n\t\t\tq.emplace(ci,cj,3-cd,cp+1,cq);\n\t\t\tq.emplace(ci,cj,(cd+2)%4,cp,cq+1);\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='G')\n\t\t\trep(d,4) rep(p,m+1) rep(q,m+1) if(vis[i][j][d][p][q])\n\t\t\t\tres=min(res,p+q);\n\t\tcout<<(res<INF?res:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int inf = 1e9;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint mincost[101][101][4][11][11];\nvoid initcost(){\n    REP(y,101) REP(x,101) REP(d,4) REP(p,11) REP(q,11){\n        mincost[y][x][d][p][q] = inf;\n    }\n}\n\n\nstruct info{\n    int y,x,d,p,q,c;\n    info(int y, int x, int d, int p, int q, int c)\n        :y(y),x(x),d(d),p(p),q(q),c(c){}\n    info(){}\n    bool operator<(const info &a) const{\n        return c > a.c;\n    }\n};\n\nint main(){\n    int h,w,a;\n    cin >> h >> w >> a;\n    vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n    int sy,sx, gy,gx;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> field[i][j];\n            if(field[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(field[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    \n    priority_queue<info> wait;\n    if(field[sy+1][sx]!='#'){\n        wait.push(info(sy+1, sx, 1, a, a, 0));\n    }\n    initcost();\n\n    while(!wait.empty()){\n        info top = wait.top();\n        int y = top.y;\n        int x = top.x;\n        int d = top.d;\n        int p = top.p;\n        int q = top.q;\n        int c = top.c;\n        wait.pop();\n        if(field[y][x]=='G') continue;\n        if(c > mincost[y][x][d][p][q]) continue;\n\n        for(int i=0; i<4; i++){\n            int ny = y+dy[i];\n            int nx = x+dx[i];\n            int np = p;\n            int nq = q;\n            if(field[ny][nx] == '#') continue;\n            if(field[ny][nx] == 'S' && i==3) continue;\n            if(field[y][x] == 'S' && (i!=d)) continue;\n            if((i+2)%4 == d) continue;\n            if((d+i)%4 == 1) np--;\n            if((d+i)%4 == 3) nq--;\n            if(np<0 || nq<0) continue;\n            if(c+1 < mincost[ny][nx][i][np][nq]){\n                wait.push(info(ny, nx, i, np, nq, c+1));\n                mincost[ny][nx][i][np][nq] = c+1;\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int d=0; d<4; d++){\n        for(int p=0; p<=10; p++){\n            for(int q=0; q<=10; q++){\n                if(mincost[gy][gx][d][p][q] != inf){\n                    ans = min(ans, a-p +a-q);\n                }\n            }\n        }\n    }\n    if(ans == inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint N,M,A;\nstring s[111];\nint used[111][111];\nint ans;\nint ax[]={0,1,0,-1};\nint ay[]={-1,0,1,0};\nbool in(int y,int x){\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\nint P(int d){\n  if(d&1) return (d+1)%4;\n  return (d+3)%4;\n}\nint Q(int d){\n  if(d&1) return (d+3)%4;\n  return (d+1)%4;\n}\nvoid dfs(int y,int x,int d,int p,int q){\n  //for(int i=0;i<N;i++) cout<<s[i]<<endl;cout<<endl;\n  if(s[y][x]=='S'){\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n    return;\n  }\n  if(s[y][x]=='#') return;\n  if(s[y][x]=='G'){\n    ans=min(ans,p+q);\n    return;\n  }\n  if(!used[y][x]&&p<A){\n    int nd=P(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p+1,q);\n      s[y][x]='.';\n    }\n  }\n  if(!used[y][x]&&q<A){\n    int nd=Q(d);\n    int ny=y+ay[nd],nx=x+ax[nd];\n    if(in(ny,nx)){\n      s[y][x]='#';\n      dfs(ny,nx,nd,p,q+1);\n      s[y][x]='.';\n    }\n  }\n  {\n    int ny=y+ay[d],nx=x+ax[d];\n    if(in(ny,nx)){\n      used[y][x]++;\n      dfs(ny,nx,d,p,q);\n      used[y][x]--;\n    }\n  }\n}\nsigned main(){\n  cin>>N>>M>>A;\n  for(int i=0;i<N;i++) cin>>s[i];\n  ans=A*2+1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      if(s[i][j]=='S')\n\t  dfs(i,j,2,0,0);\n  cout<<(ans>A*2?-1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstruct state{ int y,x,dir,bs,s; };\n\nint main(){\n    int h,w,a;\n    cin>>h>>w>>a;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    pii s,g;\n    rep(i,h)rep(j,w){\n        if(vs[i][j]=='S')s = pii(i,j);\n        if(vs[i][j]=='G')g = pii(i,j);\n    }\n    \n    static int dp[101][101][4][11][11];\n    rep(i,101)rep(j,101)rep(k,4)rep(l,11)rep(m,11)dp[i][j][k][l][m] = INF;\n    dp[s.first][s.second][0][0][0] = 0;\n    \n    queue<state> que;\n    que.push(state{s.first, s.second, 0, 0, 0});\n    \n    // '\\', '/'\n    //テ、ツクツ? テ・ツ渉ウ, テ、ツクツ? テ・ツキツヲ\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    while(que.size()){\n        state q = que.front();\n        que.pop();\n        \n        for(int k = 1;;k++){\n            int ddy = q.y+dy[q.dir]*k;\n            int ddx = q.x+dx[q.dir]*k;\n            \n            if( q.dir == 2 && pii(ddy,ddx)==s)break;\n            if(pii(ddy,ddx)==s)continue;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n            \n            int bsnum,snum;\n            \n            //テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==0)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+3)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+3)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n            \n            //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘・ツ崢榲ィツサツ「\n            if(q.dir%2==1)  bsnum = 0, snum = 1;\n            else            bsnum = 1, snum = 0;\n            if( q.bs+bsnum<=a && q.s+snum<=a ){\n                if( dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] == INF ){\n                    dp[ddy][ddx][(q.dir+1)%4][q.bs+bsnum][q.s+snum] = dp[q.y][q.x][q.dir][q.bs][q.s] + 1;\n                    que.push( state{ddy, ddx, (int)(q.dir+1)%4, q.bs+bsnum, q.s+snum} );\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    rep(i,4){\n        for(int k=1;;k++){\n            int ddy = g.first+dy[i]*k;\n            int ddx = g.second+dx[i]*k;\n            \n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)break;\n            if(vs[ddy][ddx]=='#')break;\n\n            if( i == 0 && pii(ddy,ddx)==s)break;\n\n            rep(l,a+1){\n                rep(m,a+1){\n                    ans = min(ans, dp[ddy][ddx][(i+2)%4][l][m]);\n                }\n            }\n        }\n    }\n    if(ans>2*a)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nint dx[] = { 0, 1, 0, -1 }; // NESW\nint dy[] = { -1, 0, 1, 0 };\n\nint P[] = { 3, 2, 1, 0 };\nint Q[] = { 1, 0, 3, 2 };\n\nconst int N = 110;\nint dist[N][N][4][12];\nint n, m, a;\nvector<string> board;\npriority_queue<tuple<int, int, int, int, int>> pq;\n\nvoid enq(int r, int c, int dir, int p, int q){\n\tif (p > a || q > a) return;\n\tr += dy[dir], c += dx[dir];\n\tif (r < 0 || r >= n || c < 0 || c >= m) return;\n\tif (board[r][c] == '#') return;\n\tif (board[r][c] == 'S') return;\n\tint d = p + q;\n\tif (dist[r][c][dir][p] <= d) return;\n\tdist[r][c][dir][p] = d;\n\tpq.emplace(-d, r, c, dir, p);\n};\n\n\nint main(){\n\tcin >> n >> m >> a;\n\n\tboard.resize(n);\n\trep(i, n) cin >> board[i];\n\n\tpair<int, int> start, goal;\n\trep(i, n) rep(j, m){\n\t\tif (board[i][j] == 'S') start = MP(i, j);\n\t\tif (board[i][j] == 'G') goal = MP(i, j);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tdist[start.first][start.second][2][0] = 0;\n\tpq.push(MT(0, start.first, start.second, 2, 0));\n\n\tint ans = -1;\n\twhile (!pq.empty()){\n\t\tauto state = pq.top();\n\t\tpq.pop();\n\t\tint d, r, c, dir, p, q;\n\t\ttie(d, r, c, dir, p) = state;\n\t\td = -d;\n\t\tq = d - p;\n\n\t\tif (dist[r][c][dir][p] < d) continue;\n\n\t\tif (MP(r, c) == goal){\n\t\t\tans = d;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (board[r][c] != 'S'){\n\t\t\tenq(r, c, P[dir], p + 1, q);\n\t\t\tenq(r, c, Q[dir], p, q + 1);\n\t\t}\n\t\tenq(r, c, dir, p, q);\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,X;\nint d[100][100][4][11][11];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ad[4]={1,0,3,2},bd[4]={3,2,1,0};\nint inf=100;\nstring s[100];\ndeque<int> qx,qy,qd,qa,qb;\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nvoid pushf(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_front(x);\n\tqy.push_front(y);\n\tqd.push_front(z);\n\tqa.push_front(a);\n\tqb.push_front(b);\n\td[x][y][z][a][b]=c;\n}\nvoid pushb(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_back(x);\n\tqy.push_back(y);\n\tqd.push_back(z);\n\tqa.push_back(a);\n\tqb.push_back(b);\n\td[x][y][z][a][b]=c;\n}\nint main(){\n\tcin>>H>>W>>X;\n\trep(i,H) rep(j,W) rep(k,4) rep(a,X+1) rep(b,X+1) d[i][j][k][a][b]=inf;\n\trep(i,H) cin>>s[i];\n\tint sx,sy;\n\trep(i,H) rep(j,W) if(s[i][j]=='S') sx=i,sy=j;\n\tpushb(sx,sy,0,X,X,0);\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front(),di=qd.front(),a=qa.front(),b=qb.front();\n\t\tqx.pop_front(),qy.pop_front(),qd.pop_front(),qa.pop_front(),qb.pop_front();\n\t\tif(x==sx&&y==sy&&di!=0) continue;\n\t\tint c=d[x][y][di][a][b];\n\t\tif(s[x][y]=='G'){\n\t\t\tcout<<c<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\tif(is(nx,ny)) pushf(nx,ny,di,a,b,c);\n\t\tif(a) pushb(x,y,ad[di],a-1,b,c+1);\n\t\tif(b) pushb(x,y,bd[di],a,b-1,c+1);\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint dp[111][111][4][11][11];\nint d=2,h,w,n,sx,sy,gx,gy,ans=-1;\nstring s[111];\nstruct T{\n    int y,x,d,l,r,cost;\n    T(int a,int b,int c,int f,int e,int w){y=a,x=b,d=c,l=f,r=e,cost=w;}\n};\nsigned main(){\n    cin>>h>>w>>n;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n        if(s[i][j]=='S')sy=i,sx=j;\n        if(s[i][j]=='G')gy=i,gx=j;\n    }\n    deque<T>q;\n    q.push_back(T(sy,sx,2,0,0,0));\n    dp[sy][sx][2][0][0]=1;\n    while(!q.empty()){\n        T a=q.front();q.pop_front();\n        d=a.d;\n        if(s[a.y][a.x]=='G'){ans=a.cost;break;}\n        if(d==0&&s[a.y][a.x]=='S')continue;\n        int y=a.y+dy[d];\n        int x=a.x+dx[d];\n        if(y<0||x<0||y>=h||x>=w)continue;\n        if(s[y][x]=='#')continue;\n        if(1){\n            q.push_front(T(y,x,d,a.l,a.r,a.cost));\n        }\n        if(a.l<n){\n            q.push_back(T(y,x,3-d,a.l+1,a.r,a.cost+1));\n        }\n        if(a.r<n){\n            q.push_back(T(y,x,d^1,a.l,a.r+1,a.cost+1));\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint d[5] = { 0, 1, 0, -1, 0 };\nint dist[100][100][4][11];\n \nint main() {\n    int n, m, a;\n    cin >> n >> m >> a;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i)\n        cin >> s[i];\n\n    int si, sj, gi, gj;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n            if (s[i][j] == 'G') {\n                gi = i;\n                gj = j;\n            }\n            for (int k = 0; k < 4; ++k)\n                for (int l = 0; l <= a; ++l)\n                    dist[i][j][k][l] = 80;\n        }\n    }\n    deque<int> qi, qj, qd, qm;\n    dist[si][sj][1][0] = 0;\n    qi.push_back(si);\n    qj.push_back(sj);\n    qd.push_back(1);\n    qm.push_back(0);\n    while (!qi.empty()) {\n        int pi = qi.front();\n        int pj = qj.front();\n        int pd = qd.front();\n        int pm = qm.front();\n        qi.pop_front();\n        qj.pop_front();\n        qd.pop_front();\n        qm.pop_front();\n        if (pi == si && pj == sj && pd == 3) continue;\n        int dis = dist[pi][pj][pd][pm];\n        {\n            int ti = pi + d[pd], tj = pj + d[pd + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dist[ti][tj][pd][pm] > dis) {\n                dist[ti][tj][pd][pm] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(pd);\n                qm.push_front(pm);\n            }\n        }\n        if (pi == si && pj == sj || pi == gi && pj == gj) continue;\n \n        {\n            int td = pd ^ 1;\n            int ti = pi + d[td], tj = pj + d[td + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && pm < a && dist[ti][tj][td][pm + 1] > dis) {\n                dist[ti][tj][td][pm + 1] = dis;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(td);\n                qm.push_front(pm + 1);\n            }\n        }\n        {\n            int td = pd ^ 3;\n            int ti = pi + d[td], tj = pj + d[td + 1];\n            if (ti >= 0 && ti < n && tj >= 0 && tj < m && s[ti][tj] != '#' && dis < a && dist[ti][tj][td][pm] > dis + 1) {\n                dist[ti][tj][td][pm] = dis + 1;\n                qi.push_front(ti);\n                qj.push_front(tj);\n                qd.push_front(td);\n                qm.push_front(pm);\n            }\n        }\n    }\n    int ans = 50;\n    for (int i = 0; i < 4; ++i)\n        for (int j = 0; j <= a; ++j)\n            ans = min(ans, dist[gi][gj][i][j] + j);\n\n    cout << (ans < 50 ? ans : -1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  // pos[i][j], left a[x][y], direction d\n  auto f = [&](int i, int j, int x, int y, int d){\n    return (((i*m+j)*(a+1)+x)*(a+1)+y)*4+d;\n  };\n\n  vector<vector<int>> v(n*m*(a+1)*(a+1)*4,vector<int>());\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S'){\n      if(i+1==n || vec[i+1][j]=='#'){\n        cout << -1 << endl;\n        return 0;\n      }\n      s = f(i,j,0,0,0);\n      v[s].pb(f(i+1,j,0,0,0));\n    }\n    if(vec[i][j]=='G') t = f(i,j,0,0,0);\n  }\n\n  rep(i,n)rep(j,m-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i][j+1]=='.' || vec[i][j+1]=='G') ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,1)].pb(f(i,j+1,x,y,1));\n        v[f(i,j+1,x,y,3)].pb(f(i,j,x,y,3));\n      }\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i+1][j]=='.' || vec[i+1][j]=='G') ){\n      rep(x,a+1)rep(y,a+1){\n        v[f(i,j,x,y,0)].pb(f(i+1,j,x,y,0));\n        v[f(i+1,j,x,y,2)].pb(f(i,j,x,y,2));\n      }\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    rep(x,a+1)rep(y,a+1){\n      int p = f(i,j,x,y,0);\n      if(x<a){\n        v[p].pb(f(i,j,x+1,y,3));\n        v[p+1].pb(f(i,j,x+1,y,2));\n        v[p+2].pb(f(i,j,x+1,y,1));\n        v[p+3].pb(f(i,j,x+1,y,0));\n      }\n      if(y<a){\n        v[p].pb(f(i,j,x,y+1,1));\n        v[p+1].pb(f(i,j,x,y+1,0));\n        v[p+2].pb(f(i,j,x,y+1,3));\n        v[p+3].pb(f(i,j,x,y+1,2));\n      }\n    }\n  }\n\n  queue<int> q;\n  vector<bool> d(n*m*(a+1)*(a+1)*4, false);\n  d[s]=true;\n  q.push(s);\n  while(!q.empty()){\n    int x = q.front(); q.pop();//dbg(x/4/(a+1)/(a+1)/m, x/4/(a+1)/(a+1) % m, x%4);\n    for(auto to : v[x]){\n      if(d[to]) continue;\n      q.push(to);\n      d[to]=true;\n    }\n  }\n\n  int res = INF;\n  rep(i,a+1)rep(j,a+1)rep(k,4) if(d[t + i*(a+1)*4 + j*4 + k]) res = min(res, i+j);//dbg(res);\n  if(res<=2*a) cout << res << endl;\n  else cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n\nusing namespace std;\n\n#define MAX_H 100\n#define MAX_W 100\n#define MAX_A 10\n\nstruct State{\n  int m,x,y,p,q,d;\n  State(int m,int x,int y,int p,int q,int d) :\n    m(m),x(x),y(y),p(p),q(q),d(d) {}\n};\n\nint H,W,A;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nbool visited[MAX_H][MAX_W][MAX_A][MAX_A][4];\n\ninline bool canMove(int x,int y,int d){\n  if(0 <= x && x < W && 0 <= y && y < H){\n    if(field[y][x] == 'S' && d == 1){\n      return false;\n    }else if(field[y][x] != '#'){\n      return true;\n    }\n  }\n  return false;\n}\n\nint bfs(int sx,int sy,int gx,int gy){\n  deque<State> Q;\n  Q.push_back(State(0,sx,sy,A,A,3));\n  visited[sy][sx][A][A][3] = true;\n  \n  while(!Q.empty()){\n    State s = Q.front(); Q.pop_front();\n    int x = s.x, y = s.y;\n    if(x == gx && y == gy){ return s.m; }\n    int nx = x+dx[s.d], ny = y+dy[s.d];\n    if(canMove(nx,ny,s.d) && !visited[ny][nx][s.p][s.q][s.d]){\n      visited[ny][nx][s.p][s.q][s.d] = true;\n      Q.push_front(State(s.m,nx,ny,s.p,s.q,s.d));\n    }\n    if(s.p > 0 && field[y][x] == '.'){\n      int ndir = (s.d & 1 ? s.d+3 : s.d+1)%4;\n      if(!visited[y][x][s.p-1][s.q][ndir]){\n        visited[y][x][s.p-1][s.q][ndir] = true;\n        Q.push_back(State(s.m+1,x,y,s.p-1,s.q,ndir));\n      }\n    }\n    if(s.q > 0 && field[y][x] == '.'){\n      int ndir = (s.d & 1 ? s.d+1 : s.d+3)%4;\n      if(!visited[y][x][s.p][s.q-1][ndir]){\n        visited[y][x][s.p][s.q-1][ndir] = true;\n        Q.push_back(State(s.m+1,x,y,s.p,s.q-1,ndir));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  cin >> H >> W >> A;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){\n        sx = j; sy = i;\n      }else if(field[i][j] == 'G'){\n        gx = j; gy = i;\n      }\n    }\n  }\n  cout << bfs(sx,sy,gx,gy) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <tuple>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\n\nint dx[] = {0,-1,0,1};\nint dy[] = {-1,0,1,0};\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint H, W, A;\nint idx(int x, int y, int dir, int a1, int a2){\n  return (((y *W + x) * 4 + dir) * (A+1) + a1) * (A+1) + a2;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> A;\n  VS vs(H); REP(i,H) cin >> vs[i];\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(vs[y][x] == 'S') sy = y, sx = x;\n\telse if(vs[y][x] == 'G') gy = y, gx = x;\n\n  // (num,x,y,dir,a1,a2)\n  priority_queue<tuple<int,int,int,int,int,int>, vector<tuple<int,int,int,int,int,int> >, greater<tuple<int,int,int,int,int,int> > > pq;\n  VI dist(idx(W,H,3,A,A)+1, INF);\n  pq.push(make_tuple(0,sx,sy+1,2,0,0));\n    \n  while(!pq.empty()){\n\tint num, x, y, d, a1, a2;\n\ttie(num,x,y,d,a1,a2) = pq.top(); pq.pop();\n\tif(x == gx && y == gy) break;\n\tint fr = idx(x,y,d,a1,a2);\n\tif(dist[fr] < num) continue;\n\n\tif(vs[y][x] == '.'){\n\t  if(a1 < A){\n\t\tint td = 3 - d;\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (x == sx && y <= sy && d == 0))){\n\t\t  int toid = idx(tx,ty,td,a1+1,a2);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1+1,a2));\n\t\t  }\n\t\t}\n\t  }\n\t  if(a2 < A){\n\t\tint td = d-(d%2*2-1);\n\t\tint tx = x + dx[td], ty = y + dy[td];\n\t\tif(!(tx < 0 || W <= tx || ty < 0 || H <= ty || vs[ty][tx] == '#' || (x == sx && y <= sy && d == 0))){\n\t\t  int toid = idx(tx,ty,td,a1,a2+1);\n\t\t  if(dist[toid] > num+1){\n\t\t\tdist[toid] = num+1;\n\t\t\tpq.push(make_tuple(num+1,tx,ty,td,a1,a2+1));\n\t\t  }\n\t\t}\n\t  }\n\t}\n\t\n\tint tx = x + dx[d], ty = y + dy[d];\n\tif(tx < 0 || W <= tx || ty < 0 || H <= ty\n\t   || vs[ty][tx] == '#') continue;\n\tint toid = idx(tx,ty,d,a1,a2);\n\tif(dist[toid] > num){\n\t  dist[toid] = num;\n\t  pq.push(make_tuple(num,tx,ty,d,a1,a2));\n\t}\n  }\n\n  int ans = INF;\n  REP(d,4) REP(a1,A+1) REP(a2,A+1){\n\tint tid = idx(gx,gy,d,a1,a2);\n\tans = min(ans, dist[tid]);\n  }\n  \n  cout << (ans >= INF? -1: ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct State {\n  // d:??\\??£???????????????\n  int y, x, d, p, q, cost;\n  State(){}\n  State(int y, int x, int d, int p, int q, int cost):\n    y(y), x(x), d(d), p(p), q(q), cost(cost){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint N, M, A;\nchar mas[101][101];\nint sy, sx, gy, gx;\nint mincost[4][11][11][101][101];\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\n\nint dijkstra() {\n  rep(i, 4) rep(j, 11) rep(k, 11) {\n    rep(y, 101) rep(x, 101) mincost[i][j][k][y][x] = inf;\n  }\n  priority_queue<State> que;\n  que.push(State(sy, sx, 0, A, A, 0));\n  mincost[0][A][A][sy][sx] = 0;\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    //cout<<s.y<<\" \"<<s.x<<\" \"<<s.d<<\" \"<<s.cost<<endl;\n    if(s.y == gy && s.x == gx) return s.cost;\n    if(mincost[s.d][s.p][s.q][s.y][s.x] < s.cost) continue;\n    if(s.y == sy && s.x == sx) {\n      if(s.cost > 0 && (s.d == 0 || s.d == 2)) continue;\n      int ny = s.y+dy[(s.d+2)%4], nx = s.x+dx[(s.d+2)%4];\n      if(in(ny, nx) && mas[ny][nx] != '#') {\n\tif(s.cost < mincost[s.d][s.p][s.q][ny][nx]) {\n\t  que.push(State(ny, nx, s.d, s.p, s.q, s.cost));\n\t  mincost[s.d][s.p][s.q][ny][nx] = s.cost;\n\t}\n      }\n      continue;\n    }\n    rep(i, 4) {\n      if(s.d == i) continue;\n      int np = s.p, nq = s.q, ncost = s.cost;\n      if(s.d == 0) {\n\tif(i == 1) nq--, ncost++;\n\telse if(i == 3) np--, ncost++;\n      } else if(s.d == 1) {\n\tif(i == 0) nq--, ncost++;\n\telse if(i == 2) np--, ncost++;\n      } else if(s.d == 2) {\n\tif(i == 1) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      } else if(s.d == 3) {\n\tif(i == 0) np--, ncost++;\n\telse if(i == 2) nq--, ncost++;\n      }\n      if(np < 0 || nq < 0) continue;\n      int ny = s.y+dy[i], nx = s.x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#') continue;\n      if(ncost < mincost[(i+2)%4][np][nq][ny][nx]) {\n\t//cout<<s.y<<\" \"<<s.x<<\" \"<<s.d<<\" \"<<ny<<\" \"<<nx<<\" \"<<(i+2)%4<<\" \"<<ncost<<endl;\n\tque.push(State(ny, nx, (i+2)%4, np, nq, ncost));\n\tmincost[(i+2)%4][np][nq][ny][nx] = ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> A;\n  rep(i, N) rep(j, M) {\n    cin >> mas[i][j];\n    if(mas[i][j] == 'S') sy = i, sx = j;\n    else if(mas[i][j] == 'G') gy = i, gx = j;\n  }\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  que.emplace(si, sj, 0, 0, 0);\n  vis[si][sj][0][0][0] = true;\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (np > a || nq > a) continue;\n      int nd = dd[k][d];\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      if (t[ni][nj] == '#' || t[ni][nj] == 'S') continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nchar ba[100][100];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct P {\n  int y, x;\n  int d;\n  int a, b;\n  P(int y, int x, int d, int a, int b) : y(y),x(x),a(a),b(b),d(d) {}\n};\n\nbool ok[100][100][4][10][10];\n\nint main() {\n  int h, w, A;\n  while(cin>>h>>w>>A) {\n    int sx, sy;\n    int gx, gy;\n    REP(i,h) REP(j, w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == 'S') {\n        sy = i;\n        sx = j;\n      } else if (ba[i][j] == 'G') {\n        gy = i;\n        gx = j;\n      }\n    }\n    queue<P> Q;\n    memset(ok, 0, sizeof(ok));\n    Q.push(P(sy,sx,1,A, A));\n    bool hoge = 0;\n    while(!Q.empty()) {\n      P p = Q.front(); Q.pop();\n      if (ok[p.y][p.x][p.d][p.a][p.b]) continue;\n      ok[p.y][p.x][p.d][p.a][p.b] = 1;\n\n      //cout << p.x << \" \" << p.y << \" \" << p.d << \" \" << p.a << \" \" <<p.b << endl;\n      int yy = p.y + dy[p.d];\n      int xx = p.x + dx[p.d];\n      if (ba[p.y][p.x] == 'S' && p.d == 3) continue;\n      if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n        Q.push(P(yy,xx,p.d,p.a,p.b));\n\n      if (ba[p.y][p.x] == 'S') continue;\n      \n      if (p.a) {\n        int yy, xx;\n        int dd;\n        if (p.d % 2) {\n          dd = (p.d+3)%4;\n        } else {\n          dd = (p.d+1)%4;\n        }\n        yy = p.y + dy[dd];\n        xx = p.x + dx[dd];\n        if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n          Q.push(P(yy,xx,dd,p.a-1,p.b));\n      }\n      if (p.b) {\n        int yy, xx;\n        int dd;\n        if (p.d % 2) {\n          dd = (p.d+1)%4;\n        } else {\n          dd = (p.d+3)%4;\n        }\n        yy = p.y + dy[dd];\n        xx = p.x + dx[dd];\n        if (!(yy<0||yy>=h||xx<0||xx>=w || ba[yy][xx] == '#'))\n          Q.push(P(yy,xx,dd,p.a,p.b-1));\n      }\n    }\n    int ans = -1;\n    REP(i, 4) {\n      REP(j, A+1) {\n        REP(k, A+1) {\n          if (ok[gy][gx][i][j][k]) {\n            if (ans == -1) ans = A*2-(j+k);\n            else ans = min(ans, A*2-(j+k));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint h,w,A;\nstring mp[101];\nint dx[]={0,0,1,-1};//V^><\nint dy[]={1,-1,0,0};\n\nvoid pr(int x,int y,int dir){\n  char ch[]={'V','^','>','<'};\n  char tmp=mp[y][x];\n  mp[y][x]=ch[dir];\n  for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  mp[y][x]=tmp;\n  cout<<\"------\"<<endl;\n}\n\nint ans=1e9;//,used[101][101][10][10][4];\nint used[101][101][2];\nvoid dfs(int x,int y,int p,int q,int dir){\n  if(2*A-(p+q)>=ans)return;\n  //if(used[x][y][p][q][dir]++)return;\n  \n  vector<int> X,Y,ch;\n  while(1){\n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')break;\n    if(mp[y][x]=='S')continue;\n    if(mp[y][x]=='G')ans=min(ans,2*A-(p+q));\n    X.push_back(x);\n    Y.push_back(y);\n    ch.push_back(mp[y][x]);\n    mp[y][x]='#';\n    if(p){\n      if(dir==0)dfs(x,y,p-1,q,2); //>\n      if(dir==1)dfs(x,y,p-1,q,3); //<\n      if(dir==2)dfs(x,y,p-1,q,0); //V\n      if(dir==3)dfs(x,y,p-1,q,1); //^\n    }\n    if(q){\n      if(dir==0)dfs(x,y,p,q-1,3); //>\n      if(dir==1)dfs(x,y,p,q-1,2); //<\n      if(dir==2)dfs(x,y,p,q-1,1); //^\n      if(dir==3)dfs(x,y,p,q-1,0); //V\n    }\n  }\n  for(int i=0;i<X.size();i++)mp[Y[i]][X[i]]=ch[i];\n}\n\nint main(){\n  cin>>h>>w>>A;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='S')dfs(j,i,A,A,0);\n\n  cout<<(ans==1e9? -1:ans)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[110][110];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint bfs[110][110][11][11][4];\nstruct wolf{\n\tint r,c,a,b,d;\n\twolf(){}\n\twolf(int R,int C,int A,int B,int D){r=R;c=C;a=A;b=B;d=D;}\n};\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t}\n\tqueue<wolf>Q;\n\t//for(int i=0;i<4;i++){\n\t\tbfs[sr][sc][0][0][0]=1;\n\t\tQ.push(wolf(sr,sc,0,0,0));\n\t//}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=at.r+dx[at.d];\n\t\tint tc=at.c+dy[at.d];\n\t\tif(tr<0||tc<0||tr>=a||tc>=b||str[tr][tc]=='#')continue;\n\t\tif(!bfs[tr][tc][at.a][at.b][at.d]){\n\t\t\tbfs[tr][tc][at.a][at.b][at.d]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b,at.d));\n\t\t}\n\t\tif(at.a<c){\n\t\t\tint td=at.d^1;\n\t\t\tbfs[tr][tc][at.a+1][at.b][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a+1,at.b,td));\n\t\t}\n\t\tif(at.b<c){\n\t\t\tint td=at.d^2;\n\t\t\tbfs[tr][tc][at.a][at.b+1][td]=1;\n\t\t\tQ.push(wolf(tr,tc,at.a,at.b+1,td));\n\t\t}\n\t}\n\tint ret=999999;\n\tfor(int i=0;i<=c;i++)for(int j=0;j<=c;j++)for(int k=0;k<4;k++)\n\t\tif(bfs[gr][gc][i][j][k])ret=min(ret,i+j);\n\tif(ret<9999)printf(\"%d\\n\",ret);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count;\n  map<int,bool> P_mirror;//2->3, 3->2, 1->0, 0->1\n  map<int,bool> Q_mirror;//2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d,\n\tmap<int,bool>& _P_mirror,map<int,bool>& _Q_mirror) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {\n    P_mirror = _P_mirror;\n    Q_mirror = _Q_mirror;\n  }\n\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) { }\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nbool check(int x,int y,int gx,int gy,int dir,\n\t   map<int,bool>& P_mirror,map<int,bool>& Q_mirror,\n\t   char stage[100][100],int W,int H){\n  if(x == gx && y == gy) return true;\n\n  bool res = false;\n  int dx = x + tx[dir];\n  int dy = y + ty[dir];\n  if(dx < 0 || dy < 0 || dx >= W || dy >= H) return false;\n  if(stage[dy][dx] == '#') return false;\n\n  int next_dir = dir;\n  if(P_mirror.find(dy*W+dx) != P_mirror.end()){\n    if(dir == 0) next_dir = 3;\n    if(dir == 1) next_dir = 2;\n    if(dir == 2) next_dir = 1;\n    if(dir == 3) next_dir = 0;\n  }\n\n  if(Q_mirror.find(dy*W+dx) != Q_mirror.end()){\n    if(dir == 0) next_dir = 1;\n    if(dir == 1) next_dir = 0;\n    if(dir == 2) next_dir = 3;\n    if(dir == 3) next_dir = 2;\n  }\n\n  res |= check(dx,dy,gx,gy,next_dir,P_mirror,Q_mirror,stage,W,H);\n     \n  return res;\n}\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,4));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100][10];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.x][s.y][s.prev_dir]) continue;\n      dp[s.x][s.y][s.prev_dir] = true;\n\n      // printf(\"x:%d y:%d prev:%d\\n\",s.x,s.y,s.prev_dir);\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\tif(!check(s.x,s.y,sx,sy,(s.prev_dir+2) % 4,\n\t\t  s.P_mirror,s.Q_mirror,stage,W,H)) continue;\n\n\tuse_mirrors = s.P_reflect_count + s.Q_reflect_count;\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(s.prev_dir == 4 && i != 2) continue;\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\tif(stage[s.y][s.x] == 'S'){\n\t  if(s.prev_dir != 4 && s.prev_dir != i){\n\t    continue;\n\t  }\n\t}\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\n\tmap<int,bool> P_mirror = s.P_mirror;\n\tmap<int,bool> Q_mirror = s.Q_mirror;\n\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t  P_mirror[s.y*W+s.x] = true;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t  Q_mirror[s.y*W+s.x] = true;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tif(s.prev_dir == (i + 2) % 4) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i,P_mirror,Q_mirror));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Data{\n  int x,y,dir,P,Q,cost;\n  Data(int x=IINF,int y=IINF,int dir=IINF,int P=IINF,int Q=IINF,int cost=IINF):x(x),y(y),dir(dir),P(P),Q(Q),cost(cost){}\n  bool operator < (const Data& a)const{\n    return P+Q < a.P+a.Q;\n  }\n};\n\nint H,W,A,sp_x,sp_y;\nchar field[101][101];\nint mincost[101][101][11][11][4];\nint dx[] = {1,0,-1,0}; // 右、下、左、上\nint dy[] = {0,1,0,-1};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline int getType(int c_dir,int n_dir){\n  if( c_dir == 0 ){\n    if( n_dir == 3 ) return 0; // P -> 0, Q -> 1\n    if( n_dir == 1 ) return 1;\n  } else if( c_dir == 1 ){\n    if( n_dir == 2 ) return 0;\n    if( n_dir == 0 ) return 1;\n  } else if( c_dir == 2 ){\n    if( n_dir == 1 ) return 0;\n    if( n_dir == 3 ) return 1;\n  } else{\n    if( n_dir == 0 ) return 0;\n    if( n_dir == 2 ) return 1;\n  }\n  return -1;\n}\n\nint main(){\n  cin >> H >> W >> A;\n  rep(i,H)rep(j,W){\n    cin >> field[i][j];\n    if( field[i][j] == 'S' ) sp_x = j, sp_y = i;\n  }\n\n  rep(i,H)rep(j,W)rep(k,A+1)rep(l,A+1)rep(m,4)mincost[i][j][k][l][m] = IINF;\n  priority_queue<Data> Q;\n  if( isValid(sp_x+dx[1],sp_y+dy[1]) && field[sp_y+dy[1]][sp_x+dx[1]] != '#' ){\n    Q.push(Data(sp_x+dx[1],sp_y+dy[1],3,A,A,1));\n    mincost[sp_y][sp_x][A][A][3] = 1;\n  }\n  while(!Q.empty()){\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( field[y][x] == 'G' ){\n      cout << 2*A-(data.P+data.Q) << endl;\n      return 0;\n    }\n    rep(i,4){\n      if( i == data.dir ) continue;\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!isValid(nx,ny))continue;\n      if(field[ny][nx] == '#')continue;\n      int next_P = data.P, next_Q = data.Q;\n      int type = getType(data.dir,i);\n      if( type == 0 ) next_P--;\n      if( type == 1 ) next_Q--;\n      if( next_P < 0 || next_Q < 0) continue;\n      if(mincost[ny][nx][next_P][next_Q][i] > data.cost+1){\n\tmincost[ny][nx][next_P][next_Q][i] = data.cost+1;\n\tQ.push(Data(nx,ny,(i+2)%4,next_P,next_Q,data.cost+1));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int prev_dir;\n  int P_reflect_count; //2->1, 1->2, 0->3, 3->0\n  int Q_reflect_count; //2->3, 3->2, 1->0, 0->1\n  State() : x(0),y(0),P_reflect_count(0),Q_reflect_count(0),prev_dir(-1) {}\n  State(int _x,int _y,int _p,int _q,int _d) : x(_x),y(_y),P_reflect_count(_p),Q_reflect_count(_q),prev_dir(_d) {}\n  bool operator<(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    < (s.P_reflect_count + s.Q_reflect_count));\n  }\n  bool operator>(const State& s) const{\n    return ((P_reflect_count + Q_reflect_count)\n\t    > (s.P_reflect_count + s.Q_reflect_count));\n  }\n};\n\nint main(){\n  int H,W,A;\n  while(~scanf(\"%d %d %d\",&H,&W,&A)){\n    char stage[100][100];\n\n    int sx,sy;\n    int gx,gy;\n    for(int y=0;y<H;y++){\n      char line[101];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(line[x] == 'S'){\n\t  sx = x;\n\t  sy = y;\n\t}\n\tif(line[x] == 'G'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0,-1));\n\n    //P 2->1, 1->2, 0->3, 3->0\n    //Q 2->3, 3->2, 1->0, 0->1\n    int P_bit1=0; P_bit1 |= (1<<1); P_bit1 |= (1<<2);\n    int P_bit2=0; P_bit2 |= (1<<0); P_bit2 |= (1<<3);\n    int Q_bit1=0; Q_bit1 |= (1<<2); Q_bit1 |= (1<<3);\n    int Q_bit2=0; Q_bit2 |= (1<<0); Q_bit2 |= (1<<1);\n\n    bool dp[100][100];\n    memset(dp,false,sizeof(dp));\n    \n    int use_mirrors = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.x == gx && s.y == gy){\n\tif(s.P_reflect_count > A || s.Q_reflect_count > A) continue;\n\n\tuse_mirrors = min(s.P_reflect_count + s.Q_reflect_count,use_mirrors);\n\tbreak;\n      }\n\n      if(dp[s.x][s.y]) continue;\n      dp[s.x][s.y] = true;\n\n      for(int i=0;i<4;i++){\n\tint dx = s.x + tx[i];\n\tint dy = s.y + ty[i];\n\n\tif(dx < 0 || dy < 0 || dx >= W || dy >= H) continue;\n\tif(stage[dy][dx] == '#') continue;\n\n\t//P 2->1, 1->2, 0->3, 3->0\n\t//Q 2->3, 3->2, 1->0, 0->1\n\tint dir_history = 0;\n\tdir_history |= (1<<i);\n\tif(s.prev_dir != -1){\n\t  dir_history |= (1<<s.prev_dir);\n\t}\n\tint next_P = s.P_reflect_count;\n\tint next_Q = s.Q_reflect_count;\n\tif(P_bit1 == dir_history\n\t   || P_bit2 == dir_history){\n\t  next_P++;\n\t}\n\tif(Q_bit1 == dir_history\n\t   || Q_bit2 == dir_history){\n\t  next_Q++;\n\t}\n\tif(next_P > A || next_Q > A) continue;\n\tque.push(State(dx,dy,next_P,next_Q,i));\n      }\n    }\n    printf(\"%d\\n\",use_mirrors >= INF ? -1 : use_mirrors);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MAXH = 101;\nconst int MAXW = 101;\nconst int MAXA = 11;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int P[] = {1,0,3,2};\nconst int Q[] = {3,2,1,0};\nint H, W, A;\nchar G[MAXH][MAXW];\nint vis[MAXH][MAXW][4][MAXA][MAXA];\n\nstruct State {\n  int i, j, d, a, b;\n};\n \nint bfs(int si, int sj, int gi, int gj) {\n  queue<State> que;\n  memset(vis, 0, sizeof(vis));\n  vis[si][sj][1][A][A] = true;\n  que.push((State){si, sj, 1, A, A});\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    do {\n      State t = s;\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#' || (G[t.i][t.j] == 'S' && t.d == 3)) break;\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(G[t.i][t.j] == 'S') break;\n      t.d = P[t.d];\n      if(--t.a < 0) break;\n\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#' || (G[t.i][t.j] == 'S' && t.d == 3)) break;\n\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n    do {\n      State t = s;\n      if(G[t.i][t.j] == 'S') break;\n      t.d = Q[t.d]; \n      if(--t.b < 0) break;\n\n      t.i += di[t.d];\n      t.j += dj[t.d];\n      if(t.i < 0 || t.i >= H) break;\n      if(t.j < 0 || t.j >= W) break;\n      if(G[t.i][t.j] == '#' || (G[t.i][t.j] == 'S' && t.d == 3)) break;\n\n      if(vis[t.i][t.j][t.d][t.a][t.b]) break;\n      vis[t.i][t.j][t.d][t.a][t.b] = true;\n      que.push(t);\n    } while(0);\n  }\n  int res = INF;\n  for(int a = 0; a <= A; ++a) {\n    for(int b = 0; b <= A; ++b) {\n      for(int k = 0; k < 4; ++k) {\n        if(vis[gi][gj][k][a][b]) {\n          res = min(res, A*2 - (a+b));\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n \nint main() {\n  cin >> H >> W >> A;\n  int si, sj, gi, gj;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> G[i][j];\n      if(G[i][j] == 'S') {\n        si = i; sj = j;\n      }\n      if(G[i][j] == 'G') {\n        gi = i; gj = j;\n      }\n    }\n  }\n  cout << bfs(si, sj, gi, gj) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, N, M, P[] = {1, 0, 3, 2}, Q[] = {3, 2, 1, 0};\nint memo[100][100][10][10][4];\nstring G[100];\nconst int INF = 1e5;\n\nbool in_range(int a, int x){ return (a >= 0 && a < x);}\n\nint dfs(int x, int y, int d, int p, int q){\n  int &val = memo[x][y][p][q][d];\n  if(val >= 0) return val;\n  if(G[x][y] == 'G') return val = 0;\n  int x_ = x + dx[d], y_ = y + dy[d];\n  val = INF;\n  if(in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S'){\n    val = min(val, dfs(x_, y_, d, p, q));\n  }\n  x_ = x + dx[P[d]], y_ = y + dy[P[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && p){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, P[d], p-1, q) + 1);\n    G[x][y] = c;\n  }\n  x_ = x + dx[Q[d]], y_ = y + dy[Q[d]];\n  if(G[x][y] != 'S' && in_range(x_, N) && in_range(y_, M) && G[x_][y_] != '#' && G[x_][y_] != 'S' && q){\n    char c = G[x][y];\n    G[x][y] = '#';\n    val = min(val, dfs(x_, y_, Q[d], p, q-1) + 1);\n    G[x][y] = c;\n  }\n  // printf(\"dp[%d][%d][%d][%d][%d] = %d\\n\", x, y, p, q, d, memo[x][y][p][q][d]);\n  return val;\n}\n\nint main() {\n  int A;\n  scanf(\"%d %d %d\", &N, &M, &A);\n  int sx, sy;\n  for(int i = 0; i < N; ++i){\n    cin >> G[i];\n    for(int j = 0; j < M; ++j){\n      if(G[i][j] == 'S'){\n        sx = i;\n        sy = j;\n      }\n    }\n  }\n  fill(memo[0][0][0][0], memo[100][0][0][0], -1);\n  int ans = dfs(sx, sy, 0, A, A);\n  cout << (ans >= INF ? -1 : ans) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#define inf 1000000001\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,A,si,sj;\nchar map[100][100];\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n    \nclass State{\npublic:\n  int y,x,muki,numL,numR;\n  State(int y,int x,int muki,int l,int r):y(y),x(x),muki(muki),numL(l),numR(r){}\n};\n\nint main()\n{\n  int memo[100][100];\n  queue<State> Q;\n  cin>>H>>W>>A;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>map[i][j];\n      if(map[i][j]=='S'){\n\tsi=i;\n\tsj=j;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  Q.push(State(si,sj,2,0,0));\n  int ans=inf;\n  int a,b;\n  while(!Q.empty()){\n    State u=Q.front();\n    Q.pop();\n    //cout<<u.y<<\" \"<<u.x<<\" \"<<u.muki<<\" \"<<u.numL<<\" \"<<u.numR<<endl;\n    if(u.numL>A || u.numR>A)continue;\n    if(map[u.y][u.x]=='G'){\n      ans=min(ans,u.numL+u.numR);\n      continue;\n    }\n\n    a=u.y+Y[u.muki];\n    b=u.x+X[u.muki];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tQ.push(State(a,b,u.muki,u.numL,u.numR));\n      }\n    }\n    a=u.y+Y[(u.muki+1)%4];\n    b=u.x+X[(u.muki+1)%4];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(((u.muki+1)%4)%2==0)Q.push(State(a,b,(u.muki+1)%4,u.numL+1,u.numR));\n\tif(((u.muki+1)%4)%2==1)Q.push(State(a,b,(u.muki+1)%4,u.numL,u.numR+1));\n      }\n    }\n    a=u.y+Y[(u.muki+3)%4];\n    b=u.x+X[(u.muki+3)%4];\n    if(in(a,b)){\n      if(map[a][b]!='#'){\n\tif(((u.muki+3)%4)%2==0)Q.push(State(a,b,(u.muki+3)%4,u.numL,u.numR+1));\n\tif(((u.muki+3)%4)%2==1)Q.push(State(a,b,(u.muki+3)%4,u.numL+1,u.numR));\n      }\n    }\n  }\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool vis[100][100][4][11][11];\n\nint main() {\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> t(n);\n  REP(i,n)cin>>t[i];\n  int si,sj,gi,gj;\n  REP(i,n)REP(j,m) {\n    if (t[i][j] == 'S') {\n      si = i; sj = j;\n    } else if (t[i][j] == 'G') {\n      gi = i; gj = j;\n    }\n  }\n  REP(i,n)REP(j,m)REP(k,4)REP(l,a+1)REP(o,a+1) vis[i][j][k][l][o] = false;\n  using S = tuple<int,int,int,int,int>;\n  queue<S> que;\n  REP(i,4) {\n    que.emplace(si, sj, i, 0, 0);\n    vis[si][sj][i][0][0] = true;\n  }\n  int di[] = {1, 0, -1, 0};\n  int dj[] = {0, 1, 0, -1};\n  int dd[3][4] = {\n    {0, 1, 2, 3},\n    {1, 0, 3, 2},\n    {3, 2, 1, 0},\n  };\n  int dp[] = {0, 1, 0};\n  int dq[] = {0, 0, 1};\n  while(!que.empty()) {\n    int i,j,d,p,q;\n    tie(i,j,d,p,q) = que.front();\n    que.pop();\n    REP(k,3) {\n      int np = p + dp[k];\n      int nq = q + dq[k];\n      if (np > a || nq > a) continue;\n      int nd = dd[k][d];\n      int ni = i + di[nd];\n      int nj = j + dj[nd];\n      if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n      if (t[ni][nj] == '#') continue;\n      if (vis[ni][nj][nd][np][nq]) continue;\n      vis[ni][nj][nd][np][nq] = true;\n      que.emplace(ni,nj,nd,np,nq);\n    }\n  }\n  int mn = INF;\n  REP(i,4)REP(j,a+1)REP(k,a+1) if (vis[gi][gj][i][j][k]) mn = min(mn, j+k);\n  if (mn < INF) {\n    cout << mn << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\nint h, w, a;\nchar m[N][N];\nbool dis[N][N][15][15][4];\n\ntypedef tuple<int,int,int,int,int> T;\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, T p, T g){\n\tqueue<T> que;\n\tif(get<0>(p) + 1 > h or m[get<0>(p) + 1][get<1>(p)]) return INF;\n\n\tdis[get<0>(p) + 1][get<0>(p)][a][a][1] = 1;\n\tque.push(T(get<0>(p) + 1, get<1>(p), a, a, 1));\n\n\twhile(not que.empty()){\n\t\tint y, x, p, q, d;\n\t\ttie(y,x,p,q,d) = que.front(); que.pop();\n\t\tdis[y][x][p][q][d] = 1;\n\t\trep(i,4){\n\t\t\tif((d + 2) % 4 == i) continue;\n\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tint np = p, nq = q;\n\t\t\t\n\t\t\tif(d == 0 || d == 2){\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif((d + 1) % 4 == i){\n\t\t\t\t\tnq = q - 1;\n\t\t\t\t}else if((d - 1 + 4) % 4 == i){\n\t\t\t\t\tnp = p - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(np < 0 || nq < 0) continue;\n\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t//cout << ny << ' ' << nx << ' ' << np << ' ' << nq << endl;\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\tif(not dis[ny][nx][np][nq][i] && m[ny][nx] != '#' &&\n\t\t\t\t\tnot (m[y][x] == 'S' && d != i) &&\n\t\t\t\t\tnot (m[ny][nx] == 'S' && i == 3)){\n\t\t\t\t//cout << next.x << ' ' << next.y << ' ' << next.p << ' ' << next.q << ' ' << next.d << endl;\n\t\t\t\tque.emplace(ny,nx,np,nq,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\trep(i,a + 1){\n\t\trep(j,a + 1){\n\t\t\trep(k,4){\n\t\t\t\tif(dis[get<0>(g)][get<1>(g)][i][j][k] == false) continue;\n\t\t\t\tans = min(ans, a - i + a - j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> h >> w >> a;\n\n\tT s, g;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == 'S') s = T{i,j,0,0,0};\n\t\tif(m[i][j] == 'G') g = T{i,j,0,0,0};\n\t}\n\n\tint ans = bfs(h, w, s, g);\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m,a;\n  cin>>n>>m>>a;\n  vector<string> vec(n);\n  rep(i,n) cin>>vec[i];\n\n  int s,t;\n  rep(i,n)rep(j,m){\n    if(vec[i][j]=='S') s = i*m+j;\n    if(vec[i][j]=='G') t = i*m+j;\n  }\n  s=s*2+1;\n  t=t*2;\n\n  vector<vector<pair<int,int>>> v(n*n*2,vector<pair<int,int>>());\n  // (i*m+j)*2+b : [i][j][b] b=0 --- , b=1 | | |\n\n  rep(i,n)rep(j,m-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='G') && (vec[i][j+1]=='.' || vec[i][j+1]=='G') ){\n      int p = (i*m+j)*2, q = (i*m+j+1)*2;\n      v[p].pb(mp(q,0));\n      v[q].pb(mp(p,0));\n    }\n  }\n\n  rep(j,m)rep(i,n-1){\n    if( (vec[i][j]=='.' || vec[i][j]=='S' || vec[i][j]=='G') && (vec[i+1][j]=='.' || vec[i+1][j]=='G') ){\n      int p = (i*m+j)*2+1, q = ((i+1)*m+j)*2+1;\n      v[p].pb(mp(q,0));\n      v[q].pb(mp(p,0));\n    }\n  }\n\n  rep(i,n)rep(j,m) if(vec[i][j]=='.'){\n    int x = (i*m+j)*2;\n    v[x].pb(mp(x+1,1));\n    v[x+1].pb(mp(x,1));\n  }\n\n  deque<int> dq;\n  vector<int> d(n*m*2, INF);\n  d[s]=0;\n  dq.pb(s);\n  while(!dq.empty()){\n    int x = dq.front(); dq.pop_front();\n    for(auto p : v[x]){\n      if(d[p.fi] <= d[x]+p.se) continue;\n      if(p.se==0){\n        dq.push_front(p.fi);\n        d[p.fi] = d[x];\n      } else {\n        dq.pb(p.fi);\n        d[p.fi] = d[x]+1;\n      }\n    }\n  }\n\n  int res = min(d[t], d[t+1]);//dbg(res);\n  if(res>2*a) cout << -1 << endl;\n  else cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\nint memo[102][102][4][11][11];\nint field[102][102];\nint A;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstruct aa {\n\tint y;\n\tint x;\n\tint way;\n\tint p;\n\tint q;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn 2*A-(l.p+l.q)> 2 * A - (r.p+r.q);\n\t}\n};\n\n\n\nint pc(const int way) {\n\tif (way == 0) {\n\t\treturn 3;\n\t}\n\telse if (way == 1) {\n\t\treturn 2;\n\t}\n\telse if (way == 2) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\nint qc(const int way) {\n\tif (way == 0) {\n\t\treturn 1;\n\t}\n\telse if (way == 1) {\n\t\treturn 0;\n\t}\n\telse if (way == 2) {\n\t\treturn 3;\n\t}\n\telse {\n\t\treturn 2;\n\t}\n}\nint main() {\n\tmemset(memo, -1, sizeof(memo));\n\tint N, M; cin >> N >> M >> A;\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[0][j] = 0;\n\t}\n\tint sx, sy;\n\tint gx, gy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfield[i][0] = 0;\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (st[j] == 'S') {\n\t\t\t\tsx = j + 1;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'G') {\n\t\t\t\tgx = j + 1;\n\t\t\t\tgy = i;\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\tfield[i][j + 1] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfield[i][M+1] = 0;\n\t}\n\tfor (int j = 0; j < M + 2; ++j) {\n\t\tfield[N+1][j] = 0;\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sy,sx,1,A,A });\n\tmemo[sy][sx][1][A][A] = 1;\n\t\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = A - atop.p + A - atop.q;\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tconst int nway = atop.way;\n\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q]<0) {\n\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q] = 1;\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tif (atop.y + dy[nway] == sy&&atop.x + dx[nway] == sx) {\n\t\t\t\t\t\tif (nway == 1 || nway == 3) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (atop.x == sx&&atop.y == sy)continue;\n\t\t{\n\t\t\tif (atop.p) {\n\t\t\t\tconst int nway = pc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p - 1][atop.q] = 1;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tif (atop.y + dy[nway] == sy&&atop.x + dx[nway] == sx) {\n\t\t\t\t\t\t\tif (nway == 1 || nway == 3) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (atop.q) {\n\t\t\t\tconst int nway = qc(atop.way);\n\t\t\t\tif (field[atop.y + dy[nway]][atop.x + dx[nway]]) {\n\t\t\t\t\tif (memo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] < 0) {\n\t\t\t\t\t\tmemo[atop.y + dy[nway]][atop.x + dx[nway]][nway][atop.p][atop.q - 1] = 1;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tif (atop.y + dy[nway] == sy&&atop.x + dx[nway] == sx) {\n\t\t\t\t\t\t\tif (nway == 1 || nway == 3) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tque.push(aa{ atop.y + dy[nway], atop.x + dx[nway], nway, atop.p, atop.q });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct State {\n  // d:??\\??£???????????????\n  int y, x, d, p, q, cost;\n  State(){}\n  State(int y, int x, int d, int p, int q, int cost):\n    y(y), x(x), d(d), p(p), q(q), cost(cost){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint N, M, A;\nchar mas[101][101];\nint sy, sx, gy, gx;\nint mincost[4][11][11][101][101];\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<N&&0<=x&&x<M;\n}\n\nint dijkstra() {\n  rep(i, 4) rep(j, 11) rep(k, 11) {\n    rep(y, 101) rep(x, 101) mincost[i][j][k][y][x] = inf;\n  }\n  priority_queue<State> que;\n  int ny = sy+dy[3], nx = sx+dx[2];\n  if(in(ny, nx) && mas[ny][nx] != '#') {\n    que.push(State(ny, nx, 0, A, A, 0));\n    mincost[0][A][A][sy][sx] = 0;\n  }\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(s.y == gy && s.x == gx) return s.cost;\n    if(mincost[s.d][s.p][s.q][s.y][s.x] < s.cost) continue;\n    rep(i, 4) {\n      if(s.d == i) continue;\n      int np = s.p, nq = s.q, ncost = s.cost;\n      if(s.d == 0) {\n\tif(i == 1) nq--, ncost++;\n\telse if(i == 3) np--, ncost++;\n      } else if(s.d == 1) {\n\tif(i == 0) nq--, ncost++;\n\telse if(i == 2) np--, ncost++;\n      } else if(s.d == 2) {\n\tif(i == 1) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      } else if(s.d == 3) {\n\tif(i == 0) np--, ncost++;\n\telse if(i == 3) nq--, ncost++;\n      }\n      if(np < 0 || nq < 0) continue;\n      int ny = s.y+dy[i], nx = s.x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#') continue;\n      if(ncost < mincost[(i+2)%4][np][nq][ny][nx]) {\n\tque.push(State(ny, nx, (i+2)%4, np, nq, ncost));\n\tmincost[(i+2)%4][np][nq][ny][nx] = ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> A;\n  rep(i, N) rep(j, M) {\n    cin >> mas[i][j];\n    if(mas[i][j] == 'S') sy = i, sx = j;\n    else if(mas[i][j] == 'G') gy = i, gx = j;\n  }\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,X;\nint d[100][100][4][11][11];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ad[4]={1,0,3,2},bd[4]={3,2,1,0};\nint inf=100;\nstring s[100];\ndeque<int> qx,qy,qd,qa,qb;\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nvoid pushf(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_front(x);\n\tqy.push_front(y);\n\tqd.push_front(z);\n\tqa.push_front(a);\n\tqb.push_front(b);\n\td[x][y][z][a][b]=c;\n}\nvoid pushb(int x,int y,int z,int a,int b,int c){\n\tif(d[x][y][z][a][b]<=c) return;\n\tqx.push_back(x);\n\tqy.push_back(y);\n\tqd.push_back(z);\n\tqa.push_back(a);\n\tqb.push_back(b);\n\td[x][y][z][a][b]=c;\n}\nint main(){\n\tcin>>H>>W>>X;\n\trep(i,H) rep(j,W) rep(k,4) rep(a,X+1) rep(b,X+1) d[i][j][k][a][b]=inf;\n\trep(i,H) cin>>s[i];\n\tint sx,sy;\n\trep(i,H) rep(j,W) if(s[i][j]=='S') sx=i,sy=j;\n\tpushb(sx,sy,0,X,X,0);\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front(),di=qd.front(),a=qa.front(),b=qb.front();\n\t\tqx.pop_front(),qy.pop_front(),qd.pop_front(),qa.pop_front(),qb.pop_front();\n\t\tif(x==sx&&y==sy&&di==2) continue;\n\t\tint c=d[x][y][di][a][b];\n\t\tif(s[x][y]=='G'){\n\t\t\tcout<<c<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\tif(is(nx,ny)) pushf(nx,ny,di,a,b,c);\n\t\tif(!(x==sx&&y==sy) && a>0) pushb(x,y,ad[di],a-1,b,c+1);\n\t\tif(!(x==sx&&y==sy) && b>0) pushb(x,y,bd[di],a,b-1,c+1);\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2342 Light Road\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n\n#define QMAX 51000\ntypedef struct { char r, c, d, a, b; } Q;\nQ que[QMAX+2]; int top, end;\nchar map[103][103];\nchar mk[103][103][4][11][11];\nint  mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint  ma[4][4] = {{0,-1,-1,1},{-1,0,1,-1},{-1,1,0,-1},{1,-1,-1,0}};\nint  mb[4][4] = {{0,1,-1,-1},{1,0,-1,-1},{-1,-1,0,1},{-1,-1,1,0}};\n\nint main()\n{\n\tint H, W, A, B, r, c, d, a, b, nr, nc, nd, na, nb, ans;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d%d\", &H, &W, &A), B = A;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == 'S') sr = r, sc = c;\n\t\t\tif (map[r][c] == 'G') gr = r, gc = c;\n\t\t}\n\t}\n\tif (sr == H-1 || map[sr+1][sc] == '#') { puts(\"-1\"); return 0; }\n\tque[0].r = sr+1, que[0].c = sc, que[0].d = 2, que[0].a = que[0].b = 0;\n\tfor (a = 0; a <= A; a++) for (b = 0; b <= B; b++) mk[sr][sc][0][a][b] = 1;\n\ttop = 0, end = 1;\n\tans = 100;\n\twhile (top != end) {\n\t\tr = que[top].r, c = que[top].c, d = que[top].d, a = que[top].a, b = que[top].b;\n\t\tif (++top == QMAX) top = 0;\n\t\tif (r == gr && c == gc) {\n\t\t\tif (a+b < ans) ans = a+b;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mk[r][c][d][a][b]) continue;\n\t\tmk[r][c][d][a][b] = 1;\n\t\tfor (nd = 0; nd < 4; nd++) {\n\t\t\tnr = r + mv[nd][0], nc = c + mv[nd][1], na = ma[d][nd], nb = mb[d][nd];\n\t\t\tif (na < 0 && nb < 0) continue;\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tque[end].r = nr, que[end].c = nc, que[end].d = nd;\n\t\t\tif (na > 0) {\n\t\t\t\tif (a+1 > A || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd][a+1][b]) continue;\n\t\t\t\tque[end].a = a+1, que[end].b = b;\n\t\t\t} else if (nb > 0) {\n\t\t\t\tif (b+1 > B || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd][a][b+1]) continue;\n\t\t\t\tque[end].a = a, que[end].b = b+1;\n\t\t\t} else if (!na)\t{\n\t\t\t\tque[end].a = a, que[end].b = b;\n\t\t\t\tif (mk[nr][nc][nd][a][b]) continue;\n\t\t\t}\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\tif (ans > 20) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2342 Light Road\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n\n#define QMAX 11000\ntypedef struct { char r, c, d, a, b; } Q;\nQ que[QMAX+2]; int top, end;\nchar map[103][103];\nchar mk[103][103][4];\nint  mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint  ma[4][4] = {{0,-1,-1,1},{-1,0,1,-1},{-1,1,0,-1},{1,-1,-1,0}};\nint  mb[4][4] = {{0,1,-1,-1},{1,0,-1,-1},{-1,-1,0,1},{-1,-1,1,0}};\n\nint main()\n{\n\tint H, W, A, B, r, c, d, a, b, nr, nc, nd, na, nb, ans;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d%d\", &H, &W, &A), B = A;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == 'S') sr = r, sc = c;\n\t\t\tif (map[r][c] == 'G') gr = r, gc = c;\n\t\t}\n\t}\n\tif (sr == H-1 || map[sr+1][sc] == '#') { puts(\"-1\"); return 0; }\n\tque[0].r = sr+1, que[0].c = sc, que[0].d = 2, que[0].a = que[0].b = 0;\n\ttop = 0, end = 1;\n\tans = 100;\n\twhile (top != end) {\n\t\tr = que[top].r, c = que[top].c, d = que[top].d, a = que[top].a, b = que[top].b;\n\t\tif (++top == QMAX) top = 0;\n\t\tif (r == gr && c == gc) {\n\t\t\tif (a+b < ans) ans = a+b;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mk[r][c][d]) continue;\n\t\tmk[r][c][d] = 1;\n\t\tfor (nd = 0; nd < 4; nd++) {\n\t\t\tnr = r + mv[nd][0], nc = c + mv[nd][1], na = ma[d][nd], nb = mb[d][nd];\n\t\t\tif (na < 0 && nb < 0) continue;\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tif (mk[nr][nc][nd]) continue;\n\t\t\tque[end].r = nr, que[end].c = nc, que[end].d = nd;\n\t\t\tif (na > 0) {\n\t\t\t\tif (a+1 > A || r == sr && c == sc) continue;\n\t\t\t\tque[end].a = a+1, que[end].b = b;\n\t\t\t} else if (nb > 0) {\n\t\t\t\tif (b+1 > B || r == sr && c == sc) continue;\n\t\t\t\tque[end].a = a, que[end].b = b+1;\n\t\t\t} else if (!na)\tque[end].a = a, que[end].b = b;\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\tif (ans > 20) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2342 Light Road\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n\n#define QMAX 51000\ntypedef struct { char r, c, d, a, b; } Q;\nQ que[QMAX+2]; int top, end;\nchar map[103][103];\nchar mk[103][103][4][11][11];\nint  mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint  ma[4][4] = {{0,-1,-1,1},{-1,0,1,-1},{-1,1,0,-1},{1,-1,-1,0}};\nint  mb[4][4] = {{0,1,-1,-1},{1,0,-1,-1},{-1,-1,0,1},{-1,-1,1,0}};\n\nint main()\n{\n\tint H, W, A, B, r, c, d, a, b, nr, nc, nd, na, nb, ans;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d%d\", &H, &W, &A), B = A;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == 'S') sr = r, sc = c;\n\t\t\tif (map[r][c] == 'G') gr = r, gc = c;\n\t\t}\n\t}\n\tif (sr == H-1 || map[sr+1][sc] == '#') { puts(\"-1\"); return 0; }\n\tque[0].r = sr+1, que[0].c = sc, que[0].d = 2, que[0].a = que[0].b = 0;\n\tfor (a = 0; a <= A; a++) for (b = 0; b <= B; b++) mk[sr][sc][0][a][b] = 1;\n\ttop = 0, end = 1;\n\tans = 100;\n\twhile (top != end) {\n\t\tr = que[top].r, c = que[top].c, d = que[top].d, a = que[top].a, b = que[top++].b;\n\t\tif (r == gr && c == gc) {\n\t\t\tif (a+b < ans) ans = a+b;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mk[r][c][d][a][b]) continue;\n\t\tmk[r][c][d][a][b] = 1;\n\t\tfor (nd = 0; nd < 4; nd++) {\n\t\t\tnr = r + mv[nd][0], nc = c + mv[nd][1], na = ma[d][nd], nb = mb[d][nd];\n\t\t\tif (na < 0 && nb < 0) continue;\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tque[end].r = nr, que[end].c = nc, que[end].d = nd;\n\t\t\tif (na > 0) {\n\t\t\t\tif (a+1 > A || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd][a+1][b]) continue;\n\t\t\t\tque[end].a = a+1, que[end].b = b;\n\t\t\t} else if (nb > 0) {\n\t\t\t\tif (b+1 > B || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd][a][b+1]) continue;\n\t\t\t\tque[end].a = a, que[end].b = b+1;\n\t\t\t} else if (!na)\t{\n\t\t\t\tque[end].a = a, que[end].b = b;\n\t\t\t\tif (mk[nr][nc][nd][a][b]) continue;\n\t\t\t}\n\t\t\tend++;\n\t\t}\n\t}\n\tif (ans > 20) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2342 Light Road\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n\n#define QMAX 11000\ntypedef struct { char r, c, d, a, b; } Q;\nQ que[QMAX+2]; int top, end;\nchar map[103][103];\nchar mk[103][103][4];\nint  mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint  ma[4][4] = {{0,-1,-1,1},{-1,0,1,-1},{-1,1,0,-1},{1,-1,-1,0}};\nint  mb[4][4] = {{0,1,-1,-1},{1,0,-1,-1},{-1,-1,0,1},{-1,-1,1,0}};\n\nint main()\n{\n\tint H, W, A, B, r, c, d, a, b, nr, nc, nd, na, nb, ans;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d%d\", &H, &W, &A), B = A;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == 'S') sr = r, sc = c;\n\t\t\tif (map[r][c] == 'G') gr = r, gc = c;\n\t\t}\n\t}\n\tif (sr == H-1 || map[sr+1][sc] == '#') { puts(\"-1\"); return 0; }\n\tque[0].r = sr+1, que[0].c = sc, que[0].d = 2, que[0].a = que[0].b = 0;\n\ttop = 0, end = 1;\n\tans = 100;\n\twhile (top != end) {\n\t\tr = que[top].r, c = que[top].c, d = que[top].d, a = que[top].a, b = que[top].b;\n\t\tif (++top == QMAX) top = 0;\n\t\tif (r == gr && c == gc) {\n\t\t\tif (a+b < ans) ans = a+b;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mk[r][c][d]) continue;\n\t\tmk[r][c][d] = 1;\n\t\tfor (nd = 0; nd < 4; nd++) {\n\t\t\tnr = r + mv[nd][0], nc = c + mv[nd][1], na = ma[d][nd], nb = mb[d][nd];\n\t\t\tif (na < 0 && nb < 0) continue;\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tif (map[nr][nc] == 'S' && nd == 0) continue;\n\t\t\tif (mk[nr][nc][nd]) continue;\n\t\t\tque[end].r = nr, que[end].c = nc, que[end].d = nd;\n\t\t\tif (na > 0) {\n\t\t\t\tif (a+1 > A || r == sr && c == sc) continue;\n\t\t\t\tque[end].a = a+1, que[end].b = b;\n\t\t\t} else if (nb > 0) {\n\t\t\t\tif (b+1 > B || r == sr && c == sc) continue;\n\t\t\t\tque[end].a = a, que[end].b = b+1;\n\t\t\t} else if (!na)\tque[end].a = a, que[end].b = b;\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\tif (ans > 20) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2342 Light Road\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 51000\ntypedef struct { char r, c, d, a, b; } Q;\nQ que[QMAX+2]; int top, end;\nchar map[103][103];\nchar mk[103][103][4];\nint  mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint  ma[4][4] = {{0,-1,-1,1},{-1,0,1,-1},{-1,1,0,-1},{1,-1,-1,0}};\nint  mb[4][4] = {{0,1,-1,-1},{1,0,-1,-1},{-1,-1,0,1},{-1,-1,1,0}};\n\nint main()\n{\n\tint H, W, A, B, r, c, d, a, b, nr, nc, nd, na, nb, ans;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d%d\", &H, &W, &A), B = A;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == 'S') sr = r, sc = c;\n\t\t\tif (map[r][c] == 'G') gr = r, gc = c;\n\t\t}\n\t}\n\tif (sr == H-1 || map[sr+1][sc] == '#') { puts(\"-1\"); return 0; }\n\tque[0].r = sr+1, que[0].c = sc, que[0].d = 2, que[0].a = que[0].b = 0;\n\tmemset(mk, 100, sizeof(mk));\n\tmk[sr][sc][0] = 1;\n\ttop = 0, end = 1;\n\tans = 100;\n\twhile (top != end) {\n\t\tr = que[top].r, c = que[top].c, d = que[top].d, a = que[top].a, b = que[top].b;\n\t\tif (++top == QMAX) top = 0;\n\t\tif (r == gr && c == gc) {\n\t\t\tif (a+b < ans) ans = a+b;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mk[r][c][d] < a+b) continue;\n\t\tmk[r][c][d] = a+b;\n\t\tfor (nd = 0; nd < 4; nd++) {\n\t\t\tnr = r + mv[nd][0], nc = c + mv[nd][1], na = ma[d][nd], nb = mb[d][nd];\n\t\t\tif (na < 0 && nb < 0) continue;\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tque[end].r = nr, que[end].c = nc, que[end].d = nd;\n\t\t\tif (na > 0) {\n\t\t\t\tif (a+1 > A || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd] < a+1+b) continue;\n\t\t\t\tque[end].a = a+1, que[end].b = b;\n\t\t\t} else if (nb > 0) {\n\t\t\t\tif (b+1 > B || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd] < a+b+1) continue;\n\t\t\t\tque[end].a = a, que[end].b = b+1;\n\t\t\t} else if (!na)\t{\n\t\t\t\tque[end].a = a, que[end].b = b;\n\t\t\t\tif (mk[nr][nc][nd] < a+b) continue;\n\t\t\t}\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\tif (ans > 20) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2342 Light Road\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { char r, c, d, a, b; } Q;\nQ que[QMAX+2]; int top, end;\nchar map[103][103];\nchar mk[103][103][4][11];\nint  mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint  ma[4][4] = {{0,-1,-1,1},{-1,0,1,-1},{-1,1,0,-1},{1,-1,-1,0}};\nint  mb[4][4] = {{0,1,-1,-1},{1,0,-1,-1},{-1,-1,0,1},{-1,-1,1,0}};\n\nint main()\n{\n\tint H, W, A, B, r, c, d, a, b, nr, nc, nd, na, nb, ans;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d%d\", &H, &W, &A), B = A;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == 'S') sr = r, sc = c;\n\t\t\tif (map[r][c] == 'G') gr = r, gc = c;\n\t\t}\n\t}\n\tif (sr == H-1 || map[sr+1][sc] == '#') { puts(\"-1\"); return 0; }\n\tque[0].r = sr+1, que[0].c = sc, que[0].d = 2, que[0].a = que[0].b = 0;\n\tmemset(mk, 100, sizeof(mk));\n\tfor (a = 0; a <= A; a++) mk[sr][sc][0][a] = 0;\n\ttop = 0, end = 1;\n\tans = 100;\n\twhile (top != end) {\n\t\tr = que[top].r, c = que[top].c, d = que[top].d, a = que[top].a, b = que[top].b;\n\t\tif (++top == QMAX) top = 0;\n\t\tif (r == gr && c == gc) {\n\t\t\tif (a+b < ans) ans = a+b;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mk[r][c][d][a] <= b) continue;\n\t\tmk[r][c][d][a] = b;\n\t\tfor (nd = 0; nd < 4; nd++) {\n\t\t\tnr = r + mv[nd][0], nc = c + mv[nd][1], na = ma[d][nd], nb = mb[d][nd];\n\t\t\tif (na < 0 && nb < 0) continue;\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tque[end].r = nr, que[end].c = nc, que[end].d = nd;\n\t\t\tif (na > 0) {\n\t\t\t\tif (a+1 > A || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd][a+1] <= b) continue;\n\t\t\t\tque[end].a = a+1, que[end].b = b;\n\t\t\t} else if (nb > 0) {\n\t\t\t\tif (b+1 > B || map[r][c] == 'S') continue;\n\t\t\t\tif (mk[nr][nc][nd][a] <= b+1) continue;\n\t\t\t\tque[end].a = a, que[end].b = b+1;\n\t\t\t} else if (!na)\t{\n\t\t\t\tque[end].a = a, que[end].b = b;\n\t\t\t\tif (mk[nr][nc][nd][a] <= b) continue;\n\t\t\t}\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\tif (ans > 20) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Light Road\npublic class Main{\n\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[][] M = {\n\t\t\t{-1, 1, -2, 0},\n\t\t\t{1, -1, 0, -2},\n\t\t\t{-2, 0, -1, 1},\n\t\t\t{0, -2, 1, -1}\n\t};\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt(), w = sc.nextInt(), A = sc.nextInt();\n\t\tchar[][] m = new char[h][];\n\t\tint si = -1, sj = -1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<w;j++)if(m[i][j]=='S'){\n\t\t\t\tsi = i; sj = j;\n\t\t\t}\n\t\t}\n\t\tboolean[][][][][] u = new boolean[h][w][4][A+1][A+1];\n\t\tu[si][sj][2][0][0] = true;\n\t\tQueue<int[]> q = new LinkedList<int[]>();\n\t\tq.add(new int[]{si, sj, 2, 0, 0});\n\t\tint res = 100;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] V = q.poll();\n\t\t\tint i = V[0], j = V[1], dir = V[2], P = V[3], Q = V[4];\n\t\t\tif(m[i][j]=='G'){\n\t\t\t\tres = Math.min(res, P+Q); continue;\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint x = M[dir][k];\n\t\t\t\tif(x==-2)continue;\n\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\tif(!(0<=ni&&ni<h&&0<=nj&&nj<w)||m[ni][nj]=='#'||m[ni][nj]=='S')continue;\n\t\t\t\tif(x==-1&&!u[ni][nj][k][P][Q]){\n\t\t\t\t\tu[ni][nj][k][P][Q] = true;  q.add(new int[]{ni, nj, k, P, Q});\n\t\t\t\t}\n\t\t\t\telse if(x==0&&m[i][j]=='.'&&P<A&&!u[ni][nj][k][P+1][Q]){\n\t\t\t\t\tu[ni][nj][k][P+1][Q] = true; q.add(new int[]{ni, nj, k, P+1, Q});\n\t\t\t\t}\n\t\t\t\telse if(x==1&&m[i][j]=='.'&&Q<A&&!u[ni][nj][k][P][Q+1]){\n\t\t\t\t\tu[ni][nj][k][P][Q+1] = true; q.add(new int[]{ni, nj, k, P, Q+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res==100?-1:res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Light Road\npublic class Main{\n\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[][] M = {\n\t\t\t{-1, 1, -2, 0},\n\t\t\t{1, -1, 0, -2},\n\t\t\t{-2, 0, -1, 1},\n\t\t\t{0, -2, 1, -1}\n\t};\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt(), w = sc.nextInt(), A = sc.nextInt();\n\t\tchar[][] m = new char[h][];\n\t\tint si = -1, sj = -1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<w;j++)if(m[i][j]=='S'){\n\t\t\t\tsi = i; sj = j;\n\t\t\t}\n\t\t}\n\t\tboolean[][][][][] u = new boolean[h][w][4][A+1][A+1];\n\t\tu[si][sj][2][0][0] = true;\n\t\tQueue<int[]> q = new LinkedList<int[]>();\n\t\tq.add(new int[]{si, sj, 2, 0, 0});\n\t\tint res = 100;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] V = q.poll();\n\t\t\tint i = V[0], j = V[1], dir = V[2], P = V[3], Q = V[4];\n\t\t\tif(m[i][j]=='G'){\n\t\t\t\tres = Math.min(res, P+Q); continue;\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint x = M[dir][k];\n\t\t\t\tif(x==-2)continue;\n\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\tif(!(0<=ni&&ni<h&&0<=nj&&nj<w)||m[ni][nj]=='#')continue;\n\t\t\t\tif(x==-1&&!u[ni][nj][k][P][Q]){\n\t\t\t\t\tu[ni][nj][k][P][Q] = true;  q.add(new int[]{ni, nj, k, P, Q});\n\t\t\t\t}\n\t\t\t\telse if(x==0&&m[i][j]=='.'&&P<A&&!u[ni][nj][k][P+1][Q]){\n\t\t\t\t\tu[ni][nj][k][P+1][Q] = true; q.add(new int[]{ni, nj, k, P+1, Q});\n\t\t\t\t}\n\t\t\t\telse if(x==1&&m[i][j]=='.'&&Q<A&&!u[ni][nj][k][P][Q+1]){\n\t\t\t\t\tu[ni][nj][k][P][Q+1] = true; q.add(new int[]{ni, nj, k, P, Q+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res==100?-1:res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m,l):\n        a = [[c for c in S()] for _ in range(n)]\n        s = (-1,-1)\n        g = (-1,-1)\n        kh = set()\n        for i in range(n):\n            for j in range(m):\n                c = a[i][j]\n                if c == 'S':\n                    s = (i,j)\n                    a[i][j] = '.'\n                if c == 'G':\n                    g = (i,j)\n                    a[i][j] = '.'\n                if a[i][j] == '.':\n                    kh.add((i,j))\n\n        if (s[0]+1, s[1]) not in kh:\n            return -1\n\n        def search():\n            d = collections.defaultdict(lambda: (inf,0,0))\n            ss = ((s[0]+1, s[1]), 2)\n            d[ss] = (0,0,0)\n            q = []\n            heapq.heappush(q, ((0,0,0), ss))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                if u[0] == g:\n                    return k[0]\n\n                if u == (s, 0) or (k[0]>0 and u == (s,2)):\n                    continue\n\n                for di in range(4):\n                    if abs(di - u[1]) == 2:\n                        continue\n                    if (u[0][0]+dd[di][0], u[0][1]+dd[di][1]) not in kh:\n                        continue\n                    uv = ((u[0][0]+dd[di][0], u[0][1]+dd[di][1]), di)\n                    if v[uv]:\n                        continue\n                    if di == u[1]:\n                        if d[uv] > k:\n                            d[uv] = k\n                            heapq.heappush(q, (k, uv))\n                        continue\n\n                    if u[0] == s:\n                        continue\n\n                    ti = (0,0)\n                    if u[1] % 2 == 1:\n                        if u[1] - 1 == di:\n                            ti = (1,0)\n                        else:\n                            ti = (0,1)\n                    else:\n                        if u[1] - 1 == di:\n                            ti = (0,1)\n                        else:\n                            ti = (1,0)\n\n                    ud = (k[0]+1,k[1]+ti[0],k[2]+ti[1])\n                    if ud[1] > l or ud[2] > l or d[uv] <= ud:\n                        continue\n                    d[uv] = ud\n                    heapq.heappush(q, (ud, uv))\n\n            return -1\n\n        return search()\n\n    while 1:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, M, A = map(int, input().split())\nMP = [[0]*M for i in range(N)]\nsx = sy = gx = gy = -1\nfor i in range(N):\n    for j, c in enumerate(input()):\n        if c == '#':\n            MP[i][j] = 1\n        elif c == 'S':\n            sx = j; sy = i\n        elif c == 'G':\n            gx = j; gy = i\nU = [[set() for i in range(M)] for j in range(N)]\nDD = ((-1, 0), (0, -1), (1, 0), (0, 1))\nque = deque([(sx, sy, 0, 0, 3)])\nfor i in range(A+1):\n    for j in range(A+1):\n        U[sy][sx].add((i, j, 1))\n        U[sy][sx].add((i, j, 3))\npp = ((sx, sy), (gx, gy))\nwhile que:\n    x, y, a, b, d = que.popleft()\n\n    if (x, y) not in pp:\n        d0 = (d-1) % 4\n        dx, dy = DD[d0]\n        nx = x + dx; ny = y + dy\n        if 0 <= nx < M and 0 <= ny < N and MP[ny][nx] == 0:\n            if d % 2 == 0:\n                if b < A and (a, b+1, d0) not in U[ny][nx]:\n                    U[ny][nx].add((a, b+1, d0))\n                    que.append((nx, ny, a, b+1, d0))\n            else:\n                if a < A and (a+1, b, d0) not in U[ny][nx]:\n                    U[ny][nx].add((a+1, b, d0))\n                    que.append((nx, ny, a+1, b, d0))\n\n        d1 = (d+1) % 4\n        dx, dy = DD[d1]\n        nx = x + dx; ny = y + dy\n        if 0 <= nx < M and 0 <= ny < N and MP[ny][nx] == 0:\n            if d % 2 == 0:\n                if a < A and (a+1, b, d1) not in U[ny][nx]:\n                    U[ny][nx].add((a+1, b, d1))\n                    que.append((nx, ny, a+1, b, d1))\n            else:\n                if b < A and (a, b+1, d1) not in U[ny][nx]:\n                    U[ny][nx].add((a, b+1, d1))\n                    que.append((nx, ny, a, b+1, d1))\n\n    dx, dy = DD[d]\n    nx = x + dx; ny = y + dy\n    if 0 <= nx < M and 0 <= ny < N and MP[ny][nx] == 0:\n        if (a, b, d) not in U[ny][nx]:\n            U[ny][nx].add((a, b, d))\n            que.append((nx, ny, a, b, d))\n\nif U[gy][gx]:\n    print(min(a+b for a, b, d in U[gy][gx]))\nelse:\n    print(-1)\n\n"
  }
]