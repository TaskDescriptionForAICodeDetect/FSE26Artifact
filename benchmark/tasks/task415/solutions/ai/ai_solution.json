[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_NM 105\n#define MAX_A 11\n#define INF INT_MAX\n\ntypedef struct {\n    int x, y, dir, p, q;\n} State;\n\nchar grid[MAX_NM][MAX_NM];\nint dist[MAX_NM][MAX_NM][4][MAX_A][MAX_A];\nint N, M;\nint start_x, start_y, start_dir;\nint target_x, target_y;\nint A;\n\nint dx[4] = {0, 1, 0, -1}; // E, S, W, N\nint dy[4] = {1, 0, -1, 0};\n\nState queue[MAX_NM * MAX_NM * 4 * MAX_A * MAX_A];\nint front, rear;\n\nvoid enqueue(State s) {\n    queue[rear++] = s;\n}\n\nState dequeue() {\n    return queue[front++];\n}\n\nint is_empty() {\n    return front == rear;\n}\n\nvoid init() {\n    front = rear = 0;\n    memset(dist, -1, sizeof(dist));\n}\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < M && grid[x][y] != '*';\n}\n\nint solve() {\n    init();\n    dist[start_x][start_y][start_dir][A][A] = 0;\n    enqueue((State){start_x, start_y, start_dir, A, A});\n\n    while (!is_empty()) {\n        State current = dequeue();\n        int x = current.x;\n        int y = current.y;\n        int dir = current.dir;\n        int p = current.p;\n        int q = current.q;\n        int current_dist = dist[x][y][dir][p][q];\n\n        if (x == target_x && y == target_y) {\n            return current_dist;\n        }\n\n        // Move without placing mirror\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n        if (is_valid(nx, ny)) {\n            if (dist[nx][ny][dir][p][q] == -1 || dist[nx][ny][dir][p][q] > current_dist) {\n                dist[nx][ny][dir][p][q] = current_dist;\n                enqueue((State){nx, ny, dir, p, q});\n            }\n        }\n\n        // Place P mirror if available\n        if (p > 0) {\n            int new_dir1 = (dir + 1) % 4;\n            int new_dir2 = (dir + 3) % 4;\n            if (dist[x][y][new_dir1][p - 1][q] == -1 || dist[x][y][new_dir1][p - 1][q] > current_dist + 1) {\n                dist[x][y][new_dir1][p - 1][q] = current_dist + 1;\n                enqueue((State){x, y, new_dir1, p - 1, q});\n            }\n            if (dist[x][y][new_dir2][p - 1][q] == -1 || dist[x][y][new_dir2][p - 1][q] > current_dist + 1) {\n                dist[x][y][new_dir2][p - 1][q] = current_dist + 1;\n                enqueue((State){x, y, new_dir2, p - 1, q});\n            }\n        }\n\n        // Place Q mirror if available\n        if (q > 0) {\n            int new_dir1 = (dir + 1) % 4;\n            int new_dir2 = (dir + 3) % 4;\n            if (dist[x][y][new_dir1][p][q - 1] == -1 || dist[x][y][new_dir1][p][q - 1] > current_dist + 1) {\n                dist[x][y][new_dir1][p][q - 1] = current_dist + 1;\n                enqueue((State){x, y, new_dir1, p, q - 1});\n            }\n            if (dist[x][y][new_dir2][p][q - 1] == -1 || dist[x][y][new_dir2][p][q - 1] > current_dist + 1) {\n                dist[x][y][new_dir2][p][q - 1] = current_dist + 1;\n                enqueue((State){x, y, new_dir2, p, q - 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 'C') {\n                target_x = i;\n                target_y = j;\n            } else if (grid[i][j] == 'L') {\n                start_x = i;\n                start_y = j;\n                start_dir = 0; // East\n            } else if (grid[i][j] == 'D') {\n                start_x = i;\n                start_y = j;\n                start_dir = 1; // South\n            } else if (grid[i][j] == 'R') {\n                start_x = i;\n                start_y = j;\n                start_dir = 2; // West\n            } else if (grid[i][j] == 'U') {\n                start_x = i;\n                start_y = j;\n                start_dir = 3; // North\n            }\n        }\n    }\n    scanf(\"%d\", &A);\n\n    int result = solve();\n    if (result == -1) {\n        printf(\"impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int N, M, A;\n    cin >> N >> M >> A;\n\n    vector<string> grid(N);\n    int sx = -1, sy = -1, ex = -1, ey = -1;\n\n    for (int i = 0; i < N; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < M; ++j) {\n            if (grid[i][j] == 'S') {\n                sx = i;\n                sy = j;\n            } else if (grid[i][j] == 'T') {\n                ex = i;\n                ey = j;\n            }\n        }\n    }\n\n    int dir = -1;\n    for (int d = 0; d < 4; ++d) {\n        int nx = sx + dx[d];\n        int ny = sy + dy[d];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != '#') {\n            dir = d;\n            break;\n        }\n    }\n\n    vector<vector<vector<vector<int>>>> dist(N, vector<vector<vector<int>>>(M, vector<vector<int>>(4, vector<int>(A + 1, INT_MAX))));\n    queue<tuple<int, int, int, int>> q;\n\n    dist[sx][sy][dir][0] = 0;\n    q.push({sx, sy, dir, 0});\n\n    bool found = false;\n    int result = INT_MAX;\n\n    while (!q.empty()) {\n        auto [x, y, d, a] = q.front();\n        q.pop();\n\n        if (x == ex && y == ey) {\n            found = true;\n            result = min(result, dist[x][y][d][a]);\n            continue;\n        }\n\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != '#') {\n            if (dist[nx][ny][d][a] > dist[x][y][d][a]) {\n                dist[nx][ny][d][a] = dist[x][y][d][a];\n                q.push({nx, ny, d, a});\n            }\n        }\n\n        if (grid[x][y] == '.' && a < A) {\n            for (int mirror = 0; mirror < 2; ++mirror) {\n                int nd1, nd2;\n                if (mirror == 0) {\n                    nd1 = (d + 1) % 4;\n                    nd2 = (d + 3) % 4;\n                } else {\n                    nd1 = (d + 3) % 4;\n                    nd2 = (d + 1) % 4;\n                }\n\n                if (dist[x][y][nd1][a + 1] > dist[x][y][d][a] + 1) {\n                    dist[x][y][nd1][a + 1] = dist[x][y][d][a] + 1;\n                    q.push({x, y, nd1, a + 1});\n                }\n                if (dist[x][y][nd2][a + 1] > dist[x][y][d][a] + 1) {\n                    dist[x][y][nd2][a + 1] = dist[x][y][d][a] + 1;\n                    q.push({x, y, nd2, a + 1});\n                }\n            }\n        }\n    }\n\n    if (found) {\n        cout << result << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass State {\n    int x, y, dir, p, q;\n    State(int x, int y, int dir, int p, int q) {\n        this.x = x;\n        this.y = y;\n        this.dir = dir;\n        this.p = p;\n        this.q = q;\n    }\n}\n\npublic class LaserMirror {\n    static final int[] dx = {0, 1, 0, -1}; // N, E, S, W\n    static final int[] dy = {1, 0, -1, 0};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int A = sc.nextInt();\n        char[][] grid = new char[N][M];\n        int startX = -1, startY = -1, endX = -1, endY = -1, startDir = -1;\n        \n        for (int i = 0; i < N; i++) {\n            String line = sc.next();\n            for (int j = 0; j < M; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                } else if (grid[i][j] == 'T') {\n                    endX = i;\n                    endY = j;\n                }\n            }\n        }\n        String dirStr = sc.next();\n        switch (dirStr) {\n            case \"N\": startDir = 0; break;\n            case \"E\": startDir = 1; break;\n            case \"S\": startDir = 2; break;\n            case \"W\": startDir = 3; break;\n        }\n        \n        int[][][][][] dist = new int[N][M][4][A+1][A+1];\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < M; j++)\n                for (int d = 0; d < 4; d++)\n                    for (int p = 0; p <= A; p++)\n                        for (int q = 0; q <= A; q++)\n                            dist[i][j][d][p][q] = -1;\n        \n        Queue<State> q = new LinkedList<>();\n        q.add(new State(startX, startY, startDir, 0, 0));\n        dist[startX][startY][startDir][0][0] = 0;\n        \n        boolean found = false;\n        int result = Integer.MAX_VALUE;\n        \n        while (!q.isEmpty()) {\n            State s = q.poll();\n            if (s.x == endX && s.y == endY) {\n                found = true;\n                result = Math.min(result, dist[s.x][s.y][s.dir][s.p][s.q]);\n                continue;\n            }\n            \n            // Move without placing a mirror\n            int nx = s.x + dx[s.dir];\n            int ny = s.y + dy[s.dir];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != '#') {\n                if (dist[nx][ny][s.dir][s.p][s.q] == -1 || \n                    dist[nx][ny][s.dir][s.p][s.q] > dist[s.x][s.y][s.dir][s.p][s.q]) {\n                    dist[nx][ny][s.dir][s.p][s.q] = dist[s.x][s.y][s.dir][s.p][s.q];\n                    q.add(new State(nx, ny, s.dir, s.p, s.q));\n                }\n            }\n            \n            // Place P mirror if available\n            if (s.p < A) {\n                int newDir1 = (s.dir + 1) % 4;\n                int newDir2 = (s.dir + 3) % 4;\n                if (dist[s.x][s.y][newDir1][s.p + 1][s.q] == -1 || \n                    dist[s.x][s.y][newDir1][s.p + 1][s.q] > dist[s.x][s.y][s.dir][s.p][s.q] + 1) {\n                    dist[s.x][s.y][newDir1][s.p + 1][s.q] = dist[s.x][s.y][s.dir][s.p][s.q] + 1;\n                    q.add(new State(s.x, s.y, newDir1, s.p + 1, s.q));\n                }\n                if (dist[s.x][s.y][newDir2][s.p + 1][s.q] == -1 || \n                    dist[s.x][s.y][newDir2][s.p + 1][s.q] > dist[s.x][s.y][s.dir][s.p][s.q] + 1) {\n                    dist[s.x][s.y][newDir2][s.p + 1][s.q] = dist[s.x][s.y][s.dir][s.p][s.q] + 1;\n                    q.add(new State(s.x, s.y, newDir2, s.p + 1, s.q));\n                }\n            }\n            \n            // Place Q mirror if available\n            if (s.q < A) {\n                int newDir1 = (s.dir + 1) % 4;\n                int newDir2 = (s.dir + 3) % 4;\n                if (dist[s.x][s.y][newDir1][s.p][s.q + 1] == -1 || \n                    dist[s.x][s.y][newDir1][s.p][s.q + 1] > dist[s.x][s.y][s.dir][s.p][s.q] + 1) {\n                    dist[s.x][s.y][newDir1][s.p][s.q + 1] = dist[s.x][s.y][s.dir][s.p][s.q] + 1;\n                    q.add(new State(s.x, s.y, newDir1, s.p, s.q + 1));\n                }\n                if (dist[s.x][s.y][newDir2][s.p][s.q + 1] == -1 || \n                    dist[s.x][s.y][newDir2][s.p][s.q + 1] > dist[s.x][s.y][s.dir][s.p][s.q] + 1) {\n                    dist[s.x][s.y][newDir2][s.p][s.q + 1] = dist[s.x][s.y][s.dir][s.p][s.q] + 1;\n                    q.add(new State(s.x, s.y, newDir2, s.p, s.q + 1));\n                }\n            }\n        }\n        \n        if (found) {\n            System.out.println(result);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:30:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LaserMirrorGame {\n    static final int[] dx = {1, 0, -1, 0};\n    static final int[] dy = {0, 1, 0, -1};\n    static final int MAX_MIRRORS = 10;\n    \n    static class State {\n        int x, y, dir, p, q, dist;\n        State(int x, int y, int dir, int p, int q, int dist) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n            this.p = p;\n            this.q = q;\n            this.dist = dist;\n        }\n    }\n    \n    public static int solve(int N, int M, int laserX, int laserY, int laserDir, \n                             int creatureX, int creatureY, int A, boolean[][] obstacles) {\n        boolean[][][][] visited = new boolean[N][M][4][A+1];\n        Queue<State> queue = new LinkedList<>();\n        \n        queue.offer(new State(laserX, laserY, laserDir, A, A, 0));\n        visited[laserX][laserY][laserDir][A] = true;\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.x == creatureX && curr.y == creatureY) {\n                return curr.dist;\n            }\n            \n            // Continue straight\n            int nx = curr.x + dx[curr.dir];\n            int ny = curr.y + dy[curr.dir];\n            \n            if (nx >= 0 && nx < N && ny >= 0 && ny < M && !obstacles[nx][ny]) {\n                if (!visited[nx][ny][curr.dir][curr.p]) {\n                    visited[nx][ny][curr.dir][curr.p] = true;\n                    queue.offer(new State(nx, ny, curr.dir, curr.p, curr.q, curr.dist));\n                }\n            }\n            \n            // Place type P mirror\n            if (curr.p > 0) {\n                int[] newDirs = {(curr.dir + 1) % 4, (curr.dir + 3) % 4};\n                for (int newDir : newDirs) {\n                    nx = curr.x + dx[newDir];\n                    ny = curr.y + dy[newDir];\n                    \n                    if (nx >= 0 && nx < N && ny >= 0 && ny < M && !obstacles[nx][ny]) {\n                        if (!visited[nx][ny][newDir][curr.p - 1]) {\n                            visited[nx][ny][newDir][curr.p - 1] = true;\n                            queue.offer(new State(nx, ny, newDir, curr.p - 1, curr.q, curr.dist + 1));\n                        }\n                    }\n                }\n            }\n            \n            // Place type Q mirror\n            if (curr.q > 0) {\n                int[] newDirs = {(curr.dir + 1) % 4, (curr.dir + 3) % 4};\n                for (int newDir : newDirs) {\n                    nx = curr.x + dx[newDir];\n                    ny = curr.y + dy[newDir];\n                    \n                    if (nx >= 0 && nx < N && ny >= 0 && ny < M && !obstacles[nx][ny]) {\n                        if (!visited[nx][ny][newDir][curr.p]) {\n                            visited[nx][ny][newDir][curr.p] = true;\n                            queue.offer(new State(nx, ny, newDir, curr.p, curr.q - 1, curr.dist + 1));\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        // Example test case\n        int N = 5, M = 5;\n        int laserX = 0, laserY = 0, laserDir = 1;\n        int creatureX = 4, creatureY = 4;\n        int A = 2;\n        boolean[][] obstacles = new boolean[N][M];\n        \n        int result = solve(N, M, laserX, laserY, laserDir, creatureX, creatureY, A, obstacles);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:30:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_M 100\n#define MAX_MIRRORS 10\n\nint N, M, P, Q;\nchar grid[MAX_N][MAX_M];\nint sx, sy, ex, ey;  // start and evil coordinates\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    int x, y, dir, p_used, q_used;\n} State;\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < M && grid[x][y] != '#';\n}\n\nint solve() {\n    State queue[MAX_N * MAX_M * 4];\n    bool visited[MAX_N][MAX_M][4][MAX_MIRRORS + 1][MAX_MIRRORS + 1];\n    memset(visited, 0, sizeof(visited));\n\n    int front = 0, rear = 0;\n    for (int dir = 0; dir < 4; dir++) {\n        queue[rear++] = (State){sx, sy, dir, 0, 0};\n        visited[sx][sy][dir][0][0] = true;\n    }\n\n    while (front < rear) {\n        State curr = queue[front++];\n\n        if (curr.x == ex && curr.y == ey) \n            return 0;\n\n        // Direct move\n        int nx = curr.x + dx[curr.dir];\n        int ny = curr.y + dy[curr.dir];\n        if (is_valid(nx, ny) && !visited[nx][ny][curr.dir][curr.p_used][curr.q_used]) {\n            queue[rear++] = (State){nx, ny, curr.dir, curr.p_used, curr.q_used};\n            visited[nx][ny][curr.dir][curr.p_used][curr.q_used] = true;\n        }\n\n        // P mirror reflections\n        if (curr.p_used < P) {\n            int p_dirs[2][4] = {{1, 3, 0, 2}, {3, 1, 2, 0}};\n            for (int i = 0; i < 2; i++) {\n                int new_dir = p_dirs[i][curr.dir];\n                nx = curr.x + dx[new_dir];\n                ny = curr.y + dy[new_dir];\n                if (is_valid(nx, ny) && !visited[nx][ny][new_dir][curr.p_used + 1][curr.q_used]) {\n                    queue[rear++] = (State){nx, ny, new_dir, curr.p_used + 1, curr.q_used};\n                    visited[nx][ny][new_dir][curr.p_used + 1][curr.q_used] = true;\n                }\n            }\n        }\n\n        // Q mirror reflections\n        if (curr.q_used < Q) {\n            int q_dirs[2][4] = {{2, 0, 3, 1}, {0, 2, 1, 3}};\n            for (int i = 0; i < 2; i++) {\n                int new_dir = q_dirs[i][curr.dir];\n                nx = curr.x + dx[new_dir];\n                ny = curr.y + dy[new_dir];\n                if (is_valid(nx, ny) && !visited[nx][ny][new_dir][curr.p_used][curr.q_used + 1]) {\n                    queue[rear++] = (State){nx, ny, new_dir, curr.p_used, curr.q_used + 1};\n                    visited[nx][ny][new_dir][curr.p_used][curr.q_used + 1] = true;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &N, &M, &P, &Q);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 'S') {\n                sx = i;\n                sy = j;\n            }\n            if (grid[i][j] == 'E') {\n                ex = i;\n                ey = j;\n            }\n        }\n    }\n\n    int result = solve();\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N = 105;\nconst int DIR_COUNT = 4;\n\nint N, M, A, creature_x, creature_y, laser_x, laser_y;\nint grid[MAX_N][MAX_N];\nbool visited[MAX_N][MAX_N][DIR_COUNT][11][11];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct State {\n    int x, y, dir, p_mirrors, q_mirrors, total_mirrors;\n    State(int x, int y, int dir, int p, int q, int total) \n        : x(x), y(y), dir(dir), p_mirrors(p), q_mirrors(q), total_mirrors(total) {}\n};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < M && grid[x][y] != 1;\n}\n\nint solve() {\n    memset(visited, false, sizeof(visited));\n    queue<State> q;\n    \n    // Initial directions from laser\n    for (int i = 0; i < 4; i++) {\n        q.push(State(laser_x, laser_y, i, A, A, 0));\n        visited[laser_x][laser_y][i][A][A] = true;\n    }\n    \n    while (!q.empty()) {\n        State curr = q.front(); \n        q.pop();\n        \n        // Kill creature\n        if (curr.x == creature_x && curr.y == creature_y) {\n            return curr.total_mirrors;\n        }\n        \n        // Move in current direction\n        int nx = curr.x + dx[curr.dir];\n        int ny = curr.y + dy[curr.dir];\n        \n        if (is_valid(nx, ny)) {\n            if (!visited[nx][ny][curr.dir][curr.p_mirrors][curr.q_mirrors]) {\n                visited[nx][ny][curr.dir][curr.p_mirrors][curr.q_mirrors] = true;\n                q.push(State(nx, ny, curr.dir, curr.p_mirrors, curr.q_mirrors, curr.total_mirrors));\n            }\n        }\n        \n        // Try P mirror (45/225 degrees)\n        if (curr.p_mirrors > 0) {\n            int p_dir[] = {(curr.dir+1)%4, (curr.dir+3)%4};\n            for (int new_dir : p_dir) {\n                if (!visited[curr.x][curr.y][new_dir][curr.p_mirrors-1][curr.q_mirrors]) {\n                    visited[curr.x][curr.y][new_dir][curr.p_mirrors-1][curr.q_mirrors] = true;\n                    q.push(State(curr.x, curr.y, new_dir, curr.p_mirrors-1, curr.q_mirrors, curr.total_mirrors+1));\n                }\n            }\n        }\n        \n        // Try Q mirror (135/315 degrees)\n        if (curr.q_mirrors > 0) {\n            int q_dir[] = {(curr.dir+1)%4, (curr.dir+3)%4};\n            for (int new_dir : q_dir) {\n                if (!visited[curr.x][curr.y][new_dir][curr.p_mirrors][curr.q_mirrors-1]) {\n                    visited[curr.x][curr.y][new_dir][curr.p_mirrors][curr.q_mirrors-1] = true;\n                    q.push(State(curr.x, curr.y, new_dir, curr.p_mirrors, curr.q_mirrors-1, curr.total_mirrors+1));\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    cin >> N >> M >> A;\n    \n    // Initialize grid\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    // Get laser and creature coordinates\n    cin >> laser_x >> laser_y >> creature_x >> creature_y;\n    laser_x--; laser_y--; creature_x--; creature_y--;\n    \n    int result = solve();\n    \n    if (result == -1) {\n        cout << \"Impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:31:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport sys\n\ndef possible_to_kill(n, m, laser_start, laser_dir, obstacles, creature_pos, a):\n    directions = {\n        'E': (0, 1),\n        'W': (0, -1),\n        'N': (-1, 0),\n        'S': (1, 0)\n    }\n    \n    reflect_p = {\n        (1, 0): [(0, -1), (0, 1)],  # from S to W/E\n        (-1, 0): [(0, -1), (0, 1)],  # from N to W/E\n        (0, 1): [(1, 0), (-1, 0)],  # from E to N/S\n        (0, -1): [(1, 0), (-1, 0)],  # from W to N/S\n    }\n    \n    reflect_q = {\n        (1, 0): [(0, 1), (0, -1)],  # from S to E/W\n        (-1, 0): [(0, 1), (0, -1)],  # from N to E/W\n        (0, 1): [(-1, 0), (1, 0)],  # from E to N/S\n        (0, -1): [(-1, 0), (1, 0)],  # from W to N/S\n    }\n    \n    dir_map = {\n        'E': directions['E'],\n        'W': directions['W'],\n        'N': directions['N'],\n        'S': directions['S']\n    }\n\n    start_row, start_col = laser_start\n    creature_row, creature_col = creature_pos\n    queue = deque([(start_row, start_col, dir_map[laser_dir], 0, 0)])  # (row, col, direction, P used, Q used)\n    visited = set(((start_row, start_col, dir_map[laser_dir], 0, 0)))\n\n    while queue:\n        row, col, (d_row, d_col), p_used, q_used = queue.popleft()\n        \n        while 0 <= row < n and 0 <= col < m and (row, col) not in obstacles:\n            if (row, col) == creature_pos:\n                return p_used + q_used\n            \n            # Move in the current direction until hitting an obstacle or the edge\n            next_row, next_col = row + d_row, col + d_col\n\n            if (next_row, next_col) in visited or not (0 <= next_row < n and 0 <= next_col < m) or (next_row, next_col) in obstacles:\n                break\n\n            if p_used < a:\n                for new_d_row, new_d_col in reflect_p[(d_row, d_col)]:\n                    if (next_row, next_col, (new_d_row, new_d_col), p_used + 1, q_used) not in visited:\n                        queue.append((next_row, next_col, (new_d_row, new_d_col), p_used + 1, q_used))\n                        visited.add((next_row, next_col, (new_d_row, new_d_col), p_used + 1, q_used))\n\n            if q_used < a:\n                for new_d_row, new_d_col in reflect_q[(d_row, d_col)]:\n                    if (next_row, next_col, (new_d_row, new_d_col), p_used, q_used + 1) not in visited:\n                        queue.append((next_row, next_col, (new_d_row, new_d_col), p_used, q_used + 1))\n                        visited.add((next_row, next_col, (new_d_row, new_d_col), p_used, q_used + 1))\n\n            row, col = next_row, next_col\n\n    return -1\n\n# Usage example:\nn, m = 5, 5  # Dimensions of the grid\nlaser_start = (0, 0)\nlaser_dir = 'E'\nobstacles = {(0, 2), (2, 1), (3, 3)}\ncreature_pos = (4, 4)\na = 2  # Max number of mirrors of each type\nresult = possible_to_kill(n, m, laser_start, laser_dir, obstacles, creature_pos, a)\nprint(result)  # Minimum number of mirrors needed or -1 if impossible",
    "timestamp": "2025-08-13 06:32:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LaserGrid {\n    private static final char OBSTACLE = '#';\n    private static final char EMPTY = '.';\n    private static final char LASER_CREATURE = 'L';  // Placeholder for laser or creature position\n    private static final int[] DX = {0, 1, 0, -1};  // Right, Down, Left, Up\n    private static final int[] DY = {1, 0, -1, 0};  // Right, Down, Left, Up\n\n    private static class State {\n        int x, y, direction, mirrorsUsed;\n        State(int x, int y, int direction, int mirrorsUsed) {\n            this.x = x;\n            this.y = y;\n            this.direction = direction;\n            this.mirrorsUsed = mirrorsUsed;\n        }\n    }\n\n    public static int minMirrorsToKillCreature(char[][] grid, int startX, int startY, int creatureX, int creatureY, int maxMirrors) {\n        int n = grid.length, m = grid[0].length;\n        boolean[][][] visited = new boolean[n][m][4];\n        Queue<State> queue = new LinkedList<>();\n        \n        for (int d = 0; d < 4; d++) {\n            queue.add(new State(startX, startY, d, 0));\n            visited[startX][startY][d] = true;\n        }\n\n        while (!queue.isEmpty()) {\n            State state = queue.poll();\n            int x = state.x, y = state.y, direction = state.direction, mirrorsUsed = state.mirrorsUsed;\n\n            if (x == creatureX && y == creatureY) {\n                return mirrorsUsed;\n            }\n            \n            int nextX = x + DX[direction];\n            int nextY = y + DY[direction];\n\n            if (nextX >= 0 && nextX < n && nextY >= 0 && nextY < m && grid[nextX][nextY] != OBSTACLE) {\n                if (!visited[nextX][nextY][direction]) {\n                    visited[nextX][nextY][direction] = true;\n                    queue.add(new State(nextX, nextY, direction, mirrorsUsed));\n                }\n\n                if (mirrorsUsed < maxMirrors) {\n                    int newDirP = (direction + 1) % 4;\n                    int newDirQ = (direction + 3) % 4;\n\n                    if (!visited[nextX][nextY][newDirP]) {\n                        visited[nextX][nextY][newDirP] = true;\n                        queue.add(new State(nextX, nextY, newDirP, mirrorsUsed + 1));\n                    }\n\n                    if (!visited[nextX][nextY][newDirQ]) {\n                        visited[nextX][nextY][newDirQ] = true;\n                        queue.add(new State(nextX, nextY, newDirQ, mirrorsUsed + 1));\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        char[][] grid = {\n            {'.', '#', '.', '.', '.', '.'},\n            {'.', '.', '.', '#', '.', '.'},\n            {'.', 'L', '.', '.', '.', '.'},\n            {'.', '.', '#', '.', '.', '#'},\n            {'.', '.', '.', '.', 'L', '.'}\n        };\n        int startX = 2;  // Laser generator position\n        int startY = 1;\n        int creatureX = 4;  // Creature position\n        int creatureY = 4;\n        int maxMirrors = 10;  // Maximum mirrors available\n\n        int result = minMirrorsToKillCreature(grid, startX, startY, creatureX, creatureY, maxMirrors);\n        if (result != -1) {\n            System.out.println(\"Minimum mirrors needed: \" + result);\n        } else {\n            System.out.println(\"Impossible to kill the creature.\");\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:32:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_M 100\n#define INF INT_MAX\n\ntypedef struct {\n    int x, y, dir, mirrorsPUsed, mirrorsQUsed;\n} Node;\n\nint dx[4] = {-1, 0, 1, 0}; // N, E, S, W\nint dy[4] = {0, 1, 0, -1};\n\nint grid[MAX_N][MAX_M];\nint dist[MAX_N][MAX_M][4]; // min mirrors used to reach each cell from a direction\n\nvoid bfs(int lx, int ly, int lDir, int ex, int ey, int n, int m, int A) {\n    int queueSize = MAX_N * MAX_M * 4;\n    Node queue[queueSize];\n    int head = 0, tail = 0;\n\n    // Initialize distances\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            for (int d = 0; d < 4; ++d)\n                dist[i][j][d] = INF;\n\n    queue[tail++] = (Node) { lx, ly, lDir, 0, 0 };\n    dist[lx][ly][lDir] = 0;\n\n    while (head != tail) {\n        Node node = queue[head++];\n        head %= queueSize;\n\n        int x = node.x, y = node.y, dir = node.dir;\n        int mirrorsPUsed = node.mirrorsPUsed, mirrorsQUsed = node.mirrorsQUsed;\n\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n\n        if (nx < 0 || ny < 0 || nx >= n || ny >= m || grid[nx][ny] == -1)\n            continue;\n\n        // Try to proceed without placing a mirror\n        if (dist[nx][ny][dir] > dist[x][y][dir]) {\n            dist[nx][ny][dir] = dist[x][y][dir];\n            queue[tail++] = (Node) { nx, ny, dir, mirrorsPUsed, mirrorsQUsed };\n            tail %= queueSize;\n        }\n\n        // Attempt to place a type P mirror\n        if (mirrorsPUsed < A) {\n            int newDir = (dir + 1) % 4;\n            if (dist[x][y][newDir] > dist[x][y][dir] + 1) {\n                dist[x][y][newDir] = dist[x][y][dir] + 1;\n                queue[tail++] = (Node) { x, y, newDir, mirrorsPUsed + 1, mirrorsQUsed };\n                tail %= queueSize;\n            }\n        }\n\n        // Attempt to place a type Q mirror\n        if (mirrorsQUsed < A) {\n            int newDir = (dir + 3) % 4;\n            if (dist[x][y][newDir] > dist[x][y][dir] + 1) {\n                dist[x][y][newDir] = dist[x][y][dir] + 1;\n                queue[tail++] = (Node) { x, y, newDir, mirrorsPUsed, mirrorsQUsed + 1 };\n                tail %= queueSize;\n            }\n        }\n    }\n\n    int minMirrors = INF;\n    for (int d = 0; d < 4; ++d)\n        if (dist[ex][ey][d] < minMirrors)\n            minMirrors = dist[ex][ey][d];\n\n    if (minMirrors == INF)\n        printf(\"Impossible\\n\");\n    else\n        printf(\"%d\\n\", minMirrors);\n}\n\nint main() {\n    int n, m, a, ex, ey, lx, ly, lxDir;\n    // Assuming 0 for empty, -1 for obstacle\n    scanf(\"%d%d%d\", &n, &m, &a);\n    // Initialize the grid\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            scanf(\"%d\", &grid[i][j]);\n\n    // Positions and initial direction (0 = N, 1 = E, 2 = S, 3 = W)\n    scanf(\"%d%d\", &lx, &ly);\n    scanf(\"%d\", &lxDir);\n    scanf(\"%d%d\", &ex, &ey);\n\n    bfs(lx, ly, lxDir, ex, ey, n, m, a);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:32:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport sys\n\ndef solve(N, M, laser_x, laser_y, laser_dir, creature_x, creature_y, P, Q):\n    # Define possible mirror types and rotations\n    mirror_types = [('P', [45, 225]), ('Q', [135, 315])]\n    \n    # Define initial directions\n    directions = {\n        0: (0, 1),   # East\n        1: (1, 0),   # South \n        2: (0, -1),  # West\n        3: (-1, 0)   # North\n    }\n    \n    # Check if point is within grid\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n    \n    # State representation for BFS\n    class State:\n        def __init__(self, x, y, dir, p_used, q_used):\n            self.x = x\n            self.y = y\n            self.dir = dir\n            self.p_used = p_used\n            self.q_used = q_used\n    \n    # BFS to find minimum mirrors\n    def bfs():\n        visited = set()\n        queue = deque([State(laser_x, laser_y, laser_dir, 0, 0)])\n        \n        while queue:\n            curr = queue.popleft()\n            \n            # Check if creature is killed\n            if curr.x == creature_x and curr.y == creature_y:\n                return curr.p_used + curr.q_used\n            \n            # State key to avoid revisiting\n            key = (curr.x, curr.y, curr.dir, curr.p_used, curr.q_used)\n            if key in visited:\n                continue\n            visited.add(key)\n            \n            # Move in current direction\n            dx, dy = directions[curr.dir]\n            nx, ny = curr.x + dx, curr.y + dy\n            \n            # Continue if new point is valid\n            if is_valid(nx, ny):\n                queue.append(State(nx, ny, curr.dir, curr.p_used, curr.q_used))\n            \n            # Try placing mirrors\n            for mirror_type, angles in mirror_types:\n                for angle in angles:\n                    if mirror_type == 'P' and curr.p_used >= P:\n                        continue\n                    if mirror_type == 'Q' and curr.q_used >= Q:\n                        continue\n                    \n                    # Calculate new direction after mirror reflection\n                    new_dir = (curr.dir + (1 if angle == 45 or angle == 135 else 3)) % 4\n                    \n                    # Update mirror usage count\n                    if mirror_type == 'P':\n                        queue.append(State(curr.x, curr.y, new_dir, curr.p_used + 1, curr.q_used))\n                    else:\n                        queue.append(State(curr.x, curr.y, new_dir, curr.p_used, curr.q_used + 1))\n        \n        return -1  # Cannot kill creature\n    \n    return bfs()\n\n# Read input\nN, M = map(int, input().split())\nlaser_x, laser_y, laser_dir = map(int, input().split())\ncreature_x, creature_y = map(int, input().split())\nP, Q = map(int, input().split())\n\n# Adjust coordinates to 0-based indexing\nlaser_x -= 1\nlaser_y -= 1\ncreature_x -= 1\ncreature_y -= 1\n\n# Solve and print result\nresult = solve(N, M, laser_x, laser_y, laser_dir, creature_x, creature_y, P, Q)\nprint(result)",
    "timestamp": "2025-08-13 06:33:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    N, M = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(N)]\n    A = int(input())\n    \n    # Find laser and creature positions\n    laser_pos = None\n    creature_pos = None\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'L':\n                laser_pos = (i, j)\n            elif grid[i][j] == 'X':\n                creature_pos = (i, j)\n    \n    # Directions: 0=right, 1=down, 2=left, 3=up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    # Determine initial direction\n    # Laser direction is stored in the grid as '>', 'v', '<', '^'\n    lx, ly = laser_pos\n    initial_dir = -1\n    if grid[lx][ly] == '>':\n        initial_dir = 0\n    elif grid[lx][ly] == 'v':\n        initial_dir = 1\n    elif grid[lx][ly] == '<':\n        initial_dir = 2\n    elif grid[lx][ly] == '^':\n        initial_dir = 3\n    \n    # Priority queue: (mirrors_used, x, y, dir, p_left, q_left)\n    heap = []\n    heapq.heappush(heap, (0, lx, ly, initial_dir, A, A))\n    \n    # Visited: (x, y, dir, p_left, q_left) -> mirrors_used\n    visited = {}\n    visited[(lx, ly, initial_dir, A, A)] = 0\n    \n    found = False\n    result = -1\n    \n    while heap:\n        mirrors, x, y, dir, p_left, q_left = heapq.heappop(heap)\n        if (x, y) == creature_pos:\n            found = True\n            result = mirrors\n            break\n        \n        if mirrors > visited.get((x, y, dir, p_left, q_left), float('inf')):\n            continue\n        \n        # Move straight\n        dx, dy = directions[dir]\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#':\n            key = (nx, ny, dir, p_left, q_left)\n            if key not in visited or mirrors < visited[key]:\n                visited[key] = mirrors\n                heapq.heappush(heap, (mirrors, nx, ny, dir, p_left, q_left))\n        \n        # Try placing P mirror (45 or 225 degrees)\n        if p_left > 0:\n            new_dir1 = (dir - 1) % 4\n            new_dir2 = (dir + 1) % 4\n            for new_dir in [new_dir1, new_dir2]:\n                dx, dy = directions[new_dir]\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#':\n                    key = (nx, ny, new_dir, p_left - 1, q_left)\n                    if key not in visited or mirrors + 1 < visited[key]:\n                        visited[key] = mirrors + 1\n                        heapq.heappush(heap, (mirrors + 1, nx, ny, new_dir, p_left - 1, q_left))\n        \n        # Try placing Q mirror (135 or 315 degrees)\n        if q_left > 0:\n            new_dir1 = (dir - 1) % 4\n            new_dir2 = (dir + 1) % 4\n            for new_dir in [new_dir1, new_dir2]:\n                dx, dy = directions[new_dir]\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#':\n                    key = (nx, ny, new_dir, p_left, q_left - 1)\n                    if key not in visited or mirrors + 1 < visited[key]:\n                        visited[key] = mirrors + 1\n                        heapq.heappush(heap, (mirrors + 1, nx, ny, new_dir, p_left, q_left - 1))\n    \n    print(result if found else -1)\n\nsolve()",
    "timestamp": "2025-08-13 06:33:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nconst int MAXN = 100, MAXM = 100;\nconst int DIRECTIONS = 4;\nconst int INF = 1e9;\n\nstruct State {\n    int x, y, dir, pUsed, qUsed;\n};\n\nint dx[DIRECTIONS] = {1, 0, -1, 0}; // E, N, W, S\nint dy[DIRECTIONS] = {0, -1, 0, 1};\n\nint reflectP[DIRECTIONS] = {3, 2, 1, 0}; // Reflection mappings for type P mirror\nint reflectQ[DIRECTIONS] = {1, 0, 3, 2}; // Reflection mappings for type Q mirror\n\nint grid[MAXN][MAXM];\nint dist[MAXN][MAXM][DIRECTIONS][11][11];\n\nbool isValid(int x, int y, int N, int M) {\n    return x >= 0 && x < M && y >= 0 && y < N;\n}\n\nint main() {\n    int N, M, A;\n    cin >> N >> M >> A;\n\n    int laserX, laserY, laserDir;\n    cin >> laserY >> laserX >> laserDir;\n    laserDir--; // Convert to 0-index\n\n    int creatureX, creatureY;\n    cin >> creatureY >> creatureX;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    queue<State> q;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            for (int d = 0; d < DIRECTIONS; d++) {\n                for (int p = 0; p <= A; p++) {\n                    for (int q = 0; q <= A; q++) {\n                        dist[i][j][d][p][q] = INF;\n                    }\n                }\n            }\n        }\n    }\n\n    q.push({laserX, laserY, laserDir, 0, 0});\n    dist[laserY][laserX][laserDir][0][0] = 0;\n\n    while (!q.empty()) {\n        auto cur = q.front();\n        q.pop();\n\n        int x = cur.x, y = cur.y, dir = cur.dir, pUsed = cur.pUsed, qUsed = cur.qUsed;\n        int curDist = dist[y][x][dir][pUsed][qUsed];\n\n        if (x == creatureX && y == creatureY) {\n            cout << curDist << endl;\n            return 0;\n        }\n\n        int nx = x + dx[dir], ny = y + dy[dir];\n        if (isValid(nx, ny, N, M) && grid[ny][nx] == 0 && curDist < dist[ny][nx][dir][pUsed][qUsed]) {\n            dist[ny][nx][dir][pUsed][qUsed] = curDist;\n            q.push({nx, ny, dir, pUsed, qUsed});\n        }\n\n        if (pUsed < A) {\n            int newDirP = reflectP[dir];\n            if (curDist + 1 < dist[y][x][newDirP][pUsed + 1][qUsed]) {\n                dist[y][x][newDirP][pUsed + 1][qUsed] = curDist + 1;\n                q.push({x, y, newDirP, pUsed + 1, qUsed});\n            }\n        }\n\n        if (qUsed < A) {\n            int newDirQ = reflectQ[dir];\n            if (curDist + 1 < dist[y][x][newDirQ][pUsed][qUsed + 1]) {\n                dist[y][x][newDirQ][pUsed][qUsed + 1] = curDist + 1;\n                q.push({x, y, newDirQ, pUsed, qUsed + 1});\n            }\n        }\n    }\n\n    cout << -1 << endl; // If reached here, it means it's impossible\n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:40"
  }
]