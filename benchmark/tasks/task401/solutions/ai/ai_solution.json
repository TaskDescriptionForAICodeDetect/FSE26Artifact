[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define SIZE 8\n\nchar grid[SIZE][SIZE];\n\ntypedef struct {\n    int x, y;\n} Position;\n\nbool inBounds(int x, int y) {\n    return x >= 0 && x < SIZE && y >= 0 && y < SIZE;\n}\n\nint countFlips(int x, int y, char player, bool flip) {\n    int total = 0;\n    char opponent = (player == 'C') ? 'M' : 'C';\n    int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n    for (int d = 0; d < 8; d++) {\n        int nx = x + dx[d], ny = y + dy[d];\n        int count = 0;\n        while (inBounds(nx, ny) && grid[nx][ny] == opponent) {\n            count++;\n            nx += dx[d];\n            ny += dy[d];\n        }\n        if (inBounds(nx, ny) && grid[nx][ny] == player && count > 0) {\n            total += count;\n            if (flip) {\n                nx = x + dx[d];\n                ny = y + dy[d];\n                while (grid[nx][ny] == opponent) {\n                    grid[nx][ny] = player;\n                    nx += dx[d];\n                    ny += dy[d];\n                }\n            }\n        }\n    }\n    return total;\n}\n\nPosition findBestMove(char player) {\n    Position best = {-1, -1};\n    int maxFlips = 0;\n    bool isMami = (player == 'M');\n\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (grid[i][j] != '.') continue;\n            int flips = countFlips(i, j, player, false);\n            if (flips > 0) {\n                if (flips > maxFlips) {\n                    maxFlips = flips;\n                    best.x = i;\n                    best.y = j;\n                } else if (flips == maxFlips) {\n                    if (isMami) {\n                        if (i > best.x || (i == best.x && j < best.y)) {\n                            best.x = i;\n                            best.y = j;\n                        }\n                    } else {\n                        if (i < best.x || (i == best.x && j > best.y)) {\n                            best.x = i;\n                            best.y = j;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return best;\n}\n\nvoid playGame() {\n    bool gameOver = false;\n    while (!gameOver) {\n        gameOver = true;\n        Position mamiMove = findBestMove('M');\n        if (mamiMove.x != -1) {\n            grid[mamiMove.x][mamiMove.y] = 'M';\n            countFlips(mamiMove.x, mamiMove.y, 'M', true);\n            gameOver = false;\n        }\n        Position charlotteMove = findBestMove('C');\n        if (charlotteMove.x != -1) {\n            grid[charlotteMove.x][charlotteMove.y] = 'C';\n            countFlips(charlotteMove.x, charlotteMove.y, 'C', true);\n            gameOver = false;\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            scanf(\" %c\", &grid[i][j]);\n        }\n    }\n    playGame();\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            printf(\"%c\", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int SIZE = 8;\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nchar grid[SIZE][SIZE];\n\nstruct Move {\n    int x, y, flips;\n};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < SIZE && y >= 0 && y < SIZE;\n}\n\nint countFlips(int x, int y, char player) {\n    int total = 0;\n    for (int d = 0; d < 8; ++d) {\n        int nx = x + dx[d], ny = y + dy[d];\n        int cnt = 0;\n        while (isValid(nx, ny) && grid[nx][ny] != '.' && grid[nx][ny] != player) {\n            cnt++;\n            nx += dx[d];\n            ny += dy[d];\n        }\n        if (isValid(nx, ny) && grid[nx][ny] == player && cnt > 0) {\n            total += cnt;\n        }\n    }\n    return total;\n}\n\nvoid flipCookies(int x, int y, char player) {\n    for (int d = 0; d < 8; ++d) {\n        int nx = x + dx[d], ny = y + dy[d];\n        int cnt = 0;\n        while (isValid(nx, ny) && grid[nx][ny] != '.' && grid[nx][ny] != player) {\n            cnt++;\n            nx += dx[d];\n            ny += dy[d];\n        }\n        if (isValid(nx, ny) && grid[nx][ny] == player && cnt > 0) {\n            nx = x + dx[d];\n            ny = y + dy[d];\n            while (grid[nx][ny] != player) {\n                grid[nx][ny] = player;\n                nx += dx[d];\n                ny += dy[d];\n            }\n        }\n    }\n}\n\nvector<Move> getValidMoves(char player) {\n    vector<Move> moves;\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            if (grid[i][j] == '.') {\n                int flips = countFlips(i, j, player);\n                if (flips > 0) {\n                    moves.push_back({i, j, flips});\n                }\n            }\n        }\n    }\n    return moves;\n}\n\nbool compareMami(const Move &a, const Move &b) {\n    if (a.flips != b.flips) return a.flips > b.flips;\n    if (a.x != b.x) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool compareCharlotte(const Move &a, const Move &b) {\n    if (a.flips != b.flips) return a.flips > b.flips;\n    if (a.x != b.x) return a.x > b.x;\n    return a.y > b.y;\n}\n\nbool playTurn(char player) {\n    vector<Move> moves = getValidMoves(player);\n    if (moves.empty()) return false;\n    \n    if (player == 'M') {\n        sort(moves.begin(), moves.end(), compareMami);\n    } else {\n        sort(moves.begin(), moves.end(), compareCharlotte);\n    }\n    \n    Move best = moves[0];\n    grid[best.x][best.y] = player;\n    flipCookies(best.x, best.y, player);\n    return true;\n}\n\nint main() {\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    bool moved;\n    do {\n        moved = false;\n        if (playTurn('M')) moved = true;\n        if (playTurn('C')) moved = true;\n    } while (moved);\n    \n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CookieGame {\n    static final int SIZE = 8;\n    static final int[][] DIRECTIONS = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1},           {0, 1},\n        {1, -1},  {1, 0}, {1, 1}\n    };\n\n    static class Move {\n        int row, col, flips;\n\n        Move(int row, int col, int flips) {\n            this.row = row;\n            this.col = col;\n            this.flips = flips;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[][] grid = new char[SIZE][SIZE];\n        for (int i = 0; i < SIZE; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < SIZE; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n\n        boolean gameOver = false;\n        while (!gameOver) {\n            boolean mamiPlayed = playMove(grid, 'M', true);\n            boolean charlottePlayed = playMove(grid, 'C', false);\n            gameOver = !mamiPlayed && !charlottePlayed;\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                System.out.print(grid[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    private static boolean playMove(char[][] grid, char player, boolean isMami) {\n        List<Move> moves = new ArrayList<>();\n\n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (grid[i][j] == '.') {\n                    int totalFlips = 0;\n                    for (int[] dir : DIRECTIONS) {\n                        int flips = countFlips(grid, i, j, dir[0], dir[1], player);\n                        totalFlips += flips;\n                    }\n                    if (totalFlips > 0) {\n                        moves.add(new Move(i, j, totalFlips));\n                    }\n                }\n            }\n        }\n\n        if (moves.isEmpty()) {\n            return false;\n        }\n\n        moves.sort((a, b) -> {\n            if (a.flips != b.flips) {\n                return Integer.compare(b.flips, a.flips);\n            }\n            if (isMami) {\n                if (a.row != b.row) {\n                    return Integer.compare(b.row, a.row);\n                } else {\n                    return Integer.compare(a.col, b.col);\n                }\n            } else {\n                if (a.row != b.row) {\n                    return Integer.compare(a.row, b.row);\n                } else {\n                    return Integer.compare(b.col, a.col);\n                }\n            }\n        });\n\n        Move bestMove = moves.get(0);\n        int i = bestMove.row;\n        int j = bestMove.col;\n        grid[i][j] = player;\n\n        for (int[] dir : DIRECTIONS) {\n            int flips = countFlips(grid, i, j, dir[0], dir[1], player);\n            if (flips > 0) {\n                flipCookies(grid, i, j, dir[0], dir[1], player, flips);\n            }\n        }\n\n        return true;\n    }\n\n    private static int countFlips(char[][] grid, int i, int j, int di, int dj, char player) {\n        int flips = 0;\n        int r = i + di;\n        int c = j + dj;\n        while (r >= 0 && r < SIZE && c >= 0 && c < SIZE && grid[r][c] != '.' && grid[r][c] != player) {\n            flips++;\n            r += di;\n            c += dj;\n        }\n        if (r < 0 || r >= SIZE || c < 0 || c >= SIZE || grid[r][c] != player) {\n            return 0;\n        }\n        return flips;\n    }\n\n    private static void flipCookies(char[][] grid, int i, int j, int di, int dj, char player, int flips) {\n        int r = i + di;\n        int c = j + dj;\n        for (int k = 0; k < flips; k++) {\n            grid[r][c] = player;\n            r += di;\n            c += dj;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:26:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CookieGame {\n    private static final int BOARD_SIZE = 8;\n    private static final int[] DX = {0, 0, 1, -1, 1, 1, -1, -1};\n    private static final int[] DY = {1, -1, 0, 0, 1, -1, 1, -1};\n\n    public static int[][] playCookieGame(int[][] board) {\n        boolean canPlay;\n        do {\n            canPlay = false;\n            // Mami's turn (chocolate)\n            int[] mamiBestMove = findBestMove(board, 2, 1);\n            if (mamiBestMove != null) {\n                makeMove(board, mamiBestMove[0], mamiBestMove[1], 2, 1);\n                canPlay = true;\n            }\n\n            // Candy Witch's turn (cheese)\n            int[] witchBestMove = findBestMove(board, 1, 2);\n            if (witchBestMove != null) {\n                makeMove(board, witchBestMove[0], witchBestMove[1], 1, 2);\n                canPlay = true;\n            }\n        } while (canPlay);\n\n        return board;\n    }\n\n    private static int[] findBestMove(int[][] board, int player, int opponent) {\n        int maxFlipped = 0;\n        int[] bestMove = null;\n\n        for (int row = 0; row < BOARD_SIZE; row++) {\n            for (int col = 0; col < BOARD_SIZE; col++) {\n                if (board[row][col] != 0) continue;\n\n                int flippedCount = countFlippableCookies(board, row, col, player, opponent);\n                if (flippedCount > maxFlipped) {\n                    maxFlipped = flippedCount;\n                    bestMove = new int[]{row, col};\n                } else if (flippedCount == maxFlipped) {\n                    bestMove = chooseBetterMove(bestMove, new int[]{row, col}, player);\n                }\n            }\n        }\n\n        return maxFlipped > 0 ? bestMove : null;\n    }\n\n    private static int countFlippableCookies(int[][] board, int row, int col, int player, int opponent) {\n        int totalFlipped = 0;\n        for (int d = 0; d < 8; d++) {\n            totalFlipped += countFlippableInDirection(board, row, col, player, opponent, DX[d], DY[d]);\n        }\n        return totalFlipped;\n    }\n\n    private static int countFlippableInDirection(int[][] board, int row, int col, int player, int opponent, int dx, int dy) {\n        int x = row + dx, y = col + dy;\n        int flipped = 0;\n\n        while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[x][y] == opponent) {\n            flipped++;\n            x += dx;\n            y += dy;\n        }\n\n        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE || board[x][y] != player) {\n            flipped = 0;\n        }\n\n        return flipped;\n    }\n\n    private static void makeMove(int[][] board, int row, int col, int player, int opponent) {\n        board[row][col] = player;\n        for (int d = 0; d < 8; d++) {\n            flipCookiesInDirection(board, row, col, player, opponent, DX[d], DY[d]);\n        }\n    }\n\n    private static void flipCookiesInDirection(int[][] board, int row, int col, int player, int opponent, int dx, int dy) {\n        int x = row + dx, y = col + dy;\n        List<int[]> toFlip = new ArrayList<>();\n\n        while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[x][y] == opponent) {\n            toFlip.add(new int[]{x, y});\n            x += dx;\n            y += dy;\n        }\n\n        if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[x][y] == player) {\n            for (int[] pos : toFlip) {\n                board[pos[0]][pos[1]] = player;\n            }\n        }\n    }\n\n    private static int[] chooseBetterMove(int[] move1, int[] move2, int player) {\n        if (player == 2) { // Mami\n            return move1[0] > move2[0] ? move1 :\n                   move1[0] < move2[0] ? move2 :\n                   move1[1] < move2[1] ? move1 : move2;\n        } else { // Candy Witch\n            return move1[0] < move2[0] ? move1 :\n                   move1[0] > move2[0] ? move2 :\n                   move1[1] > move2[1] ? move1 : move2;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:26:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define GRID_SIZE 8\n#define EMPTY 0\n#define CHEESE 1\n#define CHOCOLATE 2\n\nint board[GRID_SIZE][GRID_SIZE];\nint directions[8][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}, {-1,-1}, {-1,1}, {1,-1}, {1,1}};\n\nint is_valid_move(int row, int col, int player) {\n    if (board[row][col] != EMPTY) return 0;\n    \n    for (int d = 0; d < 8; d++) {\n        int dr = directions[d][0], dc = directions[d][1];\n        int r = row + dr, c = col + dc;\n        int found_opponent = 0, found_own = 0;\n        \n        while (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {\n            if (board[r][c] == EMPTY) break;\n            if (board[r][c] == player) {\n                found_own = 1;\n                break;\n            }\n            if (board[r][c] != player) found_opponent = 1;\n            r += dr;\n            c += dc;\n        }\n        \n        if (found_opponent && found_own) return 1;\n    }\n    \n    return 0;\n}\n\nvoid flip_cookies(int row, int col, int player) {\n    for (int d = 0; d < 8; d++) {\n        int dr = directions[d][0], dc = directions[d][1];\n        int r = row + dr, c = col + dc;\n        int to_flip[64][2], flip_count = 0;\n        \n        while (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {\n            if (board[r][c] == EMPTY) break;\n            if (board[r][c] == player) {\n                for (int i = 0; i < flip_count; i++) {\n                    board[to_flip[i][0]][to_flip[i][1]] = player;\n                }\n                break;\n            }\n            to_flip[flip_count][0] = r;\n            to_flip[flip_count][1] = c;\n            flip_count++;\n            r += dr;\n            c += dc;\n        }\n    }\n    board[row][col] = player;\n}\n\nint find_best_move(int player) {\n    int best_row = -1, best_col = -1, max_flips = 0;\n    \n    for (int row = 0; row < GRID_SIZE; row++) {\n        for (int col = 0; col < GRID_SIZE; col++) {\n            if (is_valid_move(row, col, player)) {\n                int flips = 0;\n                for (int d = 0; d < 8; d++) {\n                    int dr = directions[d][0], dc = directions[d][1];\n                    int r = row + dr, c = col + dc;\n                    while (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {\n                        if (board[r][c] == EMPTY) break;\n                        if (board[r][c] == player) break;\n                        flips++;\n                        r += dr;\n                        c += dc;\n                    }\n                }\n                \n                if (player == CHOCOLATE) {\n                    if (flips > max_flips || \n                        (flips == max_flips && row > best_row) || \n                        (flips == max_flips && row == best_row && col < best_col)) {\n                        max_flips = flips;\n                        best_row = row;\n                        best_col = col;\n                    }\n                } else {\n                    if (flips > max_flips || \n                        (flips == max_flips && row < best_row) || \n                        (flips == max_flips && row == best_row && col > best_col)) {\n                        max_flips = flips;\n                        best_row = row;\n                        best_col = col;\n                    }\n                }\n            }\n        }\n    }\n    \n    return best_row * GRID_SIZE + best_col;\n}\n\nint game_over() {\n    for (int row = 0; row < GRID_SIZE; row++) {\n        for (int col = 0; col < GRID_SIZE; col++) {\n            if (is_valid_move(row, col, CHEESE) || is_valid_move(row, col, CHOCOLATE)) \n                return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int current_player = CHEESE;\n    \n    while (!game_over()) {\n        int move = find_best_move(current_player);\n        if (move == -1) break;\n        \n        int row = move / GRID_SIZE;\n        int col = move % GRID_SIZE;\n        \n        flip_cookies(row, col, current_player);\n        current_player = (current_player == CHEESE) ? CHOCOLATE : CHEESE;\n    }\n    \n    int cheese_count = 0, chocolate_count = 0;\n    for (int row = 0; row < GRID_SIZE; row++) {\n        for (int col = 0; col < GRID_SIZE; col++) {\n            if (board[row][col] == CHEESE) cheese_count++;\n            if (board[row][col] == CHOCOLATE) chocolate_count++;\n        }\n    }\n    \n    printf(\"%d %d\\n\", cheese_count, chocolate_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int BOARD_SIZE = 8;\nconst char EMPTY = '.';\nconst char CHEESE = 'C';\nconst char CHOCOLATE = 'H';\n\nclass CookieGame {\nprivate:\n    vector<vector<char>> board;\n    int directions[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}};\n\n    bool isValidPosition(int r, int c) {\n        return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;\n    }\n\n    bool canFlipInDirection(int r, int c, char player, int dr, int dc) {\n        int nr = r + dr, nc = c + dc;\n        bool foundOpponent = false;\n\n        while (isValidPosition(nr, nc) && board[nr][nc] != EMPTY) {\n            if (board[nr][nc] == player) return foundOpponent;\n            foundOpponent = true;\n            nr += dr;\n            nc += dc;\n        }\n        return false;\n    }\n\n    void flipCookiesInDirection(int r, int c, char player, int dr, int dc) {\n        int nr = r + dr, nc = c + dc;\n        while (isValidPosition(nr, nc) && board[nr][nc] != player && board[nr][nc] != EMPTY) {\n            board[nr][nc] = player;\n            nr += dr;\n            nc += dc;\n        }\n    }\n\n    bool hasValidMove(char player) {\n        for (int r = 0; r < BOARD_SIZE; r++) {\n            for (int c = 0; c < BOARD_SIZE; c++) {\n                if (board[r][c] != EMPTY) continue;\n                for (auto& dir : directions) {\n                    if (canFlipInDirection(r, c, player, dir[0], dir[1])) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    pair<int, int> findBestMove(char player) {\n        vector<pair<int, int>> validMoves;\n        for (int r = 0; r < BOARD_SIZE; r++) {\n            for (int c = 0; c < BOARD_SIZE; c++) {\n                if (board[r][c] != EMPTY) continue;\n                int flips = 0;\n                for (auto& dir : directions) {\n                    if (canFlipInDirection(r, c, player, dir[0], dir[1])) {\n                        flips++;\n                    }\n                }\n                if (flips > 0) {\n                    validMoves.push_back({r, c});\n                }\n            }\n        }\n\n        if (validMoves.empty()) return {-1, -1};\n\n        if (player == CHOCOLATE) {\n            sort(validMoves.begin(), validMoves.end(), [](const pair<int,int>& a, const pair<int,int>& b) {\n                return a.first > b.first || (a.first == b.first && a.second < b.second);\n            });\n        } else {\n            sort(validMoves.begin(), validMoves.end(), [](const pair<int,int>& a, const pair<int,int>& b) {\n                return a.first < b.first || (a.first == b.first && a.second > b.second);\n            });\n        }\n\n        return validMoves[0];\n    }\n\n    void placeCookie(int r, int c, char player) {\n        board[r][c] = player;\n        for (auto& dir : directions) {\n            if (canFlipInDirection(r, c, player, dir[0], dir[1])) {\n                flipCookiesInDirection(r, c, player, dir[0], dir[1]);\n            }\n        }\n    }\n\npublic:\n    CookieGame(vector<vector<char>> initialBoard) : board(initialBoard) {}\n\n    void play() {\n        char currentPlayer = CHOCOLATE;\n        while (hasValidMove(CHOCOLATE) || hasValidMove(CHEESE)) {\n            if (currentPlayer == CHOCOLATE) {\n                if (!hasValidMove(CHOCOLATE)) {\n                    currentPlayer = CHEESE;\n                    continue;\n                }\n                auto move = findBestMove(CHOCOLATE);\n                placeCookie(move.first, move.second, CHOCOLATE);\n                currentPlayer = CHEESE;\n            } else {\n                if (!hasValidMove(CHEESE)) {\n                    currentPlayer = CHOCOLATE;\n                    continue;\n                }\n                auto move = findBestMove(CHEESE);\n                placeCookie(move.first, move.second, CHEESE);\n                currentPlayer = CHOCOLATE;\n            }\n        }\n    }\n\n    void printBoard() {\n        for (auto& row : board) {\n            for (char cell : row) {\n                cout << cell;\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    vector<vector<char>> initialBoard(BOARD_SIZE, vector<char>(BOARD_SIZE, EMPTY));\n    \n    for (int i = 0; i < BOARD_SIZE; i++) {\n        string row;\n        cin >> row;\n        for (int j = 0; j < BOARD_SIZE; j++) {\n            initialBoard[i][j] = row[j];\n        }\n    }\n\n    CookieGame game(initialBoard);\n    game.play();\n    game.printBoard();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def check_flip(board, x, y, dx, dy, player):\n    i, j = x + dx, y + dy\n    opponent = 'C' if player == 'M' else 'M'\n    to_flip = []\n    while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == opponent:\n            to_flip.append((i, j))\n        elif board[i][j] == player:\n            return to_flip\n        else:\n            break\n        i += dx\n        j += dy\n    return []\n\ndef valid_moves(board, player):\n    moves = []\n    for x in range(8):\n        for y in range(8):\n            if board[x][y] == '.':\n                total_flipped = []\n                for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                    flipped = check_flip(board, x, y, dx, dy, player)\n                    if flipped:\n                        total_flipped.extend(flipped)\n                if total_flipped:\n                    moves.append((len(total_flipped), x, y, total_flipped))\n    return moves\n\ndef make_move(board, x, y, flips, player):\n    board[x][y] = player\n    for i, j in flips:\n        board[i][j] = player\n\ndef max_cookies_placement(board):\n    players = ['C', 'M']\n    while True:\n        any_move = False\n        for player in players:\n            moves = valid_moves(board, player)\n            if moves:\n                any_move = True\n                if player == 'C':\n                    _, x, y, flips = max(moves, key=lambda m: (m[0], -m[1], -m[2]))\n                else:\n                    _, x, y, flips = max(moves, key=lambda m: (m[0], m[1], m[2]))\n                make_move(board, x, y, flips, player)\n        if not any_move:\n            break\n    return board\n\n# Example usage:\ninitial_board = [\n    \"M.......\",\n    \"........\",\n    \"...C....\",\n    \"...M....\",\n    \"...C....\",\n    \"........\",\n    \"...C....\",\n    \"........\"\n]\n\nfinal_board = max_cookies_placement([list(row) for row in initial_board])\nfor row in final_board:\n    print(''.join(row))",
    "timestamp": "2025-08-13 06:18:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CookieGame {\n    private static final int SIZE = 8;\n    private static final char EMPTY = '.';\n    private static final char CHEESE = 'C';\n    private static final char CHOCOLATE = 'M';\n    private static final int[][] DIRECTIONS = { \n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}, // vertical and horizontal\n        {-1, -1}, {-1, 1}, {1, -1}, {1, 1} // diagonals\n    };\n\n    private static char[][] grid;\n\n    public static char[][] solve(char[][] initialGrid) {\n        grid = initialGrid;\n        boolean turnCheese = true;\n        \n        while (true) {\n            if (!playTurn(turnCheese ? CHEESE : CHOCOLATE, turnCheese ? CHOCOLATE : CHEESE)) {\n                break;\n            }\n            turnCheese = !turnCheese;\n        }\n        \n        return grid;\n    }\n\n    private static boolean playTurn(char currentPlayer, char opponent) {\n        int maxReplaced = 0;\n        int bestRow = -1, bestCol = -1;\n        \n        for (int row = 0; row < SIZE; row++) {\n            for (int col = 0; col < SIZE; col++) {\n                if (grid[row][col] == EMPTY) {\n                    int replaced = canReplace(row, col, currentPlayer, opponent);\n                    if (replaced > maxReplaced || \n                        (replaced == maxReplaced && isPreferred(row, col, currentPlayer))) {\n                        maxReplaced = replaced;\n                        bestRow = row;\n                        bestCol = col;\n                    }\n                }\n            }\n        }\n        \n        if (maxReplaced == 0) return false;\n        \n        placeCookie(bestRow, bestCol, currentPlayer, opponent);\n        return true;\n    }\n\n    private static boolean isPreferred(int row, int col, char currentPlayer) {\n        if (currentPlayer == CHEESE) {\n            return (row > bestRow || (row == bestRow && col > bestCol));\n        } else {\n            return (row < bestRow || (row == bestRow && col < bestCol));\n        }\n    }\n\n    private static int canReplace(int row, int col, char currentPlayer, char opponent) {\n        int totalReplaced = 0;\n        \n        for (int[] dir : DIRECTIONS) {\n            totalReplaced += countReplacable(row, col, dir[0], dir[1], currentPlayer, opponent);\n        }\n        \n        return totalReplaced;\n    }\n\n    private static int countReplacable(int row, int col, int dr, int dc, char currentPlayer, char opponent) {\n        int r = row + dr, c = col + dc;\n        int count = 0;\n\n        while (isValid(r, c) && grid[r][c] == opponent) {\n            count++;\n            r += dr;\n            c += dc;\n        }\n\n        if (!isValid(r, c) || grid[r][c] != currentPlayer) {\n            return 0;\n        }\n\n        return count;\n    }\n\n    private static void placeCookie(int row, int col, char currentPlayer, char opponent) {\n        grid[row][col] = currentPlayer;\n\n        for (int[] dir : DIRECTIONS) {\n            int dr = dir[0], dc = dir[1];\n            int r = row + dr, c = col + dc, count = 0;\n\n            while (isValid(r, c) && grid[r][c] == opponent) {\n                count++;\n                r += dr;\n                c += dc;\n            }\n\n            if (!isValid(r, c) || grid[r][c] != currentPlayer) continue;\n\n            r = row + dr;\n            c = col + dc;\n            while (count-- > 0) {\n                grid[r][c] = currentPlayer;\n                r += dr;\n                c += dc;\n            }\n        }\n    }\n\n    private static boolean isValid(int row, int col) {\n        return row >= 0 && row < SIZE && col >= 0 && col < SIZE;\n    }\n\n    public static void main(String[] args) {\n        char[][] initialGrid = {\n            { '.', '.', '.', '.', '.', '.', '.', '.' },\n            { '.', '.', '.', '.', '.', '.', '.', '.' },\n            { '.', '.', 'M', 'C', '.', '.', '.', '.' },\n            { '.', 'M', 'C', 'M', 'C', '.', '.', '.' },\n            { '.', '.', 'C', 'M', 'C', '.', '.', '.' },\n            { '.', '.', '.', '.', '.', '.', '.', '.' },\n            { '.', '.', '.', '.', '.', '.', '.', '.' },\n            { '.', '.', '.', '.', '.', '.', '.', '.' },\n        };\n\n        char[][] result = solve(initialGrid);\n\n        for (char[] row : result) {\n            System.out.println(Arrays.toString(row));\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:18:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define SIZE 8\n\ntypedef enum { EMPTY, CHEESE, CHOCOLATE } Cookie;\n\ntypedef struct {\n    int dx, dy;\n} Direction;\n\nDirection directions[] = {\n    {0, 1}, {1, 0}, {0, -1}, {-1, 0},\n    {1, 1}, {1, -1}, {-1, 1}, {-1, -1}\n};\n\nbool is_in_bounds(int x, int y) {\n    return x >= 0 && x < SIZE && y >= 0 && y < SIZE;\n}\n\nint capture_cookies(Cookie grid[SIZE][SIZE], int x, int y, Cookie myCookie, Cookie opponentCookie) {\n    int totalCaptured = 0;\n    for (int d = 0; d < 8; ++d) {\n        int count = 0;\n        int nx = x + directions[d].dx;\n        int ny = y + directions[d].dy;\n        \n        while (is_in_bounds(nx, ny) && grid[nx][ny] == opponentCookie) {\n            ++count;\n            nx += directions[d].dx;\n            ny += directions[d].dy;\n        }\n        \n        if (count > 0 && is_in_bounds(nx, ny) && grid[nx][ny] == myCookie) {\n            totalCaptured += count;\n            nx = x + directions[d].dx;\n            ny = y + directions[d].dy;\n            while (grid[nx][ny] == opponentCookie) {\n                grid[nx][ny] = myCookie;\n                nx += directions[d].dx;\n                ny += directions[d].dy;\n            }\n        }\n    }\n    return totalCaptured;\n}\n\nbool play_turn(Cookie grid[SIZE][SIZE], Cookie myCookie, Cookie opponentCookie) {\n    int bestCount = -1;\n    int bestX = -1, bestY = -1;\n    \n    for (int x = 0; x < SIZE; ++x) {\n        for (int y = 0; y < SIZE; ++y) {\n            if (grid[x][y] == EMPTY) {\n                Cookie tempGrid[SIZE][SIZE];\n                for (int i = 0; i < SIZE; ++i) \n                    for (int j = 0; j < SIZE; ++j) \n                        tempGrid[i][j] = grid[i][j];\n                \n                int captured = capture_cookies(tempGrid, x, y, myCookie, opponentCookie);\n                if (captured > 0) {\n                    if (myCookie == CHEESE) {\n                        if (captured > bestCount || (captured == bestCount && (x > bestX || (x == bestX && y > bestY)))) {\n                            bestCount = captured;\n                            bestX = x;\n                            bestY = y;\n                        }\n                    } else {\n                        if (captured > bestCount || (captured == bestCount && (x < bestX || (x == bestX && y < bestY)))) {\n                            bestCount = captured;\n                            bestX = x;\n                            bestY = y;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    if (bestCount > 0) {\n        capture_cookies(grid, bestX, bestY, myCookie, opponentCookie);\n        grid[bestX][bestY] = myCookie;\n        return true;\n    }\n    return false;\n}\n\nvoid play_game(Cookie grid[SIZE][SIZE]) {\n    bool moved;\n    do {\n        moved = false;\n        if (play_turn(grid, CHOCOLATE, CHEESE)) {\n            moved = true;\n        }\n        if (play_turn(grid, CHEESE, CHOCOLATE)) {\n            moved = true;\n        }\n    } while (moved);\n}\n\nint main() {\n    Cookie grid[SIZE][SIZE] = {\n        {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, CHOCOLATE, CHEESE, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, CHEESE, CHOCOLATE, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n        {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY}\n    };\n\n    play_game(grid);\n    \n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            if (grid[i][j] == EMPTY) printf(\".\");\n            else if (grid[i][j] == CHEESE) printf(\"O\");\n            else if (grid[i][j] == CHOCOLATE) printf(\"X\");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:18:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_cookie_game(initial_grid):\n    def is_valid_move(grid, row, col, player):\n        opponent = 'C' if player == 'M' else 'M'\n        directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]\n        \n        for dx, dy in directions:\n            x, y = row + dx, col + dy\n            found_opponent = False\n            captured = []\n            \n            while 0 <= x < 8 and 0 <= y < 8:\n                if grid[x][y] == opponent:\n                    found_opponent = True\n                    captured.append((x, y))\n                elif grid[x][y] == player and found_opponent:\n                    return captured\n                elif grid[x][y] == ' ' or grid[x][y] == player:\n                    break\n                x += dx\n                y += dy\n            \n        return []\n    \n    def make_move(grid, row, col, player):\n        grid[row][col] = player\n        captured = is_valid_move(grid, row, col, player)\n        for x, y in captured:\n            grid[x][y] = player\n        return grid\n    \n    def find_best_move(grid, player):\n        best_moves = []\n        max_captures = 0\n        \n        for row in range(8):\n            for col in range(8):\n                if grid[row][col] != ' ':\n                    continue\n                \n                captures = is_valid_move(grid, row, col, player)\n                \n                if captures:\n                    if len(captures) > max_captures:\n                        max_captures = len(captures)\n                        best_moves = [(row, col)]\n                    elif len(captures) == max_captures:\n                        best_moves.append((row, col))\n        \n        if not best_moves:\n            return None\n        \n        if player == 'M':\n            best_moves.sort(key=lambda x: (-x[0], x[1]))\n        else:\n            best_moves.sort(key=lambda x: (x[0], -x[1]))\n        \n        return best_moves[0]\n    \n    grid = [list(row) for row in initial_grid]\n    current_player = 'M'\n    \n    while True:\n        move = find_best_move(grid, current_player)\n        \n        if move is None:\n            if current_player == 'M':\n                current_player = 'C'\n                move = find_best_move(grid, current_player)\n                if move is None:\n                    break\n            else:\n                break\n        \n        row, col = move\n        grid = make_move(grid, row, col, current_player)\n        current_player = 'M' if current_player == 'C' else 'C'\n    \n    return [''.join(row) for row in grid]",
    "timestamp": "2025-08-13 06:19:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    # Directions: up, down, left, right, up-left, up-right, down-left, down-right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    \n    # Read initial grid\n    grid = [list(input().strip()) for _ in range(8)]\n    \n    current_player = 'W'  # W for Charlotte (cheese), B for Mami (chocolate)\n    \n    while True:\n        moves = []\n        max_flips = 0\n        \n        # Find all possible moves for current player\n        for i in range(8):\n            for j in range(8):\n                if grid[i][j] == '.':\n                    total_flips = 0\n                    for di, dj in directions:\n                        ni, nj = i + di, j + dj\n                        temp_flips = 0\n                        while 0 <= ni < 8 and 0 <= nj < 8 and grid[ni][nj] == ('B' if current_player == 'W' else 'W'):\n                            temp_flips += 1\n                            ni += di\n                            nj += dj\n                        if 0 <= ni < 8 and 0 <= nj < 8 and grid[ni][nj] == current_player and temp_flips > 0:\n                            total_flips += temp_flips\n                    if total_flips > 0:\n                        moves.append((i, j, total_flips))\n        \n        if not moves:\n            # No moves left, switch player or end game\n            if current_player == 'W':\n                current_player = 'B'\n                continue\n            else:\n                break\n        \n        # Find the best move based on player's preference\n        if current_player == 'W':\n            # Charlotte prefers lower rows, then right columns\n            moves.sort(key=lambda x: (-x[2], -x[0], x[1]))\n        else:\n            # Mami prefers higher rows, then left columns\n            moves.sort(key=lambda x: (-x[2], x[0], -x[1]))\n        \n        best_move = moves[0]\n        i, j, _ = best_move\n        \n        # Place the cookie\n        grid[i][j] = current_player\n        \n        # Flip opponent's cookies in all valid directions\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            to_flip = []\n            while 0 <= ni < 8 and 0 <= nj < 8 and grid[ni][nj] == ('B' if current_player == 'W' else 'W'):\n                to_flip.append((ni, nj))\n                ni += di\n                nj += dj\n            if 0 <= ni < 8 and 0 <= nj < 8 and grid[ni][nj] == current_player and to_flip:\n                for fi, fj in to_flip:\n                    grid[fi][fj] = current_player\n        \n        # Switch player\n        current_player = 'B' if current_player == 'W' else 'W'\n    \n    # Print the final grid\n    for row in grid:\n        print(''.join(row))\n\nsolve()",
    "timestamp": "2025-08-13 06:19:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 8;\nconst char CHEESE = 'C', CHOCOLATE = 'M', EMPTY = '-';\nconst int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nbool inBounds(int x, int y) {\n    return x >= 0 && y >= 0 && x < N && y < N;\n}\n\nbool validMove(vector<vector<char>>& board, char player, int x, int y) {\n    char opponent = (player == CHEESE) ? CHOCOLATE : CHEESE;\n    if (board[x][y] != EMPTY) return false;\n\n    for (int dir = 0; dir < 8; ++dir) {\n        int cx = x + dx[dir], cy = y + dy[dir];\n        bool hasOpponent = false;\n        while (inBounds(cx, cy) && board[cx][cy] == opponent) {\n            cx += dx[dir], cy += dy[dir];\n            hasOpponent = true;\n        }\n        if (hasOpponent && inBounds(cx, cy) && board[cx][cy] == player) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint scoreMove(vector<vector<char>>& board, char player, int x, int y) {\n    char opponent = (player == CHEESE) ? CHOCOLATE : CHEESE;\n    int score = 0;\n    for (int dir = 0; dir < 8; ++dir) {\n        int cx = x + dx[dir], cy = y + dy[dir];\n        vector<pair<int, int>> toFlip;\n        while (inBounds(cx, cy) && board[cx][cy] == opponent) {\n            toFlip.emplace_back(cx, cy);\n            cx += dx[dir], cy += dy[dir];\n        }\n        if (!toFlip.empty() && inBounds(cx, cy) && board[cx][cy] == player) {\n            score += toFlip.size();\n        }\n    }\n    return score;\n}\n\nvoid placeCookie(vector<vector<char>>& board, char player, int x, int y) {\n    char opponent = (player == CHEESE) ? CHOCOLATE : CHEESE;\n    board[x][y] = player;\n    for (int dir = 0; dir < 8; ++dir) {\n        int cx = x + dx[dir], cy = y + dy[dir];\n        vector<pair<int, int>> toFlip;\n        while (inBounds(cx, cy) && board[cx][cy] == opponent) {\n            toFlip.emplace_back(cx, cy);\n            cx += dx[dir], cy += dy[dir];\n        }\n        if (!toFlip.empty() && inBounds(cx, cy) && board[cx][cy] == player) {\n            for (const auto& p : toFlip) {\n                board[p.first][p.second] = player;\n            }\n        }\n    }\n}\n\nbool playMove(vector<vector<char>>& board, char player) {\n    vector<tuple<int, int, int>> moves; // (score, x, y)\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (validMove(board, player, i, j)) {\n                int score = scoreMove(board, player, i, j);\n                moves.emplace_back(score, i, j);\n            }\n        }\n    }\n    if (moves.empty()) return false;\n\n    if (player == CHEESE) {\n        sort(moves.begin(), moves.end(), [](auto& a, auto& b) {\n            if (get<0>(a) != get<0>(b)) return get<0>(a) > get<0>(b);\n            if (get<1>(a) != get<1>(b)) return get<1>(a) > get<1>(b);\n            return get<2>(a) > get<2>(b);\n        });\n    } else {\n        sort(moves.begin(), moves.end(), [](auto& a, auto& b) {\n            if (get<0>(a) != get<0>(b)) return get<0>(a) > get<0>(b);\n            if (get<1>(a) != get<1>(b)) return get<1>(a) < get<1>(b);\n            return get<2>(a) < get<2>(b);\n        });\n    }\n\n    auto [score, x, y] = moves[0];\n    placeCookie(board, player, x, y);\n    return true;\n}\n\nint main() {\n    vector<vector<char>> board(N, vector<char>(N));\n    for (auto& row : board) {\n        for (auto& cell : row) {\n            cin >> cell;\n        }\n    }\n\n    char currentPlayer = CHOCOLATE;\n    while (playMove(board, currentPlayer) || playMove(board, currentPlayer == CHOCOLATE ? CHEESE : CHOCOLATE)) {\n        currentPlayer = (currentPlayer == CHOCOLATE) ? CHEESE : CHOCOLATE;\n    }\n\n    for (const auto& row : board) {\n        for (const auto& cell : row) {\n            cout << cell;\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:20"
  }
]