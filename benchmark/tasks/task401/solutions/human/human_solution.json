[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nchar d[10][10];\n\nint search(int y, int x,char c){\n\tint ret = 0;\n\trep(i, 8)\n\t\tfor (int k = 1;; k++){\n\t\t\tint ty = y + dy[i] * k, tx = x + dx[i] * k;\n\t\t\tif (!cheak(tx, ty, 8, 8) || d[ty][tx] == '.')break;\n\t\t\tif (d[ty][tx] == c){\n\t\t\t\tfor (int j = k - 1; j >= 1; j--){\n\t\t\t\t\tint cty = y + dy[i] * j, ctx = x + dx[i] * j;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn ret;\n}\n\nvoid setd(int y, int x, char c){\n\n\td[y][x] = c;\n\trep(i, 8)\n\tfor (int k = 1;; k++){\n\t\tint ty = y + dy[i] * k, tx = x + dx[i] * k;\n\t\tif (!cheak(tx, ty, 8, 8) || d[ty][tx] == '.')break;\n\t\tif (d[ty][tx] == c){\n\t\t\tfor (int j = k - 1; j >= 1; j--){\n\t\t\t\tint cty = y + dy[i] * j, ctx = x + dx[i] * j;\n\t\t\t\td[cty][ctx] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\trep(y, 8)rep(x, 8){\n\t\tcin >> d[y][x];\n\t}\n\n\tfor (int i = 0;i < 64 * 10;i++){\n\t\tchar c = 'o';\n\t\tif (i % 2)c = 'x';\n\n\t\tbool f = true;\n\t\tint ty = (c == 'o' ? 8 : -1), tx = (c == 'o' ? 8 : -1); int val = 0;\n\t\trep(y, 8)rep(x, 8)if(d[y][x] == '.'){\n\t\t\tint t = search(y, x, c);\n\t\t\tif (t)\n\t\t\tif ((c == 'o' && (val < t || ((val == t && y < ty) || (val == t && y == ty && x < tx)))) || \n\t\t\t    (c == 'x' && (val < t || ((val == t && y > ty) || (val == t && y == ty && x > tx))))){\n\t\t\t\tval = t; ty = y; tx = x; f = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!f){\n\t\t\tsetd(ty, tx, c);\n\t\t}\n\t}\n\n\trep(y, 8){\n\t\trep(x, 8){\n\t\t\tcout << d[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\n\n/*}}}*/\n\nchar another_cake(char c)\n{\n\tif (c == 'o') {\n\t\treturn 'x';\n\t} else {\n\t\treturn 'o';\n\t}\n}\n\nbool in_field(P p)\n{\n\treturn (0 <= p.Y && p.Y < 8) && (0 <= p.X && p.X < 8);\n}\n\nint dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint put_cake(VVC* field, int y, int x, char cake, bool dry_run)\n{\n\tint turned = 0;\n\tREP (d, 8) {\n\t\tint ny = y + dy[d], nx = dx[d];\n\t\tvector<P> positions;\n\t\twhile (in_field(P(ny, nx)) && (*field)[ny][nx] == another_cake(cake)) {\n\t\t\tpositions.PB(P(ny, nx));\n\t\t\tny += dy[d]; nx += dx[d];\n\t\t}\n\t\tif (in_field(P(ny, nx)) && (*field)[ny][nx] == cake) {\n\t\t\tturned += positions.size();\n\t\t\tif (!dry_run) {\n\t\t\t\tEACH (positions, pos) {\n\t\t\t\t\t(*field)[(*pos).Y][(*pos).X] = cake;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn turned;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tVVC field(8, VC(8));\n\tREP (i, 8) {\n\t\tREP (j, 8) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\twhile (true) {\n\t\t// Mami\n\t\tint m_max = 0;\n\t\tP m_pos = P(-1, -1);\n\t\tREP (i, 8) {\n\t\t\tREP (j, 8) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tint count = put_cake(&field, i, j, 'o', true);\n\t\t\t\t\tif (count > m_max) {\n\t\t\t\t\t\tm_max = count;\n\t\t\t\t\t\tm_pos = P(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (m_max > 0) {\n\t\t\tput_cake(&field, m_pos.Y, m_pos.X, 'o', false);\n\t\t}\n\n\t\t// Witch\n\t\tint w_max = 0;\n\t\tP w_pos = P(-1, -1);\n\t\tREP (i, 8) {\n\t\t\tREP (j, 8) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tint count = put_cake(&field, i, j, 'x', true);\n\t\t\t\t\tif (count >= w_max) {\n\t\t\t\t\t\tw_max = count;\n\t\t\t\t\t\tw_pos = P(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (w_max > 0) {\n\t\t\tput_cake(&field, w_pos.Y, w_pos.X, 'o', false);\n\t\t}\n\n\t\tif (m_max == 0 && w_max == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tREP (i, 8) {\n\t\tREP (j, 8) {\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nchar field[8][8];\n\nchar own[] = { 'o', 'x' };\nchar enemy[] = { 'x', 'o' };\n\nint dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 }, dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\nint countReverse(int x, int y, int turn) {\n\tif (field[y][x] != '.') return 0;\n\tint sum = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint nx = x, ny = y;\n\t\tint cnt = 0;\n\t\tbool ok = true;\n\t\twhile (ok) {\n\t\t\tnx += dx[i], ny += dy[i];\n\t\t\tif (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) ok = false;\n\t\t\telse if (field[ny][nx] == '.') ok = false; //????????????\n\t\t\telse if (field[ny][nx] == own[turn]) break; //???????????????????¢????\n\t\t\telse if (field[ny][nx] == enemy[turn]) cnt++;\n\t\t}\n\t\tif (ok) sum += cnt;\n\t}\n\treturn sum;\n}\n\nvoid reverse(int x, int y, int turn) {\n\tif (field[y][x] != '.') return;\n\t//??????\n\tfield[y][x] = own[turn];\n\tfor (int i = 0; i < 8; i++) {\n\t\tint nx = x, ny = y;\n\t\tbool ok = true;\n\t\twhile (ok) {\n\t\t\tnx += dx[i], ny += dy[i];\n\t\t\tif (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) ok = false;\n\t\t\telse if (field[ny][nx] == '.') ok = false; //????????????\n\t\t\telse if (field[ny][nx] == own[turn]) break; //???????????????????¢????\n\t\t}\n\t\tif (ok) {\n\t\t\tnx = x, ny = y;\n\t\t\twhile (ok) {\n\t\t\t\tnx += dx[i], ny += dy[i];\n\t\t\t\tif (field[ny][nx] == own[turn]) break; //???????????????????¢????\n\t\t\t\telse if (field[ny][nx] == enemy[turn]) field[ny][nx] = own[turn]; //?????¢\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tstd::string s; std::cin >> s;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tfield[i][j] = s[j];\n\t\t}\n\t}\n\n\tint turn = 0;\n\tbool isReverse = false;\n\twhile (1) {\n\t\tisReverse = false;\n\t\tint max = 0, x, y;\n\t\tif (turn == 0) { //????????????\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tint cnt = countReverse(j, i, turn);\n\t\t\t\t\tif (max < cnt) {\n\t\t\t\t\t\tmax = cnt;\n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\tisReverse = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (max) reverse(x, y, turn);\n\t\tturn = !turn;\n\t\tmax = 0;\n\t\tif (turn == 1) { //CHARLOTTE \n\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\tfor (int j = 7; j >= 0; j--) {\n\t\t\t\t\tint cnt = countReverse(j, i, turn);\n\t\t\t\t\tif (max < cnt) {\n\t\t\t\t\t\tmax = cnt;\n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\tisReverse = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (max) reverse(x, y, turn);\n\t\tturn = !turn;\n\t\tif (!isReverse) break;//??????pass\n\t}\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tstd::cout << field[i][j];\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <array>\n#include <functional>\n#include <climits>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\nstruct range{\n\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\nint main() {\n\tarray<array<char, 10>, 10> T;\n\trange r8(1, 9);\n\tfor (int i: range(10))\n\t\tT[0][i] = T[9][i] = T[i][0] = T[i][9] = ' ';\n\tfor (auto i: r8) {\n\t\tfor (char j: r8)\n\t\t\tT[i][j] = gcu();\n\t\tgcu();\n\t}\n\tint dx[] {0, 1, 1, 1, 0, -1, -1, -1},\n\t\tdy[] {-1, -1, 0, 1, 1, 1, 0, -1};\n\tchar pt[] {'o', 'x'};\n\tfunction<bool(int, int, int, int)> flip{[&] (int x, int y, int k, int p) {\n\t\tx += dx[k], y += dy[k];\n\t\tif (T[y][x] != pt[!p])\n\t\t\treturn T[y][x] == pt[p];\n\t\tbool r = flip(x, y, k, p);\n\t\tif (r)\n\t\t\tT[y][x] = pt[p];\n\t\treturn r;\n\t}};\n\tfor (int p {}, b[2]{1, 1}; b[0] || b[1]; p ^= 1) {\n\t\tstruct { int c, x, y; } m {};\n\t\tfor (int i: r8)\n\t\t\tfor (int j: r8)\n\t\t\t\tif (T[i][j] == '.') {\n\t\t\t\t\tint c {};\n\t\t\t\t\tfor (int k: range(8)) {\n\t\t\t\t\t\tint d {}, x {j + dx[k]}, y {i + dy[k]};\n\t\t\t\t\t\tfor (; T[y][x] == pt[!p]; x += dx[k], y += dy[k])\n\t\t\t\t\t\t\td++;\n\t\t\t\t\t\tif (T[y][x] == pt[p])\n\t\t\t\t\t\t\tc += d;\n\t\t\t\t\t}\n\t\t\t\t\tif (c && ((p == 0 && c > m.c) || (p == 1 && c >= m.c)))\n\t\t\t\t\t\tm = {c, j, i};\n\t\t\t\t}\n\t\tif (m.c) {\n\t\t\tb[p] = 1;\n\t\t\tT[m.y][m.x] = pt[p];\n\t\t\tfor (int k: range(8))\n\t\t\t\tflip(m.x, m.y, k, p);\n\t\t} else\n\t\t\tb[p] = 0;\n\t}\n\tfor (int i: r8) {\n\t\tfor (int j: r8)\n\t\t\tout(T[i][j]);\n\t\toutl();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nint main()\n{\n\tchar a[10][10];\n\tmemset(a, 'a', sizeof a);\n\tFORI(i, 1, 8+1)\n\t{\n\t\tFORI(j, 1, 8+1)\n\t\t{\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tbool ok = true;\n\twhile (ok)\n\t{\n\t\tok = false;\n\t\tFOR(which, 2)\n\t\t{\n\t\t\tint n[10][10] = {};\n\t\t\tchar obj[] = \"xo\";\n\t\t\tFORI(i, 1, 8 + 1)\n\t\t\t{\n\t\t\t\tFORI(j, 1, 8 + 1)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][j] == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\tint x[8] = { -1,0,1,-1,1,-1,0,1 };\n\t\t\t\t\t\tint y[8] = { -1,-1,-1,0,0,1,1,1 };\n\t\t\t\t\t\tFOR(k, 8)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint X = i, Y = j;\n\t\t\t\t\t\t\tint dx = x[k], dy = y[k];\n\t\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\t\twhile (true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tX += dx; Y += dy;\n\t\t\t\t\t\t\t\tif (a[X][Y] == obj[which])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (a[X][Y] == '.'||a[X][Y]=='a')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn[i][j] += c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint maxi = 0,I,J;\n\t\t\tFORI(i, 1, 8 + 1)\n\t\t\t{\n\t\t\t\tFORI(j, 1, 8 + 1)\n\t\t\t\t{\n\t\t\t\t\tif ((!which&&maxi < n[i][j])||(which&&maxi<=n[i][j]))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxi = n[i][j];\n\t\t\t\t\t\tI = i; J = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxi != 0)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tint x[8] = { -1,0,1,-1,1,-1,0,1 };\n\t\t\t\tint y[8] = { -1,-1,-1,0,0,1,1,1 };\n\t\t\t\tFOR(k, 8)\n\t\t\t\t{\n\t\t\t\t\tint X = I, Y = J;\n\t\t\t\t\tint dx = x[k], dy = y[k];\n\t\t\t\t\tint c = 0;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tX += dx; Y += dy;\n\t\t\t\t\t\tif (a[X][Y] == obj[which])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (a[X][Y] == '.' || a[X][Y] == 'a')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!c)continue;\n\t\t\t\t\tX = I, Y = J;\n\t\t\t\t\ta[X][Y] = obj[(which + 1) % 2];\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tX += dx; Y += dy;\n\t\t\t\t\t\tif (a[X][Y] == obj[which])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[X][Y] = obj[(which + 1) % 2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tFORI(i, 1, 8 + 1)\n\t{\n\t\tFORI(j, 1, 8 + 1)\n\t\t{\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\nusing pii = pair<int, int>;\n\nconst int N = 8;\nchar mark[2] = {'o', 'x'};\n\nbool inrange(int x, int y) {\n    return 0 <= x && x < N && 0 <= y && y < N;\n}\n\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\npii select(vector<string> &board, int turn) {\n    char opp = mark[turn ^ 1];\n\n    pii ret = {-1, -1};\n    int mx = 0;\n    rep(y, 0, N) {\n        rep(x, 0, N) {\n            int i = 0, j = 0;\n            if (turn) {\n                i = N - 1 - y;\n                j = N - 1 - x;\n            } else {\n                i = y;\n                j = x;\n            }\n            if (board[i][j] != '.') continue;\n\n            int sum = 0;\n            rep(dir, 0, 8) {\n                pii tmp = {-1, -1};\n                int cnt = 0;\n                rep(k, 1, 9) {\n                    int ii = i + dy[dir] * k;\n                    int jj = j + dx[dir] * k;\n                    if (!inrange(jj, ii)) break;\n                    if (board[ii][jj] == opp) {\n                        cnt++;\n                        continue;\n                    }\n                    if(board[ii][jj]=='.'){\n                        break;\n                    }\n                    tmp = {ii, jj};\n                    break;\n                }\n                if (tmp.first != -1) {\n                    sum += cnt;\n                }\n            }\n\n            if (sum != 0) {\n                // cerr<<\"sum: \"<<sum<<\", \"<<\"j: \"<<j<<\", i:\"<<i<<endl;\n                if (mx < sum) {\n                    mx = sum;\n                    ret = {i, j};\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid update(vector<string> &board, int turn, pii pos) {\n    char opp = mark[turn ^ 1];\n    int y, x;\n    tie(y, x) = pos;\n    rep(dir, 0, 8) {\n        int cnt = 0;\n        rep(k, 1, 9) {\n            int yy = y + dy[dir] * k;\n            int xx = x + dx[dir] * k;\n            if (!inrange(xx, yy)) break;\n            if (board[yy][xx] == opp) {\n                continue;\n            }\n            if(board[yy][xx]=='.'){\n                break;\n            }\n            cnt = k;\n            break;\n        }\n        rep(k, 0, cnt) {\n            int yy = y + dy[dir] * k;\n            int xx = x + dx[dir] * k;\n            board[yy][xx] = mark[turn];\n        }\n    }\n}\n\nsigned main() {\n    vector<string> board(N);\n    rep(i, 0, N) cin >> board[i];\n\n    int turn = 0;\n    bool skipped = false;\n    // int loop=3;\n    while (1) {\n        pii pos = select(board, turn);\n        // cerr << pos.first << \", \" << pos.second << endl;\n        if (pos.first == -1) {\n            if (skipped) {\n                break;\n            }\n            skipped = true;\n            turn ^= 1;\n            continue;\n        }\n\n        // 更新\n        update(board, turn, pos);\n        turn ^= 1;\n\n        // rep(i, 0, N) {\n        //     cerr << board[i] << endl;\n        // }\n        // cerr << endl;\n    }\n\n    rep(i, 0, N) {\n        cout << board[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define loop(i, x, n) for (int i = (x); i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define int long long\n#define INF 1e9\nusing namespace std;\ntemplate<typename T> void cmin(T &a, T b) { a = min(a, b); }\ntemplate<typename T> void cmax(T &a, T b) { a = max(a, b); }\nchar mp[10][10];\n\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nbool CheckArea(int y, int x) {\n  if (0 <= y && y < 8 && 0 <= x && x < 8)\n    return true;\n  else\n    return false;\n}\n\nint check(int y, int x, char masu) {\n  int sum = 0;\n  rep(i, 8) {\n    int ny = y, nx = x, cnt = 0;\n    ny += dy[i];\n    nx += dx[i];\n    while (CheckArea(ny, nx) && mp[ny][nx] != '.') {\n      if (mp[ny][nx] != masu) cnt++;\n      if (mp[ny][nx] == masu) {\n        sum += cnt;\n        break;\n      }\n      ny += dy[i];\n      nx += dx[i];\n    }\n  }\n  return sum;\n}\n\nvoid draw(int y, int x, char masu) {\n  rep(i, 8) {\n    int ny = y, nx = x;\n    ny += dy[i];\n    nx += dx[i];\n    // cout << \"ny=\" << ny << ' ' << \"nx=\" << nx << ' ' << \"mp[ny][nx]=\" << mp[ny][nx] << endl;\n    bool ok = false;\n    while (CheckArea(ny, nx) && mp[ny][nx] != '.') {\n      if (mp[ny][nx] == masu) {\n        ok = true;\n        break;\n      }\n      ny += dy[i];\n      nx += dx[i];\n    }\n    if (ok) {\n      ny = y + dy[i];\n      nx = x + dx[i];\n      while (CheckArea(ny, nx) && mp[ny][nx] != '.') {\n        if (mp[ny][nx] == masu) break;\n        mp[ny][nx] = (masu == 'o' ? 'o' : 'x');\n        // cout << \"ny=\" << ny << ' ' << \"nx=\" << nx << endl;\n        ny += dy[i];\n        nx += dx[i];\n      }\n    }\n  }\n}\n\nsigned main() {\n  rep(i, 8) rep(j, 8) cin >> mp[i][j];\n  bool isTomoe = true;\n  int pass = 0;\n\n  while (1) {\n    if (isTomoe) {\n      int ypos, xpos, mpoint = 0;\n      rep(i, 8) rep(j, 8) {\n        if (mp[i][j] != '.') continue;\n        int temp_point = check(i, j, 'o');\n        if (mpoint < temp_point) {\n          ypos = i, xpos = j;\n          mpoint = temp_point;\n        }\n      }\n      //  cout << \"ypos=\" << ypos << ' ' << \"xpos=\" << xpos << ' ' << \"mpoint=\" << mpoint << endl;\n\n      if (mpoint == 0) {\n        pass++;\n      } else {\n        mp[ypos][xpos] = 'o';\n        draw(ypos, xpos, 'o');\n        pass = 0;\n      }\n      isTomoe = false;\n    } else {\n      int ypos, xpos, mpoint = 0;\n      for (int i = 7; i >= 0; i--) {\n        for (int j = 7; j >= 0; j--) {\n          if (mp[i][j] != '.') continue;\n          int temp_point = check(i, j, 'x');\n          if (mpoint < temp_point) {\n            ypos = i, xpos = j;\n            mpoint = temp_point;\n          }\n        }\n      }\n      //      cout << \"ypos=\" << ypos << ' ' << \"xpos=\" << xpos << ' ' << \"mpoint=\" << mpoint << endl;\n\n      if (mpoint == 0) {\n        pass++;\n      } else {\n        mp[ypos][xpos] = 'x';\n        draw(ypos, xpos, 'x');\n        pass = 0;\n      }\n      isTomoe = true;\n    }\n    if (pass == 2) break;\n    // rep(i, 8) {\n    //   rep(j, 8) cout << mp[i][j];\n    //   cout << endl;\n    // }\n    // cout << endl;\n    // out << \"pass=\" << pass << endl;\n  }\n  rep(i, 8) {\n    rep(j, 8) cout << mp[i][j];\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nvoid game(char s[8][8]);\nint repcheck(int r,int x,int y,int& si,int& sj,int i,int j,char c,char s[8][8]);\nvoid repcookie(char s[8][8],int ri,int rj,int x,int y,int r,char w);\nbool allcheck(char w,char s[8][8]);\nint main()\n{\n\tconst int size=8;\n\tchar table[size][size];\n\tstring inputbuf;\n\tfor(int i=0;i<size;i++){\n\t\tcin >> inputbuf;\n\t\tfor(int j=0;j<size;j++){\n\t\t\ttable[i][j]=inputbuf[j];\n\t\t}\n\t}\n\tgame(table);\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<size;j++){\n\t\t\tcout << table[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcin.get();\n\tcin.get();\n\treturn 0;\n}\nvoid game(char s[8][8]){\n\tint irepcookie;\n\tint si,sj;\n\tint rx,ry;\n\tint failc=0;\n\tbool filled=true;\n\twhile(true){\n\t\tsi=0;\n\t\tsj=0;\n\t\trx=0;\n\t\try=0;\n\t\tirepcookie=0;\n\t\tfilled = true;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i][j] == '.'){\n\t\t\t\t\tfilled = false;\n\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\t\tif(i == 0 && y == -1){break;}\n\t\t\t\t\t\t\tif(i == 7 && y == 1){break;}\n\t\t\t\t\t\t\tif(j == 0 && x == -1 || j == 7 && x == 1){\n\t\t\t\t\t\t\t}else{//\n\t\t\t\t\t\t\t\tif(x!=0||y!=0){\n\t\t\t\t\t\t\t\t\tif(s[i+y][j+x]=='o'){\n\t\t\t\t\t\t\t\t\t\tint repbuf = repcheck(irepcookie,x,y,si,sj,i,j,'x',s);\n\t\t\t\t\t\t\t\t\t\tif(repbuf>=irepcookie)\n\t\t\t\t\t\t\t\t\t\t\tif(irepcookie>0){\n\t\t\t\t\t\t\t\t\t\t\t\tfailc=0;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tirepcookie = repbuf;\n\t\t\t\t\t\t\t\t\t\t\trx = x;\n\t\t\t\t\t\t\t\t\t\t\try = y;\n\t\t\t\t\t\t\t\t\t\t\trepbuf = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\tif(irepcookie>0){\n\t\t\ts[si][sj] = 'x';\n\t\t\trepcookie(s,si,sj,rx,ry,irepcookie,'x');\n\t\t}else{\n\t\t\tfailc++;\n\t\t}\n\t\tif(failc >= 2){\n\t\t\t//break;\n\t\t}\n\t\tif(filled == true){\n\t\t\tbreak;\n\t\t}\n\t\tif(true==allcheck('x',s)){\n\t\t\tbreak;\n\t\t}\n\t\tsi=0;\n\t\tsj=0;\n\t\trx=0;\n\t\try=0;\n\t\tirepcookie=0;\n\t\tfilled = true;\n\t\tfor(int i=7;i>=0;i--){\n\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\tif(s[i][j] == '.'){\n\t\t\t\t\tfilled = false;\n\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\t\tif(i == 0 && y == -1){break;}\n\t\t\t\t\t\t\tif(i == 7 && y == 1){break;}\n\t\t\t\t\t\t\tif(j == 0 && x == -1 || j == 7 && x == 1){\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(x!=0||y!=0){\n\t\t\t\t\t\t\t\t\tif(s[i+y][j+x]=='x'){\n\t\t\t\t\t\t\t\t\t\tint repbuf=repcheck(irepcookie,x,y,si,sj,i,j,'o',s);\n\t\t\t\t\t\t\t\t\t\tif(repbuf>=irepcookie){\n\t\t\t\t\t\t\t\t\t\t\tif(irepcookie>0){\n\t\t\t\t\t\t\t\t\t\t\t\tfailc=0;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tirepcookie = repbuf;\n\t\t\t\t\t\t\t\t\t\t\trx = x;\n\t\t\t\t\t\t\t\t\t\t\try = y;\n\t\t\t\t\t\t\t\t\t\t\trepbuf = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(irepcookie>0){\n\t\t\ts[si][sj] = 'o';\n\t\t\trepcookie(s,si,sj,rx,ry,irepcookie,'o');\n\t\t}else{\n\t\t\tfailc++;\n\t\t}\n\t\tif(failc >= 2){\n\t\t\t//break;\n\t\t}\n\t\tif(filled == true){\n\t\t\tbreak;\n\t\t}\n\t\tif(true==allcheck('o',s)){\n\t\t\tbreak;\n\t\t}\n\t}\n}\nbool allcheck(char w,char s[8][8]){\n\tchar chk;\n\tbool allc=true;\n\tif(w=='o'){\n\t\tchk = 'x';\n\t}else{\n\t\tchk = 'o';\n\t}\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tif(s[i][j]=='o'||s[i][j]=='w'){\n\t\t\t}else{\n\t\t\t\tallc=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(allc==false){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(allc==true){return true;}\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tif(s[i][j]==w){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint repcheck(int r,int x,int y,int& si,int& sj,int i,int j,char c,char s[8][8]){\n\tchar rep;\n\tif(c=='x'){\n\t\trep = 'o';\n\t}else{\n\t\trep = 'x';\n\t}\n\tfor(int k=1;k<8;k++){\n\t\tif(k*y+i<0 || k*y+i >7 || k*x+j <0 || k*x+j >7){return 0;}\n\t\tif(s[k*y+i][k*x+j]=='.'){return 0;}\n\t\tif(s[k*y+i][k*x+j]==c){\n\t\t\tif(k==1){return 0;}\n\t\t\tif(r<=k-1){\n\t\t\t\tsi = i;\n\t\t\t\tsj = j;\n\t\t\t\treturn k-1;\n\t\t\t}else if(r>k-1){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid repcookie(char s[8][8],int ri,int rj,int x,int y,int r,char w){\n\tfor(int i=1;i<=r;i++){\n\t\ts[i*y+ri][i*x+rj] = w;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n     \nusing namespace std;\n\nchar s[8][8];\n\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nvoid reverse(int x,int y,char c) {\n    for(int d=0;d<8;++d) {\n        int nx=x+dx[d],ny=y+dy[d];\n        int tmp=0;\n        while(s[nx][ny]==(c=='o'?'x':'o')) {\n            nx+=dx[d],ny+=dy[d];\n            if(nx<0||ny<0||nx>7||ny>7) {\n                nx-=dx[d],ny-=dy[d];\n                break;\n            }\n        }\n        if(s[nx][ny]==c) {\n            while(nx!=x||ny!=y) {\n                nx-=dx[d],ny-=dy[d];\n                s[nx][ny]=c;\n            }\n        }\n    }\n}\n\nbool mami() {\n    int x,y,maxi=0;\n    for(int i=0;i<8;++i) {\n        for(int j=0;j<8;++j) {\n            if(s[i][j]!='.') continue;\n            int cnt=0;\n            for(int d=0;d<8;++d) {\n                int nx=i+dx[d],ny=j+dy[d];\n                int tmp=0;\n                while(s[nx][ny]=='x') {\n                    nx+=dx[d],ny+=dy[d];\n                    if(nx<0||ny<0||nx>7||ny>7) {\n                        nx-=dx[d],ny-=dy[d];\n                        break;\n                    }\n                    ++tmp;\n                }\n                if(s[nx][ny]=='o') cnt+=tmp;\n            }\n            if(maxi<cnt) maxi=cnt,x=i,y=j;\n        }\n    }\n    if(maxi) {\n        s[x][y]='o';\n        reverse(x,y,'o');\n        return true;\n    }\n    return false;\n}\n\nbool majo() {\n    int x,y,maxi=0;\n    for(int i=7;i>=0;--i) {\n        for(int j=7;j>=0;--j) {\n            if(s[i][j]!='.') continue;\n            int cnt=0;\n            for(int d=0;d<8;++d) {\n                int nx=i+dx[d],ny=j+dy[d];\n                int tmp=0;\n                while(s[nx][ny]=='o') {\n                    nx+=dx[d],ny+=dy[d];\n                    if(nx<0||ny<0||nx>7||ny>7) {\n                        nx-=dx[d],ny-=dy[d];\n                        break;\n                    }\n                    ++tmp;\n                }\n                if(s[nx][ny]=='x') cnt+=tmp;\n            }\n            if(maxi<cnt) maxi=cnt,x=i,y=j;\n        }\n    }\n    if(maxi) {\n        s[x][y]='x';\n        reverse(x,y,'x');\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    for(int i=0;i<8;++i) for(int j=0;j<8;++j) cin >> s[i][j];\n    bool flag=true;\n    while(flag) {\n        flag=false;\n        flag|=mami();\n        flag|=majo();\n    }\n    for(int i=0;i<8;++i) {\n        for(int j=0;j<8;++j) cout << s[i][j];\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nconst int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\nint check(const vector<string> &field, int x, int y, char c){\n\tif(field[y][x] != '.'){ return 0; }\n\tint result = 0;\n\tfor(int i = 0; i < 8; ++i){\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tfor(int j = 0; 0 <= px && px < 8 && 0 <= py && py < 8; ++j){\n\t\t\tif(field[py][px] == '.'){ break; }\n\t\t\tif(field[py][px] == c){\n\t\t\t\tresult += j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpx += dx[i]; py += dy[i];\n\t\t}\n\t}\n\treturn result;\n}\nvoid put(vector<string> &field, int x, int y, char c){\n\tfield[y][x] = c;\n\tfor(int i = 0; i < 8; ++i){\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tfor(int j = 0; 0 <= px && px < 8 && 0 <= py && py < 8; ++j){\n\t\t\tif(field[py][px] == '.'){ break; }\n\t\t\tif(field[py][px] == c){\n\t\t\t\twhile(py != y || px != x){\n\t\t\t\t\tfield[py][px] = c;\n\t\t\t\t\tpx -= dx[i]; py -= dy[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpx += dx[i]; py += dy[i];\n\t\t}\n\t}\n}\n\nint main(){\n\tvector<string> field(8);\n\tfor(int i = 0; i < 8; ++i){ cin >> field[i]; }\n\tfor(int i = 0; i < 64; ++i){\n\t\tint maxval = 0, x = 0, y = 0;\n\t\tfor(int j = 0; j < 8; ++j){\n\t\t\tfor(int k = 0; k < 8; ++k){\n\t\t\t\tint c = check(field, k, j, 'o');\n\t\t\t\tif(c > maxval){ maxval = c; x = k; y = j; }\n\t\t\t}\n\t\t}\n\t\tif(maxval > 0){ put(field, x, y, 'o'); }\n\t\tmaxval = 0, x = 0, y = 0;\n\t\tfor(int j = 0; j < 8; ++j){\n\t\t\tfor(int k = 0; k < 8; ++k){\n\t\t\t\tint c = check(field, k, j, 'x');\n\t\t\t\tif(c >= maxval){ maxval = c; x = k; y = j; }\n\t\t\t}\n\t\t}\n\t\tif(maxval > 0){ put(field, x, y, 'x'); }\n\t}\n\tfor(int i = 0; i < 8; ++i){\n\t\tcout << field[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring table[8];\nint dx[] = {0,1,1,1,0,-1,-1,-1};\nint dy[] = {-1,-1,0,1,1,1,0,-1};\nbool isInRange(int nx,int ny)\n{\n\tif (nx < 0 || nx >= 8 || ny < 0 || ny >= 8)return false;\n\treturn true;\n}\n\nint isPut(int x,int y,char putCookie)\n{\n\tint maxReverse = 0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\t\n\t\tint count = 0;\n\t\twhile (isInRange(nx, ny) && table[ny][nx] != putCookie && table[ny][nx] != '.')\n\t\t{\n\t\t\tif (putCookie == table[ny][nx])break;\n\t\t\tcount++;\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t}\n\n\t\tif (isInRange(nx,ny) && table[ny][nx] == putCookie)\n\t\t{\n\t\t\tmaxReverse += count;\n\t\t}\n\t}\n\treturn maxReverse;\n}\nvoid reversing(int px, int py,char putCookie)\n{\n\t//?????????????????????????????????\n\ttable[py][px] = putCookie;\n\n\tchar targetCookie;\n\tif (putCookie == 'o')targetCookie = 'x';\n\telse targetCookie = 'o';\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tint ny = py + dy[i];\n\t\tint nx = px + dx[i];\n\t\tbool isPut = false;\n\n\t\tint canReverseCount = 0;\n\t\twhile (isInRange(nx,ny) && table[ny][nx] != '.')\n\t\t{\n\t\t\tif (putCookie == table[ny][nx])\n\t\t\t{\n\t\t\t\tisPut = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcanReverseCount++;\n\t\t\tny += dy[i];\n\t\t\tnx += dx[i];\n\t\t}\n\n\t\tif (isPut)\n\t\t{\n\t\t\tint nextY = py + dy[i];\n\t\t\tint nextX = px + dx[i];\n\t\t\tfor (int j = 0; j < canReverseCount; j++)\n\t\t\t{\n\t\t\t\tcout << nextY << \" \" << nextX <<endl;\n\t\t\t\ttable[nextY][nextX] = putCookie;\n\t\t\t\tnextY = nextY + dy[i];\n\t\t\t\tnextX= nextX + dx[i];\n\t\t\t}\n\t\t}\n\t}\n}\n//???????????´???true?????????\nbool searchPutPos(char putCookie,int turn)\n{\n\tint maxReverse = 0;\n\tint putX = 0;\n\tint putY = 0;\n\tif (turn % 2 == 0)//??´??????????????????\n\t{\n\t\tfor (int i = 0; i < 8; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tif (table[i][j] != '.')continue;\n\t\t\t\t//???????????????????????????????????´??????\n\t\t\t\t//???????????¬????????????????????????????????¢??????????????¨?????§????????°???????????????\n\t\t\t\tint reverseNumber = isPut(j, i, putCookie);\n\t\t\t\tif (reverseNumber == 0)continue;\n\t\t\t\tif (maxReverse < reverseNumber)\n\t\t\t\t{\n\t\t\t\t\tmaxReverse = reverseNumber;\n\t\t\t\t\tputX = j;\n\t\t\t\t\tputY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse//????????????????\\?????????????\n\t{\n\t\tfor (int i = 7; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = 7; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (table[i][j] != '.')continue;\n\t\t\t\tint reverseNumber = isPut(j, i, putCookie);\n\t\t\t\tif (reverseNumber == 0)continue;\n\t\t\t\tif (maxReverse < reverseNumber)\n\t\t\t\t{\n\t\t\t\t\tmaxReverse = reverseNumber;\n\t\t\t\t\tputX = j;\n\t\t\t\t\tputY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//?????¢??????????????¨?????§???????????´???\n\tif (maxReverse == 0)return false;\n\n\t//?????¢??????\n\treversing(putX,putY,putCookie);\n\n\t//cout << putX << \" \"<<putY << endl;\n\treturn true;\n}\nint main()\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tcin >> table[i];\n\t}\n\tbool pfind = true;\n\tfor (int turn = 0;;turn++)\n\t{\n\t\tchar putCookie = '-';//?????????????????????????????\\??????\n\t\tif (turn % 2 == 1)//????????????????\\?????????????\n\t\t{\n\t\t\tputCookie = 'x';//?????????????????????\n\t\t}\n\t\telse//??´??????????????????\n\t\t{\n\t\t\tputCookie = 'o';//?????§?????¬??????????????????\n\t\t}\n\t\t//??????????????????????????´?????????????????£???????????????bool?????????\n\t\tbool find = searchPutPos(putCookie, turn);\n\n\t\tif (!find && !pfind)//????????????????????¬????????????????????????????????£?????????????????????\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tpfind = find;\n\t\t//cout << turn << endl;\n\t\tfor (int i = 0; i < 8; i++)\n\t\t{\n\t\t\tcout << table[i] << endl;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tcout << table[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <regex>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring fld[8];\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nvector<P> search(char c)\n{\n\tvector<P> v;\n\tint mx = 1;\n\tREP(i, 8)REP(j, 8)\n\t{\n\t\tif (fld[i][j] != '.') continue;\n\t\tint cnt = 0;\n\t\tREP(k, 8)\n\t\t{\n\t\t\tint tmp = 0;\n\t\t\tint nx = i; int ny = j;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 ||fld[nx][ny]=='.') break;\n\t\t\t\telse if (fld[nx][ny] != c)\n\t\t\t\t{\n\t\t\t\t\ttmp++; continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcnt += tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt > mx)\n\t\t{\n\t\t\tv.clear();\n\t\t\tv.push_back(P(i, j));\n\t\t\tmx = cnt;\n\t\t}\n\t\telse if (cnt == mx)\n\t\t{\n\t\t\tv.push_back(P(i, j));\n\t\t}\n\t}\n\treturn v;\n}\n\nbool endf()\n{\n\tvector<P> a, b;\n\ta = search('x'); b = search('y');\n\tif (a.size() == 0 && b.size() == 0) return false;\n\telse return true;\n}\n\nvoid majo()\n{\n\tvector<P> v = search('x');\n\tint x, y;\n\tif (v.size() > 0)\n\t{\n\t\tx = v.back().first; y = v.back().second;\n\t\tfld[x][y] = 'x';\n\t\tREP(k, 8)\n\t\t{\n\t\t\tvector<P> w;\n\t\t\tint nx = x; int ny = y;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 || fld[nx][ny] == '.') break;\n\t\t\t\telse if (fld[nx][ny] == 'o')\n\t\t\t\t{\n\t\t\t\t\tw.push_back(P(nx, ny)); continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREP(i, w.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tfld[w[i].first][w[i].second] = 'x';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid mami()\n{\n\tvector<P> v = search('o');\n\tint x, y;\n\tif (v.size() > 0)\n\t{\n\t\tx = v[0].first; y = v[0].second;\n\t\tfld[x][y] = 'o';\n\t\tREP(k, 8)\n\t\t{\n\t\t\tvector<P> w;\n\t\t\tint nx = x; int ny = y;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 || fld[nx][ny] == '.') break;\n\t\t\t\telse if (fld[nx][ny] == 'x')\n\t\t\t\t{\n\t\t\t\t\tw.push_back(P(nx, ny)); continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREP(i, w.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tfld[w[i].first][w[i].second] = 'o';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main()\n{\n\tREP(i, 8) cin >> fld[i];\n\tfor (int i = 0; endf(); i++)\n\t{\n\t\tif (i % 2) majo();\n\t\telse mami();\n\t}\n\tREP(i, 8) cout << fld[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint f[10][10];\nint dx[8]={0,0,1,1,1,-1,-1,-1};\nint dy[8]={1,-1,1,-1,0,1,0,-1};\nchar str[4]=\"x.o\";\nbool inner(int x,int y){\n    if(x<0||x>=8||y<0||y>=8)return false;\n    return true;\n}\nint rev(int x,int y,int p){\n    int ret = 0;\n    for(int d=0;d<8;d++){\n        int cnt=0;\n        int nx = x, ny = y;\n        while(1){\n            nx += dx[d];\n            ny += dy[d];\n            if(!inner(nx,ny)){\n                cnt = 0;\n                break;\n            }\n            if(f[nx][ny]==p)break;\n            else if(f[nx][ny]==-p)cnt++;\n            else{\n                cnt = 0;\n                break;\n            }\n        }\n        ret += cnt;\n    }\n    return ret;\n}\nvoid change(int x,int y,int p){\n    for(int d=0;d<8;d++){\n        int cnt=0;\n        int nx = x, ny = y;\n        while(1){\n            nx += dx[d];\n            ny += dy[d];\n            if(!inner(nx,ny)){\n                cnt = 0;\n                break;\n            }\n            if(f[nx][ny]==p)break;\n            else if(f[nx][ny]==-p)cnt++;\n            else{\n                cnt = 0;\n                break;\n            }\n        }\n        nx = x, ny = y;\n        for(int i=0;i<cnt;i++){\n            nx += dx[d];\n            ny += dy[d];\n            f[nx][ny]=p;\n        }\n    }\n    f[x][y]=p;\n    return;\n}\nint main(){\n    string s;\n    for(int i=0;i<8;i++){\n        cin >> s;\n        for(int j=0;j<8;j++){\n            if(s[j]=='.')f[i][j]=0;\n            else if(s[j]=='o')f[i][j]=1;\n            else f[i][j]=-1;\n        }\n    }\n    int p = 1;\n    bool pass = false;\n    for(;;){\n        int max_rev = 0;\n        int mx = -1, my = -1;\n        if(p==1){\n            for(int i=7;i>=0;i--){\n                for(int j=7;j>=0;j--){\n                    if(f[i][j]!=0)continue;\n                    int r = rev(i,j,p);\n                    if(max_rev <= r){\n                        max_rev = r;\n                        mx = i;\n                        my = j;\n                    }\n                }\n            }\n        }else{\n            for(int i=0;i<8;i++){\n                for(int j=0;j<8;j++){\n                    if(f[i][j]!=0)continue;\n                    int r = rev(i,j,p);\n                    if(max_rev <= r){\n                        max_rev = r;\n                        mx = i;\n                        my = j;\n                    }\n                }\n            }\n        }\n        if(max_rev == 0){\n            if(pass)break;\n            pass = true;\n        }else{\n            pass = false;\n            change(mx,my,p);\n        }\n        p *= -1;\n    }\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            printf(\"%c\",str[f[i][j]+1]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\n//string F[8];\nchar F[10][10];\nbool used[8][8];\nint turn;\n\nbool debug;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  /*\n  rep(i, 8) rep(j, 8){\n    cin >> F[i][j];\n  }\n  //  */\n  rep(i, 8) cin >> F[i];\n  \n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7)\n      DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        \n        if(mx < r) {\n          memcpy(u, used, sizeof u);\n          mx = r;\n          pl = turn&1;\n        }\n        \n      }\n    }\n    if(mx > 0) {\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      \n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  \n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <typeinfo>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <map>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint a[8][8]={};\nint x[8]={1,1,1,0,0,-1,-1,-1};\nint y[8]={1,0,-1,1,-1,1,0,-1};\n\nint count(int X,int Y,int p){ //pはお菓子\n\tint ans(0);\n\tif(a[X][Y]!=0){return 0;}\n\telse\n\t{\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tint q(0);\n\t\t\tfor(int j=1;j<8;j++)\n\t\t\t{\n\t\t\t\tif(X+j*x[i]>7||X+j*x[i]<0||Y+j*y[i]>7||Y+j*y[i]<0){break;}\n\t\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==p){ans+=q;break;}\n\t\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==3-p){q++;}\n\t\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==0){break;}\n\t\t\t}\n\t\t}\n\treturn ans;\n\t}\n}\n\nvoid replace(int X,int Y,int p)\n{\n\ta[X][Y]=p;\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tfor(int j=1;j<8;j++)\n\t\t{\n\t\t\tif(X+j*x[i]>7||X+j*x[i]<0||Y+j*y[i]>7||Y+j*y[i]<0){break;}\n\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==0){break;}\n\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==p)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\t{\n\t\t\t\t\ta[X+k*x[i]][Y+k*y[i]]=p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() \n{\n\t//チョコ＝1 チーズ＝2\n\tREP(i,8){\n\t\tstring s;cin>>s;\n\t\tREP(j,8){\n\t\t\tif(s[j]=='o')a[j][i]=1;\n\t\t\telse if(s[j]=='x')a[j][i]=2;\n\t\t}\n\t}\n\t\n\tfor(;;)\n\t{\n\t\tbool flag1(false),flag2(false);\n\t\t\n\t\tint ans1(0),x1(0),y1(0);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(ans1<count(j,i,1)){\n\t\t\t\t\tans1=count(j,i,1);\n\t\t\t\t\tx1=j,y1=i;\n\t\t}}}\n\t\tif(ans1>0){\n\t\t\treplace(x1,y1,1);//cout<<\"-1-\"<<endl;\n\t\t\t//REP(i,8){REP(j,8)cout<<a[j][i];cout<<endl;}\n\t\t}else{\n\t\t\tflag1=true;\n\t\t}\n\t\t\n\t\tint ans2(0),x2(0),y2(0);\n\t\tfor(int i=7;i>-1;i--){\n\t\t\tfor(int j=7;j>-1;j--){\n\t\t\t\tif(ans2<count(j,i,2)){\n\t\t\t\t\tans2=count(j,i,2);\n\t\t\t\t\tx2=j,y2=i;\n\t\t}}}\n\t\tif(ans2>0){\n\t\t\treplace(x2,y2,2);//cout<<\"-2-\"<<endl;;\n\t\t\t//REP(i,8){REP(j,8)cout<<a[j][i];cout<<endl;}\n\t\t}else{\n\t\t\tflag2=true;\n\t\t}\n\t\t\n\t\tif(flag1&&flag2)break;\n\t}\n\t\n\tREP(i,8)\n\t{\n\t\tREP(j,8)\n\t\t{\n\t\t\tif(a[j][i]==0)cout<<\".\";\n\t\t\telse if(a[j][i]==1)cout<<\"o\";\n\t\t\telse if(a[j][i]==2)cout<<\"x\";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint dx[] = {0, 1, -1, 0, 1, -1, 1, -1};\nint dy[] = {1, 1, 1, -1, -1, -1, 0, 0};\nconst int MAMI = 0;\nconst int WITCH = 1;\nstring pat = \"ox\";\n\nbool comp(int turn, int a1, int b1, int a2, int b2) {\n    if(turn == MAMI) {\n        return a1 != a2 ? a1 < a2 : b1 < b2;\n    }\n    else if(turn == WITCH) {\n        return a1 != a2 ? a1 > a2 : b1 > b2;\n    }\n}\n\nvoid change(vector<string> &board, pii point, int turn, vector<int> dirs) {\n    rep(k,0,dirs.size()) {\n        int x = point.fr, y = point.sc;\n        while(1) {\n            board[x][y] = pat[turn];\n            x = x + dx[ dirs[k] ], y = y + dy[ dirs[k] ];\n            if(board[x][y] == pat[turn]) break;\n        }\n    }\n}\n\nvoid solve(vector<string> &prev, int turn=MAMI, int flag=0) {\n    char ch = pat[turn];\n    int ma = 0;\n    pii point = pii(-1, 0);\n    vector<int> dirs;\n    rep(i,0,8) {\n        rep(j,0,8) {\n            if(prev[i][j] != '.') continue;\n            int temp = 0;\n            vector<int> vs;\n            rep(k,0,8) {\n                int cnt = 0;\n                int x = i, y = j;\n                while(1) {\n                    x = x + dx[k], y = y + dy[k];\n                    if(x < 0 || x >= 8 || y < 0 || y >= 8 || prev[x][y] == '.') {\n                        cnt = 0;\n                        break;\n                    }\n                    if(prev[x][y] == ch) {\n                        vs.pb(k);\n                        break;\n                    }\n                    cnt++;\n                }\n                temp += cnt;\n            }\n            if(temp && temp > ma) {\n                ma = temp;\n                point = pii(i, j);\n                dirs = vs;\n            }\n            else if(temp && temp == ma) {\n                if(comp(turn, i, j, point.fr, point.sc)) {\n                    point = pii(i, j);\n                    dirs = vs;\n                }\n            }\n        }\n    }\n\n    if(point.fr >= 0) {\n        change(prev, point, turn, dirs);\n        flag = 0;\n    }\n    else {\n        if(flag) return;\n        flag = 1;\n    }\n    solve(prev, turn ^ 1, flag);\n}\n\nsigned main() {\n    vector<string> board(8);\n    rep(i,0,8) cin >> board[i];\n    solve(board);\n    rep(i,0,8) {\n        rep(j,0,8) {\n            cout << board[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nint a[10][10];\n\nint distance(int sy, int sx, int gy, int gx)\n{\n\treturn max(abs(sy - gy), abs(sx - gx));\n}\n\nbool inside(int y, int x)\n{\n\treturn 0 <= y and y < 8 and 0 <= x and x < 8;\n}\n\nvoid place(int y, int x, int c, int vec)\n{\n\tint ty = -1, tx = -1;\n\tint ny = y + dy[vec], nx = x + dx[vec];\n\n\twhile (1) {\n\t\tny += dy[vec];\n\t\tnx += dx[vec];\n\t\tif (not inside(ny, nx)) break;\n\t\tif (a[ny][nx] == c) {\n\t\t\tty = ny, tx = nx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ty != -1) {\n\t\tint cury = y + dy[vec], curx = x + dx[vec];\n\n\t\tint counter = 0;\n\t\twhile (1) {\n\t\t\tif (a[cury][curx] == !c) {\n\t\t\t\tcounter++;\n\t\t\t}\n\n\t\t\tif (cury == ty and curx == tx) break;\n\n\t\t\tcury += dy[vec];\n\t\t\tcurx += dx[vec];\n\t\t}\n\n\t\tif (distance(y, x, ty, tx) - 1 == counter) {\n\t\t\tint cury = y + dy[vec], curx = x + dx[vec];\n\t\t\twhile (1) {\n\t\t\t\ta[cury][curx] = c;\n\t\t\t\tcury += dy[vec];\n\t\t\t\tcurx += dx[vec];\n\t\t\t\tif (cury - dy[vec] == ty and curx - dx[vec] == tx) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint calc(int y, int x, int c)\n{\n\tint sum = 0;\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint ty = -1, tx = -1;\n\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\n\t\twhile (1) {\n\t\t\tny += dy[i];\n\t\t\tnx += dx[i];\n\t\t\tif (not inside(ny, nx)) break;\n\t\t\tif (a[ny][nx] == c) {\n\t\t\t\tty = ny, tx = nx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ty != -1) {\n\t\t\tint cury = y + dy[i], curx = x + dx[i];\n\n\t\t\tint counter = 0;\n\t\t\twhile (1) {\n\t\t\t\tif (a[cury][curx] == !c) {\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\n\t\t\t\tif (cury == ty and curx == tx) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcury += dy[i];\n\t\t\t\tcurx += dx[i];\n\t\t\t}\n\n\t\t\tif (distance(y, x, ty, tx) - 1 == counter) {\n\t\t\t\tsum += counter;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint main()\n{\n\trep(i, 8) rep(j, 8) {\n\t\tchar c; cin >> c;\n\t\tif (c == 'o') {\n\t\t\ta[i][j] = 1;\n\t\t} else if (c == 'x') {\n\t\t\ta[i][j] = 0;\n\t\t} else {\n\t\t\ta[i][j] = -1;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tbool did1 = false, did2 = false;\n\n\t\t// mami\n\t\tint mami_max = 0, my = -1, mx = -1;\n\t\trep(y, 8) rep(x, 8) {\n\t\t\tif (a[y][x] != -1) continue;\n\t\t\tif (mami_max < calc(y, x, 1)) {\n\t\t\t\tmami_max = calc(y, x, 1);\n\t\t\t\tmy = y, mx = x;\n\t\t\t}\n\t\t}\n\n\t\tif (my != -1) {\n\t\t\ta[my][mx] = 1;\n\t\t\trep(i, 8) {\n\t\t\t\tplace(my, mx, 1, i);\n\t\t\t}\n\t\t\tdid1 = true;\n\t\t}\n\t\t\n\t\t// witch\n\t\tint witch_max = 0, wy = -1, wx = -1;\n\t\tfor (int y = 7; y >= 0; --y) for (int x = 7; x >= 0; --x) {\n\t\t\tif (a[y][x] != -1) continue;\n\t\t\tif (witch_max < calc(y, x, 0)) {\n\t\t\t\twitch_max = calc(y, x, 0);\n\t\t\t\twy = y, wx = x;\n\t\t\t}\n\t\t}\n\n\t\tif (wy != -1) {\n\t\t\ta[wy][wx] = 0;\n\t\t\trep(i, 8) {\n\t\t\t\tplace(wy, wx, 0, i);\n\t\t\t}\n\t\t\tdid2 = true;\n\t\t}\n\n\t\tif ((not did1) and (not did2)) break;\n\t}\n\n\trep(i, 8) {\n\t\trep(j, 8) {\n\t\t\tif (a[i][j] == 1) {\n\t\t\t\tprintf(\"o\");\n\t\t\t} else if (a[i][j] == 0)  {\n\t\t\t\tprintf(\"x\");\n\t\t\t} else {\n\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst char cs[] = \"xo\";\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n    state(){}\n};\n\nstate flip(const int x, const int y, state s, bool turn){\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        if (!valid(cx, cy) || s.g[cy][cx] == cs[turn]) continue;\n        while (valid(cx, cy) && s.g[cy][cx] == cs[!turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cx, cy) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i];\n                !(ix == cx && iy == cy);\n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[!turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n        s.score[turn]++;\n        s.score[1 - turn]--;\n    }\n    return s;\n}\n\nint main(){\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    for (size_t turn = 1; turn <= 64; turn++){\n        bool ok = false;\n        state next = cur;\n        for (size_t y = 0; y < 8; y++){\n            for (size_t x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 1 && next.score[1] < cand.score[1]) ||\n                        ((turn & 1) == 0 && next.score[0] <= cand.score[0])){\n                        ok = true;\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        cur = next;\n    }\n\n    for (size_t i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nbool rev(char color, int y, int x, int cc, vector<vector<char> > &b) {\n  if (b[y][x] == color) {\n    return true;\n  }\n\n  if (b[y][x] == '.') {\n    return false;\n  }\n\n  bool flag = rev(color, y + dy[cc], x + dx[cc], cc, b);\n  if (flag) {\n    b[y][x] = color;\n  }\n\n  return flag;\n}\n\nint canRevN(char color, int y, int x, int cc,\n\t    const vector<vector<char> > &b, int depth) {\n  if (b[y][x] == color) {\n    return 0;\n  }\n\n  if (b[y][x] == '.') {\n    return -depth;\n  }\n\n  return canRevN(color, y + dy[cc], x + dx[cc], cc, b, depth + 1) + 1;\n}\n\nint main() {\n  vector<vector<char> > b(10);\n  for (int y = 0; y < 10; y++) {\n    b[y].resize(10);\n    fill(b[y].begin(), b[y].end(), '.');\n  }\n\n  for (int y = 1; y <= 8; y++) {\n    for (int x = 1; x <= 8; x++) {\n      cin >> b[y][x];\n    }\n  }\n\n  char color = 'o';\n  int lastMaxN = -1;\n  int maxN = -1;\n\n  while (maxN != 0 || lastMaxN != 0) {\n    lastMaxN = maxN;\n    maxN = 0;\n\n    int maxY = -1;\n    int maxX = -1;\n\n    const int oval[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    const int xval[] = {8, 7, 6, 5, 4, 3, 2, 1};\n\n    for (int i = 0; i < 8; i++) {\n      for (int j = 0; j < 8; j++) {\n\tint y = color == 'o' ? oval[i] : xval[i];\n\tint x = color == 'o' ? oval[j] : xval[j];\n\n\tif (b[y][x] != '.') {\n\t  continue;\n\t}\n\n\tint n = 0;\n\tfor (int cc = 0; cc <= 7; cc++) {\n\t  n += canRevN(color, y + dy[cc], x + dx[cc], cc, b, 0);\n\t}\n\n\tif (n > maxN) {\n\t  maxN = n;\n\t  maxY = y;\n\t  maxX = x;\n\t}\n      }\n    }\n\n    if (maxN != 0) {\n      for (int cc = 0; cc <= 7; cc++) {\n\tb[maxY][maxX] = color;\n\trev(color, maxY + dy[cc], maxX + dx[cc], cc, b);\n      }\n    }\n\n    color = color != 'o' ? 'o' : 'x';\n  }\n\n  for (int y = 1; y <= 8; y++) {\n    for (int x = 1; x <= 8; x++) {\n      cout << b[y][x];\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\n\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nt_T string out_m2(v_<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)r_ ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            auto v = a[h][W[wi]];            str s;            if(is_same<decltype(v), char>::value)s+=v;            else s = tos(v);            if (abs(v) == inf || abs(v) == INF<T>())s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            auto v = a[h][w];            str s;            if(is_same<decltype(v), char>::value)s+=v;            else s = tos(v);            if (abs(a[h][w]) == inf || abs(a[h][w]) == INF<T>())s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    r_ out_m2(a, hs, ws, key);}\nt_T string out_m2(v_<v_<v_<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    r_ ss.str();}\nstring out_m2(int a) {    stringstream ss;    ss << a;    r_ ss.str();}\nt_T string out_m2(T &a) {    stringstream ss;    ss << a;    r_ ss.str();}\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<out_m2(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<out_m2(x)<<\", \"<< debugName(y)<<\" = \"<<out_m2(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<out_m2(x)  << \", \" <<  debugName(y)<<\" = \"<<out_m2(y) <<\", \" debugName(z)<<\" = \"<<out_m2(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<\", \" <<  debugName(b)<<\" = \"<<out_m2(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.push_back(v);\n    r_ a;\n}\ntemplate<class T> v_<T>& operator+=(v_<T> & a,const v_<T> & b){\n    fora(v, b)a += v;\n    return a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    rep(i, sz(m)){os << m[i];if(i < sz(m)-1)os<<\" \";}   r_ os;}\nostream &operator<<(ostream &os, v_<char> &m) {rep(i, sz(m)){os << m[i];}   r_ os;}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<v_<T>> &m) {rep(i, sz(m)){os << m[i]; if(i < sz(m)-1)os << endl;}   r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nvoid out() { cout << \"\" << endl; }\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n\nvoid solve() {\n    H = 8;\n    W = 8;\n    vvc(S, H, W);\n    nt(S, H, W);\n    int ma = 0;\n    vi mhs, mws;\n    auto chk = [&](int h, int w, char c) {\n        if (S[h][w] != '.')return;\n        vi HS, WS;\n        rep(ah, -1, 2)rep(aw, -1, 2) {\n                vi hs, ws;\n                bool ex = false;\n                int th = h + ah, tw = w + aw;\n                while (1) {\n                    if (!inside(th, tw, H, W))break;\n                    if (S[th][tw] == '.')break;\n                    else if (S[th][tw] == c) {\n                        ex = true;\n                        break;\n                    } else {\n                        hs += th;\n                        ws += tw;\n                    }\n                    th += ah;\n                    tw += aw;\n                }\n                if (ex) {\n                    HS += hs;\n                    WS += ws;\n                }\n            }\n        if (chma(ma, sz(HS))) {\n            mhs = HS;\n            mhs += h;\n            mws = WS;\n            mws += w;\n//            deb(h, w, c);\n//            deb(mhs);\n//            deb(mws);\n        }\n    };\n    bool upa = true, upb = true;\n    while (upa || upb) {\n        upa = false;\n        upb = false;\n        ma = 0;\n        rep(h, H)rep(w, W) {\n                chk(h, w, 'o');\n            }\n        if (ma) {\n            upa = true;\n            rep(i, sz(mhs))S[mhs[i]][mws[i]] = 'o';\n        }\n//        deb(S);\n        ma = 0;\n        rer(h, H - 1)rer(w, W - 1) {\n                chk(h, w, 'x');\n            }\n        if (ma) {\n            upb = true;\n            rep(i, sz(mhs))S[mhs[i]][mws[i]] = 'x';\n        }\n//        deb(S);\n    }\n    cout << S<<endl;\n//    out(S);\n\n}\n\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid rotate(vector<string> &field){\n  int n = field.size();\n  vector<string> tmp = field;\n  REP(i, n)REP(j, n){\n    tmp[n-i-1][n-j-1] = field[i][j];\n  }\n  REP(i, n)REP(j, n){\n    field[i][j] = tmp[i][j] == 'o' ? 'x' : tmp[i][j] == '.' ? '.' : 'o';\n  }\n}\n\npair<int, vector<string> > flip(const vector<string> &field, int x, int y, char c){\n  int n = field.size();\n  \n  int ans = 0;\n  vector<string> board = field;\n\n  board[x][y] = c;\n  \n  REP2(dx, -1, 2)REP2(dy, -1, 2){\n    if(dx == 0 && dy == 0) continue;\n    int tx = x + dx, ty = y + dy;\n    while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n          board[tx][ty] != '.' && board[tx][ty] != c) {\n      tx += dx;\n      ty += dy;\n    }\n    \n    if(0 <= tx && tx < n && 0 <= ty && ty < n && board[tx][ty] == c){\n      tx = x + dx, ty = y + dy;\n      \n      while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n            board[tx][ty] != '.' && board[tx][ty] != c) {\n        board[tx][ty] = c;\n        tx += dx;\n        ty += dy;\n        ans++;\n      }\n    }\n  }\n  return make_pair(ans, board);\n  \n}\n\nint main(){\n  vector<string> field(8);\n  \n  REP(i, 8) cin >> field[i];\n\n  int s = 0;\n  bool mami;\n  REP(i, 8) s += count(ALL(field[i]), '.');\n  if(s % 2){\n    mami = false;\n  }else{\n    mami = true;\n  }\n\n  int bad = 0;\n\n  // cout << mami << endl;\n  while(true){\n    // REP(i, 8) cout << field[i] << endl;\n    if(!mami) rotate(field);\n\n    int best = 0;\n    vector<string> bestboard;\n    \n    REP(i, 8) REP(j, 8)if(field[i][j] == '.'){\n      pair<int, vector<string> > p = flip(field, i, j, 'o');\n      if(p.first > best){\n        best = p.first;\n        bestboard = p.second;\n      }\n    }\n\n    if(best > 0){\n      field = bestboard;\n    }\n    \n    if(!mami) rotate(field);\n    \n    if(best == 0){\n      bad++;\n      if(bad > 1) break;\n    }\n    mami = !mami;\n  }\n  REP(i, 8) cout << field[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring data[8];\nint dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvoid set(int y, int x, char c){\n  data[y][x] = c;\n  for(int i=0;i<8;++i){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    bool f = false;\n    while(min(ny, nx) >= 0 && max(ny, nx) < 8){\n      if(data[ny][nx] == '.') break;\n      if(data[ny][nx] == c){\n        f = true;\n        break;\n      }\n      ny += dy[i];\n      nx += dx[i];\n    }\n    if(f){\n      ny = y + dy[i];\n      nx = x + dx[i];\n      while(data[ny][nx] != c){\n        data[ny][nx] = c;\n        ny += dy[i];\n        nx += dx[i];\n      }\n    }\n  }\n}\n\nint calc(int y, int x, char c){\n  int res = 0;\n  for(int i=0;i<8;++i){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    int cnt = 0;\n    while(min(ny, nx) >= 0 && max(ny, nx) < 8){\n      if(data[ny][nx] == '.') break;\n      if(data[ny][nx] == c){\n        res += cnt;\n        break;\n      }\n      ++cnt;\n      ny += dy[i];\n      nx += dx[i];\n    }\n  }\n  return res;\n}\n\nbool set(int t){\n  int px = -1, py = -1;\n  int valM = 0;\n  if(t){\n    for(int i=0;i<8;++i){\n      for(int j=0;j<8;++j){\n        if(data[i][j] == '.'){\n          int tmp = calc(i, j, 'o');\n          if(valM < tmp){\n            px = j;\n            py = i;\n            valM = tmp;\n          }\n        }\n      }\n    }\n    if(valM) set(py, px, 'o');\n  }else{\n    for(int i=7;i>=0;--i){\n      for(int j=7;j>=0;--j){\n        if(data[i][j] == '.'){\n          int tmp = calc(i, j, 'x');\n          if(valM < tmp){\n            px = j;\n            py = i;\n            valM = tmp;\n          }\n        }\n      }\n    }\n    if(valM) set(py, px, 'x');\n  }\n  if(px == -1 && py == -1) return false;\n  return true;\n}\n\nvoid solve(){\n  int turn = 1;\n  bool pre = true;\n  while(1){\n    bool tmp = set(turn);\n    if(!pre && !tmp) break;\n    pre = tmp;\n    turn = 1 - turn;\n  }\n}\n\nmain(){\n  while(cin >> data[0]){\n    for(int i=1;i<8;++i){\n      cin >> data[i];\n    }\n    solve();\n    for(int i=0;i<8;i++){\n      cout << data[i] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main(){\n  vector<string> S(8);\n  for(int i = 0; i < 8; ++i){\n    cin >> S[i];\n  }\n  bool f = true, g = true, h = true;\n  int player = -1, M, m, x, y, s, t, u, v;\n  char mark, opponent;\n  vector<int> dx, dy;\n  dx = {0,1,-1}; dy = {0,1,-1};\n  while (f&&g&&h){\n    f = false; g = false; h = false;\n    M = 0;\n    s = -1;\n    t = -1;\n    if (player > 0) {\n      mark = 'x';\n      opponent = 'o';\n    }else{\n      mark = 'o';\n      opponent = 'x';\n    }\n    for (int i = 0; i < 8; ++i){\n      for (int j = 0; j < 8; ++j){\n\tif (S[i][j] == 'x') f = true;\n\telse if (S[i][j] == 'o') g = true;\n\telse{//S[i][j] == '.'\n\t  h = true;\n\t  m = 0;\n\t  for (int k = 0; k < 3; ++k){//8??????????????????\n\t    for (int l = 0; l < 3; ++l) {\n\t      if (k || l){\n\t\tx = i; y = j;\n\t\twhile (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == opponent){\n\t\t  x += dx[k];\n\t\t  y += dy[l];\n\t\t}\n\t\tif (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == mark){\n\t\t  m += max(abs(x-i), abs(y-j));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if ((m >= M && player > 0)||(m > M && player < 0)) {\n\t    s = i;\n\t    t = j;\n\t    M = m;\n\t  }\n\t}\n      }\n    }\n    if (M > 0){//??????????????????????????´?????¶????????´??°\n      S[s][t] = mark;\n      for (int k = 0; k < 3; ++k){//8??????????????????\n\tfor (int l = 0; l < 3; ++l) {\n\t  if (k || l){\n\t    x = s; y = t;\n\t    while (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == opponent){\n\t      x += dx[k];\n\t      y += dy[l];\n\t    }\n\t    if (S[x+dx[k]][y+dy[l]] == mark){\n\t      while (x != s || y != t) {\n\t\tS[x][y] = mark;\n\t\tx -= dx[k];\n\t\ty -= dy[l];\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    player *= -1;\n    //    for (int i = 0; i < 8; ++i) cout << S[i] << endl;\n  }\n  for (int i = 0; i < 8; ++i) cout << S[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    vector<string> board(8, \"........\");\n    for (int i = 0; i < 8; ++i) {\n        cin >> board[i];\n    }\n        \n    int par = 0, pass = 0;;\n    while (true) {\n        \n        \n//        for (int i = 0; i < 8; ++i) {\n//            cout << board[i] << endl;\n//        }\n            \n        // par0 : ○、上、左\n        if (par == 0) {\n            int Max = 0, mx = -1, my = -1;\n            vector<string> mb;\n            for (int i = 0; i < 8; ++i) {\n                for (int j = 0; j < 8; ++j) {\n                    int con = 0;\n                    vector<string> temp = board;\n                    \n                    if (temp[i][j] != '.') continue;\n                    else temp[i][j] = 'o';\n                    \n                    for (int k = 0; k < 8; ++k) {\n                        int ni = i, nj = j;\n                        int tcon = 0; bool ok = true;\n                        vector<string> ttemp = temp;\n                        \n                        while (true) {\n                            ni += dx[k]; nj += dy[k];\n                            if (ni < 0 || ni >= 8 || nj < 0 || nj >= 8) {\n                                ok = false;\n                                break;\n                            }\n                            if (temp[ni][nj] == 'x') {\n                                ++tcon;\n                                ttemp[ni][nj] = 'o';\n                            }\n                            else if (temp[ni][nj] == 'o') {\n                                break;\n                            }\n                            else if (temp[ni][nj] == '.') {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            con += tcon;\n                            temp = ttemp;\n                        }\n                    }\n                    \n                    if (Max < con) {\n                        Max = con;\n                        mx = i;\n                        my = j;\n                        mb = temp;\n                    }\n                }\n            }\n            \n            if (Max == 0) {\n                ++pass;\n                if (pass == 2) break;\n            }\n            else {\n                pass = 0;\n                board = mb;\n            }\n            par = 1;\n        }\n        \n        // par1 : x、下、右\n        else if (par == 1) {\n            int Max = 0, mx = -1, my = -1;\n            vector<string> mb;\n            for (int i = 7; i >= 0; --i) {\n                for (int j = 7; j >= 0; --j) {\n                    int con = 0;\n                    vector<string> temp = board;\n                    \n                    if (temp[i][j] != '.') continue;\n                    else temp[i][j] = 'x';\n                    \n                    for (int k = 0; k < 8; ++k) {\n                        int ni = i, nj = j;\n                        int tcon = 0; bool ok = true;\n                        vector<string> ttemp = temp;\n                        \n                        while (true) {\n                            ni += dx[k]; nj += dy[k];\n                            if (ni < 0 || ni >= 8 || nj < 0 || nj >= 8) {\n                                ok = false;\n                                break;\n                            }\n                            if (temp[ni][nj] == 'o') {\n                                ++tcon;\n                                ttemp[ni][nj] = 'x';\n                            }\n                            else if (temp[ni][nj] == 'x') {\n                                break;\n                            }\n                            else if (temp[ni][nj] == '.') {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            con += tcon;\n                            temp = ttemp;\n                        }\n                    }\n                    \n                    if (Max < con) {\n                        Max = con;\n                        mx = i;\n                        my = j;\n                        mb = temp;\n                    }\n                }\n            }\n            \n            if (Max == 0) {\n                ++pass;\n                if (pass == 2) break;\n            }\n            else {\n                pass = 0;\n                board = mb;\n            }\n            par = 0;\n        }\n        \n    }\n    \n    for (int i = 0; i < 8; ++i) {\n        cout << board[i] << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\n//????????????????¨???????\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\n\n//f?????¶?????§x,y???c??????????????????????????£????????????????????°\nint revnums(char f[8][9], int x, int y, char c, int flag){\n  int ret=0;\n\n  char e_cookie;\n  if(c=='o') e_cookie='x';\n  else e_cookie='o';\n\n  if(f[x][y]=='.'){ //??????????????????????????§??????????????????????????????\n    //8??????????????????\n    for(int i=0; i<8; ++i){\n      int r=1;\n\n      while(0<=x+r*dx[i] && x+r*dx[i]<8 && 0<=y+r*dy[i] && y+r*dy[i]<8){\n        char focus=f[x+r*dx[i]][y+r*dy[i]];\n        if(focus==c){ //?????????????????????\n          //???????????????????????????????????£????????????????????°?????????\n\n          //??????????????£????????????\n          if(flag==1){\n            //????????????\n            f[x][y]=c;\n            //?????£????????????\n            for(int j=1; j<r; ++j){\n              f[x+j*dx[i]][y+j*dy[i]] = c;\n            }\n          }\n\n          ret+=r-1;\n          break;\n        }\n        else if(focus==e_cookie){ //??????????????????????????????\n          r++;\n        }\n        else{ //?????????????????????????????£???\n          break;\n        }\n      }\n\n    }\n\n  }\n  return ret;\n}\n\nbool charlotte(char f[8][9]){\n  int rev=0;\n  int x=-1,y=-1;\n  char c='x';\n  //????????????\n  for(int i=7; i>=0; --i){\n    for(int j=7; j>=0; --j){\n      int tmp=revnums(f,i,j,c,0);\n      if(rev<tmp){\n        rev=tmp;\n        x=i;\n        y=j;\n      }\n    }\n  }\n\n  //???????????´???????????£??????????????´?????????????????????????????´\n  if(x>=0){\n    revnums(f,x,y,c,1);\n  }\n\n  return (rev>0);\n}\n\nbool tomoe(char f[8][9]){\n  int rev=0;\n  int x=-1,y=-1;\n  char c='o';\n  //????????????\n  for(int i=0; i<8; ++i){\n    for(int j=0; j<8; ++j){\n      int tmp=revnums(f,i,j,c,0);\n      if(rev<tmp){\n        rev=tmp;\n        x=i;\n        y=j;\n      }\n    }\n  }\n\n  //???????????´???????????£??????????????´?????????????????????????????´\n  if(x>=0){\n    revnums(f,x,y,c,1);\n  }\n\n  return (rev>0);\n}\n\nvoid print_field(char f[8][9]){\n  for(int i=0; i<8; ++i){\n    for(int j=0; j<8; ++j){\n      printf(\"%c\", f[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main(){\n  char f[8][9];\n\n  for(int i=0; i<8; ++i)\n  for(int j=0; j<8; ++j)\n  scanf(\" %c\", &f[i][j]);\n\n  bool c=true, t=true;\n  while(c || t){\n    t=tomoe(f);\n    c=charlotte(f);\n  }\n\n  print_field(f);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint dx[8] = {1,1,1,-1,-1,-1,0,0}, dy[8] = {1,0,-1,1,0,-1,1,-1};\n\nint main(){\n\tchar cell[8][8];\n\trep(i,8) rep(j,8) cin >> cell[i][j];\n\tbool pass = false;\n\tfor(int u = 0;; u++){\n\t\tif(u%2 == 0){\n\t\t\tP put;\n\t\t\tint num = 0;\n\t\t\trep(i,8) rep(j,8){\n\t\t\t\tif(cell[i][j] != '.') continue;\n\t\t\t\tint sum = 0;\n\t\t\t\trep(k,8){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t\tif(0>y||y>=8||0>x||x>=8||cell[y][x] == '.'){\n\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'o'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'x') cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tsum += cnt;\n\t\t\t\t}\n\t\t\t\tif(sum > num){\n\t\t\t\t\tput.fi = i;\n\t\t\t\t\tput.sec = j;\n\t\t\t\t\tnum = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == 0){\n\t\t\t\tif(pass) break;\n\t\t\t\telse pass = true;\n\t\t\t} else{\n\t\t\t\tpass = false;\n\t\t\t\tcell[put.fi][put.sec] = 'o';\n\t\t\t\trep(k,8){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint y = put.fi, x = put.sec;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t\tif(0>y||y>=8||0>x||x>=8||cell[y][x] == '.'){\n\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'o'){\n\t\t\t\t\t\t\tfor(int l = 1; l <= cnt; l++){\n\t\t\t\t\t\t\t\ty -= dy[k]; x -= dx[k];\n\t\t\t\t\t\t\t\tcell[y][x] = 'o';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'x') cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else{\n\t\t\tP put;\n\t\t\tint num = 0;\n\t\t\tfor(int i = 7; i >= 0; i--) for(int j = 7; j >= 0; j--){\n\t\t\t\tif(cell[i][j] != '.') continue;\n\t\t\t\tint sum = 0;\n\t\t\t\trep(k,8){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint y = i, x = j;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t\tif(0>y||y>=8||0>x||x>=8||cell[y][x] == '.'){\n\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'x'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'o') cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tsum += cnt;\n\t\t\t\t}\n\t\t\t\tif(sum > num){\n\t\t\t\t\tput.fi = i;\n\t\t\t\t\tput.sec = j;\n\t\t\t\t\tnum = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == 0){\n\t\t\t\tif(pass) break;\n\t\t\t\telse pass = true;\n\t\t\t} else{\n\t\t\t\tpass = false;\n\t\t\t\tcell[put.fi][put.sec] = 'x';\n\t\t\t\trep(k,8){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint y = put.fi, x = put.sec;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t\tif(0>y||y>=8||0>x||x>=8||cell[y][x] == '.'){\n\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'x'){\n\t\t\t\t\t\t\tfor(int l = 1; l <= cnt; l++){\n\t\t\t\t\t\t\t\ty -= dy[k]; x -= dx[k];\n\t\t\t\t\t\t\t\tcell[y][x] = 'x';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cell[y][x] == 'o') cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,8){\n\t\trep(j,8){\n\t\t\tcout << cell[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Dessert Witch\n// 右横にひっくり返せぬ\n\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint s[8][8];\n\nint endJudge() {\n  int maru = 0, batu = 0, notYet = 0;\n  for(int i=0; i<8; i++) {\n    for(int j=0; j<8; j++) {\n      if(s[i][j] == -1)\n\tmaru++;\n      else if(s[i][j] == 1)\n\tbatu++;\n      else\n\tnotYet++;\n    }\n  }\n\n  if(maru==0 || batu==0 || notYet==0)\n    return 1;\n  else\n    return 0;\n}\n\nint calcMass(int currentX, int currentY, int mode) {\n  int tmp = 0;\n  int score = 0;\n  bool flag=true;\n\n  for(int k=1; k<8/* && flag==true*/; k++) { // 左上へ探索\n    if(0<=currentX-k && 0<=currentY-k) {\n      if(s[currentX-k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY-k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 上へ探索\n    if(0<=currentY-k) {\n      if(s[currentX][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY-k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 右上へ探索\n    if(0<=currentY-k && currentX+k<8) {\n      if(s[currentX+k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY-k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8; k++) { // 左横へ検索\n    if(0<=currentX-k) {\n      if(s[currentX-k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY] == mode) {\n\tscore+=tmp;\n\tbreak;\n     }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8; k++) { // 右横へ検索\n    if(currentX+k < 8) {\n      if(s[currentX+k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 左下へ検索\n    if(0<=currentX-k && currentY+k<8) {\n      if(s[currentX-k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY+k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 下へ検索\n    if(currentY+k<8) {\n      if(s[currentX][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY+k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 右下へ検\n    if(currentX+k<8 && currentY+k<8) {\n      if(s[currentX+k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY+k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n  return score;\n}\n\n\n\nvoid setOsero(int x, int y, int mode) {\n  int currentX = x, currentY = y;\n  int tmp;\n  s[x][y] = mode;\n\n  tmp=0;\n  for(int k=1; k<8; k++) { // 左上へ探索\n    if(0<=currentX-k && 0<=currentY-k) {\n      if(s[currentX-k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY-k] == mode) {\n\tfor(int l=1; l<tmp+1; l++) {\n\t  s[currentX-l][currentY-l] *= -1;\n\t}\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 上へ探索\n    if(0<=currentY-k) {\n      if(s[currentX][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY-k] == mode) {\n\tfor(int l=1; l<tmp+1; l++) {\n\t  s[currentX][currentY-l] *= -1;\n\t}\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 右上へ探索\n    if(0<=currentY-k && currentX+k<8) {\n      if(s[currentX+k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY-k] == mode) {\n\tfor(int l=1; l<tmp+1; l++) {\n\t  s[currentX+l][currentY-l] *= -1;\n\t}\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 左横へ検索\n    if(0<=currentX-k) {\n      if(s[currentX-k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX-l][currentY] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 右横へ検索\n    if(0<=currentX+k) {\n      if(s[currentX+k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX+l][currentY] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 左下へ検索\n    if(0<=currentX-k && currentY+k<8) {\n      if(s[currentX-k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY+k] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX-l][currentY+l] *= -1;\n        break;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 下へ検索\n    if(currentY+k<8) {\n      if(s[currentX][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY+k] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX][currentY+l] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 右下へ検\n    if(currentX+k<8 && currentY+k<8) {\n      if(s[currentX+k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY+k] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX+l][currentY+l] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n}\n\nvoid drawOsero() {\n  for(int i=0; i<8; i++) {\n    for(int j=0; j<8; j++) {\n      if(s[i][j] == -1)\n\tcout<<\"o\";\n      else if(s[i][j] == 1)\n\tcout<<\"x\";\n      else\n\tcout<<\".\";\n    }\n    cout<<endl;\n  }\n}\n\nint main() {\n  //int s[8][8]; // o:-1 x:1 .:0\n  //int test=0;\n\n  for(int i=0; i<8; i++) {\n    // Input\n    string tmp;\n    getline(cin, tmp);\n    for(int j=0; j<8; j++) {\n      if(tmp[j] == 'o') \n\ts[i][j] = -1;\n      else if(tmp[j] == 'x')\n\ts[i][j] = 1;\n      else\n\ts[i][j] = 0;\n    }\n  }\n  drawOsero();\n\n  while(true) {\n    int setI, setJ;\n    int tmp;\n    int maxTmp=0;\n    int outo;\n\n    outo=0;\n    // いくつ置けるのかを計算\n    for(int i=0; i<8; i++) {\n      for(int j=0; j<8; j++) {\n\tif(s[i][j] == 0) { // 空きマスである\n\t  int tmp=calcMass(i, j, -1);\n\t  if(tmp>maxTmp) {\n\t    maxTmp = tmp;\n\t    setI = i;\n\t    setJ = j;\n\t  }\n\t}\n      }\n    }\n    // 先行が置く\n    if(maxTmp != 0)\n      setOsero(setI, setJ, -1);\n    else\n      outo++;\n    cout<<\"S:\"<<maxTmp<<endl;\n    drawOsero();\n\n\n\n   maxTmp=0;\n   for(int i=7; i>=0; i--) {\n      for(int j=7; j>=0; j--) {\n\tif(s[i][j] == 0) { // 空きマスである\n\t  int tmp=calcMass(i, j, 1);\n\t  if(tmp>maxTmp) {\n\t    maxTmp = tmp;\n\t    setI = i;\n\t    setJ = j;\n\t  }\n\t}\n      }\n    }\n    // 後攻が置く\n   if(maxTmp != 0) \n     setOsero(setI, setJ, 1);\n   else\n     outo++;\n   cout<<\"A:\"<<maxTmp<<endl;\n   drawOsero();\n\n   if(endJudge()==1 || outo==2)\n     break;\n   cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0,-1,1,1,-1}, dy[] = {0,1,0,-1,-1,-1,1,1};\n\nint _flip(vvc& field, bool turn, int x, int y, int d) {\n    char cookie = turn ? 'o' : 'x';\n    char other_cookie = !turn ? 'o' : 'x';\n    if (0 <= x && x < 8 && 0 <= y && y < 8 && field[y][x] != '.') {\n        if (field[y][x] == other_cookie) {\n            int cnt = _flip(field, turn, x+dx[d], y+dy[d], d);\n            if (cnt == -1) {\n                return -1;\n            }\n            field[y][x] = cookie;\n            return cnt+1;\n        } else {\n            return 0;\n        }\n    }\n    return -1;\n}\n\nbool flip(vvc& field, bool turn) {\n    int ma = 0;\n    int X = -1, Y = -1;\n    char cookie = turn ? 'o' : 'x';\n    char other_cookie = !turn ? 'o' : 'x';\n    if (turn) {\n        REP(y, 8) REP(x, 8) {\n            if (field[y][x] != '.') continue;\n            bool ok = false;\n            REP(i, 8) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == other_cookie) {\n                    ok = true;\n                }\n            }\n            if (ok) {\n                vvc _field = field;\n                int cnt = 0;\n                REP(i, 8) {\n                    int sx = x + dx[i], sy = y + dy[i];\n                    cnt += max(0, _flip(_field, turn, sx, sy, i));\n                }\n                if (ma < cnt) {\n                    ma = cnt;\n                    X = x;\n                    Y = y;\n                }\n            }\n        }\n    } else {\n        RREP(y, 8) RREP(x, 8) {\n            if (field[y][x] != '.') continue;\n            bool ok = false;\n            REP(i, 8) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == other_cookie) {\n                    ok = true;\n                }\n            }\n            if (ok) {\n                vvc _field = field;\n                int cnt = 0;\n                REP(i, 8) {\n                    int sx = x + dx[i], sy = y + dy[i];\n                    cnt += max(0, _flip(_field, turn, sx, sy, i));\n                }\n                if (ma < cnt) {\n                    ma = cnt;\n                    X = x;\n                    Y = y;\n                }\n            }\n        }\n    }\n    if (X == -1) return false;\n    field[Y][X] = cookie;\n    REP(i, 8) {\n        int sx = X + dx[i], sy = Y + dy[i];\n        _flip(field, turn, sx, sy, i);\n    }\n    return true;\n}\n\nint main() {\n    vvc field(8, vc(8));\n    REP(y, 8) REP(x, 8) cin >> field[y][x];\n\n    bool turn = true;\n    bool passed = false;\n    while (1) {\n        if (!flip(field, turn)) {\n            if (passed) break;\n            passed = true;\n        }\n        turn = !turn;\n    }\n    REP(y, 8) {\n        REP(x, 8) {\n            printf(\"%c\", field[y][x]);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint dx[] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nint rev(int n) {\n    return n == 1 ? 2 : 1;\n}\n\nbool inFloor(int x, int y) {\n    if (0 <= x && x < 8 && 0 <= y && y < 8) return true;\n    return false;\n}\n\nint main() {\n    mat d(8, vec(8));\n\n    for (auto &i : d) {\n        for (auto &j : i) {\n            char c; cin >> c;\n            if (c == 'o') j = 1;\n            if (c == 'x') j = 2;\n        }\n    }\n\n    int turn = 1;\n    int noChangeCount = 0;\n    while (1) {\n        int tx(-1), ty(-1);\n        int dir;\n        int count = 1;\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0 ; j < 8; j++) {\n                if (d[i][j] == 0) {\n                    int count_ = 0;\n                    for (int k = 0; k < 8; k++) {\n                        int x = i + dx[k];\n                        int y = j + dy[k];\n                        int tmp = 0;\n                        while (inFloor(x, y) && d[x][y] == rev(turn)) {\n                            x += dx[k], y += dy[k];\n                            tmp++;\n                        }\n                        if (inFloor(x,y) && d[x][y] == turn) count_ += tmp;\n                    }\n\n                    if (count < count_ || (count_ > 0 && tx < 0)) {\n                        tx = i; ty = j; count = count_;\n                    } else if (count == count_) {\n                        if (turn == 1) {\n                            if (tx > i) tx = i, ty = j;\n                            else if (tx == i && ty > j) ty = j;\n                        } else {\n                            if (tx < i) tx = i, ty = j;\n                            else if (tx == i && ty < j) ty = j;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (tx > -1) {\n            d[tx][ty] = turn;\n            for (int i = 0; i < 8; i++) {\n                int x = tx + dx[i];\n                int y = ty + dy[i];\n                while (inFloor(x, y) && d[x][y] == rev(turn)) {\n                    x += dx[i], y += dy[i];\n                }\n                if (inFloor(x, y) && d[x][y] == turn)\n                    while (inFloor(x, y) && d[(x+=dx[(i+4)%8])][(y+=dy[(i+4)%8])] == rev(turn))\n                        d[x][y] = turn;\n            }\n        } else noChangeCount++;\n        if (noChangeCount >= 2) break;\n        turn = rev(turn);\n    }\n\n    for (auto i : d) {\n        for (auto j : i) {\n            if (j == 1) cout << 'o';\n            else if (j == 2) cout << 'x';\n            else cout << '.';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\n\nconst int N = 8;\n\nchar field[10][10];\n\nint dig(int turn, int y, int x, int vy, int vx, bool replac) {\n    const char mychr = turn == 1 ? 'o' : 'x';\n    const char enchr = turn == 1 ? 'x' : 'o';\n    if (field[y][x] == mychr)\n        return 0;\n    if (field[y][x] == enchr) {\n        int r = dig(turn, y + vy, x + vx, vy, vx, replac);\n        if (r >= 0 && replac) field[y][x] = mychr;\n        return r >= 0 ? r + 1 : -1;\n    }\n    return -1;\n}\n\nint main() {\n\n    repeat(i, N) {\n        string s; scanner >> s;\n        repeat(j, N) {\n            field[i + 1][j + 1] = s[j];\n        }\n    }\n\n    int halt = 0;\n    int turn = 1;\n    while (true) {\n        char mychr = turn == 1 ? 'o' : 'x';\n        array<int, 3> best = { 0, 0, 0 };\n        iterate(y, 1, N+1) {\n            iterate(x, 1, N + 1) {\n                if (field[y][x] != '.') continue;\n                int s = 0;\n                iterate(vy, -1, 2) {\n                    iterate(vx, -1, 2) {\n                        if (vx == 0 && vy == 0) continue;\n                        int l = dig(turn, y + vy, x + vx, vy, vx, false);\n                        if (l >= 0) s += l;\n                    }\n                }\n                if (turn == 1)\n                    minset(best, array<int, 3>{-s, y, x});\n                else\n                    minset(best, array<int, 3>{-s, -y, -x});\n\n            }\n        }\n        if (best[0]) {\n            int y, x;\n            if (turn == 1)\n                y = best[1], x = best[2];\n            else\n                y = -best[1], x = -best[2];\n            field[y][x] = mychr;\n            iterate(vy, -1, 2) {\n                iterate(vx, -1, 2) {\n                    int l = dig(turn, y + vy, x + vx, vy, vx, true);\n                }\n            }\n            halt = 0;\n        }\n        else\n            if (++halt >= 2) break;\n        \n        turn *= -1;\n        \n    }\n    \n    iterate(y, 1, N+1) {\n        iterate(x, 1, N+1) {\n            printer << field[y][x];\n        }\n        printer << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\ntypedef vector<string> VS;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\ntemplate<typename T>\nvoid dump(T a, int n) { for (int i = 0; i < n; i++) cout << a[i] << (i == n - 1 ? '\\n' : ' '); }\n\ntemplate<typename T>\nvoid dump(T a) { dump<T>(a, a.size()); }\n\nconstexpr int dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconstexpr int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nbool can_reverse(VS &S, int y, int x, int di, bool is_mami) {\n\tint i = 0;\n\twhile (true) {\n\t\tx += dx[di];\n\t\ty += dy[di];\n\n\t\tif (x < 0 || y < 0 || x >= 8 || y >= 8 || S[y][x] == '.') {\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\n\t\tif (S[y][x] == (is_mami ? 'o' : 'x')) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\nbool simulation(VS &S, int y0, int x0, bool is_mami) {\n\tif (S[y0][x0] != '.') {\n\t\treturn false;\n\t}\n\t\n\tS[y0][x0] = is_mami ? 'o' : 'x';\n\n\tbool flg = false;\n\tfor (int i = 0; i < 8; i++) {\n\t\tif (!can_reverse(S, y0, x0, i, is_mami)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = x0;\n\t\tint y = y0;\n\t\t\n\n\t\twhile (true) {\n\t\t\tx += dx[i];\n\t\t\ty += dy[i];\n\n\t\t\tif (x < 0 || y < 0 || x >= 8 || y >= 8\n\t\t\t\t\t|| S[y][x] == '.'\n\t\t\t\t\t|| S[y][x] == (is_mami ? 'o' : 'x')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[y][x] = is_mami ? 'o' : 'x';\n\t\t\tflg |= true;\n\t\t}\n\t}\n\n\treturn flg;\n}\n\nint counter(VS &S, bool is_mami) {\n\tint cnt = 0;\n\t\n\tfor (int i = 0; i < 8; i++) {\n\t\tcnt += count(S[i].begin(), S[i].end(), is_mami ? 'o' : 'x');\n\t}\n\n\treturn cnt;\n}\n\nint main(void) {\n\tVS S(8);\n\tfor (auto &s : S) cin >> s;\n\n\tbool is_mami = true;\n\tbool cannot = false;\n\twhile(true) {\n\t\tVS max_next;\n\t\tint now = counter(S, is_mami);\n\t\tint max_cookie = -1;\n\t\t\n\t\tfor (int y = 0; y < 8; y++) {\n\t\t\tfor (int x = 0; x < 8; x++) {\t\n\t\t\t\tVS next(S);\n\n\t\t\t\tif (!simulation(next, y, x, is_mami)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint cookie = counter(next, is_mami);\n\t\t\t\tif (cookie != now &&\n\t\t\t\t\t\t((is_mami && cookie > max_cookie) || \n\t\t\t\t\t\t (!is_mami && cookie >= max_cookie))) {\n\t\t\t\t\tmax_cookie = cookie;\n\t\t\t\t\tmax_next = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (max_cookie == -1) {\n\t\t\tif (cannot) {\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tcannot = true;\n\t\t\t\tis_mami = !is_mami;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcannot = false;\n\t\tS = max_next;\n\t\tis_mami = !is_mami;\n\t}\n\n\tfor (auto s : S) cout << s << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nint dx[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n\nvector<vector<int>>field(8, vector<int>(8));\nbool ok(int y, int x) {\n\treturn y >= 0 && y <= 7 && x >= 0 && x <= 7;\n}\n\nint turn(bool mami,vector<vector<int>>&field,const int y,const int x) {\n\n\tfield[y][x] = mami ? 1 : 2;\n\tint changenum = 0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tint num = 0;\n\t\tif (!ok(ny, nx))continue;\n\t\tif ((mami&&field[ny][nx] == 2) || (!mami&&field[ny][nx] == 1)) {\n\t\t\twhile (1) {\n\t\t\t\tnx += dx[i];\n\t\t\t\tny += dy[i];\n\t\t\t\tnum++;\n\t\t\t\tif (!ok(ny, nx))break;\n\t\t\t\tif ((mami&&field[ny][nx] == 2) || (!mami&&field[ny][nx] == 1)) {\n\n\t\t\t\t}\n\t\t\t\telse if (!field[ny][nx]) {\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int a = 1; a <= num; ++a) {\n\t\t\t\t\t\tfield[y + dy[i] * a][x + dx[i] * a] = mami ? 1 : 2;\n\t\t\t\t\t}\n\t\t\t\t\tchangenum += num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn changenum;\n}\nint main() {\n\tfor (int i = 0; i < 8; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (st[j] == 'o') {\n\n\t\t\t\tfield[i][j] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'x') {\n\t\t\t\tfield[i][j] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tbool mami = true;\n\tint flag = 2;\n\twhile (flag) {\n\t\tflag--;\n\n\n\t\tvector<vector<int>>nums(8,vector<int>(8));\n\n\t\tfor (int y = 0; y < 8; ++y) {\n\t\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\t\tif (!field[y][x]) {\n\t\t\t\t\tvector<vector<int>>cfield(field);\n\t\t\t\t\tnums[y][x] = turn(mami, cfield, y, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = 0;\n\t\tint max_y;\n\t\tint max_x = 0;\n\t\tif (mami) {\n\t\t\tfor (int y = 0; y < 8; ++y) {\n\t\t\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\t\t\tif (nums[y][x]>amax) {\n\t\t\t\t\t\tamax = nums[y][x];\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int y = 7; y >=0; --y) {\n\t\t\t\tfor (int x = 7; x >=0; --x) {\n\t\t\t\t\tif (nums[y][x]>amax) {\n\t\t\t\t\t\tamax = nums[y][x];\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amax == 0) {}\n\t\telse {\n\t\t\tflag = 2;\n\t\t\tturn(mami, field, max_y, max_x);\n\t\t\t\n\t\t}\n\t\tmami = !mami;\n\t}\n\tfor (int y = 0; y < 8; ++y) {\n\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\tif (field[y][x] == 2) {\n\t\t\t\tcout << 'x';\n\t\t\t}\n\t\t\telse if (field[y][x] == 1) {\n\t\t\t\tcout << 'o';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << '.';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\nchar s[8][8];\nint dx[8]={1,1,1,0,0,-1,-1,-1};\nint dy[8]={1,0,-1,1,-1,1,0,-1};\nset<char*> count(int i,int j,char c){\n  set<char*> ret;\n  for(int lp=0,x,y;lp<8;lp++){\n    x=i;y=j;\n    for(int k=0;k<8;k++ ){\n      x+=dx[lp]; y+=dy[lp];\n      if(x<0||x>=8||y<0||y>=8||s[x][y]=='.') break;\n      if(s[x][y]!=c) continue;\n      if(k==0) break;\n      x=i;y=j;\n      while( k-- )\n\tret.insert( &s[x+=dx[lp]][y+=dy[lp]] );\n      break;\n    }\n  }\n  if(!ret.empty())\n    ret.insert(&s[i][j]);\n  return ret;\n}\n\nvoid proc(int i,int j,char c,set<char*> &ret){\n  if(s[i][j]=='.'){\n    set<char*> tmp=count(i,j,c);\n    if(tmp.size()>ret.size()&&tmp.size()>1)\n      ret=tmp;\n  }\n}\n\nint turn(bool f){\n  char c=f?'o':'x';\n  set<char*> ret;\n  if(f){\n    for(int i=0;i<8;i++)\n      for(int j=0;j<8;j++)\n\tproc(i,j,c,ret);\n  }else{\n    for(int i=7;i>=0;i--)\n      for(int j=7;j>=0;j--)\n\tproc(i,j,c,ret);\n  }\n  for(set<char*>::iterator it=ret.begin();it!=ret.end();it++)\n    **it=c;\n  return ret.size();\n}\n\nint main(){\n  for(int i=0;i<8;i++)\n    for(int j=0;j<8;j++)\n      cin>>s[i][j];\n  bool f=true;\n  while(true){\n    if(turn(f)==0){\n      f=!f;\n      if(turn(f)==0)\n\tbreak;\n    }\n    f=!f;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++)\n      cout<<s[i][j];\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> mov;\n\nchar S[8][8];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < 8 && 0 <= x && x < 8;\n}\n\nint main(void) {\n  REP(i, 0, 8) cin >> S[i];\n\n  char me = 'o';\n  char op = me == 'x' ? 'o' : 'x';\n  char em = '.';\n  int pass = 0;\n  while(1) {\n    int ans = 0, ay = -1, ax = -1;\n    vector<mov> mv;\n    REP(i, 0, 8) REP(j, 0, 8) {\n      if(S[i][j] != em) continue;\n      int cnt = 0;\n      vector<mov> v;\n      REP(k, -1, 2) REP(l, -1, 2) {\n        int y = i, x = j;\n        if(k == 0 && l == 0) continue;\n        int q = 0;\n        while(1) {\n          y += k;\n          x += l;\n          if(!isin(y, x)) break;\n          if(S[y][x] == op) q++;\n          else break;\n        }\n        if(!(isin(y, x) && S[y][x] == me)) q = 0;\n        cnt += q;\n        if(q > 0) v.push_back(mov(pii(k, l), q));\n      }\n      if((me == 'o' && ans < cnt) || (me == 'x' && ans <= cnt)) {\n        mv = v;\n        ans = cnt;\n        ay = i;\n        ax = j;\n      }\n    }\n    if(mv.size() > 0) {\n      S[ay][ax] = me;\n      REP(i, 0, mv.size()) {\n        int y = ay, x = ax;\n        REP(j, 0, mv[i].se) {\n          y += mv[i].fi.fi;\n          x += mv[i].fi.se;\n          S[y][x] = me;\n        }\n      }\n      pass = 0;\n    } else {\n      if(pass == 1) break;\n      pass = 1;\n    }\n    swap(me, op);\n  }\n\n  REP(i, 0, 8) {\n    REP(j, 0, 8) cout << S[i][j];\n    cout << endl;\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\ninline bool inside(int i, int j, int n){\n  return 0 <= i && i < n && 0 <= j && j < n;\n}\n\npair<int, vector<string> > flip(const vector<string> &field, int x, int y, char c){\n  int n = field.size();\n  \n  int ans = 0;\n  vector<string> board = field;\n  board[x][y] = c;\n  \n  REP2(dx, -1, 2)REP2(dy, -1, 2){\n    if(dx == 0 && dy == 0) continue;\n    int tx = x + dx, ty = y + dy;\n    \n    while(inside(tx, ty, n) && board[tx][ty] != '.' && board[tx][ty] != c){\n      tx += dx;\n      ty += dy;\n    }\n    \n    if(inside(tx, ty, n) && board[tx][ty] == c){\n      tx = x + dx, ty = y + dy;\n      while(inside(tx, ty, n) && board[tx][ty] != '.' && board[tx][ty] != c) {\n        board[tx][ty] = c;\n        tx += dx;\n        ty += dy; \n        ans++;\n      }\n    }\n  }\n  return make_pair(ans, board);\n}\n\nint main(){\n  vector<string> field(8);\n  REP(i, 8) cin >> field[i];\n\n  int s = 0;\n  REP(i, 8) s += count(ALL(field[i]), '.');\n  bool mami = s % 2 == 0;\n  int bad = 0;\n  \n  while(true){\n    int best = 0;\n    vector<string> bestboard;\n    \n    REP(i, 8) REP(j, 8)if(field[i][j] == '.'){\n      pair<int, vector<string> > p = flip(field, i, j, mami ? 'o' : 'x');\n      if(p.first > best || (!mami && p.first >= best)){\n        best = p.first;\n        bestboard = p.second;\n      }\n    }\n    \n    if(best > 0){\n      bad = 0;\n      field = bestboard;\n    }\n    \n    if(best == 0 && bad++ > 10) break;\n    mami = !mami;\n  }\n  REP(i, 8) cout << field[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s[8];\nchar c[2]={'o','x'};\nint dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};\nint t;\n\nint dfs(int d,int x,int y){\n  if(min(x,y)<0||7<max(x,y)||s[y][x]=='.')return -9;\n  if(s[y][x]==c[t])return 0;\n  return dfs(d,x+dx[d],y+dy[d])+1;\n}\n\nvoid solve(){\n\n  int ct=0;\n\n  while(ct++<150){  \n\n    int px=-1,py=-1,mx=0;\n    \n    for(int y=0;y<8;y++)\n      for(int x=0;x<8;x++){\n\n\tint xx=x,yy=y,res=0;\n\tif(t)xx=7-x,yy=7-y;\n\tif(s[yy][xx]!='.')continue;\n\tfor(int i=0;i<8;i++)\n\t  res+=max(0,dfs(i,xx+dx[i],yy+dy[i]));\n\tif(res>mx)px=xx,py=yy,mx=res;\n      }\n\n    if(mx)\n      for(int i=0;i<8;i++){\n\tint res=dfs(i,px+dx[i],py+dy[i]);\n\tfor(int j=0;j<=res;j++)\n\t  s[py+j*dy[i]][px+j*dx[i]]=c[t];\n      }\n    \n    t=!t;\n  }\n  \n}\n\nint main(){\n  for(int i=0;i<8;i++)cin>>s[i];\n  \n  solve();\n  \n  for(int i=0;i<8;i++)cout<<s[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nstruct ChooseHand{\n  int pos_x;\n  int pos_y;\n  int dir;\n  int get_stone_num;\n};\n\nchar stage[8][8];\n\nChooseHand search(int x,int y,char stone){\n  int max_get_stone_num = 0;\n  char inv_stone = (stone == 'o' ? 'x' : 'o');\n\n  int get_stone_num = 0;\n  int dir = 0;\n  for(int t_idx=0;t_idx<8;t_idx++){\n    int tmp_get_num = 0;\n    bool is_close = false;\n    for(int dist=1;dist<=8;dist++){\n      int dx = x + tx[t_idx] * dist;\n      int dy = y + ty[t_idx] * dist;\n      if(dx < 0 || dy < 0 \n\t || dx >= 8 || dy >= 8) break;\n\n      if(stage[dy][dx] == inv_stone){\n\ttmp_get_num++;\n      }\n      else if(stage[dy][dx] == stone){\n\tis_close = true;\n\tdir |= (1<<t_idx);\n\tbreak;\n      }\n      else{\n\tbreak;\n      }\n    }\n    if(is_close){\n      get_stone_num += tmp_get_num;\n    }\n  }\n\n  ChooseHand ch = {x,y,dir,get_stone_num};\n  return ch;\n}\n\nChooseHand SearchForMami(char stone){\n  int max_get_stone_num = 0;\n  ChooseHand ch = {-1,-1,0,0};\n  \n  for(int y=0;y<8;y++){\n    for(int x=0;x<8;x++){\n      if(stage[y][x] != '.'){\n\tcontinue;\n      }\n      ChooseHand tmp_ch = search(x,y,stone);\n      if(max_get_stone_num < tmp_ch.get_stone_num){\n\tmax_get_stone_num = tmp_ch.get_stone_num;\n\tch = tmp_ch;\n      }\n    }\n  }\n  return ch;\n}\n\nChooseHand SearchForWitch(char stone){\n  int max_get_stone_num = 0;\n  ChooseHand ch = {-1,-1,0,0};\n  \n  for(int y=8-1;y>=0;y--){\n    for(int x=8-1;x>=0;x--){\n      if(stage[y][x] != '.'){\n\tcontinue;\n      }\n      ChooseHand tmp_ch = search(x,y,stone);\n      if(max_get_stone_num < tmp_ch.get_stone_num){\n\tmax_get_stone_num = tmp_ch.get_stone_num;\n\tch = tmp_ch;\n      }\n    }\n  }\n  return ch;\n}\n\nvoid FlipStones(ChooseHand ch,char stone){\n  int x = ch.pos_x;\n  int y = ch.pos_y;\n  stage[y][x] = stone;\n\n  for(int t_idx=0;t_idx<8;t_idx++){\n    if(!(ch.dir & (1<<t_idx))) continue;\n    for(int dist=1;dist <= 8; dist++){\n      int dx = ch.pos_x + tx[t_idx] * dist;\n      int dy = ch.pos_y + ty[t_idx] * dist;\n      if(stage[dy][dx] == stone\n\t || stage[dy][dx] == '.') break;\n      stage[dy][dx] = stone;\n    }\n  }\n}\n\nvoid PrintStage(){\n  for(int y=0;y<8;y++){\n    for(int x=0;x<8;x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main(){\n  char line[12];\n  while(~scanf(\"%s\",line)){\n    for(int x=0;x<8;x++) stage[0][x] = line[x];\n    for(int y=1;y<8;y++){\n      scanf(\"%s\",line);\n      for(int x=0;x<8;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int is_end = 0; \n    while(1){\n      ChooseHand ch;\n      //first player: mami o upper -> left\n      ch = SearchForMami('o');\n      if(ch.get_stone_num != 0){\n\tFlipStones(ch,'o');\n      }\n      else{\n\tis_end |= (1<<0);\n      }\n\n      //second player: witch x lower -> right\n      ch = SearchForWitch('x');\n      if(ch.get_stone_num != 0){\n\tFlipStones(ch,'x');\n      }\n      else{\n\tis_end |= (1<<1);\n      }\n      \n      if(is_end == (1<<2) - 1) break;\n    }\n    \n    PrintStage();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring a[8];\nint ax[]={-1,-1,-1,0,0,1,1,1};\nint ay[]={-1,0,1,-1,1,-1,0,1};\nint i,j,turn=1,x=7,y=7,cou,k=0,c1=0,c2=0;\nchar mi[]={'x','o'};\nint dfs(int dx,int dy){\n  int aa=dx+1,bb=dy+1;\n  if(y+ay[k]*aa==8||x+ax[k]*bb==8||y+ay[k]*aa<0||x+ax[k]*bb<0)return 0;\n  if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[(turn+1)%2])cou=dfs(aa,bb);\n  else if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[turn%2])return aa-1;\n  else return 0;\n  return cou;\n}\nint ds(){\n  int c=0;\n  for(k=0;k<8;k++){\n    if(ax[k]+x==8||ay[k]+y==8||ax[k]+x<0||ay[k]+y<0)continue;\n    if(a[y+ay[k]][x+ax[k]]==mi[(turn+1)%2]){c+=dfs(0,0);}\n    cou=0;\n  }\n  return c;//\n}\nint re1(int dx,int dy){\n  int c=0,aa=dx+1,bb=dy+1;\n    if(y+ay[k]*aa==8||x+ax[k]*bb==8||y+ay[k]*aa<0||x+ax[k]*bb<0)return 0;\n    if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[(turn+1)%2])c=re1(aa,bb);\n  else if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[turn%2])return 1;\n  else return 0;\n  if(c){a[y+ay[k]*aa][x+ax[k]*bb]=mi[turn%2];\n  return 1;\n    }\n    return 0;\n}\nvoid reverse(){\n  a[y][x]=mi[turn%2];\n  for(k=0;k<8;k++){\n    if(ax[k]+x==8||ay[k]+y==8||(ax[k]+x)<0||(ay[k]+y)<0)continue;\n    if(a[y+ay[k]][x+ax[k]]==mi[(turn+1)%2]){re1(0,0);}\n  }\n}\nvoid tiro(){\n  int m=0,max1=0,xy[8][8];\n  for(y=7;y>=0;y--){\n    for(x=7;x>=0;x--){\n      if(a[y][x]=='.')m=ds();\n      xy[y][x]=m;\n      max1=max(m,max1);\n      m=0;\n    } \n  }\n  if((turn+1)%2){\n  for(y=7;y>=0;y--){\n    if(max1==0)break;\n    for(x=7;x>=0;x--){\n      if(xy[y][x]==max1){\n        reverse();\n        max1=0;\n        break;\n      }\n    }   \n  }\n }\n else{\n  for(y=0;y<8;y++){\n    if(max1==0)break;\n    for(x=0;x<8;x++){\n      if(xy[y][x]==max1){\n        reverse();\n        max1=0;\n        break;\n      }\n    }   \n  }\n }\n} \nint check(){\n  int aa=0,bb=0;\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++){\n      if(a[i][j]=='x')aa++;\n      if(a[i][j]=='o')bb++;\n    }\n  }\n  c1++;\n  if((!aa||!bb)||aa+bb==64||c1>64)return 1;\n  else return 0;\n}\nint main(){\n  for(i=0;i<8;i++)cin>>a[i];\n  while(1){\n    tiro();\n    if(check())break;\n    turn++;\n  }\n  for(i=0;i<8;i++)cout<<a[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring table[8];\nint dx[] = {0,1,1,1,0,-1,-1,-1};\nint dy[] = {-1,-1,0,1,1,1,0,-1};\nbool isInRange(int nx,int ny)\n{\n\tif (nx < 0 || nx >= 8 || ny < 0 || ny >= 8)return false;\n\treturn true;\n}\n\nint isPut(int x,int y,char putCookie)\n{\n\tint maxReverse = 0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\t\n\t\tint count = 0;\n\t\twhile (isInRange(nx, ny) && table[ny][nx] != putCookie && table[ny][nx] != '.')\n\t\t{\n\t\t\tif (putCookie == table[ny][nx])break;\n\t\t\tcount++;\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t}\n\n\t\tif (isInRange(nx,ny) && table[ny][nx] == putCookie)\n\t\t{\n\t\t\tmaxReverse += count;\n\t\t}\n\t}\n\treturn maxReverse;\n}\nvoid reversing(int px, int py,char putCookie)\n{\n\t//?????????????????????????????????\n\ttable[py][px] = putCookie;\n\n\tchar targetCookie;\n\tif (putCookie == 'o')targetCookie = 'x';\n\telse targetCookie = 'o';\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tint ny = py + dy[i];\n\t\tint nx = px + dx[i];\n\t\tbool isPut = false;\n\n\t\tint canReverseCount = 0;\n\t\twhile (isInRange(nx,ny) && table[ny][nx] != '.')\n\t\t{\n\t\t\tif (putCookie == table[ny][nx])\n\t\t\t{\n\t\t\t\tisPut = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcanReverseCount++;\n\t\t\tny += dy[i];\n\t\t\tnx += dx[i];\n\t\t}\n\n\t\tif (isPut)\n\t\t{\n\t\t\tint nextY = py + dy[i];\n\t\t\tint nextX = px + dx[i];\n\t\t\tfor (int j = 0; j < canReverseCount; j++)\n\t\t\t{\n\t\t\t\ttable[nextY][nextX] = putCookie;\n\t\t\t\tnextY = nextY + dy[i];\n\t\t\t\tnextX= nextX + dx[i];\n\t\t\t}\n\t\t}\n\t}\n}\n//???????????´???true?????????\nbool searchPutPos(char putCookie,int turn)\n{\n\tint maxReverse = 0;\n\tint putX = 0;\n\tint putY = 0;\n\tif (turn % 2 == 0)//??´??????????????????\n\t{\n\t\tfor (int i = 0; i < 8; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tif (table[i][j] != '.')continue;\n\t\t\t\t//???????????????????????????????????´??????\n\t\t\t\t//???????????¬????????????????????????????????¢??????????????¨?????§????????°???????????????\n\t\t\t\tint reverseNumber = isPut(j, i, putCookie);\n\t\t\t\tif (reverseNumber == 0)continue;\n\t\t\t\tif (maxReverse < reverseNumber)\n\t\t\t\t{\n\t\t\t\t\tmaxReverse = reverseNumber;\n\t\t\t\t\tputX = j;\n\t\t\t\t\tputY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse//????????????????\\?????????????\n\t{\n\t\tfor (int i = 7; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = 7; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (table[i][j] != '.')continue;\n\t\t\t\tint reverseNumber = isPut(j, i, putCookie);\n\t\t\t\tif (reverseNumber == 0)continue;\n\t\t\t\tif (maxReverse < reverseNumber)\n\t\t\t\t{\n\t\t\t\t\tmaxReverse = reverseNumber;\n\t\t\t\t\tputX = j;\n\t\t\t\t\tputY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//?????¢??????????????¨?????§???????????´???\n\tif (maxReverse == 0)return false;\n\n\t//?????¢??????\n\treversing(putX,putY,putCookie);\n\n\t//cout << putX << \" \"<<putY << endl;\n\treturn true;\n}\nint main()\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tcin >> table[i];\n\t}\n\tbool pfind = true;\n\tfor (int turn = 0;;turn++)\n\t{\n\t\tchar putCookie = '-';//?????????????????????????????\\??????\n\t\tif (turn % 2 == 1)//????????????????\\?????????????\n\t\t{\n\t\t\tputCookie = 'x';//?????????????????????\n\t\t}\n\t\telse//??´??????????????????\n\t\t{\n\t\t\tputCookie = 'o';//?????§?????¬??????????????????\n\t\t}\n\t\t//??????????????????????????´?????????????????£???????????????bool?????????\n\t\tbool find = searchPutPos(putCookie, turn);\n\n\t\tif (!find && !pfind)//????????????????????¬????????????????????????????????£?????????????????????\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tpfind = find;\n\t\t//cout << turn << endl;\n\t}\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tcout << table[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//??????URL http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311&lang=jp\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nchar board[8][8];\n\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\nchar memo[2]={'o','x'};\n//player 0:mami 1:magi\nint dfs(int x,int y,int cnt,int idx,int player){\n    int nx=x+dx[idx],ny=y+dy[idx];\n    if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]==memo[1-player]){\n      cnt++;\n      return dfs(nx,ny,cnt,idx,player);\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]==memo[player]){\n      return cnt;\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n      return 0;\n    }\n    return 0;\n}\n\nint count(int x,int y,int player){\n    int res=0;\n    for(int i=0;i<8;i++) res+=dfs(x,y,0,i,player);\n    return res;\n}\n\nint solve(int player){\n    int ma=-1,x,y;\n    if(player==1){\n        for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n          if(board[i][j]=='.'&&count(i,j,player)>ma){\n            ma=count(i,j,player);\n            x=i;y=j;\n          }\n        }\n    }\n    if(player==0){\n        for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n            if(board[i][j]=='.' && count(i,j,player)>ma){\n                ma=count(i,j,player);\n                x=i;y=j;\n            }\n        }//?????§?????????????????´???\n    }\n    if(ma<1) return 0;\n    board[x][y]=memo[player];\n    for(int i=0;i<8;i++){\n      int tmp=dfs(x,y,0,i,player);\n      for(int j=1;j<=tmp;j++){\n        board[x+dx[i]*j][y+dy[i]*j]=memo[player];\n      }\n    }\n    return 1;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=solve(0);\n    magi_flag=solve(1);\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n#define Foreach(item,collection) for(auto item : collection)\n\nusing pii=pair<int,int>;\nusing vb=vector<bool>;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvc=vector<vector<char>>;\nusing ti3=tuple<int,int,int>;\nusing ulong=unsigned long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n#define OCB(c) (c&1)|(c&2)<<2|(c&4)<<4|(c&8)<<6|(c&16)<<8|(c&32)<<10|(c&64)<<12|(c&128)<<14\n\n\nstruct BitBoard {\n    const bool BT=true;\n    const bool WT=false;\n\n    bool Now;\n    ulong player;\n    ulong opponent;\n\n    BitBoard(ulong player,ulong opponent):player(player),opponent(opponent){}\n\n    const ulong coordinateToBit(int x,int y){\n        ulong mask=0x8000000000000000;\n        \n        switch (x)\n        {\n            case 1:\n                mask>>=1;\n                break;\n            case 2:\n                mask>>=2;\n                break;\n            case 3:\n                mask>>=3;\n                break;\n            case 4:\n                mask>>=4;\n                break;\n            case 5:\n                mask>>=5;\n                break;\n            case 6:\n                mask>>=6;\n                break;\n            case 7:\n                mask>>=7;\n                break;\n            default:\n                break;\n        }\n        mask = mask >> ((y-1)*8);\n        return mask;\n    }\n\n    bool canPut(ulong put){\n        ulong lboard=makeLegalBoard(*this);\n\n        return (put&lboard) == put;\n    }\n\n    ulong makeLegalBoard(BitBoard& board){\n        ulong hwb=board.opponent&0x7e7e7e7e7e7e7e7e;\n        ulong vwb=board.opponent&0x00FFFFFFFFFFFF00;\n        ulong awb=board.opponent&0x007e7e7e7e7e7e00;\n        ulong blank=~(board.player|board.opponent);\n\n        ulong tmp,legal;\n\n        tmp=hwb&(board.player<<1);\n        rep(i,5) tmp|=hwb&(tmp<<1);\n        legal=blank&(tmp<<1);\n\n        tmp=hwb&(board.player>>1);\n        rep(i,5) tmp|=hwb&(tmp>>1);\n        legal|=blank&(tmp>>1);\n\n        tmp=vwb&(board.player<<8);\n        rep(i,5) tmp|=vwb&(tmp<<8);\n        legal|=blank&(tmp<<8);\n        \n        tmp=vwb&(board.player>>8);\n        rep(i,5) tmp|=vwb&(tmp>>8);\n        legal|=blank&(tmp>>8);\n\n        tmp=awb&(board.player<<7);\n        rep(i,5) tmp|=vwb&(tmp<<7);\n        legal|=blank&(tmp<<7);\n        \n        tmp=awb&(board.player<<9);\n        rep(i,5) tmp|=vwb&(tmp<<9);\n        legal|=blank&(tmp<<9);\n        \n        tmp=awb&(board.player>>9);\n        rep(i,5) tmp|=vwb&(tmp>>9);\n        legal|=blank&(tmp>>9);\n        \n        tmp=awb&(board.player>>7);\n        rep(i,5) tmp|=vwb&(tmp>>7);\n        legal|=blank&(tmp>>7);\n        \n        return legal;\n    }\n\n    pair<ulong,ulong> reverse(ulong put){\n        ulong rev=0UL;\n        auto p=player;\n        auto o=opponent;\n        rep(k,8){\n            auto _rev=0UL;\n            auto mask = transfar(put,k);\n            while(mask!=0&&((mask&o)!=0)){\n                _rev|=mask;\n                mask=transfar(mask,k);\n            }\n            if((mask&p)!=0) rev|=_rev;\n\n        }\n            p^=put|rev;\n            o^=rev;\n        return make_pair(p,o);\n    }\n\n    ulong transfar(ulong put,int k){\n        switch (k)\n         {\n            case 0: //上\n                return (put << 8) & 0xffffffffffffff00;\n            case 1: //右上\n                return (put << 7) & 0x7f7f7f7f7f7f7f00;\n            case 2: //右\n                return (put >> 1) & 0x7f7f7f7f7f7f7f7f;\n            case 3: //右下\n                return (put >> 9) & 0x007f7f7f7f7f7f7f;\n            case 4: //下\n                return (put >> 8) & 0x00ffffffffffffff;\n            case 5: //左下\n                return (put >> 7) & 0x00fefefefefefefe;\n            case 6: //左\n                return (put << 1) & 0xfefefefefefefefe;\n            case 7: //左上\n                return (put << 9) & 0xfefefefefefefe00;\n            default:\n                return 0;\n        }\n    }\n\n    bool isGameEnd() {\n        auto plboard=makeLegalBoard(*this);\n        BitBoard board(opponent,player);\n        board.Now=!Now;\n\n        auto olboard=makeLegalBoard(board);\n\n        return plboard==0 && olboard==0;\n    }\n\n    void boardSwap(){\n        auto tmp=player;\n        player=opponent;\n        opponent=tmp;\n        Now=!Now;\n    }\n\n    bool isPass(){\n        auto plboard=makeLegalBoard(*this);\n        BitBoard board(opponent,player);\n        board.Now=!Now;\n        auto olboard=makeLegalBoard(board);\n\n        return plboard==0 && olboard!=0;\n    }\n\n    int Count(ulong b){\n        const int SIZE=64;\n        ulong mask=0x8000000000000000;\n        auto cnt=0;\n        rep(i,SIZE){\n            if((mask&b)!=0) cnt++;\n            mask>>=1;\n        }\n        return cnt;\n    }\n\n};\n\nvoid output(BitBoard board){\n    out(\"-------------------------\")\n    auto pb=board.player;\n    auto ob=board.opponent;\n    rep(i,8) {\n        rep(j,8){\n        if(pb&0x8000000000000000) cout << \"o\";\n        else if(ob&0x8000000000000000) cout << \"x\";\n        else cout << \".\";\n        pb<<=1;\n        ob<<=1;\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    BitBoard board(0,0);\n    rep(i,8) rep(j,8){\n        char sij;\n        cin >> sij;\n        board.player<<=1;\n        board.opponent<<=1;\n        if(sij=='o') board.player|=1;\n        if(sij=='x') board.opponent|=1;\n    }\n    board.Now=board.BT;\n    \n    while(!board.isGameEnd()){\n        if(board.isPass()){ board.boardSwap();}\n        else {\n            auto mx=board.Count(board.player);\n            ulong pq=0UL,oq=0UL;\n            rep(i,8) rep(j, 8){\n                auto put=board.coordinateToBit(i,j);\n                if(!board.canPut(put)) continue;\n                ulong p,o;\n                tie(p,o)=board.reverse(put);\n                auto res=board.Count(p);\n                if(res>mx){\n                    mx=res;\n                    oq=o;\n                    pq=p;\n                }\n            }\n            board.opponent=oq;\n            board.player=pq;\n            board.boardSwap();\n        }\n\n        if(board.isGameEnd()) {board.boardSwap();break;}\n\n        if(board.isPass()){ board.boardSwap();out(\"opponent !!!\")}\n        else {\n            auto mx=board.Count(board.player);\n            ulong pq=0UL,oq=0UL;\n            rep(i,8) rep(j, 8){\n                auto put=board.coordinateToBit(i,j);\n                if(!board.canPut(put)) continue;\n                ulong p,o;\n                tie(p,o)=board.reverse(put);\n                auto res=board.Count(p);\n                if(res>=mx){\n                    mx=res;\n                    oq=o;\n                    pq=p;\n                }\n            }\n            board.opponent=oq;\n            board.player=pq;\n            board.boardSwap();\n        }\n    }\n\n    output(board);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n\nusing namespace std;\nusing ll = long long;\n\nint e_dir[2][8] = {{-1, -1, -1, 0, 0, 1, 1, 1}, {-1, 0, 1, -1, 1, -1, 0, 1}};\ninline bool is_in_field(int y, int x, int h, int w){\n  return (y >= 0 && y < h && x >= 0 && x < w);\n}\n\nstring f[8];\nint solve(int y, int x, int d, bool p, int now){\n  if(!is_in_field(y, x, 8, 8) || f[y][x] == '.') return 0;\n  char my_c = (!p)? 'o' : 'x';\n  if(f[y][x] == my_c) return now;\n  else return solve(y+e_dir[0][d], x+e_dir[1][d], d, p, ++now);\n}\n\nbool color(int y, int x, int d, int p){\n  char my_c = (!p)? 'o' : 'x';\n  if(!is_in_field(y, x, 8, 8) || f[y][x] == '.') return false;\n  else if(f[y][x] == my_c) return true;\n  if(!color(y+e_dir[0][d], x+e_dir[1][d], d, p)) return false;\n  f[y][x] = my_c;\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  for(int i  = 0; i < 8; i++){\n    cin >> f[i];\n  }\n  pair<pair<int, int> , int> nowa, nowb;\n  do{\n    bool p = 0;\n    nowa = {{0, 0}, 0};\n    for(int i = 0; i < 8; i++){\n      for(int j = 0; j < 8; j++){\n        if(f[i][j] == '.'){\n          int t = 0;\n          for(int k = 0; k < 8; k++){\n            t += solve(i+e_dir[0][k], j+e_dir[1][k], k, p, 0);\n          }\n          if(nowa.second < t) nowa = {{i, j}, t};\n        }\n      }\n    }\n    if(nowa.second){\n      for(int i = 0; i < 8; i++) color(nowa.first.first+e_dir[0][i], nowa.first.second+e_dir[1][i], i, p);\n      f[nowa.first.first][nowa.first.second] = 'o';\n    }\n\n    p = !p;\n    nowb = {{0, 0}, 0};\n    for(int i = 7; i >= 0; i--){\n      for(int j = 7; j >= 0; j--){\n        if(f[i][j] == '.'){\n          int t = 0;\n          for(int k = 0; k < 8; k++){\n            t += solve(i+e_dir[0][k], j+e_dir[1][k], k, p, 0);\n          }\n          if(nowb.second < t) nowb = {{i, j}, t};\n        }\n      }\n    }\n    if(nowb.second){\n      for(int i = 0; i < 8; i++) color(nowb.first.first+e_dir[0][i], nowb.first.second+e_dir[1][i], i, p);\n      f[nowb.first.first][nowb.first.second] = 'x';\n    }\n  }while(nowa.second || nowb.second);\n\n  for(int i = 0; i < 8; i++){\n    cout << f[i] << endl;\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define BLACK 1 // マミ：先行\n#define WHITE -1 // カマンベール：後攻\n#define WALL 2\n#define EMPTY 0\n#define BOARD 8\n\ntypedef long long ll;\nconst int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint board[BOARD+2][BOARD+2];\n\nint ABS(int a) {\n    if (a < 0) return -a;\n    else return a;\n}\n\nint main(void) {\n    // 壁の作成\n    for (int i = 0; i < 10; i++) {\n        board[0][i] = WALL;\n        board[BOARD+1][i] = WALL;\n        board[i][0] = WALL;\n        board[i][BOARD+1] = WALL;\n    }\n    int cnt = 0;\n    // boardの作成\n    string str;\n    for (int i = 0; i < 8; i++) {\n        cin >> str;\n        for (int j = 0; j < 8; j++) {\n            if (str[j] == '.') board[i+1][j+1] = EMPTY;\n            else if (str[j] == 'o') board[i+1][j+1] = BLACK;\n            else board[i+1][j+1] = WHITE;\n        }\n    }\n    // 解の主軸\n    while (1) {\n        bool black_pass_flag = false, white_pass_flag = false;\n        // 巴マミ\n        // 最大になるところを探す\n        int ma = 0, x_index = 0, y_index = 0;\n        for (int y = 1; y <= 8; y++) {\n            for (int x = 1; x <= 8; x++) {\n//                printf(\"(%d %d)\\n\", x, y);\n                if (board[y][x] != EMPTY) {\n//                    cout << \"not empty so continue\" << endl;\n                    continue;\n                }\n                int num = 0;\n                for (int i = 0; i < 8; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (board[ny][nx] != WHITE) {\n                        continue;\n                    }\n                    while (board[ny][nx] == WHITE) {\n                        ny += dy[i];\n                        nx += dx[i];\n                    }\n                    if (board[ny][nx] == BLACK) {\n//                        printf(\"find black\\n\");\n                        //cout << nx << \" \" << ny << endl;\n                        num += max(ABS(ny - y), ABS(nx - x)) - 1;\n                    }\n                }\n                if (ma < num) {\n                    ma = num;\n                    x_index = x;\n                    y_index = y;\n                }\n            }\n        }\n//        printf(\"max:%d index:(%d,%d)\\n\", ma, x_index, y_index);\n        if (ma == 0) black_pass_flag = true;\n        else {\n        // 最大になるところに黒を置いてひっくり返す\n            board[y_index][x_index] = BLACK;\n            for (int i = 0; i < 8; i++) {\n                int nx = x_index + dx[i];\n                int ny = y_index + dy[i];\n                if (board[ny][nx] != WHITE) continue;\n                while (board[ny][nx] == WHITE) {\n                    ny += dy[i];\n                    nx += dx[i];\n                }\n                if (board[ny][nx] == BLACK) {\n                    for (int x = x_index, y = y_index; x != nx || y != ny; x += dx[i], y += dy[i]) {\n                        board[y][x] = BLACK;\n                    }\n                }\n            }\n        }\n        // カマンベール\n        // 最大になるところを探す\n        ma = 0, x_index = 0, y_index = 0;\n        for (int y = 8; y >= 1; y--) {\n            for (int x = 8; x >= 1; x--) {\n//                printf(\"(%d %d)\\n\", x, y);\n                if (board[y][x] != EMPTY) {\n//                    cout << \"not empty so continue\" << endl;\n                    continue;\n                }\n                int num = 0;\n                for (int i = 0; i < 8; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (board[ny][nx] != BLACK) {\n                        continue;\n                    }\n                    while (board[ny][nx] == BLACK) {\n                        ny += dy[i];\n                        nx += dx[i];\n                    }\n                    if (board[ny][nx] == WHITE) {\n//                        printf(\"find black\\n\");\n                        //cout << nx << \" \" << ny << endl;\n                        num += max(ABS(ny - y), ABS(nx - x)) - 1;\n                    }\n                }\n                if (ma < num) {\n                    ma = num;\n                    x_index = x;\n                    y_index = y;\n                }\n            }\n        }\n//        printf(\"max:%d index:(%d,%d)\\n\", ma, x_index, y_index);\n        if (ma == 0) white_pass_flag = true;\n        else {\n        // 最大になるところに黒を置いてひっくり返す\n            board[y_index][x_index] = WHITE;\n            for (int i = 0; i < 8; i++) {\n                int nx = x_index + dx[i];\n                int ny = y_index + dy[i];\n                if (board[ny][nx] != BLACK) continue;\n                while (board[ny][nx] == BLACK) {\n                    ny += dy[i];\n                    nx += dx[i];\n                }\n                if (board[ny][nx] == WHITE) {\n                    for (int x = x_index, y = y_index; x != nx || y != ny; x += dx[i], y += dy[i]) {\n                        board[y][x] = WHITE;\n                    }\n                }\n            }\n        }\n        if (black_pass_flag && white_pass_flag) break;\n    }\n\n    // output\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 8; j++) {\n            if (board[i][j] == BLACK) cout << \"o\";\n            else if (board[i][j] == WHITE) cout << \"x\";\n            else cout << \".\";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 155. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n;\n    if (n % 2 == 0) {\n        return mypow(sq(b), n / 2);\n    } else {\n        return mypow(b, n - 1) * b;\n    }\n}\n\n/* --------------------\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n % MOD;\n    if (n % 2 == 0) {\n        return mypow(sq(b) % MOD, n / 2);\n    } else {\n        return mypow(b, n - 1) * b % MOD;\n    }\n}\n-------------------- */\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\nstring c = \"ox\";\n\n/* ------------- Functions -------------- */\n\nll count(ll x, ll y, V<string> s, ll k) {\n    if (s[x][y] != '.') return 0;\n\n    ll ret = 0;\n    FOR(dx, -1, 1) {\n        FOR(dy, -1, 1) {\n            if (dx == 0 && dy == 0) continue;\n            ll cnt = 0;\n            FOR(d, 1, 100) {\n                ll nx = x + dx * d;\n                ll ny = y + dy * d;\n\n                if (nx < 0 || nx >= 8 || ny < 0 || ny >= 8 || s[nx][ny] == '.') {\n                    cnt = 0;\n                    break;\n                } else if (s[nx][ny] == c[k]) {\n                    break;\n                } else {\n                    cnt++;\n                }\n            }\n            ret += cnt;\n        }\n    }\n\n    return ret;\n}\n\nV<string> ope(ll x, ll y, V<string> s, ll k) {\n    s[x][y] = c[k];\n\n    FOR(dx, -1, 1) {\n        FOR(dy, -1, 1) {\n            if (dx == 0 && dy == 0) continue;\n\n            bool turn = true;\n            FOR(d, 1, 100) {\n                ll nx = x + dx * d;\n                ll ny = y + dy * d;\n\n                if (nx < 0 || nx >= 8 || ny < 0 || ny >= 8 || s[nx][ny] == '.') {\n                    turn = false;\n                    break;\n                } else if (s[nx][ny] == c[k]) {\n                    break;\n                }\n            }\n\n            if (turn) {\n                FOR(d, 1, 100) {\n                    ll nx = x + dx * d;\n                    ll ny = y + dy * d;\n\n                    if (s[nx][ny] == c[k]) {\n                        break;\n                    } else {\n                        s[nx][ny] = c[k];\n                    }\n                }\n            }\n        }\n    }\n\n    return s;\n}\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    V<string> s(8);\n    FOR(i, 0, 7) {\n        cin >> s[i];\n    }\n\n    ll MAX;\n    P<ll, ll> p;\n    bool update;\n\n    while (true) {\n        update = false;\n\n        MAX = 0;\n        FOR(x, 0, 7) {\n            FOR(y, 0, 7) {\n                ll rev = count(x, y, s, 0);\n                if (rev > MAX) {\n                    p = mp(x, y);\n                    MAX = rev;\n                }\n            }\n        }\n\n        if (MAX > 0) {\n            s = ope(p.fst, p.snd, s, 0);\n            update = true;\n        }\n\n        MAX = 0;\n        RFOR(x, 7, 0) {\n            RFOR(y, 7, 0) {\n                ll rev = count(x, y, s, 1);\n                if (rev > MAX) {\n                    p = mp(x, y);\n                    MAX = rev;\n                }\n            }\n        }\n\n        if (MAX > 0) {\n            s = ope(p.fst, p.snd, s, 1);\n            update = true;\n        }\n\n        if (!update) break;\n    }\n\n    FOR(i, 0, 7) {\n        cout << s[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nchar s[] = { 'o', 'x' };\nstring B[10];\nint dx[] = {  0, -1, -1, -1, 0, 1, 1, 1  };\nint dy[] = { -1, -1,  0,  1, 1, 1, 0, -1 };\n\nint count(int t, int ii, int jj)\n{\n    if (B[ii][jj] != '.') return 0;\n    int ans = 0;\n    loop (8, p) {\n        int i = ii + dx[p], j = jj + dy[p];\n        int cnt = 0;\n        while (B[i][j] == s[!t]) i += dx[p], j += dy[p], cnt++;\n        if (B[i][j] == s[t]) ans += cnt;\n    }\n    return ans;\n}\n\nint move(int t, int ii, int jj)\n{\n    B[ii][jj] = s[t];\n    loop (8, p) {\n        int i = ii, j = jj;\n        i += dx[p], j += dy[p];\n        while (B[i][j] == s[!t]) i += dx[p], j += dy[p];\n        if (B[i][j] != s[t]) continue;\n        i = ii + dx[p], j = jj + dy[p];\n        while (B[i][j] == s[!t]) B[i][j] = s[t], i += dx[p], j += dy[p];\n    }\n}\n\nint main()\n{\n    B[0] = \"----------\";\n    B[9] = \"----------\";\n    loop (8, i) {\n        string s; cin >> s;\n        B[i+1] = \"-\" + s + \"-\";\n    }\n\n    int dt = 0;\n    int t = 0;\n    int end = 0;\n    while (1) {\n        dt++;\n        int m_cnt = 0, x = -1, y = -1;\n        loop (8, ii) loop (8, jj) {\n            int i = ii + 1, j = jj + 1;\n            if (t) i = 8 - ii, j = 8 - jj;\n\n            int cnt = count(t, i, j);\n            if (cnt > m_cnt) m_cnt = cnt, x = i, y = j;\n        }\n        if (m_cnt) end = 0, move(t, x, y);\n        if (dt == 40) {\n            INSP(x);\n            INSP(y);\n            INSP(m_cnt);\n        }\n        else end++;\n        t ^= 1;\n        if (end > 1) break;\n    }\n    loop (8, i) {\n        cout << B[i+1].substr(1, 8) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[8] = {-1,0,1,-1,1,-1,0,1};\nint dy[8] = {-1,-1,-1,0,0,1,1,1};\nint cnt;\n\nvoid output(vector<string> t){\n\tfor(int y=1 ; y <= 8 ; y++ ){\n\t\tfor(int x=1 ; x <= 8 ; x++ ){\n\t\t\tcout << t[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint c_to_i(char c){\n\tif( c == 'o' ) return 1;\n\tif( c == 'x' ) return -1;\n\treturn 0;\n}\n\nbool check(vector<string> t, int x, int y, int i, char c){\n\tint mx = x + dx[i];\n\tint my = y + dy[i];\n\n\tif( c_to_i(t[y][x]) == -c_to_i(c) ) cnt++;\n\n\tif( t[my][mx] == c ){\n\t\treturn true;\n\t}else if( t[my][mx] == '#' || t[my][mx] == '.' ){\n\t\treturn false;\n\t}else if( c_to_i(t[my][mx]) == -c_to_i(c) ){\n\t\treturn check( t , mx , my , i , c );\n\t}\n\treturn false;\n}\n\nbool change(vector<string>& t, int x, int y, int i, int c){\n\tint mx = x + dx[i];\n\tint my = y + dy[i];\n\n\tif( t[my][mx] == c ){\n\t\tt[y][x] = c;\n\t\treturn true;\n\t}else if( c_to_i(t[my][mx]) == -c_to_i(c) ){\n\t\tbool flag = change( t , mx , my , i , c );\n\t\tif( flag ){\n\t\t\tt[y][x] = c;\n\t\t}\n\t\treturn flag;\n\t}\n\treturn false;\n}\n\nvoid move(vector<string>& t, int sx, int sy, char c){\n\tif( t[sy][sx] != '.' ) return;\n\tt[sy][sx] = c;\n\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tint mx = sx + dx[i];\n\t\tint my = sy + dy[i];\n\t\tif( c_to_i(t[my][mx]) == -c_to_i(c) ){\n\t\t\tchange( t , mx , my , i , c );\n\t\t}\n\t}\n}\n\nP search(vector<string> t, char c){\n\tint m=0, C[10][10] = {0};\n\tP p;\n\tp.first = p.second = ((c=='o')? 10 : 0 ) ;\n\n\tfor(int y=1 ; y <= 8 ; y++ ){\n\t\tfor(int x=1 ; x <= 8 ; x++ ){\n\t\t\tif( t[y][x] == '.' ){\n\t\t\t\tfor(int i=0 ; i < 8 ; i++ ){\n\t\t\t\t\tint mx = x + dx[i];\n\t\t\t\t\tint my = y + dy[i];\n\t\t\t\t\tif( c_to_i(t[my][mx]) == -c_to_i(c) ){\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tbool flag = check( t , mx , my , i , c );\n\t\t\t\t\t\tif( flag ){\n\t\t\t\t\t\t\tC[y][x] += cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm = max( m , C[y][x] );\n\t\t\t}\n\t\t}\n\t}\n\n\tif( m == 0 ){\n\t\tp.first = -1;\n\t\tp.second = -1;\n\t\treturn p;\n\t}\n\n\tfor(int y=1 ; y <= 8 ; y++ ){\n\t\tfor(int x=1 ; x <= 8 ; x++ ){\n\t\t\tif( m == C[y][x] ){\n\t\t\t\tP p_(y,x);\n\t\t\t\tp = ( c == 'o' )? min(p,p_) : max(p,p_) ;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nvoid next(vector<string>& t, char c, bool flag ){\n\tchar c_ = ( c == 'o' )? 'x' : 'o';\n\n\tP p = search( t , c );\n\tif( p.first == -1 ){\n\t\tif( flag == false ){\n\t\t\t//cout << \"pass\" << endl;\n\t\t\tnext( t , c_ , true );\n\t\t}\n\t}else{\n\t\tint x = p.second;\n\t\tint y = p.first;\n\t\tmove( t , x , y , c );\n\t\t//cout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\t//debug( t );\n\t\tnext( t , c_ , false );\n\t}\n}\n\nint main(){\n\tvector<string> t;\n\n\tfor(int y=0 ; y < 10 ; y++ ){\n\t\tstring s;\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\tif( y == 0 || y == 9 || x == 0 || x == 9 )\n\t\t\t\ts.push_back('#');\n\t\t\telse\n\t\t\t\ts.push_back('.');\n\t\t}\n\t\tt.push_back( s );\n\t}\n\n\tfor(int y=1 ; y <= 8 ; y++ ){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tt[y][i+1] = s[i];\n\t\t}\n\t}\n\tnext( t , 'x' , false );\n\toutput( t );\n}"
  },
  {
    "language": "C++",
    "code": "//$g++ -std=c++11 Template.cpp \n\n//#include <bits/stdc++.h>\n#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <iomanip>\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define ROF(i, j, k) for(int i = (int)(j); i >= (int)(k); --i)\n#define FORLL(i, n, m) for(long long i = n; i < (long long)(m); i++)\n#define SORT(v, n) sort(v, v+n)\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nusing namespace std;\nusing ll = long long;\nconst ll MOD=1000000007LL;\ntypedef pair<int, int> P;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n\npriority_queue<int> q_descending;\npriority_queue<int, vector<int>, greater<int> > q_ascending;\n\nchar t[8][9];\nint n = 8;\nint all_turn;\nint dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};\n\nbool check(int row, int col){\n  return (row >= 0 && row <= 7 && col >= 0 && col <= 7);\n}\nvoid turn(int x, int y, char c){\n  char e_c = (c == 'o' ? 'x' : 'o');\n  //8-directions\n  REP(i,n){\n    int res = 1;\n    while(check(x+res*dx[i], y+res*dy[i])){\n      char focus = t[x+res*dx[i]][y+res*dy[i]];\n      if(focus == c){\n\tt[x][y] = c;\n\tFOR(j,1,res) t[x+j*dx[i]][y+j*dy[i]] = c;\n\tbreak;\n      }\n      else if(focus == e_c) res++;\n      else break;\n    }\n  }    \n}\n\nint simulate(int x, int y, char c){\n  int ret = 0;\n  char e_c = (c == 'o' ? 'x' : 'o');\n  //8-directions\n  REP(i,n){\n    int res = 1;\n    while(check(x+res*dx[i], y+res*dy[i])){\n      char focus = t[x+res*dx[i]][y+res*dy[i]];\n      if(focus == c){\n\tret += res-1;\n\tbreak;\n      }\n      else if(focus == e_c) res++;\n      else break;\n    }\n  }  \n  return ret;\n}\nbool solve(int v){\n  int max_n=0, max_x=-1, max_y=-1;\n  char c;\n  if(v == 0) c = 'o';\n  else c = 'x';\n\n  REP(i,n) REP(j,n){\n    if(t[i][j] == '.'){      \n      int num = simulate(i,j,c);\n      if(max_n<num){\n\tmax_n = num;\n\tmax_x = i;\n\tmax_y = j;\n      }\n    }\n  }\n  turn(max_x, max_y, c);  \n  return (max_n > 0);\n}\n\nbool _solve(int v){\n  int max_n=0, max_x=-1, max_y=-1;\n  char c;\n  if(v == 0) c = 'o';\n  else c = 'x';\n\n  ROF(i,7,0) ROF(j,7,0){\n    if(t[i][j] == '.'){      \n      int num = simulate(i,j,c);\n      if(max_n<num){\n\tmax_n = num;\n\tmax_x = i;\n\tmax_y = j;\n      }\n    }\n  }\n  turn(max_x, max_y, c);  \n  return (max_n > 0); \n}\n\nint\nmain(void){  \n  ios_base::sync_with_stdio(false);\n\n  REP(i, n) cin >> t[i];\n\n  bool first = true, second = true;\n  while(first || second){\n    first = solve(0);\n    second = _solve(1);\n  }\n\n  REP(i,n) {\n    REP(j,n) cout << t[i][j];\n    cout << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring grid[8];\nint m,posx,posy;\n\nvoid cookie(int y,int x,char t){\n  int dx[] = {0,1,1,1,0,-1,-1,-1},dy[] = {1,1,-1,0,-1,1,-1,0};\n  int ans = 0;\n\n  for(int i=0;i<8;i++){\n    int sx = x,sy = y;\n    int tmp = -1;\n    while(1){\n      sx += dx[i],sy += dy[i];\n      tmp++;\n      if(sx<0 || sy<0 || sx>=8 || sy>=8)break;\n      if(grid[sy][sx] == t || grid[sy][sx] == '.')break;\n    }\n    if(sx<0 || sy<0 || sx>=8 || sy>=8)continue;\n    if(grid[sy][sx] == t)ans += tmp;\n  }\n  if(ans>m){\n    m = ans;\n    posx = x;\n    posy = y;\n  }\n}\n\nvoid change(int y, int x,char t){\n  grid[y][x] = t;\n  int dx[] = {0,1,1,1,0,-1,-1,-1},dy[] = {1,1,-1,0,-1,1,-1,0};\n  for(int i=0;i<8;i++){\n    int sx = x,sy = y;\n    while(1){\n      sx += dx[i],sy += dy[i];\n      if(sx<0 || sy<0 || sx>=8 || sy>=8)break;\n      if(grid[sy][sx] == t || grid[sy][sx] == '.')break;\n    }\n    if(sx<0 || sy<0 || sx>=8 || sy>=8)continue;\n    if(grid[sy][sx] == t){\n      sx = x,sy = y;\n      while(1){\n\tsx += dx[i],sy += dy[i];\n\tif(sx<0 || sy<0 || sx>=8 || sy>=8)break;\n\tif(grid[sy][sx] == t || grid[sy][sx] == '.')break;\n\tgrid[sy][sx] = t;\n      }\n    } \n  }\n}\n\nint main(){\n  for(int i=0;i<8;i++)cin >> grid[i];\n  while(1){\n    bool f = false;\n    m = 0;\n    posx = posy = -1;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tif(grid[i][j]=='.')cookie(i,j,'o');\n      }\n    }\n    if(m>0){\n      f = true;\n      change(posy,posx,'o');\n    }\n\n    m = 0;\n    posx = posy = -1;\n    for(int i=7;i>=0;i--){\n      for(int j=7;j>=0;j--){\n\tif(grid[i][j]=='.')cookie(i,j,'x');\n      }\n    }\n    if(m>0){\n      f=true;\n      change(posy,posx,'x');\n    }\n\n    if(!f)break;\n  }\n\n  for(int i=0;i<8;i++)cout << grid[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nvector< vector<char> > field(8,vector<char>(8));\nint dx[8] = {1,1,0,-1,-1,-1,0,1};\nint dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint check(int x, int y, char c)\n{\n\tint res=0;\n\tif(field[y][x] != '.'){ return 0; }\n\trep(i,8)\n\t{\n\t\tint nx = x;\n\t\tint ny = y;\n\t\tint cnt=0;\n\t\twhile(true)\n\t\t{\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8){ break; }\n\t\t\tif(field[ny][nx] == c){ res += cnt; break; }\n\t\t\tif(field[ny][nx] == '.'){ break; }\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid put(int x, int y, char c)\n{\n\tfield[y][x] = c;\n\trep(i,8)\n\t{\n\t\tint nx = x;\n\t\tint ny = y;\n\t\twhile(true)\n\t\t{\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8){ break; }\n\t\t\tif(field[ny][nx] == c){\n\t\t\t\twhile(true)\n\t\t\t\t{\n\t\t\t\t\tnx -= dx[i];\n\t\t\t\t\tny -= dy[i];\n\t\t\t\t\tif(nx == x && ny == y){ break; }\n\t\t\t\t\tfield[ny][nx] = c;\n\t\t\t\t}\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tif(field[ny][nx] == '.'){ break; }\n\t\t}\n\t}\n}\n\nbool win()\n{\n\tint o_cnt=0;\n\tint x_cnt=0;\n\trep(y,8){\n\t\trep(x,8){\n\t\t\tif(field[y][x] == 'o'){ o_cnt++; }\n\t\t\tif(field[y][x] == 'x'){ x_cnt++; }\n\t\t}\n\t}\n\treturn o_cnt==0 || x_cnt==0 || o_cnt+x_cnt==64;\n}\n\nint main()\n{\n\trep(y,8){\n\t\trep(x,8){\n\t\t\tcin >> field[y][x];\n\t\t}\n\t}\n\n\tint turn=1;\n\tint max_x, max_y;\n\tint pass=0;\n\twhile(true)\n\t{\n\t\tchar player = (turn % 2) ? 'o' : 'x';\n\t\tint num=0, max_x=-1, max_y=-1;\n\t\tif(player == 'o')\n\t\t{\n\t\t\trep(y,8){\n\t\t\t\trep(x,8){\n\t\t\t\t\tint tmp = check(x,y,player);\n\t\t\t\t\tif(num < tmp){\n\t\t\t\t\t\tnum = tmp;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int y=7;y>=0;y--){\n\t\t\t\tfor(int x=7;x>=0;x--){\n\t\t\t\t\tint tmp = check(x,y,player);\n\t\t\t\t\tif(num < tmp){\n\t\t\t\t\t\tnum = tmp;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_x != -1)\n\t\t{ \n\t\t\tpass=0;\n\t\t\tput(max_x, max_y, player); \n\t\t}else{\n\t\t\tpass++;\n\t\t}\n\t\tturn++;\n\t\tif(pass > 1){ break; }\n\t\tif(win()){ break; }\n\t}\n\n\t\n\trep(y,8){\n\t\trep(x,8){\n\t\t\tcout << field[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nint dx[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n\nvector<vector<int>>field(8, vector<int>(8));\nbool ok(int y, int x) {\n\treturn y >= 0 && y <= 7 && x >= 0 && x <= 7;\n}\n\nint turn(bool mami,vector<vector<int>>&field,const int y,const int x) {\n\n\tfield[y][x] = mami ? 1 : 2;\n\tint changenum = 0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tint num = 0;\n\t\tif (!ok(ny, nx))continue;\n\t\tif ((mami&&field[ny][nx] == 2) || (!mami&&field[ny][nx] == 1)) {\n\t\t\twhile (1) {\n\t\t\t\tnx += dx[i];\n\t\t\t\tny += dy[i];\n\t\t\t\tnum++;\n\t\t\t\tif (!ok(ny, nx))break;\n\t\t\t\tif ((mami&&field[ny][nx] == 2) || (!mami&&field[ny][nx] == 1)) {\n\n\t\t\t\t}\n\t\t\t\telse if (!field[ny][nx]) {\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int a = 1; a <= num; ++a) {\n\t\t\t\t\t\tfield[y + dy[i] * a][x + dx[i] * a] = mami ? 1 : 2;\n\t\t\t\t\t}\n\t\t\t\t\tchangenum += num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn changenum;\n}\nint main() {\n\tfor (int i = 0; i < 8; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (st[j] == 'o') {\n\n\t\t\t\tfield[i][j] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'x') {\n\t\t\t\tfield[i][j] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tbool mami = true;\n\tint flag = 2;\n\twhile (flag) {\n\t\tflag--;\n\n\n\t\tvector<vector<int>>nums(8,vector<int>(8));\n\n\t\tfor (int y = 0; y < 8; ++y) {\n\t\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\t\tif (!field[y][x]) {\n\t\t\t\t\tvector<vector<int>>cfield(field);\n\t\t\t\t\tnums[y][x] = turn(mami, cfield, y, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = 0;\n\t\tint max_y;\n\t\tint max_x = 0;\n\t\tif (mami) {\n\t\t\tfor (int y = 0; y < 8; ++y) {\n\t\t\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\t\t\tif (nums[y][x]>amax) {\n\t\t\t\t\t\tamax = nums[y][x];\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int y = 7; y >=0; --y) {\n\t\t\t\tfor (int x = 7; x >=0; --x) {\n\t\t\t\t\tif (nums[y][x]>amax) {\n\t\t\t\t\t\tamax = nums[y][x];\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amax == 0)break;\n\t\telse {\n\t\t\tflag = 2;\n\t\t\tturn(mami, field, max_y, max_x);\n\t\t\t\n\t\t}\n\t\tmami = !mami;\n\t}\n\tfor (int y = 0; y < 8; ++y) {\n\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\tif (field[y][x] == 2) {\n\t\t\t\tcout << 'x';\n\t\t\t}\n\t\t\telse if (field[y][x] == 1) {\n\t\t\t\tcout << 'o';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << '.';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX_N 12\n#define MAX_T 10000\n\nint x[MAX_N][MAX_N];\nint z[8],y[8];\nchar c,T[4]=\".ox\";\n\nint main(){\n\tfor(int i=1;i<=8;i++){\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tcin>>c;\n\t\t\tif(c=='o'){\n\t\t\t\tx[i][j]=1;\n\t\t\t}\n\t\t\tif(c=='x'){\n\t\t\t\tx[i][j]=2;\n\t\t\t}\n\t\t\tif(c=='.'){\n\t\t\t\tx[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<MAX_T;i++){\n\t\tint dx[8]={0,1,1,1,0,-1,-1,-1};\n\t\tint dy[8]={-1,-1,0,1,1,1,0,-1};\n\t\tfor(int h=2;h>0;h--){\n\t\t\tint score=0,maxn=0,cnt=0,X=0,Y=0,cx=0,cy=0;\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tfor(int k=1;k<=8;k++){\n\t\t\t\t\tif(x[j][k]==0){\n\t\t\t\t\t\tscore=0;\n\t\t\t\t\t\tfor(int l=0;l<8;l++){\n\t\t\t\t\t\t\tz[l]=0;\n\t\t\t\t\t\t\tcnt=0;\n\t\t\t\t\t\t\tcx=j+dx[l];cy=k+dy[l];\n\t\t\t\t\t\t\twhile(cx>=1 && cx<=8 && cy>=1 && cy<=8){\n\t\t\t\t\t\t\t\tif(x[cx][cy]==0){\n\t\t\t\t\t\t\t\t\tgoto E;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(x[cx][cy]!=h){\n\t\t\t\t\t\t\t\t\tgoto F;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\tcx+=dx[l];cy+=dy[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto E;\nF:;\n\t\t\t\t\t\t\tscore+=cnt;\n\t\t\t\t\t\t\tz[l]=1;\nE:;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(score>maxn || (score==maxn && h==1)){\n\t\t\t\t\t\t\tmaxn=score;X=j;Y=k;\n\t\t\t\t\t\t\tfor(int l=0;l<8;l++){y[l]=z[l];}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxn>=1){\n\t\t\t\tx[X][Y]=(3-h);\n\t\t\t}\n\t\t\tfor(int l=0;l<8;l++){\n\t\t\t\tif(y[l]==1){\n\t\t\t\t\tcx=X+dx[l];cy=Y+dy[l];\n\t\t\t\t\twhile(cx>=1 && cx<=8 && cy>=1 && cy<=8){\n\t\t\t\t\t\tif(x[cx][cy]!=h){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[cx][cy]=(3-h);\n\t\t\t\t\t\tcx+=dx[l];cy+=dy[l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=8;i++){\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tcout<<T[x[i][j]];\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid rotate(vector<string> &field){\n  int n = field.size();\n  vector<string> tmp = field;\n  REP(i, n)REP(j, n){\n    tmp[n-i-1][n-j-1] = field[i][j];\n  }\n  REP(i, n)REP(j, n){\n    field[i][j] = tmp[i][j] == 'o' ? 'x' : tmp[i][j] == '.' ? '.' : 'o';\n  }\n}\n\npair<int, vector<string> > flip(const vector<string> &field, int x, int y, char c){\n  int n = field.size();\n  \n  int ans = 0;\n  vector<string> board = field;\n\n  board[x][y] = c;\n  \n  REP2(dx, -1, 2)REP2(dy, -1, 2){\n    if(dx == 0 && dy == 0) continue;\n    int tx = x + dx, ty = y + dy;\n    while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n          board[tx][ty] != '.' && board[tx][ty] != c) {\n      tx += dx;\n      ty += dy;\n    }\n    \n    if(0 <= tx && tx < n && 0 <= ty && ty < n && board[tx][ty] == c){\n      tx = x + dx, ty = y + dy;\n      \n      while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n            board[tx][ty] != '.' && board[tx][ty] != c) {\n        board[tx][ty] = c;\n        tx += dx;\n        ty += dy;\n        ans++;\n      }\n    }\n  }\n  return make_pair(ans, board);\n  \n}\n\nint main(){\n  vector<string> field(8);\n  \n  REP(i, 8) cin >> field[i];\n\n  int s = 0;\n  bool mami;\n  REP(i, 8) s += count(ALL(field[i]), '.');\n  if(s % 2){\n    mami = false;\n  }else{\n    mami = true;\n  }\n\n  // cout << mami << endl;\n  while(true){\n    // REP(i, 8) cout << field[i] << endl;\n    if(!mami) rotate(field);\n\n    int best = 0;\n    vector<string> bestboard;\n    \n    REP(i, 8) REP(j, 8)if(field[i][j] == '.'){\n      pair<int, vector<string> > p = flip(field, i, j, 'o');\n      if(p.first > best){\n        best = p.first;\n        bestboard = p.second;\n      }\n    }\n\n    if(best > 0){\n      field = bestboard;\n    }\n    \n    if(!mami) rotate(field);\n    \n    if(best == 0) break;\n    mami = !mami;\n  }\n  REP(i, 8) cout << field[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\npair<int, vector<string>> mv(vector<string> f, int x, int y, char c)\n{\n\tint count = 0;\n\tint sx[] = { -1, 0, 1, -1, 1, -1, 0, 1, };\n\tint sy[] = { -1, -1, -1, 0, 0, 1, 1, 1, };\n\tf[x][y] = c;\n\tREP(dir, 8)\n\t{\n\t\tFOR(i, 1, 10)\n\t\t{\n\t\t\tchar &p = f[sx[dir] * i + x][sy[dir] * i + y];\n\t\t\tif (p == '.') { break; }\n\t\t\tif (p == c)\n\t\t\t{ \n\t\t\t\tFOR(j, 1, i)\n\t\t\t\t{\n\t\t\t\t\tf[sx[dir] * j + x][sy[dir] * j + y] = c;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn make_pair(count, f);\n}\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tauto F = read<string>(8);\n\t\t// かべ\n\t\tfor (auto&s : F) { s = \".\" + s + \".\"; }\n\t\tF.insert(F.begin(), string(10, '.'));\n\t\tF.push_back(string(10, '.'));\n\n\t\twhile (true)\n\t\t{\n\t\t\tauto n1 = make_pair(0, F);\n\t\t\tFOR(i, 1, 9) FOR(j, 1, 9) if (F[i][j] == '.')\n\t\t\t{\n\t\t\t\tauto m = mv(F, i, j, 'o');\n\t\t\t\tif (m.first > n1.first) { n1 = m; }\n\t\t\t}\n\t\t\tif (n1.first) { F = n1.second; }\n\n\t\t\tauto n2 = make_pair(0, F);\n\t\t\tRFOR(i, 1, 9) RFOR(j, 1, 9) if (F[i][j] == '.')\n\t\t\t{\n\t\t\t\tauto m = mv(F, i, j, 'x');\n\t\t\t\tif (m.first > n2.first) { n2 = m; }\n\t\t\t}\n\t\t\tif (n2.first) { F = n2.second; }\n\n\t\t\tif (n1.first == 0 && n2.first == 0) { break; }\n\t\t}\n\t\tFOR(i, 1, 9) write(F[i].substr(1, 8));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef tuple<int, int, int> Tuple;\nconst char *cookie = \"ox\";\nconst int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dy[] = {1, 0, -1, -1, -1, 0, 1, 1};\n\nchar grid[10][10];\n\nvoid show()\n{\n\tfor (int i = 1; i <= 8; i++){\n\t\tfor (int j = 1; j <= 8; j++){\n\t\t\tprintf(\"%c\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\nint calc(int turn, int x, int y)\n{\n\tint res = 0;\n\tfor (int dir = 0; dir < 8; dir++){\n\t\tint k = 1;\n\t\twhile (true){\n\t\t\tint nx = x + dx[dir] * k;\n\t\t\tint ny = y + dy[dir] * k;\n\t\t\tif (grid[nx][ny] == '.') break;\n\t\t\tif (grid[nx][ny] == cookie[turn]) break;\n\t\t\tk++;\n\t\t}\n\t\tif (grid[x + dx[dir] * k][y + dy[dir] * k] == '.') k = 0;\n\t\t\n\t\tfor (int i = 1; i < k; i++){\n\t\t\tint nx = x + dx[dir] * i;\n\t\t\tint ny = y + dy[dir] * i;\n\t\t\t//if (grid[nx][ny] == '.') break;\n\t\t\t//if (grid[nx][ny] == cookie[turn]) break;\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid st(int turn, int x, int y)\n{\n\tgrid[x][y] = cookie[turn];\n\tfor (int dir = 0; dir < 8; dir++){\n\t\tint k = 1;\n\t\twhile (true){\n\t\t\tint nx = x + dx[dir] * k;\n\t\t\tint ny = y + dy[dir] * k;\n\t\t\tif (grid[nx][ny] == '.') break;\n\t\t\tif (grid[nx][ny] == cookie[turn]) break;\n\t\t\tk++;\n\t\t}\n\t\tif (grid[x + dx[dir] * k][y + dy[dir] * k] == '.') k = 0;\n\t\t\n\t\tfor (int i = 1; i < k; i++){\n\t\t\tint nx = x + dx[dir] * i;\n\t\t\tint ny = y + dy[dir] * i;\n\t\t\t//if (grid[nx][ny] == '.') break;\n\t\t\t//if (grid[nx][ny] == cookie[turn]) break;\n\t\t\tgrid[nx][ny] = cookie[turn];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(grid, '.', sizeof(grid));\n\tfor (int i = 1; i <= 8; i++){\n\t\tfor (int j = 1; j <= 8; j++){\n\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t}\n\t}\n\t\n\tint turn = 0;\n\tint pass = 0;\n\twhile (true){\n\t\tint sign = turn ? 1 : -1;\n\t\t// score, i, j\n\t\tTuple maxi(0, 0, 0);\n\t\tfor (int i = 1; i <= 8; i++){\n\t\t\tfor (int j = 1; j <= 8; j++){\n\t\t\t\tif (grid[i][j] != '.') continue;\n\t\t\t\tTuple t(calc(turn, i, j), i * sign, j * sign);\n\t\t\t\tmaxi = max(maxi, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//show();\n\t\tif (get<0>(maxi) == 0){\n\t\t\tpass++;\n\t\t\tif (pass >= 2){\n\t\t\t\tshow();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tst(turn, abs(get<1>(maxi)), abs(get<2>(maxi)));\n\t\t\tpass = 0;\n\t\t}\n\t\tturn ^= 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s[10];\n\nint cnt[10][10];\n\nint dx[] = { 0,1,1,1,0,-1,-1,-1 };\nint dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nbool check() {\n\tbool f[3] = {};\n\tREP(i, 8) {\n\t\tif (s[i].find('o') != -1)f[0] = 1;\n\t\tif (s[i].find('x') != -1)f[1] = 1;\n\t\tif (s[i].find('.') != -1)f[2] = 1;\n\t}\n\treturn f[0] && f[1] && f[2];\n}\n\nint count(int y, int x, int d, bool t) {\n\tint res = 0;\n\tbool f = 0;\n\tx += dx[d];\n\ty += dy[d];\n\twhile (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\tif (s[y][x] == (t ? 'o' : 'x')) {\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tif (t) {\n\t\t\t\tif (s[y][x] == 'x')res++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[y][x] == 'o')res++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\tif (f)return res;\n\treturn 0;\n}\n\nvoid print() {\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tREP(i, 8)cin >> s[i];\n\tbool f = 1;\n\tint err = 0;\n\twhile (1) {\n\t\tREP(i, 10)REP(j, 10)cnt[i][j] = 0;\n\t\tif (!check())break;\n\t\tint ma = 0;\n\t\tP pos = { -1,-1 };\n\t\tREP(i, 8) {\n\t\t\tREP(j, 8) {\n\t\t\t\tint ny, nx;\n\t\t\t\tif (f)ny = i, nx = j;\n\t\t\t\telse ny = 7 - i, nx = 7 - j;\n\t\t\t\tif (s[ny][nx] == '.') {\n\t\t\t\t\tint w = 0;\n\t\t\t\t\tREP(k, 8)w += count(ny, nx, k, f);\n\t\t\t\t\tif (ma < w) {\n\t\t\t\t\t\tma = w;\n\t\t\t\t\t\tpos = { ny,nx };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ma != 0) {\n\t\t\terr = 0;\n\t\t\tREP(i, 8) {\n\t\t\t\tint y = pos.first, x = pos.second;\n\t\t\t\tint w = count(y, x, i, f);\n\t\t\t\tREP(j, w + 1) {\n\t\t\t\t\tint ny = pos.first + dy[i] * j,\n\t\t\t\t\t\tnx = pos.second + dx[i] * j;\n\t\t\t\t\t//cout << \"!\" << ny << \" \" << nx << endl;\n\t\t\t\t\tif (f)s[ny][nx] = 'o';\n\t\t\t\t\telse s[ny][nx] = 'x';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse err++;\n\t\tif (err >= 2)break;\n\t\t//print();\n\t\t//cout << endl;\n\t\tf = !f;\n\t}\n\tprint();\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2311.cpp\n// Author: ymiyamoto\n//\n// Created on Sun Dec 10 17:01:13 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct pos_t {\n  int32_t x;\n  int32_t y;\n};\n\nbool in_range(int32_t x, int32_t y)\n{\n  return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nvoid turnover(vector<string> &matrix, vector<pos_t> poss, char my)\n{\n  for (auto pos : poss) {\n    matrix[pos.x][pos.y] = my;\n  }\n}\n\nvector<pos_t> search(vector<string> &matrix, pos_t start, int32_t dx, int32_t dy, char my, char op)\n{\n  int32_t k = 1;\n  vector<pos_t> poss;\n  int32_t x = start.x;\n  int32_t y = start.y;\n  while (in_range(x + k * dx, y + k * dy) && matrix[x + k * dx][y + k * dy] == op) {\n    poss.push_back({x + k * dx, y + k * dy});\n    k++;\n  }\n  if (!poss.empty() && in_range(x + k * dx, y + k * dy) && matrix[x + k * dx][y + k * dy] == my) {\n    return poss;\n  }\n\n  poss.clear();\n  return poss;\n}\n\nvector<pos_t> turn(vector<string> &matrix, pos_t start, char my, char op)\n{\n  vector<pos_t> poss;\n  for (int32_t dx = -1; dx <= 1; dx++) {\n    for (int32_t dy = -1; dy <= 1; dy++) {\n      if (!(dx == 0 && dy == 0)) {\n        vector<pos_t> pos = search(matrix, start, dx, dy, my, op);\n        poss.insert(poss.end(), pos.begin(), pos.end());\n      }\n    }\n  }\n  return poss;\n}\n\nint32_t main()\n{\n  vector<string> matrix(8);\n  for (uint32_t i = 0; i < matrix.size(); i++) {\n    cin >> matrix[i];\n  }\n\n  while (true) {\n    bool first = false;\n    bool second = false;\n\n    uint32_t maxnum = 1;\n    vector<pos_t> maxval;\n    for (int32_t i = 0; i < 8; i++) {\n      for (int32_t j = 0; j < 8; j++) {\n        if (matrix[i][j] == '.') {\n          pos_t start{i, j};\n          vector<pos_t> poss = turn(matrix, start, 'o', 'x');\n          poss.push_back(start);\n          if (maxnum < poss.size()) {\n            maxnum = poss.size();\n            maxval = poss;\n            first = true;\n          }\n        }\n      }\n    }\n    turnover(matrix, maxval, 'o');\n\n    maxnum = 1;\n    vector<pos_t> opval;\n    for (int32_t i = 7; i >= 0; i--) {\n      for (int32_t j = 7; j >= 0; j--) {\n        if (matrix[i][j] == '.') {\n          pos_t start{i, j};\n          vector<pos_t> poss = turn(matrix, start, 'x', 'o');\n          poss.push_back(start);\n          if (maxnum < poss.size()) {\n            maxnum = poss.size();\n            opval = poss;\n            second = true;\n          }\n        }\n      }\n    }\n    turnover(matrix, opval, 'x');\n\n    if (first == false && second == false) break;\n  }\n\n  for (auto m : matrix) {\n    cout << m << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nchar table[8][8];\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nbool range(int x, int y) {\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nint change(char c, P p) {\n    int count = 0;\n    rep(i, 8) {\n        int x = p.se + dx[i], y = p.fi + dy[i];\n        int tmp = 0;\n        while(range(x, y) && c != table[y][x] && table[y][x] != '.') {\n            tmp++;\n            y += dy[i], x += dx[i];\n        }\n        if (range(x, y) && table[y][x] == c) count += tmp;\n    }\n    return count;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    rep(i, 8)rep(j, 8) cin >> table[i][j];\n    bool mami = true;\n    int fin = 0;\n    while(fin < 2) {\n        int maxi = 0;\n        P p;\n        if (mami) {\n            char c = 'o';\n            rep(i, 8)rep(j, 8) {\n                if (table[i][j] != '.') continue;\n                int cnt = change(c, P(i, j));\n                if (cnt > maxi) {\n                    p = P(i, j);\n                    maxi = cnt;\n                }\n            }\n            if (maxi > 0) {\n                fin = 0;\n                table[p.fi][p.se] = c;\n                rep(i, 8) {\n                    int x = p.se + dx[i], y = p.fi + dy[i];\n                    while(range(x, y) && c != table[y][x] && table[y][x] != '.') {\n                        y += dy[i], x += dx[i];\n                    }\n                    if (range(x, y) && table[y][x] == c) {\n                        x = p.se + dx[i], y = p.fi + dy[i];\n                        while(range(x, y) && c != table[y][x] && table[y][x] != '.') {\n                            table[y][x] = c;\n                            y += dy[i], x += dx[i];\n                        }\n                    }\n                }\n            } else {\n                fin++;\n            }\n        } else {\n            char c = 'x';\n            repr(i, 8)repr(j, 8) {\n                if (table[i][j] != '.') continue;\n                int cnt = change(c, P(i, j));\n                if (cnt > maxi) {\n                    p = P(i, j);\n                    maxi = cnt;\n                }\n            }\n            if (maxi > 0) {\n                fin = 0;\n                table[p.fi][p.se] = c;\n                rep(i, 8) {\n                    int x = p.se + dx[i], y = p.fi + dy[i];\n                    while(range(x, y) && c != table[y][x] && table[y][x] != '.') {\n                        y += dy[i], x += dx[i];\n                    }\n                    if (range(x, y) && table[y][x] == c) {\n                        x = p.se + dx[i], y = p.fi + dy[i];\n                        while(range(x, y) && c != table[y][x] && table[y][x] != '.') {\n                            table[y][x] = c;\n                            y += dy[i], x += dx[i];\n                        }\n                    }\n                }\n            } else {\n                fin++;\n            }\n        }\n\n        mami = !mami;\n    }\n\n    rep(i, 8) {\n        rep(j, 8) cout << table[i][j];\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\n\nchar t[10][10];\n\nint getSum(int x,int y, char c)\n{\n\tint sum = 0;\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tint cnt=0;\n\t\tint nx=x;\n\t\tint ny=y;\n\t\twhile(true)\n\t\t{\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t\tif(t[nx][ny]=='.')\n\t\t\t{\n\t\t\t\tcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(t[nx][ny]==c)\n\t\t\t{\n\t\t\t\tsum+=cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid changedResult(int x,int y, char c)\n{\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tint cnt=0;\n\t\tint nx=x;\n\t\tint ny=y;\n\t\twhile(true)\n\t\t{\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t\tif(t[nx][ny]=='.')\n\t\t\t{\n\t\t\t\tcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(t[nx][ny]==c)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcnt++;\n\t\t}\n\t\tif(cnt>0)\n\t\t{\n\t\t\tnx = x;\n\t\t\tny = y;\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(t[nx][ny]=='.')\n\t\t\t\t\tbreak;\n\t\t\t\telse if(t[nx][ny]==c)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tt[nx][ny] = c;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tfor(int i=0;i<10;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tt[i][j]='.';\n\t\n\tfor(int i=1;i<=8;i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j=1;j<=8;j++)\n\t\t\tt[i][j]=s[j-1];\n\t}\n\t/*\n\tfor(int i=0;i<10;i++)\n\t{\n\t\tfor(int j=0;j<10;j++)\n\t\t\tcout << t[i][j];\n\t\tcout << endl;\n\t}\n\t*/\n\n\tchar turn='o';\n\tint pass=0;\n\twhile(true)\n\t{\n\t\tint high=0;\n\t\tint nx=0;\n\t\tint ny=0;\n\t\tif(turn=='o')\n\t\t{\n\t\t\tfor(int i=1;i<=8;i++)\n\t\t\tfor(int j=1;j<=8;j++)\n\t\t\t\tif(t[i][j]=='.')\n\t\t\t\t{\n\t\t\t\t\tint tmp=getSum(i,j,turn);\n\t\t\t\t\tif(tmp>high)\n\t\t\t\t\t{\n\t\t\t\t\t\thigh=tmp;\n\t\t\t\t\t\tnx=i;\n\t\t\t\t\t\tny=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\telse if(turn=='x')\n\t\t{\n\t\t\tfor(int i=8;i>=1;i--)\n\t\t\tfor(int j=8;j>=1;j--)\n\t\t\t\tif(t[i][j]=='.')\n\t\t\t\t{\n\t\t\t\t\tint tmp=getSum(i,j,turn);\n\t\t\t\t\tif(tmp>high)\n\t\t\t\t\t{\n\t\t\t\t\t\thigh=tmp;\n\t\t\t\t\t\tnx=i;\n\t\t\t\t\t\tny=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\tif(high==0)\n\t\t{\n\t\t\tpass++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchangedResult(nx,ny,turn);\n\t\t\tt[nx][ny] = turn;\n\t\t\tpass=0;\n\t\t}\n\t\tif(turn=='o')turn='x';\n\t\telse if(turn=='x')turn='o';\n\t\tif(pass>=2)break;\n\t}\n\tfor(int i=1;i<9;i++)\n\t{\n\t\tfor(int j=1;j<9;j++)\n\t\t\tcout << t[i][j];\n\t\tcout << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//??????URL http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311&lang=jp\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nchar board[8][8];\n\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\nchar memo[2]={'x','o'};\n//player 0:mami 1:magi\nint dfs(int x,int y,int cnt,int idx,int player){\n    int nx=x+dx[idx],ny=y+dy[idx];\n    if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]==memo[player]){\n      cnt++;\n      return dfs(nx,ny,cnt,idx,player);\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]==memo[1-player]){\n      return cnt;\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n      return 0;\n    }\n    return 0;\n}\n\nint count(int x,int y,int player){\n    int res=0;\n    for(int i=0;i<8;i++) res+=dfs(x,y,0,i,player);\n    return res;\n}\n\nint solve(int player){\n    int ma=-1,x,y;\n    for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n      if(board[i][j]=='.' && count(i,j,player)>ma){\n        ma=count(i,j,player);\n        x=i;y=j;\n      }\n    }//?????§?????????????????´???\n    if(ma<1) return 0;\n    board[x][y]=memo[1-player];\n    for(int i=0;i<8;i++){\n      int tmp=dfs(x,y,0,i,player);\n      for(int j=1;j<=tmp;j++){\n        board[x+dx[i]*j][y+dy[i]*j]=memo[player];\n      }\n    }\n    return 1;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=solve(0);\n    magi_flag=solve(1);\n  //  cout<<mami_flag<<\" \"<<magi_flag<<endl;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\ntypedef vector<string> VS;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\ntemplate<typename T>\nvoid dump(T a, int n) { for (int i = 0; i < n; i++) cout << a[i] << (i == n - 1 ? '\\n' : ' '); }\n\ntemplate<typename T>\nvoid dump(T a) { dump<T>(a, a.size()); }\n\nconstexpr int dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconstexpr int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nbool can_reverse(VS &S, int y, int x, int di, bool is_mami) {\n\tint i = 0;\n\twhile (true) {\n\t\tx += dx[di];\n\t\ty += dy[di];\n\n\t\tif (x < 0 || y < 0 || x >= 8 || y >= 8 || S[y][x] == '.') {\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\n\t\tif (S[y][x] == (is_mami ? 'o' : 'x')) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\nbool simulation(VS &S, int y0, int x0, bool is_mami) {\n\tif (S[y0][x0] != '.') {\n\t\treturn false;\n\t}\n\t\n\tS[y0][x0] = is_mami ? 'o' : 'x';\n\n\tbool flg = false;\n\tfor (int i = 0; i < 8; i++) {\n\t\tif (!can_reverse(S, y0, x0, i, is_mami)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = x0;\n\t\tint y = y0;\n\t\t\n\n\t\twhile (true) {\n\t\t\tx += dx[i];\n\t\t\ty += dy[i];\n\n\t\t\tif (x < 0 || y < 0 || x >= 8 || y >= 8\n\t\t\t\t\t|| S[y][x] == '.'\n\t\t\t\t\t|| S[y][x] == (is_mami ? 'o' : 'x')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[y][x] = is_mami ? 'o' : 'x';\n\t\t\tflg |= true;\n\t\t}\n\t}\n\n\treturn flg;\n}\n\nint counter(VS &S, bool is_mami) {\n\tint cnt = 0;\n\t\n\tfor (int i = 0; i < 8; i++) {\n\t\tcnt += count(S[i].begin(), S[i].end(), is_mami ? 'o' : 'x');\n\t}\n\n\treturn cnt;\n}\n\nint main(void) {\n\tVS S(8);\n\tfor (auto &s : S) cin >> s;\n\n\tbool is_mami = true;\n\tbool cannot = false;\n\twhile(true) {\n\t\tVS max_next;\n\t\tint now = counter(S, is_mami);\n\t\tint max_cookie = -1;\n\t\t\n\t\tfor (int y = 0; y < 8; y++) {\n\t\t\tfor (int x = 0; x < 8; x++) {\t\n\t\t\t\tVS next(S);\n\n\t\t\t\tif (!simulation(next, y, x, is_mami)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint cookie = counter(next, is_mami);\n\t\t\t\tif (cookie != now &&\n\t\t\t\t\t\t((is_mami && cookie > max_cookie) || \n\t\t\t\t\t\t (!is_mami && cookie >= max_cookie))) {\n\t\t\t\t\tmax_cookie = cookie;\n\t\t\t\t\tmax_next = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (max_cookie == -1) {\n\t\t\tif (cannot) {\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tcannot = true;\n\t\t\t\tis_mami = !is_mami;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcannot = false;\n\t\tS = max_next;\n\t\tis_mami = !is_mami;\n\t}\n\n\tfor (auto s : S) cout << s << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<iostream>\n#include<algorithm>\n\n#define empty 0\n#define choco 1\n#define cheese 2\nusing namespace std;\n\nint main(void){\n\n\tint s[8][8];\n\tchar inp;\n\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tcin>>inp;\n\t\t\tswitch(inp){\n\t\t\t\tcase '.':\n\t\t\t\t\ts[i][j]=empty;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\ts[i][j]=choco;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\ts[i][j]=cheese;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt,sum,max,mx,my;\n\tint x,y;\n\tint max2;\n\n\twhile(1){\n\t\t\n\t\t/*Chocolatecooky*/\n\t\tmax=-1,mx=-1,my=-1;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i][j]==empty){\n\t\t\t\t\tsum=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(i+k>=0&&i+k<=7&&j+l>=0&&j+l<=7){\n\t\t\t\t\t\t\t\tif(s[i+k][j+l]==cheese){\n\t\t\t\t\t\t\t\t\tx=j,y=i,cnt=0;\n\t\t\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\t\tx+=l,y+=k;\n\t\t\t\t\t\t\t\t\t\tif(x>=0&&x<=7&&y>=0&&y<=7){\n\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==empty) break;\n\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==choco){\n\t\t\t\t\t\t\t\t\t\t\t\tsum+=cnt;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==cheese) cnt++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((max<sum||(max==sum&&my>i)||(max==sum&&my==i&&mx>j))&&sum!=0) max=sum,mx=j,my=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max!=-1){\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(my+i>=0&&my+i<=7&&mx+j>=0&&mx+j<=7){\n\t\t\t\t\t\tif(s[my+i][mx+j]==cheese){\n\t\t\t\t\t\t\tx=mx,y=my;\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\tx+=j,y+=i;\n\t\t\t\t\t\t\t\tif(x>=0&&x<=7&&y>=0&&y<=7){\n\t\t\t\t\t\t\t\t\tif(s[y][x]==empty) break;\n\t\t\t\t\t\t\t\t\tif(s[y][x]==choco){\n\t\t\t\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\t\t\tx-=j,y-=i;\n\t\t\t\t\t\t\t\t\t\t\tif(x>=0&&x<=8&&y>=0&&y<=8){\n\t\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==cheese) s[y][x]=choco;\n\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\ts[y][x]=choco;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*Cheese*/\n\t\tmax2=-1,mx=-1,my=-1;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i][j]==empty){\n\t\t\t\t\tsum=0;\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tfor(int l=-1;l<=1;l++){\n\t\t\t\t\t\t\tif(i+k>=0&&i+k<=7&&j+l>=0&&j+l<=7){\n\t\t\t\t\t\t\t\tif(s[i+k][j+l]==choco){\n\t\t\t\t\t\t\t\t\tx=j,y=i,cnt=0;\n\t\t\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\t\tx+=l,y+=k;\n\t\t\t\t\t\t\t\t\t\tif(x>=0&&x<=7&&y>=0&&y<=7){\n\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==empty) break;\n\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==cheese){\n\t\t\t\t\t\t\t\t\t\t\t\tsum+=cnt;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==choco) cnt++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((max2<sum||(max2==sum&&my<i)||(max2==sum&&my==i&&mx<j))&&sum!=0) max2=sum,mx=j,my=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max2!=-1){\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(my+i>=0&&my+i<=7&&mx+j>=0&&mx+j<=7){\n\t\t\t\t\t\tif(s[my+i][mx+j]==choco){\n\t\t\t\t\t\t\tx=mx,y=my;\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\tx+=j,y+=i;\n\t\t\t\t\t\t\t\tif(x>=0&&x<=7&&y>=0&&y<=7){\n\t\t\t\t\t\t\t\t\tif(s[y][x]==empty) break;\n\t\t\t\t\t\t\t\t\tif(s[y][x]==cheese){\n\t\t\t\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\t\t\tx-=j,y-=i;\n\t\t\t\t\t\t\t\t\t\t\tif(x>=0&&x<=8&&y>=0&&y<=8){\n\t\t\t\t\t\t\t\t\t\t\t\tif(s[y][x]==choco) s[y][x]=cheese;\n\t\t\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\t\ts[y][x]=cheese;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max==-1&&max2==-1) break;\n\t}\n\t\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tswitch(s[i][j]){\n\t\t\t\tcase empty:\n\t\t\t\t\tcout<<\".\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase choco:\n\t\t\t\t\tcout<<\"o\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase cheese:\n\t\t\t\t\tcout<<\"x\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//??????URL http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311&lang=jp\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nchar board[8][8];\n\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\n//player 0:mami 1:magi\nint dfs(int x,int y,int cnt,int idx,int player){\n    int nx=x+dx[idx],ny=y+dy[idx];\n    if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n      cnt++;\n      return dfs(nx,ny,cnt,idx,player);\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n      return cnt;\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n      return 0;\n    }\n    return 0;\n}\n\nint count(int x,int y,int player){\n    int res=0;\n    for(int i=0;i<8;i++) res+=dfs(x,y,0,i,player);\n    return res;\n}\n\nint solve(int player){\n    int ma=-1,x,y;\n    for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n      if(board[i][j]=='.' && count(i,j,player)>ma){\n        ma=count(i,j,player);\n        x=i;y=j;\n      }\n    }//?????§?????????????????´???\n    if(ma<1) return 0;\n    board[x][y]='o';\n    for(int i=0;i<8;i++){\n      int tmp=dfs(x,y,0,i,player);\n      for(int j=1;j<=tmp;j++){\n        board[x+dx[i]*j][y+dy[i]*j]='o';\n      }\n    }\n    return 1;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=solve(0);\n    magi_flag=solve(1);\n  //  cout<<mami_flag<<\" \"<<magi_flag<<endl;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid rotate(vector<string> &field){\n  int n = field.size();\n  vector<string> tmp = field;\n  REP(i, n)REP(j, n){\n    tmp[n-i-1][n-j-1] = field[i][j];\n  }\n  REP(i, n)REP(j, n){\n    field[i][j] = tmp[i][j] == 'o' ? 'x' : tmp[i][j] == '.' ? '.' : 'o';\n  }\n}\n\npair<int, vector<string> > flip(const vector<string> &field, int x, int y, char c){\n  int n = field.size();\n  \n  int ans = 0;\n  vector<string> board = field;\n\n  board[x][y] = c;\n  \n  REP2(dx, -1, 2)REP2(dy, -1, 2){\n    if(dx == 0 && dy == 0) continue;\n    int tx = x + dx, ty = y + dy;\n    while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n          board[tx][ty] != '.' && board[tx][ty] != c) {\n      tx += dx;\n      ty += dy;\n    }\n    \n    if(0 <= tx && tx < n && 0 <= ty && ty < n && board[tx][ty] == c){\n      tx = x + dx, ty = y + dy;\n      \n      while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n            board[tx][ty] != '.' && board[tx][ty] != c) {\n        board[tx][ty] = c;\n        tx += dx;\n        ty += dy;\n        ans++;\n      }\n    }\n  }\n  return make_pair(ans, board);\n  \n}\n\nint main(){\n  vector<string> field(8);\n  \n  REP(i, 8) cin >> field[i];\n\n  int s = 0;\n  bool mami;\n  REP(i, 8) s += count(ALL(field[i]), '.');\n  if(s % 2){\n    mami = false;\n  }else{\n    mami = true;\n  }\n\n  int bad = 0;\n\n  // cout << mami << endl;\n  while(true){\n    // REP(i, 8) cout << field[i] << endl;\n    if(!mami) rotate(field);\n\n    int best = 0;\n    vector<string> bestboard;\n    \n    REP(i, 8) REP(j, 8)if(field[i][j] == '.'){\n      pair<int, vector<string> > p = flip(field, i, j, 'o');\n      if(p.first > best){\n        best = p.first;\n        bestboard = p.second;\n      }\n    }\n\n    if(best > 0){\n      bad = 0;\n      field = bestboard;\n    }\n    \n    if(!mami) rotate(field);\n    \n    if(best == 0){\n      bad++;\n      if(bad > 1) break;\n    }\n    mami = !mami;\n  }\n  REP(i, 8) cout << field[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef pair<int,int> pii;\n \nchar board[8][8];\n \nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n \nint mami_dfs(int x,int y,int cnt,int idx){\n  int nx=x+dx[idx],ny=y+dy[idx];\n  if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n    cnt++;\n    return mami_dfs(nx,ny,cnt,idx);\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n    return cnt;\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n    return 0;\n  }\n  return 0;\n}\n \nint magi_dfs(int x,int y,int cnt,int idx){\n  int nx=x+dx[idx],ny=y+dy[idx];\n  if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n    cnt++;\n    return magi_dfs(nx,ny,cnt,idx);\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n    return cnt;\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n    return 0;\n  }\n  return 0;\n}\n \nint mami_count(int x,int y){//(x,y)???????????????¨??????????????????°\n  int res=0;\n  for(int i=0;i<8;i++) res+=mami_dfs(x,y,0,i);\n  return res;\n}\n \nint magi_count(int x,int y){//(x,y)???????????????¨??????????????????°\n  int res=0;\n  for(int i=0;i<8;i++) res+=magi_dfs(x,y,0,i);\n  return res;\n}\n \nint mami_solve(){//????????????????????????¶???\n  int ma=-1,x,y;\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n    if(board[i][j]=='.' && mami_count(i,j)>ma){\n      ma=mami_count(i,j);\n      x=i;y=j;\n    }\n  }//??????§??????????????????´???\n  if(ma<1) return false;\n  board[x][y]='o';\n  for(int i=0;i<8;i++){\n    int tmp=mami_dfs(x,y,0,i);\n    for(int j=1;j<=tmp;j++){\n      board[x+dx[i]*j][y+dy[i]*j]='o';\n    }\n  }\n  return true;\n}\n \nbool magi_solve(){//????????????????????????¶???\n  int ma=-1,x,y;\n  for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n    if(board[i][j]=='.'&&magi_count(i,j)>ma){\n      ma=magi_count(i,j);\n      x=i;y=j;\n    }\n  }//??????§??????????????????´???\n  if(ma<1) return false;\n  board[x][y]='x';\n  for(int i=0;i<8;i++){\n    int tmp=magi_dfs(x,y,0,i);\n    for(int j=1;j<=tmp;j++){\n      board[x+dx[i]*j][y+dy[i]*j]='x';\n    }\n  }\n  return true;\n}\n \nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n \n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=mami_solve();\n    magi_flag=magi_solve();\n  //  cout<<mami_flag<<\" \"<<magi_flag<<endl;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint dx[] = {-1,-1,0,1,1,1,0,-1},dy[] = {0,1,1,1,0,-1,-1,-1};\n\nint main(){\n\tint field[10][10] = {},mas[10][10] = {};\n\tstring s;\n\tfor(int i = 0;i < 8;i++){\n\t\tcin >> s;\n\t\tfor(int j = 0;j < 8;j++){\n\t\t\tif(s[j] == 'o') field[i + 1][j + 1] = 1;\n\t\t\telse if(s[j] == 'x') field[i + 1][j + 1] = 2;\n\t\t}\n\t}\n\tint flag = 0;//o start\n\tbool pass = false;\n\twhile(1){\n\t\tint can = 0;\n\t\tint mnum = 0,mx,my;\n\t\tfor(int i = 0;i <= 9;i++){\n\t\t\tfor(int j = 0;j <= 9;j++) mas[i][j] = 0;\n\t\t}\n\t\tfor(int i = 1;i <= 8;i++){\n\t\t\tfor(int j = 1;j <= 8;j++){\n\t\t\t\tif(!field[i][j]){\n\t\t\t\t\tint ma = 0;\n\t\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\t\tint x = i + dx[k],y = j + dy[k],cnt = 0;\n\t\t\t\t\t\twhile(field[x][y] == (flag + 1) % 2 + 1) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[x][y]) {\n\t\t\t\t\t\t\tma += cnt;\n\t\t\t\t\t\t\tmas[i][j] += (1 << k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((flag == 0 && mnum < ma) || (flag == 1 && mnum <= ma)){\n\t\t\t\t\t\tmnum = ma;\n\t\t\t\t\t\tmx = i;\n\t\t\t\t\t\tmy = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(ma) can++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(can == 0){\n\t\t\tif(!pass) pass = true;\n\t\t\telse break;\n\t\t}else{\n\t\t\tfield[mx][my] = flag + 1;\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif((mas[mx][my] >> i) & 1){\n\t\t\t\t\tint x = mx + dx[i],y = my + dy[i];\n\t\t\t\t\twhile(field[x][y] == (flag + 1) % 2 + 1){\n\t\t\t\t\t\tfield[x][y] = flag + 1;\n\t\t\t\t\t\tx += dx[i];\n\t\t\t\t\t\ty += dy[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpass = false;\n\t\t}\n\t\tflag = !flag;\n\t}\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tif(field[i][j] == 0) cout << '.';\n\t\t\telse if(field[i][j] == 1) cout << 'o';\n\t\t\telse cout << 'x';\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nbool valid(int ni,int nj){ return ni>=0&&ni<8&&nj>=0&&nj<8; }\n\nchar board[10][10];\n\nint di[]={-1,-1,-1,0,0,1,1,1};\nint dj[]={-1,0,1,-1,1,-1,0,1};\n\nvoid dfs(bool turn,bool pass){\n\tif(!turn){//mami\n\t\tint cnt=0,ii,jj;\n\t\tfor(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n\t\t\tif(board[i][j]!='.')continue;\n\t\t\tint ncnt=0;\n\t\t\trep(d,8){\n\t\t\t\tint ni=i+di[d],nj=j+dj[d],sum=0;\n\t\t\t\twhile(valid(ni,nj)&&board[ni][nj]=='x'){\n\t\t\t\t\tni+=di[d],nj+=dj[d];\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t\tif(valid(ni,nj)&&board[ni][nj]=='o'){\n\t\t\t\t\tncnt+=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt<=ncnt){\n\t\t\t\tcnt=ncnt;\n\t\t\t\tii=i; jj=j;\n\t\t\t}\n\t\t}\n\t\tif(cnt==0){\n\t\t\tif(pass)return;\n\t\t\telse{\n\t\t\t\tdfs(true,true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboard[ii][jj]='o';\n\t\trep(d,8){\n\t\t\tint ni=ii+di[d],nj=jj+dj[d];\n\t\t\twhile(valid(ni,nj)&&board[ni][nj]=='x'){\n\t\t\t\tni+=di[d],nj+=dj[d];\n\t\t\t}\n\t\t\tif(valid(ni,nj)&&board[ni][nj]=='o'){\n\t\t\t\tint nni=ii+di[d],nnj=jj+dj[d];\n\t\t\t\twhile(valid(nni,nnj)&&board[nni][nnj]=='x'){\n\t\t\t\t\tboard[nni][nnj]='o';\n\t\t\t\t\tnni+=di[d],nnj+=dj[d];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i,8)cout<<board[i]<<endl;\n\t\t//cout<<endl;\n\t\tdfs(true,false);\n\t}else{\n\t\tint cnt=0,ii,jj;\n\t\trep(i,8)rep(j,8){\n\t\t\tif(board[i][j]!='.')continue;\n\t\t\tint ncnt=0;\n\t\t\trep(d,8){\n\t\t\t\tint ni=i+di[d],nj=j+dj[d],sum=0;\n\t\t\t\twhile(valid(ni,nj)&&board[ni][nj]=='o'){\n\t\t\t\t\tni+=di[d],nj+=dj[d];\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t\tif(valid(ni,nj)&&board[ni][nj]=='x'){\n\t\t\t\t\tncnt+=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt<=ncnt){\n\t\t\t\tcnt=ncnt;\n\t\t\t\tii=i; jj=j;\n\t\t\t}\n\t\t}\n\t\tif(cnt==0){\n\t\t\tif(pass)return;\n\t\t\telse{\n\t\t\t\tdfs(false,true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboard[ii][jj]='x';\n\t\trep(d,8){\n\t\t\tint ni=ii+di[d],nj=jj+dj[d];\n\t\t\twhile(valid(ni,nj)&&board[ni][nj]=='o'){\n\t\t\t\tni+=di[d],nj+=dj[d];\n\t\t\t}\n\t\t\tif(valid(ni,nj)&&board[ni][nj]=='x'){\n\t\t\t\tint nni=ii+di[d],nnj=jj+dj[d];\n\t\t\t\twhile(valid(nni,nnj)&&board[nni][nnj]=='o'){\n\t\t\t\t\tboard[nni][nnj]='x';\n\t\t\t\t\tnni+=di[d],nnj+=dj[d];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i,8)cout<<board[i]<<endl;\n\t\t//cout<<endl;\n\t\tdfs(false,false);\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\trep(i,8)cin>>board[i];\n\tdfs(false,false);\n\trep(i,8)cout<<board[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nint dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy[] = {-1, 0, 1, 1, -1, 0, 1, -1};\n\nstring s[8];\nint d[8][8][8];\n\nint count(int y, int x, int dir, int turn){\n\tint ret = 0, nx = x, ny = y;\n\tif(s[y][x] != '.') return 0;\n\tchar c = (turn % 2 == 0 ? 'o' : 'x');\n\tchar e = (turn % 2 == 1 ? 'o' : 'x');\n\tfor(int i = 0; i < 9; i++){\n\t\tnx += dx[dir];\n\t\tny += dy[dir];\n\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8) return 0;\n\t\tif(s[ny][nx] == c) return i;\n\t\telse if(s[ny][nx] == '.') return 0;\n\t}\n\treturn 0;\n}\n\nvoid fill(int y, int x, int dir, int turn){\n\tint nx = x, ny = y;\n\tchar c = (turn % 2 == 0 ? 'o' : 'x');\n\tchar e = (turn % 2 == 1 ? 'o' : 'x');\n\ts[y][x] = c;\n\tfor(int i = 0; i < 9; i++){\n\t\tny += dy[dir];\n\t\tnx += dx[dir];\n\t\tif(s[ny][nx] == c) return;\n\t\ts[ny][nx] = c;\n\t}\n}\n\nint main(){\n\trep(i, 8) s[i] = in.next();\n\t\n\tfor(int i = 0; i < 1000; i++){\n\t\tint y, x, dir, c = 0;\n\t\tfor(int ty = 0; ty < 8; ty++){\n\t\t\tfor(int tx = 0; tx < 8; tx++){\n\t\t\t\tint tc = 0, ttd = 0;\n\t\t\t\tfor(int td = 0; td < 8; td++){\n\t\t\t\t\tint ttc = count(ty, tx, td, i);\n\t\t\t\t\ttc += ttc;\n\t\t\t\t\tif(ttc != 0) ttd |= (1<<td);\n\t\t\t\t}\n\t\t\t\tif((tc > c) || (i % 2 == 1 && tc == c)){\n\t\t\t\t\tc = tc;\n\t\t\t\t\tx = tx;\n\t\t\t\t\ty = ty;\n\t\t\t\t\tdir = ttd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(c == 0) continue;\n\t\tfor(int td = 0; td < 8; td++){\n\t\t\tif((dir & (1<<td)) != 0) fill(y, x, td, i);\n\t\t}\n\t}\n\n\trep(i, 8) cout<<s[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int N = 2001;\nconst ll inf = (1LL<<62);\nll dp[N][N];\nll compute(int a,int b,const vector<ll> &sum,const ll l){\n  if (a < b)swap(a,b);\n  return (sum[a]-sum[b-1])/l;\n}\n\n//a > b should be satisfied: a,b is index\nll solve(int n,const ll l,int a,int b,const vector<int> &all,const vector<ll> &sum){\n  //cout << a << \" \" << b << \" \" << n <<\" \" << endl;\n  if (a+1 == n || b+1 == n){\n    ll ret=0;\n    if (b == 0){//circular\n      ret=compute(all[a],all[1],sum,l);\n    }else {\n      ret=compute(all[a],all[b],sum,l);\n    }\n    return ret;\n  }\n  if (a < b)swap(a,b);\n  int now=max(a,b)+1;\n\n  ll &ret=dp[a][b];\n  if (dp[a][b] != -1)return ret;\n  ret=inf;\n  //right//\n  ret=min(ret,compute(all[now],all[a],sum,l)+solve(n,l,now,b,all,sum));\n\n  //left//b->now\n  if (b == 0){\n    ret=min(ret,compute(all[1],all[now],sum,l)+solve(n,l,a,now,all,sum));\n  }else {\n    ret=min(ret,compute(all[now],all[b],sum,l)+solve(n,l,a,now,all,sum));\n  }\n  return ret;\n}\n\n\n\nmain(){\n  int n,m;\n  ll l;\n  while(cin>>n>>m>>l){\n    vector<ll> sum(m+1);\n    vector<int> all(n+1);\n    rep(i,n){\n      cin>>all[i];\n      //all[i]--;\n    }\n    sum[0]=0;\n    rep(i,m){\n      int in;\n      cin>>in;\n      sum[i+1]=in+sum[i];\n    }\n    sort(all.begin(),all.end());\n    rep(i,n+1)rep(j,n+1)dp[i][j]=-1;\n    n++;\n    cout << solve(n,l,1,0,all,sum) << endl;\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nvoid solve(vector<string>& s){\n    for(bool turn=true, pass=false; ; turn=!turn){\n        tuple<int, int, int, vector<string> > best = {0, turn? -8: 0, turn? -8: 0, s};\n        rep(x, 8)rep(y, 8)if(s[x][y] == '.'){\n            char my = turn? 'o': 'x', your = turn? 'x': 'o';\n            int cnt = 0;\n            vector<string> t = s; t[x][y] = my;\n            for(int dx=-1; dx<=1; ++dx){\n                for(int dy=-1; dy<=1; ++dy){\n                    int nx = x + dx, ny = y + dy;\n                    if((dx|dy) == 0 || !inrect(nx, ny) || s[nx][ny] != your)continue;\n                    vector<string> tmp = t;\n                    while(inrect(nx, ny) && s[nx][ny] == your){\n                        tmp[nx][ny] = my; nx += dx; ny += dy;\n                    }\n                    if(inrect(nx, ny) && s[nx][ny] == my){\n                        cnt += max(abs(x - nx) - 1, abs(y - ny) - 1);\n                        t.swap(tmp);\n                    }\n                }\n            }\n            if(cnt){\n                //chmax(best, {cnt, turn? -x: x, turn? -y: y, t});\n                tuple<int, int, int, vector<string> > cur = {cnt, turn? -x: x, turn? -y: y, t};\n                chmax(best, cur);\n            }\n        }\n        if(get<0>(best) == 0){\n            if(pass)break; else pass = true;\n        }\n        else{\n            if(pass)pass = false;\n            s.swap(get<3>(best));\n        }\n    }\n}\n\nint main(){\n    vector<string> s(8);\n    rep(i, 8)cin >> s[i];\n    solve(s);\n    rep(i, 8)cout << s[i] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint map[8][8];\n\nint val(int y,int x){\n\tint dx[]={1,1,1,0,0,-1,-1,-1};\n\tint dy[]={1,0,-1,1,-1,1,0,-1};\n\tint ans=0;\n\tfor(int i=0;i<8;i++){\n\t\tint cnt=0,a=y,b=x;\n\t\twhile(true){\n\t\t\ta+=dy[i],b+=dx[i];\n\t\t\tif(a>=0&&a<8&&b>=0&&b<8){\n\t\t\t\tif(map[a][b]==1)cnt++;\n\t\t\t\tif(map[a][b]==0){\n\t\t\t\t\tans+=cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[a][b]==2)break;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid ch(int y,int x){\n\tint dx[]={1,1,1,0,0,-1,-1,-1};\n\tint dy[]={1,0,-1,1,-1,1,0,-1};\n\tfor(int i=0;i<8;i++){\n\t\tint a=y,b=x;\n\t\tbool ok=false;\n\t\twhile(true){\n\t\t\ta+=dy[i],b+=dx[i];\n\t\t\tif(a>=0&&a<8&&b>=0&&b<8){\n\t\t\t\tif(map[a][b]==0){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[a][b]==2)break;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tif(ok){\n\t\t\twhile(true){\n\t\t\t\tif(a==y&&b==x)break;\n\t\t\t\ta-=dy[i],b-=dx[i];\n\t\t\t\tmap[a][b]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tchar z;cin>>z;\n\t\t\tif(z=='o')map[i][j]=0;\n\t\t\tif(z=='x')map[i][j]=1;\n\t\t\tif(z=='.')map[i][j]=2;\n\t\t}\n\t}\n\tint t=0;\n\tfor(int u=0;u<130;u++){\n\t\tif(t==0){\n\t\t\tint x=-1,y=-1,z=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\t\tint k=val(i,j);\n\t\t\t\t\t\tif(k>z)x=j,y=i,z=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z)ch(y,x);\n\t\t}\n\t\tif(t==1){\n\t\t\tint x=-1,y=-1,z=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\t\tint k=val(i,j);\n\t\t\t\t\t\tif(k>=z)x=j,y=i,z=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z)ch(y,x);\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==0)map[i][j]=3;\n\t\t\t\tif(map[i][j]==1)map[i][j]=0;\n\t\t\t\tif(map[i][j]==3)map[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tt=1-t;\n\t}\n\t\n\tif(t){\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==0)map[i][j]=3;\n\t\t\t\tif(map[i][j]==1)map[i][j]=0;\n\t\t\t\tif(map[i][j]==3)map[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tif(map[i][j]==0)cout<<\"o\";\n\t\t\tif(map[i][j]==1)cout<<\"x\";\n\t\t\tif(map[i][j]==2)cout<<\".\";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<string> board(8);\nvector<int> dx={0,1,1,1,0,-1,-1,-1};\nvector<int> dy={1,1,0,-1,-1,-1,0,1};\n\nint angles_check(int x, int y, string name){\n    char my_dessert;\n    if(name==\"mami\"){\n        my_dessert='o';\n    }else{\n        my_dessert='x';\n    }\n    int ret=0;\n    for(int i=0;i<8;i++){\n        int step=1,tmp_ret=0;\n        while(1){\n            int now_x = x+dx[i]*step;\n            int now_y = y+dy[i]*step;\n\n            //境界判定\n            if(!(0<=now_x && now_x<8 && 0<=now_y && now_y<8)){\n                tmp_ret=0;\n                break;\n            }\n            \n            if(board[now_x][now_y]==my_dessert){\n                break;\n            }else if(board[now_x][now_y]=='.'){\n                tmp_ret=0;\n                break;\n            }\n            tmp_ret++;\n            step++;\n        }\n        ret+=tmp_ret;\n    }\n    return ret;\n}\n\nvoid replace_board(int x, int y, string name){\n    char my_dessert;\n    if(name==\"mami\"){\n        my_dessert='o';\n    }else{\n        my_dessert='x';\n    }\n\n    board[x][y]=my_dessert;\n\n    for(int i=0;i<8;i++){\n        int step=1;\n        bool flag=false;\n        while(1){\n            int now_x = x+dx[i]*step;\n            int now_y = y+dy[i]*step;\n            //境界判定\n            if(!(0<=now_x && now_x<8 && 0<=now_y && now_y<8))break;\n            if(board[now_x][now_y]==my_dessert){\n                flag=true;\n                break;\n            }else if(board[now_x][now_y]=='.'){\n                break;\n            }\n            step++;\n        }\n        if(flag) if(step>=2) for(int k=1;k<step;k++) board[x+dx[i]*k][y+dy[i]*k]=my_dessert;\n    }\n}\n\nint board_check(string name){\n    vector<vector<int>> max_check(8,vector<int>(8,0));\n    int get_num,maxi=0;\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            if(board[i][j]!='.')continue;\n            get_num=angles_check(i,j,name);\n            max_check[i][j]=get_num;\n            maxi=max(maxi,get_num);\n        }\n    }\n    if(name==\"mami\"){\n        for(int i=0;i<8;i++){\n            for(int j=0;j<8;j++){\n                if(maxi!=0 && maxi==max_check[i][j]){\n                    replace_board(i,j,name);\n                    goto A;\n                }\n            }\n        }\n    }else{\n        for(int i=7;i>=0;i--){\n            for(int j=7;j>=0;j--){\n                if(maxi!=0 && maxi==max_check[i][j]){\n                    replace_board(i,j,name);\n                    goto A;\n                }\n            }\n        }\n    }\n    A:\n    return maxi;\n}\n\nint main(){\n    for(int i=0;i<8;i++) cin >> board[i];\n    string name=\"mami\";\n    int pass=0;\n    while(1){\n        if(pass==2)break;\n        if(name==\"mami\"){\n            if(!board_check(name)){\n                pass++;\n            }else{\n                pass=0;\n            }\n            name=\"charlotte\";\n        }else{\n            if(!board_check(name)){\n                pass++;\n            }else{\n                pass=0;\n            }\n            name=\"mami\";\n        }\n    }\n\n    for(int i=0;i<8;i++) cout << board[i] <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nchar table[10][10] ;\nint dx[] = {-1,0,1,-1,1,-1,0,1} ;\nint dy[] = {-1,-1,-1,0,0,1,1,1} ;\nint dx2[] = {1,0,-1,1,-1,1,0,-1} ;\nint dy2[] = {1,1,1,0,0,-1,-1,-1} ;\nchar p = 'o' , e = 'x' ;\n\nint f( int x , int y ){\n\tint ans = 0 ;\n\tfor( int k=0 ; k<8 ; k++ ){\n\t\tint nx2 = x , ny2 = y , ans2 = 0 ;\n\t\tfor( int q=0 ; ; q++ ){\n\t\t\tif( table[ny2+dy[k]][nx2+dx[k]] == e ) ans2++ ;\n\t\t\telse if( table[ny2+dy[k]][nx2+dx[k]] == p ){\n\t\t\t\tans += ans2 ; break ;\n\t\t\t}\n\t\t\telse break ;\n\t\t\tnx2 += dx[k] ;\n\t\t\tny2 += dy[k] ;\n\t\t}\n\t}\n\treturn ans+1 ;\n}\n\nint main(){\n\t\n\tfor( int i=0 ; i<10 ; i++ ){\n\t\tfor( int j=0 ; j<10 ; j++ ){\n\t\t\tif( i==0 || i==9 || j==0 || j==9 ) table[i][j] = '#' ;\n\t\t\telse cin >> table[i][j] ;\n\t\t}\n\t}\n\t\n\tint cheak = 0 ;char a ;\n\twhile(1){\n\t\t//cin >> a ;\n\t\tint nx=0,ny=0,nk=0,cnt=1,cnt2=0 ;\n\t\tfor( int i=1 ; i<=8 ; i++ ){\n\t\t\tfor( int j=1 ; j<=8 ; j++ ){\n\t\t\t\tif( table[i][j] == '.' ){\n\t\t\t\t\tcnt2 = f(j,i) ;\n\t\t\t\t\tif( cnt < cnt2 ){ nx = j ; ny = i ; cnt = cnt2 ; }\n\t\t\t\t\telse if( cnt == cnt2 ){\n\t\t\t\t\t\tif( p == 'o' ){\n\t\t\t\t\t\t\tif( ny > i ){ nx = j ; ny = i ; }\n\t\t\t\t\t\t\telse if( ny == i && nx > j ){ nx = j ; ny = i ; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( p == 'x' ){\n\t\t\t\t\t\t\tif( ny < i ){ nx = j ; ny = i ; }\n\t\t\t\t\t\t\telse if( ny == i && nx < j ){ nx = j ; ny = i ;}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"end\" << nx << \" \" << ny << \" \" << p << cnt << endl ;//------------\n\t\tif( cnt > 1 ){\n\t\t\tfor( int i=0 ; i<8 ; i++ ){\n\t\t\t\tint nx3 = nx , ny3 = ny ;\n\t\t\t\tfor( int j=0 ; ; j++ ){\n\t\t\t\t\tif( table[ny3+dy[i]][nx3+dx[i]] == e ){\n\t\t\t\t\t\tny3 += dy[i] ; nx3 += dx[i] ;\n\t\t\t\t\t}\n\t\t\t\t\telse if( j>=0 && table[ny3+dy[i]][nx3+dx[i]] == p ){\n\t\t\t\t\t\tfor( ; j>0 ; j-- ){\n\t\t\t\t\t\t\ttable[ny3][nx3] = p ;\n\t\t\t\t\t\t\tny3 -= dy[i] ; nx3 -= dx[i] ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\t\telse break ;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttable[ny][nx] = p ;\n\t\t\tcheak = 0 ;\n\t\t}\n\t\telse cheak++ ;\n\t\t/*\n\t\tfor( int i=0 ; i<=9 ; i++ ){//--------------\n\t\t\tfor( int j=0 ; j<=9 ; j++ ){\n\t\t\t\tcout << table[i][j] ;\n\t\t\t}\n\t\t\tcout << endl ;\n\t\t}*/\n\t\t\n\t\tif( cheak >= 2 ) break ;\n\t\t\n\t\tswap(p,e) ;\n\t\tswap(dx,dx2) ;\n\t\tswap(dy,dy2) ;\n\t}\n\t\n\tfor( int i=1 ; i<=8 ; i++ ){\n\t\tfor( int j=1 ; j<=8 ; j++ ){\n\t\t\tcout << table[i][j] ;\n\t\t}\n\t\tcout << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring a[8];\nint ax[]={-1,-1,-1,0,0,1,1,1};\nint ay[]={-1,0,1,-1,1,-1,0,1};\nint i,j,turn=1,x=7,y=7,cou,k=0,c1=0,c2=0;\nchar mi[]={'x','o'};\nint dfs(int dx,int dy){\n  int aa=dx+1,bb=dy+1;\n  if(y+ay[k]*aa==8||x+ax[k]*bb==8||y+ay[k]*aa<0||x+ax[k]*bb<0)return 0;\n  if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[(turn+1)%2])cou=dfs(aa,bb);\n  else if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[turn%2])return aa-1;\n  else return 0;\n  return cou;\n}\nint ds(){\n  int c=0;\n  for(k=0;k<8;k++){\n    if(ax[k]+x==8||ay[k]+y==8||ax[k]+x<0||ay[k]+y<0)continue;\n    if(a[y+ay[k]][x+ax[k]]==mi[(turn+1)%2]){c+=dfs(0,0);}\n    cou=0;\n  }\n  return c;//\n}\nint re1(int dx,int dy){\n  int c=0,aa=dx+1,bb=dy+1;\n    if(y+ay[k]*aa==8||x+ax[k]*bb==8||y+ay[k]*aa<0||x+ax[k]*bb<0)return 0;\n    if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[(turn+1)%2])c=re1(aa,bb);\n  else if(a[y+ay[k]*aa][x+ax[k]*bb]==mi[turn%2])return 1;\n  else return 0;\n  if(c){a[y+ay[k]*aa][x+ax[k]*bb]=mi[turn%2];\n  return 1;\n    }\n    return 0;\n}\nvoid reverse(){\n  a[y][x]=mi[turn%2];\n  for(k=0;k<8;k++){\n    if(ax[k]+x==8||ay[k]+y==8||(ax[k]+x)<0||(ay[k]+y)<0)continue;\n    if(a[y+ay[k]][x+ax[k]]==mi[(turn+1)%2]){re1(0,0);}\n  }\n}\nvoid tiro(){\n  int m=0,max1=0,xy[8][8];\n  for(y=7;y>=0;y--){\n    for(x=7;x>=0;x--){\n      if(a[y][x]=='.')m=ds();\n      xy[y][x]=m;\n      max1=max(m,max1);\n      m=0;\n    } \n  }\n  if(!turn%2){\n  for(y=7;y>=0;y--){\n    if(max1==0)break;\n    for(x=7;x>=0;x--){\n      if(xy[y][x]==max1){\n        reverse();\n        max1=0;\n        break;\n      }\n    }   \n  }\n }\n else{\n  for(y=0;y<8;y++){\n    if(max1==0)break;\n    for(x=0;x<8;x++){\n      if(xy[y][x]==max1){\n        reverse();\n        max1=0;\n        break;\n      }\n    }   \n  }\n }\n} \nint check(){\n  int aa=0,bb=0;\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++){\n      if(a[i][j]=='x')aa++;\n      if(a[i][j]=='o')bb++;\n    }\n  }\n  c1++;\n  if((!aa||!bb)||aa+bb==64||c1>64)return 1;\n  else return 0;\n}\nint main(){\n  for(i=0;i<8;i++)cin>>a[i];\n  while(1){\n    tiro();\n    if(check())break;\n    turn++;\n  }\n  for(i=0;i<8;i++)cout<<a[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<long long>;\nusing vlad=valarray<double>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\nint main(){\n    vvi f(10,vi(10,-1)); vi a(2,0);\n    range(i,1,9)range(j,1,9){\n        char c;cin>>c;\n        if(c=='o'){f[i][j]=0;a[0]++;}\n        if(c=='x'){f[i][j]=1;a[1]++;}\n    }\n    int t=0,nt=0;\n    while(a[0]+a[1]<64&&a[0]&&a[1]){\n        int mx=0,px,py;\n        range(i,1,9){\n            range(j,1,9){\n                int turnable=0, y=t?9-i:i, x=t?9-j:j;\n                if(f[y][x]!=-1)continue;\n                vi v={1,0,-1,0,1,1,-1,-1,1};\n                rep(k,8){\n                    int dy=v[k],dx=v[k+1];\n                    range(l,1,8){\n                        if(f[y+dy*l][x+dx*l]==-1)break;\n                        if(f[y+dy*l][x+dx*l]==t){\n                            turnable+=l-1;\n                            break;\n                        }\n                    }\n                }\n                if(mx<turnable){\n                    mx=turnable; py=y; px=x;\n                }\n            }\n        }\n        if(mx==0){\n            nt++;\n            if(nt==2){\n                break;\n            }\n        }else{\n            nt=0;\n            vi v={1,0,-1,0,1,1,-1,-1,1};\n            a[t]++;\n            rep(k,8){\n                int y=py,x=px;\n                int dy=v[k],dx=v[k+1];\n                range(l,1,8){\n                    if(f[y+dy*l][x+dx*l]==-1)break;\n                    if(f[y+dy*l][x+dx*l]==t){\n                        rep(m,l) f[y+dy*m][x+dx*m]=t;\n                        a[t]+=(l-1);\n                        a[!t]-=(l-1);\n                        break;\n                    }\n                }\n            }\n        }\n        t=!t;\n    }\n    range(i,1,9){range(j,1,9)cout<<(\".ox\"[f[i][j]+1]);cout<<endl;}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1003,INF=1<<30;\nvector<int> dx={-1,0,1,1,1,0,-1,-1},dy={1,1,1,0,-1,-1,-1,0};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    vector<string> S(8);\n    for(int i=0;i<8;i++){\n        cin>>S[i];\n    }\n    \n    for(int turn=0;turn<64*2;turn++){\n        pair<int,int> oku={-1,-1};\n        int maxi=0;\n        if(turn%2==0){\n            for(int i=0;i<8;i++){\n                for(int j=0;j<8;j++){\n                    if(S[i][j]=='o'||S[i][j]=='x') continue;\n                    int cnt=0;\n                    for(int k=0;k<8;k++){\n                        int xnow=i+dx[k],ynow=j+dy[k];\n                        int subcnt=0;\n                        while(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='x'){\n                            subcnt++;\n                            xnow+=dx[k];\n                            ynow+=dy[k];\n                        }\n                        if(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='o') cnt+=subcnt;\n                    }\n                    \n                    if(maxi<cnt){\n                        maxi=max(maxi,cnt);\n                        oku={i,j};\n                    }\n                }\n            }\n            \n            if(maxi){\n                int i=oku.first,j=oku.second;\n                \n                for(int k=0;k<8;k++){\n                    int xnow=i+dx[k],ynow=j+dy[k];\n                    while(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='x'){\n                        xnow+=dx[k];\n                        ynow+=dy[k];\n                    }\n                    if(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='o'){\n                        xnow=i+dx[k];ynow=j+dy[k];\n                        \n                        while(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='x'){\n                            S[xnow][ynow]='o';\n                            xnow+=dx[k];\n                            ynow+=dy[k];\n                        }\n                    }\n                }\n                \n                S[i][j]='o';\n            }\n        }else{\n            for(int i=7;i>=0;i--){\n                for(int j=7;j>=0;j--){\n                    if(S[i][j]=='o'||S[i][j]=='x') continue;\n                    int cnt=0;\n                    for(int k=0;k<8;k++){\n                        int xnow=i+dx[k],ynow=j+dy[k];\n                        int subcnt=0;\n                        while(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='o'){\n                            subcnt++;\n                            xnow+=dx[k];\n                            ynow+=dy[k];\n                        }\n                        if(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='x') cnt+=subcnt;\n                    }\n                    \n                    if(maxi<cnt){\n                        maxi=max(maxi,cnt);\n                        oku={i,j};\n                    }\n                }\n            }\n            \n            if(maxi){\n                int i=oku.first,j=oku.second;\n                \n                for(int k=0;k<8;k++){\n                    int xnow=i+dx[k],ynow=j+dy[k];\n                    while(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='o'){\n                        xnow+=dx[k];\n                        ynow+=dy[k];\n                    }\n                    if(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='x'){\n                        xnow=i+dx[k];ynow=j+dy[k];\n                        \n                        while(xnow>=0&&xnow<8&&ynow>=0&&ynow<8&&S[xnow][ynow]=='o'){\n                            S[xnow][ynow]='x';\n                            xnow+=dx[k];\n                            ynow+=dy[k];\n                        }\n                    }\n                }\n                \n                S[i][j]='x';\n            }\n        }\n    }\n    \n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            cout<<S[i][j];\n        }\n        cout<<endl;\n    }\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <regex>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring fld[8];\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nvector<P> search(char c)\n{\n\tvector<P> v;\n\tint mx = 1;\n\tREP(i, 8)REP(j, 8)\n\t{\n\t\tif (fld[i][j] != '.') continue;\n\t\tint cnt = 0;\n\t\tREP(k, 8)\n\t\t{\n\t\t\tint tmp = 0;\n\t\t\tint nx = i; int ny = j;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 ||fld[nx][ny]=='.') break;\n\t\t\t\telse if (fld[nx][ny] != c)\n\t\t\t\t{\n\t\t\t\t\ttmp++; continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcnt += tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt > mx)\n\t\t{\n\t\t\tv.clear();\n\t\t\tv.push_back(P(i, j));\n\t\t\tmx = cnt;\n\t\t}\n\t\telse if (cnt == mx)\n\t\t{\n\t\t\tv.push_back(P(i, j));\n\t\t}\n\t}\n\treturn v;\n}\n\nbool endf()\n{\n\tvector<P> a, b;\n\ta = search('x'); b = search('o');\n\tif (a.size() == 0 && b.size() == 0) return false;\n\telse return true;\n}\n\nvoid majo()\n{\n\tvector<P> v = search('x');\n\tint x, y;\n\tif (v.size() > 0)\n\t{\n\t\tx = v.back().first; y = v.back().second;\n\t\tfld[x][y] = 'x';\n\t\tREP(k, 8)\n\t\t{\n\t\t\tvector<P> w;\n\t\t\tint nx = x; int ny = y;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 || fld[nx][ny] == '.') break;\n\t\t\t\telse if (fld[nx][ny] == 'o')\n\t\t\t\t{\n\t\t\t\t\tw.push_back(P(nx, ny)); continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREP(i, w.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tfld[w[i].first][w[i].second] = 'x';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid mami()\n{\n\tvector<P> v = search('o');\n\tint x, y;\n\tif (v.size() > 0)\n\t{\n\t\tx = v[0].first; y = v[0].second;\n\t\tfld[x][y] = 'o';\n\t\tREP(k, 8)\n\t\t{\n\t\t\tvector<P> w;\n\t\t\tint nx = x; int ny = y;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 || fld[nx][ny] == '.') break;\n\t\t\t\telse if (fld[nx][ny] == 'x')\n\t\t\t\t{\n\t\t\t\t\tw.push_back(P(nx, ny)); continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREP(i, w.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tfld[w[i].first][w[i].second] = 'o';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main()\n{\n\tREP(i, 8) cin >> fld[i];\n\tfor (int i = 0; endf(); i++)\n\t{\n\t\tif (i % 2) majo();\n\t\telse mami();\n\t}\n\tREP(i, 8) cout << fld[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\nstring F[10];\nbool used[10][10];\nint turn;\n\nbool debug;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n  \n  if(x == 4 && y == 2 && dx == 0 && dy == 1) {\n    cerr << \"pass\\n\";\n  }\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    if(cnt) cerr << \"hit \" << cnt << \"\\n\";\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  \n  rep(i, 8) {\n    cin >> F[i];\n  }\n  \n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    cerr << \"ox\"[turn&1] << endl;\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7)\n      DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        \n        if(mx < r) {\n          cerr << \"update mx \";\n          memcpy(u, used, sizeof u);\n          mx = r;\n          cerr << mx << endl;\n          pl = turn&1;\n        }\n        \n      }\n    }\n    if(mx > 0) {\n      cerr << \"update field\\n\";\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      \n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  \n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Dessert Witch\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// #define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\n\nstruct P {\n  int x, y;\n  vpi l;\n  int score;\n};\n\nchar field[8][8];\n\nint dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nint dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate <typename T> bool select(T t, char c1, char c2){\n  vector<P> v;\n\n  REP(y, 8) REP(x, 8){\n    if(field[y][x] != '.') continue;\n\n    vpi l;\n    REP(i, 8){\n      int sx = x + dx[i];\n      int sy = y + dy[i];\n      if(0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == c2) {\n        vpi ll;\n        while(0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == c2) {\n          ll.push_back({sx, sy});\n          sx += dx[i];\n          sy += dy[i];\n        }\n        if(0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == c1) {\n          for(pii p : ll) {\n            l.push_back(p);\n          }\n        }\n      }\n    }\n\n    if (!l.empty()) {\n      LOG(\"(%d %d) %d\\n\", x, y, (int)l.size());\n      l.push_back({x, y});\n      v.push_back({x, y, l, (int)l.size()});\n    }\n  }\n\n  LOG(\"size() %d\\n\", (int)v.size());\n  if (v.empty()) return true;\n  sort(RALL(v), t);\n  LOG(\"(%d %d)\\n\", v[0].x, v[0].y);\n  for(pii p : v[0].l) {\n    LOG(\"\\t(%d %d) %c\\n\", p.first, p.second, c1);\n    field[p.second][p.first] = c1;\n  }\n  return false;\n}\n\nvoid printWorld(){\n  REP(y, 8) {\n    REP(x, 8){\n      cout << field[y][x];\n    }\n    cout << endl;\n  }\n  cout << \"--------------\" << endl;\n}\n\nint main() {\n  auto A = [](P a, P b){\n             return a.score * 1000 - a.y * 10 - a.x < b.score * 1000 - b.y * 10 - b.x;\n           };\n  auto B = [](P a, P b){\n             return a.score * 1000 + a.y * 10 + a.x < b.score * 1000 + b.y * 10 + b.x;\n           };\n\n  REP(y, 8) REP(x, 8){\n    cin >> field[y][x];\n  }\n\n  while(1) {\n    int flag = 0;\n\n    if(select(A, 'o', 'x')) flag |= 1;\n    if(select(B, 'x', 'o')) flag |= 2;\n\n    if(flag == 3) break;\n  }\n\n  printWorld();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s[8];\nchar c[2]={'o','x'};\nint dd[10]={0,1,1,1,0,-1,-1,-1,0,1};\n\nint dfs(int x,int y,int d,bool t,bool f){\n  if(min(x,y)<0||7<max(x,y)||s[y][x]=='.')return -1e9;\n  if(s[y][x]==c[t])return 0;\n  if(f)s[y][x]=c[t];\n  return dfs(x+dd[d],y+dd[d+2],d,t,f)+1;\n}\n\nint cal(bool t,int x,int y,bool f){\n  if(s[y][x]!='.')return 0;\n  int res=0;\n  for(int i=0;i<8;i++)res+=max(0,dfs(x+dd[i],y+dd[i+2],i,t,f));\n  if(f)s[y][x]=c[t];    \n  return res;\n}\n\nvoid solve(bool t,int d){\n  if(d==2)return;\n  int mx=0,x,y;\n  if(t)\n    for(int i=7;i>=0;i--)\n      for(int j=7;j>=0;j--){\n\tint res=cal(t,j,i,0);\n\tif(mx<res)mx=res,x=j,y=i;\n      }\n  else\n    for(int i=0;i<8;i++)\n      for(int j=0;j<8;j++){\n\tint res=cal(t,j,i,0);\n\tif(mx<res)mx=res,x=j,y=i;\n      }\n  if(mx)cal(t,x,y,1),d=0;\n  solve(!t,d+!mx);\n}\n\nint main(){\n  for(int i=0;i<8;i++)cin>>s[i];\n  solve(0,0);\n  for(int i=0;i<8;i++)cout<<s[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nint main(){\n    string field[8];\n    int cost[8][8];\n    for(int i=0; i< 8; i++) cin >> field[i];\n\n    bool pass = false;\n    for(int q=0; ; q++){\n        for(int i=0; i< 8; i++)for(int j=0; j< 8; j++) cost[i][j] = 0;\n        string s = \"ox\";\n\n        int maxReverse = 0;\n        for(int i=0; i< 8; i++){\n            for(int j=0; j< 8; j++){\n                if(field[i][j] == '.'){\n                    int count = 0;\n                    for(int dx = -1; dx <= 1; dx++){\n                        for(int dy = -1; dy <= 1; dy++){\n                            if(dx == 0 && dy == 0) continue;\n                            if(isIn(i+dx, j+dy) && field[i+dx][j+dy] == s[(q+1)%2]){\n                                int c = 0;\n                                for(c=1; isIn(i+dx*c, j+dy*c) && field[i+dx*c][j+dy*c] == s[(q+1)%2]; c++);\n\n                                if(isIn(i+dx*c, j+dy*c) && field[i+dx*c][j+dy*c] != '.') count += c-1;\n                            }\n                        }\n                    }\n                    maxReverse = max(maxReverse, count);\n                    cost[i][j] = count;\n                }\n            }\n        }\n        if(maxReverse == 0 && pass) break;\n        else if(maxReverse != 0) pass = false;\n        else if(maxReverse == 0){pass = true; continue;}\n\n        if(q%2 == 0){\n            for(int i=0; i< 8; i++){\n                for(int j=0; j< 8; j++){\n                    if(cost[i][j] == maxReverse){\n                        field[i][j] = s[q%2];\n                        for(int dx = -1; dx <= 1; dx++){\n                            for(int dy = -1; dy <= 1; dy++){\n                                if(dx == 0 && dy == 0) continue;\n                                if(isIn(i+dx, j+dy) && field[i+dx][j+dy] == s[(q+1)%2]){\n                                    bool is = true;\n                                    int c = 0;\n                                    for(c=1; isIn(i+dx*c, j+dy*c) && field[i+dx*c][j+dy*c] == s[(q+1)%2]; c++);\n                                    if(isIn(i+dx*c, j+dy*c) && field[i+dx*c][j+dy*c] != '.') for(int p=0; p < c; p++) field[i+dx*p][j+dy*p] = s[q%2];\n                                }\n                            }\n                        }\n                        i = 10; j = 10;\n                    }\n                }\n            }\n        }\n        else {\n            for(int i=7; 0 <= i; i--){\n                for(int j=7; 0 <= j; j--){\n                    if(cost[i][j] == maxReverse){\n                        field[i][j] = s[q%2];\n                        for(int dx = -1; dx <= 1; dx++){\n                            for(int dy = -1; dy <= 1; dy++){\n                                if(dx == 0 && dy == 0) continue;\n                                if(isIn(i+dx, j+dy) && field[i+dx][j+dy] == s[(q+1)%2]){\n                                    bool is = true;\n                                    int c = 0;\n                                    for(c=1; isIn(i+dx*c, j+dy*c) && field[i+dx*c][j+dy*c] == s[(q+1)%2]; c++);\n                                    if(isIn(i+dx*c, j+dy*c) && field[i+dx*c][j+dy*c] != '.') for(int p=0; p < c; p++) field[i+dx*p][j+dy*p] = s[q%2];\n                                }\n                            }\n                        }\n                        i = -1; j = -1;\n                    }\n                }\n            }\n        }\n    }\n    for(int i=0; i< 8; i++) cout << field[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\narray<array<int, 10>, 10> v{};\narray<int, 8> dx {-1, -1, -1, 0, 0, 1, 1, 1}, dy{-1, 0, 1, -1, 1, -1, 0, 1};\n\nint turn1(){\n    int res1 = 0, res2 = 0, m = 0;\n    for (int i = 1; i <= 8; ++i) {\n        for (int j = 1; j <= 8; ++j) {\n            if(v[i][j] != 0) continue;\n            int kes = 0;\n            for (int k = 0; k < 8; ++k) {\n                int p = dy[k], q = dx[k];\n                int s = i, t = j;\n                int kess = 0;\n                while(v[s+p][t+q] == 2) kess++, s += p, t += q;\n                if(v[s+p][t+q] == 1) kes += kess;\n            }\n            if(m < kes) res1 = i, res2 = j, m = kes;\n        }\n    }\n    if(m){\n        v[res1][res2] = 1;\n        for (int k = 0; k < 8; ++k) {\n            int p = dy[k], q = dx[k];\n            int s = res1, t = res2;\n            while(v[s+p][t+q] == 2) s += p, t += q;\n            if(v[s+p][t+q] == 1) {\n                s = res1, t = res2;\n                while(v[s+p][t+q] == 2) v[s+p][t+q] = 1, s += p, t += q;\n            }\n        }\n        return 1;\n    }\n    return 0;\n}\n\nint turn2(){\n    int res1 = 0, res2 = 0, m = 0;\n    for (int i = 8; i >= 1; --i) {\n        for (int j = 8; j >= 1; --j) {\n            if(v[i][j] != 0) continue;\n            int kes = 0;\n            for (int k = 0; k < 8; ++k) {\n                int p = dy[k], q = dx[k];\n                int s = i, t = j;\n                int kess = 0;\n                while(v[s+p][t+q] == 1) kess++, s += p, t += q;\n                if(v[s+p][t+q] == 2) kes += kess;\n            }\n            if(m < kes) res1 = i, res2 = j, m = kes;\n        }\n    }\n    if(m){\n        v[res1][res2] = 2;\n        for (int k = 0; k < 8; ++k) {\n            int p = dy[k], q = dx[k];\n            int s = res1, t = res2;\n            while(v[s+p][t+q] == 1) s += p, t += q;\n            if(v[s+p][t+q] == 2) {\n                s = res1, t = res2;\n                while(v[s+p][t+q] == 1) v[s+p][t+q] = 2, s += p, t += q;\n            }\n        }\n        return 1;\n    }\n    return 0;\n}\n\n\nint main() {\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            v[i][j] = -1;\n        }\n    }\n    for (int i = 0; i < 8; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 8; ++j) {\n            if(s[j] == 'o') v[i+1][j+1] = 1;\n            else if(s[j] == 'x') v[i+1][j+1] = 2;\n            else v[i+1][j+1] = 0;\n        }\n    }\n    int turn = 0;\n    while(true){\n        if(!turn) {\n            int res = turn1();\n            if(!res) {\n                res = turn2();\n                turn ^= 1;\n            }\n            if(!res) break;\n        }else {\n            int res = turn2();\n            if(!res) {\n                res = turn1();\n                turn ^= 1;\n            }\n            if(!res) break;\n        }\n        turn ^= 1;\n    }\n    for (int i = 1; i <= 8; ++i) {\n        for (int j = 1; j <= 8; ++j) {\n            if(v[i][j] == 0) printf(\".\");\n            else if(v[i][j] == 1) printf(\"o\");\n            else printf(\"x\");\n        }\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n#define int2(x, y) int x, y; scanf(\"%lld %lld\", &x, &y);\n \nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, 1, -1, -1};\n// assign\n\nvector< string > board(8);\n\nbool f(char a, char b);\nbool g(char a, char b);\nint search(int x, int y, char a, char b);\nvoid turn(int x, int y, char a, char b);\n\nsigned main()\n{\n    rep(i, 8) {\n        cin >> board[i];\n    }\n    while (1) {\n        bool ret1 = f('o', 'x');\n        bool ret2 = g('x', 'o');\n        if (!ret1 && !ret2) {\n            break;\n        }\n    }\n    rep(i, 8) {\n        cout << board[i] << endl;\n    }\n    return 0;\n}\n\nbool f(char a, char b)\n{\n    int getpoint = 0, x = -1, y = -1;\n    rep(i, 8) {\n        rep(j, 8) {\n            int tmp = search(i, j, a, b);\n            if (tmp > getpoint) {\n                getpoint = tmp;\n                x = i; y = j;\n            }\n        }\n    }\n    if (x == -1) {\n        return false;\n    } else {\n        turn(x, y, a, b);\n        return true;\n    }\n}\n\nint search(int x, int y, char a, char b)\n{\n    int ret = 0;\n    if (board[x][y] != '.' ) { return 0;}\n    rep(i, 8) {\n        int px = x, py = y, tmp = 0;\n        while (0 <= px + dx[i] && px + dx[i] < 8 && \n                0 <= py + dy[i] && py + dy[i] < 8 && \n                board[px + dx[i]][py + dy[i]] == b) {\n            tmp++;\n            px += dx[i]; py += dy[i];\n        }\n        if (tmp && 0 <= px + dx[i] && px + dx[i] < 8 && \n                0 <= py + dy[i] && py + dy[i] < 8 && \n                board[px + dx[i]][py + dy[i]] == a) {\n            ret += tmp;\n        }\n    }\n    return ret;\n}\n\nvoid turn(int x, int y, char a, char b)\n{\n    board[x][y] = a;\n    rep(i, 8) {\n        int px = x, py = y;\n        while (0 <= px + dx[i] && px + dx[i] < 8 && \n                0 <= py + dy[i] && py + dy[i] < 8 && \n                board[px + dx[i]][py + dy[i]] == b) {\n            px += dx[i]; py += dy[i];\n        }\n        if (0 <= px + dx[i] && px + dx[i] < 8 && \n                0 <= py + dy[i] && py + dy[i] < 8 && \n                board[px + dx[i]][py + dy[i]] == a) {\n            while (board[px][py] == b) {\n                board[px][py] = a;\n                px -= dx[i]; py -= dy[i];\n            }\n        }\n    }\n}\n\nbool g(char a, char b)\n{\n    int getpoint = 0, x = -1, y = -1;\n    for (int i = 7; i >= 0; i--) {\n        for (int j = 7; j >= 0; j--) {\n            int tmp = search(i, j, a, b);\n            if (tmp > getpoint) {\n                getpoint = tmp;\n                x = i; y = j;\n            }\n        }\n    }\n    if (x == -1) {\n        return false;\n    } else {\n        turn(x, y, a, b);\n        return true;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nchar fi[8][8];\nint h=8,w=8;\n\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,0,-1,1};\n\nint score(int x,int y,char c){\n    int res=0;\n    for(int k=0;k<8;k++){\n        int cnt=0;\n        bool ed=0;\n        int nx=x+dx[k],ny=y+dy[k];\n        while(0<=nx&&nx<h&&0<=ny&&ny<w){\n            if(fi[nx][ny]=='.')break;\n            else if(c!=fi[nx][ny]){\n                cnt++;\n            }\n            else{\n                ed=1;\n                break;\n            }\n            nx+=dx[k];\n            ny+=dy[k];\n        }\n        if(ed){\n            res+=cnt;\n        }\n    }\n    return res;\n}\n\nvoid update(int x,int y){\n    for(int k=0;k<8;k++){\n        int cnt=0;\n        bool ed=0;\n        int nx=x+dx[k],ny=y+dy[k];\n        while(0<=nx&&nx<h&&0<=ny&&ny<w){\n            if(fi[nx][ny]=='.')break;\n            else if(fi[x][y]!=fi[nx][ny]){\n                cnt++;\n            }\n            else{\n                ed=1;\n                break;\n            }\n            nx+=dx[k];\n            ny+=dy[k];\n        }\n        if(ed){\n            for(int i=1;i<=cnt;i++){\n                fi[x+dx[k]*i][y+dy[k]*i]=fi[x][y];\n            }\n        }\n    }\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin >> fi[i][j];\n        }\n    }\n    int stop=0;\n    int turn=0;\n    while(1){\n        int mx=0;\n        int x,y;\n        if(turn==0){\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(fi[i][j]=='.'){\n                        if(mx<score(i,j,'o')){\n                            mx=score(i,j,'o');\n                            x=i,y=j;\n                        }\n                    }\n                }\n            }\n        }\n        else{\n            for(int i=h-1;i>=0;i--){\n                for(int j=w-1;j>=0;j--){\n                    if(fi[i][j]=='.'){\n                        if(mx<score(i,j,'x')){\n                            mx=score(i,j,'x');\n                            x=i,y=j;\n                        }\n                    }\n                }\n            }\n        }\n        if(mx==0){\n            //break;\n            stop++;\n        }\n        else{\n            fi[x][y]=(turn?'x':'o');\n            update(x,y);\n            stop=0;\n        }\n        if(stop>2)break;\n        turn^=1;\n    }\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            printf(\"%c\",fi[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ssize 8\n#define fi first\n#define se second\nusing namespace std;\nusing P = pair<int, int>;\n\nstring s[ssize];\nchar cookie[2] = {'x', 'o'};\nP dummy = {-1, -1};\n\nvoid solve();\nP search(bool turn);\nvoid setc(P now, bool turn);\nint calc(P now, bool turn, P nowd);\nbool ch(P now);\n\nint main() {\n  for(int i = 0; i < ssize; ++i) cin >> s[i];\n  solve();\n  for(int i = 0; i < ssize; ++i) cout << s[i] << endl;\n  return 0;\n}\n\nvoid solve() {\n  int fin = 0;\n  bool turn = 1;\n  while(fin != 2) {\n    P now = search(turn);\n    if(now == dummy)\n      ++fin;\n    else {\n      fin = 0;\n      setc(now, turn);\n    }\n    turn = !turn;\n  }\n}\n\nP search(bool turn) {\n  P ans = dummy;\n  int cnt = 0;\n  for(int i = 0; i < ssize; ++i)\n    for(int j = 0; j < ssize; ++j)\n      if(s[i][j] == '.') {\n        int now = 0;\n        for(int k = -1; k <= 1; ++k)\n          for(int l = -1; l <= 1; ++l)\n            if(k != 0 || l != 0) {\n              now += calc({i, j}, turn, {k, l});\n            }\n        if(turn && now > cnt) {\n          cnt = now;\n          ans = {i, j};\n        }\n        if(!turn && now >= cnt && now != 0) {\n          cnt = now;\n          ans = {i, j};\n        }\n      }\n  return ans;\n}\n\nvoid setc(P now, bool turn) {\n  s[now.fi][now.se] = cookie[turn];\n  for(int i = -1; i <= 1; ++i)\n    for(int j = -1; j <= 1; ++j)\n      if(i != 0 || j != 0) {\n        P nowp = now;\n        int cnt = calc(now, turn, {i, j});\n        for(int k = 0; k < cnt; ++k) {\n          nowp.fi += i;\n          nowp.se += j;\n          s[nowp.fi][nowp.se] = cookie[turn];\n        }\n      }\n}\n\nint calc(P now, bool turn, P nowd) {\n  int cnt = 0;\n  while(ch({now.fi + nowd.fi, now.se + nowd.se})) {\n    now.fi += nowd.fi;\n    now.se += nowd.se;\n    if(s[now.fi][now.se] == cookie[turn])\n      return cnt;\n    else if(s[now.fi][now.se] == cookie[!turn])\n      ++cnt;\n    else\n      break;\n  }\n  return 0;\n}\n\nbool ch(P now) {\n  return now.fi >= 0 && now.fi < ssize && now.se >= 0 &&\n         now.se <= ssize;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\nint l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}\nint s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}\nint p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}else r 0;}\nint o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}\nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){scanf(\"%s\",&t[i][1]);t[i][0]='0';t[i][9]='0';}\n  f[1]=-1;for(n=0;;n=(n+1)%2){f[n]=-1;\n  for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,mark[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,mark[n],0):0;\n    if(f[n]!=0)o(0,0,f[2+n],f[4+n],mark[n],0);\n    if(f[0]==0&&f[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//?????????\n//????£?????????????\n// o:= ?????????x:= ??????\n// {'o', 'x', '.'} = {0, 1, 2}\n//????£??????????????????§10x10??????\n// o:= ?????????????????§?????????\n// x:= ?????????????????§?????????\n\n\nint di[8] = {0, -1, -1, -1, 0, 1, 1, 1};\nint dj[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h;\n\nint ex(int i, int j, int p, int o, vector<vector<int> > osero){ //?????£?????????????????°?????????\n\n    if(osero[i][j] != 2) return 0;\n    int ans = 0;\n    for(int k = 0; k < 8; k++){\n        int ni = i + di[k];\n        int nj = j + dj[k];\n        int temp = 0;\n        while(1){\n            \n            if(osero[ni][nj] == p){\n                ans += temp;\n                break;\n            }else if(osero[ni][nj] == 2){\n                break;\n            }else{\n                temp++;\n            }\n\n            ni += di[k];\n            nj += dj[k];\n        }\n    }\n    return ans;\n}\n\nbool play(int i, int j, int p, int o, vector<vector<int> >& osero){ //??????????????£??°?????????\n    \n    int ni = i + di[h];\n    int nj = j + dj[h];\n\n    //????????????????????????????????§0?????????\n    if(osero[ni][nj] == 2){\n        return false;\n    }\n        \n    //?????????????????????????????????????????§1?????????\n    if(osero[ni][nj] == p){\n        return true;\n    }\n\n    //???????????????????¬??????????\n    if(osero[ni][nj] == o){\n        bool flag = play(ni, nj, p, o, osero);\n        if(flag){ //1?????°??£???????????????????????¢\n            osero[ni][nj] = p;\n            return true;\n        }\n    }\n    \n\n    return false;\n}\n\n\nint main(){\n    \n    //??\\???\n    vector<vector<int> > osero(10, vector<int> (10, 2));\n    for(int i = 1; i <= 8; i++){\n        for(int j = 1; j <= 8; j++){\n            char input; cin >> input;\n            if(input == 'o') osero[i][j] = 0;\n            else if(input == 'x') osero[i][j] = 1;\n        }\n    }\n\n    bool flag = true;\n\n    while(flag){\n\n        flag = false;\n        //??????????????????\n        int MAX = 0;\n        int MAX_i = 0, MAX_j = 0;\n        for(int i = 1; i <= 8; i++){\n            for(int j = 1; j <= 8; j++){\n                int temp = ex(i, j, 0, 1, osero);\n                if(temp > MAX){\n                    MAX = temp;\n                    MAX_i = i;\n                    MAX_j = j;\n                    flag = true;\n                }\n            }\n        }\n\n        if(MAX > 0) for(h = 0; h < 8; h++){\n            play(MAX_i, MAX_j, 0, 1, osero);\n            osero[MAX_i][MAX_j] = 0;\n        }\n\n        //????\\?????????????\n        MAX = 0;\n        for(int i = 8; i >= 1; i--){\n            for(int j = 8; j >= 1; j--){\n                int temp = ex(i, j, 1, 0, osero);\n                if(temp > MAX){\n                    MAX = temp;\n                    MAX_i = i;\n                    MAX_j = j;\n                    flag = true;\n                }\n            }\n        }\n\n\n        if(MAX > 0) for(h = 0; h < 8; h++){\n            play(MAX_i, MAX_j, 1, 0, osero);\n            osero[MAX_i][MAX_j] = 1;\n        }\n\n    }\n\n    //??????\n    for(int i = 1; i <= 8; i++){\n        for(int j = 1; j <= 8; j++){\n            if(osero[i][j] == 0) cout << 'o';\n            if(osero[i][j] == 1) cout << 'x';\n            if(osero[i][j] == 2) cout << '.';\n        }\n        cout << endl;\n    }   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px) - 1, abs(y - py) - 1);\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px || qy != py) {\n\t\t\t\t\tc[qy][qx] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (t % 2 == 1) {\n\t\t\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (p > r && p >= 1) {\n\t\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) {\n\t\t\t\tv = 1; t++; continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tplace(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i];\n    if(i == SZ(s)-1) {\n      cout << endl;\n    } else {\n      cout << \" \";\n    }\n  }\n}\n\nvector<int> dx = {1, 1, 0, -1, -1, -1, 0, 1};\nvector<int> dy = {0, 1, 1, 1, 0, -1, -1, -1};\n\nstruct Game {\n  int h = 8, w = 8;\n  int cnt = 64;\n  int path = 0;\n  bool turnm = true;\n  vector<vector<char>> board;\n  Game(vector<vector<char>> &board) {\n    this->board = board;\n  }\n\n  void mami() {\n    vector<vector<bool>> sel(h, vector<bool>(w, false));\n    int maxrev = -1;\n    int maxx = -1, maxy = -1;\n    vector<bool> maxdir(8, false);\n    REP(i, h) {\n      REP(j, w) {\n        if(board[i][j] != '.') continue;\n        int rev = 0;\n        vector<bool> dir(8, false);\n        REP(k, 8) {\n          int x = i+dx[k], y = j+dy[k];\n          int tmp = 0;\n          while(0 <= x && x < h && 0 <= y && y < w && board[x][y] == 'x') {\n            tmp++;\n            x += dx[k];\n            y += dy[k];\n          }\n          if(0 <= x && x < h && 0 <= y && y < w && board[x][y] == 'o') {\n            rev += tmp;\n            dir[k] = true;\n          }\n        }\n        if(rev > 0 && rev > maxrev) {\n          maxx = i;\n          maxy = j;\n          maxrev = rev;\n          maxdir = dir;\n        }\n      }\n    }\n\n    if(maxrev != -1) {\n      cnt--;\n      path = 0;\n      REP(i, 8) {\n        if(maxdir[i]) {\n          int x = maxx + dx[i], y = maxy + dy[i];\n          while(0 <= x && x < h && 0 <= y && y < w && board[x][y] == 'x') {\n            board[x][y] = 'o';\n            x += dx[i];\n            y += dy[i];\n          }\n        }\n      }\n      board[maxx][maxy] = 'o';\n    } else {\n      path++;\n    }\n\n    // cout << maxx << \":\" << maxy << \":\" << maxrev << endl;\n    // prt();\n\n  }\n\n  void lotte() {\n    vector<vector<bool>> sel(h, vector<bool>(w, false));\n    int maxrev = -1;\n    int maxx = -1, maxy = -1;\n    vector<bool> maxdir(8, false);\n    RREP(i, h-1) {\n      RREP(j, w-1) {\n        if(board[i][j] != '.') continue;\n        // cout << i << \":\" << j << endl;\n        int rev = 0;\n        vector<bool> dir(8, false);\n        REP(k, 8) {\n          int x = i+dx[k], y = j+dy[k];\n          int tmp = 0;\n          while(0 <= x && x < h && 0 <= y && y < w && board[x][y] == 'o') {\n            tmp++;\n            x += dx[k];\n            y += dy[k];\n          }\n          // cout << x << \":\" << y << endl;\n          if(0 <= x && x < h && 0 <= y && y < w && board[x][y] == 'x') {\n            rev += tmp;\n            dir[k] = true;\n          }\n        }\n        if(rev > 0 && rev > maxrev) {\n          maxx = i;\n          maxy = j;\n          maxrev = rev;\n          maxdir = dir;\n        }\n      }\n    }\n\n    if(maxrev != -1) {\n      cnt--;\n      path = 0;\n      REP(i, 8) {\n        if(maxdir[i]) {\n          int x = maxx + dx[i], y = maxy + dy[i];\n          while(0 <= x && x < h && 0 <= y && y < w && board[x][y] == 'o') {\n            board[x][y] = 'x';\n            x += dx[i];\n            y += dy[i];\n          }\n        }\n      }\n      board[maxx][maxy] = 'x';\n    } else {\n      path++;\n    }\n    // cout << maxx << \":\" << maxy << \":\" << maxrev << endl;\n    // prt();\n  }\n\n  void solve() {\n    while(cnt > 0 && path != 2) {\n      // cout << \"A\" << endl;\n      if(turnm) {\n        mami();\n        turnm = false;\n      } else {\n        lotte();\n        turnm = true;\n      }\n    }\n    prt();\n  }\n\n  void prt() {\n    REP(i, h) {\n      REP(j, w) {\n        cout << board[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nint main () {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n\n  vector<vector<char>> v(8, vector<char>(8));\n  REP(i, 8) {\n    REP(j, 8) {\n      cin >> v[i][j];\n    }\n  }\n  Game(v).solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\n//string F[8];\nchar F[8][9];\nbool used[8][8];\nint turn;\n\nbool debug;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  /*\n  rep(i, 8) rep(j, 8){\n    cin >> F[i][j];\n  }\n  //  */\n  rep(i, 8) cin >> F[i];\n  \n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7)\n      DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        \n        if(mx < r) {\n          memcpy(u, used, sizeof u);\n          mx = r;\n          pl = turn&1;\n        }\n        \n      }\n    }\n    if(mx > 0) {\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      \n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  \n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main(){\n  vector<string> S(8);\n  for(int i = 0; i < 8; ++i){\n    cin >> S[i];\n  }\n  bool f = true, g = true, h = true;\n  int player = -1, M, m, x, y, s, t, u, v, pass = 0;\n  char mark, opponent;\n  vector<int> dx, dy;\n  dx = {0,1,-1}; dy = {0,1,-1};\n  while (f&&g&&h&&pass<2){\n    f = false; g = false; h = false;\n    M = 0;\n    s = -1;\n    t = -1;\n    if (player > 0) {\n      mark = 'x';\n      opponent = 'o';\n    }else{\n      mark = 'o';\n      opponent = 'x';\n    }\n    for (int i = 0; i < 8; ++i){\n      for (int j = 0; j < 8; ++j){\n\tif (S[i][j] == 'x') f = true;\n\telse if (S[i][j] == 'o') g = true;\n\telse{//S[i][j] == '.'\n\t  h = true;\n\t  m = 0;\n\t  for (int k = 0; k < 3; ++k){//8??????????????????\n\t    for (int l = 0; l < 3; ++l) {\n\t      if (k || l){\n\t\tx = i; y = j;\n\t\twhile (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == opponent){\n\t\t  x += dx[k];\n\t\t  y += dy[l];\n\t\t}\n\t\tif (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == mark){\n\t\t  m += max(abs(x-i), abs(y-j));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if ((m >= M && player > 0)||(m > M && player < 0)) {\n\t    s = i;\n\t    t = j;\n\t    M = m;\n\t  }\n\t}\n      }\n    }\n    if (M > 0){//??????????????????????????´?????¶????????´??°\n      S[s][t] = mark;\n      pass = 0;\n      for (int k = 0; k < 3; ++k){//8??????????????????\n\tfor (int l = 0; l < 3; ++l) {\n\t  if (k || l){\n\t    x = s; y = t;\n\t    while (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == opponent){\n\t      x += dx[k];\n\t      y += dy[l];\n\t    }\n\t    if (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == mark){\n\t      while (x != s || y != t) {\n\t\tS[x][y] = mark;\n\t\tx -= dx[k];\n\t\ty -= dy[l];\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }else ++pass;\n    player *= -1;\n    //    for (int i = 0; i < 8; ++i) cout << S[i] << endl;\n  }\n  for (int i = 0; i < 8; ++i) cout << S[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nstring s;\nchar a[10][10];\n\nint check(int now,int y,int x){\n  int res=0;\n  if(now==0){\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        if(i==1 && j==1)continue;\n        int cont=0;\n        bool flag=0;\n        for(int k=1;k<8;k++){\n          if(y+k*dy[i]<0 || y+k*dy[i]>=8)break;\n          if(x+k*dx[j]<0 || x+k*dx[j]>=8)break;\n          if(a[y+k*dy[i]][x+k*dx[j]]=='o'){\n            flag=1;\n            break;\n          }else if(a[y+k*dy[i]][x+k*dx[j]]=='.'){\n            flag=0;\n            break;\n          }else{\n            cont++;\n          }\n        }\n        if(flag)res+=cont;\n      }\n    }\n  }else{\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        if(i==1 && j==1)continue;\n        int cont=0;\n        bool flag=0;\n        for(int k=1;k<8;k++){\n          if(y+k*dy[i]<0 || y+k*dy[i]>=8)break;\n          if(x+k*dx[j]<0 || x+k*dx[j]>=8)break;\n          if(a[y+k*dy[i]][x+k*dx[j]]=='x'){\n            flag=1;\n            break;\n          }else if(a[y+k*dy[i]][x+k*dx[j]]=='.'){\n            flag=0;\n            break;\n          }else{\n            cont++;\n          }\n        }\n        if(flag)res+=cont;\n      }\n    }\n  }\n  return res;\n}\n\nvoid check2(int now,int y,int x){\n  if(now==0){\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        if(i==1 && j==1)continue;\n        bool flag=0;\n        for(int k=1;k<8;k++){\n          if(y+k*dy[i]<0 || y+k*dy[i]>=8)break;\n          if(x+k*dx[j]<0 || x+k*dx[j]>=8)break;\n          if(a[y+k*dy[i]][x+k*dx[j]]=='o'){\n            flag=1;\n            break;\n          }else if(a[y+k*dy[i]][x+k*dx[j]]=='.'){\n            flag=0;\n            break;\n          }\n        }\n        if(flag){\n          for(int k=1;k<8;k++){\n            if(y+k*dy[i]<0 || y+k*dy[i]>=8)break;\n            if(x+k*dx[j]<0 || x+k*dx[j]>=8)break;\n            if(a[y+k*dy[i]][x+k*dx[j]]=='o')break;\n            else if(a[y+k*dy[i]][x+k*dx[j]]=='.')break;\n            else a[y+k*dy[i]][x+k*dx[j]]='o';\n          }\n        }\n      }\n    }\n  }else{\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        if(i==1 && j==1)continue;\n        if(y+dy[i]<0 || y+dy[i]>=8)continue;\n        if(x+dx[j]<0 || x+dx[j]>=8)continue;\n        bool flag=0;\n        for(int k=1;k<8;k++){\n          if(y+k*dy[i]<0 || y+k*dy[i]>=8)break;\n          if(x+k*dx[j]<0 || x+k*dx[j]>=8)break;\n          if(a[y+k*dy[i]][x+k*dx[j]]=='x'){\n            flag=1;\n            break;\n          }else if(a[y+k*dy[i]][x+k*dx[j]]=='.'){\n            flag=0;\n            break;\n          }\n        }\n        if(flag){\n          for(int k=1;k<8;k++){\n            if(y+k*dy[i]<0 || y+k*dy[i]>=8)break;\n            if(x+k*dx[j]<0 || x+k*dx[j]>=8)break;\n            if(a[y+k*dy[i]][x+k*dx[j]]=='x')break;\n            else if(a[y+k*dy[i]][x+k*dx[j]]=='.')break;\n            else a[y+k*dy[i]][x+k*dx[j]]='x';\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid solve(int now,int stop){\n  if(stop==2)return;\n  if(now==0){\n    int maxi=-1,maxj=-1;\n    int nowmax=0;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n        if(a[i][j]!='.')continue;\n        int tmp=check(0,i,j);\n        if(tmp>nowmax){\n          nowmax=tmp;\n          maxi=i;\n          maxj=j;\n        }\n      }\n    }\n    if(nowmax==0){\n      solve(1,stop+1);\n    }else{\n      a[maxi][maxj]='o';\n      check2(0,maxi,maxj);\n      solve(1,0);\n    }\n  }else{\n    int maxi=-1,maxj=-1;\n    int nowmax=0;\n    for(int i=7;i>=0;i--){\n      for(int j=7;j>=0;j--){\n        if(a[i][j]!='.')continue;\n        int tmp=check(1,i,j);\n        if(tmp>nowmax){\n          nowmax=tmp;\n          maxi=i;\n          maxj=j;\n        }\n      }\n    }\n    if(nowmax==0){\n      solve(0,stop+1);\n    }else{\n      a[maxi][maxj]='x';\n      check2(1,maxi,maxj);\n      solve(0,0);\n    }\n  }\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cin>>a[i][j];\n    }\n  }\n  solve(0,0);\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<a[i][j];\n    }\n    cout<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    vector<string> s(8);\n    REP(i, 8) cin >> s[i];\n\n    const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1};\n    const int dx[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n    int pass = 0;\n    for (int t = 0;; ++t) {\n        if (pass == 2) break;\n        char myStone = t & 1 ? 'x' : 'o';\n        char opStone = t & 1 ? 'o' : 'x';\n\n        int ma = 0;\n        int pi = -1, pj = -1;\n        REP(i, 8) {\n            REP(j, 8) {\n                if (s[i][j] != '.') continue;\n                int cnt = 0;\n                REP(k, 8) {\n                    int y = i + dy[k], x = j + dx[k];\n                    if (y < 0 or x < 0 or 8 <= y or 8 <= x or s[y][x] != opStone) continue;\n                    int tmp = 0;\n                    while (0 <= y and 0 <= x and y < 8 and x < 8 and s[y][x] == opStone) {\n                        ++tmp;\n                        y += dy[k], x += dx[k];\n                    }\n                    if (0 <= y and 0 <= x and y < 8 and x < 8 and s[y][x] == myStone) cnt += tmp;\n                }\n                if (chmax(ma, cnt)) {\n                    pi = i, pj = j;\n                } else if (ma == cnt) {\n                    if (t & 1) {\n                        if (i > pi or i == pi and j > pj) {\n                            pi = i, pj = j;\n                        }\n                    } else {\n                        if (i < pi or i == pi and j < pj) {\n                            pi = i, pj = j;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (ma == 0) {\n            ++pass; continue;\n        } else {\n            pass = 0;\n        }\n\n        s[pi][pj] = myStone;\n        REP(k, 8) {\n            int y = pi + dy[k], x = pj + dx[k];\n            if (y < 0 or x < 0 or 8 <= y or 8 <= x or s[y][x] != opStone) continue;\n            while (0 <= y and 0 <= x and y < 8 and x < 8 and s[y][x] == opStone) {\n                y += dy[k], x += dx[k];\n            }\n            if (y < 0 or x < 0 or 8 <= y or 8 <= x or s[y][x] != myStone) continue;\n\n            y = pi + dy[k], x = pj + dx[k];\n            while (0 <= y and 0 <= x and y < 8 and x < 8 and s[y][x] == opStone) {\n                s[y][x] = myStone;\n                y += dy[k], x += dx[k];\n            }\n        }\n    }\n\n    REP(i, 8) cout << s[i] << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nchar fie[9][9];\nconst char *dat=\"ox\";\nint dx[8]={0,1,0,-1,1,1,-1,-1};\nint dy[8]={1,0,-1,0,1,-1,1,-1};\n\nint check(int x,int y,int t){\n\tint cnt=0;\n\tfor(int i=0;i<8;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tint cc=0;\n\t\twhile(nx>=0 && nx<8 && ny>=0 && ny<8){\n\t\t\tif(fie[nx][ny]=='.')break;\n\t\t\tif(fie[nx][ny]==dat[t]){\n\t\t\t\tcnt+=cc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(fie[nx][ny]==dat[1-t]){\n\t\t\t\tcc++;\n\t\t\t}\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid flip(int x,int y,int t){\n\tfie[x][y]=dat[t];\n\tfor(int i=0;i<8;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\twhile(nx>=0 && nx<8 && ny>=0 && ny<8){\n\t\t\tif(fie[nx][ny]=='.')break;\n\t\t\tif(fie[nx][ny]==dat[t]){\n\t\t\t\tfor(int j=x+dx[i],k=y+dy[i];j!=nx || k!=ny;j+=dx[i],k+=dy[i]){\n\t\t\t\t\tfie[j][k]=dat[t];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t}\n}\n\nint main(void){\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tscanf(\"%c\",&fie[j][i]);\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tint turn=0,pass=0;\n\twhile(pass<2){\n\t\tint nx=-1,ny=-1;\n\t\tint nc=0;\n\t\tif(turn==0){\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(fie[j][i]=='.'){\n\t\t\t\t\t\tint cc=check(j,i,turn);\n\t\t\t\t\t\tif(cc>nc){\n\t\t\t\t\t\t\tnx=j;\n\t\t\t\t\t\t\tny=i;\n\t\t\t\t\t\t\tnc=cc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=7;i>=0;i--){\n\t\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\t\tif(fie[j][i]=='.'){\n\t\t\t\t\t\tint cc=check(j,i,turn);\n\t\t\t\t\t\tif(cc>nc){\n\t\t\t\t\t\t\tnx=j;\n\t\t\t\t\t\t\tny=i;\n\t\t\t\t\t\t\tnc=cc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nc==0){\n\t\t\tpass++;\n\t\t}else{\n\t\t\tflip(nx,ny,turn);\n\t\t\tpass=0;\n\t\t}\n\t\tturn=1-turn;\n\t}\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tprintf(\"%c\",fie[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nconst char B = 'o';\nconst char W = 'x';\nconst char S = '.';\nchar board[8][8];\n\nint reversible(char player, int y, int x) {\n\tif (board[y][x] != S)return 0;\n\tint ret = 0;\n\tfor (int dy = -1; dy <= 1; dy++)\n\t\tfor (int dx = -1; dx <= 1; dx++)\n\t\t\tif (!(dy == 0 && dx == 0)) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tint yy = y + dy, xx = x + dx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(0 <= yy && yy < 8 && 0 <= xx && xx < 8))break;\n\t\t\t\t\tchar c = board[yy][xx];\n\t\t\t\t\tif (c == S) break;\n\t\t\t\t\tif (c == player) {\n\t\t\t\t\t\tret += cnt;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tyy += dy; xx += dx;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\treturn ret;\n}\n\nvoid reverse(char player, int y, int x, int dy, int dx) {\n\tint yy = y + dy, xx = x + dx;\n\twhile (true) {\n\t\tif (!(0 <= yy && yy < 8 && 0 <= xx && xx < 8)) return;\n\t\tchar c = board[yy][xx];\n\t\tif (c == S) return;\n\t\tif (c == player) break;\n\t\tyy += dy; xx += dx;\n\t}\n\twhile (true) {\n\t\tyy -= dy; xx -= dx;\n\t\tif (yy == y && xx == x) break;\n\t\tboard[yy][xx] = player;\n\t}\n}\n\nvoid reverse(char player, int y, int x) {\n\tassert(reversible(player, y, x));\n\tboard[y][x] = player;\n\tfor (int dy = -1; dy <= 1; dy++)\n\t\tfor (int dx = -1; dx <= 1; dx++)\n\t\t\tif (!(dy == 0 && dx == 0))\n\t\t\t\treverse(player, y, x, dy, dx);\n}\n\npair<int, int> status() {\n\tint cntB = 0, cntW = 0;\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tchar c = board[y][x];\n\t\t\tif (c == B) cntB++;\n\t\t\tif (c == W) cntW++;\n\t\t}\n\t}\n\treturn make_pair(cntB, cntW);\n}\n\nsigned main() {\n\tfor (int y = 0; y < 8; y++)\n\t\tfor (int x = 0; x < 8; x++)\n\t\t\tcin >> board[y][x];\n\tint maxcnt = 0;\n\twhile (true) {\n\t\tpair<int, int> s = status();\n\t\tif (s.first == 0 || s.second == 0 || s.first + s.second == 8 * 8)break;\n\t\tint Bx, By;\tmaxcnt = 0;\n\t\trep(y, 0, 8)rep(x, 0, 8)\n\t\t\tif (chmax(maxcnt, reversible(B, y, x)))\n\t\t\t\tBx = x, By = y;\n\t\tif (maxcnt)reverse(B, By, Bx);\n\t\tint Wx, Wy; maxcnt = 0;\n\t\trrep(y, 0, 8)rrep(x, 0, 8)\n\t\t\tif (chmax(maxcnt, reversible(W, y, x)))\n\t\t\t\tWx = x, Wy = y;\n\t\tif (maxcnt)reverse(W, Wy, Wx);\n\t}\n\trep(i, 0, 8) {\n\t\trep(j, 0, 8) {\n\t\t\tcout << board[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\n/*}}}*/\nvector<string> s(8);\n\nvoid check(){\n    cout << \"check\" << endl;\n    rep(i,8) cout << s[i] << endl;\n}\n\n// turn = 0 then me = o\nint count(int x,int y,char me){\n    int ret = 0;\n    for(int dx=-1;dx<2;dx++) for(int dy=-1;dy<2;dy++){\n        if(dx==0 and dy==0) continue;\n\n        //cout << dx << \" \" << dy << endl;\n        for(int i=1;i<8;i++){\n            int nx = x + dx*i;\n            int ny = y + dy*i;\n            //cout << \"next : \" << nx << \" \" << ny << endl;\n            if(nx<0 or ny<0 or nx>=8 or ny>=8) break;\n            if(s[nx][ny]=='.') break;\n            if(s[nx][ny]==me){\n                //cout << \"hit : \" << nx << \" \" << ny << \" \" << i-1 << endl;\n                ret += i-1;\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nbool f(int turn){\n    //check();\n    int cnt = 0;\n    int cx,cy;\n    if(turn==0){    // mami\n        rep(i,8) rep(j,8) if(s[i][j]=='.'){\n            int t = count(i,j,'o');\n            if(cnt < t){\n                cnt = t;\n                cx=i;\n                cy=j;\n            }\n        }\n        if(cnt==0) return false;\n        int x = cx;\n        int y = cy;\n        for(int dx=-1;dx<2;dx++) for(int dy=-1;dy<2;dy++){\n            if(dx==0 and dy==0) continue;\n\n            for(int i=1;i<8;i++){\n                int nx = x + dx*i;\n                int ny = y + dy*i;\n                if(nx<0 or ny<0 or nx>=8 or ny>=8) break;\n                if(s[nx][ny]=='.') break;\n                if(s[nx][ny]=='o'){\n                    for(int j=1;j<i;j++){\n                        s[x+dx*j][y+dy*j]='o';\n                    }\n                    break;\n                }\n            }\n        }\n        s[cx][cy] = 'o';\n    }else{\n        rep(i,8) rep(j,8) if(s[i][j]=='.'){\n            int t = count(i,j,'x');\n            if(cnt <= t){\n                cnt = t;\n                cx=i;\n                cy=j;\n            }\n        }\n        if(cnt==0) return false;\n        int x = cx;\n        int y = cy;\n        for(int dx=-1;dx<2;dx++) for(int dy=-1;dy<2;dy++){\n            if(dx==0 and dy==0) continue;\n\n            for(int i=1;i<8;i++){\n                int nx = x + dx*i;\n                int ny = y + dy*i;\n                if(nx<0 or ny<0 or nx>=8 or ny>=8) break;\n                if(s[nx][ny]=='.') break;\n                if(s[nx][ny]=='x'){\n                    for(int j=1;j<i;j++){\n                        s[x+dx*j][y+dy*j]='x';\n                    }\n                    break;\n                }\n            }\n        }\n        s[cx][cy]='x';\n    }\n    return true;\n}\n\n\nint main(){\n    rep(i,8) cin >> s[i];\n    int turn = 0;   // 0 :mami , 1:majo\n    while(1){\n        //check();\n        auto t = s;\n        //bool y = f(turn);\n        //if(!y) break;\n        f(0);\n        f(1);\n        turn++;\n        turn%=2;\n        if(t==s) break;\n    }\n\n    //s[0] = \"....o...\";\n    //s[1] = \"....o...\";\n    //s[2] = \"....o...\";\n    //s[3] = \"...oo...\";\n    //s[4] = \"...oxxxx\";\n    //s[5] = \"..o.....\";\n    //s[6] = \".o......\";\n    //s[7] = \"o.......\";\n\n    //int p = count(4,2,'x');\n    //cout << p << endl;\n    //cout << \"answer: \" << endl;\n    rep(i,8) cout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,n,m) for(ll i=n; i>(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nll di[8]={1,1,0,-1,-1,-1,0,1};\nll dj[8]={0,-1,-1,-1,0,1,1,1};\n\nll nx(vector<string> v, ll li, ll lj, ll turn){\n  char c;\n  if(turn%2==0) c='x';\n  else c='o';\n\n  ll res=0;\n  FOR(d,0,8){\n    ll x=1;\n\n    if(li+x*di[d]<0 || 7<li+x*di[d] || lj+x*dj[d]<0 || 7<lj+x*dj[d]  )continue;\n    while(v[li+x*di[d]][lj+x*dj[d]]==c){\n      x++;\n\n      if(li+x*di[d]<0 || 7<li+x*di[d] || lj+x*dj[d]<0 || 7<lj+x*dj[d]  )break;\n    }\n\n    if(li+x*di[d]<0 || 7<li+x*di[d] || lj+x*dj[d]<0 || 7<lj+x*dj[d]  )continue;\n\n    if(v[li+x*di[d]][lj+x*dj[d]]!='.'&&v[li+x*di[d]][lj+x*dj[d]]!=c){\n      res+=x-1;\n    }\n  }\n  return res;\n}\n\n\nvector<string> nch(vector<string> v, ll li, ll lj, ll turn){\n  char c;\n  if(turn%2==0) c='o';\n  else c='x';\n  v[li][lj]=c;\n  FOR(d,0,8){\n    ll x=1;\n    if(li+x*di[d]<0 || 7<li+x*di[d] || lj+x*dj[d]<0 || 7<lj+x*dj[d]  )continue;\n\n    while(v[li+x*di[d]][lj+x*dj[d]]!=c&&v[li+x*di[d]][lj+x*dj[d]]!='.'){\n      x++;\n      if(li+x*di[d]<0 || 7<li+x*di[d] || lj+x*dj[d]<0 || 7<lj+x*dj[d]  ){\n        x=0;\n        break;\n      }\n      if(v[li+x*di[d]][lj+x*dj[d]]==c){\n        break;\n      }\n      if(v[li+x*di[d]][lj+x*dj[d]]=='.'){\n        x=1;\n        break;\n      }\n    }\n    FOR(j,0,x){\n      v[li+j*di[d]][lj+j*dj[d]]=c;\n    }\n\n  }\n    return v;\n\n}\n\nP toPut(vector<string> v, ll turn){\n  ll li=0,lj=0,mres=0;\n  FOR(i,0,8){\n    FOR(j,0,8){\n      if(v[i][j]=='.'){\n        if(mres<nx(v,i,j,turn)&&turn%2==0){\n          li=i;lj=j;\n          mres=nx(v,i,j,turn);\n        }\n        if(mres<=nx(v,i,j,turn)&&turn%2==1){\n          li=i;lj=j;\n          mres=nx(v,i,j,turn);\n        }\n\n      }\n    }\n  }\n  return P(li,lj);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<string> v(8);\n  cinv(v,0,8);\n  FOR(i,0,150){\n    P p = toPut(v,i);\n    ll li=p.first;\n    ll lj=p.second;\n    if(nx(v,li,lj,i)!=0 && v[li][lj]=='.')v=nch(v,li,lj,i);\n  }\n\n  FOR(i,0,8){\n    FOR(j,0,8){\n      cout<<v[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#ifdef __GNUC__\n#include <bits/stdc++.h>\n#else\n#define _CRT_SECURE_NO_WARNINGS\n#include <__msvc_all_public_headers.hpp>\n#undef min\n#undef max\n#endif\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nstruct Point {\n\tstatic int H, W;\n\tstatic const vector<Point> d;\n\tstatic void set_range(int _H, int _W) { H = _H; W = _W; }\n\tstatic constexpr Point zero() { return { 0,0 }; }\n\tstatic constexpr Point one() { return { 1,1 }; }\n\tint x, y;\n\tconstexpr Point() :x(0), y(0) {}\n\tconstexpr Point(int _x, int _y) : x(_x), y(_y) {}\n\tconstexpr Point(const pair<int, int>& xy) : x(xy.first), y(xy.second) {}\n\tPoint(int n) :x(n% W), y(n / W) {}\n\tconstexpr Point operator+()const { return *this; }\n\tconstexpr Point operator-()const { return { -x,-y }; }\n\tconstexpr Point operator+(const Point& p)const { return Point(*this) += p; }\n\tconstexpr Point operator-(const Point& p)const { return Point(*this) -= p; }\n\tconstexpr Point operator*(const Point& p)const { return Point(*this) *= p; }\n\tconstexpr Point operator/(const Point& p)const { return Point(*this) /= p; }\n\tconstexpr Point operator+(int n)const { return Point(*this) += Point(n, n); }\n\tconstexpr Point operator-(int n)const { return Point(*this) -= Point(n, n); }\n\tconstexpr Point operator*(int n)const { return Point(*this) *= Point(n, n); }\n\tconstexpr Point operator/(int n)const { return Point(*this) /= Point(n, n); }\n\tconstexpr Point& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tconstexpr Point& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tconstexpr Point& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tconstexpr Point& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tconstexpr Point& operator+=(int n) { x += n; x += n; return *this; }\n\tconstexpr Point& operator-=(int n) { x -= n; x -= n; return *this; }\n\tconstexpr Point& operator*=(int n) { x *= n; x *= n; return *this; }\n\tconstexpr Point& operator/=(int n) { x /= n; x /= n; return *this; }\n\tconstexpr bool operator==(const Point& p)const { return x == p.x && y == p.y; }\n\tconstexpr bool operator!=(const Point& p)const { return x != p.x || y != p.y; }\n\tbool operator<(const Point& p)const { return to_i() < p.to_i(); }\n\tbool operator<=(const Point& p)const { return to_i() <= p.to_i(); }\n\tbool operator>(const Point& p)const { return to_i() > p.to_i(); }\n\tbool operator>=(const Point& p)const { return to_i() >= p.to_i(); }\n\tPoint& operator++() { if (x != W - 1) { ++x; } else { x = 0; ++y; } return *this; }\n\tPoint& operator--() { if (x != 0) { --x; } else { x = W - 1; --y; } return *this; }\n\tPoint operator++(int) { Point t(*this); ++* this; return t; }\n\tPoint operator--(int) { Point t(*this); --* this; return t; }\n\tconstexpr int operator[](int i)const { return i == 0 ? x : i == 1 ? y : 0; }\n\tbool in_range()const { return 0 <= x && x < W && 0 <= y && y < H; }\n\tint to_i()const { return x + y * W; }\n\tconstexpr pair<int, int> to_pair()const { return { x,y }; }\n\tint dist(const Point& p)const { return std::abs(x - p.x) + std::abs(y - p.y); }\n\tPoint abs(const Point& p)const { return { std::abs(x - p.x),std::abs(y - p.y) }; }\n\tPoint& swap() { std::swap(x, y); return *this; }\n\tvector<Point> adjacent4()const {\n\t\tvector<Point> v(4); for (int i = 0; i < 4; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent8()const {\n\t\tvector<Point> v(8); for (int i = 0; i < 8; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent6()const {\n\t\tvector<Point> v(6); for (int i = 0; i < 6; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adj4_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent4())if (P.in_range())v.push_back(P); return v;\n\t}\n\tvector<Point> adj8_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent8())if (P.in_range())v.push_back(P); return v;\n\t}\n\tconstexpr Point left()const { return { x - 1,y }; }\n\tconstexpr Point right()const { return { x + 1,y }; }\n\tconstexpr Point up()const { return { x,y - 1 }; }\n\tconstexpr Point down()const { return { x,y + 1 }; }\n\tconstexpr Point moved(char c)const { return Point(*this).move(c); }\n\tconstexpr Point& move(char c) {\n\t\tswitch (c) {\n\t\tcase 'L':case 'l':case'>':x--; break;\n\t\tcase 'R':case 'r':case'<':x++; break;\n\t\tcase 'U':case 'u':case'^':y--; break;\n\t\tcase 'D':case 'd':case'v':y++; break;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr Point rotate90() { return { y,-x }; }\n\tconstexpr Point rotate180() { return { -x,-y }; }\n\tconstexpr Point rotate270() { return { -y,x }; }\n};\nint Point::H, Point::W;\nconst vector<Point> Point::d{ {0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1},{1,-1},{-1,1} };\ninline ostream& operator<<(ostream& os, const Point& p) { return  os << '(' << p.x << \", \" << p.y << ')'; }\ninline istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n\nstring Straight(Point p, const Point& d, const VS& s) {\n\tstring res;\n\tfor (p += d; p.in_range(); p += d) {\n\t\tres.push_back(s[p.y][p.x]);\n\t}\n\treturn res;\n}\n\n\nconst int n = 8;\n\nint cnt(const VS& s, Point p, char me) {\n\tif (s[p.y][p.x] != '.')return 0;\n\n\tchar opp = me == 'o' ? 'x' : 'o';\n\tint res = 0;\n\tfor (Point d : Point::d) {\n\t\tstring str = Straight(p, d, s);\n\t\tsize_t pos = str.find(me);\n\t\tif (pos == string::npos)continue;\n\n\t\tint cnt_opp = count(range_it(str, 0, pos), opp);\n\t\tif (cnt_opp == pos)res += cnt_opp;\n\t}\n\treturn res;\n}\nvoid put_cookie(VS& s, Point p, char me) {\n\tif (s[p.y][p.x] != '.')return;\n\n\tchar opp = me == 'o' ? 'x' : 'o';\n\ts[p.y][p.x] = me;\n\tfor (Point d : Point::d) {\n\t\tstring str = Straight(p, d, s);\n\t\tsize_t pos = str.find(me);\n\t\tif (pos == string::npos)continue;\n\n\t\tint cnt_opp = count(range_it(str, 0, pos), opp);\n\t\tif (cnt_opp == pos) {\n\t\t\tfor (Point p2 = p + d; s[p2.y][p2.x] == opp; p2 += d) {\n\t\t\t\ts[p2.y][p2.x] = me;\n\t\t\t}\n\t\t}\n\t}\n}\n\nPoint find_o(const VS& s) {\n\tPoint res(-1, -1); int ma = 0;\n\trep(i, n * n) {\n\t\tPoint p(i);\n\t\tint result = cnt(s, p, 'o');\n\t\tif (chmax(ma, result)) {\n\t\t\tres = p;\n\t\t}\n\t}\n\treturn res;\n}\nPoint find_x(const VS& s) {\n\tPoint res(-1, -1); int ma = 0;\n\trrep(i, n * n) {\n\t\tPoint p(i);\n\t\tint result = cnt(s, p, 'x');\n\t\tif (chmax(ma, result)) {\n\t\t\tres = p;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tVS s = in[n];\n\tPoint::set_range(n, n);\n\n\tconst Point nil(-1, -1);\n\trep(_, inf) {\n\t\tPoint O = find_o(s);\n\t\tif (O != nil) {\n\t\t\tput_cookie(s, O, 'o');\n\t\t}\n\t\tPoint X = find_x(s);\n\t\tif (X != nil) {\n\t\t\tput_cookie(s, X, 'x');\n\t\t}\n\t\tif (O == nil && X == nil)break;\n\t}\n\tout.set(end_line)(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<string> s(8);\nint dh[8] = { -1,-1,0,1,1,1,0,-1 };\nint dw[8] = { 0,1,1,1,0,-1,-1,-1 };\nll change_cnt(ll sh, ll sw, ll turn) {\n\tchar me = 'o';\n\tchar you = 'x';\n\tif (turn == 1) me = 'x', you = 'o';\n\tll cnt[8] = {};\n\tll res = 0;\n\tfor (ll i = 0; i < 8; i++) {\n\t\tll tmp = 0;\n\t\tll h = sh + dh[i];\n\t\tll w = sw + dw[i];\n\t\twhile (h < 8 && w < 8 && h >= 0 && w >= 0) {\n\t\t\tif (s[h][w] == you) tmp++;\n\t\t\telse if (s[h][w] == me) {\n\t\t\t\tcnt[i] = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse break;\n\t\t\th += dh[i];\n\t\t\tw += dw[i];\n\t\t}\n\t\tres += cnt[i];\n\t}\n\treturn res;\n}\n\nvoid change(ll sh, ll sw, ll turn) {\n\tchar me = 'o';\n\tchar you = 'x';\n\tif (turn == 1) me = 'x', you = 'o';\n\tll cnt[8] = {};\n\tll res = 0;\n\tfor (ll i = 0; i < 8; i++) {\n\t\tll tmp = 0;\n\t\tll h = sh + dh[i];\n\t\tll w = sw + dw[i];\n\t\twhile (h < 8 && w < 8 && h >= 0 && w >= 0) {\n\t\t\tif (s[h][w] == you) tmp++;\n\t\t\telse if (s[h][w] == me) {\n\t\t\t\tcnt[i] = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th += dh[i];\n\t\t\tw += dw[i];\n\t\t}\n\t\tif (cnt[i] > 0) {\n\t\t\t//cout << sh << \" \" << sw << endl;\n\t\t\ts[sh][sw] = me;\n\t\t\tll h = sh + dh[i];\n\t\t\tll w = sw + dw[i];\n\t\t\twhile (h < 8 && w < 8 && h >= 0 && w >= 0) {\n\t\t\t\tif (s[h][w] == you) s[h][w] = me;\n\t\t\t\telse break;\n\t\t\t\th += dh[i];\n\t\t\t\tw += dw[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tfor (ll i = 0; i < 8; i++) cin >> s[i];\n\tint turn = 0;\n\tint zero = 0;\n\twhile (zero < 2) {\n\t\tll mx = 0;\n\t\tif (turn == 0) {\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\t//cout << i << \" \" << j << \" \"<< change_cnt(i,j,turn) << endl;\n\t\t\t\t\t\tchmax(mx, change_cnt(i, j, turn));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mx == 0) {\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tzero = 0;\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (ll i = 0; i < 8; i++) {\n\t\t\t\t\tfor (ll j = 0; j < 8; j++) {\n\t\t\t\t\t\tif (s[i][j] == '.' && mx == change_cnt(i, j, turn)) {\n\n\t\t\t\t\t\t\tchange(i, j, turn);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t//cout << mx << endl;\n\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\tfor (int j = 7; j >= 0; j--) {\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\tchmax(mx, change_cnt(i, j, turn));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mx == 0) {\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tzero = 0;\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (ll i = 7; i >= 0; i--) {\n\t\t\t\t\tfor (ll j = 7; j >= 0; j--) {\n\t\t\t\t\t\tif (s[i][j] == '.' && mx == change_cnt(i, j, turn)) {\n\t\t\t\t\t\t\tchange(i, j, turn);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for (ll i = 0; i < 8; i++) cout << s[i] << \"\\n\";\n\t\tturn = (turn + 1) % 2;\n\t}\n\tfor (ll i = 0; i < 8; i++) cout << s[i] << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define SIZE 8\n#define UNABLE -100\nusing namespace std;\n\nstring table[SIZE];\n\nint p[8] = {1, 0, -1, 0, 1, 1, -1, -1}, q[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nstring s = \"ox\";\n\nvoid dfs_revise(int x, int y, int k, string c) {\n  if (x < 0) return;\n  if (x >= SIZE) return;\n  if (y < 0) return;\n  if (y >= SIZE) return;\n  if (table[y][x] == '.') return;\n  if (table[y][x] == c[0]) return;\n  \n  table[y].replace(x, 1, c);\n  \n  dfs_revise(x + p[k], y + q[k], k, c);\n}\n\nint dfs(int x, int y, int k, string c) {\n  if (x < 0) return UNABLE;\n  if (x >= SIZE) return UNABLE;\n  if (y < 0) return UNABLE;\n  if (y >= SIZE) return UNABLE;\n  if (table[y][x] == '.') return UNABLE;\n  \n  if (c[0] == table[y][x]) return 0;\n  return dfs(x + p[k], y + q[k], k, c) + 1;\n}\n\nvoid game() {\n  int flag = 0;\n  int max, maxx, maxy;\n  int pass = 0;\n  string c;\n  for ( ; ; ) {\n    max = 0;\n    c.erase();\n    if (flag == 0) c.push_back(s[0]);\n    else c.push_back(s[1]);\n    for (int i = 0; i < SIZE; i++) {\n      for (int j = 0; j < SIZE; j++) {\n\tif (table[i][j] != '.') continue;\n\tint temp = 0;\n\tfor (int k = 0; k < 8; k++) {\n\t  int x = j + p[k];\n\t  int y = i + q[k];\n\t  if (x < 0 || y < 0 || x >= SIZE || y >= SIZE) continue;\n\t  if (table[y][x] == '.') continue;\n\t  int s = dfs(x, y, k, c);\n\t  if (s >= 0) temp += s;\n\t}\n\t\n\tif (temp == 0) continue;\n\tif (flag == 0 && temp > max) {\n\t  max = temp;\n\t  maxx = j;\n\t  maxy = i;\n\t} else if (flag == 1 && temp >= max) {\n\t  max = temp;\n\t  maxx = j;\n\t  maxy = i;\n\t}\n      }\n    }\n    if (max == 0) {\n      pass++;\n    } else {\n      //cout << max << ' ' << maxx << ' ' << maxy << endl;\n      pass = 0;\n      table[maxy].replace(maxx, 1, c);\n      for (int k = 0; k < 8; k++) {\n\tif (dfs(maxx + p[k], maxy + q[k], k, c) > 0) {\n\t  dfs_revise(maxx + p[k], maxy + q[k], k, c);\n\t}\n      }\n    }\n    if (pass == 2) break;\n    if (flag == 0) flag = 1;\n    else flag = 0;\n  }\n}\n\nint main() {\n  for (int i = 0; i < SIZE; i++) {\n    cin >> table[i];\n  }\n\n  game();\n\n  for (int i = 0; i < SIZE; i++) {\n    cout << table[i] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int dx[]={-1,0,1,-1,1,-1,0,1};\nconst int dy[]={-1,-1,-1,0,0,1,1,1};\nconst char type[]={'o','x'};\nchar fld[10][10];\nint cnt(int y,int x,int ds,int ty,int cn){\n    if(y<0||y>=8||x<0||x>=8)return 0;\n    if(fld[y][x]==type[ty])return cn;\n    if(fld[y][x]=='.')return 0;\n    return cnt(y+dy[ds],x+dx[ds],ds,ty,cn+1);\n}\nbool dlt(int y,int x,int ds,int ty){\n    if(y<0||y>=8||x<0||x>=8)return false;\n    if(fld[y][x]==type[ty])return true;\n    if(fld[y][x]=='.')return false;\n    if(dlt(y+dy[ds],x+dx[ds],ds,ty)==false)return false;\n    fld[y][x]=type[ty];\n    return true;\n}\nint main(){\n    for(int i=0;i<8;i++)scanf(\"%s\",fld[i]);\n\n    for(int turn=0;turn<64;turn++){\n        int mx,my,mc=0;\n        for(int i=0;i<8;i++){\n            int y=((turn&1)?7-i:i);\n            for(int j=0;j<8;j++){\n                int x=((turn&1)?7-j:j);\n                if(fld[y][x]!='.')continue;\n                int val=0;\n                for(int k=0;k<8;k++){\n                    val+=cnt(y+dy[k],x+dx[k],k,turn&1,0);\n                }\n                if(mc<val){\n                    mc=val;\n                    mx=x;\n                    my=y;\n                }\n                //if(val)printf(\"%d:%d %d %d\\n\",turn,y,x,val);\n            }\n        }\n        if(mc==0)continue;\n        fld[my][mx]=type[turn&1];\n        for(int i=0;i<8;i++){\n            dlt(my+dy[i],mx+dx[i],i,turn&1);\n        }\n        //printf(\"%d %d\\n\",my,mx);\n        //for(int i=0;i<8;i++)printf(\"%s\\n\",fld[i]);\n    }\n    for(int i=0;i<8;i++)printf(\"%s\\n\",fld[i]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntypedef vector<string> Board;\n\nbool reverse_rec(Board& board, char stone,int x,int y, int dx,int dy) {\n    if(x>7 || y>7) return false;\n    if(x<0 || y<0) return false;\n    if(board[y][x]=='.') return false;\n    if(board[y][x]==stone) return true;\n\n    bool flag = reverse_rec(board, stone, x+dx,y+dy,dx,dy);\n\n    if(flag) {\n        board[y][x]=stone;\n    }\n        \n    return flag;\n}\nint count(Board& board, char stone) {\n    int res=0;\n    rep(i,board.size()) rep(j,board[i].size()) if(board[i][j]==stone) res++;\n    return res;\n}\nvoid plot(Board& board) {\n    rep(i,board.size()) {\n        rep(j,board[i].size()) {\n            cout<<board[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n\n}\nvoid reverse(Board &board, char stone, int x, int y) {\n    if(board[y][x]!='.') return;\n    for(int dx=-1;dx<=1;dx++) {\n        for(int dy=-1;dy<=1;dy++) {\n            if(!(0<=x+dx&&x+dx<8)) continue;\n            if(!(0<=y+dy&&y+dy<8)) continue;\n            // cout<<dx<<\",\"<<dy<<endl;\n\n            if(board[dy+y][dx+x]!=stone && reverse_rec(board,stone,x+dx,y+dy,dx,dy)) {\n                board[y][x]=stone;\n\n            }\n        }\n    }\n\n}\n\nbool mami(Board &board) {\n    int maxi = count(board, 'o');\n    bool flag = false;\n    Board res = board;\n    rep(i,8) {\n        rep(j,8) {\n            Board tmp = board;\n            reverse(tmp, 'o', j, i);\n            if(maxi < count(tmp,'o')) {\n                maxi = count(tmp,'o');\n                res = tmp;\n                flag = true;\n\n            }\n        }\n    }\n    board = res;\n    return flag;\n}\nbool majo(Board &board) {\n    int maxi = count(board, 'x');\n    bool flag = false;\n    Board res = board;\n    for(int i=7;i>=0;i--) {\n        for(int j=7;j>=0;j--) {\n            Board tmp = board;\n            reverse(tmp, 'x', j, i);\n            if(maxi < count(tmp,'x')) {\n                maxi = count(tmp,'x');\n                res = tmp;\n                flag = true;\n            }\n        }\n    }\n    board = res;\n    return flag;\n}\n\nint main() {\n    Board board;\n    rep(i,8) {\n        string str;\n        cin>>str;\n        board.pb(str);\n    }\n\n    while(1) {\n        bool f = mami(board);\n        f |= majo(board);\n        if(!f) {\n            plot(board);\n            break;\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MA_DEFINES\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define inf (1ll<<60)\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nbool is_valid(int x,int y){\n    return 0<=x&&x<8&&0<=y&&y<8;\n}\n\nbool process(vector<string> &s, char c){\n    char cc=(c=='o'?'x':'o');\n    int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,1,1,1,0,-1,-1,-1};\n    vp mem;\n    rep(i,8){\n        rep(j,8){\n            int ii=i,jj=j;\n            if(c=='x')ii=7-ii,jj=7-jj;\n            vp tmp;\n            tmp.pb({ii,jj});\n            if(s[ii][jj]=='.'){\n                rep(k,8){\n                    vp t;\n                    int nx=jj+dx[k],ny=ii+dy[k];\n                    while(true){\n                        if(!is_valid(nx,ny)||s[ny][nx]=='.'){\n                          t.resize(0);\n                          break;\n                        }\n                        else if(s[ny][nx]==cc)t.pb({ny,nx});\n                        else if(s[ny][nx]==c)break;\n                        nx+=dx[k],ny+=dy[k];\n                    }\n                    for(pi p:t)tmp.pb(p);\n                }\n            }\n            if(tmp.size()!=1&&mem.size()<tmp.size()){\n                mem=tmp;\n            }\n        }\n    }\n    if(mem.empty())return false;\n    for(pi p:mem){\n        int nx=p.se,ny=p.fi;\n        s[ny][nx]=c;\n    }\n    return true;\n}\n\nvoid solve(vector<string> &s){\n    bool f=false;\n    do{\n        f=process(s,'o');\n        f|=process(s,'x');\n    }while(f);\n}\n\nvoid run(){\n    vector<string> s(8);\n    rep(i,8)cin>>s[i];\n    solve(s);\n    rep(i,8)cout<<s[i]<<endl;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool infield(int h, int w){\n    return 0<=h && h<8 && 0<=w && w<8;\n}\n\nint turn_field(vector<string> &field, bool flip, int h, int w, char myc, char opc){\n    if(field[h][w] != '.')\n        return 0;\n    \n    int count = 0;\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            if(i==0 && j==0) continue;\n            \n            int l = 0;\n            int nh = h, nw = w;\n            do{\n                l++;\n                nh = h + i*l;\n                nw = w + j*l;\n            }while(infield(nh, nw) && field[nh][nw] == opc);\n            \n            if(infield(nh, nw) && field[nh][nw] == myc){\n                count += l - 1;\n                if(flip)\n                    for(int k=0; k<l; k++)\n                        field[h+k*i][w+k*j] = myc;\n            }\n        }\n    }\n    return count;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    char turnc[] = {'o', 'x'};\n    \n    vector<string> field(8);\n    for(string &s: field)\n        cin >> s;\n    \n    int pass = 0;\n    int turn = 0;\n    while (pass < 2) {\n        bool update = false;\n        char myc = turnc[turn];\n        char opc = turnc[turn^1];\n        \n        int count = 0;\n        int th, tw;\n        \n        if(turn == 0){\n            for(int h=0; h<8; h++){\n                for(int w=0; w<8; w++){\n                    int tcount = turn_field(field, false, h, w, myc, opc);\n                    if(count < tcount){\n                        count = tcount;\n                        th = h;\n                        tw = w;\n                        update = true;\n                    }\n                }\n            }\n        }else{\n            for(int h=7; 0<=h; h--){\n                for(int w=7; 0<=w; w--){\n                    int tcount = turn_field(field, false, h, w, myc, opc);\n                    if(count < tcount){\n                        count = tcount;\n                        th = h;\n                        tw = w;\n                        update = true;\n                    }\n                }\n            }\n        }\n        \n        if(update){\n            turn_field(field, true, th, tw, myc, opc);\n            pass = 0;\n        }else{\n            pass++;\n        }\n        \n        turn ^= 1;\n    }\n    \n    for(string s: field)\n        cout << s << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nint dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nchar colors[] = {'o', 'x'};\nchar field[10][10];\n\nint put(int y, int x, int turn, bool dryrun) {\n  int ret = 0;\n  REP(dir, 8) {\n    int yy = y + dy[dir], xx = x + dx[dir];\n    while (field[yy][xx] == colors[!turn]) {\n      yy += dy[dir]; xx += dx[dir];\n    }\n    if (field[yy][xx] == colors[turn]) {\n      for (;;) {\n        yy -= dy[dir]; xx -= dx[dir];\n        if (!dryrun) { field[yy][xx] = colors[turn]; }\n        if (yy == y && xx == x) { break; }\n        ++ret;\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  memset(field, '.', sizeof(field));\n  FOREQ(y, 1, 8) FOREQ(x, 1, 8) {\n    scanf(\" %c\", &field[y][x]);\n  }\n\n  for (int turn = 0, pass = 0; pass < 2; turn = !turn) {\n    int max_count = 0, arg_max_y = -1, arg_max_x = -1;\n    FOREQ(y, 1, 8) FOREQ(x, 1, 8) {\n      if (field[y][x] != '.') { continue; }\n      int count = put(y, x, turn, true);\n      if (count > max_count || (count == max_count && turn == 1)) {\n        max_count = count;\n        arg_max_y = y;\n        arg_max_x = x;\n      }\n    }\n    if (max_count == 0) {\n      ++pass;\n    } else {\n      pass = 0;\n      put(arg_max_y, arg_max_x, turn, false);\n    }\n  }\n\n  FOREQ(y, 1, 8) {\n    FOREQ(x, 1, 8) {\n      printf(\"%c\", field[y][x]);\n    }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nstring s[8];\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\nchar turn[2]={'o','x'};\ntypedef pair<int, int> pii;\n\nbool inMap(int x, int y){\n  if(0 <= x && x < 8 &&\n     0 <= y && y < 8)\n    return true;\n  return false;\n}\n\nint count(int x, int y, int t){\n  if(s[y][x] != '.')return 0;\n  \n  int length[8] = {0};\n  int r,res = 0;\n  int nt = (t + 1)&1;\n  for(int i = 0; i < 8; i++){\n    r = 0;\n\n    while(inMap(x + (r + 1)*dx[i], y + (r + 1)*dy[i]) &&\n\t  s[y + (r + 1)*dy[i] ][x + (r + 1)*dx[i] ] == turn[nt]){\n      length[i]++;\n      r++;\n    }\n\n    if(!inMap(x + (r + 1)*dx[i], y + (r + 1)*dy[i]) ||\n      s[y + (r + 1)*dy[i] ][x + (r + 1)*dx[i] ] != turn[t]){\n      length[i] = 0;\n    }\n  }\n\n  for(int i = 0; i < 8; i++){\n    res += length[i];\n  }\n  //cout << res << endl;\n  return res;\n}\n\n\nvoid update(int x, int y, int t){\n  int r;\n  int nt = (t + 1)&1;\n  s[y][x] = turn[t];\n  for(int i = 0; i < 8; i++){\n    r = 0;\n    while(inMap(x + (r + 1)*dx[i], y + (r + 1)*dy[i]) &&\n\t  s[y + (r + 1)*dy[i] ][x + (r + 1)*dx[i] ] == turn[nt]){\n      r++;\n    }\n\n\n    if(inMap(x + (r + 1)*dx[i], y + (r + 1)*dy[i]) &&\n       s[y + (r + 1)*dy[i] ][x + (r + 1)*dx[i] ] == turn[t]){\n      while(0 < r){\n\ts[y + r*dy[i] ][x + r*dx[i] ] = turn[t];\n\tr--;\n      }\n    }\n\n  }\n}\n\n\nint main(){\n  for(int i = 0; i < 8; i++)cin>>s[i];\n  int greatest = -1, t = -1;\n  pii pos;\n  int pass = 0;\n  while(pass < 2){\n    greatest = 0;\n    t++;\n    t = t&1;\n    //cout << turn[t] << endl;\n    pos = pii(-1, -1);\n    for(int i = 0; i < 8; i++){\n      for(int j = 0; j < 8; j++){\n\tint tmp = count(j, i, t);\n\t//cout << tmp << endl;\n\tif(t){\n\t  if(greatest <= tmp){\n\t    //cout << \"f\" << endl;\n\t    greatest = tmp;\n\t    pos = pii(j, i);\n\t    // cout << greatest << endl;\n\t    // cout << pos.first << \" \" << pos.second << endl;\n\t  }\n\t}else{\n\t  if(greatest < tmp){\n\t    greatest = tmp;\n\t    pos = pii(j, i);\n\t    // cout << greatest << endl;\n\t    // cout << pos.first << \" \" << pos.second << endl;\n\t  }\n\t}\n      }\n    }\n\n    if(greatest != 0){\n      // cout << \"x:\" << pos.first << \" y:\" << pos.second << endl;\n      // cout << greatest << endl;\n      update(pos.first, pos.second, t);\n    }\n    if(greatest == 0)pass++;\n    else pass = 0;\n\n  }\n    for(int i = 0; i < 8; i++){\n      cout << s[i] << endl;\n    }\n    //cout << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define FORQ(i,a,b) for(int i = (a); i <= (b); i++)\n#define FORD(i,a,b) for(int i = (a)-1; i >= b; i--)\nusing vi = vector<int>;\n\nbool isin(int x, int y){\n  return (0 <= x) and (x < 8) and (0 <= y) and (y < 8);\n}\n\nvi dx = {1,0,-1,0,1,1,-1,-1}, dy = {0,1,0,-1,1,-1,1,-1};\n\nint main(){\n  vector<string> board(8);\n  rep(i,8) cin >> board[i];\n  bool ismami = true;\n  int notchanged = 0;\n\n  while(1){\n    //cerr << ismami << endl;\n    vector<string> prev = board; // 前の盤面を取っておくよう\n    vector<string> next = board; // 数最大の候補\n    int rnum = 0; // 最大のひっくり返せる数\n\n    if(ismami){\n      rep(i,8) rep(j,8){ // (i,j)に置くことを試す\n\tboard = prev;\n\tint tmp = 0; // (i,j)に置くときにひっくり返せる数\n\tif(board[i][j] != '.') continue;\n\trep(k,8) FORQ(l,1,8){\n\t  int nx = i + l * dx[k], ny = j + l * dy[k];\n\t  if(not isin(nx,ny)) break;\n\t  if(board[nx][ny] == 'x') continue;\n\t  if(board[nx][ny] == 'o'){\n\t    //cerr << i << \"\\t\" << j << \"\\t\" << l << endl;\n\t    tmp += l - 1;\n\t    FOR(m, 0, l) board[i+m*dx[k]][j+m*dy[k]] = 'o';\n\t    break;\n\t  }\n\t  if(board[nx][ny] == '.') break;\n\t}\n\tif(tmp > rnum){\n\t  //cerr << tmp << endl;\n\t  rnum = tmp;\n\t  next = board;\n\t}\n      }\n    }else{\n      FORD(i,8,0) FORD(j,8,0){ // (i,j)に置くことを試す\n\tboard = prev;\n\tint tmp = 0; // (i,j)に置くときにひっくり返せる数\n\tif(board[i][j] != '.') continue;\n\trep(k,8) FORQ(l,1,8){\n\t  int nx = i + l * dx[k], ny = j + l * dy[k];\n\t  if(not isin(nx,ny)) break;\n\t  if(board[nx][ny] == 'o') continue;\n\t  if(board[nx][ny] == 'x'){\n\t    tmp += l - 1;\n\t    FOR(m, 0, l) board[i+m*dx[k]][j+m*dy[k]] = 'x';\n\t    break;\n\t  }\n\t  if(board[nx][ny] == '.') break;\n\t}\n\tif(tmp > rnum){\n\t  //cerr << tmp << endl;\n\t  rnum = tmp;\n\t  next = board;\n\t}\n        \n      }\n    }\n\n    board = next;\n    ismami = not ismami;\n    \n    if(prev == next) notchanged++;\n    else notchanged = 0;\n    if(notchanged == 2) break;\n    // rep(i,8){\n    //   rep(j,8) cerr << board[i][j];\n    //   cerr << endl;\n    // }\n  }\n  rep(i,8){\n    rep(j,8) cout << board[i][j];\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> P;\n\nint cho,che;\nchar table[8][8];\nvector<P> v;\n\nconst int dx[8] = {0,0,1,1,1,-1,-1,-1};\nconst int dy[8] = {1,-1,0,-1,1,-1,0,1};\nconst char ch[3] = {'x','o'};\n\nvoid check(int x,int y,int turn,vector<P> &v){\n  char c = ch[turn],d = ch[1-turn];\n  int count = 0;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int cnt = 0;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tif(table[nx][ny] == c){\n\t  count += cnt;\n\t}\n\tbreak;\n      }\n\n      cnt++;\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }   \n\n  if(count == 0){\n    return;\n  }\n\n  if(turn){\n    v.push_back(P(-count,PA(x,y)));\n  }else{\n    v.push_back(P(-count,PA(-x,-y)));\n  }\n}\n\nvoid change(P a,int turn){\n  char c = ch[turn],d = ch[1-turn];\n\n  a.first = -a.first;\n\n  if(!turn){\n    a.second.first = -a.second.first;\n    a.second.second = -a.second.second;\n  }\n\n  table[a.second.first][a.second.second] = c;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int nx = a.second.first + dx[i];\n    int ny = a.second.second + dy[i];\n    vector<PA> v;\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tbreak;\n      }\n\n      v.push_back(PA(nx,ny));\n      nx += dx[i];\n      ny += dy[i];\n    }\n\n    if(!(0 > nx || 0 > ny || nx >= 8 || ny >= 8) && table[nx][ny] == c){\n      while(true){     \n\tif(nx == a.second.first && ny == a.second.second){\n\t  break;\n\t}\n\ttable[nx][ny] = c;  \n\tnx -= dx[i];\n\tny -= dy[i];\n      }\n    }\n\n  } \n\n  if(turn){\n    cho += a.first+1;\n    che -= a.first;\n  }else{\n    cho -= a.first;\n    che += a.first+1;\n  }\n}\n\nint main(){\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cin >> table[i][j];\n\n      if(table[i][j] == 'o'){\n\tcho++;\n      }else if(table[i][j] == 'x'){\n\tche++;\n      }\n    }\n  }\n\n  //true mami ------ false witch\n  bool turn = true;\n  int pass = 0;\n\n  while(true){\n    vector<P> v;\n \n    if(pass == 2 || !cho || !che || cho+che == 64){\n      break;\n    }\n \n    for(int i = 0 ; i < 8 ; i++){\n      for(int j = 0 ; j < 8 ; j++){\n\tif(table[i][j] == '.'){\n\t  int n = turn ? 1 : 0;\n\t  check(i,j,n,v);\n\t}\n      }\n    }  \n\n    int size = (int)v.size();\n\n    if(size == 0){\n      pass++;\n    }else{\n      pass = 0;\n      int n = turn ? 1 : 0;\n      sort(v.begin(),v.end());\n      change(v[0],n);\n    }\n\n    turn = !turn;\n  }\n\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cout << table[i][j];\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int g,h,i,j,k,l,m;\n  char a[10][10]={};\n  for(i=1;i<=8;++i){\n    for(j=1;j<=8;++j)\n      scanf(\"%c\",&a[i][j]);\n    getchar();\n  }\n  char s[2]={'x','o'};\n  int x[8]={1,1,0,-1,-1,-1,0,1},y[8]={0,1,1,1,0,-1,-1,-1};\n  g=0;\n  for(;;){\n    for(h=0;h<2;++h){\n      int mxx,mxy,mxn=0;\n      for(i=1;i<=8;++i){\n\tfor(j=1;j<=8;++j){\n\t  if(a[i][j]=='.'){\n\t    int sm=0;\n\t    for(k=0;k<8;++k){\n\t      if(a[i+y[k]][j+x[k]]==s[h]){\n\t\tfor(l=1;a[i+y[k]*(l+1)][j+x[k]*(l+1)]==s[h];++l);\n\t\tif(a[i+y[k]*(l+1)][j+x[k]*(l+1)]==s[(h+1)%2])\n\t\t  sm+=l;\n\t      }\n\t    }\n\t    if(sm){\n\t      if(0){\n\t      }else if(mxn<sm){\n\t\tmxx=j;\n\t\tmxy=i;\n\t\tmxn=sm;\n\t      }else if(mxn>sm){\n\t      }else{\n\t\tif(h){\n\t\t  if(0){\n\t\t  }else if(mxy<i){\n\t\t    mxx=j;\n\t\t    mxy=i;\n\t\t  }else if(mxy>i){\n\t\t  }else{\n\t\t    if(mxx<j)\n\t\t      mxx=j;\n\t\t  }\n\t\t}else{\n\t\t  if(0){\n\t\t  }else if(mxy>i){\n\t\t    mxx=j;\n\t\t    mxy=i;\n\t\t  }else if(mxy<i){\n\t\t  }else{\n\t\t    if(mxx>j)\n\t\t      mxx=j;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      if(mxn){\n\ta[mxy][mxx]=s[(h+1)%2];\n\tfor(k=0;k<8;++k){\n\t  if(a[mxy+y[k]][mxx+x[k]]==s[h]){\n\t    for(l=1;a[mxy+y[k]*(l+1)][mxx+x[k]*(l+1)]==s[h];++l);\n\t    if(a[mxy+y[k]*(l+1)][mxx+x[k]*(l+1)]==s[(h+1)%2]){\n\t      for(m=0;m<l;++m)\n\t\ta[mxy+y[k]*(m+1)][mxx+x[k]*(m+1)]=s[(h+1)%2];\n\t    }\n\t  }\n\t}\n\tg=0;\n      }else{\n\tif(g)\n\t  break;\n\telse\n\t  g=1;\n      }\n    }\n    if(h<2)\n      break;\n  }\n  for(i=1;i<=8;++i){\n    for(j=1;j<=8;++j)\n      printf(\"%c\",a[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<string> v(8);\n\tREP(i, 8)cin >> v[i];\n\t\n\t\n\tREP(t, 10000) {\n\t\tint p = -1, q = -1, cmax = -1;\n\t\tif (t % 2 == 0) {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'x')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\tif (tmp != 0)s.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax < c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\n\t\t\t\tv[p][q] = 'o';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'x')v[ni][nj] = 'o';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'o')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\tif (tmp != 0)s.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax <= c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\n\t\t\t\tv[p][q] = 'x';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'o')v[ni][nj] = 'x';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Dessert Witch\n// 右横にひっくり返せぬ\n\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint s[8][8];\n\nint endJudge() {\n  int maru = 0, batu = 0, notYet = 0;\n  for(int i=0; i<8; i++) {\n    for(int j=0; j<8; j++) {\n      if(s[i][j] == -1)\n\tmaru++;\n      else if(s[i][j] == 1)\n\tbatu++;\n      else\n\tnotYet++;\n    }\n  }\n\n  if(maru==0 || batu==0 || notYet==0)\n    return 1;\n  else\n    return 0;\n}\n\nint calcMass(int currentX, int currentY, int mode) {\n  int tmp = 0;\n  int score = 0;\n  bool flag=true;\n\n  for(int k=1; k<8/* && flag==true*/; k++) { // 左上へ探索\n    if(0<=currentX-k && 0<=currentY-k) {\n      if(s[currentX-k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY-k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 上へ探索\n    if(0<=currentY-k) {\n      if(s[currentX][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY-k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 右上へ探索\n    if(0<=currentY-k && currentX+k<8) {\n      if(s[currentX+k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY-k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8; k++) { // 左横へ検索\n    if(0<=currentX-k) {\n      if(s[currentX-k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY] == mode) {\n\tscore+=tmp;\n\tbreak;\n     }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8; k++) { // 右横へ検索\n    if(currentX+k < 8) {\n      if(s[currentX+k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 左下へ検索\n    if(0<=currentX-k && currentY+k<8) {\n      if(s[currentX-k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY+k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 下へ検索\n    if(currentY+k<8) {\n      if(s[currentX][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY+k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n\n  tmp=0;\n  flag=true;\n  for(int k=1; k<8/* && flag==true*/; k++) { // 右下へ検\n    if(currentX+k<8 && currentY+k<8) {\n      if(s[currentX+k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY+k] == mode) {\n\tscore+=tmp;\n\tbreak;\n      }\n      else\n\t//flag=false;\n\tbreak;\n    }\n    else\n      //flag=false;\n      break;\n  }\n  return score;\n}\n\n\n\nvoid setOsero(int x, int y, int mode) {\n  int currentX = x, currentY = y;\n  int tmp;\n  s[x][y] = mode;\n\n  tmp=0;\n  for(int k=1; k<8; k++) { // 左上へ探索\n    if(0<=currentX-k && 0<=currentY-k) {\n      if(s[currentX-k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY-k] == mode) {\n\tfor(int l=1; l<tmp+1; l++) {\n\t  s[currentX-l][currentY-l] *= -1;\n\t}\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 上へ探索\n    if(0<=currentY-k) {\n      if(s[currentX][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY-k] == mode) {\n\tfor(int l=1; l<tmp+1; l++) {\n\t  s[currentX][currentY-l] *= -1;\n\t}\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 右上へ探索\n    if(0<=currentY-k && currentX+k<8) {\n      if(s[currentX+k][currentY-k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY-k] == mode) {\n\tfor(int l=1; l<tmp+1; l++) {\n\t  s[currentX+l][currentY-l] *= -1;\n\t}\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 左横へ検索\n    if(0<=currentX-k) {\n      if(s[currentX-k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX-l][currentY] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 右横へ検索\n    if(0<=currentX+k) {\n      if(s[currentX+k][currentY] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX+l][currentY] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 左下へ検索\n    if(0<=currentX-k && currentY+k<8) {\n      if(s[currentX-k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX-k][currentY+k] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX-l][currentY+l] *= -1;\n        break;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 下へ検索\n    if(currentY+k<8) {\n      if(s[currentX][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX][currentY+k] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX][currentY+l] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n  tmp=0;\n  for(int k=1; k<8; k++) { // 右下へ検\n    if(currentX+k<8 && currentY+k<8) {\n      if(s[currentX+k][currentY+k] == -mode)\n\ttmp++;\n      else if(s[currentX+k][currentY+k] == mode) {\n\tfor(int l=1; l<tmp+1; l++)\n\t  s[currentX+l][currentY+l] *= -1;\n\tbreak;\n      }\n      else\n\tbreak;\n    }\n    else\n      break;\n  }\n}\n\nvoid drawOsero() {\n  for(int i=0; i<8; i++) {\n    for(int j=0; j<8; j++) {\n      if(s[i][j] == -1)\n\tcout<<\"o\";\n      else if(s[i][j] == 1)\n\tcout<<\"x\";\n      else\n\tcout<<\".\";\n    }\n    cout<<endl;\n  }\n}\n\nint main() {\n  //int s[8][8]; // o:-1 x:1 .:0\n  //int test=0;\n\n  for(int i=0; i<8; i++) {\n    // Input\n    string tmp;\n    getline(cin, tmp);\n    for(int j=0; j<8; j++) {\n      if(tmp[j] == 'o') \n\ts[i][j] = -1;\n      else if(tmp[j] == 'x')\n\ts[i][j] = 1;\n      else\n\ts[i][j] = 0;\n    }\n  }\n  //drawOsero();\n\n  while(true) {\n    int setI, setJ;\n    int tmp;\n    int maxTmp=0;\n    int outo;\n\n    outo=0;\n    // いくつ置けるのかを計算\n    for(int i=0; i<8; i++) {\n      for(int j=0; j<8; j++) {\n\tif(s[i][j] == 0) { // 空きマスである\n\t  int tmp=calcMass(i, j, -1);\n\t  if(tmp>maxTmp) {\n\t    maxTmp = tmp;\n\t    setI = i;\n\t    setJ = j;\n\t  }\n\t}\n      }\n    }\n    // 先行が置く\n    if(maxTmp != 0)\n      setOsero(setI, setJ, -1);\n    else\n      outo++;\n    //cout<<\"S:\"<<maxTmp<<endl;\n    //drawOsero();\n\n\n\n   maxTmp=0;\n   for(int i=7; i>=0; i--) {\n      for(int j=7; j>=0; j--) {\n\tif(s[i][j] == 0) { // 空きマスである\n\t  int tmp=calcMass(i, j, 1);\n\t  if(tmp>maxTmp) {\n\t    maxTmp = tmp;\n\t    setI = i;\n\t    setJ = j;\n\t  }\n\t}\n      }\n    }\n    // 後攻が置く\n   if(maxTmp != 0) \n     setOsero(setI, setJ, 1);\n   else\n     outo++;\n   //cout<<\"A:\"<<maxTmp<<endl;\n   //drawOsero();\n\n   if(endJudge()==1 || outo==2)\n     break;\n   //cout<<endl;\n  }\n  drawOsero();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long // intで書いたけど心配なときにlong longに変換する\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n\n#define NROW 8\n#define NCOL 8\n\n#define PLAYERA 0\n#define PLAYERB 1\n\n#define STONEA 'o'\n#define STONEB 'x'\n#define STONEEMPTY '.'\n\nstruct Point {\n    int r;\n    int c;\n};\n\nchar board[NROW][NCOL];\n\nvoid change_player(int *turn) {\n    if(*turn == PLAYERA) {\n        *turn = PLAYERB;\n    } else {\n        *turn = PLAYERA;\n    }\n}\n\nint count_placed_stones() {\n    int cnt = 0;\n    REP(i, NROW) REP(j, NCOL) if(board[i][j] != STONEEMPTY) cnt++;\n    return cnt;\n}\n\nbool in_board(Point p) {\n    if (p.r < 0 || NROW <= p.r || p.c < 0 || NCOL <= p.c) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nint simulate_placement(int turn, Point p, bool execute) {\n    int replace_cnt = 0;\n    char my_stone, opponent_stone;\n    my_stone = (turn == PLAYERA) ? STONEA : STONEB;\n    opponent_stone = (turn == PLAYERA) ? STONEB : STONEA;\n    Point tp;\n    bool ok;\n    if(board[p.r][p.c] != STONEEMPTY) return 0;\n    REP(dir, 8) {\n        tp.r = p.r; tp.c = p.c;\n        ok = true;\n        while(true) {\n            tp.r += dx[dir]; tp.c += dy[dir];\n            if(!in_board(tp)){\n                ok = false; break;\n            }\n            if(board[tp.r][tp.c] == opponent_stone){\n                continue;\n            } else if (board[tp.r][tp.c] == my_stone) {\n                break;\n            } else {\n                ok = false; break;\n            }\n        }\n        if(!ok) continue;\n        while(true) {\n            tp.r -= dx[dir]; tp.c -= dy[dir];\n            if (tp.r == p.r && tp.c == p.c) break;\n            if(execute) board[tp.r][tp.c] = my_stone;\n            replace_cnt++;\n        }\n    }\n    if(execute) board[p.r][p.c] = my_stone;\n    return replace_cnt;\n}\n\nbool play_turn(int turn) {\n    bool placed_stone = false;\n    int best_replace_cnt = 0;\n    int cur_replace_cnt;\n    Point bestp = {-1, -1};\n    Point curp = {-1, -1};\n    REP(r, NROW) REP(c, NCOL) {\n        if(turn == PLAYERA) {\n            curp.r = r; curp.c = c;\n        } else {\n            curp.r = NROW - r - 1; curp.c = NCOL - c - 1;\n        }\n        cur_replace_cnt = simulate_placement(turn, curp, false);\n        if (cur_replace_cnt > best_replace_cnt) {\n            best_replace_cnt = cur_replace_cnt;\n            bestp.r = curp.r; bestp.c = curp.c;\n        }\n    }\n    if(bestp.r != -1 && bestp.c != -1) {\n        simulate_placement(turn, bestp, true);\n        placed_stone = true;\n    }\n    return placed_stone;\n}\n\nvoid print_board() {\n    REP(r, NROW) {\n        REP(c, NCOL) {\n            cout << board[r][c];\n        }\n        cout << endl;\n    }\n}\n\nvoid solve() {\n    int turn = PLAYERA;\n    int continuous_skip_cnt = 0;\n    while(count_placed_stones() < NROW*NCOL) {\n        bool placed_stone = play_turn(turn);\n        if(placed_stone) {\n            continuous_skip_cnt = 0;\n        } else {\n            continuous_skip_cnt++;\n            if (continuous_skip_cnt >= 2) break;\n        }\n        change_player(&turn);\n    }\n    print_board();\n}\n\nsigned main() {\n    REP(i, NROW) {\n        string rowstr; cin >> rowstr;\n        REP(j, NCOL) board[i][j] = rowstr[j];\n    }\n\n    solve();\n}\n\n// https://github.com/kurokoji/.cpp-Template/wiki テンプレートについて\n// http://www.creativ.xyz/dump-cpp-652 dump()について\n// https://gist.github.com/rigibun/7905920 色々\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nvector< vector<char> >V(8,vector<char>(8));\nint dx[8]={-1,1,0,0,-1,-1,1,1};\nint dy[8]={0,0,-1,1,-1,1,-1,1};\n\nbool update;\nint idx,idy,count;\nbool can[8];\n\nbool in(int x,int y){\n\treturn x>=0 && y>=0 && x<8 && y<8;\n}\n\nvoid check(int k){\n\tchar me,you;\n\tbool tcan[8];\n\tcount=0;\n\tmemset(can,false,sizeof(can));\n\tif(k==0){me='o';you='x';}\n\telse{me='x';you='o';}\n\tfor(int iy=0;iy<8;iy++){\n\t\tint tcount,ttcount;\n\t\tfor(int ix=0;ix<8;ix++){\n\t\t\tint x=ix,y=iy;\n\t\t\tif(k!=0){\n\t\t\t\tx=7-ix;\n\t\t\t\ty=7-iy;\n\t\t\t}\n\t\t\ttcount=0;\n\t\t\tmemset(tcan,false,sizeof(tcan));\n\t\t\tif(V[y][x]!='.')\n\t\t\t\tcontinue;\n\t\t\tfor(int d=0;d<8;d++){\n\t\t\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\t\t\tttcount=0;\n\t\t\t\twhile(in(nx,ny)&&V[ny][nx]==you){\n\t\t\t\t\tnx+=dx[d];ny+=dy[d];ttcount++;\n\t\t\t\t}\n\t\t\t\tif(in(nx,ny) && V[ny][nx]==me &&ttcount>0){\n\t\t\t\t\ttcount+=ttcount;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\ttcan[d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tcount>count){\n\t\t\t\tidx=x;idy=y;count=tcount;update=true;\n\t\t\t\tfor(int i=0;i<8;i++) can[i]=tcan[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid put(int k){\n\tchar me,you;\n\tif(count==0)\n\t\treturn;\n\tif(k==0){me='o';you='x';}\n\telse{me='x';you='o';}\n\tV[idy][idx]=me;\n\tfor(int d=0;d<8;d++){\n\t\tif(can[d]){\n\t\t\tint nx=idx+dx[d],ny=idy+dy[d];\n\t\t\twhile(in(nx,ny) && V[ny][nx]==you){\n\t\t\t\tV[ny][nx]=me;nx+=dx[d];ny+=dy[d];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print(){\n\tfor(int y=0;y<8;y++){\n\t\tfor(int x=0;x<8;x++)\n\t\t\tcout<<V[y][x];\n\t\tcout<<endl;\n\t}\n}\n\n\nint main()\n{\n\tfor(int y=0;y<8;y++)\n\t\tfor(int x=0;x<8;x++)\n\t\t\tcin>>V[y][x];\n\n\tupdate=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tcheck(0);\n\t\tput(0);\n\t\tcheck(1);\n\t\tput(1);\n\t}\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <array>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\nusing namespace std;\n\nconstexpr int n = 8;\nbool is_on_field(int y, int x) { return 0 <= y and y < n and 0 <= x and x < n; }\nint main() {\n    // input\n    array<array<char, n>, n> f;\n    repeat (y, n) repeat (x, n) scanf(\" %c\", &f[y][x]);\n    // solve\n    auto use = [](array<array<char, n>, n> f, int y, int x, char c) {\n        int cnt = 0;\n        repeat_from (dy, -1, +1+1) repeat_from (dx, -1, +1+1) if (dy != 0 or dx != 0) {\n            f[y][x] = c;\n            for (int k = 1; ; ++ k) {\n                int ny = y + k*dy;\n                int nx = x + k*dx;\n                if (not is_on_field(ny, nx)) break;\n                if (f[ny][nx] == '.') break;\n                if (f[ny][nx] == c) {\n                    while (-- k) {\n                        f[y + k*dy][x + k*dx] = c;\n                        ++ cnt;\n                    }\n                    break;\n                }\n            }\n        }\n        return make_pair(f, cnt);\n    };\n    int pass = 0;\n    for (int turn = 0; ; ++ turn) {\n        char c = turn % 2 == 0 ? 'o' : 'x';\n        int result_y = -1, result_x = -1;\n        int result = 0;\n        repeat (y, n) repeat (x, n) if (f[y][x] == '.') {\n            int cnt = use(f, y, x, c).second;\n            if (result < cnt or (result == cnt and turn % 2 == 1)) {\n                result_y = y;\n                result_x = x;\n                result = cnt;\n            }\n        }\n        if (not result) {\n            pass += 1;\n            if (pass >= 2) {\n                break;\n            }\n        } else {\n            pass = 0;\n            f = use(f, result_y, result_x, c).first;\n        }\n    }\n    // output\n    repeat (y, n) {\n        repeat (x, n) {\n            printf(\"%c\", f[y][x]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=2e9;\ndouble EPS=1e-10;\nchar fld[8][8];\nchar rev(char c){\n      return c=='o'?'x':'o';\n}\nchar turn(int k){\n      return k==0?'x':'o';\n}\nbool pos(int x,int y){\n      return 0<=x&&x<8&&0<=y&&y<8;\n}\nint cnt(int x,int y,int dx,int dy,char k){\n      int res=0;\n      char l=rev(k);\n      x+=dx;y+=dy;\n      while(1){\n            if(fld[x][y]==l)res++;\n            else break;\n            x+=dx;y+=dy;\n            if(!pos(x,y)){\n                  return 0;\n            }\n      }\n      if(fld[x][y]==k){\n            //cout<<\"ok\"<<endl;\n            return res;\n      }\n      //cout<<\"ok\"<<endl;\n      return 0;\n}\nint rec(int x,int y,char k){\n      //cout<<x<<\" \"<<y<<\" \"<<k<<endl;;\n      int res=0;\n      for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                  if(i==0&&j==0)continue;\n                  //cout<<\"ok\"<<endl;\n                  res+=cnt(x,y,i,j,k);\n                  //if(x==2&&y==4)cout<<res<<\" \";\n            }\n      }\n      //if(x==2&&y==4)cout<<endl;\n      return res;\n}\nvoid change(int x,int y,char k){\n      //cout<<x<<\" \"<<y<<\" \"<<k<<endl;\n      for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                  if(i==0&&j==0)continue;\n                  int res=cnt(x,y,i,j,k);\n                  //cout<<res<<endl;\n                  if(res==0)continue;\n                  REP(l,res+1){\n                        fld[x+i*l][y+j*l]=k;\n                  }\n            }\n      }\n      return;\n}\nint main(){\n      REP(i,8)REP(j,8)cin>>fld[j][i];\n      int t=1;\n      int c=0;//d=0;\n      while(1){\n            //d++;\n            int ma=0,mx,my;\n            //cout<<turn(t)<<endl;\n            if(t==1){\n                  for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n                        if(fld[j][i]!='.')continue;\n                        int res=rec(j,i,turn(t));\n                        //cout<<res<<\" \";\n                        //if(res==0)continue;\n                        if(res>=ma){\n                              mx=j;my=i;ma=res;\n                        }\n                  }\n            }else{\n                  REP(i,8)REP(j,8){\n                        if(fld[j][i]!='.')continue;\n                        int res=rec(j,i,turn(t));\n                        //cout<<res<<\" \";\n                        //if(res==0)continue;\n                        if(res>=ma){\n                              mx=j;my=i;ma=res;\n                        }\n                  }\n            }\n            //REP(i,8)REP(j,8)printf(\"%c%c\",fld[j][i],j==7?'\\n':' ');cout<<endl;\n            //cout<<endl<<mx<<\" \"<<my<<\" \"<<ma<<\" \"<<turn(t)<<endl;\n            if(ma==0){\n                  //cout<<1<<endl;\n                  c++;\n                  t^=1;\n                  //cout<<c<<endl;\n                  if(c>=2)break;\n                  continue;\n            }else c=0;\n            //REP(i,8)REP(j,8)printf(\"%c%c\",fld[j][i],j==7?'\\n':' ');cout<<endl;\n            //cout<<1<<endl;\n            //fld[mx][my]=turn(t);\n            change(mx,my,turn(t));\n            //REP(i,8){REP(j,8)printf(\"%c\",fld[j][i]);cout<<endl;}\n            //cout<<endl;\n            t^=1;\n            //if(d>10)break;\n      }\n      REP(i,8){REP(j,8)printf(\"%c\",fld[j][i]);cout<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint dx[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dy[]={1, -1, 0, 0, 1, -1, 1, -1};\nconst int N=8;\nchar c[N][N];\n\nbool Mami(){\n   int Rev=0;\n   int ii, jj;\n   for(int i=0; i<N; i++){\n      for(int j=0; j<N; j++){\n         //cout<< i<<\" \"<<j<< endl;\n         if(c[i][j]=='o'||c[i][j]=='x') continue;\n         vector<int> V;\n         for(int k=0; k<8; k++){\n            int ni=i+dy[k];\n            int nj=j+dx[k];\n            if(!(0<=ni&&ni<N&&0<=nj&&nj<N)) continue;\n            V.push_back(k);\n         }\n         int rev=0;\n         for(int k: V){\n            //cout<< k<< endl;\n            int ni=i, nj=j;\n            while(1){\n               ni+=dy[k];\n               nj+=dx[k];\n               if(!(0<=ni&&ni<N&&0<=nj&&nj<N)) break;\n               if(c[ni][nj]=='.') break;\n               if(c[ni][nj]=='o'){\n                  for(int _i=i+dy[k], _j=j+dx[k]; _i!=ni||_j!=nj; _i+=dy[k], _j+=dx[k]){\n                     //cout<< _i<<\" \"<<_j<< endl;\n                     rev++;\n                  }\n                  break;\n               }\n            }\n         }\n         if(rev>Rev){\n            ii=i, jj=j;\n            Rev=rev;\n         }\n      }\n   }\n   //cout<< Rev<< \" \"<<ii<<\" \"<<jj<< endl;\n   if(Rev==0) return false;\n   c[ii][jj]='o';\n   for(int k=0; k<8; k++){\n      int ni=ii, nj=jj;\n      while(1){\n         ni+=dy[k];\n         nj+=dx[k];\n         //cout<< ni<< \" \"<< nj<< endl;\n         if(!(0<=ni&&ni<N&&0<=nj&&nj<N)) break;\n         if(c[ni][nj]=='.') break;\n         if(c[ni][nj]=='o'){\n            for(int _i=ii+dy[k], _j=jj+dx[k]; _i!=ni||_j!=nj; _i+=dy[k], _j+=dx[k]){\n               c[_i][_j]='o';\n            }\n            break;\n         }\n      }\n   }\n   return true;\n}\n\nbool Hoge(){\n   int Rev=0;\n   int ii, jj;\n   for(int i=N-1; i>=0; i--){\n      for(int j=N-1; j>=0; j--){\n         if(c[i][j]=='o'||c[i][j]=='x') continue;\n         vector<int> V;\n         for(int k=0; k<8; k++){\n            int ni=i+dy[k];\n            int nj=j+dx[k];\n            if(!(0<=ni&&ni<N&&0<=nj&&nj<N)) continue;\n            V.push_back(k);\n         }\n         int rev=0;\n         for(int k: V){\n         int ni=i, nj=j;\n            while(1){\n               ni+=dy[k];\n               nj+=dx[k];\n               if(!(0<=ni&&ni<N&&0<=nj&&nj<N)) break;\n               if(c[ni][nj]=='.') break;\n               if(c[ni][nj]=='x'){\n                  for(int _i=i+dy[k], _j=j+dx[k]; _i!=ni||_j!=nj; _i+=dy[k], _j+=dx[k]){\n                     rev++;\n                  }\n                  break;\n               }\n            }\n         }\n         if(rev>Rev){\n            ii=i, jj=j;\n            Rev=rev;\n         }\n      }\n   }\n   if(Rev==0) return false;\n   c[ii][jj]='x';\n   for(int k=0; k<8; k++){\n      int ni=ii, nj=jj;\n      while(1){\n         ni+=dy[k];\n         nj+=dx[k];\n         if(!(0<=ni&&ni<N&&0<=nj&&nj<N)) break;\n         if(c[ni][nj]=='.') break;\n         if(c[ni][nj]=='x'){\n            for(int _i=ii+dy[k], _j=jj+dx[k]; _i!=ni||_j!=nj; _i+=dy[k], _j+=dx[k]){\n               c[_i][_j]='x';\n            }\n            break;\n         }\n      }\n   }\n   return true;\n}\n\nint main(){\n\n   for(int i=0; i<N; i++){\n      for(int j=0; j<N; j++){\n         cin>> c[i][j];\n      }\n   }\n\n   bool F=true;\n   while(F){\n      bool x=Mami();\n      bool y=Hoge();\n      //cout<< x<< \" \"<< y<< endl;\n      F=(x||y);\n   }\n\n   for(int i=0; i<N; i++){\n      for(int j=0; j<N; j++){\n         cout<< c[i][j];\n      }cout<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std; \n#define MAXA 100000000\n#define MAXB 100000000\n#define MAXC 100000000\n#define MAXD 100000000\n#define MAXN 50\n#define MAXM 50\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nchar board[8][8];\nint check(int x,int y,char c)\n{\n  int res=0;\n  if(board[y][x] !='.'){return 0;}\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      int count=0;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[ny][nx]==c){res+=count;break;}\n\t  if(board[ny][nx]=='.'){break;}\n\t  count++;\n\t}\n    }\n  return res;\n}\nvoid put(int x,int y,char c)\n{\n  board[y][x]=c;\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[nx][ny]==c){\n\t    while(1)\n\t      {\n\t\tnx -=dx[k];\n\t\tny -=dy[k];\n\t\tif(nx == x && ny == y){break;}\n\t\tboard[ny][nx]= c;\n\t      }\n\t    break;\n\t  }\n\t  if(board[ny][nx]=='.'){break;}\n\t}\n    }\n}\n\nbool win()\n{\n  int o_count=0;\n  int x_count=0;\n  for(int x=0;x<8;x++)\n    {\n      for(int y=0;y<8;y++)\n\t{\n\t  if(board[x][y]=='o'){o_count++;}\n\t  if(board[x][y]=='x'){x_count++;}\n\t}\n    }\n  return o_count==0 || x_count==0 || o_count+x_count==64;\n}\n    \nint main(int argc,char const* argv[])\n{\n  for(int i=0;i<8;i++)\n    {\n      for(int j=0;j<8;j++)\n\t{\n\t  cin >> board[i][j];\n\t}\n    }\n  int turn=1;\n  int max_x,max_y;\n  int pass=0;\n  while(1)\n    {\n      char player=(turn % 2) ? 'o' : 'x';\n      int num=0;max_x=-1,max_y=-1;\n      if(player == 'o')\n\t{\n\t  for(int y=0;y<8;y++)\n\t    {\n\t      for(int x=0;x<8;x++)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for(int y=7;y>=0;y--)\n\t    {\n\t      for(int x=7;x>=0;x--)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(max_x != -1)\n\t{\n\t  pass=0;\n\t  put(max_x,max_y,player);\n\t}\n      else\n\t{\n\t  pass++;\n\t}\n      turn++;\n      if(pass>1){break;}\n      if(win()){break;}\n    }\n    \n  for(int y=0;y<8;y++)\n    {\n      for(int x=0;x<8;x++)\n\t{\n\t  cout << board[y][x];\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\nstring q = \"ox\";\nint dx[8] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dy[8] = {1, -1, 1, 0, -1, 1, 0, -1};\n\nvector<string> rev(vector<string> s, int turn, int y, int x){\n  char c = q[(turn+1)%2];\n  s[y][x] = q[turn%2];\n  for(int dir=0; dir<8; dir++){\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) continue;\n    if( s[ny][nx] == '.' ) continue;\n    bool f = false;\n    while( s[ny][nx] == c ){\n      ny += dy[dir];\n      nx += dx[dir];\n\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) break;\n      if( s[ny][nx] == q[turn%2] ){\n        f = true;\n        break;\n      }\n      if( s[ny][nx] == '.' ) break;\n    }\n    while( f ){\n      if( ny == y && nx == x ) break;\n      s[ny][nx] = q[turn%2];\n      ny -= dy[dir];\n      nx -= dx[dir];\n    }\n  }\n  return s;\n}\n\n\nint calc(vector<string> s, int turn, int y, int x){\n  char e = q[(turn+1)%2];\n  char my = q[turn%2];\n  int cnt = 0;\n  for(int dir=0; dir<8; dir++){\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) continue;\n    int tmp = 0;\n    bool f = false;\n    while( s[ny][nx] == e ){\n      tmp++;\n      ny += dy[dir];\n      nx += dx[dir];\n\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) break;\n      if( s[ny][nx] == my ){\n        f = true;\n        break;\n      }\n    }\n    cnt += tmp * f;\n  }\n  return cnt;\n}\n\nvector<string> func(vector<string> s, int turn){\n  int a = -1;\n  int rx = -1, ry = -1;\n  for(int i=0; i<8; i++){\n    for(int j=0; j<8; j++){\n      int x = j, y = i;\n      if( turn % 2 == 1 ) x = 7 - j;\n      if( turn % 2 == 1 ) y = 7 - i;\n      if( s[y][x] != '.' ) continue;\n\n      int r = calc(s, turn, y, x);\n      if( a < r ){\n        a = r;\n        rx = x;\n        ry = y;\n      }\n    }\n  }\n  // cerr << a << \" \" << rx << \" \" << ry << endl;\n  if( a <= 0 ) return s;\n  return rev(s, turn, ry, rx);\n}\n\nint main(void) {\n\n  vector<string> s(8);\n  for(int i=0; i<8; i++) cin >> s[i];\n  int q = 0;\n  int turn = 0;\n  while( turn < 200 ){\n    vector<string> t = func(s, turn);\n    turn++;\n    if( s == t ) q++;\n    s = t;\n    // if( q > 3 ) break;\n    // for(int i=0; i<8; i++) cerr << s[i] << endl;\n    // cerr << endl;\n  }\n\n  for(int i=0; i<8; i++){\n    cout << s[i] << endl;\n  }\n\n  return 0;\n}\n\n\n// EOF"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<stack>\n\nusing namespace std;\n\n#define INF 999999999\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nvector<string> bo(10);\nint f;\n\nvoid cookie(int t){\n\tint d[8][2]={{-1,-1},{-1,0},{-1,1},\n\t\t{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\tint x=9, y=9, ma=0, nx, ny, ins, sum, i ,j;\n\tstring co=\"ox\";\n\tfor(int ii=1;ii<=8;ii++){\n\t\tif(t==0) i = ii;\n\t\telse i = 9 - ii;\n\t\tfor(int jj=1;jj<=8;jj++){\n\t\t\tif(t==0) j = jj;\n\t\t\telse j = 9 - jj;\n\t\t\tsum = 0;\n\t\t\tif(bo[i][j]=='.'){\n\t\t\t\tREP(a,8){\n\t\t\t\t\tins = 0;\n\t\t\t\t\tnx = i;\n\t\t\t\t\tny = j;\n\t\t\t\t\twhile(bo[nx+d[a][0]][ny+d[a][1]]==co[1-t]){\n\t\t\t\t\t\tins++;\n\t\t\t\t\t\tnx += d[a][0];\n\t\t\t\t\t\tny += d[a][1];\n\t\t\t\t\t}\n\t\t\t\t\t//cout << nx <<\"=\" << ny <<endl ;\n\t\t\t\t\tif(ins && bo[nx+d[a][0]][ny+d[a][1]]==co[t]) sum += ins;\n\t\t\t\t}\n\t\t\t\tif(ma < sum){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tma = sum;\n\t\t\t\t}\n\t\t\t\t//cout << ma << endl;\n\t\t\t}\n\t\t}\n\t}\n\tif(ma){\n\t\tf++;\n\t\t//cout << co[t] << \":\" << x << \",\" << y << endl;\n\t\tREP(a,8){\n\t\t\tbo[x][y] = co[t];\n\t\t\tnx = x;\n\t\t\tny = y;\n\t\t\twhile(bo[nx+d[a][0]][ny+d[a][1]]==co[1-t]){\n\t\t\t\tnx += d[a][0];\n\t\t\t\tny += d[a][1];\n\t\t\t}\n\t\t\tif(bo[nx+d[a][0]][ny+d[a][1]] == co[t]){\n\t\t\t\twhile(nx!=x||ny!=y){\n\t\t\t\t\tbo[nx][ny] = co[t];\n\t\t\t\t\tnx -= d[a][0];\n\t\t\t\t\tny -= d[a][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint i, j;\n\tstring ins;\n\tREP(a,8){\n\t\tcin >> ins;\n\t\tbo[a+1] = \"z\" + ins + \"z\";\n\t}\n\tbo[0] = \"zzzzzzzzzz\";\n\tbo[9] = \"zzzzzzzzzz\";\n\tf = 1;\n\twhile(f>0){\n\t\tf = 0;\n\t\t//mami\n\t\tcookie(0);\n\t\t//charl\n\t\tcookie(1);\n\t}\n\t//cout << \"ok\" << endl;\n\tREP(a,8) cout << bo[a+1].substr(1,8) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst char cs[] = \"xo\";\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n    state(){}\n};\n\nstate flip(const int x, const int y, state s, bool turn){\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        while (valid(cx, cy) && s.g[cy][cx] == cs[1 - turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cx, cy) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i];\n                !(ix == cx && iy == cy);\n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[1 - turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n    }\n    return s;\n}\n\nint main()\n{\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    for (size_t turn = 1; turn <= 64; turn++){\n        bool ok = false;\n        state next = cur;\n        for (size_t y = 0; y < 8; y++){\n            for (size_t x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 0 && next.score[1] >= cand.score[1]) ||\n                        ((turn & 1) == 1 && next.score[0] > cand.score[0])){\n                        ok = true;\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        cur = next;\n    }\n\n    for (size_t i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#include <iostream>\n#include <array>\n// #include <map>\n// #include <string>\n// #include <algorithm>\n// #include <numeric>\n// #include <limits>\n\nusing namespace std;\n\nstruct Dir{\n\tint i;\n\tint j;\n\tDir(int _i, int _j) : i(_i), j(_j) {\n\t}\n};\n\narray<array<char, 8>, 8> cloth; // [i][j]\narray<Dir, 8> dirs = {\n\t//Dir( 0, 0),\n\tDir( 1, 0),\n\tDir(-1, 0),\n\tDir( 0, 1),\n\tDir( 1, 1),\n\tDir(-1, 1),\n\tDir( 0,-1),\n\tDir( 1,-1),\n\tDir(-1,-1)\n};\n\ninline bool inRange(int i, int j) {\n\tif (i < 0 or 8 <= i) {\n\t\treturn false;\n\t}\n\tif (j < 0 or 8 <= j) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint turnLine(int i, int j, int c, Dir d) {\n\tint count = 0;\n\ti += d.i;\n\tj += d.j;\n\twhile (inRange(i, j)) {\n\t\tif (cloth[i][j] == c) {\n\t\t\treturn count;\n\t\t}\n\t\tif (cloth[i][j] == '.') {\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\ti += d.i;\n\t\tj += d.j;\n\t}\n\treturn 0;\n}\n\nvoid turnLineReal(int i, int j, int c, Dir d, int count) {\n\tcloth[i][j] = c;\n\tfor (int k = 0; k < count; k++) {\n\t\ti += d.i;\n\t\tj += d.j;\n\t\tcloth[i][j] = c;\n\t}\n}\n\nint put(int i, int j, char c) {\n\tif (cloth[i][j] != '.') {\n\t\treturn 0;\n\t}\n\tint count = 0;\n\tfor (auto d : dirs) {\n\t\tcount += turnLine(i, j, c, d);\n\t}\n\treturn count;\n}\n\nvoid putReal(int i, int j, char c) {\n\tfor (auto d : dirs) {\n\t\tint count = turnLine(i, j, c, d);\n\t\tturnLineReal(i, j, c, d, count);\n\t}\n}\n\nbool mami() {\n\tint m = 0; // max\n\tint put_i;\n\tint put_j;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tint p = put(i, j, 'o');\n\t\t\tif (m < p) {\n\t\t\t\tm = p;\n\t\t\t\tput_i = i;\n\t\t\t\tput_j = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (m == 0) {\n\t\treturn false;\n\t}\n\tputReal(put_i, put_j, 'o');\n\treturn true;\n}\n\nbool bebe() {\n\tint m = 0; // max\n\tint put_i;\n\tint put_j;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tint p = put(i, j, 'x');\n\t\t\tif (m <= p) {\n\t\t\t\tm = p;\n\t\t\t\tput_i = i;\n\t\t\t\tput_j = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (m == 0) {\n\t\treturn false;\n\t}\n\tputReal(put_i, put_j, 'x');\n\treturn true;\n}\n\nvoid print() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcout << cloth[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcin >> cloth[i][j];\n\t\t}\n\t}\n\tbool flg = true;\n\twhile (flg) {\n\t\tflg = false;\n\t\tflg = mami() or flg;\n\t\t//std::cout << \"debug mami end\" << std::endl; // debug\n\t\t//print();\n\t\tflg = bebe() or flg;\n\t\t//std::cout << \"debug bebe end\" << std::endl; // debug\n\t\t//print();\n\t}\n\t//std::cout << \"debug \" << std::endl; // debug\n\tprint();\n\t//std::cout << \"\\e[38;5;0m\\e[48;5;40m --- end ---  \\e[m\" << std::endl; // debug\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n\nvector<string> s(10, string(10, '.'));\nint dx[8] = { 1,0,-1,0,-1,-1,1,1 };\nint dy[8] = { 0,1,0,-1,-1,1,-1,1 };\n\ntypedef pair<int, int> P;\nmap<char, char> rv;\n\nint count(vector<string> v, char c) {\n\tint cnt = 0;\n\trep(i, v.size()) {\n\t\trep(j, v[i].size()) {\n\t\t\tif (v[i][j] == c) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvector<string> put(int y, int x, char c) {\n\tauto ts = s;\n\tts[y][x] = c;\n\trep(i, 8) {\n\t\tint ty = y + dy[i], tx = x + dx[i];\n\t\tint cnt = 0;\n\t\tvector<P> ch;\n\t\twhile (1) {\n\t\t\tif (rv[ts[ty][tx]] != c) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch.push_back(P(ty, tx));\n\t\t\tty += dy[i]; tx += dx[i];\n\t\t}\n\t\tif (ts[ty][tx] == c) {\n\t\t\teach(p, ch) {\n\t\t\t\tts[p.first][p.second] = c;\n\t\t\t}\n\t\t}\n\t}\n\treturn ts;\n}\n\nP maxPoint(char c) {\n\tint ma = 0, now = count(s, c);\n\tP p(-1, -1);\n\n\tif (c == 'o') {\n\t\tfor (int y = 1; y <= 8; y++) {\n\t\t\tfor (int x = 1; x <= 8; x++) {\n\t\t\t\tif (s[y][x] == '.') {\n\t\t\t\t\tint next = count(put(y, x, c), c);\n\t\t\t\t\tif (ma < next && next > now + 1) {\n\t\t\t\t\t\tma = next;\n\t\t\t\t\t\tp = P(y, x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int y = 8; y >= 1; y--) {\n\t\t\tfor (int x = 8; x >= 1; x--) {\n\t\t\t\tif (s[y][x] == '.') {\n\t\t\t\t\tint next = count(put(y, x, c), c);\n\t\t\t\t\tif (ma < next && next > now + 1) {\n\t\t\t\t\t\tma = next;\n\t\t\t\t\t\tp = P(y, x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn p;\n}\n\nint main() {\n\tfor (int y = 1; y <= 8; y++) {\n\t\tcin >> s[y];\n\t\ts[y] = \".\" + s[y] + \".\";\n\t}\n\trv['o'] = 'x';\n\trv['x'] = 'o';\n\trv['.'] = '.';\n\n\tstring tb = \"ox\";\n\n\tint wait = 0;\n\tfor (int i = 0;; i++) {\n\t\tchar c = tb[i % 2];\n\t\tauto p = maxPoint(c);\n\t\tif (p.first == -1) {\n\t\t\twait++;\n\t\t\tif (wait == 2)break;\n\t\t\tcontinue;\n\t\t}\n\t\twait = 0;\n\t\ts = put(p.first, p.second, c);\n\t}\n\n\tfor (int y = 1; y <= 8; y++) {\n\t\tfor (int x = 1; x <= 8; x++) {\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) ((void) 42)\n#define dump2D(...) ((void) 42)\n#define dump1D(...) ((void) 42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\nchar minimize = 'o'; // second\n\nstring s[8];\nint dx[] = {1, 0, 1, 1, -1, 0, -1, -1};\nint dy[] = {0, 1, 1, -1, 0, -1, -1, 1};\nchar blank = '.';\n\nbool is_inside(int y, int x, int h, int w) { return 0 <= y && 0 <= x && y < h && x < w; }\n\nusing Cordinate = tuple<int, int>;\n\nint num(char me, char you, int y, int x, int sy, int sx, vector<Cordinate> & cords) {\n  assert(s[y][x] == blank);\n  int res = 0;\n  vector<Cordinate> nc;\n  while(1) {\n    y += sy;\n    x += sx;\n    if(!is_inside(y, x, 8, 8)) return 0;\n    if(s[y][x] == blank) return 0;\n    if(s[y][x] == you) res++, nc.emplace_back(y, x);\n    if(s[y][x] == me) break;\n  }\n  for(auto el : nc) cords.push_back(el);\n  return res;\n}\n\nbool check(char me, char you) {\n  tuple<int, int, int, vector<Cordinate>> ans(0, 8, 8, vector<Cordinate>());\n\n  for(int i = 0; i < 8; i++) for(int j = 0; j < 8; j++) {\n    if(s[i][j] != blank) continue;\n    vector<Cordinate> cords;\n    int sum = 0;\n    for(int d = 0; d < 8; d++) {\n      sum += num(me, you, i, j, dy[d], dx[d], cords);\n    }\n    ans = max(ans, make_tuple(\n          sum,\n          me == minimize ? -i : i,\n          me == minimize ? -j : j,\n          cords\n          )\n        );\n  }\n\n  if(me == minimize && get<1>(ans) != 8) get<1>(ans) *= -1, get<2>(ans) *= -1;\n\n  for(auto p : get<3>(ans)) {\n    s[get<0>(p)][get<1>(p)] = me;\n  }\n  // dump(get<1>(ans), get<2>(ans));\n  bool passed = get<1>(ans) == 8;\n  if(!passed) s[get<1>(ans)][get<2>(ans)] = me;\n  return passed;\n}\n\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  for(int i = 0; i < 8; i++) cin >> s[i];\n\n  char me = 'o', you = 'x';\n\n  int pass = 0;\n  while(1) {\n    // dump(me);\n    auto p = check(me, you);\n    if(p) pass++;\n    else pass = 0;\n    if(pass == 2) break;\n    swap(me, you);\n    // for(int i = 0; i < 8; i++) cout << s[i] << \"\\n\";\n  }\n\n  for(int i = 0; i < 8; i++) cout << s[i] << \"\\n\";\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 998244353\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    // for(int i=0; i<8; i++){\n    //     cout << dx[i] << \" \" << dy[i] << endl;\n    // }\n    vector<string> m;\n    REP(i,8){\n        string s; cin >> s;\n        m.PB(s);\n    }\n    int t = 0;\n    bool update = true;\n    while(update){\n        update = false;\n        {\n            int mx=-1;\n            int sx=10, sy=10;\n            int dir=-1;\n            char my, op;\n            if(t&1){\n                my = 'x';\n                op = 'o'; \n            }else{\n                my = 'o';\n                op = 'x';\n            }\n            for(int i=0; i<8; i++){\n                for(int j=0; j<8; j++){\n                    if(m[i][j] == 'o' || m[i][j] == 'x') continue;\n\n                    int sum = 0;\n                    for(int k=0; k<8; k++){\n                        bool ok = false;\n                        int ny = i , nx = j;\n                        int ct = 0;\n                        while(1){\n                            ny += dy[k], nx += dx[k];\n                            if(!(ny >= 0 && ny < 8 && nx >= 0 && nx < 8)) break;\n                            if(m[ny][nx] == '.') break;\n\n                            if(m[ny][nx] == my) {\n                                ok = true;\n                                break;\n                            }\n                            ct++;\n                        }\n                        if(!ok) continue;\n                        sum += ct; \n                    }\n                    mx = max(mx, sum);\n                }\n            }\n            for(int i=0; i<8; i++){\n                for(int j=0; j<8; j++){\n                    if(m[i][j] == 'o' || m[i][j] == 'x') continue;\n\n                    int sum = 0;\n                    for(int k=0; k<8; k++){\n                        bool ok = false;\n                        int ny = i , nx = j;\n                        int ct = 0;\n                        while(1){\n                            ny += dy[k], nx += dx[k];\n                            if(!(ny >= 0 && ny < 8 && nx >= 0 && nx < 8)) break;\n                            if(m[ny][nx] == '.') break;\n\n                            if(m[ny][nx] == my) {\n                                ok = true;\n                                break;\n                            }\n                            ct++;\n                        }\n                        if(!ok) continue;\n                        sum += ct;\n                    }\n                    \n                    if(mx == sum){\n                        if(my == 'o'){\n                            if(sy > i){\n                                sy = i, sx = j;\n                            }\n                            else if(sy == i){\n                                if(sx > j)\n                                sy = i, sx = j;\n                            }\n                        }else{\n                            if(sy < i){\n                                sy = i, sx = j;\n                            }\n                            else if(sy == i){\n                                if(sx < j){\n                                    sy = i, sx = j;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n                \n            if(mx <= 0){\n\n            }else{\n                //cout << sy << \" \" << sx << \" \" <<  mx << endl;\n                update = true;\n                m[sy][sx] = my;\n                for(int i=0; i<8; i++){\n                    int ny = sy, nx = sx;\n                    int gy = -1, gx = -1;\n                    bool ok =false;\n                    while(1){\n                        ny += dy[i], nx += dx[i];\n                        if(!(ny >= 0 && ny < 8 && nx >= 0 && nx < 8)) break;\n                        if(m[ny][nx] == '.') break;\n                        if(m[ny][nx] == my) {\n                            ok = true;\n                            break;   \n                        }\n                    }\n                    if(!ok) continue;\n                    gy = ny, gx = nx;\n                    int tsy = sy, tsx = sx;\n                    while(1){\n                        if(tsy == gy && tsx == gx) break;\n\n                        m[tsy][tsx] = my;\n                        tsy += dy[i], tsx += dx[i];\n                    }\n                }\n            }\n        }\n        // for(int i=0; i<8; i++){\n        //     cout << m[i] << endl;\n        // }\n        t^=1;\n        {\n            int mx=-1;\n            int sx=-1, sy=-1;\n            int dir=-1;\n            char my, op;\n            if(t&1){\n                my = 'x';\n                op = 'o'; \n            }else{\n                my = 'o';\n                op = 'x';\n            }\n            for(int i=0; i<8; i++){\n                for(int j=0; j<8; j++){\n                    if(m[i][j] == 'o' || m[i][j] == 'x') continue;\n\n                    int sum = 0;\n                    for(int k=0; k<8; k++){\n                        bool ok = false;\n                        int ny = i , nx = j;\n                        int ct = 0;\n                        while(1){\n                            ny += dy[k], nx += dx[k];\n                            if(!(ny >= 0 && ny < 8 && nx >= 0 && nx < 8)) break;\n                            if(m[ny][nx] == '.') break;\n\n                            if(m[ny][nx] == my) {\n                                ok = true;\n                                break;\n                            }\n                            ct++;\n                        }\n                        if(!ok) continue;\n                        sum += ct; \n                    }\n                    mx = max(mx, sum);\n                }\n            }\n            for(int i=0; i<8; i++){\n                for(int j=0; j<8; j++){\n                    if(m[i][j] == 'o' || m[i][j] == 'x') continue;\n\n                    int sum = 0;\n                    for(int k=0; k<8; k++){\n                        bool ok = false;\n                        int ny = i , nx = j;\n                        int ct = 0;\n                        while(1){\n                            ny += dy[k], nx += dx[k];\n                            if(!(ny >= 0 && ny < 8 && nx >= 0 && nx < 8)) break;\n                            if(m[ny][nx] == '.') break;\n\n                            if(m[ny][nx] == my) {\n                                ok = true;\n                                break;\n                            }\n                            ct++;\n                        }\n                        if(!ok) continue;\n                        sum += ct;\n                    }\n                    \n                    if(mx == sum){\n                        if(my == 'o'){\n                            if(sy > i){\n                                sy = i, sx = j;\n                            }\n                            else if(sy == i){\n                                if(sx > j)\n                                sy = i, sx = j;\n                            }\n                        }else{\n                            if(sy < i){\n                                sy = i, sx = j;\n                            }\n                            else if(sy == i){\n                                if(sx < j){\n                                    sy = i, sx = j;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if(mx <= 0){\n\n            }else{\n                update = true;\n                m[sy][sx] = my;\n                for(int i=0; i<8; i++){\n                    int ny = sy, nx = sx;\n                    int gy = -1, gx = -1;\n                    bool ok = false;\n                    while(1){\n                        ny += dy[i], nx += dx[i];\n                        if(!(ny >= 0 && ny < 8 && nx >= 0 && nx < 8)) break;\n                        if(m[ny][nx] == '.') break;\n                        if(m[ny][nx] == my) {\n                            ok = true;\n                            break;   \n                        }\n                    }\n                    if(!ok) continue;\n                    gy = ny, gx = nx;\n                    int tsy = sy, tsx = sx;\n                    while(1){\n                        if(tsy == gy && tsx == gx) break;\n\n                        m[tsy][tsx] = my;\n                        tsy += dy[i], tsx += dx[i];\n                    }\n                }\n            }\n        }\n        // for(int i=0; i<8; i++){\n        //     cout << m[i] << endl;\n        // }\n        t ^= 1;\n    }\n\n    for(int i=0; i<8; i++){\n        cout << m[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s[8];\nchar c[2]={'o','x'};\nint dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};\nint t;\n\nint dfs(int d,int x,int y){\n  if(min(x,y)<0||7<max(x,y)||s[y][x]=='.')return -9;\n  if(s[y][x]==c[t])return 0;\n  return dfs(d,x+dx[d],y+dy[d])+1;\n}\n\nvoid solve(){\n  int ct=0;\n  while(ct++<150){  \n    int px=-1,py=-1,mx=0;\n    for(int y=0;y<8;y++)\n      for(int x=0;x<8;x++){\n\tint xx=x,yy=y,res=0;\n\tif(t)xx=7-x,yy=7-y;\n\tif(s[yy][xx]!='.')continue;\n\tfor(int i=0;i<8;i++)res+=max(0,dfs(i,xx+dx[i],yy+dy[i]));\n\tif(res>mx)px=xx,py=yy,mx=res;\n      }\n    if(mx)\n      for(int i=0;i<8;i++){\n\tint res=dfs(i,px+dx[i],py+dy[i]);\n\tfor(int j=0;j<=res;j++)\n\t  s[py+j*dy[i]][px+j*dx[i]]=c[t];\n      }\n    t=!t;\n  }\n}\n\nint main(){\n  for(int i=0;i<8;i++)cin>>s[i];\n  solve();\n  for(int i=0;i<8;i++)cout<<s[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <functional>\nusing namespace std;\ntypedef tuple<int,int,int> tiii;\n\ntypedef struct{\n\tint x;\n\tint y;\n}dir;\nvector<dir>D={\n\t{-1,-1},{0,-1},{1,-1},\n\t{-1,0},{1,0},\n\t{-1,1},{0,1},{1,1},\n};\n\nconst int H=8,W=8;\nvector<function<bool(tiii&,tiii&)> >sorter={\n\t[](tiii &a,tiii &b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)>get<2>(b))return true;\n\t\tif(get<2>(a)<get<2>(b))return false;\n\t\tif(get<1>(a)>get<1>(b))return true;\n\t\tif(get<1>(a)<get<1>(b))return false;\n\t\treturn false;\n\t},\n\t[](tiii &a,tiii &b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)<get<2>(b))return true;\n\t\tif(get<2>(a)>get<2>(b))return false;\n\t\tif(get<1>(a)<get<1>(b))return true;\n\t\tif(get<1>(a)>get<1>(b))return false;\n\t\treturn false;\n\t}\n};\n\nint check2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=check2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\treturn r+1;\n}\nint check1(int color,int x,int y,vector<string>&m){\n\tint R=-1;\n\tfor(auto &d:D){\n\t\tint r=check2(color,d,x+d.x,y+d.y,m);\n\t\tif(r>0){\n\t\t\tif(R<0)R=0;\n\t\t\tR+=r;\n\t\t}\n\t}\n\treturn R;\n}\n\nint fill2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=fill2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\tm[y][x]=color;\n\treturn r+1;\n}\nvoid fill1(int color,int x,int y,vector<string>&m){\n\tfor(auto &d:D){\n\t\tfill2(color,d,x+d.x,y+d.y,m);\n\t}\n}\n\nint main(){\n\tstring color=\"ox\";\n\tvector<string>m(H);\n\tfor(int h=0;h<H;h++)cin>>m[h];\n\tint turn=0,pass=0;\n\tfor(;;){\n\t\tvector<tiii>v;\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)if(m[y][x]=='.'){\n\t\t\tint r=check1(color[turn],x,y,m);\n\t\t\tif(r>0)v.push_back(make_tuple(r,x,y));\n\t\t}\n\t\tif(v.empty()){\n\t\t\tpass++;\n\t\t\tif(pass>1)break;\n\t\t}else{\n\t\t\tpass=0;\n\t\t\tsort(v.begin(),v.end(),sorter[turn]);\n\t\t\ttiii &t=*v.rbegin();\n\t\t\tfill1(color[turn],get<1>(t),get<2>(t),m);\n\t\t\tm[get<2>(t)][get<1>(t)]=color[turn];\n\t\t}\n\t\tturn^=1;\n\t}\n\tfor(int h=0;h<H;h++)cout<<m[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s[10];\n\nint cnt[10][10];\n\nint dx[] = { 0,1,1,1,0,-1,-1,-1 };\nint dy[] = { 1,1,0,-1,-1,-1,0,1 };\n\nbool check() {\n\tbool f[3] = {};\n\tREP(i, 8) {\n\t\tif (s[i].find('o') != -1)f[0] = 1;\n\t\tif (s[i].find('x') != -1)f[1] = 1;\n\t\tif (s[i].find('.') != -1)f[2] = 1;\n\t}\n\treturn f[0] && f[1] && f[2];\n}\n\nint count(int y, int x, int d, bool t) {\n\tint res = 0;\n\tbool f = 0;\n\tx += dx[d];\n\ty += dy[d];\n\twhile (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\tif (s[y][x] == (t ? 'o' : 'x')) {\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tif (t) {\n\t\t\t\tif (s[y][x] == 'x')res++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[y][x] == 'o')res++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\tif (f)return res;\n\treturn 0;\n}\n\nvoid print() {\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tREP(i, 8)cin >> s[i];\n\tbool f = 1;\n\twhile (1) {\n\t\tREP(i, 10)REP(j, 10)cnt[i][j] = 0;\n\t\tif (!check())break;\n\t\tint ma = 0;\n\t\tP pos = { -1,-1 };\n\t\tREP(i, 8) {\n\t\t\tREP(j, 8) {\n\t\t\t\tint ny, nx;\n\t\t\t\tif (f)ny = i, nx = j;\n\t\t\t\telse ny = 7 - i, nx = 7 - j;\n\t\t\t\tif (s[ny][nx] == '.') {\n\t\t\t\t\tint w = 0;\n\t\t\t\t\tREP(k, 8)w += count(ny, nx, k, f);\n\t\t\t\t\tif (ma < w) {\n\t\t\t\t\t\tma = w;\n\t\t\t\t\t\tpos = { ny,nx };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ma != 0) {\n\t\t\tREP(i, 8) {\n\t\t\t\tint y = pos.first, x = pos.second;\n\t\t\t\tint w = count(y, x, i, f);\n\t\t\t\tREP(j, w + 1) {\n\t\t\t\t\tint ny = pos.first + dy[i] * j,\n\t\t\t\t\t\tnx = pos.second + dx[i] * j;\n\t\t\t\t\t//cout << \"!\" << ny << \" \" << nx << endl;\n\t\t\t\t\tif (f)s[ny][nx] = 'o';\n\t\t\t\t\telse s[ny][nx] = 'x';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//print();\n\t\t//cout << endl;\n\t\tf = !f;\n\t}\n\tprint();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid rotate(vector<string>& s) {\n\tvector<string> t = s;\n\tfor (int i = 0; i < 8; i++)\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tif (t[7 - i][7 - j] == 'o') s[i][j] = 'x';\n\t\t\telse if (t[7 - i][7 - j] == 'x') s[i][j] = 'o';\n\t\t\telse s[i][j] = '.';\n}\n\nint foo(vector<string>& s, int i, int j, int di, int dj) {\n\tif (i < 0 || i >= 8 || j < 0 || j >= 8 || s[i][j] == '.') return -1;\n\telse if (s[i][j] == 'o') return 0;\n\telse {\n\t\tint x = foo(s, i + di, j + dj, di, dj);\n\t\treturn x == -1 ? -1 : x + 1;\n\t}\n}\n\nint bar(vector<string>& s, int i, int j, int di, int dj) {\n\tif (i < 0 || i >= 8 || j < 0 || j >= 8 || s[i][j] == '.') return -1;\n\telse if (s[i][j] == 'o') return 0;\n\telse {\n\t\tint x = bar(s, i + di, j + dj, di, dj);\n\t\tif (x == -1) return -1;\n\t\telse {\n\t\t\ts[i][j] = 'o';\n\t\t\treturn x + 1;\n\t\t}\n\t}\n}\n\nint main() {\n\tvector<string> s(8);\n\tfor (int i = 0; i < 8; i++) cin >> s[i];\n\tbool flag = true;\n\tint t;\n\tfor (t = 0; ; t++) {\n\t\tint _i, _j, maxi = 0;\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (s[i][j] != '.') continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int di = -1; di <= 1; di++)\n\t\t\t\t\tfor (int dj = -1; dj <= 1; dj++)\n\t\t\t\t\t\tif (di || dj)\n\t\t\t\t\t\t\tsum += max(0, foo(s, i + di, j + dj, di, dj));\n\t\t\t\tif (sum > maxi) {\n\t\t\t\t\t_i = i; _j = j; maxi = sum;\n\t\t\t\t}\n\t\t\t}\n\t\tif (maxi > 0) {\n\t\t\ts[_i][_j] = 'o';\n\t\t\tfor (int di = -1; di <= 1; di++)\n\t\t\t\tfor (int dj = -1; dj <= 1; dj++)\n\t\t\t\t\tif (di || dj)\n\t\t\t\t\t\tbar(s, _i + di, _j + dj, di, dj);\n\t\t\tflag = true;\n\t\t}\n\t\telse if (flag) flag = false;\n\t\telse break;\n\t\trotate(s);\n\t}\n\tif (t % 2 == 1) rotate(s);\n\tfor (int i = 0; i < 8; i++)\n\t\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nchar table[8][8];\nstring s = \"ox\";\nbool range_check(int y, int x)\n{\n    if(y < 0 || x < 0 || y >= 8 || x >= 8) return false;\n    else return true;\n}\nvoid Put(int y, int x, int flag)\n{\n    table[y][x] = s[flag];\n    for(int k = 0; k < 8; k++)\n    {\n        int ny = y;\n        int nx = x;\n        bool ok = false;\n        while(1)\n        {\n            ny += dy[k];\n            nx += dx[k];\n            if(!range_check(ny, nx)) break;\n            if(table[ny][nx] == '.') break;\n            if(table[ny][nx] == s[flag])\n            {\n                ok = true;\n                break;\n            }\n        }\n        if(ok)\n        {\n            ny = y;\n            nx = x;\n            while(1)\n            {\n                ny += dy[k];\n                nx += dx[k];\n                if(table[ny][nx] == s[flag]) break;\n                table[ny][nx] = s[flag];\n            }\n        }\n    }\n}\nint Search(int y, int x, int flag)\n{\n    int ret = 0;\n    for(int k = 0; k < 8; k++)\n    {\n        int ny = y;\n        int nx = x;\n        int cnt = 0;\n        while(1)\n        {\n            ny += dy[k];\n            nx += dx[k];\n            if(!range_check(ny, nx)) break;\n            if(table[ny][nx] == '.') break;\n            if(table[ny][nx] == s[flag])\n            {\n                ret += cnt;\n                break;\n            }\n            if(table[ny][nx] == s[!flag]) cnt++;\n        }\n    }\n    return ret;\n}\nvoid Solve()\n{\n    bool ok = false;\n    priority_queue<PP> que;\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++)\n        {\n            if(table[i][j] != '.') continue;\n            int cnt = Search(i, j, 0);\n            if(cnt >= 1) que.push(PP(cnt, P(-i, -j)));\n        }\n    }\n    if(!que.empty())\n    {\n        PP p = que.top();\n        Put(-p.second.first, -p.second.second, 0);\n        ok = true;\n    }\n    //clear()がない( 一一)\n    que = decltype(que)();\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++)\n        {\n            if(table[i][j] != '.') continue;\n            int cnt = Search(i, j, 1);\n            if(cnt >= 1) que.push(PP(cnt, P(i, j)));\n        }\n    }\n    if(!que.empty())\n    {\n        PP p = que.top();\n        Put(p.second.first, p.second.second, 1);\n        ok = true;\n    }\n    if(ok) Solve();\n    else return;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++) cin >> table[i][j];\n    }\n    Solve();\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++) cout << table[i][j];\n        cout << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool stop;\nint board[8][8];\nint dr[] = {0,1,1,1,0,-1,-1,-1};\nint dc[] = {1,1,0,-1,-1,-1,0,1};\n\nstruct poc {\n\tint row;\n\tint col;\n\tint count;\n\tvector<int> dir;\n\tbool operator<(const poc& right) const {\n\t\tif (count == right.count) {\n\t\t\tif (row == right.row) {\n\t\t\t\treturn (col < right.col);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (row < right.row);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (count > right.count);\n\t\t}\n\t}\n};\n\nvoid update_board(int p, poc c) {\n\tboard[c.row][c.col] = p;\n\tfor (int i = 0; i < (c.dir).size(); ++i) {\n\t\tint nr = c.row + dr[c.dir[i]];\n\t\tint nc = c.col + dc[c.dir[i]];\n\t\tbool find = false;\n\t\twhile (!find) {\n\t\t\tboard[nr][nc] = p;\n\t\t\tnr += dr[c.dir[i]];\n\t\t\tnc += dc[c.dir[i]];\n\t\t\tif (board[nr][nc] == p) {\n\t\t\t\tfind = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid play_turn(int p) {\n\tvector<poc> cand;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (board[i][j] == 0) {\n\t\t\t\tint count = 0;\n\t\t\t\tvector<int> ds;\n\t\t\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\t\t\tint nr = i + dr[d];\n\t\t\t\t\tint nc = j + dc[d];\n\t\t\t\t\tint rcmin = min(nr,nc);\n\t\t\t\t\tint rcmax = max(nr,nc);\n\t\t\t\t\tif (rcmax < 8 && rcmin >= 0 && board[nr][nc] == -p) {\n\t\t\t\t\t\tbool find = false; \n\t\t\t\t\t\tint tc = 0;\n\t\t\t\t\t\twhile (!find) {\n\t\t\t\t\t\t\tif (board[nr][nc] == p) {\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\tstop = false;\n\t\t\t\t\t\t\t\tds.push_back(d);\n\t\t\t\t\t\t\t\tcount += tc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (board[nr][nc] == -p) {\n\t\t\t\t\t\t\t\t++tc;\n\t\t\t\t\t\t\t\tnr += dr[d];\n\t\t\t\t\t\t\t\tnc += dc[d];\n\t\t\t\t\t\t\t\trcmin = min(nr,nc);\n\t\t\t\t\t\t\t\trcmax = max(nr,nc);\n\t\t\t\t\t\t\t\tif (rcmax >= 8 || rcmin < 0) {\n\t\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ds.size() > 0) {\n\t\t\t\t\tcand.push_back({i,j,count,ds});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cand.size() > 0) {\n\t\tsort(cand.begin(),cand.end());\n\t\tpoc prop = cand[0];\n\t\tif (p == -1) {\n\t\t\tint max_c = cand[0].count;\n\t\t\tfor (int i = 0; i < cand.size() && cand[i].count == max_c; ++i) {\n\t\t\t\tprop = cand[i];\n\t\t\t}\n\t\t}\n\t\tupdate_board(p,prop);\n\t}\n\treturn;\n}\n\nint main(void) {\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tchar c; \n\t\t\tcin >> c;\n\t\t\tif (c == 'x') {\n\t\t\t\tboard[i][j] = -1;\n\t\t\t}\n\t\t\telse if (c == '.') {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboard[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tstop = false;\n\twhile (!stop) {\n\t\tstop = true;\n\t\tplay_turn(1);\n\t\tplay_turn(-1);\n\t}\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (board[i][j] == -1) {\n\t\t\t\tcout << \"x\";\n\t\t\t}\n\t\t\telse if (board[i][j] == 0) {\n\t\t\t\tcout << \".\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"○\";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid rotate(vector<string> &field){\n  int n = field.size();\n  vector<string> tmp = field;\n  REP(i, n)REP(j, n) tmp[n-i-1][n-j-1] = field[i][j];\n  field = tmp;\n}\n\npair<int, vector<string> > flip(const vector<string> &field, int x, int y, char c){\n  int n = field.size();\n  \n  int ans = 0;\n  vector<string> board = field;\n  board[x][y] = c;\n  \n  REP2(dx, -1, 2)REP2(dy, -1, 2){\n    if(dx == 0 && dy == 0) continue;\n    int tx = x + dx, ty = y + dy;\n    while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n          board[tx][ty] != '.' && board[tx][ty] != c) {\n      tx += dx;\n      ty += dy;\n    }\n    \n    if(0 <= tx && tx < n && 0 <= ty && ty < n && board[tx][ty] == c){\n      tx = x + dx, ty = y + dy;\n      \n      while(0 <= tx && tx < n&& 0 <= ty && ty < n &&\n            board[tx][ty] != '.' && board[tx][ty] != c) {\n        board[tx][ty] = c;\n        tx += dx;\n        ty += dy; \n        ans++;\n      }\n    }\n  }\n  return make_pair(ans, board);\n  \n}\n\nint main(){\n  vector<string> field(8);\n  \n  REP(i, 8) cin >> field[i];\n\n  int s = 0;\n  bool mami;\n  REP(i, 8) s += count(ALL(field[i]), '.');\n  if(s % 2){\n    mami = false;\n  }else{\n    mami = true;\n  }\n\n  int bad = 0;\n\n  // cout << mami << endl;\n  while(true){\n    // REP(i, 8) cout << field[i] << endl;\n    if(!mami) rotate(field);\n\n    int best = 0;\n    vector<string> bestboard;\n    \n    REP(i, 8) REP(j, 8)if(field[i][j] == '.'){\n      pair<int, vector<string> > p = flip(field, i, j, mami ? 'o' : 'x');\n      if(p.first > best){\n        best = p.first;\n        bestboard = p.second;\n      }\n    }\n\n    if(best > 0){\n      bad = 0;\n      field = bestboard;\n    }\n    \n    if(!mami) rotate(field);\n    \n    if(best == 0){\n      bad++;\n      if(bad > 10) break;\n    }\n    mami = !mami;\n  }\n  REP(i, 8) cout << field[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n;i++)\nvector<vector<char>>s(8,vector<char>(8));\nbool inrange(int y,int x){return (0<=y&&y<8&&0<=x&&x<8);}\nbool foo=false;\nint cnt,ty,tx;\nvoid init(){foo=false; cnt=0;}\nvoid _set(int a,int b){ty=a;tx=b;cnt=0; foo=false;}\nvoid update(int y,int x,char key){\n    vector<vector<char>>temp;\n    temp=s;\n    init();\n    temp[y][x]=key;\n    for(int i=x+1; i<8;i++){\n        if(temp[y][i]==key){foo=true; break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y][x+1+i]=key;\n    init();\n    for(int i=x-1; i>=0; i--){\n        if(temp[y][i]==key){foo=true;break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y][x-1-i]=key;\n    init();\n    for(int i=y+1; i<8;i++){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+i+1][x]=key;\n    init();\n    for(int i=y-1;i>=0;i--){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-1-i][x]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+1+i][x+1+i]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+1+i][x-1-i]=key;\n    _set(y, x);\n    for(int i=0; i<8;i++){\n        --ty;--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-1-i][x-1-i]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        --ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-i-1][x+1+i]=key;\n    s=temp;\n    \n}\nint cal(int y,int x, char key){\n    vector<vector<char>>temp;\n    temp=s;\n    temp[y][x]=key;\n    int ans=0;\n    init();\n    for(int i=x+1; i<8;i++){\n        if(temp[y][i]==key){foo=true; break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=x-1; i>=0; i--){\n        if(temp[y][i]==key){foo=true;break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=y+1; i<8;i++){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=y-1;i>=0;i--){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y, x);\n    for(int i=0; i<8;i++){\n        --ty;--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        --ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    return ans;\n}\n\nint main(){\n    rep(i,8)rep(j,8)cin>>s[i][j];\n    char key='o';\n    bool flag=false;\n    while(true){\n        int maxi=0;\n        pair<int,int>let;\n        if(key=='o'){\n            for(int i=0; i<8;i++){\n                for(int j=0; j<8;j++){\n                    if(s[i][j]!='.')continue;\n                    int t=cal(i,j,key);\n                    if(t>maxi){\n                        cout<<t<<\" \"<<endl;\n                        cout<<\"y :\"<<i<<\" j \"<<j<<endl;\n                        maxi=t;\n                        let=pair<int,int>(i,j);\n                    }\n                }\n            }\n        }else{\n            for(int i=7; i>=0;i--){\n                for(int j=7; j>=0;j--){\n                    if(s[i][j]!='.')continue;\n                    int t=cal(i,j,key);\n                    if(t>maxi){\n                        maxi=t;\n                        let=pair<int,int>(i,j);\n                    }\n                }\n            }\n            \n        }\n        if(flag&&maxi==0)break;\n        else flag=false;\n        if(maxi==0){flag=true;continue;}\n        update(let.first,let.second,key);\n        key=(key=='o'?'x':'o');\n    }\n    rep(i,8){rep(j,8)cout<<s[i][j]; cout<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\nusing namespace std;\n#define MOD 998244353\n#define INF 1<<30\n#define LINF (ll)1<<62\n#define MAX 510000\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(),(x).end()\n#define uni(q) unique(all(q)),q.end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll, ll> P;\ntypedef vector<pair<ll, ll>> vpl;\nconst int mod = 1e9 + 7;\n\nchar s[8][8];\nll num[8][8];\nll dy[8] = {1,0,-1,0,1,-1,1,-1};\nll dx[8] = {0,1,0,-1,1,-1,-1,1};\nbool direc[8][8][8]; //y,x,direction\n\nbool in(ll y, ll x){\n    return 0<=y && y<8 && 0<=x && x<8;\n}\n\n\nint main(){\n    rep(i,8) rep(j,8) cin >> s[i][j];\n    while(1){\n        bool put = false;\n        ll mx = 0;\n        bool flag = false;\n        rep(i,8) rep(j,8) num[i][j] = 0;\n        rep(i,8){\n            rep(j,8){\n                if(s[i][j] != '.') continue;\n                ll cnt = 0;\n                rep(k,8){\n                    ll ny = i + dy[k];\n                    ll nx = j + dx[k];\n                    if(!in(ny,nx)) continue;\n                    ll kcnt = 0;\n                    while(1){\n                        if(!in(ny,nx)){\n                            kcnt = 0;\n                            direc[i][j][k] = false;\n                            break;\n                        }\n                        if(s[ny][nx]=='x'){\n                            direc[i][j][k] = true;\n                            kcnt++;\n                            ny += dy[k];\n                            nx += dx[k];\n                        }else if(s[ny][nx]=='.'){\n                            kcnt = 0;\n                            direc[i][j][k] = false;\n                            break;\n                        }else{\n                            break;\n                        }\n                    }\n                    cnt += kcnt;\n                }\n                num[i][j] = max(num[i][j], cnt);\n                mx = max(num[i][j],mx);\n            }\n        }\n        if(mx!=0){\n            put = true;\n            rep(i,8){\n                rep(j,8){\n                    if(num[i][j]==mx){\n                        rep(k,8){\n                            if(direc[i][j][k]){\n                                s[i][j] = 'o';\n                                ll ny = i + dy[k];\n                                ll nx = j + dx[k];\n                                while(s[ny][nx]=='x'){\n                                    s[ny][nx] = 'o';\n                                    ny += dy[k];\n                                    nx += dx[k];\n                                }\n                            }\n                        }\n                        flag = true;\n                        break;\n                    }\n                }\n                if(flag) break;\n            }\n        }\n        rep(i,8) rep(j,8) num[i][j] = 0;\n        rep(i,8) rep(j,8) rep(k,8) direc[i][j][k] = false;\n        mx = 0;\n        for(ll i=7; i>=0; i--){\n            for(ll j=7; j>=0; j--){\n                if(s[i][j] != '.') continue;\n                ll cnt = 0;\n                rep(k,8){\n                    ll ny = i + dy[k];\n                    ll nx = j + dx[k];\n                    if(!in(ny,nx)) continue;\n                    ll kcnt = 0;\n                    while(1){\n                        if(!in(ny,nx)){\n                            kcnt = 0;\n                            direc[i][j][k] = false;\n                            break;\n                        }\n                        if(s[ny][nx]=='o'){\n                            direc[i][j][k] = true;\n                            kcnt++;\n                            ny += dy[k];\n                            nx += dx[k];\n                        }else if(s[ny][nx]=='.'){\n                            kcnt = 0;\n                            direc[i][j][k] = false;\n                            break;\n                        }else{\n                            break;\n                        }\n                    }\n                    cnt += kcnt;\n                }\n                num[i][j] = max(num[i][j], cnt);\n                mx = max(num[i][j],mx);\n            }\n        }\n        flag = false;\n        if(mx!=0){\n            put = true;\n            for(ll i=7; i>=0; i--){\n                for(ll j=7; j>=0; j--){\n                    if(mx==num[i][j]){\n                        rep(k,8){\n                            if(direc[i][j][k]){\n                                s[i][j] = 'x';\n                                ll ny = i + dy[k];\n                                ll nx = j + dx[k];\n                                while(s[ny][nx]=='o'){\n                                    s[ny][nx] = 'x';\n                                    ny += dy[k];\n                                    nx += dx[k];\n                                }\n                            }\n                        }\n                        flag = true;\n                        break;\n                    }\n                }\n                if(flag) break;\n            }\n        }\n        if(!put) break;\n        rep(i,8) rep(j,8) rep(k,8) direc[i][j][k] = false;\n    }\n    rep(i,8){\n        rep(j,8) cout << s[i][j];\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nusing namespace std;\nchar in[10][10];\nint dx[]={-1,-1,-1,0,0,1,1,1};\nint dy[]={-1,0,1,-1,1,-1,0,1};\nint f2(char a,char b,int c,int d,int q){\n\tint sum=0;\n\trep(i,8){\n\t\tint co=1;\n\t\tint x=c+dx[i],y=d+dy[i];\n\t\tif(in[x][y]!=a)continue;\n\t\twhile(1){\n\t\t\tx+=dx[i];\n\t\t\ty+=dy[i];\n\t\t\tif(in[x][y]==b){\n\t\t\t\tsum+=co;\n\t\t\t\tif(q){\n\t\t\t\t\tint xx=c,yy=d;\n\t\t\t\t\trep(j,co){\n\t\t\t\t\t\txx+=dx[i];\n\t\t\t\t\t\tyy+=dy[i];\n\t\t\t\t\t\tin[xx][yy]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in[x][y]=='.')break;\n\t\t\tco++;\n\t\t}\n\t}\n\treturn sum;\n}\nbool f(char a,char b){\n\tint ma=0,x,y;\n\tloop(i,1,9)loop(j,1,9)if(in[i][j]=='.'){\n\t\tint d=f2(a,b,i,j,0);\n\t\tif(a=='x'&&ma<d){ma=d;x=i;y=j;}\n\t\tif(a=='o'&&ma<=d){ma=d;x=i;y=j;}\n\t}\n\tif(!ma)return false;\n\tin[x][y]=b;\n\tf2(a,b,x,y,1);\n\treturn true;\n}\nint main(){\n\trep(i,10)rep(j,10)if(!i||!j||i==9||j==9)in[i][j]='.';\n\telse cin>>in[i][j];\n\twhile(f('x','o')+f('o','x')!=0);\n\trep(i,8){rep(j,8)cout<<in[i+1][j+1];cout<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/*繧ェ繧サ繝ュ繝輔ぅ繝シ繝ォ繝?/\nstring field[8];\n\n/*隧穂セ。髢「謨ー*/\n/*player=0 Mami / player=1 Majo*/\nint Evaluation(int x,int y,int player){\n  int n=0;\n  int temp;\n  if(player == 0){\n    \n    /*蜿ウ*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }else{\n    \n    /*蜿ウ*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }\n  \n  return n;\n}\n\n/*逶、髱「蜿肴丐*/\n/*player=0 Mami / player=1 Majo*/\nvoid Reflection(int x,int y,int player){\n  int temp;\n  if(player == 0){\n    \n    /*蜿ウ*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x+j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x-j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x+j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x+j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x-j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x-j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }else{\n    \n    /*蜿ウ*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x+j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x-j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*荳?/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x+j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蜿ウ荳?/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x+j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x-j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*蟾ヲ荳?/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x-j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }\n}\n/*逶、髱「縺悟?縺ヲ蝓九∪縺」縺ヲ縺?◆繧液rue*/\n\nbool flag1,flag2;\n\nbool Mami(){\n  bool flag = true;\n  int n=0,x,y;\n  for(int i=0 ; i < 8 ; i++){\n    for(int j=0 ; j < 8 ; j++){\n      if(field[i][j] == '.'){\n\tint temp = Evaluation(j,i,0);\n\tif(temp > n){\n\t  n = temp;\n\t  x = j;\n\t  y = i;\n \t}\n\tflag = false;\n      }\n    }\n  }\n  if(n > 0){\n    field[y][x]='o';\n    Reflection(x,y,0);\n    flag1 = false;\n  }\n  return flag;\n}\n\nbool Majo(){\n  bool flag = true;\n  int n=0,x,y;\n  for(int i=7 ; i >= 0 ; i--){\n    for(int j=7 ; j >= 0 ; j--){\n      if(field[i][j] == '.'){\n\tint temp = Evaluation(j,i,1);\n\tif(temp > n){\n\t  n = temp;\n\t  x = j;\n\t  y = i;\n \t}\n\tflag = false;\n      }\n    }\n  }\n  if(n > 0){\n    field[y][x]='x';\n    Reflection(x,y,1);\n    flag2 = false;\n  }\n  return flag;\n}\n\nint main(){ \n  \n  for(int i=0 ; i < 8 ; i++)cin >>field[i];\n  \n  /*o縺九ｉ繧ケ繧ソ繝シ繝?/\n  int player = 0; // 0:o 1:x\n  int cnt=0;\n  /*鄂ョ縺?※縺ェ縺??謇?′縺ェ縺上↑繧?縺セ縺溘?縺ゥ縺。繧峨ｂ鄂ョ縺代↑縺上↑繧九∪縺ァ*/\n  while(1){\n    flag1=true;\n    flag2=true;\n    if(player%2 == 0){\n      if(Mami())break;\n    }else{\n      if(Majo())break;\n    }\n    if(flag1 == true && flag2 == true)cnt++;\n    if(flag1 == false || flag2 == false)cnt=0;\n    if(cnt > 1)break;\n    // if(player==17)break;\n    player++;\n  }\n  \n  /*逶、髱「蜃コ蜉?/\n  for(int i=0 ; i < 8 ; i++)cout <<field[i]<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nvector< vector<int> > m(8, vector<int>(8, 0));\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < 8 && 0 <= y && y < 8;\n}\nint f(int x, int y, int dx, int dy, int turn, bool isReplace) {\n//\tcout << x << \" \" << y << \" \" << endl;\n\tif ( !inRange(x, y) ) return -inf;\n\tif ( m[y][x] == 0 ) return -inf;\n\tif ( m[y][x] == turn ) return 0;\n\tint res = f(x+dx, y+dy, dx, dy, turn, isReplace)+1;\n\tif (res > 0 && isReplace) {\n\t\tm[y][x] = turn;\n\t}\n\treturn res;\n}\nint f(int x, int y, int turn, bool isReplace) {\n\tint res = 0;\n\tif (m[y][x] != 0) return 0;\n\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\tif (dx == 0 && dy == 0) continue;\n//\t\t\tcout << \":\" << dx << \" \" << dy << endl;\n\t\t\tint dr = f(x+dx, y+dy, dx, dy, turn, isReplace);\n\t\t\tif (dr >= 0) res += dr;\n\t\t}\n\t}\n\tif (res <= 0) return 0;\n\tif (isReplace) m[y][x] = turn;\n\treturn res+1;\n}\nvoid out() {\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tif (m[i][j] == 0) cout << \".\";\n\t\t\tif (m[i][j] == 1) cout << \"o\";\n\t\t\tif (m[i][j] == 2) cout << \"x\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tREP(i, 8) {\n\t\tstring str; cin >> str;\n\t\tREP(j, 8) {\n\t\t\tm[i][j] = str[j] == 'o' ? 1 : str[j] == 'x' ? 2 : 0;\n\t\t}\n\t}\n\tREP(t, 150) {\n\t\t{\n\t\t\tvector< tuple<int, int, int> > v;\n\t\t\tREP(i, 8) REP(j, 8) {\n\t\t\t\tint n = f(j, i, 1, false);\n\t\t\t\tif (n > 0) v.pb( make_tuple(-n, i, j) );\n\t\t\t}\n\t\t\tif (v.size() > 0) {\n\t\t\t\tsort( ALL(v) );\n\t\t\t\tf(get<2>(v[0]), get<1>(v[0]), 1, true);\n\t\t\t}\n\t\t}\n//\t\tout(); cout << endl;\n\t\t{\n\t\t\tvector< tuple<int, int, int> > v;\n\t\t\tREP(i, 8) REP(j, 8) {\n\t\t\t\tint n = f(j, i, 2, false);\n\t\t\t\tif (n > 0) v.pb( make_tuple(-n, -i, -j) );\n\t\t\t}\n\t\t\tif (v.size() > 0) {\n//\t\t\t\tcout << -get<2>(v[0]) << \" \" << -get<1>(v[0]) << endl;\n\t\t\t\tsort( ALL(v) );\n\t\t\t\tf(-get<2>(v[0]), -get<1>(v[0]), 2, true);\n\t\t\t}\n\t\t}\n//\t\tout(); cout << endl;\n\t}\n\tout();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <functional>\n#include <algorithm>\nusing namespace std;\ntypedef tuple<int,int,int> tiii;\ntypedef struct{\n\tint x;\n\tint y;\n}dir;\nvector<dir>D={\n\t{-1,-1},{0,-1},{1,-1},\n\t{-1,0},{1,0},\n\t{-1,1},{0,1},{1,1},\n};\n\nconst int H=8,W=8;\nvector<function<bool(tiii,tiii)> >sorter={//{num,x,y}\n\t[](tiii a,tiii b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)>get<2>(b))return true;\n\t\tif(get<2>(a)<get<2>(b))return false;\n\t\tif(get<1>(a)>get<1>(b))return true;\n\t\tif(get<1>(a)<get<1>(b))return false;\n\t\treturn false;\n\t},\n\t[](tiii a,tiii b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)<get<2>(b))return true;\n\t\tif(get<2>(a)>get<2>(b))return false;\n\t\tif(get<1>(a)<get<1>(b))return true;\n\t\tif(get<1>(a)>get<1>(b))return false;\n\t\treturn false;\n\t}\n};\n\nint check2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=check2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\treturn r+1;\n}\nint check1(int color,int x,int y,vector<string>&m){\n\tint R=-1;\n\tfor(auto &d:D){\n\t\tint r=check2(color,d,x+d.x,y+d.y,m);\n\t\tif(r>0){\n\t\t\tif(R<0)R=0;\n\t\t\tR+=r;\n\t\t}\n\t}\n\treturn R;\n}\n\nint fill2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=fill2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\tm[y][x]=color;\n\treturn r+1;\n}\nvoid fill1(int color,int x,int y,vector<string>&m){\n\tfor(auto &d:D)fill2(color,d,x+d.x,y+d.y,m);\n}\n\nint main(){\n\tstring color=\"ox\";\n\tvector<string>m(H);\n\tfor(int h=0;h<H;h++)cin>>m[h];\n\tint turn=0,pass=0;\n\tfor(;;turn^=1){\n\t\tvector<tiii>v;\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)if(m[y][x]=='.'){\n\t\t\tint r=check1(color[turn],x,y,m);\n\t\t\tif(r>0)v.push_back(make_tuple(r,x,y));\n\t\t}\n\t\tif(v.empty()){\n\t\t\tpass++;\n\t\t\tif(pass>1)break;\n\t\t}else{\n\t\t\tpass=0;\n\t\t\tsort(v.begin(),v.end(),sorter[turn]);\n\t\t\ttiii &t=*v.rbegin();\n\t\t\tint x=get<1>(t),y=get<2>(t);\n\t\t\tfill1(color[turn],x,y,m);\n\t\t\tm[y][x]=color[turn];\n\t\t}\n\t}\n\tfor(int h=0;h<H;h++)cout<<m[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <functional>\n#include <algorithm>\nusing namespace std;\ntypedef tuple<int,int,int> tiii;\n\ntypedef struct{\n\tint x;\n\tint y;\n}dir;\nvector<dir>D={\n\t{-1,-1},{0,-1},{1,-1},\n\t{-1,0},{1,0},\n\t{-1,1},{0,1},{1,1},\n};\n\nconst int H=8,W=8;\nvector<function<bool(tiii,tiii)> >sorter={\n\t[](tiii a,tiii b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)>get<2>(b))return true;\n\t\tif(get<2>(a)<get<2>(b))return false;\n\t\tif(get<1>(a)>get<1>(b))return true;\n\t\tif(get<1>(a)<get<1>(b))return false;\n\t\treturn false;\n\t},\n\t[](tiii a,tiii b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)<get<2>(b))return true;\n\t\tif(get<2>(a)>get<2>(b))return false;\n\t\tif(get<1>(a)<get<1>(b))return true;\n\t\tif(get<1>(a)>get<1>(b))return false;\n\t\treturn false;\n\t}\n};\n\nint check2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=check2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\treturn r+1;\n}\nint check1(int color,int x,int y,vector<string>&m){\n\tint R=-1;\n\tfor(auto &d:D){\n\t\tint r=check2(color,d,x+d.x,y+d.y,m);\n\t\tif(r>0){\n\t\t\tif(R<0)R=0;\n\t\t\tR+=r;\n\t\t}\n\t}\n\treturn R;\n}\n\nint fill2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=fill2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\tm[y][x]=color;\n\treturn r+1;\n}\nvoid fill1(int color,int x,int y,vector<string>&m){\n\tfor(auto &d:D){\n\t\tfill2(color,d,x+d.x,y+d.y,m);\n\t}\n}\n\nint main(){\n\tstring color=\"ox\";\n\tvector<string>m(H);\n\tfor(int h=0;h<H;h++)cin>>m[h];\n\tint turn=0,pass=0;\n\tfor(;;){\n\t\tvector<tiii>v;\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)if(m[y][x]=='.'){\n\t\t\tint r=check1(color[turn],x,y,m);\n\t\t\tif(r>0)v.push_back(make_tuple(r,x,y));\n\t\t}\n\t\tif(v.empty()){\n\t\t\tpass++;\n\t\t\tif(pass>1)break;\n\t\t}else{\n\t\t\tpass=0;\n\t\t\tsort(v.begin(),v.end(),sorter[turn]);\n\t\t\ttiii &t=*v.rbegin();\n\t\t\tfill1(color[turn],get<1>(t),get<2>(t),m);\n\t\t\tm[get<2>(t)][get<1>(t)]=color[turn];\n\t\t}\n\t\tturn^=1;\n\t}\n\tfor(int h=0;h<H;h++)cout<<m[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n\nvector<string> s(10, string(10, '.'));\nint dx[8] = { 1,0,-1,0,-1,-1,1,1 };\nint dy[8] = { 0,1,0,-1,-1,1,-1,1 };\n\ntypedef pair<int, int> P;\nmap<char, char> rv;\n\nint count(vector<string> v, char c) {\n\tint cnt = 0;\n\trep(i, v.size()) {\n\t\trep(j, v[i].size()) {\n\t\t\tif (v[i][j] == c) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvector<string> put(int y, int x, char c) {\n\tauto ts = s;\n\tts[y][x] = c;\n\trep(i, 8) {\n\t\tint ty = y + dy[i], tx = x + dx[i];\n\t\tint cnt = 0;\n\t\tvector<P> ch;\n\t\twhile (1) {\n\t\t\tif (rv[ts[ty][tx]] != c) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch.push_back(P(ty, tx));\n\t\t\tty += dy[i]; tx += dx[i];\n\t\t}\n\t\tif (ts[ty][tx] == c) {\n\t\t\teach(p, ch) {\n\t\t\t\tts[p.first][p.second] = c;\n\t\t\t}\n\t\t}\n\t}\n\treturn ts;\n}\n\nP maxPoint(char c) {\n\tint ma = 0, now = count(s, c);\n\tP p(-1, -1);\n\n\tif (c == 'o') {\n\t\tfor (int y = 1; y <= 8; y++) {\n\t\t\tfor (int x = 1; x <= 8; x++) {\n\t\t\t\tif (s[y][x] == '.') {\n\t\t\t\t\tint next = count(put(y, x, c), c);\n\t\t\t\t\tif (ma < next && next > now + 1) {\n\t\t\t\t\t\tma = next;\n\t\t\t\t\t\tp = P(y, x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int y = 8; y >= 1; y--) {\n\t\t\tfor (int x = 8; x >= 1; x--) {\n\t\t\t\tif (s[y][x] == '.') {\n\t\t\t\t\tint next = count(put(y, x, c), c);\n\t\t\t\t\tif (ma < next && next > now + 1) {\n\t\t\t\t\t\tma = next;\n\t\t\t\t\t\tp = P(y, x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn p;\n}\n\nint main() {\n\tfor (int y = 1; y <= 8; y++) {\n\t\tcin >> s[y];\n\t\ts[y] = \".\" + s[y] + \".\";\n\t}\n\trv['o'] = 'x';\n\trv['x'] = 'o';\n\trv['.'] = '.';\n\n\tstring tb = \"ox\";\n\n\tint wait = 0;\n\tfor (int i = 0;; i++) {\n\t\tchar c = tb[i % 2];\n\t\tauto p = maxPoint(c);\n\t\tif (p.first == -1) {\n\t\t\twait++;\n\t\t\tif (wait == 2)break;\n\t\t\tcontinue;\n\t\t}\n\t\ts = put(p.first, p.second, c);\n\t}\n\n\tfor (int y = 1; y <= 8; y++) {\n\t\tfor (int x = 1; x <= 8; x++) {\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint W = 8, H = 8;\nint dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nint dy[] = {0, -1, 0, 1, 1, -1, 1, -1};\n\nchar cookie[] = {'o', 'x'};\nstring field[8];\n\nint turnNum(int x, int y, int d, int n, char c)\n{\n    if(x < 0 || y < 0 || x >= W || y >= H) return 0;\n    \n    if(field[y][x] == c) return n;\n    if(field[y][x] == '.') return 0;\n\n    int tx = x + dx[d];\n    int ty = y + dy[d];\n    \n    return turnNum(tx, ty, d, n + 1, c);\n}\n\nbool turn(int x, int y, int d, char c)\n{\n    if(x < 0 || y < 0 || x >= W || y >= H) return false;\n    if( field[y][x] == '.') return false;\n    if( field[y][x] == c) return true;\n    \n    int tx = x + dx[d];\n    int ty = y + dy[d];\n\n    if(turn(tx,ty,d,c) == true) field[y][x] = c;\n}\n\nvoid solve()\n{\n    int t = 0;\n    int pass = 0;\n    \n    while(1) {\n\tint mx = 0;\n\tint px = -1, py = -1;\n\n\tint start = (t%2==0 ? 0 : H-1);\n\tint end = (t%2==0 ? H : 0);\n\tfor(int i=start; (t%2==0?i<end:i>=0); (t%2==0?i++:i--))\n\t    for(int j=start; (t%2==0?j<end:j>=0); (t%2==0?j++:j--)) {\n\t\tif(field[i][j] !='.') continue;\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int k=0; k<8; k++)\n\t\t    cnt += turnNum(j+dx[k], i+dy[k], k, 0, cookie[t%2]);\n\n\t\tif(cnt > mx) {\n\t\t    mx = cnt;\n\t\t    px = j;\n\t\t    py = i;\n\t\t}\n\t    }\n\n\tif(px == -1) {\n\t    pass++;\n\n\t    if( pass == 2) break;\n\t}\n\telse {\n\t    pass = 0;\n\t    \n\t    field[py][px] = cookie[t%2];\n\t    for(int i=0; i<8; i++)\n\t\tturn(px+dx[i], py+dy[i], i, cookie[t%2]);\n\t}\n\n\tt++;\n    }\n}\n\nint main()\n{\n    for(int i=0; i<H; i++)\n\tcin >> field[i];\n\n    solve();\n\n    for(int i=0; i<H; i++)\n\tcout << field[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint dx[] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nint rev(int n) {\n    return n == 1 ? 2 : 1;\n}\n\nbool inFloor(int x, int y) {\n    if (0 <= x && x < 8 && 0 <= y && y < 8) return true;\n    return false;\n}\n\nint main() {\n    mat d(8, vec(8));\n\n    for (auto &i : d) {\n        for (auto &j : i) {\n            char c; cin >> c;\n            if (c == 'o') j = 1;\n            if (c == 'x') j = 2;\n        }\n    }\n\n    int turn = 1;\n    int pass = 0;\n    while (1) {\n        int tx(-1), ty(-1);\n        int count = 1;\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0 ; j < 8; j++) {\n                if (d[i][j] == 0) {\n                    int count_ = 0;\n                    for (int k = 0; k < 8; k++) {\n                        int x = i + dx[k];\n                        int y = j + dy[k];\n                        int tmp = 0;\n                        while (inFloor(x, y) && d[x][y] == rev(turn)) {\n                            x += dx[k], y += dy[k];\n                            tmp++;\n                        }\n                        if (inFloor(x,y) && d[x][y] == turn) count_ += tmp;\n                    }\n\n                    if (count < count_ || (count_ > 0 && tx < 0)) {\n                        tx = i; ty = j; count = count_;\n                    } else if (count == count_) {\n                        if (turn == 1) {\n                            if (tx > i) tx = i, ty = j;\n                            else if (tx == i && ty > j) ty = j;\n                        } else {\n                            if (tx < i) tx = i, ty = j;\n                            else if (tx == i && ty < j) ty = j;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (tx > -1) {\n            d[tx][ty] = turn;\n            for (int i = 0; i < 8; i++) {\n                int x = tx + dx[i];\n                int y = ty + dy[i];\n                while (inFloor(x, y) && d[x][y] == rev(turn)) {\n                    x += dx[i], y += dy[i];\n                }\n                if (inFloor(x, y) && d[x][y] == turn)\n                    while (inFloor(x, y) && d[(x+=dx[(i+4)%8])][(y+=dy[(i+4)%8])] == rev(turn))\n                        d[x][y] = turn;\n            }\n            pass = 0;\n        } else pass++;\n        if (pass == 2) break;\n\n        turn = rev(turn);\n    }\n\n    for (auto i : d) {\n        for (auto j : i) {\n            if (j == 1) cout << 'o';\n            else if (j == 2) cout << 'x';\n            else cout << '.';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> mov;\n\nchar S[8][8];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < 8 && 0 <= x && x < 8;\n}\n\nint main(void) {\n  REP(i, 0, 8) cin >> S[i];\n\n  char me = 'o';\n  char op = me == 'x' ? 'o' : 'x';\n  char em = '.';\n  int pass = 0;\n  while(1) {\n    int ans = 0, ay = -1, ax = -1;\n    vector<mov> mv;\n    REP(i, 0, 8) REP(j, 0, 8) {\n      if(S[i][j] != em) continue;\n      int cnt = 0;\n      vector<mov> v;\n      REP(k, -1, 2) REP(l, -1, 2) {\n        int y = i, x = j;\n        if(k == 0 && l == 0) continue;\n        int q = 0;\n        while(1) {\n          y += k;\n          x += l;\n          if(!isin(y, x)) break;\n          if(S[y][x] == op) q++;\n          else break;\n        }\n        if(!(isin(y, x) && S[y][x] == me)) q = 0;\n        cnt += q;\n        if(q > 0) v.push_back(mov(pii(k, l), q));\n      }\n      if((me == 'o' && ans < cnt) || (me == 'x' && ans <= cnt)) {\n        mv = v;\n        ans = cnt;\n        ay = i;\n        ax = j;\n      }\n    }\n    if(mv.size() > 0) {\n      S[ay][ax] = me;\n      REP(i, 0, mv.size()) {\n        int y = ay, x = ax;\n        REP(j, 0, mv[i].se) {\n          y += mv[i].fi.fi;\n          x += mv[i].fi.se;\n          S[y][x] = me;\n        }\n      }\n      pass = 0;\n    } else {\n      if(pass == 1) break;\n      pass = 1;\n    }\n    swap(me, op);\n  }\n\n  REP(i, 0, 8) {\n    REP(j, 0, 8) cout << S[i][j];\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nint dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nint main()\n{\n\tvector<string> s(8);\n\tfor(int i=0; i<8; ++i)\n\t\tcin >> s[i];\n\n\tbool ng = false;\n\tchar my = 'o';\n\tchar your = 'x';\n\tfor(;;){\n\t\tint y0;\n\t\tint x0;\n\t\tint maxNum = 0;\n\t\tfor(int i=0; i<8; ++i){\n\t\t\tfor(int j=0; j<8; ++j){\n\t\t\t\tif(s[i][j] != '.')\n\t\t\t\t\tcontinue;\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int k=0; k<8; ++k){\n\t\t\t\t\tint y = i + dy[k];\n\t\t\t\t\tint x = j + dx[k];\n\t\t\t\t\twhile(0 <= y && y < 8 && 0 <= x && x < 8 && s[y][x] == your){\n\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t}\n\t\t\t\t\tif(0 <= y && y < 8 && 0 <= x && x < 8 && s[y][x] == my){\n\t\t\t\t\t\tnum += max(abs(y - i) - 1, abs(x - j) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif((my == 'o' && num > maxNum) || (my == 'x' && num >= maxNum)){\n\t\t\t\t\tmaxNum = num;\n\t\t\t\t\ty0 = i;\n\t\t\t\t\tx0 = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(maxNum == 0){\n\t\t\tif(ng)\n\t\t\t\tbreak;\n\t\t\tng = true;\n\t\t}else{\n\t\t\tng = false;\n\t\t\ts[y0][x0] = my;\n\t\t\tfor(int i=0; i<8; ++i){\n\t\t\t\tint y = y0 + dy[i];\n\t\t\t\tint x = x0 + dx[i];\n\t\t\t\twhile(0 <= y && y < 8 && 0 <= x && x < 8 && s[y][x] == your){\n\t\t\t\t\ty += dy[i];\n\t\t\t\t\tx += dx[i];\n\t\t\t\t}\n\t\t\t\tif(0 <= y && y < 8 && 0 <= x && x < 8 && s[y][x] == my){\n\t\t\t\t\ty = y0 + dy[i];\n\t\t\t\t\tx = x0 + dx[i];\n\t\t\t\t\twhile(0 <= y && y < 8 && 0 <= x && x < 8 && s[y][x] == your){\n\t\t\t\t\t\ts[y][x] = my;\n\t\t\t\t\t\ty += dy[i];\n\t\t\t\t\t\tx += dx[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswap(my, your);\n\t}\n\n\tfor(int i=0; i<8; ++i)\n\t\tcout << s[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\nchar field[8][8];\nint dx[8] = { 0, 0,-1,-1,-1, 1, 1, 1};\nint dy[8] = { 1,-1, 0, 1,-1,0, 1, -1};\nchar cookies[2] = {'o','x'};\nchar rev(char m){\n  if(m == 'o')return 'x';\n  else if(m == 'x')return 'o';\n  return '.';\n}\nvoid print_field(){\n  for(int i = 0;i < 8;i++){\n\t  for(int j = 0;j < 8;j++){\n\t\tcout << field[i][j];\n\t}\n\tcout << endl;\n  }\n}\n\nbool replace(int k,char m,int x,int y){\n  if(x < 0 || x >= 8 || y < 0 || y >= 8 || field[y][x] == '.')return false;\n  if(m == field[y][x])return true;\n  else if(field[y][x] == rev(m) && replace(k,m,x+dx[k],y+dy[k])){\n\tfield[y][x] = m;\n\treturn true;\n  }\n  return false;\n}\n\nint check(int k,char m,int x,int y,int cnt){\n  if(x < 0 || x >= 8 || y < 0 || y >= 8 || field[y][x] == '.')return 0;\n  assert(field[y][x] != '.');\n  if(field[y][x] == rev(m)){\n\treturn check(k,m,x+dx[k],y+dy[k],cnt+1);\n  } \n  assert(field[y][x] == m);\n  return cnt;\n}\n\nint main(){\n\n  for(int i = 0;i < 8;i++){\n\tfor(int j = 0;j < 8;j++){\n\t  cin >> field[i][j];\n\t}\n  }\n  int turn = 0;\n  int f = 0;\n  while(1){\n\tturn %= 2;\n\t\n\tint m_cnt = 0;\n\tint m_x = -10;\n\tint m_y = -10;\n\t\n\tfor(int i = 0;i < 8;i++){\n\t  for(int j = 0;j < 8;j++){\n\t\tint k_x,k_y;\n\t\tint tmp = 0;\n\t\tk_x = j;\n\t\tk_y = i;\n\t\tif(turn == 1){\n\t\t  k_x = 7-j;\n\t\t  k_y = 7-i;\n\t\t}\n\t\tif(field[k_y][k_x] != '.')continue;\n\t\tfor(int k = 0;k < 8;k++){\n\t\t  tmp += check(k,cookies[turn],k_x+dx[k],k_y+dy[k],0);\n\t\t}\n\n\t\tif(m_cnt < tmp){\n\t\t  m_cnt = tmp;\n\t\t  m_x = k_x;\n\t\t  m_y = k_y;\n\t\t}\n\t  }\n\t}\n\tif(m_cnt != 0){\n\t  field[m_y][m_x] = cookies[turn];\n\t  for(int k = 0;k < 8;k++){\n\t\treplace(k,cookies[turn],m_x+dx[k],m_y+dy[k]);\n\t  }\n\t  f = 0;\n\t}else{\n\t  f++;\n\t  if(f == 2)break;\n\t}\n\t\n\tturn++;\n  }\n\n\n  print_field();\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px) - 1, abs(y - py) - 1);\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px || qy != py) {\n\t\t\t\t\tc[qy][qx] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) {\n\t\t\t\tv = 1; t++; continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tplace(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing P = pair<ll, ll>;\nusing P3 = pair<P,ll>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1 << 30;\nconstexpr ll MOD = ll(1e9)+7;\nconstexpr int di[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconstexpr int dj[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconstexpr double EPS = 1e-9;\n\nint n = 8;\nvector<string> s(n);\n\nbool isIn(int i, int j){\n    return i>=0 && i<n & j>=0 && j<n;\n}\n\nint count(int i, int j, char c){\n    int res = 0;\n    for(int k=0;k<8;k++){\n        int ni = i+di[k], nj = j+dj[k];\n        int cnt = 0;\n        while(1){\n            if(!isIn(ni,nj) || s[ni][nj] == '.'){\n                cnt = 0;\n                break;\n            }\n            else if(s[ni][nj]==c) break;\n            else {\n                cnt++;\n                ni += di[k]; nj += dj[k];\n            }\n        }\n        res += cnt;\n    }\n    return res;\n}\n\nvoid put(int i, int j, char c){\n    for(int k=0;k<8;k++){\n        int ni = i+di[k], nj = j+dj[k];\n        while(1){\n            if(!isIn(ni,nj) || s[ni][nj] == '.'){\n                break;\n            }\n            else if(s[ni][nj]==c){\n                while(1){\n                    ni -= di[k]; nj -= dj[k];\n                    s[ni][nj] = c;\n                    if(ni == i && nj == j) break;\n                }\n                break;\n            }\n            else {\n                ni += di[k]; nj += dj[k];\n            }\n        }\n    }\n}\n\nint solve(){\n    for(int i=0;i<n;i++){\n        cin >> s[i];\n    }\n    bool turn = true;\n    bool update = true;\n    while(1){\n        int pi = -1, pj = -1, maxi = 0;\n        char c = (turn ? 'o' : 'x');\n        if(turn){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(s[i][j] != '.') continue;\n                    int cnt = count(i,j,c);\n                    if(cnt > maxi){\n                        pi = i; pj = j;\n                        maxi = cnt; \n                    }\n                }\n            }\n        }else{\n            for(int i=n-1;i>=0;i--){\n                for(int j=n-1;j>=0;j--){\n                    if(s[i][j] != '.') continue;\n                    int cnt = count(i,j,c);\n                    if(cnt > maxi){\n                        pi = i; pj = j;\n                        maxi = cnt;\n                    }\n                }\n            }\n        }\n        if(maxi > 0){\n            put(pi, pj, c);\n            update = true;\n        }else{\n            if(!update) break;\n            update = false;\n        }\n        turn = !turn;\n    }\n    for(int i=0;i<n;i++){\n        cout << s[i] << endl;\n    }\n    return 0;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\n//const int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nconst int dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,-1,0,1,1,-1,1,-1};\n\nconst int n=8;\nint a[n][n];\n\nint main(){\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='o') a[i][j]=1;\n\t\tif(c=='x') a[i][j]=-1;\n\t}\n\tint B=1;\n\tbool flag=0;\n\twhile(1){\n\t\tint mx=0,I,J;\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(a[i][j]==0){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tint x=i+dx[k],y=j+dy[k],tmp=0;\n\t\t\t\twhile(x>=0&&x<n&&y>=0&&y<n&&a[x][y]==-B){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t\tif(x>=0&&x<n&&y>=0&&y<n&&a[x][y]==B) cnt+=tmp;\n\t\t\t}\n\t\t\tif(cnt>=mx){\n\t\t\t\tif(B==1){\n\t\t\t\t\tif(cnt>mx) I=i,J=j;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tI=i,J=j;\n\t\t\t\t}\n\t\t\t\tmx=cnt;\n\t\t\t}\n\t\t}\n\t\tif(mx>0){\n\t\t\tflag=0;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tint x=I+dx[k],y=J+dy[k];\n\t\t\t\twhile(x>=0&&x<n&&y>=0&&y<n&&a[x][y]==-B){\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t\tif(x>=0&&x<n&&y>=0&&y<n&&a[x][y]==B){\n\t\t\t\t\tx-=dx[k],y-=dy[k];\n\t\t\t\t\twhile(x>=0&&x<n&&y>=0&&y<n&&a[x][y]==-B){\n\t\t\t\t\t\ta[x][y]=B;\n\t\t\t\t\t\tx-=dx[k],y-=dy[k];\n\t\t\t\t\t}\n\t\t\t\t\ta[x][y]=B;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(flag) break;\n\t\t\tflag=1;\n\t\t}\n\t\tB*=-1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(a[i][j]==1) cout<<'o';\n\t\t\tif(a[i][j]==-1) cout<<'x';\n\t\t\tif(a[i][j]==0) cout<<'.';\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nvoid solve(vector<string>& s){\n    for(bool turn=true, pass=false; ; turn=!turn){\n        tuple<int, int, int, vector<string> > best = {0, turn? -8: 0, turn? -8: 0, s};\n        rep(x, 8)rep(y, 8)if(s[x][y] == '.'){\n            char my = turn? 'o': 'x', your = turn? 'x': 'o';\n            int cnt = 0;\n            vector<string> t = s; t[x][y] = my;\n            for(int dx=-1; dx<=1; ++dx){\n                for(int dy=-1; dy<=1; ++dy){\n                    int nx = x + dx, ny = y + dy;\n                    if((dx|dy) == 0 || !inrect(nx, ny) || s[nx][ny] != your)continue;\n                    vector<string> tmp = t;\n                    while(inrect(nx, ny) && s[nx][ny] == your){\n                        tmp[nx][ny] = my; nx += dx; ny += dy;\n                    }\n                    if(inrect(nx, ny) && s[nx][ny] == my){\n                        cnt += max(abs(x - nx) - 1, abs(y - ny) - 1);\n                        t.swap(tmp);\n                    }\n                }\n            }\n            if(cnt)chmax(best, make_tuple(cnt, turn? -x: x, turn? -y: y, t));\n        }\n        if(get<0>(best) == 0){\n            if(pass)break; else pass = true;\n        }\n        else{\n            if(pass)pass = false;\n            s.swap(get<3>(best));\n        }\n    }\n}\n\nint main(){\n    vector<string> s(8);\n    rep(i, 8)cin >> s[i];\n    solve(s);\n    rep(i, 8)cout << s[i] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n};\n\nstate flip(int x, int y, state s, bool turn){\n    const char cs[] = \"xo\";\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        const int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n        const int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        if (!valid(cx, cy) || s.g[cy][cx] == cs[turn]) continue;\n        while (valid(cx, cy) && s.g[cy][cx] == cs[!turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cx, cy) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i];\n                !(ix == cx && iy == cy);\n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[!turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n        s.score[turn]++;\n        s.score[!turn]--;\n    }\n    return s;\n}\n\nint main(){\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    for (int turn = 1; turn <= 64; turn++){\n        state next = cur;\n        for (int y = 0; y < 8; y++){\n            for (int x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 1 && next.score[1] < cand.score[1]) ||\n                        ((turn & 1) == 0 && next.score[0] <= cand.score[0])){\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        cur = next;\n    }\n\n    for (int i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int NUM = 8;\n\nstring field[NUM];\n\nint check(int y, int x, char cookie){\n  int res = 0;\n  \n  for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if(!i && !j) continue;\n      int num = 0;\n      for(int nx = x+j, ny = y+i; 0 <= nx && nx < NUM && 0 <= ny && ny < NUM ; ny += i,nx += j){\n\tif(field[ny][nx] == cookie){\n\t  res += num;\n\t  break;\n\t} else if(field[ny][nx] == '.'){\n\t  break;\n\t} else {\n\t  num++;\n\t}\n      }\n    }\n  }\n  return res;\n}\n\nvoid put(int y, int x, char cookie){\n\n  field[y][x] = cookie;\n  \n   for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if(!i && !j) continue;\n      bool flag = false;\n      for(int nx = x+j, ny = y+i, n; 0 <= nx && nx < NUM && 0 <= ny && ny < NUM ; ny += i,nx += j){\n\tif(field[ny][nx] == cookie){\n\t  flag = true;\n\t  break;\n\t} else if(field[ny][nx] == '.'){\n\t  break;\n\t} else {\n\t}\n      }\n\n\tif(flag){\n\t  for(int nx = x+j, ny = y+i, n; 0 <= nx && nx < NUM && 0 <= ny && ny < NUM ; ny += i,nx += j){\n\t     if(field[ny][nx] == cookie){\n\t       break;\n\t     } else if(field[ny][nx] == '.'){\n\t       break;\n\t     } else {\n\t       field[ny][nx] = cookie;\n\t     }\n\t  }\n\t}\n\t\n    }\n   }\n}\n   \nvoid print(){\n    for(int i = 0; i < NUM; i++){\n    cout<<field[i]<<endl;\n  }\n}\n\nsigned main(){\n\n  for(int i = 0; i < NUM; i++){\n    cin>>field[i];\n  }\n\n  while(true){\n    pair<int,pair<int,int> > TOMOEMAMI, CHARLOTTE;\n    \n    for(int i = 0; i < NUM; i++){\n      for(int j = 0; j < NUM; j++){\n\tif(field[i][j] != '.') continue;\n\tint num = check(i,j, 'o');\n\tif(TOMOEMAMI.first < num) TOMOEMAMI = make_pair(num,make_pair(i,j));\n      }\n    }\n    if(TOMOEMAMI.first) put(TOMOEMAMI.second.first, TOMOEMAMI.second.second,'o');\n    \n    \n    for(int i = NUM-1; i >= 0; i--){\n      for(int j = NUM-1; j >= 0; j--){\n\tif(field[i][j] != '.') continue;\n\tint num = check(i,j, 'x');\n\t\n\tif(CHARLOTTE.first < num) CHARLOTTE = make_pair(num,make_pair(i,j));\n      }\n    }\n    if(CHARLOTTE.first) put(CHARLOTTE.second.first,CHARLOTTE .second.second,'x');\n\n    if(!TOMOEMAMI.first && !CHARLOTTE.first) break;\n  }\n\n  \n  print();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[8] = {-1,-1,-1,0,1,1,1,0};\nint dy[8] = {0,1,-1,1,-1,0,1,-1};\n\nbool inrange(int x,int y){\n  if(x<0||y<0||x>7||y>7) return false;\n  else return true;\n}\n\nchar hit[3] = \"ox\";\nint changeban(char wmap[8][8],int turn,int x,int y){\n  int cnt = 0;\n  REP(i,8){\n    bool changable = false;\n    int nx = x+dx[i]; int ny = y+dy[i];\n    if(!inrange(nx,ny)) continue;\n    while(1){\n      if(!inrange(nx,ny)) break;\n      if(wmap[nx][ny]=='.') break;\n      if(wmap[nx][ny]==hit[turn]) changable = true;\n      nx += dx[i]; ny+= dy[i];\n    }\n    if(changable){\n      nx = x+dx[i]; ny = y+dy[i];\n      while(wmap[nx][ny]!=hit[turn]){\n        cnt++;\n        wmap[nx][ny] = hit[turn];\n        nx += dx[i]; ny+= dy[i];\n      }\n    }\n  }\n  return cnt;\n}\n\n//MAXとなるところにさす\nint max_search(char ban[8][8],int turn){\n  char bkup[8][8];\n  char ansban[8][8];\n  REP(i,8) REP(j,8) ansban[i][j] = ban[i][j];\n  int maxchan = -1;\n  if(turn==0){\n    for(int i=7;i>-1;i--){\n      for(int j=7;j>-1;j--){\n        if(ban[i][j]=='.'){\n          REP(k,8) REP(l,8) bkup[k][l] = ban[k][l];\n          bkup[i][j]=hit[turn];\n          int rst = changeban(bkup,turn,i,j);\n          if((maxchan<=rst)&&(rst!=0)){\n            maxchan = rst;\n            REP(k,8) REP(l,8) ansban[k][l] = bkup[k][l];\n          }\n        }\n      }\n    }\n  }else{\n    REP(i,8){\n      REP(j,8){\n        if(ban[i][j]=='.'){\n          REP(k,8) REP(l,8) bkup[k][l] = ban[k][l];\n          bkup[i][j]=hit[turn];\n          int rst = changeban(bkup,turn,i,j);\n          if((maxchan<=rst)&&(rst!=0)){\n            //cout << \"(\" << i <<\",\" <<j <<\")\" <<\"num: \" << rst << endl;\n            maxchan = rst;\n            REP(k,8) REP(l,8) ansban[k][l] = bkup[k][l];\n          }\n        }\n      }\n    }\n  }\n  REP(i,8) REP(j,8) ban[i][j] = ansban[i][j];\n  return maxchan;//-1,0ならさせない\n}\n\nvoid ShowBan(char data[8][8]){\n  REP(i,8){\n    REP(j,8){\n      cout << data[i][j];\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  char data[8][8];\n  REP(i,8){\n    scanf(\"%s\",data[i]);\n  }\n  while(1){\n    //2人もおけないならend\n    int rst1 = max_search(data,0);\n    //ShowBan(data);\n    int rst2 = max_search(data,1);\n    //ShowBan(data);\n    if((rst1<=0)&&(rst2<=0)) break;\n  }\n  ShowBan(data);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\nconst int dx[] = { 1,0,-1,0,1,-1,-1,1 };\nconst int dy[] = { 0,1,0,-1,1,1,-1,-1 };\n\nint32_t main() {\n    const int n = 8;\n    vector<string> s(n); cin >> s;\n    auto valid = [&](int i, int j) {\n        return (0 <= i && i < n &&\n                0 <= j && j < n);\n    };\n\n    auto f = [&](int i, int j, char c, bool flip = false) -> int {\n        char d = c^'o'^'x';\n        if (s[i][j] != '.') return 0;\n        if (flip) s[i][j] = c;\n        int ans = 0;\n        rep (dir,8) {\n            int x = i+dx[dir], y = j+dy[dir];\n            int cnt = 0;\n            while (valid(x,y) && s[x][y] == d) {\n                cnt++, x += dx[dir], y += dy[dir];\n            }\n            if (valid(x,y) && s[x][y] == c) {\n                ans += cnt;\n                if (flip) {\n                    x = i, y = j;\n                    rep (_,cnt) x += dx[dir], y += dy[dir], s[x][y] = c;\n                }\n            }\n        }\n        return ans;\n    };\n\n    while (true) {\n        debug {\n            rep (i,n) cerr << s[i] << endl;\n            cerr << endl;\n        }\n\n        bool update = false;\n        int ma = 0, x = -1, y = -1;\n        rep (i,n) rep (j,n) if (chmax(ma, f(i,j,'o'))) x = i, y = j;\n        if (ma > 0) f(x,y,'o',true), update = true;\n\n        debug {\n            rep (i,n) cerr << s[i] << endl;\n            cerr << endl;\n        }\n\n        ma = 0, x = -1, y = -1;\n        repR (i,n) repR (j,n) if (chmax(ma, f(i,j,'x'))) x = i, y = j;\n        if (ma > 0) f(x,y,'x',true), update = true;\n\n        if (not update) break;\n    }\n\n    rep (i,n) cout << s[i] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#include <iostream>\n#include <array>\n// #include <map>\n// #include <string>\n// #include <algorithm>\n// #include <numeric>\n// #include <limits>\n\nusing namespace std;\n\nstruct Dir{\n\tint i;\n\tint j;\n\tDir(int _i, int _j) : i(_i), j(_j) {\n\t}\n};\n\narray<array<char, 8>, 8> cloth; // [i][j]\narray<Dir, 8> dirs = {\n\t//Dir( 0, 0),\n\tDir( 1, 0),\n\tDir(-1, 0),\n\tDir( 0, 1),\n\tDir( 1, 1),\n\tDir(-1, 1),\n\tDir( 0,-1),\n\tDir( 1,-1),\n\tDir(-1,-1)\n};\n\ninline bool inRange(int i, int j) {\n\tif (i < 0 or 8 <= i) {\n\t\treturn false;\n\t}\n\tif (j < 0 or 8 <= j) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint turnLine(int i, int j, int c, Dir d) {\n\tint count = 0;\n\ti += d.i;\n\tj += d.j;\n\twhile (inRange(i, j)) {\n\t\tif (cloth[i][j] == c) {\n\t\t\treturn count;\n\t\t}\n\t\tif (cloth[i][j] == '.') {\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t\ti += d.i;\n\t\tj += d.j;\n\t}\n\treturn 0;\n}\n\nvoid turnLineReal(int i, int j, int c, Dir d, int count) {\n\tcloth[i][j] = c;\n\tfor (int k = 0; k < count; k++) {\n\t\ti += d.i;\n\t\tj += d.j;\n\t\tcloth[i][j] = c;\n\t}\n}\n\nint put(int i, int j, char c) {\n\tif (cloth[i][j] != '.') {\n\t\treturn 0;\n\t}\n\tint count = 0;\n\tfor (auto d : dirs) {\n\t\tcount += turnLine(i, j, c, d);\n\t}\n\treturn count;\n}\n\nvoid putReal(int i, int j, char c) {\n\tfor (auto d : dirs) {\n\t\tint count = turnLine(i, j, c, d);\n\t\tturnLineReal(i, j, c, d, count);\n\t}\n}\n\nbool mami() {\n\tint m = 0; // max\n\tint put_i;\n\tint put_j;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tint p = put(i, j, 'o');\n\t\t\tif (m < p) {\n\t\t\t\tm = p;\n\t\t\t\tput_i = i;\n\t\t\t\tput_j = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (m == 0) {\n\t\treturn false;\n\t}\n\tputReal(put_i, put_j, 'o');\n\treturn true;\n}\n\nbool bebe() {\n\tint m = 0; // max\n\tint put_i;\n\tint put_j;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tint p = put(i, j, 'x');\n\t\t\tif (m <= p) {\n\t\t\t\tm = p;\n\t\t\t\tput_i = i;\n\t\t\t\tput_j = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (m == 0) {\n\t\treturn false;\n\t}\n\tputReal(put_i, put_j, 'x');\n\treturn true;\n}\n\nvoid print() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcout << cloth[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcin >> cloth[i][j];\n\t\t}\n\t}\n\tbool flg = true;\n\twhile (flg) {\n\t\tflg = false;\n\t\tflg = mami() or flg;\n\t\tstd::cout << \"debug mami end\" << std::endl; // debug\n\t\tprint();\n\t\tflg = bebe() or flg;\n\t\tstd::cout << \"debug bebe end\" << std::endl; // debug\n\t\tprint();\n\t}\n\tstd::cout << \"debug \" << std::endl; // debug\n\tprint();\n\t//std::cout << \"\\e[38;5;0m\\e[48;5;40m --- end ---  \\e[m\" << std::endl; // debug\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std; \nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nchar board[8][8];\nint check(int x,int y,char c)\n{\n  int res=0;\n  if(board[y][x] !='.'){return 0;}\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      int count=0;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[ny][nx]==c){res+=count;break;}\n\t  if(board[ny][nx]=='.'){break;}\n\t  count++;\n\t}\n    }\n  return res;\n}\nvoid put(int x,int y,char c)\n{\n  board[y][x]=c;\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[nx][ny]==c){\n\t    while(1)\n\t      {\n\t\tnx -=dx[k];\n\t\tny -=dy[k];\n\t\tif(nx == x && ny == y){break;}\n\t\tboard[ny][nx]= c;\n\t      }\n\t    break;\n\t  }\n\t  if(board[ny][nx]=='.'){break;}\n\t}\n    }\n}\n\nbool win()\n{\n  int o_count=0;\n  int x_count=0;\n  for(int x=0;x<8;x++)\n    {\n      for(int y=0;y<8;y++)\n\t{\n\t  if(board[x][y]=='o'){o_count++;}\n\t  if(board[x][y]=='x'){x_count++;}\n\t}\n    }\n  return o_count==0 || x_count==0 || o_count+x_count==64;\n}\n    \nint main(int argc,char const* argv[])\n{\n  for(int i=0;i<8;i++)\n    {\n      for(int j=0;j<8;j++)\n\t{\n\t  cin >> board[i][j];\n\t}\n    }\n  int turn=1;\n  int max_x,max_y;\n  int pass=0;\n  while(1)\n    {\n      char player=(turn % 2) ? 'o' : 'x';\n      int num=0;max_x=-1,max_y=-1;\n      if(player == 'o')\n\t{\n\t  for(int y=0;y<8;y++)\n\t    {\n\t      for(int x=0;x<8;x++)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for(int y=7;y>=0;y--)\n\t    {\n\t      for(int x=7;x>=0;x--)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(max_x != -1)\n\t{\n\t  pass=0;\n\t  put(max_x,max_y,player);\n\t}\n      else\n\t{\n\t  pass++;\n\t}\n      turn++;\n      if(pass>1){break;}\n      if(win()){break;}\n    }\n    \n  for(int y=0;y<8;y++)\n    {\n      for(int x=0;x<8;x++)\n\t{\n\t  cout << board[y][x];\n\t}\n      cout << endl;\n    }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nchar table[8][8];\nstring s = \"ox\";\nbool range_check(int y, int x)\n{\n    if(y < 0 || x < 0 || y >= 8 || x >= 8) return false;\n    else return true;\n}\nvoid Put(int y, int x, int flag)\n{\n    table[y][x] = s[flag];\n    for(int k = 0; k < 8; k++)\n    {\n        int ny = y;\n        int nx = x;\n        bool ok = false;\n        while(1)\n        {\n            ny += dy[k];\n            nx += dx[k];\n            if(!range_check(ny, nx)) break;\n            if(table[ny][nx] == '.') break;\n            if(table[ny][nx] == s[flag])\n            {\n                ok = true;\n                break;\n            }\n        }\n        if(ok)\n        {\n            ny = y;\n            nx = x;\n            while(1)\n            {\n                ny += dy[k];\n                nx += dx[k];\n                if(table[ny][nx] == s[flag]) break;\n                table[ny][nx] = s[flag];\n            }\n        }\n    }\n}\nint Search(int y, int x, int flag)\n{\n    int ret = 0;\n    for(int k = 0; k < 8; k++)\n    {\n        int ny = y;\n        int nx = x;\n        int cnt = 0;\n        while(1)\n        {\n            ny += dy[k];\n            nx += dx[k];\n            if(!range_check(ny, nx)) break;\n            if(table[ny][nx] == '.') break;\n            if(table[ny][nx] == s[flag])\n            {\n                ret += cnt;\n                break;\n            }\n            if(table[ny][nx] == s[!flag]) cnt++;\n        }\n    }\n    return ret;\n}\nvoid Solve()\n{\n    bool ok = false;\n    priority_queue<PP> que;\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++)\n        {\n            if(table[i][j] != '.') continue;\n            int cnt = Search(i, j, 0);\n            if(cnt >= 1) que.push(PP(cnt, P(-i, -j)));\n        }\n    }\n    if(!que.empty())\n    {\n        PP p = que.top();\n        Put(-p.second.first, -p.second.second, 0);\n        ok = true;\n    }\n    //clear()がない( 一一)\n    que = decltype(que)();\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++)\n        {\n            if(table[i][j] != '.') continue;\n            int cnt = Search(i, j, 1);\n            if(cnt >= 1) que.push(PP(cnt, P(i, j)));\n        }\n    }\n    if(!que.empty())\n    {\n        PP p = que.top();\n        Put(p.second.first, p.second.second, 1);\n        ok = true;\n    }\n    if(ok) Solve();\n    else return;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++) cin >> table[i][j];\n    }\n    Solve();\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++) cout << table[i][j];\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//$g++ -std=c++11 Template.cpp \n\n//#include <bits/stdc++.h>\n#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <iomanip>\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define ROF(i, j, k) for(int i = (int)(j); i >= (int)(k); --i)\n#define FORLL(i, n, m) for(long long i = n; i < (long long)(m); i++)\n#define SORT(v, n) sort(v, v+n)\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nusing namespace std;\nusing ll = long long;\nconst ll MOD=1000000007LL;\ntypedef pair<int, int> P;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n\npriority_queue<int> q_descending;\npriority_queue<int, vector<int>, greater<int> > q_ascending;\n\nchar t[8][9];\nint n = 8;\nint all_turn;\nint dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};\n\nbool check(int row, int col){\n  return (row >= 0 && row <= 7 && col >= 0 && col <= 7);\n}\nvoid turn(int x, int y, char c){\n  char e_c = (c == 'o' ? 'x' : 'o');\n  //8-directions\n  REP(i,n){\n    int res = 1;\n    while(check(x+res*dx[i], y+res*dy[i])){\n      char focus = t[x+res*dx[i]][y+res*dy[i]];\n      if(focus == c){\n\tt[x][y] = c;\n\tFOR(j,1,res) t[x+j*dx[i]][y+j*dy[i]] = c;\n\tbreak;\n      }\n      else if(focus == e_c) res++;\n      else break;\n    }\n  }    \n}\n\nint simulate(int x, int y, char c){\n  int ret = 0;\n  char e_c = (c == 'o' ? 'x' : 'o');\n  //8-directions\n  REP(i,n){\n    int res = 1;\n    while(check(x+res*dx[i], y+res*dy[i])){\n      char focus = t[x+res*dx[i]][y+res*dy[i]];\n      if(focus == c){\n\tret += res-1;\n\tbreak;\n      }\n      else if(focus == e_c) res++;\n      else break;\n    }\n  }  \n  return ret;\n}\nbool solve(){\n  int max_n=0, max_x=-1, max_y=-1;\n  char c = 'o';\n\n  REP(i,n) REP(j,n){\n    if(t[i][j] == '.'){      \n      int num = simulate(i,j,c);\n      if(max_n<num){\n\tmax_n = num;\n\tmax_x = i;\n\tmax_y = j;\n      }\n    }\n  }\n  if(max_x >= 0) turn(max_x, max_y, c);  \n  return (max_n > 0);\n}\n\nbool _solve(){\n  int max_n=0, max_x=-1, max_y=-1;\n  char c = 'x';\n\n  ROF(i,7,0) ROF(j,7,0){\n    if(t[i][j] == '.'){          \n    int num = simulate(i,j,c);\n    if(max_n<num){\n      max_n = num;\n      max_x = i;\n      max_y = j;\n    }\n    }\n  }\n  if(max_x >= 0) turn(max_x, max_y, c);  \n  return (max_n > 0); \n}\n\nint\nmain(void){  \n  ios_base::sync_with_stdio(false);\n\n  REP(i, n) cin >> t[i];\n\n  bool first = true, second = true;\n  while(first || second){\n    first = solve();\n    second = _solve();\n  }\n\n  REP(i,n) {\n    REP(j,n) cout << t[i][j];\n    cout << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#define llint long long\n#define inf 1e18\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint a[8][8];\nllint dx[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nllint calc(llint px, llint py, llint turn, bool flip)\n{\n\tif(a[px][py]) return 0;\n\t\n\tllint ret = 0;\n\tfor(int i = 0; i < 8; i++){\n\t\tbool flag = false;\n\t\tfor(int j = 1; ; j++){\n\t\t\tllint nx = px + dx[i]*j, ny = py + dy[i]*j;\n\t\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8) break;\n\t\t\tif(a[nx][ny] == 0) break;\n\t\t\tif(a[nx][ny] == turn){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) continue;\n\t\t\n\t\tfor(int j = 1; ; j++){\n\t\t\tllint nx = px + dx[i]*j, ny = py + dy[i]*j;\n\t\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8) break;\n\t\t\tif(a[nx][ny] == 0) break;\n\t\t\tif(a[nx][ny] == turn) break;\n\t\t\tret++;\n\t\t\tif(flip) a[nx][ny] *= -1;\n\t\t}\n\t}\n\tif(flip) a[px][py] = turn;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tchar c;\n\tfor(int y = 0; y < 8; y++){\n\t\tfor(int x = 0; x < 8; x++){\n\t\t\tcin >> c;\n\t\t\tif(c == 'o') a[x][y] = 1;\n\t\t\tif(c == 'x') a[x][y] = -1;\n\t\t\tif(c == '.') a[x][y] = 0;\n\t\t}\n\t}\n\t\n\tllint turn = 1; bool pass = false;\n\twhile(1){\n\t\tllint max_val = 0, max_x, max_y;\n\t\tif(turn == 1){\n\t\t\tfor(int y = 0; y < 8; y++){\n\t\t\t\tfor(int x = 0; x < 8; x++){\n\t\t\t\t\tllint res = calc(x, y, turn, 0);\n\t\t\t\t\tif(res > max_val){\n\t\t\t\t\t\tmax_val = res;\n\t\t\t\t\t\tmax_x = x, max_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int y = 7; y >= 0; y--){\n\t\t\t\tfor(int x = 7; x >= 0; x--){\n\t\t\t\t\tllint res = calc(x, y, turn, 0);\n\t\t\t\t\tif(res > max_val){\n\t\t\t\t\t\tmax_val = res;\n\t\t\t\t\t\tmax_x = x, max_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_val == 0){\n\t\t\tif(pass) break;\n\t\t\tpass = true;\n\t\t}\n\t\telse calc(max_x, max_y, turn, 1), pass = false;\n\t\tturn *= -1;\n\t}\n\t\n\tfor(int y = 0; y < 8; y++){\n\t\tfor(int x = 0; x < 8; x++){\n\t\t\tif(a[x][y] == 1) cout << \"o\";\n\t\t\tif(a[x][y] == 0) cout << \".\";\n\t\t\tif(a[x][y] == -1) cout << \"x\";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\n    int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n    int x_best, y_best, most_got, got_count;\n    char s[8][8];\n    bool is_changed[2] = {true, true};\n    char mine[2] = {'o', 'x'};\n    char yours[2] = {'x', 'o'};\n    for (int x=0; x<8; x++) {\n        for (int y=0; y<8; y++) {\n            cin >> s[x][y];\n        }\n    }\n    while (is_changed[0] || is_changed[1]) {\n        for (int player=0; player<2; player++) {\n            is_changed[player] = false;\n            most_got = 0;\n            for (int x=0; x<8; x++) {\n                for (int y=0; y<8; y++) {\n                    if (s[x][y] != '.') {\n                        continue;\n                    }\n                    got_count = 0;\n                    for (int i=0; i<8; i++) {\n                        int x_cur = x;\n                        int y_cur = y;\n                        int k = 0;\n                        while (true) {\n                            x_cur += dx[i];\n                            y_cur += dy[i];\n                            k++;\n                            if (x_cur < 0 || y_cur < 0 || x_cur > 7 || y_cur > 7) {\n                                break;\n                            }\n                            if (s[x_cur][y_cur] != yours[player]) {\n                                if (s[x_cur][y_cur] == mine[player]) {\n                                    got_count += k-1;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if ((player == 0 && got_count > most_got)\n                        || (player == 1 && got_count >= most_got && got_count > 0)) {\n                        x_best = x;\n                        y_best = y;\n                        most_got = got_count;\n                        is_changed[player] = true;\n                    }\n                }\n            }\n            if (is_changed[player]) {\n                for (int i=0; i<8; i++) {\n                    int x_cur = x_best;\n                    int y_cur = y_best;\n                    int k = 0;\n                    while (true) {\n                        x_cur += dx[i];\n                        y_cur += dy[i];\n                        k++;\n                        if (x_cur < 0 || y_cur < 0 || x_cur > 7 || y_cur > 7) {\n                            break;\n                        }\n                        if (s[x_cur][y_cur] != yours[player]) {\n                            if (s[x_cur][y_cur] == mine[player] && k > 1) {\n                                while (true) {\n                                    x_cur -= dx[i];\n                                    y_cur -= dy[i];\n                                    if (s[x_cur][y_cur] != yours[player]) {\n                                        break;\n                                    }\n                                    s[x_cur][y_cur] = mine[player];\n                                }\n                                s[x_best][y_best] = mine[player];\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (int x=0; x<8; x++) {\n        for (int y=0; y<8; y++) {\n            cout << s[x][y];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[8] = {1, 1, 1, 0, 0,-1,-1,-1};\nint dy[8] = {1, 0,-1, 1,-1, 1, 0,-1};\n\nint put(int turn, int x, int y, vector<vector<char> >& field, bool ischange){\n    char c[2] = {'o', 'x'};\n    field[x][y] = c[1-turn];\n    int count=0;\n    for(int i=0; i<8; i++){\n        int tmpx=x+dx[i], tmpy=y+dy[i];\n        int precount=0;\n        while(field[tmpx][tmpy] == c[1-turn]){\n            precount++;\n            tmpx += dx[i];\n            tmpy += dy[i];\n        }\n        if(field[tmpx][tmpy] == c[turn]){\n            count+=precount;\n            if(ischange){\n                for(int j=0; j<precount; j++){\n                    tmpx -= dx[i];\n                    tmpy -= dy[i];\n                    field[tmpx][tmpy] = c[turn];\n                }\n            }\n        }\n    }\n    if(!ischange){\n        field[x][y] = '.';\n    }else{\n        field[x][y] = c[turn];\n    }\n    return count;\n}    \n\nint main(){\n    vector<vector<char> > field(10, vector<char>(10, 'E'));\n    for(int i=1; i<=8; i++){\n        for(int j=1; j<=8; j++){\n            cin >> field[i][j];\n        }\n    }\n    \n    int turn = 0;\n    for(int s=0; s<64; s++){\n        int best=0;\n        int x=0, y=0;\n        for(int i=1; i<=8; i++){\n            for(int j=1; j<=8; j++){\n                if(field[i][j]!='.') continue;\n                int eval = put(turn, i, j, field, false);\n                if(eval +turn > best){\n                    best = eval;\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n        if(best!=0){\n            put(turn, x, y, field, true);\n        }\n        turn = 1-turn;\n    }\n\n    for(int i=1; i<=8; i++){\n        for(int j=1; j<=8; j++){\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing T = tuple<int,int,int>;//count,x,y\nchar board[8][8];\n\nT place(bool turn){\n    //turn==ture := 'o' else 'x'\n    T ret(0,-1,-1);\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            if(board[i][j]!='.') continue;\n            int cnt = 0;\n            int d[9]={0,-1,-1,1,1,0,1,-1,0};\n            for(int k=0;k<8;k++){\n                int dx=d[k],dy=d[k+1];\n                int y=i,x=j;\n                int temp=0;\n                while(true){\n                    x+=dx; y+=dy;\n                    if(x<0||x>=8||y<0||y>=8) break;\n                    if(board[y][x]=='.') break;\n                    if(board[y][x]==(turn?'o':'x')){\n                        cnt+=temp;\n                        break;\n                    }else{\n                        temp++;\n                    }\n                }\n            }\n            // cout<<(turn?-cnt:cnt)<<' '<<i<<' '<<j<<endl;\n\n            if(turn)ret = min(ret,T(-cnt,i,j));\n            else ret = max(ret,T(cnt,i,j));\n        }\n    }\n    if(turn)get<0>(ret)*=-1;\n    return ret;\n}\n\nvoid emplace(T t,bool turn){\n    int i,j;\n    tie(ignore,i,j) = t;\n    int d[9]={0,-1,-1,1,1,0,1,-1,0};\n    board[i][j]=(turn?'o':'x');\n    for(int k=0;k<8;k++){\n        int dx=d[k],dy=d[k+1];\n        int y=i,x=j;\n        while(true){\n            x+=dx; y+=dy;\n            if(x<0||x>=8||y<0||y>=8) break;\n            if(board[y][x]=='.') break;\n            if(board[y][x]==(turn?'o':'x')){\n                while(x!=j||y!=i){\n                    x-=dx;y-=dy;\n                    board[y][x]=(turn?'o':'x');\n                }\n                break;\n            }else{\n                continue;\n            }\n        }\n    }\n}\n\nint main(){\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++) cin>>board[i][j];\n    }\n    bool flag = true;\n    for(int i=0;i<64;i++){\n        // for(int i=0;i<8;i++){\n        //     for(int j=0;j<8;j++){\n        //         cout<<board[i][j];\n        //     }\n        //     cout<<endl;\n        // }cout<<endl;\n        T t = place(i%2==0);\n        if(get<0>(t)==0){\n            if(!flag) break;\n            else flag = false;\n            continue;\n        }\n        flag=true;\n        emplace(t, i%2==0);\n    }\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            cout<<board[i][j];\n        }\n        cout<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nconst char B = 'o';\nconst char W = 'x';\nconst char S = '.';\nchar board[8][8];\n\nint reversible(char player, int y, int x) {\n\tif (board[y][x] != S)return 0;\n\tint ret = 0;\n\tfor (int dy = -1; dy <= 1; dy++)\n\t\tfor (int dx = -1; dx <= 1; dx++)\n\t\t\tif (!(dy == 0 && dx == 0)) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tint yy = y + dy, xx = x + dx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(0 <= yy && yy < 8 && 0 <= xx && xx < 8))break;\n\t\t\t\t\tchar c = board[yy][xx];\n\t\t\t\t\tif (c == S) break;\n\t\t\t\t\tif (c == player) {\n\t\t\t\t\t\tret += cnt;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tyy += dy; xx += dx;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\treturn ret;\n}\n\nvoid reverse(char player, int y, int x, int dy, int dx) {\n\tint yy = y + dy, xx = x + dx;\n\twhile (true) {\n\t\tif (!(0 <= yy && yy < 8 && 0 <= xx && xx < 8)) return;\n\t\tchar c = board[yy][xx];\n\t\tif (c == S) return;\n\t\tif (c == player) break;\n\t\tyy += dy; xx += dx;\n\t}\n\twhile (true) {\n\t\tyy -= dy; xx -= dx;\n\t\tif (yy == y && xx == x) break;\n\t\tboard[yy][xx] = player;\n\t}\n}\n\nvoid reverse(char player, int y, int x) {\n\tassert(reversible(player, y, x));\n\tboard[y][x] = player;\n\tfor (int dy = -1; dy <= 1; dy++)\n\t\tfor (int dx = -1; dx <= 1; dx++)\n\t\t\tif (!(dy == 0 && dx == 0))\n\t\t\t\treverse(player, y, x, dy, dx);\n}\n\npair<int, int> status() {\n\tint cntB = 0, cntW = 0;\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tchar c = board[y][x];\n\t\t\tif (c == B) cntB++;\n\t\t\tif (c == W) cntW++;\n\t\t}\n\t}\n\treturn make_pair(cntB, cntW);\n}\n\nsigned main() {\n\tfor (int y = 0; y < 8; y++)\n\t\tfor (int x = 0; x < 8; x++)\n\t\t\tcin >> board[y][x];\n\twhile (true) {\n\t\tint Bx, By, Bmaxcnt = 0;\n\t\trep(y, 0, 8)rep(x, 0, 8)\n\t\t\tif (chmax(Bmaxcnt, reversible(B, y, x)))\n\t\t\t\tBx = x, By = y;\n\t\tif (Bmaxcnt)reverse(B, By, Bx);\n\t\tint Wx, Wy,Wmaxcnt = 0;\n\t\trrep(y, 0, 8)rrep(x, 0, 8)\n\t\t\tif (chmax(Wmaxcnt, reversible(W, y, x)))\n\t\t\t\tWx = x, Wy = y;\n\t\tif (Wmaxcnt)reverse(W, Wy, Wx);\n\t\tif (Bmaxcnt == 0 && Wmaxcnt == 0)break;\n\t}\n\trep(i, 0, 8) {\n\t\trep(j, 0, 8) {\n\t\t\tcout << board[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint dx[] = {0,1,0,-1,1,1,-1,-1};\nint dy[] = {1,0,-1,0,-1,1,-1,1};\n\nchar ba[8][8];\nint dfs(int y, int x, int d, int num) {\n  char c = ba[y][x];\n\n  int yy = y+dy[d];\n  int xx = x+dx[d];\n\n  if (yy<0||yy>=8||xx<0||xx>=8) return 0;\n  if (ba[yy][xx] == c) {\n    return dfs(yy,xx,d,num+1);\n  } else if (ba[yy][xx] == '.'){\n    return 0;\n  } else {\n    return num;\n  }\n}\nint func(int y, int x, bool mami) {\n  int res = 0;\n  REP(k,8) {\n    int yy = y+dy[k];\n    int xx = x+dx[k];\n\n    if (yy<0||yy>=8||xx<0||xx>=8)continue;\n    if (mami && ba[yy][xx] == 'x' || !mami && ba[yy][xx] == 'o')\n      res += dfs(yy,xx,k,1);\n  }\n  return res;\n}\n\nbool changedfs(int y, int x, int d, char c) {\n  int yy = y+dy[d];\n  int xx = x+dx[d];\n\n  if (yy<0||yy>=8||xx<0||xx>=8) return 0;\n\n  if (ba[yy][xx] == '.'){\n    return 0;\n  } if (ba[yy][xx] != c) {\n    if (changedfs(yy, xx, d, c)) {\n      ba[yy][xx] = c;\n      return 1;\n    } else {\n      return 0;\n    }\n  } else {\n    return 1;\n  }\n}\n\nvoid change(int y, int x, char c) {\n  REP(k,8) {\n    changedfs(y,x,k,c);\n  }\n}\n\n\nint main() {\n\n  REP(i, 8) {\n    REP(j,8) {\n      cin >> ba[i][j];\n    }\n  }\n  bool mami = 1;\n  int ct = 0;\n  bool f=1;\n  while(ct++<100&&f) {\n    int x,y,ma = 0;\n    f = 0;\n    REP(i, 8) {\n      REP(j,8) {\n        if (ba[i][j] == '.') {\n          int tmp = func(i,j,1);\n          if (tmp) {\n            //printf(\"%d,%d %d\\n\",i,j,tmp );\n          }\n          if (ma < tmp) {\n            ma = tmp;\n            y = i;\n            x = j;\n          }\n        }\n      }\n    }\n    if (ma) {\n      ba[y][x] = 'o';\n      change(y,x,'o');\n      f = 1;\n    }\n    // REP(i,8) {\n    //   REP(j,8) {\n    //     cout << ba[i][j];\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n    \n    ma = 0;\n\n    for (int i=7; i>=0; --i) {\n      for (int j=7; j>=0; --j) {\n        if (ba[i][j] == '.') {\n          int tmp = func(i,j,0);\n          if (tmp) {\n//            printf(\"%d,%d %d\\n\",i,j,tmp );\n          }\n\n          if (ma < tmp) {\n            ma = tmp;\n            y = i;\n            x = j;\n          }\n        }\n      }\n    }\n    if (ma) {\n      f = 1;\n      ba[y][x] = 'x';\n      change(y,x,'x');\n    }\n\n    // REP(i,8) {\n    //   REP(j,8) {\n    //     cout << ba[i][j];\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n  }\n  REP(i,8) {\n    REP(j,8) {\n      cout << ba[i][j];\n    }\n    cout << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint tab[10][10];\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {-1,-1,-1,0,0,1,1,1};\nint calc(int px, int py, int turn, bool flag = false){\n  int res = 0;\n  int opp = 3 - turn;\n  REP(i,8){\n\tint x = px+dx[i], y = py+dy[i], cnt = 0;\n\twhile(tab[y][x] == opp)\n\t  x += dx[i], y += dy[i], ++cnt;\n  \n\tif(tab[y][x] == turn){\n\t  res += cnt;\n\t  if(flag){\n\t\twhile(px != x || py != y){\n\t\t  tab[y][x] = turn;\n\t\t  x -= dx[i], y -= dy[i];\n\t\t}\n\t  }\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  fill((int*)tab, (int*)tab+10*10, 0);\n  REP(y,8){\n\tstring line;\n\tcin >> line;\n\tREP(x,8)\n\t  switch(line[x]){\n\t  case 'o':\n\t\ttab[y+1][x+1] = 1; break;\n\t  case 'x':\n\t\ttab[y+1][x+1] = 2; break;\n\t  case '.':\n\t\ttab[y+1][x+1] = 0; break;\n\t  }\n  }\n\n  bool finish = false;\n  while(!finish){\n\tfinish = true;\n\tint tx = -1, ty, M = 0;\n\tfor(int y=1;y<=8;++y){\n\t  for(int x=1;x<=8;++x){\n\t\tif(tab[y][x] != 0) continue;\n\t\tint res = calc(x,y,1);\n\t\tif(M < res){\n\t\t  M = res;\n\t\t  ty = y;\n\t\t  tx = x;\n\t\t}\n\t  }\n\t}\n\tif(M > 0){\n\t  tab[ty][tx] = 1;\n\t  finish = false, calc(tx,ty,1,true);\n\t}\n\t  \n\ttx = -1, ty = -1, M = 0;\n\tfor(int y=8;y>=1;--y){\n\t  for(int x=8;x>=1;--x){\n\t\tif(tab[y][x] != 0) continue;\n\t\tint res = calc(x,y,2);\n\t\tif(M < res){\n\t\t  M = res;\n\t\t  ty = y;\n\t\t  tx = x;\n\t\t}\n\t  }\n\t}\n\tif(M > 0){\n\t  tab[ty][tx] = 2;\n\t  finish = false, calc(tx,ty,2,true);\n\t}\n  }\n\n  REP(y,8){\n\tREP(x,8)\n\t  switch(tab[y+1][x+1]){\n\t  case 1:\n\t\tcout << 'o'; break;\n\t  case 2:\n\t\tcout << 'x'; break;\n\t  case 0:\n\t\tcout << '.';\n\t  }\n\tcout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n// #define FORDIR(d) REP (d, n_dir)\n\ntypedef complex<int> P;\n#define Y real()\n#define X imag()\n\n/*}}}*/\n\nchar another_cake(char c)\n{\n\tif (c == 'o') {\n\t\treturn 'x';\n\t} else if (c == 'x') {\n\t\treturn 'o';\n\t} else {\n\t\treturn '.';\n\t}\n}\n\nbool in_field(P p)\n{\n\treturn (0 <= p.Y && p.Y < 8) && (0 <= p.X && p.X < 8);\n}\n\nint dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint put_cake(VVC* field, int y, int x, char cake, bool dry_run)\n{\n\tint turned = 0;\n\tREP (d, 8) {\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tvector<P> positions;\n\t\twhile (in_field(P(ny, nx)) && (*field)[ny][nx] == another_cake(cake)) {\n\t\t\tpositions.PB(P(ny, nx));\n\t\t\tny += dy[d]; nx += dx[d];\n\t\t}\n\t\tif (in_field(P(ny, nx)) && (*field)[ny][nx] == cake) {\n\t\t\tturned += positions.size();\n\t\t\tif (!dry_run) {\n\t\t\t\t(*field)[y][x] = cake;\n\t\t\t\tEACH (positions, pos) {\n\t\t\t\t\t(*field)[(*pos).Y][(*pos).X] = cake;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn turned;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tVVC field(8, VC(8));\n\tREP (i, 8) {\n\t\tREP (j, 8) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\twhile (true) {\n\t\t// Mami\n\t\tint m_max = 0;\n\t\tP m_pos = P(-1, -1);\n\t\tREP (i, 8) {\n\t\t\tREP (j, 8) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tint count = put_cake(&field, i, j, 'o', true);\n\t\t\t\t\tif (count > m_max) {\n\t\t\t\t\t\tm_max = count;\n\t\t\t\t\t\tm_pos = P(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (m_max > 0) {\n\t\t\tput_cake(&field, m_pos.Y, m_pos.X, 'o', false);\n\t\t}\n\n\t\t// Witch\n\t\tint w_max = 0;\n\t\tP w_pos = P(-1, -1);\n\t\tREP (i, 8) {\n\t\t\tREP (j, 8) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tint count = put_cake(&field, i, j, 'x', true);\n\t\t\t\t\tif (count >= w_max) {\n\t\t\t\t\t\tw_max = count;\n\t\t\t\t\t\tw_pos = P(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (w_max > 0) {\n\t\t\tput_cake(&field, w_pos.Y, w_pos.X, 'x', false);\n\t\t}\n\n\t\tif (m_max == 0 && w_max == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tREP (i, 8) {\n\t\tREP (j, 8) {\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n;i++)\nvector<vector<char>>s(8,vector<char>(8));\nbool inrange(int y,int x){return (0<=y&&y<8&&0<=x&&x<8);}\nbool foo=false;\nint cnt,ty,tx;\nvoid init(){foo=false; cnt=0;}\nvoid _set(int a,int b){ty=a;tx=b;cnt=0; foo=false;}\nvoid update(int y,int x,char key){\n    vector<vector<char>>temp;\n    temp=s;\n    init();\n    temp[y][x]=key;\n    for(int i=x+1; i<8;i++){\n        if(temp[y][i]==key){foo=true; break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y][x+1+i]=key;\n    init();\n    for(int i=x-1; i>=0; i--){\n        if(temp[y][i]==key){foo=true;break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y][x-1-i]=key;\n    init();\n    for(int i=y+1; i<8;i++){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+i+1][x]=key;\n    init();\n    for(int i=y-1;i>=0;i--){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-1-i][x]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+1+i][x+1+i]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+1+i][x-1-i]=key;\n    _set(y, x);\n    for(int i=0; i<8;i++){\n        --ty;--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-1-i][x-1-i]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        --ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-i-1][x+1+i]=key;\n    s=temp;\n    \n}\nint cal(int y,int x, char key){\n    vector<vector<char>>temp;\n    temp=s;\n    temp[y][x]=key;\n    int ans=0;\n    init();\n    for(int i=x+1; i<8;i++){\n        if(temp[y][i]==key){foo=true; break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=x-1; i>=0; i--){\n        if(temp[y][i]==key){foo=true;break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=y+1; i<8;i++){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=y-1;i>=0;i--){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y, x);\n    for(int i=0; i<8;i++){\n        --ty;--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        --ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    return ans;\n}\n\nint main(){\n    rep(i,8)rep(j,8)cin>>s[i][j];\n    char key='o';\n    bool flag=false;\n    while(true){\n        int maxi=0;\n        pair<int,int>let;\n        if(key=='o'){\n            for(int i=0; i<8;i++){\n                for(int j=0; j<8;j++){\n                    if(s[i][j]!='.')continue;\n                    int t=cal(i,j,key);\n                    if(t>maxi){\n                        maxi=t;\n                        let=pair<int,int>(i,j);\n                    }\n                }\n            }\n        }else{\n            for(int i=7; i>=0;i--){\n                for(int j=7; j>=0;j--){\n                    if(s[i][j]!='.')continue;\n                    int t=cal(i,j,key);\n                    if(t>maxi){\n                        maxi=t;\n                        let=pair<int,int>(i,j);\n                    }\n                }\n            }\n            \n        }\n        if(flag&&maxi==0)break;\n        else flag=false;\n        if(maxi==0){flag=true; key=(key=='o'?'x':'o');continue;}\n        update(let.first,let.second,key);\n        key=(key=='o'?'x':'o');\n    }\n    rep(i,8){rep(j,8)cout<<s[i][j]; cout<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nconst char mark[]={'o','x'};\nconst int dy[]={-1,-1,-1,0,0,0,1,1,1};\nconst int dx[]={-1,0,1,-1,0,1,-1,0,1};\n\nvoid solve(){\n    char field[10][10];\n    for(int i = 0; i < 8; i++)\n        for(int j = 0; j < 8; j++)\n            cin>>field[i][j];\n    int tern=0;\n    int cnt=0;\n    int tmp=0;\n    while(1){\n        tmp++;\n        bool isRev=false;\n        vector<pair<int,pair<int,int> > > vipii;\n        for(int i = 7; i >= 0; i--){\n            for(int j = 7; j >= 0; j--){\n                if(field[i][j]=='.'){\n                    // ツ各ツ陛サツ古シツづ可づつつ「ツづ陳イツづ猟づゥ\n                    int sum=0;\n                    for(int k = 0; k < 9; k++){\n                        int ny=i+dy[k];\n                        int nx=j+dx[k];\n                        if(!(ny>=0&&nx>=0&&ny<8&&nx<8)||field[ny][nx]!=mark[(tern+1)%2])\n                            continue;\n                        int idx=0;\n                        // ツづ債つウツづ慊づェツづつ「ツづゥツつゥツづつ、ツつゥツ陳イツづ猟づゥ\n                        while(1){\n                            idx++;\n                            ny+=dy[k];nx+=dx[k];\n                            if(!(ny>=0&&nx>=0&&ny<8&&nx<8))\n                                break;\n                            // ツづ債つウツづ慊づェツづづゥ\n                            if(field[ny][nx]==mark[tern]){\n                                sum+=idx;\n                                break;\n                            }\n                            else if(field[ny][nx]=='.')\n                                break;\n                        }\n                    }\n                    if(sum!=0){\n                        if(tern%2==0)\n                            vipii.push_back(make_pair(sum,make_pair(-i,-j)));\n                        else\n                            vipii.push_back(make_pair(sum,make_pair(i,j)));\n                    }\n                }\n            }\n        }\n        if(vipii.size()==0)\n            cnt++;\n        else\n            cnt=0;\n        if(cnt>=2)\n            break;\n        if(vipii.size()>=1){\n            sort(vipii.begin(),vipii.end(),greater<pair<int,pair<int,int> > >());\n            int y,x;\n            if(tern%2==0){\n                y=-vipii[0].second.first;\n                x=-vipii[0].second.second;\n            }\n            else{\n                y=vipii[0].second.first;\n                x=vipii[0].second.second;\n            }\n            for(int k = 0; k < 9; k++){\n                int ny=y+dy[k];\n                int nx=x+dx[k];\n                if(!(ny>=0&&nx>=0&&ny<8&&nx<8)||field[ny][nx]!=mark[(tern+1)%2])\n                    continue;\n                int idx=0;\n                // ツづ債つウツづ慊づェツづつ「ツづゥツつゥツづつ、ツつゥツ陳イツづ猟づゥ\n                while(1){\n                    idx++;\n                    ny+=dy[k];nx+=dx[k];\n                    if(!(ny>=0&&nx>=0&&ny<8&&nx<8))\n                        break;\n                    // ツづ債つウツづ慊づェツづづゥ\n                    if(field[ny][nx]==mark[tern]){\n                        isRev=true;\n                        // ツづ青づつュツづィツ陛板つオツづつ「ツつュ\n                        int cx=nx;\n                        int cy=ny;\n                        while(1){\n                            if(cx==x&&y==cy){\n                                field[cy][cx]=mark[tern];\n                                break;\n                            }\n                            field[cy][cx]=mark[tern];\n                            cx-=dx[k];\n                            cy-=dy[k];\n                        }\n                        break;\n                    }\n                    else if(field[ny][nx]=='.')\n                        break;\n                }\n            }\n        }\n        tern=(tern+1)%2;\n    }\n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            cout<<field[i][j];\n        }\n        cout<<endl;\n    }\n}\n\nint main(){\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(int n,int x,int y){return x>=0&&x<n&&y>=0&&y<n;}\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\nint main() {\n  int n=8,r=0;\n  string s[n],t=\"ox\";\n  for(int i=0; i<n; i++) cin >> s[i];\n  for(int l=0; l<64; l++) {\n    int xx,yy,M=0;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<n; j++) {\n        if(s[i][j]!='.') continue;\n        int c=0;\n        for(int k=0; k<8; k++) {\n          int x=i+dx[k],y=j+dy[k],z=0;\n          while(check(n,x,y)&&s[x][y]==t[r^1]) {\n            z++;\n            x+=dx[k];\n            y+=dy[k];\n          }\n          if(check(n,x,y)&&s[x][y]==t[r]) c+=z;\n        }\n        if(M<c) M=c,xx=i,yy=j;\n        else if(r&&M==c) xx=i,yy=j;\n      }\n    }\n    if(M) {\n      s[xx][yy]=t[r];\n      for(int k=0; k<8; k++) {\n        int x=xx+dx[k],y=yy+dy[k];\n        while(check(n,x,y)&&s[x][y]==t[r^1]) {\n          x+=dx[k];\n          y+=dy[k];\n        }\n        if(check(n,x,y)&&s[x][y]==t[r]) {\n          x=xx+dx[k],y=yy+dy[k];\n          while(check(n,x,y)&&s[x][y]==t[r^1]) {\n            s[x][y]=t[r];\n            x+=dx[k];\n            y+=dy[k];\n          }\n        }\n      }\n    }\n    r^=1;\n  }\n  for(int i=0; i<n; i++) cout << s[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nvector<string> s(8);\nint64 dx[8] = {-1, -1, -1, 0, 0, 1, 1,1 };\nint64 dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<8&&0<=x&&x<8;\n}\n\nint canput(int y, int x, char c, bool f=0) {\n  bool ok = 0;\n  int res = 0;\n  REP(k, 8) {\n    int yy = y, xx=x;\n    stack<PII> st;\n    if (s[yy][xx] != '.') continue;\n    int cnt = 0;\n    while (in(yy+dy[k], xx+dx[k])) {\n      yy += dy[k]; xx += dx[k];\n      if (s[yy][xx] == '.' || s[yy][xx] == c) break;\n      st.emplace(yy, xx);\n      cnt++;\n    }\n    if (s[yy][xx] == c) {\n      if (cnt >= 1) {\n        ok = 1;\n        res += st.size();\n        if (f) {\n          while (st.size()) {\n            s[st.top().fs][st.top().sc] = c;\n            st.pop();\n          }\n        }\n      }\n    }\n  }\n  if (f) {\n    s[y][x] = c;\n  }\n  return res;\n}\n\nint main(void) {\n  REP(i, 8) {\n    cin >> s[i];\n  }\n\n  char cc[2] = {'o', 'x'};\n  int64 cnt_turn = 0, turn = 0;\n  while (cnt_turn < 2) {\n    cnt_turn++;\n    int64 mx = 0, yy, xx;\n    for (int64 y = (turn ? 7 : 0); (turn ? y >= 0 : y < 8); (turn? y-- : y++)) {\n      for (int64 x = (turn ? 7 : 0); (turn ? x >= 0 : x < 8); (turn? x-- : x++)) {\n        int64 ret = canput(y, x, cc[turn]);\n        if (ret > mx) {\n          mx = ret;\n          yy = y; xx = x;\n          cnt_turn = 0;\n        }\n      }\n    }\n    if (mx) {\n      canput(yy, xx, cc[turn], 1);\n    }\n    turn = 1-turn;\n  }\n\n  REP(i, 8) {\n    cout << s[i] << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define CHOCO 'o'\n#define CHEESE 'x'\n#define NONE '.'\n\nusing Board = vector<vector<char>>;\n\nstruct Vector2 {\n  int x;\n  int y;\n};\n\nvoid debug_print(Board& board){\n  for(int i = 0 ; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      cout << board[i][j]; \n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nbool in_area(Vector2 v){\n  return 0 <= v.x && v.x < 8 && 0 <= v.y && v.y < 8;\n}\n\nbool is_reverse(Board board, Vector2 v, int x, int y, char color){\n  v.x += x; v.y += y;\n  char check = (color == CHOCO ? CHEESE : CHOCO);\n  bool ok = false;\n  while(in_area(v)){\n    if(board[v.y][v.x] == check) ok = true;\n    else if(board[v.y][v.x] == color && ok) return true;\n    else break;\n    v.x += x; v.y += y;\n  }\n  return false;\n}\n\nint reverse_count(Board board, Vector2 v, char color){\n  int reverse_num = 0;\n  board[v.y][v.x] = color;\n  for(int i = 0; i < 8; i++){\n    if(is_reverse(board, v, ddx[i], ddy[i], color)) {\n      Vector2 vv = v;\n      vv.x += ddx[i], vv.y += ddy[i];\n      while(board[vv.y][vv.x] != color) {\n\tboard[vv.y][vv.x] = color;\n\treverse_num++;\n\tvv.x += ddx[i], vv.y += ddy[i];\n      }\n    }\n  }\n  return reverse_num;\n}\n\nvoid reverse(Board& board, Vector2 v, char color){\n  int reverse_num = 0;\n  board[v.y][v.x] = color;\n  for(int i = 0; i < 8; i++){\n    if(is_reverse(board, v, ddx[i], ddy[i], color)) {\n      Vector2 vv = v;\n      vv.x += ddx[i], vv.y += ddy[i];\n      while(board[vv.y][vv.x] != color) {\n\tboard[vv.y][vv.x] = color;\n\treverse_num++;\n\tvv.x += ddx[i], vv.y += ddy[i];\n      }\n    }\n  }\n}\n\nvoid simulate(Board& board, char& color){\n  int max_reverse = 0;\n  Vector2 position;\n  if(color == CHOCO){\n    for(int h = 0; h < 8; h++){\n      for(int w = 0; w < 8; w++) {\n\tif(board[h][w] != NONE) continue;\n\tint rev = reverse_count(board, {w, h}, color);\n\tif(max_reverse < rev) {\n\t  max_reverse = rev;\n\t  position = {w, h};\n\t}\n      }\n    }\n  } else {\n    for(int h = 7; h >= 0; h--){\n      for(int w = 7; w >= 0; w--) {\n\tif(board[h][w] != NONE) continue;\n\tint rev = reverse_count(board, {w, h}, color);\n\tif(max_reverse < rev) {\n\t  max_reverse = rev;\n\t  position = {w, h};\n\t}\n      }\n    }\n  }\n  if(max_reverse == 0) return ;\n  reverse(board, position, color);\n}\n\nint main(){\n  vector<vector<char>> board = vector<vector<char>>(8, vector<char>(9));\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      cin >> board[i][j];\n    }\n  }\n  \n  for(int turn = 0; turn < 64 *  2; turn++){\n    char color = (turn % 2 == 0 ? CHOCO : CHEESE);\n    simulate(board, color);\n    // debug_print(board);\n  }\n  \n  for(int i = 0 ; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      cout << board[i][j]; \n    }\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <utility> // pair make_pair\nusing std::pair;\nusing std::make_pair;\n#include <tuple> // tuple(c++11) make_tuple(c++11)\nusing std::tuple; // get<address>(variable)\nusing std::make_tuple;\n#include <string> // string stoi(c++11) stoll(c++11) to_string(c++11)\nusing std::string;\nusing std::stoi;\nusing std::stoll;\nusing std::to_string;\n#include <queue> // queue priority_queue\nusing std::queue;\nusing std::priority_queue;\n#include <stack> // stack\nusing std::stack;\n#include <vector> // vector\nusing std::vector;\n#include <map> // map\nusing std::map;\n#include <set> // set\nusing std::set; // insert erase find count\n#include <algorithm> // min max\nusing std::sort;\nusing std::lower_bound; // iterator,  >=\nusing std::upper_bound; // iterator,  >\nusing std::min;\nusing std::max;\nusing std::min_element; // iterator\nusing std::max_element; // iterator\n#include <complex> // complex\nusing std::complex; // real imag\n#include <iostream> // cin cout\nusing std::cin;\nusing std::cout;\nusing std::endl;\n#include <iomanip> // setprecision fixed(manipulator)\nusing std::setprecision;\nusing std::fixed;\n#include <cmath>\n#include <cstdio>\n\n#define lli long long int\n#define INF (int)1e09\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define EFOR(i, m, n) for (int i = m; i <= n; i++)\n#define RFOR(i, m, n) for (int i = m; i > n; i--)\n#define REFOR(i, m, n) for (int i = m; i >= n; i--)\n#define VSORT(v) sort((v).begin(), (v).end()) // sort vector\ntypedef pair<int, int> PI;\ntypedef tuple<int, int, int> TI;\ntemplate <typename T> using Vec = vector<T>; // c++11\n\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nvoid dump (Vec<Vec<char>>& table) {\n    FOR(i, 0, 10) {\n        FOR(j, 0, 10) {\n            cout << table[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool change(Vec<Vec<char>>& table, char me, char you) {\n    int ans_i = 0;\n    int ans_j = 0;\n    int ans_cnt = 0;\n\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            if (table[i][j] != '.') {\n                continue;\n            }\n            int cnt = 0;\n            FOR(k, 0, 8) {\n                int now_cnt = 0;\n                int mul = 1;\n                while (1) {\n                    int cy = i + mul * dy[k];\n                    int cx = j + mul * dx[k];\n                    char moji = table[cy][cx];\n                    if (moji == me) {\n                        cnt += now_cnt;\n                        break;\n                    } else if (moji != you) {\n                        break;\n                    } else {\n                        mul++;\n                        now_cnt++;\n                    }\n                }\n            }\n            if (cnt > ans_cnt || (cnt == ans_cnt && me == 'x')) {\n                ans_i = i;\n                ans_j = j;\n                ans_cnt = cnt;\n            }\n        }\n    }\n\n    if (ans_cnt == 0) {\n        return false;\n    } else {\n        table[ans_i][ans_j] = me;\n        FOR(i, 0, 8) {\n            int mul = 1;\n            while (1) {\n                int cy = ans_i + mul * dy[i];\n                int cx = ans_j + mul * dx[i];\n                char moji = table[cy][cx];\n                if (moji == me) {\n                    RFOR(j, mul, 0) {\n                        cy -= dy[i];\n                        cx -= dx[i];\n                        table[cy][cx] = me;\n                    }\n                    break;\n                } else if (moji == you) {\n                    mul++;\n                } else {\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n}\n\nint main(void) {\n    Vec<Vec<char>> table(10, Vec<char>(10, '#'));\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            cin >> table[i][j];\n        }\n    }\n\n    bool tomoe_check = true;\n    bool majyo_check = true;\n    //dump(table);\n    //cout << endl;\n    while (1) {\n        tomoe_check = change(table, 'o', 'x');\n        if (tomoe_check == false && majyo_check == false) {\n            break;\n        }\n        //dump(table);\n        //cout << endl;\n        majyo_check = change(table, 'x', 'o');\n        if (tomoe_check == false && majyo_check == false) {\n            break;\n        }\n        //dump(table);\n        //cout << endl;\n    }\n    //dump(table);\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            cout << table[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define range(x,y) x >= 0 && x < 8 && y >= 0 && y < 8\n\nint putable[8][8];\nconst int dx[8] = {-1,0,1,-1,1,-1,0,1}, dy[8] = {-1,-1,-1,0,0,1,1,1};\nchar table[8][9];\n\nint putablechecker(char c){\n\tint i, j, k, l, flag = 0;\n\tchar e;\n\tmemset(putable,0,sizeof(putable));\n\tif(c == 'o')\n\t\te = 'x';\n\telse\n\t\te = 'o';\n\tfor(i = 0;i < 8;i++){\n\t\tfor(j = 0;j < 8;j++){\n\t\t\tif(table[i][j] == '.'){\n\t\t\t\tfor(k = 0;k < 8;k++){\n\t\t\t\t\tfor(l = 1;range(j + dx[k] * l,i + dy[k] * l) && table[i + dy[k] * l][j + dx[k] * l] == e;l++);\n\t\t\t\t\tif(range(j + dx[k] * l,i + dy[k] * l) && table[i + dy[k] * l][j + dx[k] * l] == c){\n\t\t\t\t\t\tfor(l = 1;table[i + dy[k] * l][j + dx[k] * l] == e;l++){\n\t\t\t\t\t\t\tputable[i][j]++;\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(void){\n\tint t, count, i, j, max, max_i, max_j;\n\tchar c;\n\tfor(i = 0;i < 8;i++)\n\t\tgets(table[i]);\n\tc = 'o';\n\tt = putablechecker(c);\n\tcount = 0;\n\twhile(t || count < 2){\n\t\tif(!t)\n\t\t\tcount++;\n\t\telse{ // おける場所がある\n\t\t\tcount = 0;\n\t\t\tmax = 0;\n\t\t\tif(c == 'o'){\n\t\t\t\tfor(i = 0;i < 8;i++){\n\t\t\t\t\tfor(j = 0;j < 8;j++){\n\t\t\t\t\t\tif(max < putable[i][j]){\n\t\t\t\t\t\t\tmax = putable[i][j];\n\t\t\t\t\t\t\tmax_i = i;\n\t\t\t\t\t\t\tmax_j = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i = 8;i >= 0;i--){\n\t\t\t\t\tfor(j = 8;j >= 0;j--){\n\t\t\t\t\t\tif(max < putable[i][j]){\n\t\t\t\t\t\t\tmax = putable[i][j];\n\t\t\t\t\t\t\tmax_i = i;\n\t\t\t\t\t\t\tmax_j = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i = 0;i < 8;i++){\n\t\t\t\tfor(j = 1;range(max_j + dx[i] * j,max_i + dy[i] * j) && table[max_i + dy[i] * j][max_j + dx[i] * j] == ((c == 'o') ? 'x':'o');j++); // 範囲外参照を取り除く\n\t\t\t\tif(range(max_i + dy[i] * j,max_j + dx[i] * j) && table[max_i + dy[i] * j][max_j + dx[i] * j] == c){\n\t\t\t\t\tfor(j = 1;table[max_i + dy[i] * j][max_j + dx[i] * j] == ((c == 'o') ? 'x':'o');j++)\n\t\t\t\t\t\ttable[max_i + dy[i] * j][max_j + dx[i] * j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttable[max_i][max_j] = c;\n\t\t}\n\t\tif(c == 'o')\n\t\t\tc = 'x';\n\t\telse\n\t\t\tc = 'o';\n\t\tt = putablechecker(c);\n\t}\n\tfor(i = 0;i < 8;i++){\n\t\tfor(j = 0;j < 8;j++)\n\t\t\tprintf(\"%c\",table[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px), abs(y - py));\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px && qy != py) {\n\t\t\t\t\tc[qx][qy] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) break;\n\t\tplace(y, x, t++ % 2 == 0 ? 'o' : 'x', true);\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <functional>\n#include <algorithm>\nusing namespace std;\ntypedef tuple<int,int,int> tiii;\n\ntypedef struct{\n\tint x;\n\tint y;\n}dir;\nvector<dir>D={\n\t{-1,-1},{0,-1},{1,-1},\n\t{-1,0},{1,0},\n\t{-1,1},{0,1},{1,1},\n};\n\nconst int H=8,W=8;\nvector<function<bool(tiii,tiii)> >sorter={ //{num,x,y}\n\t[](tiii a,tiii b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)>get<2>(b))return true;\n\t\tif(get<2>(a)<get<2>(b))return false;\n\t\tif(get<1>(a)>get<1>(b))return true;\n\t\tif(get<1>(a)<get<1>(b))return false;\n\t\treturn false;\n\t},\n\t[](tiii a,tiii b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)<get<2>(b))return true;\n\t\tif(get<2>(a)>get<2>(b))return false;\n\t\tif(get<1>(a)<get<1>(b))return true;\n\t\tif(get<1>(a)>get<1>(b))return false;\n\t\treturn false;\n\t}\n};\n\nint check2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=check2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\treturn r+1;\n}\nint check1(int color,int x,int y,vector<string>&m){\n\tint R=-1;\n\tfor(auto &d:D){\n\t\tint r=check2(color,d,x+d.x,y+d.y,m);\n\t\tif(r>0){\n\t\t\tif(R<0)R=0;\n\t\t\tR+=r;\n\t\t}\n\t}\n\treturn R;\n}\n\nint fill2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=fill2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\tm[y][x]=color;\n\treturn r+1;\n}\nvoid fill1(int color,int x,int y,vector<string>&m){\n\tfor(auto &d:D)fill2(color,d,x+d.x,y+d.y,m);\n}\n\nint main(){\n\tstring color=\"ox\";\n\tvector<string>m(H);\n\tfor(int h=0;h<H;h++)cin>>m[h];\n\tint turn=0,pass=0;\n\tfor(;;turn^=1){\n\t\tvector<tiii>v;\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)if(m[y][x]=='.'){\n\t\t\tint r=check1(color[turn],x,y,m);\n\t\t\tif(r>0)v.push_back(make_tuple(r,x,y));\n\t\t}\n\t\tif(v.empty()){\n\t\t\tpass++;\n\t\t\tif(pass>1)break;\n\t\t}else{\n\t\t\tpass=0;\n\t\t\tsort(v.begin(),v.end(),sorter[turn]);\n\t\t\ttiii &t=*v.rbegin();\n\t\t\tint x=get<1>(t),y=get<2>(t);\n\t\t\tfill1(color[turn],x,y,m);\n\t\t\tm[y][x]=color[turn];\n\t\t}\n\t}\n\tfor(int h=0;h<H;h++)cout<<m[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nstatic const int dy[8] = {0,-1,-1,-1,0,1,1,1};\nstatic const int dx[8] = {1,1,0,-1,-1,-1,0,1};\n\nconst int n = 11;\nchar m[n][n];\n\nint search(int y, int x, char b, char a){\n    int cnt = 0;\n    rep(i,8){\n        int line = 0;\n        range(j,1,9){\n            if(m[y + dy[i] * j][x + dx[i] * j] == b) line++;\n            else if(m[y + dy[i] * j][x + dx[i] * j] == a){\n                cnt+=line;\n                break;\n            }else{\n                break;\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid putCookie(int y, int x, char b, char a){\n    int ny, nx;\n    m[y][x] = a;\n    rep(i,8){\n        ny = y + dy[i];\n        nx = x + dx[i];\n        range(j,1,9){\n            if(m[y + dy[i] * j][x + dx[i] * j] == b) continue;\n            else if(m[y + dy[i] * j][x + dx[i] * j] == a){\n                range(k,1,n){\n                    if(m[y + dy[i] * k][x + dx[i] * k] == b) m[y  + dy[i] * k][x + dx[i] * k] = a;\n                    else break;\n                }\n            } else break;\n        }\n    }\n}\n\nint main(){\n    rep(i,n) rep(j,n) m[i][j] = '.';\n    rep(i,8) rep(j,8) cin >> m[i + 1][j + 1];\n\n    bool a, b;\n    int cnt, x, y;\n    while(true){\n        a = b = false;\n\n        cnt = 1;\n        for(int i = 8; i >= 1; i--){\n            for(int j = 8; j >= 1; j--){\n                if(m[i][j] != '.') continue;\n                int temp = search(i, j, 'x', 'o');\n                if(temp >= cnt){\n                    cnt = temp;\n                    x = j;\n                    y = i;\n                    a = true;\n                }\n            }\n        }\n        if(a) putCookie(y, x, 'x', 'o');\n        /*\n        cout << y <<' '<<x<< endl;\n    rep(i,8){ rep(j,8){cout << m[i +1][j+1];} cout << endl;}\n    cout << endl;\n    */\n\n        cnt = 1;\n        range(i,1,9){\n            range(j,1,9){\n                if(m[i][j] != '.') continue;\n                int temp = search(i, j, 'o', 'x');\n                if(temp >= cnt){\n                    cnt = temp;\n                    x = j;\n                    y = i;\n                    b = true;\n                }\n            }\n        }\n        if(b) putCookie(y, x, 'o', 'x');\n\n        /*\n        cout << y <<' '<<x<< endl;\n    rep(i,8){ rep(j,8){cout << m[i+1][j+1];} cout << endl;}\n    cout << endl;\n    */\n\n        if(not a && not b) break;\n    }\n    rep(i,8){ rep(j,8){cout << m[i + 1][j + 1];} cout << endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px), abs(y - py));\n\t\t\tif (m) {\n\t\t\t\tint qx = x + dx[i], qy = y + dy[i];\n\t\t\t\twhile (qx != px && qy != py) {\n\t\t\t\t\tc[qx][qy] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) break;\n\t\tplace(y, x, t++ % 2 == 0 ? 'o' : 'x', true);\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    vector<string> v(8);\n    for(int i=0; i<8; ++i) {\n        cin >> v[i]; // v[y][x]\n    }\n\n    int turn = 0;\n    int pass_cnt = 0;\n    bool finished = false;\n    while(pass_cnt < 2 && !finished) {\n        if(turn % 2 == 0) {\n            int put_x = 0, put_y = 0;\n            int reverse_num = 0;\n            int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1},\n                dy[8] = {0, 1, 0, -1, -1, 1, 1, -1};\n            for(int i=0; i<8; ++i) {\n                for(int j=0; j<8; ++j) {\n                    if(v[i][j] == '.') {\n                        int reverse_num2 = 0;\n                        for(int d=0; d<8; ++d) {\n                            int r_num2_tmp = 0;\n                            int cx = j, cy = i;\n                            while(true) {\n                                int nx = cx + dx[d], ny = cy + dy[d];\n                                if(nx < 0 || 8 <= nx || ny < 0 || 8 <= ny) {\n                                    r_num2_tmp = 0;\n                                    break;\n                                }\n                                if(v[ny][nx] == 'x') {\n                                    r_num2_tmp++;\n                                } else if(v[ny][nx] == 'o') {\n                                    break;\n                                } else if(v[ny][nx] == '.') {\n                                    r_num2_tmp = 0;\n                                    break;\n                                }\n                                cx = nx; cy = ny;\n                            }\n                            reverse_num2 += r_num2_tmp;\n                        }\n                        if(reverse_num2 > reverse_num) {\n                            reverse_num = reverse_num2;\n                            put_x = j;\n                            put_y = i;\n                        }\n                    }\n                }\n           }\n           if(reverse_num == 0) {\n               pass_cnt += 1;\n           } else {\n               pass_cnt = 0;\n               v[put_y][put_x] = 'o';\n               //cout << \"o turn: \" << put_y+1 << \" \" << put_x+1 << endl;\n\n               int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1},\n                   dy[8] = {0, 1, 0, -1, -1, 1, 1, -1};\n               for(int d=0; d<8; ++d) {\n                   int cx = put_x, cy = put_y;\n                   while(true) {\n                       int nx = cx + dx[d], ny = cy + dy[d];\n                       if(nx < 0 || 8 <= nx || ny < 0 || 8 <= ny) {\n                           break;\n                       }\n                       if(v[ny][nx] == 'o') {\n                           int x = put_x, y = put_y;\n                           while(x != nx || y != ny) {\n                                v[y][x] = 'o';\n                                y += dy[d];\n                                x += dx[d];\n                           }\n                           break;\n                       } else if(v[ny][nx] == '.') {\n                           break;\n                       }\n                       cx = nx; cy = ny;\n                   }\n               }\n           }\n        } else {\n            int put_x = 0, put_y = 0;\n            int reverse_num = 0;\n            int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1},\n                dy[8] = {0, 1, 0, -1, -1, 1, 1, -1};\n            for(int i=7; i>=0; --i) {\n                for(int j=7; j>=0; --j) {\n                    if(v[i][j] == '.') {\n                        int reverse_num2 = 0;\n                        for(int d=0; d<8; ++d) {\n                            int r_num2_tmp = 0;\n                            int cx = j, cy = i;\n                            while(true) {\n                                int nx = cx + dx[d], ny = cy + dy[d];\n                                if(nx < 0 || 8 <= nx || ny < 0 || 8 <= ny) {\n                                    r_num2_tmp = 0;\n                                    break;\n                                }\n                                if(v[ny][nx] == 'o') {\n                                    r_num2_tmp++;\n                                } else if(v[ny][nx] == 'x') {\n                                    break;\n                                } else if(v[ny][nx] == '.') {\n                                    r_num2_tmp = 0;\n                                    break;\n                                }\n                                cx = nx; cy = ny;\n                            }\n                            reverse_num2 += r_num2_tmp;\n                        }\n                        if(reverse_num2 > reverse_num) {\n                            reverse_num = reverse_num2;\n                            put_x = j;\n                            put_y = i;\n                        }\n                    }\n                }\n           }\n           if(reverse_num == 0) {\n               pass_cnt += 1;\n           } else {\n               pass_cnt = 0;\n               v[put_y][put_x] = 'x';\n\n               //cout << \"x turn: \" << put_y+1 << \" \" << put_x+1 << endl;\n               int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1},\n                   dy[8] = {0, 1, 0, -1, -1, 1, 1, -1};\n               for(int d=0; d<8; ++d) {\n                   int cx = put_x, cy = put_y;\n                   while(true) {\n                       int nx = cx + dx[d], ny = cy + dy[d];\n                       if(nx < 0 || 8 <= nx || ny < 0 || 8 <= ny) {\n                           break;\n                       }\n                       if(v[ny][nx] == 'x') {\n                           int x = put_x, y = put_y;\n                           while(x != nx || y != ny) {\n                                v[y][x] = 'x';\n                                y += dy[d];\n                                x += dx[d];\n                           }\n                           break;\n                       } else if(v[ny][nx] == '.') {\n                           break;\n                       }\n                       cx = nx;\n                       cy = ny;\n                   }\n               }\n           }\n        }\n        turn++;\n\n        finished = true;\n        for(auto& x : v) {\n            if(x.find('.') != string::npos) {\n                finished = false;\n            }\n        }\n    }\n\n    for(auto& x : v) {\n        cout << x << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntemplate <typename T> T &chmin(T &a, const T &b) {return a = min(a, b);}\ntemplate <typename T> T &chmax(T &a, const T &b) {return a = max(a, b);}\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = 1e9;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nint b[8][8];\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint dfs(int x, int y, int dir, int target){\n\tint nx = x+dx[dir];\n\tint ny = y+dy[dir];\n\tif(nx < 0 or nx > 7 or ny < 0 or ny > 7) return -1;\n\tif(b[nx][ny] == 0) return -1;\n\tif(b[nx][ny] == -target) return 0;\n\tint ret = 0;\n\tret = dfs(nx, ny, dir, target);\n\tif(ret == -1) return -1;\n\treturn 1 + ret;\n}\n\nvoid update(int x, int y, vector<int> ds, int target){\n\tb[x][y] = -target;\n  REP(i, ds.size()){\n\t\tint nx = x+dx[ds[i]]; int ny = y+dy[ds[i]];\n\t\twhile(b[nx][ny] == target){\n\t\t\tb[nx][ny] = -target;\n\t\t \tnx += dx[ds[i]]; ny += dy[ds[i]];\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tREP(i, 8) { string str; cin >> str; REP(j, 8) { if(str[j] == '.') continue; b[i][j] = (str[j] == 'o' ? 1 : -1); } }\n\tint x = -1;\n\tint y = -1;\n\tbool bad = false;\n\tint taken = -1;\n\twhile(true){\n\t\tint maxim = 0;\n\t\tvector<int> ds;\n\t\tREP(xx, 8) REP(yy, 8){\n\t\t\tint i, j;\n\t\t\tif(taken == -1) { i = xx; j = yy; }\n\t\t\telse { i = 7-xx; j = 7-yy; }\n\t\t\tif(b[i][j] != 0) continue;\n\t\t\tint count = 0;\n\t\t\tint total = 0;\n\t\t\tvector<int> dirs;\n\t\t\tREP(k, 8) { count = max(dfs(i, j, k, taken), 0); if(count) dirs.push_back(k); total += count; }\n\t\t\tif(total > maxim) { x=i; y=j; maxim=total; bad=false; ds = dirs; }\n\t\t}\n \t\tif(maxim == 0) { if(bad) break; bad = true; }\n\t\telse update(x, y, ds, taken);\n\t\ttaken = -taken;\n\t}\n\tstring tmp;\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tif(b[i][j] == 0) tmp = \".\";\n\t\t\tif(b[i][j] == 1) tmp = \"o\";\n\t\t\tif(b[i][j] == -1) tmp = \"x\";\n\t\t\tcout << tmp; \n\t\t}\n\t\tcout << endl;\n }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[8] = {-1,-1,-1,0,1,1,1,0};\nint dy[8] = {0,1,-1,1,-1,0,1,-1};\n\nbool inrange(int x,int y){\n  if(x<0||y<0||x>7||y>7) return false;\n  else return true;\n}\n\nchar hit[3] = \"ox\";\nint changeban(char wmap[8][8],int turn,int x,int y){\n  int cnt = 0;\n  REP(i,8){\n    bool changable = false;\n    int nx = x+dx[i]; int ny = y+dy[i];\n    if(!inrange(nx,ny)) continue;\n    while(1){\n      if(!inrange(nx,ny)) break;\n      if(wmap[nx][ny]=='.') break;\n      if(wmap[nx][ny]==hit[turn]) changable = true;\n      nx += dx[i]; ny+= dy[i];\n    }\n    if(changable){\n      nx = x+dx[i]; ny = y+dy[i];\n      while(wmap[nx][ny]!=hit[turn]){\n        cnt++;\n        wmap[nx][ny] = hit[turn];\n        nx += dx[i]; ny+= dy[i];\n      }\n    }\n  }\n  return cnt;\n}\n\n//MAXとなるところにさす\nint max_search(char ban[8][8],int turn){\n  char bkup[8][8];\n  char ansban[8][8];\n  REP(i,8) REP(j,8) ansban[i][j] = ban[i][j];\n  int maxchan = -1;\n  if(turn==0){\n    for(int i=7;i>-1;i--){\n      for(int j=7;j>-1;j--){\n        if(ban[i][j]=='.'){\n          REP(k,8) REP(l,8) bkup[k][l] = ban[k][l];\n          bkup[i][j]=hit[turn];\n          int rst = changeban(bkup,turn,i,j);\n          if((maxchan<=rst)&&(rst!=0)){\n            maxchan = rst;\n            REP(k,8) REP(l,8) ansban[k][l] = bkup[k][l];\n          }\n        }\n      }\n    }\n  }else{\n    REP(i,8){\n      REP(j,8){\n        if(ban[i][j]=='.'){\n          REP(k,8) REP(l,8) bkup[k][l] = ban[k][l];\n          bkup[i][j]=hit[turn];\n          int rst = changeban(bkup,turn,i,j);\n          if((maxchan<=rst)&&(rst!=0)){\n            //cout << \"(\" << i <<\",\" <<j <<\")\" <<\"num: \" << rst << endl;\n            maxchan = rst;\n            REP(k,8) REP(l,8) ansban[k][l] = bkup[k][l];\n          }\n        }\n      }\n    }\n  }\n  REP(i,8) REP(j,8) ban[i][j] = ansban[i][j];\n  return maxchan;//-1,0ならさせない\n}\n\nvoid ShowBan(char data[8][8]){\n  REP(i,8){\n    REP(j,8){\n      cout << data[i][j];\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  char data[8][8];\n  REP(i,8){\n    scanf(\"%s\",data[i]);\n  }\n  while(1){\n    //2人もおけないならend\n    int rst1 = max_search(data,0);\n    //ShowBan(data);\n    int rst2 = max_search(data,1);\n    //ShowBan(data);\n    if((rst1<=0)&&(rst2<=0)) break;\n  }\n  ShowBan(data);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 B : ¨ÙqÌ\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint dx[] = {0,1,1,1,0,-1,-1,-1};\nint dy[] = {-1,-1,0,1,1,1,0,-1};\n\nint main(){\n\tstring board[8];\n\twhile(cin >> board[0]){\n\t\tfor(int i=1;i<8;i++) cin >> board[i];\n\t\t// I¹»èÌÀªÊ|ÈÌÅ300^[­ç¢ñµÄ¨­\n\t\tfor(int c=0;c<300;c++){\n\t\t\t// ©ªÌèî\n\t\t\tchar m = c%2 ? 'x' : 'o';\n\t\t\t// èÌèî\n\t\t\tchar o = c%2 ? 'o' : 'x';\n\t\t\tint cx = 0, cy = 0, cnt = 0, dir = 0;\n\t\t\tfor(int ix=0;ix<8;ix++){\n\t\t\t\tfor(int iy=0;iy<8;iy++){\n\t\t\t\t\t// Ì^[Èç¸ðt]\n\t\t\t\t\tint x = c%2 ? 7-ix : ix;\n\t\t\t\t\tint y = c%2 ? 7-iy : iy;\n\t\t\t\t\tif(board[x][y]!='.') continue;\n\t\t\t\t\tint cur = 0, rev = 0;\n\t\t\t\t\tfor(int d=0;d<8;d++){\n\t\t\t\t\t\tint nx = x+dx[d], ny = y+dy[d];\n\t\t\t\t\t\tint tmp = 0;\n\t\t\t\t\t\twhile(0<=nx&&nx<8&&0<=ny&&ny<8&&board[nx][ny]==o){\n\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t\tnx += dx[d];\n\t\t\t\t\t\t\tny += dy[d];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(0<=nx&&nx<8&&0<=ny&&ny<8&&board[nx][ny]==m){\n\t\t\t\t\t\t\tcur += tmp;\n\t\t\t\t\t\t\trev |= (1<<d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt < cur) cx = x, cy = y, cnt = cur, dir = rev;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// u«·¦çêéNbL[ªÈ¯êÎpX\n\t\t\tif(cnt == 0) continue;\n\t\t\t// NbL[ðu«·¦é\n\t\t\tboard[cx][cy] = m;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tif(!(dir&(1<<i))) continue;\n\t\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\t\twhile(board[nx][ny]==o){\n\t\t\t\t\tboard[nx][ny] = m;\n\t\t\t\t\tnx += dx[i];\n\t\t\t\t\tny += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<8;i++) cout << board[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint dx[] = { -1, 0, 1,-1, 1,-1, 0 ,1 };\nint dy[] = { -1,-1,-1, 0, 0, 1, 1, 1 };\nstring field[8];\n\nint count(int x, int y, char s) {\n\tint sum = 0;\n\trep(i, 8) {\n\t\tint rx = x, ry = y;\n\t\tint score = 0;\n\t\twhile (true) {\n\t\t\t//??¨?????¢??????????????????????????¢?????????????????????????????????\n\t\t\tif (0 > ry + dy[i] || ry + dy[i] >= 8 || 0 > rx + dx[i] || rx + dx[i] >= 8) {\n\t\t\t\tscore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//?????¨?¢?????????????????????????????????????\n\t\t\trx += dx[i];\n\t\t\try += dy[i];\n\t\t\t//?¬??????????????????????????????¢?¢????\n\t\t\tif(field[ry][rx] == s) score++;\n\t\t\t//??????????????????????????¢????????????\n\t\t\telse if(field[ry][rx]=='.'){\n\t\t\t\tscore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//????????????????????¢????¢????\n\t\t\telse break;\n\t\t}\n\t\tsum += score;\n\t}\n\treturn sum;\n}\n\nvoid reverse(int x, int y, char s) {\n\trep(i, 8) {\n\t\t//cnt?????????????????°?????°????????????????????°\n\t\tint rx = x, ry = y, cnt = 0;\n\t\twhile (true) {\n\t\t\t//??¨?????¢????????§????????????????????????????????????????????????\n\t\t\tif (0 > ry + dy[i] || ry + dy[i] >= 8 || 0 > rx + dx[i] || rx + dx[i] >= 8) break;\n\t\t\t//?????¨?¢????????????????????????????????????????\n\t\t\trx += dx[i];\n\t\t\try += dy[i];\n\t\t\t//?¬???????????????????????????????????¢?????????????????¶????\n\t\t\tif (field[ry][rx] == s) {\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//????????????????????????????????????????????????????????????\n\t\t\telse if (field[ry][rx] == '.') break;\n\t\t\t//??????????????°??\\????????¨?????¢???????????????????????????\n\t\t\telse {\n\t\t\t\t//tx,ty??????????????´????????????????????????????¨??????????\n\t\t\t\tint tx = x, ty = y;\n\t\t\t\t//cnt(????????????????????°)????????°????????????\n\t\t\t\tfor (int j\t = 0; j < cnt; j++) {\n\t\t\t\t\t//????????¨?????£???????????£???????????????\n\t\t\t\t\tif (s == 'x') field[ty + dy[i]][tx + dx[i]] = 'o';\n\t\t\t\t\telse field[ty + dy[i]][tx + dx[i]] = 'x';\n\t\t\t\t\ttx += dx[i];\n\t\t\t\t\tty += dy[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//?????????????????????x,y?????§?¨????????????´??°\n\tif (s == 'x') field[y][x] = 'o';\n\telse field[y][x] = 'x';\n}\n\nint main() {\n\t//??¨?????¢?????±??\\???\n\trep(i, 8) getline(cin, field[i]);\n\t//true????????????????????????false????????£???????????????\n\tbool turn = true;\n\t//mx,my????????§???????????¢????????????x,y??§?¨????????´????????????°\n\tint score, mx, my;\n\t//flag1???????????????????????????????????°false\n\t//flag0????????£?????????????????????????????°false?????????????????´??°?????????\n\tbool flag0 = true, flag1 = true;\n\n\twhile (flag0 || flag1) {\n\t\tint MAX = 0;\n\t\trep(y, 8) {\n\t\t\trep(x, 8) {\n\t\t\t\tif (field[y][x] == '.') {\n\t\t\t\t\t//????????¨?????£?????§????????????\n\t\t\t\t\t//o:?????????x:?????£?????????\n\t\t\t\t\tif (turn) {\n\t\t\t\t\t\tscore = count(x, y, 'x');\n\t\t\t\t\t\tif (score > MAX) {\n\t\t\t\t\t\t\tMAX = max(MAX, score);\n\t\t\t\t\t\t\tmx = x;\n\t\t\t\t\t\t\tmy = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tscore = count(x, y, 'o');\n\t\t\t\t\t\tif (score >= MAX) {\n\t\t\t\t\t\t\tMAX = max(MAX, score);\n\t\t\t\t\t\t\tmx = x;\n\t\t\t\t\t\t\tmy = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//????????????????????????\n\t\t//?????¬????????????????????????????????£?????´?????????\n\t\tif (MAX == 0) {\n\t\t\t//????????????\n\t\t\tif (turn) {\n\t\t\t\tflag1 = false;\n\t\t\t\tturn = !turn;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag0 = false;\n\t\t\t\tturn = !turn;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tflag1 = true;\n\t\t\tflag0 = true;\n\t\t}\n\t\t//??¨?????¢??´??°\n\t\tif (turn) reverse(mx, my, 'x');\n\t\telse reverse(mx, my, 'o');\n\t\t//??????????????£\n\t\tturn = !turn;\n\t}\n\trep(i, 8) cout << field[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint board[8][8];\nint turn[8][8];\nint subturn[8][8][8];\n\nbool move(int fre, int ene) {\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (board[i][j] != 0) {\n                turn[i][j] = -1;\n            } else {\n                int turnnum = 0;\n                for (int k = 0; k < 8; k++) {\n                    int p = 1;\n                    bool subok = false;\n                    int xx = i + p * dx[k];\n                    int yy = j + p * dy[k];\n                    while (xx >= 0 && xx < 8 && yy >= 0 && yy < 8) {\n                        if (board[xx][yy] == fre) {\n                            subok = true;\n                            break;\n                        } else if (board[xx][yy] == 0) {\n                            break;\n                        }\n                        p++;\n                        xx += dx[k];\n                        yy += dy[k];\n                    }\n                    if (subok) {\n                        turnnum += p - 1;\n                        subturn[i][j][k] = p - 1;\n                    } else {\n                        subturn[i][j][k] = 0;\n                    }\n                }\n                turn[i][j] = turnnum;\n            }\n        }\n    }\n    int maxnum = 0;\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            // if (turn[i][j] == -1) {\n            //     cout << \"a\" << \" \";\n            // } else {\n            //     cout << turn[i][j] << \" \";\n            // }\n            maxnum = max(maxnum, turn[i][j]);\n        }\n        //cout << endl;\n    }\n    if (maxnum > 0) {\n        bool ok = false;\n        if (fre == 1) {\n            for (int i = 0; i < 8; i++) {\n                for (int j = 0; j < 8; j++) {\n                    if (turn[i][j] == maxnum) {\n                        board[i][j] = fre;\n                        for (int k = 0; k < 8; k++) {\n                            for (int l = 1; l <= subturn[i][j][k]; l++) {\n                                board[i + l * dx[k]][j + l * dy[k]] = fre;\n                            }\n                        }\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) {\n                    break;\n                }\n            }\n        } else {\n            for (int i = 7; i >= 0; i--) {\n                for (int j = 7; j >= 0; j--) {\n                    if (turn[i][j] == maxnum) {\n                        board[i][j] = fre;\n                        for (int k = 0; k < 8; k++) {\n                            for (int l = 1; l <= subturn[i][j][k]; l++) {\n                                board[i + l * dx[k]][j + l * dy[k]] = fre;\n                            }\n                        }\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) {\n                    break;\n                }\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    string s;\n    int vac = 0;\n    for (int i = 0; i < 8; i++) {\n        cin >> s;\n        for (int j = 0; j < 8; j++) {\n            if (s[j] == 'o') {\n                board[i][j] = 1;\n            } else if (s[j] == 'x') {\n                board[i][j] = 2;\n            } else {\n                board[i][j] = 0;\n                vac++;\n            }\n        }\n    }\n    while (1) {\n        bool tomoe = move(1, 2);\n        // for (int i = 0; i < 8; i++) {\n        //     for (int j = 0; j < 8; j++) {\n        //         cout << board[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << \"b\" << endl;\n        bool charl = move(2, 1);\n        // cout << tomoe << \" \" << charl << endl;\n        // for (int i = 0; i < 8; i++) {\n        //     for (int j = 0; j < 8; j++) {\n        //         cout << board[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << \"b\" << endl;\n        if (!tomoe && !charl) {\n            break;\n        }\n    }\n    for (int i = 0; i < 8; i++) {\n        string ss = \"\";\n        for (int j = 0; j < 8; j++) {\n            if (board[i][j] == 1) {\n                ss += \"o\";\n            } else if (board[i][j] == 2) {\n                ss += \"x\";\n            } else {\n                ss += \".\";\n            }\n        }\n        cout << ss << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<utility>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint cnt(vector<string>& matrix, int now_h, int now_w, int dh, int dw, char target) {\n    int now_cnt = 0;\n    for (; now_h < matrix.size() && now_h >= 0 && now_w < matrix[0].size() && now_w >= 0; now_h += dh, now_w += dw) {\n        if (matrix[now_h][now_w] == '.') return 0;\n        else if (matrix[now_h][now_w] == target) return now_cnt;\n        else {\n            matrix[now_h][now_w] = target;\n            now_cnt++;\n        }\n    }\n    return 0;\n}\n\nint all_cnt(vector<string>& matrix, int now_h, int now_w, char target) {\n    int dh[3] = {-1, 0, 1};\n    int dw[3] = {-1, 0, 1};\n    int res = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (i == 1 && j == 1) continue;\n            vector<string> tmp(matrix);\n            int now_cnt = cnt(tmp, now_h + dh[i], now_w + dw[j], dh[i], dw[j], target);\n            if (now_cnt > 0) {\n                matrix = tmp;\n                res += now_cnt;\n            }\n        }\n    }\n    return res;\n}\n\nbool mami_comp(const pair<int, P>& l, const pair<int, P>& r) {\n    if (l.first != r.first) return l.first > r.first;\n    if (l.second.first != r.second.first) return l.second.first < r.second.first;\n    return l.second.second < r.second.second;\n}\n\nbool majo_comp(const pair<int, P>& l, const pair<int, P>& r) {\n    if (l.first != r.first) return l.first > r.first;\n    if (l.second.first != r.second.first) return l.second.first > r.second.first;\n    return l.second.second > r.second.second;\n}\n\nbool mami_ok(vector<string>& matrix) {\n    vector<PP> candidate;\n    for (int i = 0; i < matrix.size(); i++) {\n        for (int j = 0;  j < matrix[i].size(); j++) {\n            if (matrix[i][j] != '.') continue;\n            vector<string> tmp(matrix);\n            int now_cnt = all_cnt(tmp, i, j, 'o');\n            if (now_cnt == 0) continue;\n            candidate.push_back(PP(now_cnt, P(i, j)));\n        }\n    }\n    if (candidate.size() == 0) return false;\n    sort(candidate.begin(), candidate.end(), mami_comp);\n    int final_h = candidate[0].second.first, final_w = candidate[0].second.second;\n    matrix[final_h][final_w] = 'o';\n    all_cnt(matrix, final_h, final_w, 'o');\n    return true;\n}\n\nbool majo_ok(vector<string>& matrix) {\n    vector<PP> candidate;\n    for (int i = 0; i < matrix.size(); i++) {\n        for (int j = 0;  j < matrix[i].size(); j++) {\n            if (matrix[i][j] != '.') continue;\n            vector<string> tmp(matrix);\n            int now_cnt = all_cnt(tmp, i, j, 'x');\n            if (now_cnt == 0) continue;\n            candidate.push_back(PP(now_cnt, P(i, j)));\n        }\n    }\n    if (candidate.size() == 0) return false;\n    sort(candidate.begin(), candidate.end(), majo_comp);\n    int final_h = candidate[0].second.first, final_w = candidate[0].second.second;\n    matrix[final_h][final_w] = 'x';\n    all_cnt(matrix, final_h, final_w, 'x');\n    return true;\n}\n\nvoid solve() {\n    vector<string> grid(8);\n    for (int i = 0 ; i < 8; i++) {\n        cin >> grid[i];\n    }\n    char targets[2] = {'o', 'x'};\n    int now = 0;\n    bool can_change = true;\n    while (true) {\n        bool is_fin = false;\n        if (mami_ok(grid)) can_change = true;\n        else {\n            if (!can_change) is_fin = true;\n            else can_change = false;\n        }\n        if (is_fin) break;\n        now ^= 1;\n        if (majo_ok(grid)) can_change = true;\n        else {\n            if (!can_change) is_fin = true;\n            else can_change = false;\n        }\n        if (is_fin) break;\n        now ^= 1;\n    }\n    for (int i = 0; i < 8; i++) {\n        cout << grid[i] << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst char cs[] = \"xo\";\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n    state(){}\n};\n\nstate flip(const int x, const int y, state s, bool turn){\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        if (!valid(cx, cy) || s.g[cy][cx] == cs[turn]) continue;\n        while (valid(cx, cy) && s.g[cy][cx] == cs[!turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cx, cy) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i];\n                !(ix == cx && iy == cy);\n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[!turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n        s.score[turn]++;\n        s.score[1 - turn]--;\n    }\n    return s;\n}\n\nint main(){\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    for (size_t turn = 1; turn <= 128; turn++){\n        bool ok = false;\n        state next = cur;\n        for (size_t y = 0; y < 8; y++){\n            for (size_t x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 1 && next.score[1] < cand.score[1]) ||\n                        ((turn & 1) == 0 && next.score[0] <= cand.score[0])){\n                        ok = true;\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        cur = next;\n        //for (size_t i = 0; i < 8; i++){\n        //    cout << cur.g[i] << endl;\n        //}\n    }\n\n    for (size_t i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<string> v(8);\n\tREP(i, 8)cin >> v[i];\n\tint cnt = 0;\n\tREP(i, 8)REP(j, 8)if (v[i][j] == '.')cnt++;\n\tREP(t, cnt) {\n\t\tint p = -1, q = -1, cmax = -1;\n\t\tif (t % 2 == 0) {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'x')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\tif (tmp != 0)s.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax < c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\n\t\t\t\tv[p][q] = 'o';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'x')v[ni][nj] = 'o';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'o')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\tif (tmp != 0)s.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax <= c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\n\t\t\t\tv[p][q] = 'x';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'o')v[ni][nj] = 'x';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility> // pair make_pair\nusing std::pair;\nusing std::make_pair;\n#include <tuple> // tuple(c++11) make_tuple(c++11)\nusing std::tuple; // get<address>(variable)\nusing std::make_tuple;\n#include <string> // string stoi(c++11) stoll(c++11) to_string(c++11)\nusing std::string;\nusing std::stoi;\nusing std::stoll;\nusing std::to_string;\n#include <queue> // queue priority_queue\nusing std::queue;\nusing std::priority_queue;\n#include <stack> // stack\nusing std::stack;\n#include <vector> // vector\nusing std::vector;\n#include <map> // map\nusing std::map;\n#include <set> // set\nusing std::set; // insert erase find count\n#include <algorithm> // min max\nusing std::sort;\nusing std::lower_bound; // iterator,  >=\nusing std::upper_bound; // iterator,  >\nusing std::min;\nusing std::max;\nusing std::min_element; // iterator\nusing std::max_element; // iterator\n#include <complex> // complex\nusing std::complex; // real imag\n#include <iostream> // cin cout\nusing std::cin;\nusing std::cout;\nusing std::endl;\n#include <iomanip> // setprecision fixed(manipulator)\nusing std::setprecision;\nusing std::fixed;\n#include <cmath>\n#include <cstdio>\n\n#define lli long long int\n#define INF (int)1e09\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define EFOR(i, m, n) for (int i = m; i <= n; i++)\n#define RFOR(i, m, n) for (int i = m; i > n; i--)\n#define REFOR(i, m, n) for (int i = m; i >= n; i--)\n#define VSORT(v) sort((v).begin(), (v).end()) // sort vector\ntypedef pair<int, int> PI;\ntypedef tuple<int, int, int> TI;\ntemplate <typename T> using Vec = vector<T>; // c++11\n\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nvoid dump (Vec<Vec<char>>& table) {\n    FOR(i, 0, 10) {\n        FOR(j, 0, 10) {\n            cout << table[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool change(Vec<Vec<char>>& table, char me, char you) {\n    int ans_i = 0;\n    int ans_j = 0;\n    int ans_cnt = 0;\n\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            if (table[i][j] != '.') {\n                continue;\n            }\n            int cnt = 0;\n            FOR(k, 0, 8) {\n                int now_cnt = 0;\n                int mul = 1;\n                while (1) {\n                    int cy = i + mul * dy[k];\n                    int cx = j + mul * dx[k];\n                    char moji = table[cy][cx];\n                    if (moji == me) {\n                        cnt += now_cnt;\n                        break;\n                    } else if (moji != you) {\n                        break;\n                    } else {\n                        mul++;\n                        now_cnt++;\n                    }\n                }\n            }\n            if (cnt > ans_cnt || (cnt == ans_cnt && me == 'x')) {\n                ans_i = i;\n                ans_j = j;\n                ans_cnt = cnt;\n            }\n        }\n    }\n\n    if (ans_cnt == 0) {\n        return false;\n    } else {\n        table[ans_i][ans_j] = me;\n        FOR(i, 0, 8) {\n            int mul = 1;\n            while (1) {\n                int cy = ans_i + mul * dy[i];\n                int cx = ans_j + mul * dx[i];\n                char moji = table[cy][cx];\n                if (moji == me) {\n                    RFOR(j, mul, 0) {\n                        cy -= dy[i];\n                        cx -= dx[i];\n                        table[cy][cx] = me;\n                    }\n                    break;\n                } else if (moji == you) {\n                    mul++;\n                } else {\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n}\n\nint main(void) {\n    Vec<Vec<char>> table(10, Vec<char>(10, '#'));\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            cin >> table[i][j];\n        }\n    }\n\n    bool tomoe_check = true;\n    bool majyo_check = true;\n    while (1) {\n        tomoe_check = change(table, 'o', 'x');\n        if (tomoe_check == false && majyo_check == false) {\n            break;\n        }\n        majyo_check = change(table, 'x', 'o');\n        if (tomoe_check == false && majyo_check == false) {\n            break;\n        }\n    }\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            cout << table[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nchar f[8][8];\n\ninline bool inner(int x, int y) { return 0<=x && x<8 && 0<=y && y<8; }\n\nint kount(int cx, int cy, char me, char ene) {\n    if(f[cx][cy]!='.') return 0;\n    int c = 0;\n    rep(d, 8) {\n        int x = cx+dx[d], y = cy+dy[d], t = 0;\n        while(inner(x, y) && f[x][y]==ene) x+=dx[d], y+=dy[d], t++;\n        if(inner(x, y) && f[x][y]==me) c += t;\n    }\n    return c;\n}\n\nvoid flip(int cx, int cy, char me, char ene) {\n    if(f[cx][cy]!='.') return ;\n    f[cx][cy] = me;\n    rep(d, 8) {\n        int x = cx+dx[d], y = cy+dy[d];\n        while(inner(x, y) && f[x][y]==ene) x+=dx[d], y+=dy[d];\n        if(inner(x, y) && f[x][y]==me) {\n            int tx=cx, ty=cy;\n            while(tx!=x || ty!=y) {\n                f[tx][ty] = me;\n                tx+=dx[d], ty+=dy[d];\n            }\n        }\n    }\n}\n\nint main() {\n    rep(i, 8) rep(j, 8) scanf(\" %c\", f[i]+j);\n    int a, b;\n    do {\n        a = 0;\n        rep(i, 8) rep(j, 8) a = max(a, kount(i, j, 'o', 'x'));\n        if(a) rep(i, 8) rep(j, 8) if(kount(i, j, 'o', 'x')==a) {\n            flip(i, j, 'o', 'x');\n            a = -1;\n        }\n        b = 0;\n        rep(i, 8) rep(j, 8) b = max(b, kount(i, j, 'x', 'o'));\n        if(b) rep(i, 8) rep(j, 8) if(kount(7-i, 7-j, 'x', 'o')==b) {\n            flip(7-i, 7-j, 'x', 'o');\n            b = -1;\n        }\n    } while(a || b);\n    rep(i, 8) {\n        rep(j, 8) putchar(f[i][j]);\n        putchar('\\n');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> P;\n\nint cho,che;\nchar table[8][8];\nvector<P> v;\n\nconst int dx[8] = {0,0,1,1,1,-1,-1,-1};\nconst int dy[8] = {1,-1,0,-1,1,-1,0,1};\nconst char ch[3] = {'x','o'};\n\nvoid check(int x,int y,int turn,vector<P> &v){\n  char c = ch[turn],d = ch[1-turn];\n  int count = 0;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int cnt = 0;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tif(table[nx][ny] == c){\n\t  count += cnt;\n\t}\n\tbreak;\n      }\n\n      cnt++;\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }   \n\n  if(count == 0){\n    return;\n  }\n\n  if(turn){\n    v.push_back(P(-count,PA(x,y)));\n  }else{\n    v.push_back(P(-count,PA(-x,-y)));\n  }\n}\n\nvoid change(P a,int turn){\n  char c = ch[turn],d = ch[1-turn];\n\n  a.first = -a.first;\n\n  if(!turn){\n    a.second.first = -a.second.first;\n    a.second.second = -a.second.second;\n  }\n\n  table[a.second.first][a.second.second] = c;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int nx = a.second.first + dx[i];\n    int ny = a.second.second + dy[i];\n    vector<PA> v;\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tbreak;\n      }\n\n      v.push_back(PA(nx,ny));\n      nx += dx[i];\n      ny += dy[i];\n    }\n\n    if(!(0 > nx || 0 > ny || nx >= 8 || ny >= 8) && table[nx][ny] == c){\n      while(true){     \n\tif(nx == a.second.first && ny == a.second.second){\n\t  break;\n\t}\n\ttable[nx][ny] = c;  \n\tnx -= dx[i];\n\tny -= dy[i];\n      }\n    }\n\n  } \n\n  if(turn){\n    cho += a.first+1;\n    che -= a.first;\n  }else{\n    cho -= a.first;\n    che += a.first+1;\n  }\n}\n\nint main(){\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cin >> table[i][j];\n\n      if(table[i][j] == 'o'){\n\tcho++;\n      }else if(table[i][j] == 'x'){\n\tche++;\n      }\n    }\n  }\n\n  //true mami ------ false witch\n  bool turn = true;\n  int end = 60;\n\n  while(true){\n    vector<P> v;\n \n    if(!end || !cho || !che || cho+che == 64){\n      break;\n    }\n    end--;\n    for(int i = 0 ; i < 8 ; i++){\n      for(int j = 0 ; j < 8 ; j++){\n\tif(table[i][j] == '.'){\n\t  int n = turn ? 1 : 0;\n\t  check(i,j,n,v);\n\t}\n      }\n    }\n  \n    if(v.size() > 0){\n      int n = turn ? 1 : 0;\n      sort(v.begin(),v.end());\n      change(v[0],n);\n    }\n\n    turn = !turn;\n  }\n\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cout << table[i][j];\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std; \n#define MAXA 100000000\n#define MAXB 100000000\n#define MAXC 100000000\n#define MAXD 100000000\n#define MAXN 50\n#define MAXM 50\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nchar board[8][8];\nint check(int x,int y,char c)\n{\n  int res=0;\n  if(board[y][x] !='.'){return 0;}\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      int count=0;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[ny][nx]==c){res+=count;break;}\n\t  if(board[ny][nx]=='.'){break;}\n\t  count++;\n\t}\n    }\n  return res;\n}\nvoid put(int x,int y,char c)\n{\n  board[y][x]=c;\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[nx][ny]==c){\n\t    while(1)\n\t      {\n\t\tnx -=dx[k];\n\t\tny -=dy[k];\n\t\tif(nx == x && ny == y){break;}\n\t\tboard[ny][nx]= c;\n\t      }\n\t    break;\n\t  }\n\t  if(board[ny][nx]=='.'){break;}\n\t}\n    }\n}\n\nbool win()\n{\n  int o_count=0;\n  int x_count=0;\n  for(int x=0;x<8;x++)\n    {\n      for(int y=0;y<8;y++)\n\t{\n\t  if(board[x][y]=='o'){o_count++;}\n\t  if(board[x][y]=='x'){x_count++;}\n\t}\n    }\n  return o_count==0 || x_count==0 || o_count+x_count==64;\n}\n    \nint main(int argc,char const* argv[])\n{\n  for(int i=0;i<8;i++)\n    {\n      for(int j=0;j<8;j++)\n\t{\n\t  cin >> board[i][j];\n\t}\n    }\n  int turn=1;\n  int max_x,max_y;\n  int pass=0;\n  while(1)\n    {\n      char player=(turn % 2) ? 'o' : 'x';\n      int num=0;max_x=-1,max_y=-1;\n      if(player == 'o')\n\t{\n\t  for(int y=0;y<8;y++)\n\t    {\n\t      for(int x=0;x<8;x++)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for(int y=7;y>=0;y--)\n\t    {\n\t      for(int x=7;x>=0;x--)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(max_x != -1)\n\t{\n\t  pass=0;\n\t  put(max_x,max_y,player);\n\t}\n      else\n\t{\n\t  pass++;\n\t}\n      turn++;\n      if(pass>1){break;}\n      if(win()){break;}\n    }\n    \n  for(int y=0;y<8;y++)\n    {\n      for(int x=0;x<8;x++)\n\t{\n\t  cout << board[y][x];\n\t}\n      cout << endl;\n    }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/*??????????????£?????????*/\nstring field[8];\n\n/*????????¢??°*/\n/*player=0 Mami / player=1 Majo*/\nint Evaluation(int x,int y,int player){\n  int n=0;\n  int temp;\n  if(player == 0){\n    \n    /*???*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'o'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }else{\n    \n    /*???*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'x'){\n\tn+=temp;\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }\n  \n  return n;\n}\n\n/*?????¢??????*/\n/*player=0 Mami / player=1 Majo*/\nvoid Reflection(int x,int y,int player){\n  int temp;\n  if(player == 0){\n    \n    /*???*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x+j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'x'){\n\ttemp++;\n      }else if(field[y][i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x-j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'x'){\n\ttemp++;\n      }else if(field[i][x] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x+j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x+j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x-j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'x'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'o'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x-j] = 'o';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }else{\n    \n    /*???*/\n    temp=0;\n    for(int i=x+1 ; i < 8 ; i++){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x+j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=x-1 ; i >= 0 ; i--){\n      if(field[y][i] == 'o'){\n\ttemp++;\n      }else if(field[y][i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y][x-j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y-1 ; i >=0 ; i--){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*???*/\n    temp=0;\n    for(int i=y+1 ; i < 8 ; i++){\n      if(field[i][x] == 'o'){\n\ttemp++;\n      }else if(field[i][x] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y-i >=0 ;i++){\n      if(field[y-i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x+i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x+j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x+i < 8 && y+i < 8 ; i++){\n      if(field[y+i][x+i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x+i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x+j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y-i >=0 ;i++){\n      if(field[y-i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y-i][x-i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y-j][x-j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    /*??????*/\n    temp=0;\n    for(int i=1 ; x-i >= 0 && y+i < 8 ;i++){\n      if(field[y+i][x-i] == 'o'){\n\ttemp++;\n      }else if(field[y+i][x-i] == 'x'){\n\tfor(int j=1 ; j <= temp ; j++){\n\t  field[y+j][x-j] = 'x';\n\t}\n\tbreak;\n      }else{\n\tbreak;\n      }\n    }\n    \n  }\n}\n/*?????¢?????¨???????????£????????????true*/\n\nbool flag1,flag2;\n\nbool Mami(){\n  bool flag = true;\n  int n=0,x,y;\n  for(int i=0 ; i < 8 ; i++){\n    for(int j=0 ; j < 8 ; j++){\n      if(field[i][j] == '.'){\n\tint temp = Evaluation(j,i,0);\n\tif(temp > n){\n\t  n = temp;\n\t  x = j;\n\t  y = i;\n \t}\n\tflag = false;\n      }\n    }\n  }\n  if(n > 0){\n    field[y][x]='o';\n    Reflection(x,y,0);\n    flag1 = false;\n  }\n  return flag;\n}\n\nbool Majo(){\n  bool flag = true;\n  int n=0,x,y;\n  for(int i=7 ; i >= 0 ; i--){\n    for(int j=7 ; j >= 0 ; j--){\n      if(field[i][j] == '.'){\n\tint temp = Evaluation(j,i,1);\n\tif(temp > n){\n\t  n = temp;\n\t  x = j;\n\t  y = i;\n \t}\n\tflag = false;\n      }\n    }\n  }\n  if(n > 0){\n    field[y][x]='x';\n    Reflection(x,y,1);\n    flag2 = false;\n  }\n  return flag;\n}\n\nint main(){ \n  \n  for(int i=0 ; i < 8 ; i++)cin >>field[i];\n  \n  /*o??????????????????*/\n  int player = 0; // 0:o 1:x\n  int cnt=0;\n  /*?????????????????´??????????????????,????????????????????????????????????????????§*/\n  while(1){\n    flag1=true;\n    flag2=true;\n    if(player%2 == 0){\n      if(Mami())break;\n    }else{\n      if(Majo())break;\n    }\n    if(flag1 == true && flag2 == true)cnt++;\n    if(flag1 == false || flag2 == false)cnt=0;\n    if(cnt > 1)break;\n    // if(player==17)break;\n    player++;\n  }\n  \n  /*?????¢??????*/\n  for(int i=0 ; i < 8 ; i++)cout <<field[i]<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint dx[8] = {-1, 0,+1,-1,+1,-1, 0,+1};\nint dy[8] = {-1,-1,-1, 0, 0,+1,+1,+1};\nchar f[256] = {0};\n\nvoid debug(const vector<string>& v){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < 8 ; y++ ){\n\t\tcout << v[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// (x,y) に c を置く\nvoid place(int x, int y, char c, vector<string>& v){\n\tif( v[y][x] != '.' ) return;\n\tv[y][x] = c;\n\t\n\t// p[i] := 方向 i に置けるかどうか \n\tint p[8] = {false};\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) continue;\n\t\tif( v[my][mx] == f[c] ){\n\t\t\twhile( true ){\n\t\t\t\tmx += dx[i];\n\t\t\t\tmy += dy[i];\n\t\t\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) break;\n\t\t\t\tif( v[my][mx] == '.' ) break;\n\t\t\t\tif( v[my][mx] == c ){\n\t\t\t\t\tp[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tif( !p[i] ) continue;\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) continue;\n\t\tif( v[my][mx] == f[c] ){\n\t\t\twhile( true ){\n\t\t\t\tif( v[my][mx] == f[c] ){\n\t\t\t\t\tv[my][mx] = c;\n\t\t\t\t}\n\t\t\t\tmx += dx[i];\n\t\t\t\tmy += dy[i];\n\t\t\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) break;\n\t\t\t\tif( v[my][mx] == '.' || v[my][mx] == c ) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// (x,y) に c をおいた時にひっくり返す個数を返す.\nint get_stone(int x, int y, char c, vector<string> v){\n\tif( v[y][x] != '.' ) return 0;\n\t\n\t// p[i] := 方向 i に置けるかどうか \n\tint p[8] = {false};\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) continue;\n\t\tif( v[my][mx] == f[c] ){\n\t\t\twhile( true ){\n\t\t\t\tmx += dx[i];\n\t\t\t\tmy += dy[i];\n\t\t\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) break;\n\t\t\t\tif( v[my][mx] == '.' ) break;\n\t\t\t\tif( v[my][mx] == c ){\n\t\t\t\t\tp[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int i=0 ; i < 8 ; i++ ){\n\t\tif( !p[i] ) continue;\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) continue;\n\t\tif( v[my][mx] == f[c] ){\n\t\t\twhile( true ){\n\t\t\t\tif( v[my][mx] == f[c] ) res++;\n\t\t\t\tmx += dx[i];\n\t\t\t\tmy += dy[i];\n\t\t\t\tif( mx < 0 || my < 0 || 8 <= mx || 8 <= my ) break;\n\t\t\t\tif( v[my][mx] == '.' || v[my][mx] == c ) break;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<string> solve(char c, vector<string> v, bool pass = false){\n\tint cnt = 0;\n\tfor(int y=0 ; y < 8 ; y++ ){\n\t\tfor(int x=0 ; x < 8 ; x++ ){\n\t\t\tcnt = max( cnt , get_stone(x,y,c,v) );\n\t\t}\n\t}\n\t\n\t//debug(v);\n\t\n\tif( cnt == 0 ){ // パスするとき\n\t\tif( pass ){ // 前回もパスなら試合終了\n\t\t\treturn v;\n\t\t}else{ // パスする\n\t\t\treturn solve(f[c],v,true);\n\t\t}\n\t}\n\t\n\tif( c == 'o' ){\n\t\tfor(int y=0 ; y < 8 ; y++ ){\n\t\t\tfor(int x=0 ; x < 8 ; x++ ){\n\t\t\t\tif( cnt == get_stone(x,y,c,v) ){\n\t\t\t\t\tplace(x,y,c,v);\n\t\t\t\t\treturn solve(f[c],v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(int y=7 ; y >= 0 ; y-- ){\n\t\t\tfor(int x=7 ; x >= 0 ; x-- ){\n\t\t\t\tif( cnt == get_stone(x,y,c,v) ){\n\t\t\t\t\tplace(x,y,c,v);\n\t\t\t\t\treturn solve(f[c],v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tf['o'] = 'x';\n\tf['x'] = 'o';\n\tvector<string> v(8);\n\tfor(int y=0 ; y < 8 ; y++ ){\n\t\tcin >> v[y];\n\t}\n\tvector<string> ans = solve('o',v);\n\tfor(int y=0 ; y < 8 ; y++ ){\n\t\tcout << ans[y] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nchar map[8][8];\n\nint mami_search(int starty, int startx, int dy, int dx)\n{\n\tint ret = 0;\n\tint count = 0;\n\tbool flag = false;\n\tint ny = starty;\n\tint nx = startx;\n\n\twhile (true) {\n\t\tny += dy;\n\t\tnx += dx;\n\n\t\tif (ny < 0 || ny >= 8 || nx < 0 || nx >= 8 || map[ny][nx] == '.') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (map[ny][nx] == 'x') {\n\t\t\tcount++;\n\t\t}\n\n\t\tif (map[ny][nx] == 'o') {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flag == true) {\n\t\tret = count;\n\t}\n\n\treturn ret;\n}\n\nvoid mami_reverse(int y, int x)\n{\n\tmap[y][x] = 'o';\n\n\tfor (int dy = -1; dy <= 1; dy++) {\n\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\tbool flag = false;\n\t\t\tint yy = y + dy;\n\t\t\tint xx = x + dx;\n\n\t\t\twhile (true) {\n\t\t\t\tif (yy < 0 || yy >= 8 || xx < 0 || x >= 8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (map[yy][xx] == 'x') {\n\t\t\t\t\tmap[yy][xx] = 'p';\n\t\t\t\t}\n\t\t\t\telse if (map[yy][xx] == 'o') {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tyy += dy;\n\t\t\t\txx += dx;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (map[i][j] == 'p') {\n\t\t\t\t\t\tif (flag == true) {\n\t\t\t\t\t\t\tmap[i][j] = 'o';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmap[i][j] = 'x';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool mami()\n{\n\tbool flag = false;\n\tint num = 0;\n\tint ans_x, ans_y;\n\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tif (map[y][x] == '.') {\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\tcount += mami_search(y, x, dy, dx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (num < count) {\n\t\t\t\t\tans_y = y;\n\t\t\t\t\tans_x = x;\n\t\t\t\t\tnum = count;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flag == true) {\n\t\tmami_reverse(ans_y, ans_x);\n\t}\n\n\treturn flag;\n}\n\nint charlotte_search(int starty, int startx, int dy, int dx)\n{\n\tint ret = 0;\n\tint count = 0;\n\tbool flag = false;\n\tint ny = starty;\n\tint nx = startx;\n\n\twhile (true) {\n\t\tny += dy;\n\t\tnx += dx;\n\n\t\tif (ny < 0 || ny >= 8 || nx < 0 || nx >= 8 || map[ny][nx] == '.') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (map[ny][nx] == 'o') {\n\t\t\tcount++;\n\t\t}\n\n\t\tif (map[ny][nx] == 'x') {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flag == true) {\n\t\tret = count;\n\t}\n\n\treturn ret;\n}\n\nvoid charlotte_reverse(int y, int x)\n{\n\tmap[y][x] = 'x';\n\n\tfor (int dy = -1; dy <= 1; dy++) {\n\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\tbool flag = false;\n\t\t\tint yy = y + dy;\n\t\t\tint xx = x + dx;\n\n\t\t\twhile (true) {\n\t\t\t\tif (yy < 0 || yy >= 8 || xx < 0 || x >= 8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (map[yy][xx] == 'o') {\n\t\t\t\t\tmap[yy][xx] = 'p';\n\t\t\t\t}\n\t\t\t\telse if (map[yy][xx] == 'x') {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tyy += dy;\n\t\t\t\txx += dx;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (map[i][j] == 'p') {\n\t\t\t\t\t\tif (flag == true) {\n\t\t\t\t\t\t\tmap[i][j] = 'x';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmap[i][j] = 'o';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool charlotte()\n{\n\tbool flag = false;\n\tint num = 0;\n\tint ans_x, ans_y;\n\n\tfor (int y = 7; y >= 0; y--) {\n\t\tfor (int x = 7; x >= 0; x--) {\n\t\t\tif (map[y][x] == '.') {\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\t\tcount += charlotte_search(y, x, dy, dx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (num < count) {\n\t\t\t\t\tans_y = y;\n\t\t\t\t\tans_x = x;\n\t\t\t\t\tnum = count;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flag == true) {\n\t\tcharlotte_reverse(ans_y, ans_x);\n\t}\n\n\treturn flag;\n}\n\n\nint main()\n{\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tcin >> map[y][x];\n\t\t}\n\t}\n\n\tbool mami_flag = true;\n\tbool charlotte_flag = true;\n\n\twhile (mami_flag == true || charlotte_flag == true) {\n\t\tmami_flag = mami();\n\t\tcharlotte_flag = charlotte();\n\t}\n\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tcout << map[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n\n#define reps(i,f,n) for(int i = f; i < int(n); i++)\n#define rep(i,n) reps(i,0,n)\n\nusing namespace std;\n\nchar cell[16][16];\nchar co[] = {'o','x'};\nint dx[] = {1, 1,  1,  0, -1, -1, -1, 0};\nint dy[] = {1, 0, -1, -1, -1 , 0,  1, 1};\n\n\nint check(int x, int y){\n\tif(x<0||y<0||8<=y||8<=x)return 0;\n\treturn 1;\n}\n\nint cp(int index, int turn){\n\tif(turn == 0){\n\t\treturn index < 8;\n\t}else{\n\t\treturn index >= 0;\n\t}\n}\n\nint func(int turn){\n\tint get[8][8]={0};\n\t\n\trep(i,8) rep(j,8)get[i][j]=-1;\n\t\n\tint di, f;\n\tif(turn==0){\n\t\tdi = 1;\n\t\tf = 0;\n\t}\n\telse{\n\t\tdi = -1;\n\t\tf = 7;\n\t}\n\tfor(int i = f; cp(i,turn); i+=di)for(int j = f; cp(j,turn); j+=di){\n\t\tint t = 0;\n\t\tif(cell[i][j]=='.'){\n\t\t\trep(k,8){\n\t\t\t\tint c = 0;\n\t\t\t\tint x = j+dx[k];\n\t\t\t\tint y = i+dy[k];\n\t\t\t\twhile(check(x,y)){\n\t\t\t\t\tif(cell[y][x]==co[turn]){\n\t\t\t\t\t\tt+=c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(cell[y][x] == co[1-turn]){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}else if(cell[y][x] =='.'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ty+=dy[k];\n\t\t\t\t\tx+=dx[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t==0)t=-1;\n\t\tget[i][j] = t;\n\t}\n\t\n\t//rep(i,8){rep(j,8){printf(\"%3d\", get[i][j]);}puts(\"\");}\n\t\n\tint mg = 0;\n\trep(i,8)rep(j,8)mg = get[i][j]>mg?get[i][j]:mg;\n\tfor(int i = f; cp(i,turn); i+=di)for(int j = f; cp(j,turn); j+=di){\n\t\tif(get[i][j] == mg){\n\t\t\tcell[i][j] = co[turn];\n\t\t\trep(k,8){\n\t\t\t\tqueue< pair<int,int> > c;\n\t\t\t\tint x = j+dx[k];\n\t\t\t\tint y = i+dy[k];\n\t\t\t\twhile(check(x,y)){\n\t\t\t\t\tif(cell[y][x]==co[1-turn]){\n\t\t\t\t\t\tc.push(make_pair(x,y));\n\t\t\t\t\t}else if(cell[y][x] == co[turn]){\n\t\t\t\t\t\twhile(!c.empty()){\n\t\t\t\t\t\t\tint xx=c.front().first;\n\t\t\t\t\t\t\tint yy=c.front().second;\n\t\t\t\t\t\t\tc.pop();\n\t\t\t\t\t\t\tcell[yy][xx]=co[turn];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(cell[y][x] == '.'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ty+=dy[k];\n\t\t\t\t\tx+=dx[k];\n\t\t\t\t}\n\t\t\t}\n\t//\t\trep(k,8)puts(cell[k]);\n\t//\t\tputs(\"\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\t\n\trep(i,8) scanf(\"%s\", cell[i]);\n\t\n\tint t = 0;\n\tint turn = 0;\n\t\n\twhile(t!=2){\n\t\tif(!func(turn)){\n\t\t\tt++;\n\t\t}else{\n\t\t\tt = 0;\n\t\t}\n//\t\tprintf(\"%d\\n\", t);\n\t\tturn = 1 - turn;\n\t}\t\n\t\n\trep(i,8)puts(cell[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <regex>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring fld[8];\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nbool endf()\n{\n\tint a = 0; int b = 0; int c = 0;\n\tREP(i, 8)REP(j, 8)\n\t{\n\t\tif (fld[i][j] == 'o') a++;\n\t\telse if (fld[i][j] == 'x') b++;\n\t\telse c++;\n\t}\n\tif (a == 0 || b == 0 || c == 0) return false;\n\telse return true;\n}\n\nvector<P> search(char c)\n{\n\tvector<P> v;\n\tint mx = 1;\n\tREP(i, 8)REP(j, 8)\n\t{\n\t\tif (fld[i][j] != '.') continue;\n\t\tint cnt = 0;\n\t\tREP(k, 8)\n\t\t{\n\t\t\tint tmp = 0;\n\t\t\tint nx = i; int ny = j;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 ||fld[nx][ny]=='.') break;\n\t\t\t\telse if (fld[nx][ny] != c)\n\t\t\t\t{\n\t\t\t\t\ttmp++; continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcnt += tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt > mx)\n\t\t{\n\t\t\tv.clear();\n\t\t\tv.push_back(P(i, j));\n\t\t\tmx = cnt;\n\t\t}\n\t\telse if (cnt == mx)\n\t\t{\n\t\t\tv.push_back(P(i, j));\n\t\t}\n\t}\n\treturn v;\n}\n\nvoid majo()\n{\n\tvector<P> v = search('x');\n\tint x, y;\n\tif (v.size() > 0)\n\t{\n\t\tx = v.back().first; y = v.back().second;\n\t\tfld[x][y] = 'x';\n\t\tREP(k, 8)\n\t\t{\n\t\t\tvector<P> w;\n\t\t\tint nx = x; int ny = y;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 || fld[nx][ny] == '.') break;\n\t\t\t\telse if (fld[nx][ny] == 'o')\n\t\t\t\t{\n\t\t\t\t\tw.push_back(P(nx, ny)); continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREP(i, w.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tfld[w[i].first][w[i].second] = 'x';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid mami()\n{\n\tvector<P> v = search('o');\n\tint x, y;\n\tif (v.size() > 0)\n\t{\n\t\tx = v[0].first; y = v[0].second;\n\t\tfld[x][y] = 'o';\n\t\tREP(k, 8)\n\t\t{\n\t\t\tvector<P> w;\n\t\t\tint nx = x; int ny = y;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tnx = nx + dx[k]; ny = ny + dy[k];\n\t\t\t\tif (nx<0 || ny<0 || nx>7 || ny>7 || fld[nx][ny] == '.') break;\n\t\t\t\telse if (fld[nx][ny] == 'x')\n\t\t\t\t{\n\t\t\t\t\tw.push_back(P(nx, ny)); continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tREP(i, w.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tfld[w[i].first][w[i].second] = 'o';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main()\n{\n\tREP(i, 8) cin >> fld[i];\n\tfor (int i = 0; endf(); i++)\n\t{\n\t\tif (i % 2) majo();\n\t\telse mami();\n\t}\n\tREP(i, 8) cout << fld[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define FORQ(i,a,b) for(int i = (a); i <= (b); i++)\n#define FORD(i,a,b) for(int i = (a)-1; i >= b; i--)\nusing vi = vector<int>;\n\nbool isin(int x, int y){\n  return (0 <= x) and (x < 8) and (0 <= y) and (y < 8);\n}\n\nvi dx = {1,0,-1,0,1,1,-1,-1}, dy = {0,1,0,-1,1,-1,1,-1};\n\nint main(){\n  vector<string> board(8);\n  rep(i,8) cin >> board[i];\n  bool ismami = true;\n  int notchanged = 0;\n\n  while(1){\n    //cerr << ismami << endl;\n    vector<string> prev = board; // 前の盤面を取っておくよう\n    vector<string> next = board; // 数最大の候補\n    int rnum = 0; // 最大のひっくり返せる数\n\n    if(ismami){\n      rep(i,8) rep(j,8){ // (i,j)に置くことを試す\n\tboard = prev;\n\tint tmp = 0; // (i,j)に置くときにひっくり返せる数\n\tif(board[i][j] != '.') continue;\n\trep(k,8) FORQ(l,1,8){\n\t  int nx = i + l * dx[k], ny = j + l * dy[k];\n\t  if(not isin(nx,ny)) break;\n\t  if(board[nx][ny] == 'x') continue;\n\t  if(board[nx][ny] == 'o'){\n\t    //cerr << i << \"\\t\" << j << \"\\t\" << l << endl;\n\t    tmp += l - 1;\n\t    FOR(m, 0, l) board[i+m*dx[k]][j+m*dy[k]] = 'o';\n\t    break;\n\t  }\n\t  if(board[nx][ny] == '.') break;\n\t}\n\tif(tmp > rnum){\n\t  //cerr << tmp << endl;\n\t  rnum = tmp;\n\t  next = board;\n\t}\n      }\n    }else{\n      FORD(i,8,0) FORD(j,8,0){ // (i,j)に置くことを試す\n\tboard = prev;\n\tint tmp = 0; // (i,j)に置くときにひっくり返せる数\n\tif(board[i][j] != '.') continue;\n\trep(k,8) FORQ(l,1,8){\n\t  int nx = i + l * dx[k], ny = j + l * dy[k];\n\t  if(not isin(nx,ny)) break;\n\t  if(board[nx][ny] == 'o') continue;\n\t  if(board[nx][ny] == 'x'){\n\t    tmp += l - 1;\n\t    FOR(m, 0, l) board[i+m*dx[k]][j+m*dy[k]] = 'x';\n\t    break;\n\t  }\n\t  if(board[nx][ny] == '.') break;\n\t}\n\tif(tmp > rnum){\n\t  //cerr << tmp << endl;\n\t  rnum = tmp;\n\t  next = board;\n\t}\n        \n      }\n    }\n\n    board = next;\n    ismami = not ismami;\n    \n    if(prev == next) notchanged++;\n    else notchanged = 0;\n    if(notchanged == 2) break;\n    // rep(i,8){\n    //   rep(j,8) cerr << board[i][j];\n    //   cerr << endl;\n    // }\n  }\n  rep(i,8){\n    rep(j,8) cout << board[i][j];\n    cout << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nvector< vector<char> >V(8,vector<char>(8));\nint dx[8]={-1,1,0,0,-1,-1,1,1};\nint dy[8]={0,0,-1,1,-1,1,-1,1};\n\nbool update;\nint idx,idy,count;\nbool can[8];\n\nbool in(int x,int y){\n\treturn x>=0 && y>=0 && x<8 && y<8;\n}\n\nvoid check(int k){\n\tchar me,you;\n\tbool tcan[8];\n\tcount=0;\n\tmemset(can,false,sizeof(can));\n\tif(k==0){me='o';you='x';}\n\telse{me='x';you='o';}\n\tif(k==0){\n\tfor(int y=0;y<8;y++){\n\t\tint tcount,ttcount;\n\t\tfor(int x=0;x<8;x++){\n\t\t\ttcount=0;\n\t\t\tmemset(tcan,false,sizeof(tcan));\n\t\t\tif(V[y][x]!='.')\n\t\t\t\tcontinue;\n\t\t\tfor(int d=0;d<8;d++){\n\t\t\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\t\t\tttcount=0;\n\t\t\t\twhile(in(nx,ny)&&V[ny][nx]==you){\n\t\t\t\t\tnx+=dx[d];ny+=dy[d];ttcount++;\n\t\t\t\t}\n\t\t\t\tif(in(nx,ny) && V[ny][nx]==me &&ttcount>0){\n\t\t\t\t\ttcount+=ttcount;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\ttcan[d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tcount>count){\n\t\t\t\tidx=x;idy=y;count=tcount;update=true;\n\t\t\t\tfor(int i=0;i<8;i++) can[i]=tcan[i];\n\t\t\t}\n\t\t}\n\t}\n\t}\n\telse{\n\tfor(int y=7;y>=0;y--){\n\t\tint tcount,ttcount;\n\t\tfor(int x=7;x>=0;x--){\n\t\t\ttcount=0;\n\t\t\tmemset(tcan,false,sizeof(tcan));\n\t\t\tif(V[y][x]!='.')\n\t\t\t\tcontinue;\n\t\t\tfor(int d=0;d<8;d++){\n\t\t\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\t\t\tttcount=0;\n\t\t\t\twhile(in(nx,ny)&&V[ny][nx]==you){\n\t\t\t\t\tnx+=dx[d];ny+=dy[d];ttcount++;\n\t\t\t\t}\n\t\t\t\tif(in(nx,ny) && V[ny][nx]==me &&ttcount>0){\n\t\t\t\t\ttcount+=ttcount;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\ttcan[d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tcount>count){\n\t\t\t\tidx=x;idy=y;count=tcount;update=true;\n\t\t\t\tfor(int i=0;i<8;i++) can[i]=tcan[i];\n\t\t\t}\n\t\t}\n\t}\n\t}\n}\n\nvoid put(int k){\n\tchar me,you;\n\tif(count==0)\n\t\treturn;\n\tif(k==0){me='o';you='x';}\n\telse{me='x';you='o';}\n\tV[idy][idx]=me;\n\tfor(int d=0;d<8;d++){\n\t\tif(can[d]){\n\t\t\tint nx=idx+dx[d],ny=idy+dy[d];\n\t\t\twhile(in(nx,ny) && V[ny][nx]==you){\n\t\t\t\tV[ny][nx]=me;nx+=dx[d];ny+=dy[d];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print(){\n\tfor(int y=0;y<8;y++){\n\t\tfor(int x=0;x<8;x++)\n\t\t\tcout<<V[y][x];\n\t\tcout<<endl;\n\t}\n}\n\n\nint main()\n{\n\tfor(int y=0;y<8;y++)\n\t\tfor(int x=0;x<8;x++)\n\t\t\tcin>>V[y][x];\n\n\tupdate=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tcheck(0);\n\t\tput(0);\n\t\tcheck(1);\n\t\tput(1);\n\t}\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint T[8][8],x[8]={0,0,1,-1,1,1,-1,-1},y[8]={1,-1,0,0,1,-1,1,-1};\n/*\nvoid P(){\n for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      if(T[i][j]==0)cout<<'o';\n      else if(T[i][j]==1)cout<<'x';\n      else cout<<'.';\n    }\n    cout<<endl;\n  }\n}\n*/\nint count(int a,int b,int muki,int f)\n{\n  int c=0;\n  while(1){\n    a+=x[muki];b+=y[muki];\n    if(a<0 || b<0 || a>7|| b>7){\n      c=0;\n      break;\n    }\n    if(T[a][b]==2){\n      c=0;\n      break;\n    }\n    if(T[a][b]==f)break;\n    c++;\n  }\n  return c;\n}\n\nvoid move(int a,int b,int muki,int f)\n{\n  int flag=0,aa=a,bb=b;\n  while(1){\n    a+=x[muki];b+=y[muki];\n    if(a<0 || b<0 || a>7|| b>7)break;\n    if(T[a][b]==2)break;\n    if(T[a][b]==f){\n      flag=1;\n      break;\n    }\n  }\n  if(flag==0)return;\n  while(1){\n    aa+=x[muki];bb+=y[muki];\n    if(aa<0 || bb<0 || aa>7|| bb>7)break;\n    if(T[aa][bb]==2)break;\n    if(T[aa][bb]==f)break;\n    T[aa][bb]=f;\n  }\n} \nint main()\n{\n  char c;\n  int mk,ki,kj,mc,ci,cj,sum;\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cin>>c;\n      if(c=='o')T[i][j]=0;\n      else if(c=='x')T[i][j]=1;\n      else T[i][j]=2;\n    }\n  }\n  \n  while(1){\n    mk=0;ki=-1;kj=-1;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tif(T[i][j]==2){\n\t  sum=0;\n\t  for(int k=0;k<8;k++){\n\t    sum+=count(i,j,k,0);\n\t  }\n\t  if(mk<sum){\n\t    mk=sum;\n\t    ki=i;\n\t    kj=j;\n\t  }\t\n\t}\n      }\n    }\n    if(mk>0){\n      T[ki][kj]=0;\n      for(int i=0;i<8;i++)move(ki,kj,i,0);\n    }\n    //P();\n    mc=0;ci=-1;cj=-1;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tif(T[i][j]==2){\n\t  sum=0;\n\t  for(int k=0;k<8;k++){\n\t    sum+=count(i,j,k,1);\n\t  }\n\t  if(mc<=sum){\n\t    mc=sum;\n\t    ci=i;\n\t    cj=j;\n\t  }\t\n\t}\n      }\n    }\n    if(mc>0){\n      T[ci][cj]=1;\n      for(int i=0;i<8;i++)move(ci,cj,i,1);\n    }\n    //P();\n    if(mk==0 && mc==0)break;\n  }\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      if(T[i][j]==0)cout<<'o';\n      else if(T[i][j]==1)cout<<'x';\n      else cout<<'.';\n    }\n    cout<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[8]={0,1,1,1,0,-1,-1,-1};\nint y[8]={1,1,0,-1,-1,-1,0,1};\n\nbool canmove(int x,int y){\n  return (0 <= x && x <= 7 && 0 <= y && y <= 7);\n}\n\nint main(){\n  char m[8][8];\n  for(int i=0;i<8;i++) for(int j=0;j<8;j++) cin>>m[i][j];\n  char my='o',opp='x';\n  int turn = 0;\n  int nochange=0;\n  while(true){\n    int _max=0;\n    int ii=0,jj=0;\n    int data=0;\n    for(int i=0;i<8;i++){ \n      for(int j=0;j<8;j++){\n\tif(m[i][j]=='.'){\n\t  int temp=0;\n\t  int dd=0;\n\t  for(int k=0;k<8;k++){\n\t    int t=0;\n\t    for(int l=1;l<8;l++){\n\t      if(canmove(i+l*y[k],j+l*x[k])){\n\t\tchar target=m[i+l*y[k]][j+l*x[k]];\n\t\tif(target==opp) t++;\n\t\telse if(target==my){\n\t\t  temp+=t;\n\t\t  dd += (1<<k);\n\t\t  break;\n\t\t}\n\t\telse break;\n\t      }else break;\n\t    }\n\t  }\n\t  if(!turn && _max < temp){\n\t    _max=temp;\n\t    ii=i;\n\t    jj=j;\n\t    data=dd;\n\t  }else if(turn && _max <= temp){\n\t    _max=temp;\n\t    ii=i;\n\t    jj=j;\n\t    data=dd;\n\t  }\n\t}\n      }\n    }\n    if(_max==0){\n      nochange++;\n    }else{\n      m[ii][jj]=my;\n      for(int i=0;i<8;i++){\n\tfor(int j=1;j<8;j++){\n\t  if(((data>>i)&1) && canmove(ii+j*y[i],jj+j*x[i]) && m[ii+j*y[i]][jj+j*x[i]]==opp){\n\t    m[ii+j*y[i]][jj+j*x[i]]=my;\n\t  }else break;\n\t}\n      }\n      nochange=0;\n    }\n    if(nochange >= 2) break;\n    swap(my,opp);\n    turn = 1-turn;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<m[i][j];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint check(int **map, int now, int notnow, int x, int y, int put)\n{\n    int toreru = 0;\n    int temptoreru[3] = {0};\n    int temp = 7;\n    for(int i = 1; x-i >= 0 && temp != 0; i++)\n    {\n        if(temp & 0x04)\n        {\n            if(y-i < 0)\n            {\n                temp &= 0x03;\n            }\n            else\n            {\n                if(map[x-i][y-i] == now)\n                {\n                    if(put == 1)\n                    {\n                        for(int k = 0; k <= temptoreru[0]; k++)\n                        {\n                            map[x-k][y-k] = now;\n                        }\n                    }\n                    toreru += temptoreru[0];\n                    temp &= 0x03;\n                }\n                else if(map[x-i][y-i] == notnow)\n                {\n                    temptoreru[0]++;\n                }\n                else\n                {\n                    temp &= 0x03;\n                }\n            }\n        }\n        if(temp & 0x02)\n        {\n            if(map[x-i][y] == now)\n            {\n                if(put == 1)\n                {\n                    for(int k = 0; k <= temptoreru[1]; k++)\n                    {\n                        map[x-k][y] = now;\n                    }\n                }\n                toreru += temptoreru[1];\n                temp &= 0x05;\n            }\n            else if(map[x-i][y] == notnow)\n            {\n                temptoreru[1]++;\n            }\n            else\n            {\n                temp &= 0x05;\n            }\n        }\n        if(temp & 0x01)\n        {\n            if(y+i >= 8)\n            {\n                temp &= 0x06;\n            }\n            else\n            {\n                if(map[x-i][y+i] == now)\n                {\n                    if(put == 1)\n                    {\n                        for(int k = 0; k <= temptoreru[2]; k++)\n                        {\n                            map[x-k][y+k] = now;\n                        }\n                    }\n                    toreru += temptoreru[2];\n                    temp &= 0x06;\n                }\n                else if(map[x-i][y+i] == notnow)\n                {\n                    temptoreru[2]++;\n                }\n                else\n                {\n                    temp &= 0x06;\n                }\n            }\n        }\n    }\n\n    temp = 0x07;\n    temptoreru[0] = 0;\n    temptoreru[1] = 0;\n    temptoreru[2] = 0;\n\n    for(int i = 1; x + i < 8 && temp != 0; i++)\n    {\n        if(temp & 0x04)\n        {\n            if(y-i < 0)\n            {\n                temp &= 0x03;\n            }\n            else\n            {\n                if(map[x+i][y-i] == now)\n                {\n                    if(put == 1)\n                    {\n                        for(int k = 0; k <= temptoreru[0]; k++)\n                        {\n                            map[x+k][y-k] = now;\n                        }\n                    }\n                    toreru += temptoreru[0];\n                    temp &= 0x03;\n                }\n                else if(map[x+i][y-i] == notnow)\n                {\n                    temptoreru[0]++;\n                }\n                else\n                {\n                    temp &= 0x03;\n                }\n            }\n        }\n        if(temp & 0x02)\n        {\n            if(map[x+i][y] == now)\n            {\n                if(put == 1)\n                {\n                    for(int k = 0; k <= temptoreru[1]; k++)\n                    {\n                        map[x+k][y] = now;\n                    }\n                }\n                toreru += temptoreru[1];\n                temp &= 0x05;\n            }\n            else if(map[x+i][y] == notnow)\n            {\n                temptoreru[1]++;\n            }\n            else\n            {\n                temp &= 0x05;\n            }\n        }\n        if(temp & 0x01)\n        {\n            if(y+i >= 8)\n            {\n                temp &= 0x06;\n            }\n            else\n            {\n                if(map[x+i][y+i] == now)\n                {\n                    if(put == 1)\n                    {\n                        for(int k = 0; k <= temptoreru[2]; k++)\n                        {\n                            map[x+k][y+k] = now;\n                        }\n                    }\n                    toreru += temptoreru[2];\n                    temp &= 0x06;\n                }\n                else if(map[x+i][y+i] == notnow)\n                {\n                    temptoreru[2]++;\n                }\n                else\n                {\n                    temp &= 0x06;\n                }\n            }\n        }\n    }\n\n    temp = 0x03;\n    temptoreru[0] = 0;\n    temptoreru[1] = 0;\n\n    for(int i = 1; temp != 0; i++)\n    {\n        if(temp & 0x02)\n        {\n            if(y-1 < 0)\n            {\n                temp &= 0x01;\n            }\n            else\n            {\n                if(map[x][y-i] == now)\n                {\n                    if(put == 1)\n                    {\n                        for(int k = 0; k <= temptoreru[0]; k++)\n                        {\n                            map[x][y-k] = now;\n                        }\n                    }\n                    toreru += temptoreru[0];\n                    temp &= 0x01;\n                }\n                else if(map[x][y-i] == notnow)\n                {\n                    temptoreru[0]++;\n                }\n                else\n                {\n                    temp &= 0x01;\n                }\n            }\n        }\n        if(temp & 0x01)\n        {\n            if(y+1 >= 8)\n            {\n                temp &= 0x02;\n            }\n            else\n            {\n                if(map[x][y+i] == now)\n                {\n                    if(put == 1)\n                    {\n                        for(int k = 0; k <= temptoreru[1]; k++)\n                        {\n                            map[x][y+k] = now;\n                        }\n                    }\n                    toreru += temptoreru[1];\n                    temp &= 0x02;\n                }\n                else if(map[x][y+i] == notnow)\n                {\n                    temptoreru[1]++;\n                }\n                else\n                {\n                    temp &= 0x02;\n                }\n            }\n        }\n    }\n\n    return toreru;\n}\n\nint main()\n{\n    //int map[8][8] = {{0}};\n    int **map;\n    map = (int **)malloc(sizeof(int *)*8);\n    char temp;\n    for(int i = 0; i < 8; i++)\n    {\n        map[i] = (int *)malloc(sizeof(int)*8);\n        for(int j = 0; j < 8; j++)\n        {\n            scanf(\"%c\", &temp);\n            if(temp == 'o') map[i][j] = 1;\n            else if(temp == 'x') map[i][j] = 2;\n            else map[i][j] = 0;\n        }\n        scanf(\"%c\", &temp);\n    }\n\n    int turn = 1;\n    int loop = 0;\n\n    while(loop != 2)\n    {\n        //printf(\"%d, %d\\n\", turn, loop);\n        if(turn == 1)\n        {\n            int max = 0;\n            int x = -1;\n            int y = -1;\n            for(int i = 0; i < 8; i++)\n            {\n                for(int j = 0; j < 8; j++)\n                {\n                    if(map[i][j] == 0)\n                    {\n                        int temp = check(map, 1, 2, i, j, 0);\n                        if(temp > max)\n                        {\n                            max = temp;\n                            x = i;\n                            y = j;\n                        }\n                    }\n                }\n            }\n            if(x == -1)\n            {\n                loop++;\n            }\n            else\n            {\n                //printf(\"%d, %d\\n\", x, y);\n                int temp = check(map, 1, 2, x, y, 1);\n                loop = 0;\n            }\n            turn = 2;\n        }\n        else\n        {\n            int max = 0;\n            int x = -1;\n            int y = -1;\n            for(int i = 7; i >= 0; i--)\n            {\n                for(int j = 7; j >= 0; j--)\n                {\n                    if(map[i][j] == 0)\n                    {\n                        int temp = check(map, 2, 1, i, j, 0);\n                        if(temp > max)\n                        {\n                            max = temp;\n                            x = i;\n                            y = j;\n                        }\n                    }\n                }\n            }\n            if(x == -1)\n            {\n                loop++;\n            }\n            else\n            {\n                //printf(\"%d, %d\\n\", x, y);\n                int temp = check(map, 2, 1, x, y, 1);\n                loop = 0;\n            }\n            turn = 1;\n        }\n\n        /*\n        for(int i = 0; i < 8; i++)\n        {\n            for(int j = 0; j < 8; j++)\n            {\n                if(map[i][j] == 0) printf(\".\");\n                if(map[i][j] == 1) printf(\"o\");\n                if(map[i][j] == 2) printf(\"x\");\n            }\n            printf(\"\\n\");\n        }//*/\n    }\n\n\n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++)\n        {\n            if(map[i][j] == 0) printf(\".\");\n            if(map[i][j] == 1) printf(\"o\");\n            if(map[i][j] == 2) printf(\"x\");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstring s[8];\nint cnt[8][8];\n\nbool in(int y, int x) {\n    return y >= 0 && x >= 0 && y < 8 && x < 8;\n}\n\nint count(int sy, int sx, char c, char d) {\n    int res = 0;\n    for (int i = 0; i < 8; ++i) {\n        int y = sy + dy[i], x = sx + dx[i], num = 0;\n        while (in(y, x) && s[y][x] == d) {\n            y += dy[i];\n            x += dx[i];\n            num++;\n        }\n        if (!in(y, x) || s[y][x] != c) continue;\n        res += num;\n    }\n    return res;\n}\n\nvoid simu(int sy, int sx, char c, char d) {\n    for (int i = 0; i < 8; ++i) {\n        int y = sy + dy[i], x = sx + dx[i];\n        while (in(y, x) && s[y][x] == d) {\n            y += dy[i];\n            x += dx[i];\n        }\n        if (!in(y, x) || s[y][x] != c) continue;\n        s[sy][sx] = c;\n        y = sy + dy[i], x = sx + dx[i];\n        while (in(y, x) && s[y][x] == d) {\n            s[y][x] = c;\n            y += dy[i];\n            x += dx[i];\n        }\n    }\n}\n\nint mami() {\n    memset(cnt, 0, sizeof(cnt));\n    int mx = 0, y = -1, x = -1;\n    for (int i = 0; i < 8; ++i) for (int j = 0; j < 8; ++j) if (s[i][j] == '.') {\n        cnt[i][j] = count(i, j, 'o', 'x');\n        if (cnt[i][j] > mx) {\n            mx = cnt[i][j];\n            y = i;\n            x = j;\n        }\n    }\n    if (y < 0) return -1;\n    simu(y, x, 'o', 'x');\n    return 0;\n}\n\nint majo() {\n    memset(cnt, 0, sizeof(cnt));\n    int mx = 0, y = -1, x = -1;\n    for (int i = 7; i > -1; --i) for (int j = 7; j > -1; --j) if (s[i][j] == '.') {\n        cnt[i][j] = count(i, j, 'x', 'o');\n        if (cnt[i][j] > mx) {\n            mx = cnt[i][j];\n            y = i;\n            x = j;\n        }\n    }\n    if (y < 0) return -1;\n    simu(y, x, 'x', 'o');\n    return 0;\n}\n\nvoid _main() {\n    REP (i, 8) cin >> s[i];\n    int pass = 0;\n    while (true) {\n        if (mami() < 0) pass++;\n        else pass = 0;\n        if (pass == 2) break;\n        if (majo() < 0) pass++;\n        else pass = 0;\n        if (pass == 2) break;\n    }\n    REP (i, 8) cout << s[i] << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar c[10][10];\nint dx[3]={-1,0,1},dy[3]={-1,0,1};\n\nint solve(int y,int x,char now){\n\n    int res=0;\n\n    if(c[y][x]=='x' || c[y][x]=='o')return res;\n\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n\n            if(i==1 && j==1)j++;\n\n            int T=0,X=x,Y=y;\n\n            while(1){\n                int nx=X+dx[j],ny=Y+dy[i];\n\n                if(c[ny][nx]=='.')break;\n\n                else if(c[ny][nx]==now){\n                    \n                    res+=T;\n                    break;\n\n                }\n\n                else{\n\n                    T++;\n\n                    X=nx;Y=ny;\n                }\n\n            }\n        }\n    }\n\n    return res;\n\n}\n\nvoid hanten(int y,int x,char now){\n\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            if(i==1 && j==1)j++;\n\n            int T=0,X=x,Y=y;\n\n            while(1){\n                int nx=X+dx[j],ny=Y+dy[i];\n\n                if(c[ny][nx]=='.')break;\n                \n                else if(c[ny][nx]==now){\n                    \n                    for(int k=0;k<T;k++){\n\n                        c[Y][X]=now;\n                        \n                        Y-=dy[i];X-=dx[j];\n\n                    }\n\n                    break;\n\n                }\n\n                else{\n\n                    T++;\n\n                    X=nx;Y=ny;\n\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    for(int i=1;i<=8;i++){\n        for(int j=1;j<=8;j++)cin>>c[i][j];\n    }\n    for(int i=0;i<10;i++){\n        c[i][0]='.';c[i][9]='.';c[0][i]='.';c[9][i]='.';\n    }\n\n    bool t=true;//trueなら巴マミのターン\n\n    while(1){\n\n        bool fi=true;//終了判定\n\n        for(int i=1;i<=8;i++){\n            for(int j=1;j<=8;j++){\n                if(solve(i,j,'o')!=0 || solve(i,j,'x')!=0)fi=false;\n            }\n        }\n\n        if(fi){\n            for(int i=1;i<=8;i++){\n                for(int j=1;j<=8;j++){\n                    cout<<c[i][j];\n                }\n                cout<<endl;\n            }\n            break;\n        }\n\n        int x,y,MAX=0;//クッキーを置く位置\n\n        if(t){\n            t=false;\n            for(int i=1;i<=8;i++){\n                for(int j=1;j<=8;j++){\n                    if(c[i][j]=='.'){\n                        int a=solve(i,j,'o');\n                        if(MAX<a){\n                            x=j;y=i;MAX=a;\n                        }\n                    }\n                }\n            }\n\n            if(MAX!=0){\n\n                c[y][x]='o';\n\n                hanten(y,x,'o');\n\n            }\n        }\n        else{\n            t=true;\n            for(int i=8;i>0;i--){\n                for(int j=8;j>0;j--){\n                    if(c[i][j]=='.'){\n                        int a=solve(i,j,'x');\n                        if(MAX<a){\n                            x=j;y=i;MAX=a;\n                        }\n                    }\n                }\n            }\n\n            if(MAX!=0){\n\n                c[y][x]='x';\n\n                hanten(y,x,'x');\n            }\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<utility>\n#include<string.h>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define CHMIN(a,b) (a) = min((a),(b))\n#define CHMAX(a,b) (a) = max((a),(b))\n\nint search(char *ban,int y,int x,int dis,int jo)\n{\n    if(y<0||y>8)return 0;\n    if(x<0||x>8)return 0;\n    int dx[8]={0,1,1,1,0,-1,-1,-1};\n    int dy[8]={1,1,0,-1,-1,-1,0,1};\n    if((y+dy[dis]>=8 || y+dy[dis]<0))return 0;\n    if((x+dx[dis]>=8 || x+dx[dis]<0))return 0;\n    else if(jo==0&&*(ban+8*(y+dy[dis])+x+dx[dis])==*(ban+8*y+x))return 0;\n    else if(jo==0&&*(ban+8*(y+dy[dis])+x+dx[dis])=='.')return 0;\n    else if(jo==0&&*(ban+8*(y+dy[dis])+x+dx[dis])!=*(ban+8*y+x))\n    {\n        int a=search(ban,y+dy[dis],x+dx[dis],dis,1);\n        if(a>=1)return a;\n        else return 0;\n    }\n    else if(jo==1)\n    {\n        if(*(ban+8*(y+dy[dis])+x+dx[dis])==*(ban+8*y+x))\n        {\n            int a=search(ban,y+dy[dis],x+dx[dis],dis,1);\n            if(a>=1)return a+1;\n            else return 0;\n        }\n        else if(*(ban+8*(y+dy[dis])+x+dx[dis])=='.')return 0;\n        else return 1;\n    }\n    return 0;\n}\n\nvoid printban(char *ban)\n{\n    REP(i,8)\n    {\n        REP(j,8)printf(\"%c\",*(ban+8*i+j));\n        printf(\"\\n\");\n    }\n    return;\n}\n\nint re(char *ban, int y,int x , int dis ,int jo)\n{\n    if(y<0||y>8)return 0;\n    if(x<0||x>8)return 0;\n    int dx[8]={0,1,1,1,0,-1,-1,-1};\n    int dy[8]={1,1,0,-1,-1,-1,0,1};\n    if((y+dy[dis]>=8 || y+dy[dis]<0))return 0;\n    if((x+dx[dis]>=8 || x+dx[dis]<0))return 0;\n    else if(jo==0&&*(ban+8*(y+dy[dis])+x+dx[dis])==*(ban+8*y+x))return 0;\n    else if(jo==0&&*(ban+8*(y+dy[dis])+x+dx[dis])=='.')return 0;\n    else if(jo==0&&*(ban+8*(y+dy[dis])+x+dx[dis])!=*(ban+8*y+x))\n    {\n        if(re(ban,y+dy[dis],x+dx[dis],dis,1)==1)return 1;\n    }\n    else if(jo==1)\n    {\n        if(*(ban+8*(y+dy[dis])+x+dx[dis])==*(ban+8*y+x))\n        {\n            if(re(ban,y+dy[dis],x+dx[dis],dis,1)==1)\n            {\n                *(ban+8*y+x)='o'+'x'-*(ban+8*y+x);\n                return 1;\n            }\n            else return 0;\n        }\n        else if(*(ban+8*(y+dy[dis])+x+dx[dis])=='.')return 0;\n        else\n        {\n            *(ban+8*y+x)='o'+'x'-*(ban+8*y+x);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    char ban[64]={};\n    REP(i,8)\n    {\n        REP(j,8)scanf(\"%c\",&ban[i*8+j]);\n        scanf(\"\\n\");\n    }\n    int none=0;\n    int now=0;\n    int rexo[64]={};\n    int max;\n    int maxban;\n    while(1==1)\n    {\n        REP(i,64)rexo[i]=0;\n        max=0;\n        maxban=-1;\n        if(now==0)\n        {\n            REP(i,64)\n            {\n                if(ban[i]=='.')\n                {\n                    ban[i]='o';\n                    REP(k,8)rexo[i]+=search(&ban[0],i/8,i%8,k,0);\n                    ban[i]='.';\n                }\n            }\n            REP(i,64)if(max<rexo[i])\n            {\n                max=rexo[i];\n                maxban=i;\n            }\n            ban[maxban]='o';\n            REP(k,8)re(ban,maxban/8,maxban%8,k,0);\n            if(max==0)none++;\n            else none=0;\n            if(none==2)break;\n        }\n        else if(now==1)\n        {\n            for(int i=63;i>=0;i--)\n            {\n                if(ban[i]=='.')\n                {\n                    ban[i]='x';\n                    REP(k,8)rexo[i]+=search(&ban[0],i/8,i%8,k,0);\n                    ban[i]='.';\n                }\n            }\n            for(int i=63;i>=0;i--)if(max<rexo[i])\n            {\n                max=rexo[i];\n                maxban=i;\n            }\n            ban[maxban]='x';\n            REP(k,8)re(ban,maxban/8,maxban%8,k,0);\n            if(max==0)none++;\n            else none=0;\n            if(none==2)break;\n        }\n        now=1-now;\n        //REP(i,64)printf(\"%d\",rexo[i]);\n        //printf(\"\\n\");\n        //printban(ban);\n        //printf(\"############\\n\");\n    }\n    printban(ban);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\nstring F[8];\n//char F[8][9];\nbool used[8][8];\nint turn;\n\nbool debug;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  /*\n  rep(i, 8) rep(j, 8){\n    cin >> F[i][j];\n  }\n  //  */\n  rep(i, 8) cin >> F[i];\n  \n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7)\n      DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        \n        if(mx < r) {\n          memcpy(u, used, sizeof u);\n          mx = r;\n          pl = turn&1;\n        }\n        \n      }\n    }\n    if(mx > 0) {\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      \n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  \n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nint evalDir(int i, int j, int di, int dj, char c, const vs &v) {\n  for (int s = 0;; s++) {\n    i += di, j += dj;\n    if (i < 0 || j < 0 || i >= 8 || j >= 8 || v[i][j] == '.') return 0;\n    if (v[i][j] == c) return s;\n  }\n}\n\nvi di = {0, 1, 1, 1, 0, -1, -1, -1}, dj = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nint eval(int i, int j, char c, const vs &v) {\n  if (v[i][j] != '.') return 0;\n  int s = 0;\n  rep(k, 8) s += evalDir(i, j, di[k], dj[k], c, v);\n  return s;\n}\n\nvoid update(int i, int j, char c, vs &v) {\n  v[i][j] = c;\n  rep(k, 8) {\n    int t = evalDir(i, j, di[k], dj[k], c, v);\n    if (t) {\n      int ui = i, uj = j;\n      while (t--) {\n        ui += di[k], uj += dj[k];\n        v[ui][uj] = c;\n      }\n    }\n  }\n}\n\nvoid solve() {\n  vs v(8);\n  rep(i, 8) cin >> v[i];\n  for (;;) {\n    auto f = [&](char c) {\n      int maxi = -INF, ti, tj;\n      if (c == 'o') {\n        rep(i, 8) rep(j, 8) {\n          int e = eval(i, j, c, v);\n          if (cmax(maxi, e)) {\n            ti = i;\n            tj = j;\n          }\n        }\n      } else {\n        for (int i = 7; i >= 0; i--) {\n          for (int j = 7; j >= 0; j--) {\n            int e = eval(i, j, c, v);\n            if (cmax(maxi, e)) {\n              ti = i;\n              tj = j;\n            }\n          }\n        }\n      }\n      if (maxi > 0) {\n        update(ti, tj, c, v);\n        return false;\n      }\n      return true;\n    };\n    bool a = f('o');\n    bool b = f('x');\n    if (a && b) break;\n  }\n  rep(i, 8) cout << v[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nbool inside( const int y, const int x )\n{\n\treturn 0 <= y && y < 8 && 0 <= x && x < 8;\n}\n\nint flip( VS &board, int y, int x, char c )\n{\n\tint res = 0;\n\tREP( dy, -1, 2 )\n\t{\n\t\tREP( dx, -1, 2 )\n\t\t{\n\t\t\tif ( !( dy | dx ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool ok = false;\n\t\t\tfor ( int cy = y + dy, cx = x + dx; inside( cy, cx );  cy += dy, cx += dx )\n\t\t\t{\n\t\t\t\tif ( board[ cy ][ cx ] == '.' )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if ( board[ cy ][ cx ] == c )\n\t\t\t\t{\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ok )\n\t\t\t{\t\n\t\t\t\tfor ( int cy = y + dy, cx = x + dx; inside( cy, cx ) && board[ cy ][ cx ] != c;  cy += dy, cx += dx )\n\t\t\t\t{\n\t\t\t\t\tboard[ cy ][ cx ] = c;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ( res )\n\t{\n\t\tboard[y][x] = c;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tVS board( 8 );\n\tFOR( line, board )\n\t{\n\t\tcin >> line;\n\t}\n\n\tfor ( int t = 0; ; t++ )\n\t{\n\t\tbool pass1 = false, pass2 = false;\n\n\t\t{ // mami\n\t\t\tint maxflip = 0, y = -1, x;\n\t\t\tREP( i, 0, 8 )\n\t\t\t{\n\t\t\t\tREP( j, 0, 8 )\n\t\t\t\t{\n\t\t\t\t\tif ( board[i][j] != '.' )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tVS tmp_board( board );\n\t\t\t\t\tconst int tmp = flip( tmp_board, i, j, 'o' );\n\t\t\t\t\tif ( maxflip < tmp )\n\t\t\t\t\t{\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\tmaxflip = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( maxflip == 0 )\n\t\t\t{\n\t\t\t\tpass1 = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflip( board, y, x, 'o' );\n\t\t\t}\n\t\t}\n\t\t{ // charlotte\n\t\t\tint maxflip = 0, y = -1, x;\n\t\t\tfor ( int i = 7; 0 <= i; i-- )\n\t\t\t{\n\t\t\t\tfor ( int j = 7; 0 <= j; j-- )\n\t\t\t\t{\n\t\t\t\t\tif ( board[i][j] != '.' )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tVS tmp_board( board );\n\t\t\t\t\tconst int tmp = flip( tmp_board, i, j, 'x' );\n\t\t\t\t\tif ( maxflip < tmp )\n\t\t\t\t\t{\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\tmaxflip = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( maxflip == 0 )\n\t\t\t{\n\t\t\t\tpass2 = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflip( board, y, x, 'x' );\n\t\t\t}\n\t\t}\n\n\t\tif ( pass1 && pass2 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFOR( line, board )\n\t{\n\t\tcout << line << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1};\nconst int dy[]={0,-1,-1,-1,0,1,1,1};\n\nint main(){\n\tchar B[8][9];\n\trep(i,8) scanf(\"%s\",B[i]);\n\n\trep(t,64){\n\t\tchar c1=(t%2?'x':'o'),c2=(t%2?'o':'x'); // ©ªÌNbL[, èÌNbL[\n\n\t\tint i_opt=0,j_opt=0,tot_opt=0;\n\t\trep(i,8) rep(j,8) if(B[i][j]=='.') {\n\t\t\tint tot=0; // ÆêéèÌNbL[ÌÂ\n\t\t\trep(k,8){ // (i,j) Éu¢½Æ«ÉèÌNbL[ðÍ³ßé©\n\t\t\t\tint l,y,x;\n\t\t\t\tfor(l=1;;l++){\n\t\t\t\t\ty=i+l*dy[k];\n\t\t\t\t\tx=j+l*dx[k];\n\t\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c2);\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\ty=i+l*dy[k];\n\t\t\t\tx=j+l*dx[k];\n\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c1) tot+=l-1;\n\t\t\t}\n\t\t\tif(tot_opt<tot\n\t\t\t|| tot_opt==tot && (t%2?make_pair(i_opt,j_opt)<make_pair(i,j)\n\t\t\t\t\t\t\t\t   :make_pair(i_opt,j_opt)>make_pair(i,j))){\n\t\t\t\ti_opt=i;\n\t\t\t\tj_opt=j;\n\t\t\t\ttot_opt=tot;\n\t\t\t}\n\t\t}\n\n\t\tif(tot_opt==0) continue;\n\n\t\t// NbL[ðu­\n\t\tB[i_opt][j_opt]=c1;\n\t\trep(k,8){ // ½]\n\t\t\tint l,y,x;\n\t\t\tfor(l=1;;l++){\n\t\t\t\ty=i_opt+l*dy[k];\n\t\t\t\tx=j_opt+l*dx[k];\n\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c2);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\ty=i_opt+l*dy[k];\n\t\t\tx=j_opt+l*dx[k];\n\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c1){\n\t\t\t\tfor(l--;l>0;l--){\n\t\t\t\t\tint y=i_opt+l*dy[k],x=j_opt+l*dx[k];\n\t\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c2) B[y][x]=c1;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,8) puts(B[i]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int D[8][2] = { {1, 1}, {1, 0}, {1, -1}, \n\t\t      {0, 1}, {0, -1}, \n\t\t      {-1, 1}, {-1, 0}, {-1, -1} };\n\nchar T[10][10];\nbool turn = true; // 巴マミのターンのときtrue、お菓子の魔女のターンのときfalse。\n\nchar M() {\n  return (turn ? 'o' : 'x');\n}\n\nchar E() {\n  return (turn ? 'x' : 'o');\n}\n\nbool ok (int i, int j) {\n  return 1 <= i && i <= 8 && 1 <= j && j <= 8; \n}\n\nint main() {\n  fill(&T[0][0], &T[0][0]+100, '.');\n  char s;\n  for (int i=1; i<=8; i++) {\n    for (int j=1; j<=8; j++) {\n      cin >> s;\n      T[i][j] = s;\n    }\n  }\n  for (int t=0; t<64; t++) { \n    // 石が置けないときにパスする判定だけは厳密にやって、\n    // 決着がついたとしても64ターンやることにする。\n    int max = 0;\n    int maxx, maxy;\n    bool houkou[8];\n    for (int i=(turn ? 1 : 8); (turn ? i<=8 : i>=1); (turn ? i++ : i--)) {\n      for (int j=(turn ? 1 : 8); (turn ? j<=8 : j>=1); (turn ? j++ : j--)) {\n\tif (T[i][j] == '.') { // (i,j)が空なら\n\t  int temp = 0;\n\t  bool temph[8];\n\t  fill(temph, temph+8, false);\n\t  for (int k=0; k<8; k++) {\n\t    int ishi = 1;\n\t    while (ok (i + ishi * D[k][0], j + ishi * D[k][1]) \n\t\t   && T[i + ishi * D[k][0]][j + ishi * D[k][1]] == E()) {\n\t      ishi++;\n\t    }\n\t    if (ok (i + ishi * D[k][0], j + ishi * D[k][1]) \n\t\t&& T[i + ishi * D[k][0]][j + ishi * D[k][1]] == M()) {\n\t      temp += ishi-1;\n\t      temph[k] = true;\n\t    }\n\t  }\n\t  if (temp > max) {\n\t    max = temp;\n\t    maxx = i;\n\t    maxy = j;\n\t    for (int k=0; k<8; k++) {\n\t      houkou[k] = temph[k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    if (max > 0) { // 置ける場所があるとき\n      T[maxx][maxy] = M();\n      for (int k=0; k<8; k++) {\n\tif (houkou[k]) {\n\t  int ishi = 1;\n\t  while (ok (maxx + ishi * D[k][0], maxy + ishi * D[k][1]) \n\t\t && T[maxx + ishi * D[k][0]][maxy + ishi * D[k][1]] == E()) {\n\t    T[maxx + ishi * D[k][0]][maxy + ishi * D[k][1]] = M();\n\t    ishi++;\n\t  }\n\t}\n      }\n    }\n    turn = !turn;\n  }\n  for (int i=1; i<=8; i++) {\n    for (int j=1; j<=8; j++) {\n      cout << T[i][j];\n      if (j == 8) cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstring s[8];\nbool is(int x,int y){\n\treturn 0<=x&&x<8&&0<=y&&y<8;\n}\nint dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};\nint main(){\n\trep(i,8) cin>>s[i];\n\tbool mami=true;\n\tbool skip=false;\n\twhile(true){\n\t\tif(mami){\n\t\t\tint chi,chj,mx=0;\n\t\t\trep(i,8) rep(j,8){\n\t\t\t\tif(s[i][j]!='.') continue;\n\t\t\t\tint stone=0;\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=i,y=j;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='x'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='o'&&cnt>0) stone+=cnt;\n\t\t\t\t}\n\t\t\t\tif(stone>mx){\n\t\t\t\t\tchi=i,chj=j,mx=stone;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==0){\n\t\t\t\tif(skip) break;\n\t\t\t\tskip=true;\n\t\t\t}else{\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=chi,y=chj;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='x'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='o'&&cnt>0){\n\t\t\t\t\t\tint xx=chi,yy=chj;\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\txx+=dx[d],yy+=dy[d];\n\t\t\t\t\t\t\tif(s[xx][yy]=='o') break;\n\t\t\t\t\t\t\ts[xx][yy]='o';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts[chi][chj]='o';\n\t\t\t\tskip=false;\n\t\t\t}\n\t\t}else{\n\t\t\tint chi,chj,mx=0;\n\t\t\tfor(int i=7;i>=0;i--) for(int j=7;j>=0;j--){\n\t\t\t\tif(s[i][j]!='.') continue;\n\t\t\t\tint stone=0;\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=i,y=j;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='o'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='x'&&cnt>0) stone+=cnt;\n\t\t\t\t}\n\t\t\t\tif(stone>mx){\n\t\t\t\t\tchi=i,chj=j,mx=stone;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==0){\n\t\t\t\tif(skip) break;\n\t\t\t\tskip=true;\n\t\t\t}else{\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=chi,y=chj;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='o'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='x'&&cnt>0){\n\t\t\t\t\t\tint xx=chi,yy=chj;\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\txx+=dx[d],yy+=dy[d];\n\t\t\t\t\t\t\tif(s[xx][yy]=='x') break;\n\t\t\t\t\t\t\ts[xx][yy]='x';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts[chi][chj]='x';\n\t\t\t\tskip=false;\n\t\t\t}\n\t\t}\n\t\tmami=!mami;\n\t}\n\trep(i,8) cout<<s[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(x) x.begin(),x.end()\n\n\nint s[10][10]={};\n\nint ddx[8]={-1,0,1,1,1,0,-1,-1};\nint ddy[8]={-1,-1,-1,0,1,1,1,0};\n\n\nint solve(int y,int x,int d,int base){\n    int dx=ddx[d];\n    int dy=ddy[d];\n    int ret=0;\n    \n    rep(i,8){\n        int dxi=dx*(i+1),dyi=dy*(i+1);\n        if( !( y+dyi>=0 && y+dyi<8 && x+dxi>=0 && x+dxi<8 ) || s[y+dyi][x+dxi]==-1 ) return 0;\n        else if(s[y+dyi][x+dxi]==base)return ret;\n        else if(s[y+dyi][x+dxi]!=base)ret++;\n    }\n    return -100;\n}\n\n\nvoid out(){\n    rep(i,8){\n        rep(j,8){\n            int aa=s[i][j];\n            if(aa==1)cout<<\"o\";\n            if(aa==0)cout<<\"x\";\n            if(aa==-1)cout<<\".\";\n        }\n        cout<<endl;\n    }\n}\n\n\nint main(){\n    rep(i,8){\n        rep(j,8){\n            char tmp;\n            cin>>tmp;\n            if(tmp=='o')s[i][j]=1;\n            else if(tmp=='x')s[i][j]=0;\n            else s[i][j]=-1;\n        }\n    }\n    \n    int flag=false;\n    while(true){\n//        out();cout<<endl;\n        \n        \n        int d[10]={};\n        int y=-1,x=-1;\n        int count=0;\n        for(int i=0;i<8;i++){\n            for(int j=0;j<8;j++){\n                if(s[i][j]!=-1)continue;\n                int result=0;\n                int tmp[10]={};\n                rep(k,8){\n                    int aaa=solve(i,j,k,1);\n                    tmp[k]=aaa;\n                    result+=aaa;\n                }\n                if(result>count){\n                    count=result;\n                    y=i;\n                    x=j;\n                    rep(z,8)d[z]=tmp[z];\n                }\n            }\n        }\n        if(count!=0){\n            flag=false;\n            s[y][x]=1;\n            rep(i,8){\n                rep(j,d[i]){\n                    s[y+ddy[i]*(j+1)][x+ddx[i]*(j+1)]=1;        ///////\n                }\n            }\n        }\n        else{\n            if(flag)break;\n            flag=true;\n        }\n/////////////////////////////////////////////////////////\n//        out();cout<<endl;\n        y=-1,x=-1;\n        count=0;\n        for(int i=7;i>=0;i--){\n            for(int j=7;j>=0;j--){\n                if(s[i][j]!=-1)continue;\n                int result=0;\n                int tmp[10]={};\n                rep(k,8){\n                    int aaa=solve(i,j,k,0);\n                    tmp[k]=aaa;\n                    result+=aaa;\n                }\n                if(result>count){\n                    count=result;\n                    y=i;\n                    x=j;\n                    rep(z,8)d[z]=tmp[z];\n                }\n            }\n        }\n        if(count!=0){\n            flag=false;\n            s[y][x]=0;\n            rep(i,8){\n                rep(j,d[i]){\n                    s[y+ddy[i]*(j+1)][x+ddx[i]*(j+1)]=0;        ///////\n                }\n            }\n        }\n        else{\n            if(flag)break;\n            flag=true;\n        }\n        \n    }\n    out();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar t[8][8];\n\nint func(int y,int x,char ch){\n  int res=0;\n  int cnt=0;\n  for(int Y=y+1;;Y++){\n    if(Y>=8)break;\n    if(t[Y][x]==ch){ res+=cnt;   break; }\n    if(t[Y][x]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int Y=y-1;;Y--){\n    if(Y<0)break;\n    if(t[Y][x]==ch){ res+=cnt;   break; }\n    if(t[Y][x]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n for(int X=x+1;;X++){\n    if(X>=8)break;\n    if(t[y][X]==ch){ res+=cnt;   break; }\n    if(t[y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x-1;;X--){\n    if(X<0)break;\n    if(t[y][X]==ch){ res+=cnt;   break; }\n    if(t[y][X]=='.')break;\n    cnt++;\n  }\n\n\n  cnt=0;\n  for(int X=x+1,Y=y+1;;X++,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x+1,Y=y-1;;X++,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n\n\n  cnt=0;\n  for(int X=x-1,Y=y+1;;X--,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x-1,Y=y-1;;X--,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n\n  return res;\n}\n\nvoid func2(int y,int x,char ch){\n  int flg=0;\n  for(int Y=y+1;;Y++){\n    if(Y>=8)break;\n    if(t[Y][x]==ch){flg=1;break; }\n    if(t[Y][x]=='.')break;\n  }\n  if(flg){\n    for(int Y=y+1;;Y++){\n      if(Y>=8)break;\n      if(t[Y][x]==ch)break; \n      if(t[Y][x]=='.')break;\n      t[Y][x]=ch;\n    }\n  }\n\n  flg=0;\n  for(int Y=y-1;;Y--){\n    if(Y<0)break;\n    if(t[Y][x]==ch){flg=1;break; }\n    if(t[Y][x]=='.')break;\n  }\n  if(flg){\n    for(int Y=y-1;;Y--){\n      if(Y<0)break;\n      if(t[Y][x]==ch)break; \n      if(t[Y][x]=='.')break;\n      t[Y][x]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x+1;;X++){\n    if(X>=8)break;\n    if(t[y][X]==ch){flg=1;break;}\n    if(t[y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x+1;;X++){\n      if(X>=8)break;\n      if(t[y][X]==ch)break;\n      if(t[y][X]=='.')break;\n      t[y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x-1;;X--){\n    if(X<0)break;\n    if(t[y][X]==ch){flg=1;break; }\n    if(t[y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1;;X--){\n      if(X<0)break;\n      if(t[y][X]==ch)break;\n      if(t[y][X]=='.')break;\n      t[y][X]=ch;\n    }\n  }\n\n\n  flg=0;\n  for(int X=x+1,Y=y+1;;X++,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x+1,Y=y+1;;X++,Y++){\n      if(X>=8||Y>=8)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x+1,Y=y-1;;X++,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){  \n    for(int X=x+1,Y=y-1;;X++,Y--){\n      if(X>=8||Y<0)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n\n  flg=0;\n  for(int X=x-1,Y=y+1;;X--,Y++){\n    if(X<0||Y>=8)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1,Y=y+1;;X--,Y++){\n      if(X<0||Y>=8)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x-1,Y=y-1;;X--,Y--){\n    if(X<0||Y<0)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1,Y=y-1;;X--,Y--){\n      if(X<0||Y<0)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n}\n\nint main(){\n  for(int i=0;i<8;i++)\n    for(int j=0;j<8;j++)\n      cin>>t[i][j];\n\n  int cnt=0;\n  for(int i=0;;i++){\n    \n    char ch=(i%2?'x':'o');\n    \n\n    int ay,ax,maxm=0;\n    if(ch=='o'){\n      for(int j=0;j<8;j++){\n\tfor(int k=0;k<8;k++){\n\t  if(t[j][k]!='.')continue;\n\t  int x=func(j,k,ch);\n\t\n\t  if(x>maxm){\n\t    maxm=x;\n\t    ay=j;\n\t    ax=k;\n\t  }\n\t}\n      }\n    }else{\n      for(int j=7;j>=0;j--){\n\tfor(int k=7;k>=0;k--){\n\t  if(t[j][k]!='.')continue;\n\t  int x=func(j,k,ch);\n\t\n\t  if(x>maxm){\n\t    maxm=x;\n\t    ay=j;\n\t    ax=k;\n\t  }\n\t}\n      }\n\n    }\n\n    if(maxm==0){\n      cnt++;\n      if(cnt==2)break;\n      continue;\n    }else cnt=0;\n\n    // cout<<ay<<' '<<ax<<endl;\n\n    t[ay][ax]=ch;\n    func2(ay,ax,ch);\n    \n  }//i\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++)cout<<t[i][j];\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst char *st = \"ox\";\nconst int dy[] = {-1, -1, 1, 1, -1, 0, 1, 0}, dx[] = {1, -1, 1, -1, 0, -1, 0, 1};\nstring s[8];\nint gain(int y, int x, int t){\n\tint res = 0;\n\trep(d, 8){\n\t\tint ny = y + dy[d], nx = x + dx[d], cnt = 0;\n\t\twhile(0 <= ny && ny < 8 && 0 <= nx && nx < 8){\n\t\t\tif(s[ny][nx] == st[t] || s[ny][nx] == '.') break;\n\t\t\tny += dy[d]; nx += dx[d];\n\t\t\tcnt++;\n\t\t}\n\t\tif(0 <= ny && ny < 8 && 0 <= nx && nx < 8 && s[ny][nx] == st[t]) res += cnt;\n\t}\n\treturn res;\n}\nvoid flip(int y, int x, int t){\n\ts[y][x] = st[t];\n\trep(d, 8){\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\twhile(0 <= ny && ny < 8 && 0 <= nx && nx < 8){\n\t\t\tif(s[ny][nx] == st[t] || s[ny][nx] == '.') break;\n\t\t\tny += dy[d]; nx += dx[d];\n\t\t}\n\t\tif(!(0 <= ny && ny < 8 && 0 <= nx && nx < 8) || s[ny][nx] != st[t]) continue;\n\t\tny = y + dy[d], nx = x + dx[d];\n\t\twhile(0 <= ny && ny < 8 && 0 <= nx && nx < 8){\n\t\t\tif(s[ny][nx] == st[t] || s[ny][nx] == '.') break;\n\t\t\ts[ny][nx] = st[t];\n\t\t\tny += dy[d]; nx += dx[d];\n\t\t}\n\t}\n}\n\n\nint main(){\n\trep(i, 8) cin >> s[i];\n\tint turn = 0; int pass = 0;\n\t\n\twhile(1){\n\t\tint mx = 0, mxi, mxj;\n\t\trep(ii, 8) rep(jj, 8){\n\t\t\tint i = turn ? 7 - ii : ii, j = turn ? 7 - jj : jj;\n\t\t\tif(s[i][j] == '.'){\n\t\t\t\tint g = gain(i, j, turn);\n\t\t\t\tif(g > mx) mx = g, mxi = i, mxj = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mx == 0 && pass) break;\n\t\tif(mx == 0){\n\t\t\tpass = 1;\n\t\t}\n\t\telse{\n\t\t\tpass = 0;\n\t\t\tflip(mxi, mxj, turn);\n\t\t}\n\t\tturn ^= 1;\n\t}\n\trep(i, 8) cout << s[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\n\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nchar mat[8][8];\nstring ox = \"ox\";\n\nvoid output(){\n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            cout << mat[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint num(int i, int j, int x){\n    int ret = 0;\n    for(int k = 0; k < 8; k++){\n        int ni = i+di[k], nj = j+dj[k], cnt = 0;\n        while(inRange(ni,0,8)&&inRange(nj,0,8)&&mat[ni][nj]==ox[1-x]){\n            ni += di[k], nj += dj[k], cnt++;\n        }\n        if(inRange(ni,0,8)&&inRange(nj,0,8)&&mat[ni][nj]==ox[x]){\n            ret += cnt;\n        }\n    }\n    return ret;\n}\n\nvoid put(int i, int j, int x){\n    for(int k = 0; k < 8; k++){\n        int ni = i+di[k], nj = j+dj[k];\n        while(inRange(ni,0,8)&&inRange(nj,0,8)&&mat[ni][nj]==ox[1-x]){\n            ni += di[k], nj += dj[k];\n        }\n        if(inRange(ni,0,8)&&inRange(nj,0,8)&&mat[ni][nj]==ox[x]){\n            while(ni != i || nj != j){\n                ni -= di[k], nj -= dj[k];\n                mat[ni][nj] = ox[x];\n            }\n        }\n    }\n}\n\nint main(){\n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            cin >> mat[i][j];\n        }\n    }\n    bool update = true;\n    while(update){\n        update = false;\n        for(int s = 0; s < 2; s++){\n            int pi = -1, pj = -1, cnt = 0;\n            for(int i = 0; i < 8; i++){\n                for(int j = 0; j < 8; j++){\n                    int gi = s==0 ? i : 7-i;\n                    int gj = s==0 ? j : 7-j;\n                    if(mat[gi][gj] != '.')    continue;\n                    int tmp = num(gi, gj, s);\n                    if(tmp > cnt)   cnt = tmp, pi = gi, pj = gj;\n                }\n            }\n            if(cnt == 0)    continue;\n            update = true;\n            put(pi, pj, s);\n        }\n    }\n    output();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 10\nusing namespace std;\nint Check(string);\nint Cnt(string,int,int,int,int);\nvoid Reverse(int,int,string,vector<int>);\nstring in[N];\nint main(){\n  int r,end,i,j;\n  string who=\"o\";\n  for(i=0;i<N;i++) in[0]+='X',in[N-1]+='X';\n  for(i=1;i<N-1;i++) cin >> in[i],in[i]='X'+in[i]+'X';\n  end=0;\n  while(1){\n    r=Check(who);\n    if(r==0) end++;\n    else end=0;\n    if(end==2) break;\n    who==\"o\" ? who=\"x\" : who=\"o\";\n  }\n  for(i=1;i<=8;i++){\n    for(j=1;j<=8;j++){\n      cout << in[i][j];\n    }\n    cout << endl;\n  }\n  return 0;\n}\nint Check(string who){\n  int cnt,r,max=0,i,j;\n  char ox;\n  pair<int,int> i_j;\n  vector<int> m,t;\n  if(who==\"o\") ox='x';\n  else ox='o';\n  if(who==\"o\"){\n    for(i=1;i<N-1;i++){\n      for(j=1;j<N-1;j++){\n\tif(in[i][j]=='.'){\n\t  for(int k=0;k<8;k++) t.push_back(0);\n\t  cnt=0;\n\t  if(in[i][j-1]==ox){\n\t    r=Cnt(who,i,j-1,0,-1);\n\t    cnt+=r;\n\t    t[0]=r;\n\t  }\n\t  if(in[i-1][j-1]==ox){\n\t    r=Cnt(who,i-1,j-1,-1,-1);\n\t    cnt+=r;\n\t    t[1]=r;\n\t  }\n\t  if(in[i-1][j]==ox){\n\t    r=Cnt(who,i-1,j,-1,0);\n\t    cnt+=r;\n\t    t[2]=r;\n\t  }\n\t  if(in[i-1][j+1]==ox){\n\t    r=Cnt(who,i-1,j+1,-1,1);\n\t    cnt+=r;\n\t    t[3]=r;\n\t  }\n\t  if(in[i][j+1]==ox){\n\t    r=Cnt(who,i,j+1,0,1);\n\t    cnt+=r;\n\t    t[4]=r;\n\t  }\n\t  if(in[i+1][j+1]==ox){\n\t    r=Cnt(who,i+1,j+1,1,1);\n\t    cnt+=r;\n\t    t[5]=r;\n\t  }\n\t  if(in[i+1][j]==ox){\n\t    r=Cnt(who,i+1,j,1,0);\n\t    cnt+=r;\n\t    t[6]=r;\n\t  }\n\t  if(in[i+1][j-1]==ox){\n\t    r=Cnt(who,i+1,j-1,1,-1);\n\t    cnt+=r;\n\t    t[7]=r;\n\t  }\n\t  if(max<cnt){\n\t    max=cnt;\n\t    i_j=make_pair(i,j);\n\t    m=t;\t  \n\t  }\n\t  t.clear();\n\t}\n      }\n    }\n  }else{\n    for(i=N-2;i>=1;i--){\n      for(j=N-2;j>=1;j--){\n\tif(in[i][j]=='.'){\n\t  for(int k=0;k<8;k++) t.push_back(0);\n\t  cnt=0;\n\t  if(in[i][j-1]==ox){\n\t    r=Cnt(who,i,j-1,0,-1);\n\t    cnt+=r;\n\t    t[0]=r;\n\t  }\n\t  if(in[i-1][j-1]==ox){\n\t    r=Cnt(who,i-1,j-1,-1,-1);\n\t    cnt+=r;\n\t    t[1]=r;\n\t  }\n\t  if(in[i-1][j]==ox){\n\t    r=Cnt(who,i-1,j,-1,0);\n\t    cnt+=r;\n\t    t[2]=r;\n\t  }\n\t  if(in[i-1][j+1]==ox){\n\t    r=Cnt(who,i-1,j+1,-1,1);\n\t    cnt+=r;\n\t    t[3]=r;\n\t  }\n\t  if(in[i][j+1]==ox){\n\t    r=Cnt(who,i,j+1,0,1);\n\t    cnt+=r;\n\t    t[4]=r;\n\t  }\n\t  if(in[i+1][j+1]==ox){\n\t    r=Cnt(who,i+1,j+1,1,1);\n\t    cnt+=r;\n\t    t[5]=r;\n\t  }\n\t  if(in[i+1][j]==ox){\n\t    r=Cnt(who,i+1,j,1,0);\n\t    cnt+=r;\n\t    t[6]=r;\n\t  }\n\t  if(in[i+1][j-1]==ox){\n\t    r=Cnt(who,i+1,j-1,1,-1);\n\t    cnt+=r;\n\t    t[7]=r;\n\t  }\n\t  if(max<cnt){\n\t    max=cnt;\n\t    i_j=make_pair(i,j);\n\t    m=t;\t  \n\t  }\n\t  t.clear();\n\t}\n      }\n    }\n  }\n  if(max==0) return 0;\n  Reverse(i_j.first,i_j.second,who,m);\n  return 1;\n}\nint Cnt(string who,int y,int x,int py,int px){\n  int cnt=1;\n  char ox,oxr;\n  if(who==\"o\") ox='x',oxr='o';\n  else ox='o',oxr='x';\n  while(1){\n    y+=py;\n    x+=px;\n    if(in[y][x]==oxr) break;\n    else if(in[y][x]==ox) cnt++;\n    else{\n      cnt=0;\n      break;\n    }\n  }\n  return cnt;\n}\nvoid Reverse(int y,int x,string who,vector<int> V){\n  int i,cpy=y,cpx=x;\n  char ox,oxr;\n  int py[8]={0,-1,-1,-1,0,1,1,1},px[8]={-1,-1,0,1,1,1,0,-1};\n  if(who==\"o\") ox='x',oxr='o';\n  else ox='o',oxr='x';\n  in[cpy][cpx]=oxr;\n  for(i=0;i<V.size();i++){\n    cpy=y,cpx=x;\n    if(V[i]!=0){\n      if(i==0){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==1){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==2){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==3){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==4){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==5){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==6){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n      else if(i==7){\n\twhile(V[i]){\n\t  cpy+=py[i];\n\t  cpx+=px[i];\n\t  in[cpy][cpx]=oxr;\n\t  V[i]--;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing vl=vector<ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(ll i=(a);i<n;i++)\n#define LINF ((ll)1ll<<60)\n\nint main(){\n    vs f(8);\n    rep(i,8)cin>>f[i];\n    int turn=0, finish=0;\n    while(1){\n        int my,mx,mv=-1;\n        rep(i,8)rep(j,8){\n            int y=(turn==0?i:7-i);\n            int x=(turn==0?j:7-j);\n            if(f[y][x]!='.')continue;\n            int val=0;\n            rep(k,8){\n                int dy=vl{1,1,1,0,0,-1,-1,-1}[k];\n                int dx=vl{1,0,-1,1,-1,1,0,-1}[k];\n                int del=0, cx=x, cy=y, cnt=0;\n                while(1){\n                    cx+=dx, cy+=dy;\n                    if(cx<0 or cy<0 or cx>7 or cy>7) break;\n                    char self=(turn==0?'o':'x');\n                    char other=(turn==0?'x':'o');\n                    if(f[cy][cx]==self){\n                        val+=cnt;\n                        break;\n                    }else if(f[cy][cx]==other){\n                        cnt++;\n                    }else{\n                        break;\n                    }\n                }\n            }\n            if(val!=0){\n                if(mv<val){\n                    mv=val;\n                    my=y, mx=x;\n                }\n            }\n        }\n        if(mv==-1){\n            finish++;\n        }else{\n            finish=0;\n            rep(k,8){\n                int dy=vl{1,1,1,0,0,-1,-1,-1}[k];\n                int dx=vl{1,0,-1,1,-1,1,0,-1}[k];\n                int del=0, cx=mx, cy=my, cnt=0;\n                while(1){\n                    bool fin=false;\n                    cx+=dx, cy+=dy;\n                    if(cx<0 or cy<0 or cx>7 or cy>7) break;\n                    char self=(turn==0?'o':'x');\n                    char other=(turn==0?'x':'o');\n                    if(f[cy][cx]==self){\n                        fin=true;\n                    }else if(f[cy][cx]==other){\n                        cnt++;\n                    }else{\n                        break;\n                    }\n                    if(fin){\n                        cx=mx, cy=my;\n                        rep(_,cnt+1){\n                            f[cy][cx]=self;\n                            cx+=dx, cy+=dy;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if(finish==2)break;\n        turn=1-turn;\n    }\n    rep(i,8)cout<<f[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n\nconst int dx[] = {1,1,1,0,0,-1,-1,-1};\nconst int dy[] = {1,0,-1,1,-1,1,0,-1};\nconst double EPS = 1e-9;\n\nvoid cerrTable(vector<vector<char> > table){\n    for(int i=0;i<table.size();i++){\n        for(int j=0;j<table[i].size();j++){\n            cerr << table[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\nint main(){\n    int N = 8;\n    const char mami='o',charlotte='x',empty='.',wall='z';\n    vector<vector<char> > table(N+2,vector<char>(N+2,wall));\n    for(int y=1;y<=N;y++){\n        for(int x=1;x<=N;x++){\n            cin >> table[y][x];\n        }\n    }\n\n    for(bool updated=true;updated;){\n        updated = false;\n\n        int mamiy,mamix,maxmami=0;\n        // mami\n        for(int y=1;y<=N;y++){\n            for(int x=1;x<=N;x++){\n                if(table[y][x] == empty){\n                    int cnt = 0;\n                    for(int i=0;i<8;i++){\n                        int ny = y+dy[i],nx=x+dx[i];\n                        if(table[ny][nx] == charlotte){\n                            int localcnt = 0;\n                            while(table[ny][nx] == charlotte){\n                                localcnt++;\n                                ny += dy[i],nx+=dx[i];\n                            }\n                            if(table[ny][nx] == mami){\n                                cnt += localcnt;\n                            }\n                        }\n                    }\n                    if(cnt > maxmami){\n                        maxmami = cnt;\n                        mamiy = y;\n                        mamix = x;\n                    }\n                }\n            }\n        }\n\n        if(maxmami != 0){\n            table[mamiy][mamix] = mami;\n            for(int i=0;i<8;i++){\n                int ny = mamiy + dy[i];\n                int nx = mamix + dx[i];\n                if(table[ny][nx] == charlotte){\n                    while(table[ny][nx] == charlotte){\n                        ny += dy[i],nx+=dx[i];\n                    }\n                    if(table[ny][nx] == mami){\n                        ny -= dy[i],nx-=dx[i];\n                        while(ny != mamiy or nx != mamix){\n                            table[ny][nx] = mami;\n                            ny -= dy[i],nx -= dx[i];\n                        }\n                    }\n                }\n            }\n        }\n\n        int charlottey,charlottex,maxcharlotte=0;\n        // charlotte\n        for(int y=1;y<=N;y++){\n            for(int x=1;x<=N;x++){\n                if(table[y][x] == empty){\n                    int cnt = 0;\n                    for(int i=0;i<8;i++){\n                        int ny = y+dy[i],nx=x+dx[i];\n                        if(table[ny][nx] == mami){\n                            int localcnt = 0;\n                            while(table[ny][nx] == mami){\n                                localcnt++;\n                                ny += dy[i],nx+=dx[i];\n                            }\n                            if(table[ny][nx] == charlotte){\n                                cnt += localcnt;\n                            }\n                        }\n                    }\n                    if(cnt >= maxcharlotte){\n                        maxcharlotte = cnt;\n                        charlottey = y;\n                        charlottex = x;\n                    }\n                }\n            }\n        }\n\n        if(maxcharlotte != 0){\n            table[charlottey][charlottex] = charlotte;\n            for(int i=0;i<8;i++){\n                int ny = charlottey + dy[i];\n                int nx = charlottex + dx[i];\n                if(table[ny][nx] == mami){\n                    while(table[ny][nx] == mami){\n                        ny += dy[i],nx+=dx[i];\n                    }\n                    if(table[ny][nx] == charlotte){\n                        ny -= dy[i],nx-=dx[i];\n                        while(ny != charlottey or nx != charlottex){\n                            table[ny][nx] = charlotte;\n                            ny -= dy[i],nx -= dx[i];\n                        }\n                    }\n                }\n            }\n        }\n\n        if(maxmami != 0 or maxcharlotte != 0){\n            updated = true;\n        }\n    }\n\n    for(int i=1;i<=8;i++){\n        for(int j=1;j<=8;j++){\n            cout << table[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main(){\n  vector<string> S(8);\n  for(int i = 0; i < 8; ++i){\n    cin >> S[i];\n  }\n  bool f = true, g = true, h = true;\n  int player = -1, M, m, x, y, s, t, u, v;\n  char mark, opponent;\n  vector<int> dx, dy;\n  dx = {0,1,-1}; dy = {0,1,-1};\n  while (f&&g&&h){\n    f = false; g = false; h = false;\n    M = 0;\n    s = -1;\n    t = -1;\n    if (player > 0) {\n      mark = 'x';\n      opponent = 'o';\n    }else{\n      mark = 'o';\n      opponent = 'x';\n    }\n    for (int i = 0; i < 8; ++i){\n      for (int j = 0; j < 8; ++j){\n\tif (S[i][j] == 'x') f = true;\n\telse if (S[i][j] == 'o') g = true;\n\telse{//S[i][j] == '.'\n\t  h = true;\n\t  m = 0;\n\t  for (int k = 0; k < 3; ++k){//8??????????????????\n\t    for (int l = 0; l < 3; ++l) {\n\t      if (k || l){\n\t\tx = i; y = j;\n\t\twhile (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == opponent){\n\t\t  x += dx[k];\n\t\t  y += dy[l];\n\t\t}\n\t\tif (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == mark){\n\t\t  m += max(abs(x-i), abs(y-j));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if ((m >= M && player > 0)||(m > M && player < 0)) {\n\t    s = i;\n\t    t = j;\n\t    M = m;\n\t  }\n\t}\n      }\n    }\n    if (M > 0){//??????????????????????????´?????¶????????´??°\n      S[s][t] = mark;\n      for (int k = 0; k < 3; ++k){//8??????????????????\n\tfor (int l = 0; l < 3; ++l) {\n\t  if (k || l){\n\t    x = s; y = t;\n\t    while (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == opponent){\n\t      x += dx[k];\n\t      y += dy[l];\n\t    }\n\t    if (0 <= x+dx[k] && x+dx[k] < 8 && 0 <= y+dy[l] && y+dy[l] < 8 && S[x+dx[k]][y+dy[l]] == mark){\n\t      while (x != s || y != t) {\n\t\tS[x][y] = mark;\n\t\tx -= dx[k];\n\t\ty -= dy[l];\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    player *= -1;\n    //    for (int i = 0; i < 8; ++i) cout << S[i] << endl;\n  }\n  for (int i = 0; i < 8; ++i) cout << S[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n#define TIMES(i_, n_) for(int i_ = 0; i_ < (n_); ++i_)\n\nint put(vector<string> &field, int r, int c, char ch, bool actual = false) {\n    static const int DR[] = {0, -1, -1, -1, 0, 1, 1, 1};\n    static const int DC[] = {1, 1, 0, -1, -1, -1, 0, 1};\n    int cnt = 0;\n    TIMES(dir, 8) {\n        int cur_r = r + DR[dir], cur_c = c + DC[dir];\n        int tmp = 0;\n        int phase = 0;\n        while(0 <= cur_r && cur_r < 8 && 0 <= cur_c && cur_c < 8) {\n            if(field[cur_r][cur_c] == ch) {\n                cnt += tmp;\n                if(actual && phase == 0) {\n                    phase = 1;\n                    cur_r = r+DR[dir];\n                    cur_c = c+DC[dir];\n                    continue;\n                }\n                break;\n            }\n            if(field[cur_r][cur_c] == '.') break;\n            if(phase == 1) field[cur_r][cur_c] = ch;\n            ++tmp;\n            cur_r += DR[dir];\n            cur_c += DC[dir];\n        }\n    }\n    if(actual) {\n        field[r][c] = ch;\n    }\n    return cnt;\n}\n\nbool mami(vector<string> &field) {\n    int max_cnt = 0;\n    int best_r, best_c;\n    TIMES(r, 8) {\n        TIMES(c, 8) {\n            if(field[r][c] != '.') continue;\n            int cnt = put(field, r, c, 'o');\n            if(cnt > max_cnt) {\n                max_cnt = cnt;\n                best_r = r;\n                best_c = c;\n            }\n        }\n    }\n    if(max_cnt > 0) {\n        put(field, best_r, best_c, 'o', true);\n    }\n    return max_cnt > 0;\n}\n\nbool witch(vector<string> &field) {\n    int max_cnt = 0;\n    int best_r, best_c;\n    for(int r = 7; r >= 0; --r) {\n        for(int c = 7; c >= 0; --c) {\n            if(field[r][c] != '.') continue;\n            int cnt = put(field, r, c, 'x');\n            if(cnt > max_cnt) {\n                max_cnt = cnt;\n                best_r = r;\n                best_c = c;\n            }\n        }\n    }\n    if(max_cnt > 0) {\n        put(field, best_r, best_c, 'x', true);\n    }\n    return max_cnt > 0;\n}\n\nbool solve() {\n    vector<string> field(8);\n    TIMES(i, 8) {\n        cin >> field[i];\n    }\n    while(true) {\n        bool changed = false;\n        changed = mami(field) || changed;\n        changed = witch(field) || changed;\n        if(!changed) break;\n    }\n    TIMES(i, 8) {\n        cout << field[i] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef tuple<int, int, int> Tuple;\nconst char *cookie = \"ox\";\nconst int dx[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dy[] = {1, 0, -1, -1, -1, 0, 1, 1};\n\nchar grid[10][10];\n\nvoid show()\n{\n\tfor (int i = 1; i <= 8; i++){\n\t\tfor (int j = 1; j <= 8; j++){\n\t\t\tprintf(\"%c\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\nint calc(int turn, int x, int y)\n{\n\tint res = 0;\n\tfor (int dir = 0; dir < 8; dir++){\n\t\tint k = 1;\n\t\twhile (true){\n\t\t\tint nx = x + dx[dir] * k;\n\t\t\tint ny = y + dy[dir] * k;\n\t\t\tif (grid[nx][ny] == '.') break;\n\t\t\tif (grid[nx][ny] == cookie[turn]) break;\n\t\t\tk++;\n\t\t}\n\t\tif (grid[x + dx[dir] * k][y + dy[dir] * k] == '.') k = 0;\n\t\t\n\t\tfor (int i = 1; i < k; i++){\n\t\t\tint nx = x + dx[dir] * i;\n\t\t\tint ny = y + dy[dir] * i;\n\t\t\t//if (grid[nx][ny] == '.') break;\n\t\t\t//if (grid[nx][ny] == cookie[turn]) break;\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid st(int turn, int x, int y)\n{\n\tgrid[x][y] = cookie[turn];\n\tfor (int dir = 0; dir < 8; dir++){\n\t\tint k = 1;\n\t\twhile (true){\n\t\t\tint nx = x + dx[dir] * k;\n\t\t\tint ny = y + dy[dir] * k;\n\t\t\tif (grid[nx][ny] == '.') break;\n\t\t\tif (grid[nx][ny] == cookie[turn]) break;\n\t\t\tk++;\n\t\t}\n\t\tif (grid[x + dx[dir] * k][y + dy[dir] * k] == '.') k = 0;\n\t\t\n\t\tfor (int i = 1; i < k; i++){\n\t\t\tint nx = x + dx[dir] * i;\n\t\t\tint ny = y + dy[dir] * i;\n\t\t\t//if (grid[nx][ny] == '.') break;\n\t\t\t//if (grid[nx][ny] == cookie[turn]) break;\n\t\t\tgrid[nx][ny] = cookie[turn];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(grid, '.', sizeof(grid));\n\tfor (int i = 1; i <= 8; i++){\n\t\tfor (int j = 1; j <= 8; j++){\n\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t}\n\t}\n\t\n\tint turn = 0;\n\tint pass = 0;\n\twhile (true){\n\t\tint sign = turn ? 1 : -1;\n\t\t// score, i, j\n\t\tTuple maxi(0, 0, 0);\n\t\tfor (int i = 1; i <= 8; i++){\n\t\t\tfor (int j = 1; j <= 8; j++){\n\t\t\t\tif (grid[i][j] != '.') continue;\n\t\t\t\tTuple t(calc(turn, i, j), i * sign, j * sign);\n\t\t\t\tmaxi = max(maxi, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//show();\n\t\tif (get<0>(maxi) == 0){\n\t\t\tpass++;\n\t\t\tif (pass >= 2){\n\t\t\t\tshow();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tst(turn, abs(get<1>(maxi)), abs(get<2>(maxi)));\n\t\t\tpass = 0;\n\t\t}\n\t\tturn ^= 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pll> vp;\ntypedef vector<ll> vll;\n\nconst int H = 8;\nconst int W = 8;\nchar board[H][W];\nint dp[H][W];\n\nint dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nchar getOpposite(char player) {\n    return (player == 'o') ? 'x' : 'o';\n}\n\n// check if (x, y) is occupied by the opponent\nbool isOpposite(int x, int y, char player) {\n    return board[x][y] == getOpposite(player);\n}\n\n// update max when one of the end is (x, y)\nvoid updateDP(int x, int y, char player) {\n    rep(k, 8) {\n        int cnt = 0;\n        int nx = x + dx[k], ny = y + dy[k];\n\n        while (inside(nx, ny) && isOpposite(nx, ny, player)) {\n            cnt++;\n            nx += dx[k], ny += dy[k];\n        }\n        if (inside(nx, ny) && board[nx][ny] == '.') {\n            dp[nx][ny] += cnt;\n        }\n    }\n}\n\nP getMaxId(char player) {\n    int max_x = -1;\n    int max_y = -1;\n    int max_num = 0;\n\n    if (player == 'o') {\n        rep(i, H) {\n            rep(j, W) {\n                if (dp[i][j] > max_num) {\n                    max_num = dp[i][j];\n                    max_x = i;\n                    max_y = j;\n                }\n            }\n        }\n    } else {\n        rrep(i, H) {\n            rrep(j, W) {\n                if (dp[i][j] > max_num) {\n                    max_num = dp[i][j];\n                    max_x = i;\n                    max_y = j;\n                }\n            }\n        }\n    }\n\n    return P(max_x, max_y);\n}\n\nvoid place(int x, int y, char player) {\n    board[x][y] = player;\n    rep(k, 8) {\n        int cnt = 0;\n        int nx = x + dx[k], ny = y + dy[k];\n\n        while (inside(nx, ny) && isOpposite(nx, ny, player)) {\n            cnt++;\n            nx += dx[k], ny += dy[k];\n        }\n        if (inside(nx, ny) && board[nx][ny] == player) {\n            while (cnt > 0) {\n                nx -= dx[k], ny -= dy[k];\n                board[nx][ny] = player;\n                cnt--;\n            }\n        }\n    }\n}\n\nvoid initDP() {\n    rep(i, H) rep(j, W) dp[i][j] = 0;\n}\n\n// is pass, then return false\nbool play(char player) {\n    initDP();\n\n    rep(i, H) {\n        rep(j, W) {\n            if (board[i][j] == player) {\n                updateDP(i, j, player);\n            }\n        }\n    }\n\n    P p = getMaxId(player);\n    int max_x = p.first, max_y = p.second;\n\n    if (max_x != -1) {\n        place(max_x, max_y, player);\n        return true;\n    }\n    return false;\n}\n\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    rep(i, H) {\n        string s;\n        cin >> s;\n        rep(j, W) board[i][j] = s[j];\n    }\n\n    bool updated = true;\n    while (updated) {\n        bool up1 = play('o');\n        bool up2 = play('x');\n        updated = up1 || up2;\n    }\n\n    rep(i, H) {\n        rep(j, W) {\n            cout << board[i][j];\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint dx[]{ -1,-1,-1,0,0,1,1,1 }, dy[]{ -1,0,1,-1,1,-1,0,1 };\nchar s[8][9];\nint dfs(int x, int y, int id, char c, int cnt) {\n\tif (!(0 <= x&&x < 8 && 0 <= y&&y < 8) || s[x][y] == '.')return 0;\n\tif (s[x][y] == c)return cnt;\n\treturn dfs(x + dx[id], y + dy[id], id, c, cnt + 1);\n}\nint main() {\n\trep(i, 8)scanf(\"%s\", s[i]);\n\tbool flag = false;\n\tfor (int i = 1;; i++) {\n\t\tif (i & 1) {//o\n\t\t\tint Max = 0, nx, ny;\n\t\t\trep(j, 8)rep(k, 8) {\n\t\t\t\tif (s[j][k] != '.')continue;\n\t\t\t\tint d = 0;\n\t\t\t\trep(t, 8)d += dfs(j + dx[t], k + dy[t], t, 'o', 0);\n\t\t\t\tif (Max < d) {\n\t\t\t\t\tMax = d; nx = j; ny = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Max == 0) {\n\t\t\t\tif (flag)break;\n\t\t\t\tflag = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag = false;\n\t\t\ts[nx][ny] = 'o';\n\t\t\trep(t, 8) {\n\t\t\t\tint k = dfs(nx + dx[t], ny + dy[t], t, 'o', 0);\n\t\t\t\trep(y, k)s[nx + dx[t] * (y + 1)][ny + dy[t] * (y + 1)] = 'o';\n\t\t\t}\n\t\t}\n\t\telse {//x\n\t\t\tint Max = 0, nx, ny;\n\t\t\tfor (int j = 7; j >= 0; j--)for (int k = 7; k >= 0; k--) {\n\t\t\t\tif (s[j][k] != '.')continue;\n\t\t\t\tint d = 0;\n\t\t\t\trep(t, 8)d += dfs(j + dx[t], k + dy[t], t, 'x', 0);\n\t\t\t\tif (Max < d) {\n\t\t\t\t\tMax = d; nx = j; ny = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Max == 0) {\n\t\t\t\tif (flag)break;\n\t\t\t\tflag = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag = false;\n\t\t\ts[nx][ny] = 'x';\n\t\t\trep(t, 8) {\n\t\t\t\tint k = dfs(nx + dx[t], ny + dy[t], t, 'x', 0);\n\t\t\t\trep(y, k)s[nx + dx[t] * (y + 1)][ny + dy[t] * (y + 1)] = 'x';\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 8)printf(\"%s\\n\", s[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring data[8];\nint dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvoid set(int y, int x, char c){\n  data[y][x] = c;\n  for(int i=0;i<8;++i){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    bool f = false;\n    while(min(ny, nx) >= 0 && max(ny, nx) < 8){\n      if(data[ny][nx] == '.') break;\n      if(data[ny][nx] == c){\n        f = true;\n        break;\n      }\n      ny += dy[i];\n      nx += dx[i];\n    }\n    if(f){\n      ny = y + dy[i];\n      nx = x + dx[i];\n      while(data[ny][nx] != c){\n        data[ny][nx] = c;\n        ny += dy[i];\n        nx += dx[i];\n      }\n    }\n  }\n}\n\nint calc(int y, int x, char c){\n  int res = 0;\n  for(int i=0;i<8;++i){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    int cnt = 0;\n    while(min(ny, nx) >= 0 && max(ny, nx) < 8){\n      if(data[ny][nx] == '.') break;\n      if(data[ny][nx] == c){\n        res += cnt;\n        break;\n      }\n      ++cnt;\n      ny += dy[i];\n      nx += dx[i];\n    }\n  }\n  return res;\n}\n\nbool set(int t){\n  int px = -1, py = -1;\n  int valM = 0;\n  if(t){\n    for(int i=0;i<8;++i){\n      for(int j=0;j<8;++j){\n        if(data[i][j] == '.'){\n          int tmp = calc(i, j, 'o');\n          if(valM < tmp){\n            px = j;\n            py = i;\n            valM = tmp;\n          }\n        }\n      }\n    }\n    if(valM) set(py, px, 'o');\n  }else{\n    for(int i=7;i>=0;--i){\n      for(int j=7;j>=0;--j){\n        if(data[i][j] == '.'){\n          int tmp = calc(i, j, 'x');\n          if(valM < tmp){\n            px = j;\n            py = i;\n            valM = tmp;\n          }\n        }\n      }\n    }\n    if(valM) set(py, px, 'x');\n  }\n  if(px == -1 && py == -1) return false;\n  return true;\n}\n\nmain(){\n  for(int i=0;i<8;++i){\n    cin >> data[i];\n  }\n  while(set(1) || set(0));\n  for(int i=0;i<8;i++){\n    cout << data[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint main(){\n  vector<string> grid(8);\n  REP(y, 8) cin>>grid[y];\n  bool update = true;\n  while(update){\n    update = false;\n    {\n      int sx = -1, sy = -1;\n      int cnt = 0;\n      REP(y, 8)REP(x, 8)if(grid[y][x] == '.'){\n        int t = 0;\n        REP(r, 8){\n          int nx = x + dx[r], ny = y + dy[r];\n          int rt = 0;\n          while(true){\n            if(!(nx >= 0 && nx < 8 && ny >= 0 && ny < 8)){\n              break;\n            }\n            if(grid[ny][nx] == '.'){\n              break;\n            }\n            if(grid[ny][nx] == 'o'){\n              t += rt;\n              break;\n            }\n            assert(grid[ny][nx] == 'x');\n            rt ++;\n            ny += dy[r]; nx += dx[r];\n          }\n        }\n        if(cnt < t){\n          sx = x; sy = y; cnt = t;\n        }\n      }\n      if(sx != -1){\n        update = true;\n        grid[sy][sx] = 'o';\n        REP(r, 8){\n          int nx = sx + dx[r], ny = sy + dy[r];\n          bool ok = true;\n          while(true){\n            if(!(nx >= 0 && nx < 8 && ny >= 0 && ny < 8)){\n              ok = false;\n              break;\n            }\n            if(grid[ny][nx] == '.'){\n              ok = false;\n              break;\n            }\n            if(grid[ny][nx] == 'o'){\n              break;\n            }\n            assert(grid[ny][nx] == 'x');\n            ny += dy[r]; nx += dx[r];\n          }\n          if(ok){\n            nx = sx + dx[r], ny = sy + dy[r];\n            while(true){\n              assert((nx >= 0 && nx < 8 && ny >= 0 && ny < 8));\n              if(grid[ny][nx] == 'o'){\n                break;\n              }\n              assert(grid[ny][nx] == 'x');\n              grid[ny][nx] = 'o';\n              ny += dy[r]; nx += dx[r];\n            }\n          }\n        }\n      }\n    }\n    {\n      int sx = -1, sy = -1;\n      int cnt = 1;\n      REP(y, 8)REP(x, 8)if(grid[y][x] == '.'){\n        int t = 0;\n        REP(r, 8){\n          int nx = x + dx[r], ny = y + dy[r];\n          int rt = 0;\n          while(true){\n            if(!(nx >= 0 && nx < 8 && ny >= 0 && ny < 8)){\n              break;\n            }\n            if(grid[ny][nx] == '.'){\n              break;\n            }\n            if(grid[ny][nx] == 'x'){\n              t += rt;\n              break;\n            }\n            assert(grid[ny][nx] == 'o');\n            rt ++;\n            ny += dy[r]; nx += dx[r];\n          }\n        }\n        if(cnt <= t){\n          sx = x; sy = y; cnt = t;\n        }\n      }\n      if(sx != -1){\n        update = true;\n        grid[sy][sx] = 'x';\n        REP(r, 8){\n          int nx = sx + dx[r], ny = sy + dy[r];\n          bool ok = true;\n          while(true){\n            if(!(nx >= 0 && nx < 8 && ny >= 0 && ny < 8)){\n              ok = false;\n              break;\n            }\n            if(grid[ny][nx] == '.'){\n              ok = false;\n              break;\n            }\n            if(grid[ny][nx] == 'x'){\n              break;\n            }\n            assert(grid[ny][nx] == 'o');\n            ny += dy[r]; nx += dx[r];\n          }\n          if(ok){\n            nx = sx + dx[r], ny = sy + dy[r];\n            while(true){\n              assert((nx >= 0 && nx < 8 && ny >= 0 && ny < 8));\n              if(grid[ny][nx] == 'x'){\n                break;\n              }\n              assert(grid[ny][nx] == 'o');\n              grid[ny][nx] = 'x';\n              ny += dy[r]; nx += dx[r];\n            }\n          }\n        }\n      }\n    }\n  }\n  REP(y, 8) cout<<grid[y]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nchar s[8][8];\nint dx[8]={1,1, 1,  0, 0,  -1,-1,-1};\nint dy[8]={1,0,-1,  1,-1,   1, 0,-1};\nvector<char*> count(int i, int j, char c){\n  int x,y;\n  vector<char*> ret;\n  for( int lp=0;lp<8;lp++ ){\n    x=i;y=j;\n    for(int k=0;k<8;k++ ){\n      x+=dx[lp]; y+=dy[lp];\n      if( x<0 || x>=8 ) break;\n      if( y<0 || y>=8 ) break;\n      if( s[x][y]=='.' ) break;\n      if( s[x][y]!=c ) continue;\n      if( k==0 ) break;\n\n      x=i; y=j;\n      for( int z=0;z<=k;z++ ){\n\tx+=dx[lp]; y+=dy[lp];\n\tret.push_back( &s[x][y] );\n      }\n      break;\n    }\n  }\n  if( !ret.empty() )\n    ret.push_back( &s[i][j] );\n  return ret;\n}\n\nvoid proc(int i, int j,char c, vector<char*> &ret ){\n  if( s[i][j]!='.' )\n    return;\n\n  vector<char*> tmp = count(i,j,c);\n  if( tmp.size() > ret.size() && tmp.size()>1 )\n    ret = tmp;\n};\n\nint turn(bool f){\n  char c = f?'o':'x';\n  vector<char*> ret;\n  if( f ){\n    for( int i=0;i<8;i++ )\n      for( int j=0;j<8;j++ )\n\tproc( i,j,c, ret );\n  }else{\n    for( int i=7;i>=0;i-- )\n      for( int j=7;j>=0;j-- )\n\tproc( i,j,c, ret );\n  }\n  for( int i=0;i<(int)ret.size(); i++ )\n    *ret[i] = c;\n  return ret.size();\n}\n\nint main(){\n  for( int i=0;i<8;i++ )\n    for(int j=0;j<8;j++ )\n      cin >> s[i][j];\n\n  bool f=true;\n  while( true ){\n    if( turn(f)==0 ){\n      f=!f;\n      if( turn(f)==0 )\n\tbreak;\n    }\n    f=!f;\n  }\n\n  for( int i=0;i<8;i++ ){\n    for( int j=0;j<8;j++ )\n      cout << s[i][j];\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dy[]={-1,-1,-1,0,1,1,1,0}, dx[]={-1,0,1,1,1,0,-1,-1};\nchar mass[2]={'o','x'};\nchar s[16][16];\n\nvoid solve(int p){\n  int x=-1,y=-1,get=0;\n  rep(i,8) rep(j,8){\n    if(s[i][j]!='.') continue;\n    //    cout << \"i \"<< i << \" j \" << j << endl;\n    int nget=0;\n    rep(d,8){\n      int ny=i+dy[d], nx=j+dx[d];\n      while(s[ny][nx]!='.' && ny>=0 && ny<8 && nx>=0 && nx<8){\n\tif(mass[p]==s[ny][nx]){\n\t  nget += max(abs(i-ny)-1, abs(j-nx)-1);\n\t  break;\n\t}\n\tny+=dy[d]; nx+=dx[d];\n      }\n    }\n\n    if(p && get <= nget){\n      y = i; x = j; get = nget;\n    }else if(!p && get < nget){\n      y = i; x = j; get = nget;\n    }\n  }\n  //  cout << y << \"  \" << x << endl;\n  if(get>0){\n    s[y][x] = mass[p];\n    rep(d,8){\n      int ny=y+dy[d], nx=x+dx[d];\n      while(s[ny][nx]!='.' && ny>=0 && ny<8 && nx>=0 && nx<8){\n\tif(mass[p]==s[ny][nx]){\n\t  ny=y+dy[d],nx=x+dx[d];\n\t  while(s[ny][nx]!=mass[p]){\n\t    s[ny][nx] = mass[p];\n\t    ny+=dy[d]; nx+=dx[d];\n\t  }\n\t  break;\n\t}\n\tny+=dy[d]; nx+=dx[d];\n      }\n    }\n  }\n}\n\nint main(){\n  rep(i,8) scanf(\"%s\", s[i]);\n\n  rep(i,64){\n    //    cout << \"i \" << i << endl;\n    solve(i%2);\n  }\n\n  rep(i,8) puts(s[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint dx[] = {-1,-1,0,1,1,1,0,-1},dy[] = {0,1,1,1,0,-1,-1,-1};\n\nint main(){\n\tint field[10][10] = {},mas[10][10] = {};\n\tstring s;\n\tfor(int i = 0;i < 8;i++){\n\t\tcin >> s;\n\t\tfor(int j = 0;j < 8;j++){\n\t\t\tif(s[j] == 'o') field[i + 1][j + 1] = 1;\n\t\t\telse if(s[j] == 'x') field[i + 1][j + 1] = 2;\n\t\t}\n\t}\n\tint flag = 0;//o start\n\tbool pass = false;\n\twhile(1){\n\t\tint can = 0;\n\t\tint mnum = 0,mx,my;\n\t\tfor(int i = 0;i <= 9;i++){\n\t\t\tfor(int j = 0;j <= 9;j++) mas[i][j] = 0;\n\t\t}\n\t\tfor(int i = 1;i <= 8;i++){\n\t\t\tfor(int j = 1;j <= 8;j++){\n\t\t\t\tif(!field[i][j]){\n\t\t\t\t\tint ma = 0;\n\t\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\t\tint x = i + dx[k],y = j + dy[k],cnt = 0;\n\t\t\t\t\t\twhile(field[x][y] == (flag + 1) % 2 + 1) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tx += dx[k];\n\t\t\t\t\t\t\ty += dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[x][y]) {\n\t\t\t\t\t\t\tma += cnt;\n\t\t\t\t\t\t\tmas[i][j] += (1 << k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((flag == 0 && mnum < ma) || (flag == 1 && mnum <= ma)){\n\t\t\t\t\t\tmnum = ma;\n\t\t\t\t\t\tmx = i;\n\t\t\t\t\t\tmy = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(ma) can++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(can == 0){\n\t\t\tif(!pass) pass = true;\n\t\t\telse break;\n\t\t}else{\n\t\t\tfield[mx][my] = flag + 1;\n\t\t\tfor(int i = 0;i < 8;i++){\n\t\t\t\tif((mas[mx][my] >> i) & 1){\n\t\t\t\t\tint x = mx + dx[i],y = my + dy[i];\n\t\t\t\t\twhile(field[x][y] == (flag + 1) % 2 + 1){\n\t\t\t\t\t\tfield[x][y] = flag + 1;\n\t\t\t\t\t\tx += dx[i];\n\t\t\t\t\t\ty += dy[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflag = !flag;\n\t}\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tif(field[i][j] == 0) cout << '.';\n\t\t\telse if(field[i][j] == 1) cout << 'o';\n\t\t\telse cout << 'x';\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nchar b[8][16];\n\nint main(){\n  REP(i,8) scanf(\"%s\", b[i]);\n\n  // ÜÝÁ½            \n\n  char mami = 'o';\n  char shal = 'x';\n\n  char ck[2] = { mami, shal };\n  int turn = 0;\n  int bad = 0;\n\n  while(bad < 2){\n    int maxcnt = 0;\n    int px, py;\n\n    //printf(\"bad: %d\\n\", bad);\n\n    REP(y,8) REP(x,8) if(b[y][x] == '.'){\n      int cnt = 0;\n      REP(i,3) REP(j,3) if(i != 1 || j != 1){\n\tint dy = i - 1;\n\tint dx = j - 1;\n\n\tint xx = x + dx;\n\tint yy = y + dy;\n\n\tint cc = 0;\n\n\twhile(true){\n\t  if(xx < 0) break;\n\t  if(yy < 0) break;\n\t  if(xx > 7) break;\n\t  if(yy > 7) break;\n\n\t  if(b[yy][xx] == ck[turn]){\n\t    cnt += cc;\n\t    break;\n\t  }else if(b[yy][xx] == ck[(turn + 1) % 2]){\n\t    cc++;\n\t  }else{\n\t    break;\n\t  }\n\n\t  yy += dy;\n\t  xx += dx;\n\t}\n      }\n\n      if(turn == 0){\n\tif(cnt > maxcnt){\n\t  maxcnt = cnt;\n\t  px = x;\n\t  py = y;\n\t}\n      }else{\n\tif(cnt >= maxcnt){\n\t  maxcnt = cnt;\n\t  px = x;\n\t  py = y;\n\t}\n      }\n    }\n\n    if(maxcnt > 0){\n      bad = 0;\n\n      b[py][px] = ck[turn];\n      REP(i,3) REP(j,3) if(i != 1 || j != 1){\n\tint dy = i - 1;\n\tint dx = j - 1;\n\n\tint xx = px + dx;\n\tint yy = py + dy;\n\n\twhile(true){\n\t  if(xx < 0) break;\n\t  if(yy < 0) break;\n\t  if(xx > 7) break;\n\t  if(yy > 7) break;\n\n\t  if(b[yy][xx] == ck[turn]){\n\t    dx = -dx;\n\t    dy = -dy;\n\t    yy += dy;\n\t    xx += dx;\n\n\t    while(yy != py || xx != px){\n\t      b[yy][xx] = ck[turn];\n\t      yy += dy;\n\t      xx += dx;\n\t    }\n\n\t    break;\n\t  }else if(b[yy][xx] == ck[(turn + 1) % 2]){\n\t  }else{\n\t    break;\n\t  }\n\n\t  xx += dx;\n\t  yy += dy;\n\t}\n      }\n\n    }else{\n      bad++;\n    }\n    \n    turn = (turn + 1) % 2;\n  }\n\n  REP(i,8) puts(b[i]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\n//int dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n }; */\n\n\n/** Problem2311 : Dessert Witch **/\nenum {\n\tWHITE = 0,\n\tBLACK,\n\tNONE,\n};\n\nint board[8][8];\nint board_tmp[8][8];\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nvoid print_board()\n{\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (board[j][i] == WHITE) cout << \"o\";\n\t\t\telse if (board[j][i] == BLACK) cout << \"x\";\n\t\t\telse cout << \".\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nbool range_valid(int x, int y)\n{\n\tif (x < 0 || 8 <= x || y < 0 || 8 <= y) return false;\n\treturn true;\n}\n\nbool can_reverse(int x, int y, int d, int turn)\n{\n\tif (!range_valid(x, y) || board[x][y] == NONE) return false;\n\tif (board[x][y] == turn) return true;\n\t\n\treturn can_reverse(x+dx[d], y+dy[d], d, turn);\n}\n\nvoid do_reverse(int x, int y, int d, int turn)\n{\n\tif (board[x][y] == turn) return;\n\tboard[x][y] = turn;\n\tdo_reverse(x+dx[d], y+dy[d], d, turn);\n}\n\nbool can_put(int x, int y, int turn)\n{\n\tif (board[x][y] != NONE) return false;\n\t\n\tfor (int i=0; i<8; i++) {\n\t\tint nx = x+dx[i], ny=y+dy[i];\n\t\tif (board[nx][ny] == 1-turn && can_reverse(x+dx[i], y+dy[i], i, turn)) return true;\n\t}\n\treturn false;\n}\n\nbool can_put_all(int turn)\n{\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (can_put(j, i, turn)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool gameover()\n{\n\treturn !can_put_all(WHITE) && !can_put_all(BLACK);\n}\n\nPII count_stone()\n{\n\tPII res = PII(0, 0);\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (board[i][j] == WHITE) res.first++;\n\t\t\telse if (board[i][j] == BLACK) res.second++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint turn=WHITE;\n\t\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif (c=='.')\t\t board[j][i] = NONE;\n\t\t\telse if (c=='o') board[j][i] = WHITE;\n\t\t\telse\t\t\t board[j][i] = BLACK;\n\t\t}\n\t}\n\t\n\twhile (true) {\n\t\tprint_board();\n\t\tcout << endl;\n\t\t\n\t\tif (!can_put_all(turn)) {\n\t\t\tturn = 1-turn;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint target_x = -1, target_y = -1, cnt_max=0;\n\t\t\n\t\tfor (int y=0; y<8; y++) {\n\t\t\tfor (int x=0; x<8; x++) {\n\t\t\t\tif (board[x][y] != NONE) continue;\n\t\t\t\t\n\t\t\t\tmemcpy(board_tmp, board, sizeof(board));\n\t\t\t\t\n\t\t\t\tbool ok=false;\n\t\t\t\tfor (int i=0; i<8; i++) {\n\t\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\t\tif (board[nx][ny] != 1-turn) continue;\n\t\t\t\t\t\n\t\t\t\t\tif (can_reverse(nx, ny, i, turn)) {\n\t\t\t\t\t\tdo_reverse(nx, ny, i, turn);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ok) {\n\t\t\t\t\tprint_board();\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t\n\t\t\t\t\tboard[x][y] = turn;\n\t\t\t\t\tPII cnt = count_stone();\n\t\t\t\t\t\n\t\t\t\t\tif (turn == WHITE) {\n\t\t\t\t\t\tif (cnt_max < cnt.first) {\n\t\t\t\t\t\t\ttarget_x = x;\n\t\t\t\t\t\t\ttarget_y = y;\n\t\t\t\t\t\t\tcnt_max = cnt.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cnt_max <= cnt.second) {\n\t\t\t\t\t\t\ttarget_x = x;\n\t\t\t\t\t\t\ttarget_y = y;\n\t\t\t\t\t\t\tcnt_max = cnt.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmemcpy(board, board_tmp, sizeof(board));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<8; i++) {\n\t\t\tprint_board();\n\t\t\tcout << endl;\n\t\t\t\n\t\t\tint nx = target_x+dx[i], ny = target_y+dy[i];\n\t\t\tif (board[nx][ny] != 1-turn) continue;\n\t\t\t\n\t\t\tif (can_reverse(nx, ny, i, turn)) {\n\t\t\t\tdo_reverse(nx, ny, i, turn);\n\t\t\t}\n\t\t}\n\t\tboard[target_x][target_y] = turn;\n\t\tturn = 1-turn;\n\t\t\n\t\tif (gameover()) {\n\t\t\tprint_board();\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nchar table[8][8];\nint available[8][8];\n\nint direct_x(int k);\nint direct_y(int k);\n\n\nint check_mami();\nint check_majo();\n\nint check(char cookie);\nint place(char cookie);\n\nint main(void){\n\n  const char mami='o';\n  const char majo='x';\n\n  char cookie[2]={mami,majo};\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cin >> table[i][j];\n    }\n  }\n\n  int pass[2]={0,0};\n  \n  for(int cnt1=0; (pass[0]!=1 or pass[1] != 1) and cnt1 < 200 ;cnt1++){\n\n    check(cookie[cnt1%2]);\n    if(place(cookie[cnt1%2]) <=0){\n      pass[cnt1%2]=1;\n    }\n    else{\n      pass[cnt1%2]=0;\n    }\n\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\t//cout <<  available[i][j];\n      }\n      //cout << endl;\n    }\n    //cout << endl;\n\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\t//cout <<  table[i][j];\n      }\n      //cout << endl;\n    }\n    //cout << endl;    \n    \n  }\n  //cout << \"game is over!\" << endl;\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout <<  table[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}\n\n//int check_mami(){\nint check(char cookie){\n\n  char enemy;\n\n  if(cookie != 'o' and cookie != 'x') abort();\n  else if(cookie == 'o') enemy='x';\n  else if(cookie == 'x') enemy='o';\n  \n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      available[i][j]=0;\n    }\n  }\n  \n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      if(table[i][j] == 'o' or table[i][j] == 'x') continue; //has been placed?\n\n      for(int k=0;k<9;k++){\n\tif(!(i+direct_y(k)>=0 and i+direct_y(k)<= 7 and j+direct_x(k)>=0 and j+direct_x(k)<=7) ) continue;\n\tif(table[i+direct_y(k)][j+direct_x(k)] == enemy){\n\t  //cout << \"you can place at:(\" <<i <<\",\"<<j << \"),k:\"<< k << endl;\n\t  for(int a=2; i+a*direct_y(k)>=0 and i+a*direct_y(k)<= 7 and j+a*direct_x(k)>=0 and j+a*direct_x(k) <=7 ;a++){\n\t    if(table[i+a*direct_y(k)][j+a*direct_x(k)] == cookie ){\n\t      //cout <<\"you can get cookie:\"<<a-1 << \" at k:\" <<k << endl;\n\t      available[i][j] += a-1;\n\t      break;\n\t    }\n\t    else if(table[i+a*direct_y(k)][j+a*direct_x(k)] == enemy ){\n\t      continue;\n\t    }\n\t    else{\n\t      break;\n\t    }\n\t  }\n\t  \n\t}\n\telse continue;\n      }\n      \n    }\n  }\n  \n}\n\nint direct_x(int k){\n\n  return (k%3) - 1;\n\n}\n\nint direct_y(int k){\n\n  return -(k/3) + 1;\n\n}\n\nint place(char cookie){\n\n  int x=0,y=0;\n  int max=0;\n  //cout << \"cookie is :\" << cookie << endl;\n\n  char enemy;\n  if(cookie != 'o' and cookie != 'x') abort();\n  else if(cookie == 'o') enemy='x';\n  else if(cookie == 'x') enemy='o';  \n  \n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      if(cookie=='o'){\n\tif(available[i][j] > max){\n\t  //cout << \"cookie:o,max reflashed! max:\"<< max  << \"(x,y)=(\" <<x << \",\" <<y << \")\" << endl;\n\t  max=available[i][j];\n\t  x=j;\n\t  y=i;\n\t}\n      }\n      else if(cookie == 'x'){\n\tif(available[i][j] >= max){\n\t  //cout << \"cookie:x,max reflashed! max:\"<< max  << \"(x,y)=(\" <<x << \",\" <<y << \")\" << endl;\n\t  max=available[i][j];\t  \n\t  x=j;\n\t  y=i;\n\t}\n      }\n    }\n  }\n  if(max > 0){\n    //cout << \"cookie will be placed (\" <<x << \",\" <<y << \")\" << endl;\n\n    for(int k=0;k<9;k++){\n      if(!(y+direct_y(k)>=0 and y+direct_y(k)<= 7 and x+direct_x(k)>=0 and x+direct_x(k)<=7) ) continue;\n      if(table[y+direct_y(k)][x+direct_x(k)] == enemy){\n\t//cout << \"you can place at:(\" <<x <<\",\"<<y << \"),k:\"<< k << endl;\n\tfor(int a=2; y+a*direct_y(k)>=0 and y+a*direct_y(k)<= 7 and x+a*direct_x(k)>=0 and x+a*direct_x(k) <=7 ;a++){\n\t  if(table[y+a*direct_y(k)][x+a*direct_x(k)] == cookie ){\n\t    //cout <<\"you can get cookie:\"<<a-1 << \" at k:\" <<k << endl;\n\t    //available[i][j] += a-1;\n\n\t    for(int b=0;b<a-1+1;b++){\n\t      table[y+b*direct_y(k)][x+b*direct_x(k)] = cookie;\n\t    }\n\t    \n\t    break;\n\t  }\n\t  else if(table[y+a*direct_y(k)][x+a*direct_x(k)] == enemy ){\n\t    continue;\n\t  }\n\t  else{\n\t    break;\n\t  }\n\t}\n\t  \n      }\n      else continue;\n    }    \n    \n  }\n  else{\n    //cout << \"you cannot place cookie!\" << endl;\n  }\n\n  return max;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,1,0,-1,-1,-1,0,1};\nconst int dy[]={0,-1,-1,-1,0,1,1,1};\n\nint main(){\n\tchar B[8][9];\n\trep(i,8) scanf(\"%s\",B[i]);\n\n\trep(t,64){\n\t\tchar c1=(t%2?'x':'o'),c2=(t%2?'o':'x'); // ©ªÌNbL[, èÌNbL[\n\n\t\tint i_opt=0,j_opt=0,tot_opt=0;\n\t\trep(i,8) rep(j,8) if(B[i][j]=='.') {\n\t\t\tint tot=0; // ÆêéèÌNbL[ÌÂ\n\t\t\trep(k,8){ // (i,j) Éu¢½Æ«ÉèÌNbL[ðÍ³ßé©\n\t\t\t\tint l,y,x;\n\t\t\t\tfor(l=1;;l++){\n\t\t\t\t\ty=i+l*dy[k];\n\t\t\t\t\tx=j+l*dx[k];\n\t\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c2);\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\ty=i+l*dy[k];\n\t\t\t\tx=j+l*dx[k];\n\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c1) tot+=l-1;\n\t\t\t}\n\t\t\tif(tot_opt<tot\n\t\t\t|| tot_opt==tot && (t?make_pair(i_opt,j_opt)<make_pair(i,j)\n\t\t\t\t\t\t\t\t :make_pair(i_opt,j_opt)>make_pair(i,j))){\n\t\t\t\ti_opt=i;\n\t\t\t\tj_opt=j;\n\t\t\t\ttot_opt=tot;\n\t\t\t}\n\t\t}\n\n\t\tif(tot_opt==0) continue;\n\n\t\t// NbL[ðu­\n\t\tB[i_opt][j_opt]=c1;\n\t\trep(k,8){ // ½]\n\t\t\tint l,y,x;\n\t\t\tfor(l=1;;l++){\n\t\t\t\ty=i_opt+l*dy[k];\n\t\t\t\tx=j_opt+l*dx[k];\n\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c2);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\ty=i_opt+l*dy[k];\n\t\t\tx=j_opt+l*dx[k];\n\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c1){\n\t\t\t\tfor(l--;l>0;l--){\n\t\t\t\t\tint y=i_opt+l*dy[k],x=j_opt+l*dx[k];\n\t\t\t\t\tif(0<=y && y<8 && 0<=x && x<8 && B[y][x]==c2) B[y][x]=c1;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,8) puts(B[i]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define inRange(x, y, w, h) (0 <= x && x < w && 0 <= y && y < h)\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define repd(i, b, n) for(int i=b; i > n; --i)\n\nusing namespace std;\n\nconst int dx[] = { 0, 0, -1, 1, -1, -1, 1, 1 };\nconst int dy[] = { -1, 1, 0, 0, -1, 1, -1, 1 };\nchar fd[8][8];\n\nint counter( int x, int y, int d, char _my, char your )\n{\n\tint count = 0;\n\tint mx = x + dx[d];\n\tint my = y + dy[d];\n\twhile(inRange(mx, my, 8, 8)) {\n\t\tchar c = fd[my][mx];\n\t\tif(c == _my) return count;\n\t\telse if(c == your) ++count;\n\t\telse break;\n\t\tmx += dx[d];\n\t\tmy += dy[d];\n\t}\n\treturn 0;\n}\n\nvoid filler( int x, int y, int d, char _my )\n{\n\tfd[y][x] = _my;\n\tint mx = x + dx[d];\n\tint my = y + dy[d];\n\tdo {\n\t\tfd[my][mx] = _my;\n\t\tmx += dx[d];\n\t\tmy += dy[d];\n\t\tif(fd[my][mx] == _my) break;\n\t} while(inRange(mx, my, 8, 8));\n}\n\nint main( void )\n{\n\twhile(cin >> fd[0][0]) {\n\t\trep2(x, 1, 8) cin >> fd[0][x];\n\t\trep2(y, 1, 8) rep(x, 8) cin >> fd[y][x];\n\t\tbool hit1, hit2;\n\t\tdo {\n\t\t\tint sx, sy, count, Max = 0;\n\t\t\thit1 = false;\n\t\t\trep(y, 8)\n\t\t\t\trep(x, 8) {\n\t\t\t\t\tif(fd[y][x] != '.') continue;\n\t\t\t\t\tcount = 0;\n\t\t\t\t\trep(d, 8) count += counter(x, y, d, 'o', 'x');\n\t\t\t\t\tif(Max < count) { Max = count; sx = x; sy = y; hit1 = true; }\n\t\t\t\t}\n\t\t\tif(hit1) rep(d, 8) if(counter(sx, sy, d, 'o', 'x')) filler(sx, sy, d, 'o');\n\n\t\t\thit2 = false;\n\t\t\tMax = 0;\n\t\t\trepd(y, 7, -1)\n\t\t\t\trepd(x, 7, -1) {\n\t\t\t\t\tif(fd[y][x] != '.') continue;\n\t\t\t\t\tcount = 0;\n\t\t\t\t\trep(d, 8) count += counter(x, y, d, 'x', 'o');\n\t\t\t\t\tif(Max < count) { Max = count; sx = x; sy = y; hit2 = true; }\n\t\t\t\t}\n\t\t\tif(hit2) rep(d, 8) if(counter(sx, sy, d, 'x', 'o')) filler(sx, sy, d, 'x');\n\t\t} while(hit1 || hit2);\n\t\trep(y, 8) {\n\t\t\trep(x, 8)\n\t\t\t\tcout << fd[y][x];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstring s[8];\nbool is(int x,int y){\n\treturn 0<=x&&x<8&&0<=y&&y<8;\n}\nint dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};\nint main(){\n\trep(i,8) cin>>s[i];\n\tbool mami=true;\n\tbool skip=false;\n\twhile(true){\n\t\tif(mami){\n\t\t\tint chi,chj,mx=0;\n\t\t\trep(i,8) rep(j,8){\n\t\t\t\tif(s[i][j]!='.') continue;\n\t\t\t\tint stone=0;\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=i,y=j;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='x'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='o'&&cnt>0) stone+=cnt;\n\t\t\t\t}\n\t\t\t\tif(stone>mx){\n\t\t\t\t\tchi=i,chj=j,mx=stone;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==0){\n\t\t\t\tif(skip) break;\n\t\t\t\tskip=true;\n\t\t\t}else{\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=chi,y=chj;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='x'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='o'&&cnt>0){\n\t\t\t\t\t\tint xx=chi,yy=chj;\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\txx+=dx[d],yy+=dy[d];\n\t\t\t\t\t\t\tif(s[xx][yy]=='o') break;\n\t\t\t\t\t\t\ts[xx][yy]='o';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts[chi][chj]='o';\n\t\t\t}\n\t\t}else{\n\t\t\tint chi,chj,mx=0;\n\t\t\tfor(int i=7;i>=0;i--) for(int j=7;j>=0;j--){\n\t\t\t\tif(s[i][j]!='.') continue;\n\t\t\t\tint stone=0;\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=i,y=j;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='o'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='x'&&cnt>0) stone+=cnt;\n\t\t\t\t}\n\t\t\t\tif(stone>mx){\n\t\t\t\t\tchi=i,chj=j,mx=stone;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==0){\n\t\t\t\tif(skip) break;\n\t\t\t\tskip=true;\n\t\t\t}else{\n\t\t\t\trep(d,8){\n\t\t\t\t\tint x=chi,y=chj;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\twhile(is(x,y)&&s[x][y]=='o'){\n\t\t\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(is(x,y)&&s[x][y]=='x'&&cnt>0){\n\t\t\t\t\t\tint xx=chi,yy=chj;\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\txx+=dx[d],yy+=dy[d];\n\t\t\t\t\t\t\tif(s[xx][yy]=='x') break;\n\t\t\t\t\t\t\ts[xx][yy]='x';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts[chi][chj]='x';\n\t\t\t}\n\t\t}\n\t\tmami=!mami;\n\t}\n\trep(i,8) cout<<s[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\nstring F[8];\nbool used[8][8];\nint turn;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b)                                       \\\n  for(int i=turn&1?a:b; turn&1?i>=b:i<=a; turn&1?i--:i++)\n\nint main() {\n  rep(i, 8) cin >> F[i];\n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0) DREP(j, 7, 0) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        if(mx < r) {\n          memcpy(u, used, sizeof u);\n          mx = r; pl = turn&1;\n        }\n      }\n    }\n    if(mx > 0) {\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    puts(\"\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n#define FOR(i) rep(i,0,7)\n\nvector<vector<int>> fie(8,vector<int>(8));\n\nint cou(int x,int y,int color,vector<vector<int>>& copy){\n\n    int res = 0;\n\n    vector<vector<int>> temp;\n\n    temp = copy;\n    for(int i = x - 1;i >= 0;i--){\n        if(copy[i][y] == 0) break;\n        if(copy[i][y] == color){\n            res += x - i - 1;\n            copy = temp;\n            break;\n        }\n        temp[i][y] = color;\n    }\n\n    temp = copy;\n    for(int i = x + 1;i < 8;i--){\n        if(copy[i][y] == 0) break;\n        if(copy[i][y] == color){\n            res = i - x - 1;\n            copy = temp;\n            break;\n        }\n        temp[i][y] = color;\n    }\n    temp = copy;\n    for(int i = y - 1;i >= 0;i--){\n        if(copy[x][i] == 0) break;\n        if(copy[x][i] == color){\n            res += y - i - 1;\n            copy = temp;\n            break;\n        }\n        temp[x][i] = color;\n    }\n\n    temp = copy;\n    for(int i = y + 1;i < 8;i--){\n        if(copy[x][i] == 0) break;\n        if(copy[x][i] == color){\n            res += i - y -1;\n            copy = temp;\n            break;\n        }\n        temp[x][i] = color;\n    }\n    int dx[2] = {1,-1};\n    int dy[2] = {1,-1};\n\n    for(int di = 0;di < 2;di++) for(int dj = 0;dj < 2;dj++){\n            temp = copy;\n            for (int i = 1;; i++)\n            {\n                int nx = i * dx[di] + x;\n                int ny = i * dy[dj] + y;\n                if (!(0 <= nx && nx < 8 && 0 <= ny && ny < 8))\n                    break;\n                if (copy[nx][ny] == 0)\n                    break;\n                if (copy[nx][ny] == color)\n                {\n                    res += i - 1;\n                    copy = temp;\n                    break;\n                }\n                temp[nx][ny] = color;\n        }\n    }\n\n    return res;\n}\n\nint pass = 0;\n\nstring ans_s = \".ox\";\nint rec(int turn)\n{\n    if(pass == 2) return 0;\n    if(turn == 1){\n        int MAX = 0;\n        P ans = {-1,-1};\n        for(int i = 0;i < 8;i++){\n            for(int j = 0;j < 8;j++){\n                if(fie[i][j] == 0){\n                    auto copy = fie;\n                    int t = cou(i,j,turn,copy);\n                    if(MAX < t)\n                    {\n                        ans.first = i;\n                        ans.second = j;\n                        MAX = t;\n                    }\n                }\n            }\n        }\n        if(ans.first != -1)\n        {\n            cou(ans.first,ans.second,turn,fie);\n            fie[ans.first][ans.second] = turn;\n            pass = 0;\n        }\n        else\n        {\n            pass++;\n        }\n        return rec(2);\n    }\n    if(turn == 2){\n        int MAX = 0;\n        P ans = {-1,-1};\n        for(int i = 7;i >= 0;i--){\n            for(int j = 7;j >= 0;j--){\n                if(fie[i][j] == 0){\n                    auto copy = fie;\n                    int t = cou(i,j,turn,copy);\n                    if(MAX < t)\n                    {\n                        ans.first = i;\n                        ans.second = j;\n                        MAX = t;\n                    }\n                }\n            }\n        }\n        if(ans.first != -1)\n        {\n            cou(ans.first,ans.second,turn,fie);\n            fie[ans.first][ans.second] = turn;\n            pass = 0;\n        }\n        else\n        {\n            pass++;\n        }\n        return rec(1);\n    }\n    return 0;\n}\nint main()\n{\n    FOR(i){\n        string s;\n        cin >> s;\n        FOR(j){\n            if(s[j] == 'o'){\n                fie[i][j] = 1;\n            }\n            if(s[j] == 'x'){\n                fie[i][j] = 2;\n            }\n        }\n    }\n\n    rec(1);\n\n\n    FOR(i){\n        FOR(j){\n            cout << ans_s[fie[i][j]]; \n        }\n        cout << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int>P;\n#define X first\n#define Y second\n/*\nオセロ\noxoxox\n*/\n\nchar mp[10][10];\n\nint dx[8]={0,1,1,1,0,-1,-1,-1};\nint dy[8]={1,1,0,-1,-1,-1,0,1};\n\nint pos_cnt(P p){\n\tint cnt=0;\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=1;true;j++){\n\t\t\tif(mp[p.X+j*dx[i]][p.Y+j*dy[i]]=='.'||mp[p.X+j*dx[i]][p.Y+j*dy[i]]=='*')break;\n\t\t\tif(mp[p.X+j*dx[i]][p.Y+j*dy[i]]==mp[p.X][p.Y]){\n\t\t\t\tcnt+=(j-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nP pos_check(char c){\n\tP p;p.X=-1;p.Y=-1;\n\tint mx=0;\n\t\n\tif(c=='o'){\n\t\tfor(int i=1;i<=8;i++){\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tif(mp[j][i]=='.'){\n\t\t\t\t\tmp[j][i]=c;\n\t\t\t\t\tint tmp=pos_cnt(P(j,i));\n\t\t\t\t\tif(mx<tmp){\n\t\t\t\t\t\tp.X=j;\n\t\t\t\t\t\tp.Y=i;\n\t\t\t\t\t\tmx=tmp;\n\t\t\t\t\t}\n\t\t\t\t\tmp[j][i]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(int i=8;i>=1;i--){\n\t\t\tfor(int j=8;j>=1;j--){\n\t\t\t\tif(mp[j][i]=='.'){\n\t\t\t\t\t\n\t\t\t\t\tmp[j][i]=c;\n\t\t\t\t\tint tmp=pos_cnt(P(j,i));\n\t\t\t\t\tif(mx<tmp){\n\t\t\t\t\t\tp.X=j;\n\t\t\t\t\t\tp.Y=i;\n\t\t\t\t\t\tmx=tmp;\n\t\t\t\t\t}\n\t\t\t\t\tmp[j][i]='.';\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nvoid pos_change(P p){\n\tfor(int i=0;i<8;i++){\n\t\tint f=0;\n\t\tfor(int j=1;true;j++){\n\t\t\tif(mp[p.X+j*dx[i]][p.Y+j*dy[i]]=='.'||mp[p.X+j*dx[i]][p.Y+j*dy[i]]=='*')break;\n\t\t\tif(mp[p.X+j*dx[i]][p.Y+j*dy[i]]==mp[p.X][p.Y]){\n\t\t\t\tf=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;f;j++){\n\t\t\tif(mp[p.X+j*dx[i]][p.Y+j*dy[i]]!=mp[p.X][p.Y])mp[p.X+j*dx[i]][p.Y+j*dy[i]]=mp[p.X][p.Y];\n\t\t\telse if(mp[p.X+j*dx[i]][p.Y+j*dy[i]]==mp[p.X][p.Y])break;\n\t\t}\n\t}\n}\n\n\nint main(){\n\t//初期化\n\tmemset(mp,'.',sizeof(mp));\n\t//入力\n\tfor(int i=1;i<=8;i++){\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tcin>>mp[j][i];\n\t\t}\n\t}\n\t\n\t//oから始まる\n\tchar turn='o';\n\t\n\t//2回連続でどこにもおけなかったら終了\n\tfor(int dame=0;dame<2;){\n\t\t//おける場所を探す\n\t\tP p=pos_check(turn);\n\t\tif(p.X<0){\n\t\t\t//置けない\n\t\t\tdame++;\n\t\t}else{\n\t\t\t//おける\n\t\t\tdame=0;\n\t\t\t//おける場所に置く\n\t\t\tmp[p.X][p.Y]=turn;\n\t\t\t//ひっくり返す\n\t\t\tpos_change(p);\n\t\t}\n\t\t\n\t\t//ターン変更\n\t\tif(turn=='o')turn='x';\n\t\telse if(turn=='x')turn='o';\n\t\t\n\t}\n\t\n\t//出力\n\tfor(int i=1;i<=8;i++){\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tcout<<mp[j][i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<string> v(8);\n\tREP(i, 8)cin >> v[i];\n\tint cnt = 0;\n\tREP(i, 8)REP(j, 8)if (v[i][j] == '.')cnt++;\n\tREP(t, cnt) {\n\t\tint p = -1, q = -1, cmax = -1;\n\t\tif (t % 2 == 0) {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'x')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\ts.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax < c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tv[p][q] = 'o';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'x')v[ni][nj] = 'o';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'o')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\ts.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax <= c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax<=0)continue;\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tv[p][q] = 'x';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'o')v[ni][nj] = 'x';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n//#include <unordered_map>\n//#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tint n = 8;\n\tMAT(char, a, n, n);\n\tint dy8[] = { -1,-1,-1,0,1,1,1,0 };\n\tint dx8[] = { -1,0,1,1,1,0,-1,-1 };\n\tchar c = 'o';\n\tint pre = -1;\n\twhile (true) {\n\t\tint max = 0;\n\t\tstd::vector<PAIR> v;\n\t\tchar o = (c == 'o') ? 'x' : 'o';\n\t\tREP(i, n) REP(j, n) {\n\t\t\tif (a[i][j] != '.') continue;\n\t\t\tint cnt = 0;\n\t\t\tREP(d, 8) {\n\t\t\t\tint k = 1;\n\t\t\t\twhile (true) {\n\t\t\t\t\tint dy = i + dy8[d] * k;\n\t\t\t\t\tint dx = j + dx8[d] * k;\n\t\t\t\t\tif (!IN(0, dy, n) || !IN(0, dx, n)) break;\n\t\t\t\t\tif (a[dy][dx] == o) {\n\t\t\t\t\t\t++k;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (a[dy][dx] == c) {\n\t\t\t\t\t\tcnt += k - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt == 0) continue;\n\t\t\tif (max == cnt) v.emplace_back(i, j);\n\t\t\tif (max < cnt) {\n\t\t\t\tmax = cnt;\n\t\t\t\tv = std::vector<PAIR>(1, PAIR(i, j));\n\t\t\t}\n\t\t}\n\t\tif (pre == max && max == 0) break;\n\t\tif (max == 0) {\n\t\t\tpre = 0;\n\t\t\tc = o;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tpre = -1;\n\t\t}\n\t\tint pi, pj;\n\t\tint p = (c == 'o') ? 0 : v.size() - 1;\n\t\tpi = v[p].first;\n\t\tpj = v[p].second;\n\t\ta[pi][pj] = c;\n\t\tstd::vector<int> dd;\n\t\tREP(d, 8) {\n\t\t\tint k = 1;\n\t\t\twhile (true) {\n\t\t\t\tint dy = pi + dy8[d] * k;\n\t\t\t\tint dx = pj + dx8[d] * k;\n\t\t\t\tif (!IN(0, dy, n) || !IN(0, dx, n)) break;\n\t\t\t\tif (a[dy][dx] == o) {\n\t\t\t\t\t++k;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (a[dy][dx] == c) {\n\t\t\t\t\tif (k > 1) dd.emplace_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, dd.size()) {\n\t\t\tint d = dd[i];\n\t\t\tint k = 1;\n\t\t\twhile (true) {\n\t\t\t\tint dy = pi + dy8[d] * k;\n\t\t\t\tint dx = pj + dx8[d] * k;\n\t\t\t\tif (!IN(0, dy, n) || !IN(0, dx, n)) break;\n\t\t\t\tif (a[dy][dx] == o) {\n\t\t\t\t\t++k;\n\t\t\t\t\ta[dy][dx] = c;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = o;\n\t}\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tOUT(a[i][j]);\n\t\t}BR;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n#include <cctype>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <map>\n \nusing namespace std;\n\nstring s[8];\n\n// ue migiue migi migishita shita hidarishita hidari hidariue\nint dy[]={-1,-1,0,1,1,1,0,-1};\nint dx[]={0,1,1,1,0,-1,-1,-1};\n\nint cnt(int y,int x,char c){\n\n\tif( s[y][x]!='.' ) return 0;\n\n\tint res=0;\n\tfor(int k=0;k<8;k++){\n\t\tfor(int i=1;0<=y+dy[k]*i && y+dy[k]*i<8 && 0<=x+dx[k]*i && x+dx[k]*i<8;i++){\n\t\t\tif(s[y+dy[k]*i][x+dx[k]*i]==c){res+=i-1;break;}\n\t\t\telse if(s[y+dy[k]*i][x+dx[k]*i]=='.') break;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid update(int y,int x,char c){\n\t\n\ts[y][x]=c;\n\n\tfor(int k=0;k<8;k++){\n\t\tint pos=-1;\n\t\tfor(int i=1;0<=y+dy[k]*i && y+dy[k]*i<8 && 0<=x+dx[k]*i && x+dx[k]*i<8;i++){\n\t\t\tif(s[y+dy[k]*i][x+dx[k]*i]==c){pos=i;break;}\n\t\t\telse if(s[y+dy[k]*i][x+dx[k]*i]=='.') break;\n\t\t}\n\t\tfor(int i=1;i<pos;i++){\n\t\t\ts[y+dy[k]*i][x+dx[k]*i]=c;\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\n\tfor(int i=0;i<8;i++) cin>>s[i];\n\n\twhile(true){\n\t\tint change=0;\n\n\t\t//mami o ue hidari\n\t\tint add=0;\n\t\tint y,x;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tint tmp=cnt(i,j,'o');\n\t\t\t\tif(add<tmp){\n\t\t\t\t\tadd=tmp;\n\t\t\t\t\ty=i,x=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(add!=0){\n\t\t\tchange++;\n\t\t\tupdate(y,x,'o');\n\n\t\t\t//cout<<add<<endl;\n\t\t\t//for(int i=0;i<8;i++) cout<<s[i]<<endl;\n\n\t\t}\n\n\n\t\t//chokoreto x shita migi\n\t\tadd=0;\n\t\tfor(int i=7;i>=0;i--){\n\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\tint tmp=cnt(i,j,'x');\n\t\t\t\tif(add<tmp){\n\t\t\t\t\tadd=tmp;\n\t\t\t\t\ty=i,x=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(add!=0){\n\t\t\tchange++;\n\t\t\tupdate(y,x,'x');\n\n\t\t\t//cout<<add<<endl;\n\t\t\t//for(int i=0;i<8;i++) cout<<s[i]<<endl;\n\t\t}\t\t\n\n\t\tif(change==0) break;\n\t}\n\n\tfor(int i=0;i<8;i++) cout<<s[i]<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px) - 1, abs(y - py) - 1);\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px || qy != py) {\n\t\t\t\t\tc[qy][qx] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1 && t % 2 == 1) { x = j; y = i; r = p; }\n\t\t\t\t\telse if (p > r && p >= 1) { x = j; y = i; r = p; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) { v = 1; t++; continue; }\n\t\t\tbreak;\n\t\t}\n\t\telse { place(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0; }\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//55\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  char g[8][8];\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cin>>g[i][j];\n    }\n  }\n  for(;;){\n    bool f=false;\n    for(int i=0;i<2;i++){\n      const char *c=\"ox\";\n      int r[64]={};\n      char n[64][8][8];\n      for(int j=0;j<8;j++){\n\tfor(int k=0;k<8;k++){\n\t  int x=j*8+k;\n\t  copy(g[0],g[8],n[x][0]);\n\t  if(g[j][k]=='.'){\n\t    for(int l=0;l<8;l++){\n\t      char t[8][8];\n\t      copy(n[x][0],n[x+1][0],t[0]);\n\t      int dx[]={0,1,1,1,0,-1,-1,-1};\n\t      int dy[]={1,1,0,-1,-1,-1,0,1};\n\t      for(int m=1;;m++){\n\t\tint ny=j+dy[l]*m;\n\t\tint nx=k+dx[l]*m;\n\t\tif(nx<0||ny<0||8<=nx||8<=ny||t[ny][nx]=='.')break;\n\t\tif(t[ny][nx]==c[i]){\n\t\t  r[x]+=m-1;\n\t\t  copy(t[0],t[8],n[x][0]);\n\t\t  break;\n\t\t}else{\n\t\t  t[ny][nx]=c[i];\n\t\t}\n\t      }\n\t    }\n\t    if(r[x]){\n\t      n[x][j][k]=c[i];\n\t    }\n\t  }\n\t}\n      }\n      if(i){\n\treverse(r,r+64);\n      }\n      int m=max_element(r,r+64)-r;\n      f|=r[m];\n      if(i){\n\tm=63-m;\n      }\n      copy(n[m][0],n[m+1][0],g[0]);\n    }\n    if(!f)break;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<g[i][j];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <fstream>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> PI;\n#ifndef M_PI\nconst double M_PI=acos(-1.0);\n#endif\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int((a).size()))\n#define F first\n#define S second\nvoid pkuassert(bool b){if(!b){int a=0;cout << 1/a << endl;}};\nint dx[]={0,-1,0,1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\n\nstring in[8];\n\nint cnt(int x,int y,char a,bool fi=false){\n  int ret=0;\n  for(int i=-1;i<=1;++i)\n    for(int j=-1;j<=1;++j){\n      if((i|j)==0) continue;\n      int cx=x+i,cy=y+j;\n      int cnt=0;\n      while(true){\n        if(min(cx,cy)<0 || max(cx,cy)>=8) break;\n        if(in[cx][cy]==a){\n          if(fi){\n            while(true){\n              cx-=i;\n              cy-=j;\n              in[cx][cy]=a;\n              if(cx==x && cy==y) break;\n            }\n          }\n          ret += cnt;\n          break;\n        }\n        if(in[cx][cy]=='.') break;\n        cx+=i;\n        cy+=j;\n        ++cnt;\n      }\n    }\n\n  return ret;\n}\n\nint main(){\n  rep(i,8) cin >> in[i];\n\n  while(true){\n    bool end=true;\n\n    PI pos=mp(-1,-1);\n    int maxv=0;\n    rep(i,8)rep(j,8){\n      if(in[i][j]!='.') continue;\n      int tv=cnt(i,j,'o');\n      if(tv>maxv){\n        pos=mp(i,j);\n        maxv=tv;\n      }\n    }\n\n    if(maxv){\n      cnt(pos.F,pos.S,'o',true);\n      in[pos.F][pos.S]='o';\n      end=false;\n    }\n\n    \n    pos=mp(-1,-1);\n    maxv=0;    \n    \n    rep(i,8)rep(j,8){\n      if(in[i][j]!='.') continue;      \n      int tv=cnt(i,j,'x');\n      if(tv>=maxv){\n        pos=mp(i,j);\n        maxv=tv;\n      }\n    }\n\n    if(maxv){\n      cnt(pos.F,pos.S,'x',true);\n      in[pos.F][pos.S]='x';\n      end=false;\n    }    \n\n    //rep(i,8) cout << in[i] << endl;\n    if(end) break;\n  }\n\n  rep(i,8) cout << in[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\nstring q = \"ox\";\nint dx[8] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dy[8] = {1, -1, 1, 0, -1, 1, 0, -1};\n\nvector<string> rev(vector<string> s, int turn, int y, int x){\n  char c = q[(turn+1)%2];\n  s[y][x] = q[turn%2];\n  int cnt = 0;\n  for(int dir=0; dir<8; dir++){\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) continue;\n    if( s[ny][nx] == '.' ) continue;\n    bool f = false;\n    while( s[ny][nx] == c ){\n      cnt++;\n      // s[ny][nx] = q[turn%2];\n      ny += dy[dir];\n      nx += dx[dir];\n\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) break;\n      if( s[ny][nx] == q[turn%2] ){\n        f = true;\n        break;\n      }\n      if( s[ny][nx] == '.' ) break;\n    }\n    while( f ){\n      if( ny == y && nx == x ) break;\n      s[ny][nx] = q[turn%2];\n      ny -= dy[dir];\n      nx -= dx[dir];\n    }\n  }\n  return s;\n}\n\n\nint calc(vector<string> s, int turn, int y, int x){\n  char c = 'x';\n  if( turn % 2 == 1 ) c = 'o';\n  int cnt = 0;\n  for(int dir=0; dir<8; dir++){\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) continue;\n    int tmp = 0;\n    bool f = false;\n    while( s[ny][nx] == c ){\n      tmp++;\n      ny += dy[dir];\n      nx += dx[dir];\n\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) break;\n      if( s[ny][nx] == q[turn%2] ){\n        f = true;\n        break;\n      }\n    }\n    cnt += tmp * f;\n  }\n  return cnt;\n}\n\nvector<string> func(vector<string> s, int turn){\n  int a = -1;\n  int rx = -1, ry = -1;\n  for(int i=0; i<8; i++){\n    for(int j=0; j<8; j++){\n      int x = j, y = i;\n      if( turn % 2 == 1 ) x = 7 - j;\n      if( turn % 2 == 1 ) y = 7 - i;\n      if( s[y][x] != '.' ) continue;\n\n      int r = calc(s, turn, y, x);\n      if( a < r ){\n        a = r;\n        rx = x;\n        ry = y;\n      }\n    }\n  }\n  // cerr << a << \" \" << rx << \" \" << ry << endl;\n  if( a <= 0 ) return s;\n  return rev(s, turn, ry, rx);\n}\n\nint main(void) {\n\n  vector<string> s(8);\n  for(int i=0; i<8; i++) cin >> s[i];\n  int q = 0;\n  int turn = 0;\n  while( true ){\n    vector<string> t = func(s, turn);\n    turn++;\n    if( s == t ) q++;\n    s = t;\n    if( q > 3 ) break;\n    // for(int i=0; i<8; i++) cerr << s[i] << endl;\n    // cerr << endl;\n  }\n\n  for(int i=0; i<8; i++){\n    cout << s[i] << endl;\n  }\n\n  return 0;\n}\n\n\n// EOF"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/03 05:33:41\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    vector<vector<int>> state(8, vector<int>(8, 0));\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            char c;\n            cin >> c, state[i][j] = c == '.' ? -1 : c == 'o' ? 1 : 0;\n        }\n    }\n    auto next = [](vector<vector<int>>& state, const int turn) {\n        int maxi = 0;\n        vector<vector<int>> next_state;\n        for (int ii = 0; ii < 8; ii++) {\n            for (int jj = 0; jj < 8; jj++) {\n                const int i = turn == 1 ? ii : 7 - ii;\n                const int j = turn == 1 ? jj : 7 - jj;\n                if (state[i][j] != -1) { continue; }\n                auto prev = state;\n                state[i][j] = turn;\n                int u = 1, d = 1, l = 1, r = 1, ul = 1, ur = 1, dl = 1, dr = 1;\n                for (; i - u >= 0 and state[i - u][j] == 1 - turn; u++) {}\n                if (i - u < 0 or state[i - u][j] == -1) { u = 1; }\n                u--;\n                for (int k = 1; k <= u; k++) { state[i - k][j] = turn; }\n\n                for (; i + d < 8 and state[i + d][j] == 1 - turn; d++) {}\n                if (i + d >= 8 or state[i + d][j] == -1) { d = 1; }\n                d--;\n                for (int k = 1; k <= d; k++) { state[i + k][j] = turn; }\n\n                for (; j - l >= 0 and state[i][j - l] == 1 - turn; l++) {}\n                if (j - l < 0 or state[i][j - l] == -1) { l = 1; }\n                l--;\n                for (int k = 1; k <= l; k++) { state[i][j - k] = turn; }\n\n                for (; j + r < 8 and state[i][j + r] == 1 - turn; r++) {}\n                if (j + r >= 8 or state[i][j + r] == -1) { r = 1; }\n                r--;\n                for (int k = 1; k <= r; k++) { state[i][j + k] = turn; }\n\n                for (; i - ul >= 0 and j - ul >= 0 and state[i - ul][j - ul] == 1 - turn; ul++) {}\n                if (i - ul < 0 or j - ul < 0 or state[i - ul][j - ul] == -1) { ul = 1; }\n                ul--;\n                for (int k = 1; k <= ul; k++) { state[i - k][j - k] = turn; }\n\n                for (; i - ur >= 0 and j + ur < 8 and state[i - ur][j + ur] == 1 - turn; ur++) {}\n                if (i - ur < 0 or j + ur >= 8 or state[i - ur][j + ur] == -1) { ur = 1; }\n                ur--;\n                for (int k = 1; k <= ur; k++) { state[i - k][j + k] = turn; }\n\n                for (; i + dl < 8 and j - dl >= 0 and state[i + dl][j - dl] == 1 - turn; dl++) {}\n                if (i + dl >= 8 or j - dl < 0 or state[i + dl][j - dl] == -1) { dl = 1; }\n                dl--;\n                for (int k = 1; k <= dl; k++) { state[i + k][j - k] = turn; }\n\n                for (; i + dr < 8 and j + dr < 8 and state[i + dr][j + dr] == 1 - turn; dr++) {}\n                if (i + dr >= 8 or j + dr >= 8 or state[i + dr][j + dr] == -1) { dr = 1; }\n                dr--;\n                for (int k = 1; k <= dr; k++) { state[i + k][j + k] = turn; }\n\n                const int sum = u + d + l + r + ul + ur + dl + dr;\n                if (maxi < sum) { maxi = sum, next_state = state; }\n                state = prev;\n            }\n        }\n        if (maxi == 0) {\n            return state;\n        } else {\n            return next_state;\n        }\n    };\n    auto print = [&]() {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                cout << (state[i][j] == -1 ? '.' : state[i][j] == 0 ? 'x' : 'o');\n            }\n            cout << endl;\n        }\n    };\n    bool passed = false;\n    for (int turn = 1;; turn = 1 - turn) {\n        auto prev = state;\n        state = next(state, turn);\n        //print();\n        if (prev == state) {\n            if (passed) { break; }\n            passed = true;\n        } else {\n            passed = false;\n        }\n    }\n    print();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid rotate(vector<string>& s) {\n\tvector<string> t = s;\n\tfor (int i = 0; i < 8; i++)\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tif (t[7 - i][7 - j] == 'o') s[i][j] = 'x';\n\t\t\telse if (t[7 - i][7 - j] == 'x') s[i][j] = 'o';\n\t\t\telse s[i][j] = '.';\n}\n\nint foo(vector<string>& s, int i, int j, int di, int dj) {\n\tif (i < 0 || i >= 8 || j < 0 || j >= 8 || s[i][j] == '.') return -1;\n\telse if (s[i][j] == 'o') return 0;\n\telse {\n\t\tint x = foo(s, i + di, j + dj, di, dj);\n\t\treturn x == -1 ? -1 : x + 1;\n\t}\n}\n\nint bar(vector<string>& s, int i, int j, int di, int dj) {\n\tif (i < 0 || i >= 8 || j < 0 || j >= 8 || s[i][j] == '.') return -1;\n\telse if (s[i][j] == 'o') return 0;\n\telse {\n\t\tint x = bar(s, i + di, j + dj, di, dj);\n\t\tif (x == -1) return -1;\n\t\telse {\n\t\t\ts[i][j] = 'o';\n\t\t\treturn x + 1;\n\t\t}\n\t}\n}\n\nint main() {\n\tvector<string> s(8);\n\tfor (int i = 0; i < 8; i++) cin >> s[i];\n\tbool flag = true;\n\tint t;\n\tfor (t = 0; ; t++) {\n\t\tint _i, _j, maxi = 0;\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (s[i][j] != '.') continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int di = -1; di <= 1; di++)\n\t\t\t\t\tfor (int dj = -1; dj <= 1; dj++)\n\t\t\t\t\t\tif (di || dj)\n\t\t\t\t\t\t\tsum += max(0, foo(s, i + di, j + dj, di, dj));\n\t\t\t\tif (sum > maxi) {\n\t\t\t\t\t_i = i; _j = j; maxi = sum;\n\t\t\t\t}\n\t\t\t}\n\t\tif (maxi > 0) {\n\t\t\ts[_i][_j] = 'o';\n\t\t\tfor (int di = -1; di <= 1; di++)\n\t\t\t\tfor (int dj = -1; dj <= 1; dj++)\n\t\t\t\t\tif (di || dj)\n\t\t\t\t\t\tbar(s, _i + di, _j + dj, di, dj);\n\t\t}\n\t\telse if (flag) flag = false;\n\t\telse break;\n\t\trotate(s);\n\t}\n\tif (t % 2 == 1) rotate(s);\n\tfor (int i = 0; i < 8; i++)\n\t\tcout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint dx[8] = {1,1,0,-1,-1,-1,0,1};\nint dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint main(){\n    int turn=0;\n    int b[10][10];\n    char c;\n    memset(b, -1, sizeof(b));\n    for(int i=0;i<8;i++){\n        for(int j=0;j<8;j++){\n            cin >> c;\n            if(c == 'o'){\n                b[i+1][j+1] = 0;\n            }else if(c == 'x'){\n                b[i+1][j+1] = 1;\n            }\n        }\n    }\n\n    int cx,cy;\n    int px,py;\n    int prevnum=1,num,_num,tmp;\n    vector<int> dir,tmpdir;\n    while(1){\n        dir.clear();\n        num = 0;\n        for(int i=1;i<=8;i++){\n            for(int j=1;j<=8;j++){\n                _num = 0;\n                if(!turn){\n                    cx = j;\n                    cy = i;\n                }else{\n                    cx = 9-j;\n                    cy = 9-i;\n                }\n                if(b[cy][cx] == -1){\n                    //foreach direction\n                    for(int k=0;k<8;k++){\n                        tmp=1;\n                        if(b[cy+dy[k]][cx+dx[k]] == turn ||\n                           b[cy+dy[k]][cx+dx[k]] == -1){\n                            //隣が空もしくは同色ならcontinue\n                            continue;\n                        }\n                        while(b[cy+dy[k]*tmp][cx+dx[k]*tmp] == 1-turn){\n                            tmp++;\n                        }\n                        if(b[cy+dy[k]*tmp][cx+dx[k]*tmp] == turn){\n                            _num += tmp-1;\n                            tmpdir.push_back(k);\n                        }\n                    }\n                }\n                if(num < _num){\n                    num = _num;\n                    px = cx;\n                    py = cy;\n                    dir = tmpdir;\n                }\n                tmpdir.clear();\n            }\n        }\n\n        //置く\n        if(dir.size()) b[py][px] = turn;\n        for(int i=0;i<dir.size();i++){\n            tmp = 1;\n            while(b[py+dy[dir[i]]*tmp][px+dx[dir[i]]*tmp] != turn){\n                b[py+dy[dir[i]]*tmp][px+dx[dir[i]]*tmp] = turn;\n                tmp++;\n            }\n        }\n        if(!prevnum && !num) break;        \n        prevnum = num;\n        turn = 1 - turn;\n    }\n    for(int i=1;i<=8;i++){\n        for(int j=1;j<=8;j++){\n            if(b[i][j] == 0){\n                cout << 'o';\n            }else if(b[i][j] == 1){\n                cout << 'x';\n            }else{\n                cout << '.';\n            }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\nusing pii = pair<int, int>;\n\nconst int N = 8;\nchar mark[2] = {'o', 'x'};\n\nbool inrange(int x, int y) {\n    return 0 <= x && x < N && 0 <= y && y < N;\n}\n\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\npii select(vector<string> &board, int turn) {\n    char opp = mark[turn ^ 1];\n\n    pii ret = {-1, -1};\n    int mx = 0;\n    rep(y, 0, N) {\n        rep(x, 0, N) {\n            int i = 0, j = 0;\n            if (turn) {\n                i = N - 1 - y;\n                j = N - 1 - x;\n            } else {\n                i = y;\n                j = x;\n            }\n            if (board[i][j] != '.') continue;\n\n            int sum = 0;\n            rep(dir, 0, 8) {\n                pii tmp = {-1, -1};\n                int cnt = 0;\n                rep(k, 1, 9) {\n                    int ii = i + dy[dir] * k;\n                    int jj = j + dx[dir] * k;\n                    if (!inrange(jj, ii)) break;\n                    if (board[ii][jj] == opp) {\n                        cnt++;\n                        continue;\n                    }\n                    if(board[ii][jj]=='.'){\n                        break;\n                    }\n                    tmp = {ii, jj};\n                    break;\n                }\n                if (tmp.first != -1) {\n                    sum += cnt;\n                }\n            }\n\n            if (sum != 0) {\n                // cerr<<\"sum: \"<<sum<<\", \"<<\"j: \"<<j<<\", i:\"<<i<<endl;\n                if (mx < sum) {\n                    mx = sum;\n                    ret = {i, j};\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid update(vector<string> &board, int turn, pii pos) {\n    char opp = mark[turn ^ 1];\n    int y, x;\n    tie(y, x) = pos;\n    rep(dir, 0, 8) {\n        int cnt = 0;\n        rep(k, 1, 9) {\n            int yy = y + dy[dir] * k;\n            int xx = x + dx[dir] * k;\n            if (!inrange(xx, yy)) break;\n            if (board[yy][xx] == opp) {\n                continue;\n            }\n            if(board[yy][xx]=='.'){\n                break;\n            }\n            cnt = k;\n            break;\n        }\n        rep(k, 0, cnt) {\n            int yy = y + dy[dir] * k;\n            int xx = x + dx[dir] * k;\n            board[yy][xx] = mark[turn];\n        }\n    }\n}\n\nsigned main() {\n    vector<string> board(N);\n    rep(i, 0, N) cin >> board[i];\n\n    int turn = 0;\n    bool skipped = false;\n    // int loop=3;\n    while (1) {\n        pii pos = select(board, turn);\n        // cerr << pos.first << \", \" << pos.second << endl;\n        if (pos.first == -1) {\n            if (skipped) {\n                break;\n            }\n            skipped = true;\n            turn ^= 1;\n            continue;\n        }\n        skipped = false;\n\n        // 更新\n        update(board, turn, pos);\n        turn ^= 1;\n\n        // rep(i, 0, N) {\n        //     cerr << board[i] << endl;\n        // }\n        // cerr << endl;\n    }\n\n    rep(i, 0, N) {\n        cout << board[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n#define FOR(i,a,b) for (int i=(a),for_##i##_max=(b);i<=(for_##i##_max);++i)\n#define RFOR(i,a,b) for (int i=(a),rfor_##i##_min=(b);i>=(rfor_##i##_min);--i)\n#define REP(i,n) for (int i=0,rep_##i##_len=(n);i<(rep_##i##_len);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nnamespace { // Basics\n\ntemplate<typename T>\nvoid chmin(T &x, T y) {\n  x = std::min(x, y);\n}\n\ntemplate<typename T>\nvoid chmax(T &x, T y) {\n  x = std::max(x, y);\n}\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto minimum = static_cast<T const &(*)(T const &, T const &)>(std::min);\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto maximum = static_cast<T const &(*)(T const &, T const &)>(std::max);\n\ntemplate<typename T>\n__attribute__((unused))\nT constexpr infty = std::numeric_limits<T>::max / 3;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<int> = 1'100'100'100;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<long long int> = 100'500'400'300'200'100LL;\n\nusing lli = long long int;\nusing ld = long double;\n\n} // namespace\n\nconstexpr int dx[8] = {0, 1,  0, -1, 1,  1, -1, -1};\nconstexpr int dy[8] = {1, 0, -1,  0, 1, -1, -1,  1};\n\nnamespace { // stringify\n\ntemplate<typename T>\n__attribute__((unused))\nvoid stringify_helper(std::ostringstream &oss, T const &x) {\n  oss << std::to_string(x);\n}\n\ntemplate<>\n__attribute__((unused))\nvoid stringify_helper(std::ostringstream &oss, std::string const &s) {\n  oss << \"\\\"\" << s << \"\\\"\";\n}\n\ntemplate<typename T, typename U>\n__attribute__((unused))\nvoid stringify_helper(std::ostringstream &oss, std::pair<T, U> const &p) {\n  oss << \"(\";\n  stringify_helper(oss, p.first);\n  oss << \", \";\n  stringify_helper(oss, p.second);\n  oss << \")\";\n}\n\ntemplate<template<typename... Args> class Temp, typename... Args>\n__attribute__((unused))\nvoid stringify_helper(std::ostringstream &oss, Temp<Args...> const &v) {\n  bool b = false;\n  oss << \"{\";\n  for (auto &&x : v) {\n    if (b) { oss << \", \"; }\n    stringify_helper(oss, x);\n    b = true;\n  }\n  oss << \"}\";\n}\n\ntemplate<typename Head, typename... Tail>\n__attribute__((unused))\nstd::string stringify(Head const &head, Tail const &...tail) {\n  std::ostringstream oss;\n  if (sizeof...(tail) > 0) { oss << \"[\"; }\n  stringify_helper(oss, head);\n  int const arr[] = { (oss << \", \", stringify_helper(oss, tail), 0)... };\n  (void)arr;\n  if (sizeof...(tail) > 0) { oss << \"]\"; }\n  return oss.str();\n}\n\n} // namespace\n\nusing namespace std;\n\nusing Board = vector<string>;\nint constexpr size = 8;\n\nbool is_inboard(int i, int j) {\n  return 0 <= i && i < size && 0 <= j && j < size;\n}\n\nbool avaiable(Board const &board, int i, int j, char me, char she) {\n  REP(dir, 8) {\n    int cookie_cnt = 0;\n    int x = i + dx[dir], y = j + dy[dir];\n    while (is_inboard(x, y) && board[x][y] == she) {\n      x += dx[dir], y += dy[dir];\n      ++cookie_cnt;\n    }\n    if (is_inboard(x, y) && board[x][y] == me && cookie_cnt > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntuple<int, Board> make_move(Board const &init, int i, int j, char me, char she) {\n  Board board = init;\n  board[i][j] = me;\n  int cnt = 1;\n  REP(dir, 8) {\n    int x = i + dx[dir], y = j + dy[dir];\n    while (is_inboard(x, y) && board[x][y] == she) {\n      x += dx[dir], y += dy[dir];\n    }\n    if (!is_inboard(x, y) || board[x][y] != me) { continue; }\n    for (x -= dx[dir], y -= dy[dir]; board[x][y] == she; x -= dx[dir], y -= dy[dir]) {\n      board[x][y] = me;\n      ++cnt;\n    }\n  }\n  return make_tuple(cnt, board);\n}\n\nvector<tuple<int, int, int, Board>>\navailable_moves(Board const &board, char me, char she) {\n  vector<tuple<int,int,int,Board>> ret= { make_tuple(-1, -1, -1, board) };\n  REP(i, size) REP(j, size) {\n    if (board[i][j] == '.' && avaiable(board, i, j, me, she)) {\n      Board result; int cnt;\n      tie(cnt, result) = make_move(board, i, j, me, she);\n      ret.emplace_back(cnt, i, j, result);\n    }\n  }\n  return ret;\n}\n\nvoid solve(Board const &init) {\n  char me = 'o', she = 'x';\n  Board board = init;\n  for (int num = 0; num < 64; ++num, swap(me, she)) {\n    auto avm = available_moves(board, me, she);\n    sort(avm.begin(), avm.end(),\n        [me](auto t1, auto t2) {\n          if (get<0>(t1) != get<0>(t2)) {\n            return get<0>(t1) > get<0>(t2);\n          }\n          if (me == 'o') {\n            return make_pair(get<1>(t1), get<2>(t1)) < make_pair(get<1>(t2), get<2>(t2));\n          } else {\n            return make_pair(get<1>(t1), get<2>(t1)) > make_pair(get<1>(t2), get<2>(t2));\n          }\n        });\n    board = get<3>(avm[0]);\n\n    /*\n    cerr << num << \":\\n\";\n    for (auto &&row : board) {\n      cerr << row << \"\\n\";\n    }\n    cerr << \"\\n\";\n    */\n  }\n  for (auto &&row : board) {\n    cout << row << \"\\n\";\n  }\n}\n\nint main() {\n  // cout << fixed << setprecision(10);\n\n  Board board;\n  REP(i, 8) {\n    string row; cin >> row;\n    board.push_back(row);\n  }\n  solve(board);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nint main() {\n  vector<string> s(8);\n  for (auto& e : s) {\n    cin >> e;\n  }\n  string piece = \"ox\";\n  for (int turn = false, passed = 0; passed < 2; turn ^= true) {\n    vector<pair<int, int>> v{{-1, -1}};\n    for (int i = 0; i < 8; i++) {\n      for (int j = 0; j < 8; j++) {\n        if (s[i][j] == '.') {\n          vector<pair<int, int>> u{{i, j}};\n          for (int k = 0; k < 8; k++) {\n            vector<pair<int, int>> line;\n            for (int l = 1;; l++) {\n              int y = i + l * dy[k], x = j + l * dx[k];\n              if (0 <= y && y < 8 && 0 <= x && x < 8 && s[y][x] != '.') {\n                line.push_back({y, x});\n              } else {\n                break;\n              }\n            }\n            auto e = find_if(begin(line), end(line), [&](auto x) { return s[x.first][x.second] == piece[turn]; });\n            if (e != end(line)) {\n              for (auto it = begin(line); it != e; it++) {\n                u.push_back(*it);\n              }\n            }\n          }\n          if (!turn && u.size() > v.size() || turn && u.size() >= v.size()) {\n            v = u;\n          }\n        }\n      }\n    }\n    if (v.size() > 1) {\n      for (auto e : v) {\n        s[e.first][e.second] = piece[turn];\n      }\n      passed = 0;\n    } else {\n      passed++;\n    }\n  }\n  for (auto e : s) {\n    cout << e << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint now_grid[8][8] = {};\nint simulation[8][8] = {};\n\nint calc(pair<int, int> now,int coloring) {\n\tREP(i, 8) {\n\t\tREP(q, 8) {\n\t\t\tsimulation[i][q] = now_grid[i][q];\n \t\t}\n\t}\n\tint dx[3] = { 1,0,-1 };\n\t\n\tsimulation[now.first][now.second] = coloring;\n\tint ans = 0;\n\tREP(i, 3) {\n\t\tREP(q, 3) {\n\t\t\tfor (int t = 1; t < 9;++t) {\n\t\t\t\tint x = now.first + dx[i] * t;\n\t\t\t\tint y = now.second + dx[q] * t;\n\t\t\t\tif (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\t\t\t\tif (simulation[x][y] != simulation[now.first][now.second]) {\n\t\t\t\t\t\tif (simulation[x][y] == -1) break;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int t = 1; t < 9; ++t) {\n\t\t\t\t\t\t\tint x = now.first + dx[i] * t;\n\t\t\t\t\t\t\tint y = now.second + dx[q] * t;\n\t\t\t\t\t\t\tif (simulation[x][y] == simulation[now.first][now.second]) break;\n\t\t\t\t\t\t\tsimulation[x][y] = simulation[now.first][now.second];\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\tREP(i, 8) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(q, s.length()) {\n\t\t\tif (s[q] == 'o') {\n\t\t\t\tnow_grid[i][q] = 0;\n\t\t\t}\n\t\t\telse if (s[q] == 'x') {\n\t\t\t\tnow_grid[i][q] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow_grid[i][q] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint cnter = 0;\n\tfor (int i = 0;cnter != 2; ++i) {\n\t\ttuple<int, int, int> now = make_tuple(0, -1, -1);\n\t\tint color = i % 2;\n\t\tREP(i, 8) {\n\t\t\tREP(q, 8) {\n\t\t\t\tint x = i;\n\t\t\t\tint y = q;\n\t\t\t\tif (color == 1) {\n\t\t\t\t\tx = 7 - i;\n\t\t\t\t\ty = 7 - q;\n\t\t\t\t}\n\t\t\t\tif (now_grid[x][y] == -1) {\n\t\t\t\t\tif (get<0>(now) < calc(mp(x, y), color)) {\n\t\t\t\t\t\tnow = make_tuple(calc(mp(x, y), color), x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (get<0>(now) == 0) {\n\t\t\tcnter++;\n\t\t\tcontinue;\n\t\t}\n\t\tcnter = 0;\n\t\tcalc(mp(get<1>(now), get<2>(now)), color);\n\t\tREP(i, 8) {\n\t\t\tREP(q, 8) {\n\t\t\t\tnow_grid[i][q] = simulation[i][q];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 8) {\n\t\tREP(q, 8) {\n\t\t\tif (now_grid[i][q] == 0) {\n\t\t\t\tcout << 'o';\n\t\t\t}\n\t\t\telse if(now_grid[i][q] == 1){\n\t\t\t\tcout << 'x';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << '.';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\nchar board[10][10];\nint d1[8] = { -1,-1,-1,0,0,1,1,1 };\nint d2[8] = { -1,0,1,-1,1,-1,0,1 };\nchar inv(char a) {\n\tif (a == 'o')return 'x';\n\telse return 'o';\n}\nint count(P x,char a) {\n\tint res = 0;\n\trep(i, 8) {\n\t\tint cnt = 1;\n\t\twhile (board[x.first + cnt * d1[i]][x.second + cnt * d2[i]]==inv(a)) {\n\t\t\tcnt++;\n\t\t}\n\t\tif (board[x.first + cnt * d1[i]][x.second + cnt * d2[i]]==a) {\n\t\t\tres += cnt - 1;\n\t\t}\n\t}\n\treturn res;\n}\nvoid paint(P x, char a) {\n\trep(i, 8) {\n\t\tint cnt = 1;\n\t\twhile (board[x.first + cnt * d1[i]][x.second + cnt * d2[i]] == inv(a)) {\n\t\t\tcnt++;\n\t\t}\n\t\tif (board[x.first + cnt * d1[i]][x.second + cnt * d2[i]] == a) {\n\t\t\trep(j, cnt) {\n\t\t\t\tboard[x.first + j * d1[i]][x.second + j * d2[i]] = a;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid nex(char a) {\n\tint ma = 0; P chk;\n\trep1(i, 8) {\n\t\trep1(j, 8) {\n\t\t\tif (board[i][j] == '.') {\n\t\t\t\tint r = count({ i,j }, a);\n\t\t\t\tif (a=='o'&&ma < r) {\n\t\t\t\t\tma = r; chk = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (a == 'x'&&ma <= r) {\n\t\t\t\t\tma = r; chk = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ma == 0)return;\n\tpaint(chk, a);\n}\nint main() {\n\trep(i, 10) {\n\t\trep(j, 10) {\n\t\t\tboard[i][j] = '.';\n\t\t}\n\t}\n\tstring s;\n\trep1(i, 8) {\n\t\tcin >> s;\n\t\trep1(j, 8) {\n\t\t\tboard[i][j] = s[j - 1];\n\t\t}\n\t}\n\tchar t = 'o';\n\trep(k, 64) {\n\t\tnex(t); t = inv(t);\n\t}\n\trep1(i, 8) {\n\t\trep1(j, 8) {\n\t\t\tcout << board[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar t[8][8];\n\nint func(int y,int x,char ch){\n  int res=0;\n  int cnt=0;\n  for(int Y=y+1;;Y++){\n    if(Y>=8)break;\n    if(t[Y][x]==ch){ res+=cnt;   break; }\n    if(t[Y][x]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int Y=y-1;;Y--){\n    if(Y<0)break;\n    if(t[Y][x]==ch){ res+=cnt;   break; }\n    if(t[Y][x]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n for(int X=x+1;;X++){\n    if(X>=8)break;\n    if(t[y][X]==ch){ res+=cnt;   break; }\n    if(t[y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x-1;;X--){\n    if(X<0)break;\n    if(t[y][X]==ch){ res+=cnt;   break; }\n    if(t[y][X]=='.')break;\n    cnt++;\n  }\n\n\n  cnt=0;\n  for(int X=x+1,Y=y+1;;X++,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x+1,Y=y-1;;X++,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n\n\n  cnt=0;\n  for(int X=x-1,Y=y+1;;X--,Y++){\n    if(X<0||Y>=8)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x-1,Y=y-1;;X--,Y--){\n    if(X<0||Y<0)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n\n  return res;\n}\n\nvoid func2(int y,int x,char ch){\n  int flg=0;\n  for(int Y=y+1;;Y++){\n    if(Y>=8)break;\n    if(t[Y][x]==ch){flg=1;break; }\n    if(t[Y][x]=='.')break;\n  }\n  if(flg){\n    for(int Y=y+1;;Y++){\n      if(Y>=8)break;\n      if(t[Y][x]==ch)break; \n      if(t[Y][x]=='.')break;\n      t[Y][x]=ch;\n    }\n  }\n\n  flg=0;\n  for(int Y=y-1;;Y--){\n    if(Y<0)break;\n    if(t[Y][x]==ch){flg=1;break; }\n    if(t[Y][x]=='.')break;\n  }\n  if(flg){\n    for(int Y=y-1;;Y--){\n      if(Y<0)break;\n      if(t[Y][x]==ch)break; \n      if(t[Y][x]=='.')break;\n      t[Y][x]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x+1;;X++){\n    if(X>=8)break;\n    if(t[y][X]==ch){flg=1;break;}\n    if(t[y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x+1;;X++){\n      if(X>=8)break;\n      if(t[y][X]==ch)break;\n      if(t[y][X]=='.')break;\n      t[y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x-1;;X--){\n    if(X<0)break;\n    if(t[y][X]==ch){flg=1;break; }\n    if(t[y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1;;X--){\n      if(X<0)break;\n      if(t[y][X]==ch)break;\n      if(t[y][X]=='.')break;\n      t[y][X]=ch;\n    }\n  }\n\n\n  flg=0;\n  for(int X=x+1,Y=y+1;;X++,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x+1,Y=y+1;;X++,Y++){\n      if(X>=8||Y>=8)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x+1,Y=y-1;;X++,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){  \n    for(int X=x+1,Y=y-1;;X++,Y--){\n      if(X>=8||Y<0)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n\n  flg=0;\n  for(int X=x-1,Y=y+1;;X--,Y++){\n    if(X<0||Y>=8)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1,Y=y+1;;X--,Y++){\n      if(X<0||Y>=8)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x-1,Y=y-1;;X--,Y--){\n    if(X<0||Y<0)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1,Y=y-1;;X--,Y--){\n      if(X<0||Y<0)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n}\n\nint main(){\n  for(int i=0;i<8;i++)\n    for(int j=0;j<8;j++)\n      cin>>t[i][j];\n\n  int cnt=0;\n  for(int i=0;;i++){\n    \n    char ch=(i%2?'x':'o');\n    \n\n    int ay,ax,maxm=0;\n    if(ch=='o'){\n      for(int j=0;j<8;j++){\n\tfor(int k=0;k<8;k++){\n\t  if(t[j][k]!='.')continue;\n\t  int x=func(j,k,ch);\n\t\n\t  if(x>maxm){\n\t    maxm=x;\n\t    ay=j;\n\t    ax=k;\n\t  }\n\t}\n      }\n    }else{\n      for(int j=7;j>=0;j--){\n\tfor(int k=7;k>=0;k--){\n\t  if(t[j][k]!='.')continue;\n\t  int x=func(j,k,ch);\n\t\n\t  if(x>maxm){\n\t    maxm=x;\n\t    ay=j;\n\t    ax=k;\n\t  }\n\t}\n      }\n\n    }\n\n    if(maxm==0){\n      cnt++;\n      if(cnt==2)break;\n      continue;\n    }else cnt=0;\n\n    // cout<<ay<<' '<<ax<<endl;\n\n    t[ay][ax]=ch;\n    func2(ay,ax,ch);\n    \n  }//i\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++)cout<<t[i][j];\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nchar s[10][10];\n\nint calc(int y, int x, char c) {\n    char c2 = \"ox\"[c == 'o'];\n    int res = 0;\n    for (int i = 0; i < 8; ++i) {\n        int ty = y + dy[i];\n        int tx = x + dx[i];\n        if (s[ty][tx] != c2) continue;\n\n        int pt = 0;\n        while (s[ty][tx] == c2) {\n            pt++;\n            ty += dy[i];\n            tx += dx[i];\n        }\n        if (s[ty][tx] != c) continue;\n        res += pt;\n    }\n    return res;\n}\n\nvoid place(int y, int x, char c) {\n    s[y][x] = c;\n\n    char c2 = \"ox\"[c == 'o'];\n    for (int i = 0; i < 8; ++i) {\n        int ty = y + dy[i];\n        int tx = x + dx[i];\n        if (s[ty][tx] != c2) continue;\n\n        while (s[ty][tx] == c2) {\n            ty += dy[i];\n            tx += dx[i];\n        }\n        if (s[ty][tx] != c) continue;\n\n        do {\n            s[ty][tx] = c;\n            ty -= dy[i];\n            tx -= dx[i];\n        } while (s[ty][tx] == c2);\n    }\n}\n\nint main() {\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            s[i][j] = '#';\n            if (0 < i && i < 9 && 0 < j && j < 9) { cin >> s[i][j]; }\n        }\n    }\n\n    while (1) {\n        bool end = true;\n        for (char ck : \"ox\") {\n            int maxpt = 0, y, x;\n            for (int i = 1; i < 9; ++i) {\n                for (int j = 1; j < 9; ++j) {\n                    if (s[i][j] != '.') continue;\n                    int pt = calc(i, j, ck);\n                    if ((ck == 'o' && maxpt < pt) || (ck == 'x' && maxpt <= pt)) {\n                        maxpt = pt;\n                        y = i;\n                        x = j;\n                    }\n                }\n            }\n            if (0 < maxpt) {\n                place(y, x, ck);\n                end = false;\n            }\n        }\n        if (end) break;\n    }\n\n    for (int i = 1; i < 9; ++i) {\n        for (int j = 1; j < 9; ++j) { cout << s[i][j]; }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int n = 8;\nint a[n][n];\n\nbool isin(int i, int j){\n\treturn i >= 0 && j >= 0 && i < n && j < n;\n}\n\nint put(int i, int j, int x, VVI &d){\n\tif (a[i][j] > 0) return 0;\n\tint y;\n\tif (x == 1) y = 2;\n\telse y = 1;\n\tint dx[] = {1,1,1,0,0,-1,-1,-1}, dy[] = {1,0,-1,1,-1,1,0,-1};\n\tint res = 1;\n\td[i][j] = 1;\n\tREP(k,8){\n\t\tint ii = i + dx[k], jj = j + dy[k];\n\t\twhile (isin(ii,jj) && a[ii][jj] == y){\n\t\t\tii += dx[k];\n\t\t\tjj += dy[k];\n\t\t}\n\t\tif (isin(ii,jj) && a[ii][jj] == x){\n\t\t\tfor (int iii = i + dx[k], jjj = j + dy[k]; iii != ii || jjj != jj; iii += dx[k], jjj += dy[k]){\n\t\t\t\td[iii][jjj] = 1;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tREP(i,n){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,n){\n\t\t\tif (s[j] == 'o') a[i][j] = 1;\n\t\t\tif (s[j] == 'x') a[i][j] = 2;\n\t\t}\n\t}\n\tbool p1 = false, p2 = false;\n\tint turn = 1;\n\twhile (!p1 || !p2){\n\t\tint m = 0;\n\t\tVVI c(n,VI(n));\n\t\tif (turn == 1){\n\t\t\tREP(i,n) REP(j,n){\n\t\t\t\tVVI d(n,VI(n));\n\t\t\t\tint x = put(i,j,turn,d);\n\t\t\t\tif (x > m){\n\t\t\t\t\tm = x;\n\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m <= 1){\n\t\t\t\tp1 = true;\n\t\t\t}else{\n\t\t\t\tp1 = false;\n\t\t\t\tREP(i,n) REP(j,n) if (c[i][j]) a[i][j] = 1;\n\t\t\t}\n\t\t}else{\n\t\t\tREP(i,n) REP(j,n){\n\t\t\t\tVVI d(n,VI(n));\n\t\t\t\tint x = put(i,j,turn,d);\n\t\t\t\tif (x >= m){\n\t\t\t\t\tm = x;\n\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m <= 1){\n\t\t\t\tp2 = true;\n\t\t\t}else{\n\t\t\t\tp2 = false;\n\t\t\t\tREP(i,n) REP(j,n) if (c[i][j]) a[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\tturn = ((turn-1) ^ 1) + 1;\n\n\t}\n\n\tstring cake = \".ox\";\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tcout << cake[a[i][j]];\n\t\t}\n\t\tcout << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nvector<string>vec;\nauto cell = [](int i, int j) {\n\tif (i < 0 || j < 0 || i >= 8 || j >= 8)return (char)0;\n\treturn vec[i][j];\n};\nint dx[] = { 1,1,0,-1,-1,-1,0,1 };\nint dy[] = { 0, 1,1,1,0,-1,-1,-1 };\nconst char hs[] = \"ox\";\nint f(int i, int j, bool k)\n{\n\tint cnt = 0;\n\tfor (int dir = 0; dir < 8; ++dir)\n\t{\n\t\tint ii = i + dx[dir], jj = j + dy[dir];\n\t\tint num = 0, numm = 0;\n\t\twhile (cell(ii, jj))\n\t\t{\n\t\t\tif (cell(ii, jj) == '.')\n\t\t\t{\n\t\t\t\tnum = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cell(ii, jj) == hs[k])\n\t\t\t{\n\t\t\t\tnumm = num;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++num;\n\t\t\t}\n\t\t\tii += dx[dir];\n\t\t\tjj += dy[dir];\n\t\t}\n\t\tcnt += numm;\n\t}\n\treturn cnt;\n}\nvoid g(int i, int j, bool k)\n{\n\tfor (int dir = 0; dir < 8; ++dir)\n\t{\n\t\tint ii = i + dx[dir], jj = j + dy[dir];\n\t\tint num = 0, numm = 0;\n\t\twhile (cell(ii, jj))\n\t\t{\n\t\t\tif (cell(ii, jj) == '.')\n\t\t\t{\n\t\t\t\tnum = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cell(ii, jj) == hs[k])\n\t\t\t{\n\t\t\t\tnumm = num;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++num;\n\t\t\t}\n\t\t\tii += dx[dir];\n\t\t\tjj += dy[dir];\n\t\t}\n\t\tif (numm)\n\t\t{\n\t\t\tii = i + dx[dir], jj = j + dy[dir];\n\t\t\twhile (cell(ii, jj) == hs[!k])\n\t\t\t{\n\t\t\t\tvec[ii][jj] = hs[k];\n\t\t\t\tii += dx[dir];\n\t\t\t\tjj += dy[dir];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void)\n{\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tvec.push_back(s);\n\t}\n\tfor (;;)\n\t{\n\t\tbool p1 = true, p2 = true;\n\t\t//o\n\t\t{\n\t\t\tpair<int, pair<int, int>>cl = { 0,{0,0} };\n\t\t\tfor (int i = 0; i < 8; ++i)for (int j = 0; j < 8; ++j)\n\t\t\t{\n\t\t\t\tif (vec[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tint ret = f(i, j, false);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t{\n\t\t\t\t\t\tcl = max(cl, { ret,{-i,-j} });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cl.first)\n\t\t\t{\n\t\t\t\tp1 = false;\n\t\t\t\tvec[-cl.second.first][-cl.second.second] = 'o';\n\t\t\t\tg(-cl.second.first, -cl.second.second, false);\n\t\t\t}\n\t\t}\n\t\t//x\n\t\t{\n\t\t\tpair<int, pair<int, int>>cl = { 0,{ 0,0 } };\n\t\t\tfor (int i = 0; i < 8; ++i)for (int j = 0; j < 8; ++j)\n\t\t\t{\n\t\t\t\tif (vec[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tint ret = f(i, j, true);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t{\n\t\t\t\t\t\tcl = max(cl, { ret,{ i,j } });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cl.first)\n\t\t\t{\n\t\t\t\tp2 = false;\n\t\t\t\tvec[cl.second.first][cl.second.second] = 'x';\n\t\t\t\tg(cl.second.first, cl.second.second, true);\n\t\t\t}\n\t\t}\n\t\tif (p1 && p2)break;\n\t}\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tcout << vec[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar t[8][8];\n\nint func(int y,int x,char ch){\n  int res=0;\n  int cnt=0;\n  for(int Y=y+1;;Y++){\n    if(Y>=8)break;\n    if(t[Y][x]==ch){ res+=cnt;   break; }\n    if(t[Y][x]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int Y=y-1;;Y--){\n    if(Y<0)break;\n    if(t[Y][x]==ch){ res+=cnt;   break; }\n    if(t[Y][x]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n for(int X=x+1;;X++){\n    if(X>=8)break;\n    if(t[y][X]==ch){ res+=cnt;   break; }\n    if(t[y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x-1;;X--){\n    if(X<0)break;\n    if(t[y][X]==ch){ res+=cnt;   break; }\n    if(t[y][X]=='.')break;\n    cnt++;\n  }\n\n\n  cnt=0;\n  for(int X=x+1,Y=y+1;;X++,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x+1,Y=y-1;;X++,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n\n\n  cnt=0;\n  for(int X=x-1,Y=y+1;;X--,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n  cnt=0;\n  for(int X=x-1,Y=y-1;;X--,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){ res+=cnt;   break; }\n    if(t[Y][X]=='.')break;\n    cnt++;\n  }\n\n\n  return res;\n}\n\nvoid func2(int y,int x,char ch){\n  int flg=0;\n  for(int Y=y+1;;Y++){\n    if(Y>=8)break;\n    if(t[Y][x]==ch){flg=1;break; }\n    if(t[Y][x]=='.')break;\n  }\n  if(flg){\n    for(int Y=y+1;;Y++){\n      if(Y>=8)break;\n      if(t[Y][x]==ch)break; \n      if(t[Y][x]=='.')break;\n      t[Y][x]=ch;\n    }\n  }\n\n  flg=0;\n  for(int Y=y-1;;Y--){\n    if(Y<0)break;\n    if(t[Y][x]==ch){flg=1;break; }\n    if(t[Y][x]=='.')break;\n  }\n  if(flg){\n    for(int Y=y-1;;Y--){\n      if(Y<0)break;\n      if(t[Y][x]==ch)break; \n      if(t[Y][x]=='.')break;\n      t[Y][x]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x+1;;X++){\n    if(X>=8)break;\n    if(t[y][X]==ch){flg=1;break;}\n    if(t[y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x+1;;X++){\n      if(X>=8)break;\n      if(t[y][X]==ch)break;\n      if(t[y][X]=='.')break;\n      t[y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x-1;;X--){\n    if(X<0)break;\n    if(t[y][X]==ch){flg=1;break; }\n    if(t[y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1;;X--){\n      if(X<0)break;\n      if(t[y][X]==ch)break;\n      if(t[y][X]=='.')break;\n      t[y][X]=ch;\n    }\n  }\n\n\n  flg=0;\n  for(int X=x+1,Y=y+1;;X++,Y++){\n    if(X>=8||Y>=8)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x+1,Y=y+1;;X++,Y++){\n      if(X>=8||Y>=8)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x+1,Y=y-1;;X++,Y--){\n    if(X>=8||Y<0)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){  \n    for(int X=x+1,Y=y-1;;X++,Y--){\n      if(X>=8||Y<0)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n\n  flg=0;\n  for(int X=x-1,Y=y+1;;X--,Y++){\n    if(X<0||Y>=8)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1,Y=y+1;;X--,Y++){\n      if(X<0||Y>=8)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n  flg=0;\n  for(int X=x-1,Y=y-1;;X--,Y--){\n    if(X<0||Y<0)break;\n    if(t[Y][X]==ch){flg=1;break; }\n    if(t[Y][X]=='.')break;\n  }\n  if(flg){\n    for(int X=x-1,Y=y-1;;X--,Y--){\n      if(X<0||Y<0)break;\n      if(t[Y][X]==ch)break;\n      if(t[Y][X]=='.')break;\n      t[Y][X]=ch;\n    }\n  }\n\n}\n\nint main(){\n  for(int i=0;i<8;i++)\n    for(int j=0;j<8;j++)\n      cin>>t[i][j];\n\n  int cnt=0;\n  for(int i=0;;i++){\n    \n    char ch=(i%2?'x':'o');\n    \n\n    int ay,ax,maxm=0;\n    if(ch=='o'){\n      for(int j=0;j<8;j++){\n\tfor(int k=0;k<8;k++){\n\t  if(t[j][k]!='.')continue;\n\t  int x=func(j,k,ch);\n\t\n\t  if(x>maxm){\n\t    maxm=x;\n\t    ay=j;\n\t    ax=k;\n\t  }\n\t}\n      }\n    }else{\n      for(int j=7;j>=0;j--){\n\tfor(int k=7;k>=0;k--){\n\t  if(t[j][k]!='.')continue;\n\t  int x=func(j,k,ch);\n\t\n\t  if(x>maxm){\n\t    maxm=x;\n\t    ay=j;\n\t    ax=k;\n\t  }\n\t}\n      }\n\n    }\n\n    if(maxm==0){\n      cnt++;\n      if(cnt==2)break;\n      continue;\n    }else cnt=0;\n\n    // cout<<ay<<' '<<ax<<endl;\n\n    t[ay][ax]=ch;\n    func2(ay,ax,ch);\n    \n  }//i\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++)cout<<t[i][j];\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(const T a, const T b){return a>=0 ? a/b : (a+1)/b-1;}\ntemplate<class T> T div_ceil(const T a, const T b){return a>=0 ? (a-1)/b+1 : a/b;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\nchar s[8][8];\n\nbool in(int x, int y){\n    return 0<=x && x<8 && 0<=y && y<8;\n}\n\nchar other(char c){\n    return c == 'o' ? 'x' : 'o';\n}\n\nint count(int x, int y, int dx, int dy, char c){\n    int ret = 0;\n    x += dx; y += dy;\n    while(in(x, y) && s[x][y] == other(c)){\n        ++ret;\n        x += dx; y += dy;\n    }\n    return in(x, y) && s[x][y] == c ? ret : 0;\n}\n\nint count_sum(int x, int y, char c){\n    int ret = 0;\n    for(int dx=-1; dx<=1; ++dx)for(int dy=-1; dy<=1; ++dy)if(dx != 0 || dy != 0){\n        ret += count(x, y, dx, dy, c);\n    }\n    return ret;\n}\n\nvoid put(int x, int y, char c){\n    s[x][y] = c;\n    int tx, ty;\n    for(int dx=-1; dx<=1; ++dx)for(int dy=-1; dy<=1; ++dy)if(dx != 0 || dy != 0){\n        if(count(x, y, dx, dy, c) > 0){\n            tx = x + dx; ty = y + dy;\n            while(s[tx][ty] == other(c)){\n                s[tx][ty] = c;\n                tx += dx; ty += dy;\n            }\n        }\n    }\n}\n\nint main(){\n    rep(i, 8)rep(j, 8) scanf(\" %c\", &s[i][j]);\n    rep(i, 64){\n        int cnt = 0, tx = -1, ty = -1;\n        if(i % 2 == 0){\n            rep(x, 8)rep(y, 8)if(s[x][y] == '.'){\n                if(chmax(cnt, count_sum(x, y, 'o'))){\n                    tx = x; ty = y;\n                }\n            }\n            if(cnt > 0) put(tx, ty, 'o');\n        }\n        else{\n            rrep(x, 8)rrep(y, 8)if(s[x][y] == '.'){\n                if(chmax(cnt, count_sum(x, y, 'x'))){\n                    tx = x; ty = y;\n                }\n            }\n            if(cnt > 0) put(tx, ty, 'x');\n        }\n    }\n    rep(i, 8){\n        rep(j, 8) printf(\"%c\", s[i][j]);\n        printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dx[8]={-1,-1,0,1,1,1,0,-1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nint main(){\n\tchar t[8][8];\n\tint i,j,k,l;\n\tfor(i=0;i<8;i++)for(j=0;j<8;j++)scanf(\" %c\",&t[i][j]);\n\tbool mamiturn=false;\n\tint pass=0;\n\twhile(1){\n\t\tmamiturn=!mamiturn;\n\t\tint mx=-1,my=-1;\n\t\tint ma=0;\n\t\tfor(i=0;i<8;i++){\n\t\t\tfor(j=0;j<8;j++){\n\t\t\t\tif(t[i][j]=='.'){\n\t\t\t\t\tint res=0;\n\t\t\t\t\tfor(k=0;k<8;k++){\n\t\t\t\t\t\tint l=1;\n\t\t\t\t\t\twhile(i+dx[k]*l>=0&&i+dx[k]*l<8&&j+dy[k]*l>=0&&j+dy[k]*l<8&&t[i+dx[k]*l][j+dy[k]*l]==(mamiturn?'x':'o'))l++;\n\t\t\t\t\t\tif(l==1)continue;\n\t\t\t\t\t\tif(i+dx[k]*l>=0&&i+dx[k]*l<8&&j+dy[k]*l>=0&&j+dy[k]*l<8&&t[i+dx[k]*l][j+dy[k]*l]==(mamiturn?'o':'x')){\n\t\t\t\t\t\t\tres+=l-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res==0)continue;\n\t\t\t\t\tif(mamiturn){\n\t\t\t\t\t\tif(res>ma){\n\t\t\t\t\t\t\tma=res;\n\t\t\t\t\t\t\tmx=i;\n\t\t\t\t\t\t\tmy=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(res>=ma){\n\t\t\t\t\t\t\tma=res;\n\t\t\t\t\t\t\tmx=i;\n\t\t\t\t\t\t\tmy=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mx==-1&&my==-1){\n\t\t\tpass++;\n\t\t\tif(pass>=2)break;\n\t\t\tcontinue;\n\t\t}\n\t\telse pass=0;\n\t\tt[mx][my]=mamiturn?'o':'x';\n\t\tfor(i=0;i<8;i++){\n\t\t\tint j=1;\n\t\t\twhile(mx+dx[i]*j>=0&&mx+dx[i]*j<8&&my+dy[i]*j>=0&&my+dy[i]*j<8&&t[mx+dx[i]*j][my+dy[i]*j]==(mamiturn?'x':'o'))j++;\n\t\t\tif(mx+dx[i]*j>=0&&mx+dx[i]*j<8&&my+dy[i]*j>=0&&my+dy[i]*j<8&&t[mx+dx[i]*j][my+dy[i]*j]==(mamiturn?'o':'x')){\n\t\t\t\tj--;\n\t\t\t\twhile(j>0){\n\t\t\t\t\tt[mx+dx[i]*j][my+dy[i]*j]=mamiturn?'o':'x';\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<8;i++){\n\t\tfor(j=0;j<8;j++)printf(\"%c\",t[i][j]);puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define BLACK 1\n#define WHITE 10\n#define NORMAL 0\n\n#define DEBUG 0\n\nusing namespace std;\n\nclass Point{\n\npublic:\n\tint x, y;\n\n};\n\nint abs(int a){\n\tif (a < 0){\n\t\treturn a*-1;\n\t}\n\telse{\n\t\treturn a;\n\t}\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint isIn(int x, int y){\n\tif (x < 0 || 9<=x || y < 0 || 9<=y){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}\n\nint isEqualColor(int x, int y, int **data,int color){\n\tif (data[y][x] == color){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint changeColorNum(Point start, Point end){\n\treturn max(abs(start.x - end.x)-1, abs(start.y - end.y)-1);\n}\n\nPoint searchNextCookie(Point start, int **data, int direction,int color){\n\n\tint dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\tint dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\tPoint p;\n\tp.x = -1;\n\tp.y = -1;\n\n\tfor (int i = 1;; i++){\n\t\tint nowX = start.x + dx[direction] * i;\n\t\tint nowY = start.y + dy[direction] * i;\n\t\tif (isIn(nowX, nowY)==0){\n\t\t\tbreak;\n\t\t}\n\t\tif (isEqualColor(nowX, nowY, data, NORMAL)){\n\t\t\tbreak;\n\t\t}\n\n\t\tif (isEqualColor(nowX, nowY, data, color)){\n\t\t\tp.x = nowX;\n\t\t\tp.y = nowY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nvoid changeData(Point point, int **data,int turn){\n\n\tdata[point.y][point.x] = turn;\n\t\n\tint dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\tint dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\tfor (int i = 0; i < 8; i++){\n\t\tif (searchNextCookie(point, data, i, turn).x != -1){\n\n\t\t\tfor (int j = 1;; j++){\n\t\t\t\tPoint next;\n\t\t\t\tnext.x = point.x + dx[i] * j;\n\t\t\t\tnext.y = point.y + dy[i] * j;\n\t\t\t\tif (isEqualColor(next.x, next.y, data, turn)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdata[next.y][next.x] = turn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid show(int **data){\n\tfor (int i = 1; i < 9; i++){\n\t\tfor (int j = 1; j < 9; j++){\n\t\t\tif (data[i][j] == BLACK){\n\t\t\t\tcout << 'o';\n\t\t\t}\n\t\t\telse if (data[i][j] == WHITE){\n\t\t\t\tcout << 'x';\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << '.';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tif (DEBUG)cout << endl;\n}\n\nint changeTurn(int turn){\n\tif (turn == BLACK){\n\t\treturn WHITE;\n\t}\n\telse{\n\t\treturn BLACK;\n\t}\n}\n\nint main(){\n\n\tint **data = new int *[10];\n\tfor (int i = 0; i < 10; i++){\n\t\tdata[i] = new int[10];\n\t}\n\tchar tmp;\n\n\tfor (int i = 1; i < 9; i++){\n\t\tfor (int j = 1; j < 9; j++){\n\t\t\tcin >> tmp;\n\t\t\tif (tmp == 'o'){\n\t\t\t\tdata[i][j] = BLACK;\n\t\t\t}\n\t\t\telse if (tmp == 'x'){\n\t\t\t\tdata[i][j] = WHITE;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdata[i][j] = NORMAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (DEBUG)show(data);\n\n\tint turn = WHITE;\n\tint breakCnt = 0;\n\twhile (1){\n\t\tturn = changeTurn(turn);\n\t\tif (breakCnt >= 2){\n\t\t\tbreak;\n\t\t}\n\n\n\t\tint changeNum = 0;\n\t\tPoint maxP;\n\t\tmaxP.x = -1;\n\t\tmaxP.y = -1;\n\n\t\t//????????´???????±?????????????\n\t\tfor (int i = 1; i < 9; i++){\n\t\t\tfor (int j = 1; j < 9; j++){\n\t\t\t\tif (isEqualColor(j, i, data, NORMAL)){\n\t\t\t\t\tint nowChangeNum = 0;\n\t\t\t\t\tPoint start;\n\t\t\t\t\tstart.x = j, start.y = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++){\n\t\t\t\t\t\tPoint next = searchNextCookie(start, data, k, turn);\n\t\t\t\t\t\tif (next.x == -1)continue;\n\n\t\t\t\t\t\tnowChangeNum += changeColorNum(start, next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (turn == BLACK){\n\t\t\t\t\t\tif (changeNum < nowChangeNum && nowChangeNum != 0){\n\t\t\t\t\t\t\tmaxP.x = start.x;\n\t\t\t\t\t\t\tmaxP.y = start.y;\n\t\t\t\t\t\t\tchangeNum = nowChangeNum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (changeNum <= nowChangeNum && nowChangeNum != 0){\n\t\t\t\t\t\t\tmaxP.x = start.x;\n\t\t\t\t\t\t\tmaxP.y = start.y;\n\t\t\t\t\t\t\tchangeNum = nowChangeNum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (maxP.x == -1){\n\t\t\tbreakCnt++;\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tbreakCnt = 0;\n\t\t}\n\n\n\t\tchangeData(maxP, data, turn);\n\n\t\tif (DEBUG)show(data);\n\t}\n\n\tshow(data);\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nconst int dr[8] = {-1, -1, 1, 1, 1, -1, 0, 0};\nconst int dc[8] = {-1, 1, -1, 1, 0, 0, -1, 1};\n  \nint board[8][8];\n\nint count_lock(int r, int c, int k) {\n  int cnt = 0;\n  \n  REP(i, 8) {\n    int nr = r+dr[i], nc = c+dc[i];\n    while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1))\n      nr += dr[i], nc += dc[i];\n    if (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == k) {\n      if (i < 6) {\n\tcnt += abs(nr-r)-1;\n      } else {\n\tcnt += abs(nc-c)-1;\n      }\n    }\n  }\n  return cnt;\n}\n  \nvoid put_lock(int r, int c, int k){\n  board[r][c] = k;\n  REP(i, 8) {\n    int nr = r+dr[i], nc = c+dc[i];\n    while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1))\n      nr += dr[i], nc += dc[i];\n    if (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == k) {\n      nr -= dr[i], nc -= dc[i];\n      while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1)) {\n\tboard[nr][nc] = k;\n\tnr -= dr[i], nc -= dc[i];\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i, 8) {\n    string row;\n    cin >> row;\n    REP(j, 8) {\n      switch(row[j]) {\n      case '.':\n\tboard[i][j] = -1;\n\tbreak;\n      default:\n\tboard[i][j] = row[j] == 'o' ? 0 : 1;\n\tbreak;\n      }\n    }\n  }\n\n  int flag = true;\n  while (flag) {\n    flag = false;\n    REP(k, 2) {\n      int f = 0;\n      P f_p;\n      REP(r, 8) REP(c, 8) {\n\tif (board[r][c] == -1) {\n\t  int cnt = count_lock(r, c, k);\n\t  if ((k == 0 && cnt > f) || (k == 1 && cnt > 0 && cnt >= f)) {\n\t    f = cnt;\n\t    f_p = make_pair(r, c);\n\t  }\n\t}\n      }\n      if (f > 0) {\n\tput_lock(f_p.first, f_p.second, k);\n\tflag = true;\n      }\n    }\n    \n  }\n  REP(r, 8) {\n    REP(c, 8) {\n      switch(board[r][c]) {\n      case -1:\n\tcout << '.';\n\tbreak;\t\n      default:\n\tcout << (board[r][c] == 0 ? 'o' : 'x');\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//変数\nconst int siz = 8;\nvector<string> s(siz);\n\n\n\n\n\n\n//サブ関数\n//入力\nvoid input()\n{\n\tREP(i, siz) {\n\t\tcin >> s[i];\n\t}\n}\n\nbool isOut(int h, int w)\n{\n\tif (h < 0 || w < 0)return true;\n\tif (7 < h || 7 < w)return true;\n\treturn false;\n}\n\nint evaluate(bool mami, int h, int w)\n{\n\tchar me = (mami ? 'o' : 'x');\n\tif (s[h][w] != '.')return 0;\n\n\tint sumValue = 0;\n\tint dy[8] = { -1,-1,-1,0,1,1,1,0 };\n\tint dx[8] = { -1,0,1,1,1,0,-1,-1 };\n\tREP(dir, 8) {\n\t\tint y = h;\n\t\tint x = w;\n\t\tint value = 0;\n\t\twhile (true) {\n\t\t\ty += dy[dir];\n\t\t\tx += dx[dir];\n\t\t\tif (isOut(y, x))break;\n\t\t\tif (s[y][x] == '.') break;\n\n\t\t\tif (s[y][x] != me)value++;\n\t\t\telse {\n\t\t\t\tsumValue += value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sumValue;\n}\n\nvoid put_cookie(bool mami, int h, int w)\n{\n\tchar me = (mami ? 'o' : 'x');\n\n\tint dy[8] = { -1,-1,-1,0,1,1,1,0 };\n\tint dx[8] = { -1,0,1,1,1,0,-1,-1 };\n\tREP(dir, 8) {\n\t\tint y = h;\n\t\tint x = w;\n\t\tbool change = false;\n\n\t\twhile (true) {\n\t\t\ty += dy[dir];\n\t\t\tx += dx[dir];\n\t\t\tif (isOut(y, x))break;\n\t\t\tif (s[y][x] == '.') break;\n\t\t\tif (s[y][x] == me) {\n\t\t\t\tchange = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (change) {\n\t\t\ty = h;\n\t\t\tx = w;\n\t\t\tdo {\n\t\t\t\ts[y][x] = me;\n\t\t\t\ty += dy[dir];\n\t\t\t\tx += dx[dir];\n\t\t\t} while (s[y][x] != me);\n\t\t}\n\t}\n}\n\nbool search(bool mami)\n{\n\tint maxH = 0;\n\tint maxW = 0;\n\tint maxV = 0;\n\tREP(i, siz)REP(j, siz) {\n\t\tint tmpV = evaluate(mami, i, j);\n\t\tif (mami) {\n\t\t\tif (maxV < tmpV) {\n\t\t\t\tmaxH = i;\n\t\t\t\tmaxW = j;\n\t\t\t\tmaxV = tmpV;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (maxV <= tmpV) {\n\t\t\t\tmaxH = i;\n\t\t\t\tmaxW = j;\n\t\t\t\tmaxV = tmpV;\n\t\t\t}\n\t\t}\n\t}\n\tif (maxV) {\n\t\tput_cookie(mami, maxH, maxW);\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n//計算\nvoid calc()\n{\n\tbool mami = true;\n\tint cnt = 0;\n\twhile (cnt < 2) {\n\t\tif (search(mami))cnt = 0;\n\t\telse cnt++;\n\n\t\tmami = !mami;\n\t}\n\n}\n\n\n//出力\nvoid output()\n{\n\tcerr << endl << endl;\n\tfor (auto row : s) {\n\t\tcout << row << endl;\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tinput();\n\tcalc();\n\toutput();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint map[8][8];\n\nint val(int y,int x){\n\tint dx[]={1,1,1,0,0,-1,-1,-1};\n\tint dy[]={1,0,-1,1,-1,1,0,-1};\n\tint ans=0;\n\tfor(int i=0;i<8;i++){\n\t\tint cnt=0,a=y,b=x;\n\t\twhile(true){\n\t\t\ta+=dy[i],b+=dx[i];\n\t\t\tif(a>=0&&a<8&&b>=0&&b<8){\n\t\t\t\tif(map[a][b]==1)cnt++;\n\t\t\t\tif(map[a][b]==0){\n\t\t\t\t\tans+=cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[a][b]==2)break;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid ch(int y,int x){\n\tint dx[]={1,1,1,0,0,-1,-1,-1};\n\tint dy[]={1,0,-1,1,-1,1,0,-1};\n\tfor(int i=0;i<8;i++){\n\t\tint a=y,b=x;\n\t\tbool ok=false;\n\t\twhile(true){\n\t\t\ta+=dy[i],b+=dx[i];\n\t\t\tif(a>=0&&a<8&&b>=0&&b<8){\n\t\t\t\tif(map[a][b]==0){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[a][b]==2)break;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tif(ok){\n\t\t\twhile(true){\n\t\t\t\tif(a==y&&b==x)break;\n\t\t\t\ta-=dy[i],b-=dx[i];\n\t\t\t\tmap[a][b]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tchar z;cin>>z;\n\t\t\tif(z=='o')map[i][j]=0;\n\t\t\tif(z=='x')map[i][j]=1;\n\t\t\tif(z=='.')map[i][j]=2;\n\t\t}\n\t}\n\tint t=0,d=130;\n\twhile(d--){\n\t\tif(t==0){\n\t\t\tint x=-1,y=-1,z=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\t\tint k=val(i,j);\n\t\t\t\t\t\tif(k>z)x=j,y=i,z=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tch(y,x);\n\t\t}\n\t\tif(t==1){\n\t\t\tint x=-1,y=-1,z=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]==2){\n\t\t\t\t\t\tint k=val(i,j);\n\t\t\t\t\t\tif(k>=z)x=j,y=i,z=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tch(y,x);\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==0)map[i][j]=3;\n\t\t\t\tif(map[i][j]==1)map[i][j]=0;\n\t\t\t\tif(map[i][j]==3)map[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tt=1-t;\n\t}\n\t\n\tif(t){\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==0)map[i][j]=3;\n\t\t\t\tif(map[i][j]==1)map[i][j]=0;\n\t\t\t\tif(map[i][j]==3)map[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tif(map[i][j]==0)cout<<\"o\";\n\t\t\tif(map[i][j]==1)cout<<\"x\";\n\t\t\tif(map[i][j]==2)cout<<\".\";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \nusing namespace std;\nint board[10][10];\nint dx[] = {0,1,0,-1,1,-1,1,-1};\nint dy[] = {1,0,-1,0,1,-1,-1,1};\n\nint rev(int c,int x,int y,int d ,int depth,int flag){\n\tif(depth == 0 && board[y][x] != -1 && flag == 0) return 0;\n\t//cout << x << \" \" << y << \" \" << board[y][x] << endl;\n\tif(depth != 0 && board[y][x] == -1) return 0;\n\tif(depth == 1 && board[y][x] == c) return 0;\n\tif(depth >= 2 && c == board[y][x]){ return depth-1; }\n\tint r = rev(c,x+dx[d],y+dy[d],d,depth+1,flag);\n\tif(r){\n\t\tif(flag) board[y][x] = c;\n\t\t\n\t\treturn r;\n\t}\n\treturn 0;\n\t\n}\n\nint ableCnt(int c,int x,int y,bool flag){\n\tint cnt = 0;\n\trep(i,8){\n\t\tcnt += rev(c,x,y,i,0,flag);\n\t}\n\treturn cnt;\n}\n\n\nint main(){\n\tint turn = 0;\n\trep(i,10)rep(j,10)board[i][j] = -1;\n\tfor(int i = 1 ; i <= 8 ; i++)\n\tfor(int j = 1 ; j <= 8 ; j++){char c; cin >> c; board[i][j] = c == '.' ? -1 : c == 'o' ? 0 : 1;}\n\tbool prev_passed = 0;\n\n\twhile(1){\n\t\tint mx = -1 , px = -1, py = -1;\n\t\tif(turn == 0){\n\t\t\trep(i,8)rep(j,8){\n\t\t\t\t int get = ableCnt(turn,j+1,i+1,0);\n\t\t\t\t if( mx < get){\n\t\t\t\t\tmx = get;\n\t\t\t\t\tpx = j+1;\n\t\t\t\t\tpy = i+1;\n\t\t\t\t }\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 7 ; i >= 0 ; i--){\n\t\t\t\tfor(int j = 7 ; j >= 0 ; j--){\n\t\t\t\t int get = ableCnt(turn,j+1,i+1,0);\n\t\t\t\t if( mx < get){\n\t\t\t\t\tmx = get;\n\t\t\t\t\tpx = j+1;\n\t\t\t\t\tpy = i+1;\n\t\t\t\t }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mx == 0){\n\t\t\tif(prev_passed)break;\n\t\t\telse prev_passed = true;\n\t\t}else{\n\t\t\tableCnt(turn,px,py,1);\n\t\t\tprev_passed = false;\n\t\t}\n\t\tturn ^= 1;\n\t}\n\trep(i,8){ rep(j,8) cout << (board[i+1][j+1]==-1?'.':board[i+1][j+1]==0?'o':'x');cout << endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n#define max 8\n\nchar sym[] = {'o', 'x', '.'};\n\nint abs( int p ) {\n\tif( p < 0 ) return -p;\n\treturn p;\n}\n\nvoid count(int x, int y, int p, int num[2][max][max], char map[max][max], int vx, int vy, int cx, int cy, int mode) {\n\tif( cx < 0 || cy < 0 || cx >= max || cy >= max ) return;\n\tif( map[cx][cy] == sym[p] ) {\n\t\tif( mode == 0 ) {\n\t\t\tif( vx != 0 ) {\n\t\t\t\tnum[p][x][y] += abs( cx - x ) - 1;\n\t\t\t} else {\n\t\t\t\tnum[p][x][y] += abs( cy - y ) - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i = x, j = y; i != cx || j != cy; i += vx, j += vy) {\n\t\t\t\tmap[i][j] = sym[p];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t} else if ( map[cx][cy] == sym[2] ) {\n\t\treturn;\n\t} else {\n\t\tcx += vx;\n\t\tcy += vy;\n\t\tcount( x, y, p, num, map, vx, vy, cx, cy, mode);\n\t}\n}\n\nvoid search(int x, int y, int p, int num[2][max][max], char map[max][max]){\n\tif( map[x][y] != '.' ) return;\n\tcount(x, y, p, num, map, 1, 0, x + 1, y, 0);\n\tcount(x, y, p, num, map, 0, 1, x, y + 1, 0);\n\tcount(x, y, p, num, map, -1, 0, x - 1, y, 0);\n\tcount(x, y, p, num, map, 0, -1, x, y - 1, 0);\n\tcount(x, y, p, num, map, 1, 1, x + 1, y + 1, 0);\n\tcount(x, y, p, num, map, 1, -1, x + 1, y - 1, 0);\n\tcount(x, y, p, num, map, -1, 1, x - 1, y + 1, 0);\n\tcount(x, y, p, num, map, -1, -1, x - 1, y - 1, 0);\n}\n\nvoid set(int x, int y, int p, int num[2][max][max], char map[max][max]){\n\tif( map[x][y] != '.' ) return;\n\tcount(x, y, p, num, map, 1, 0, x + 1, y, 1);\n\tcount(x, y, p, num, map, 0, 1, x, y + 1, 1);\n\tcount(x, y, p, num, map, -1, 0, x - 1, y, 1);\n\tcount(x, y, p, num, map, 0, -1, x, y - 1, 1);\n\tcount(x, y, p, num, map, 1, 1, x + 1, y + 1, 1);\n\tcount(x, y, p, num, map, 1, -1, x + 1, y - 1, 1);\n\tcount(x, y, p, num, map, -1, 1, x - 1, y + 1, 1);\n\tcount(x, y, p, num, map, -1, -1, x - 1, y - 1, 1);\n}\n\nvoid reset(int p, int num[2][max][max]) {\n\tfor(int i = 0; i < max * max ; i++)\n\t\tnum[p][i / max][i % max ] = 0;\n}\n\nint main(void){\n//\tFILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\tchar map[max][max];\n\tint num[2][max][max];\n\tfor(int i = 0; i < max; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < max; j++) {\n\t\t\tmap[j][i] = s[j];\n\t\t\tnum[0][j][i] = 0;\n\t\t\tnum[1][j][i] = 0;\n\t\t}\n\t}\n\t//シュミレーション部分\n\tint ps[] = {0, 0};\n\tbool flg = true;\n\n\twhile( flg ) {\n\t\tflg = false;\n\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\treset(i, num);\n\t\t\tps[i] = 0;\n\t\t}\n\n\t\t//マミの手番\n\t\tint posx, posy;\n\t\tfor(int j = 0; j < max; j ++) {\n\t\t\tfor(int i = 0; i < max; i++) {\n\t\t\t\tsearch(i, j, 0, num, map);\n\t\t\t\tif( num[0][i][j] > 0 ) flg = true;\n\t\t\t\tif( ps[0] < num[0][i][j] ) {\n\t\t\t\t\tposx = i;\n\t\t\t\t\tposy = j;\n\t\t\t\t\tps[0] = num[0][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( ps[0] > 0 ) {\n\t\t\tset( posx, posy, 0, num, map );\n\t\t\tmap[posx][posy] = 'o'; \n\t\t}\n\t\t//シャルの手番\n\t\tfor(int j = max - 1; j >= 0; j --) {\n\t\t\tfor(int i = max - 1; i >= 0; i--) {\n\t\t\t\tsearch(i, j, 1, num, map);\n\t\t\t\tif( num[1][i][j] > 0 ) flg = true;\n\t\t\t\tif( ps[1] < num[1][i][j] ) {\n\t\t\t\t\tposx = i;\n\t\t\t\t\tposy = j;\n\t\t\t\t\tps[1] = num[1][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( ps[1] > 0 ) {\n\t\t\tset( posx, posy, 1, num, map );\n\t\t\tmap[posx][posy] = 'x';\n\t\t}\n\n\n\t}\n\n\tfor(int i = 0; i < max; i++) {\n\t\tfor(int j = 0; j < max; j++)\n\t\t\tcout << map[j][i];\n\t\tcout << endl;\n\t}\n\n \n//\twhile (1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define RREP(i,n) for(int i=(int)(n)-1;i>=0;i--)\nusing namespace std;\nconst int MAX_V=8;\nchar s[MAX_V][MAX_V];\nint iter(char mine,char rival,int x,int y,int vx,int vy,int n=0){\n  x+=vx;y+=vy;\n  if(x<0||x>=MAX_V||y<0||y>=MAX_V)return 0;\n  if(s[x][y]==mine)return n;\n  if(s[x][y]==rival)\n    return iter(mine,rival,x,y,vx,vy,n+1);\n  return 0;\n}\nbool iterturn(char mine,char rival,int x,int y,int vx,int vy){\n  x+=vx;y+=vy;\n  if(x<0||x>=MAX_V||y<0||y>=MAX_V)return false;\n  if(s[x][y]==mine)return true;\n  if(s[x][y]==rival){\n    if(iterturn(mine,rival,x,y,vx,vy)){\n      s[x][y]=mine;\n      return true;\n    }else return false;\n  }\n  return false;\n}\nint reversable(char mine,char rival,int x,int y){\n  return iter(mine,rival,x,y,-1,-1)+\n    iter(mine,rival,x,y,-1,0)+\n    iter(mine,rival,x,y,-1,1)+\n    iter(mine,rival,x,y,0,-1)+\n    iter(mine,rival,x,y,0,1)+\n    iter(mine,rival,x,y,1,-1)+\n    iter(mine,rival,x,y,1,0)+\n    iter(mine,rival,x,y,1,1);\n}\nvoid turn(char mine,char rival,int x,int y){\n  s[x][y]=mine;\n  iterturn(mine,rival,x,y,-1,-1);\n  iterturn(mine,rival,x,y,-1,0);\n  iterturn(mine,rival,x,y,-1,1);\n  iterturn(mine,rival,x,y,0,-1);\n  iterturn(mine,rival,x,y,0,1);\n  iterturn(mine,rival,x,y,1,-1);\n  iterturn(mine,rival,x,y,1,0);\n  iterturn(mine,rival,x,y,1,1);\n}\npair<int,int> o(){\n  int m=1,tmpm;\n  pair<int,int> pos=make_pair(-1,-1);\n  RREP(i,MAX_V)RREP(j,MAX_V){\n    if(s[i][j]=='x'||s[i][j]=='o')continue;\n    tmpm=reversable('o','x',i,j);\n    if(tmpm>=m){\n      m=tmpm;\n      pos=make_pair(i,j);\n    }\n  }\n  return pos;\n}\npair<int,int> x(){\n  int m=1,tmpm;\n  pair<int,int> pos=make_pair(-1,-1);\n  REP(i,MAX_V)REP(j,MAX_V){\n    if(s[i][j]=='x'||s[i][j]=='o')continue;\n    tmpm=reversable('x','o',i,j);\n    if(tmpm>=m){\n      m=tmpm;\n      pos=make_pair(i,j);\n    }\n  }\n  return pos;\n}\nvoid print(){\n  REP(i,MAX_V){\n    REP(j,MAX_V)\n      cout<<s[i][j];\n    cout<<endl;\n  }\n}\nint main(){ _;\n  REP(i,MAX_V)REP(j,MAX_V)cin>>s[i][j];\n  for(;;){\n    auto a=o();\n    if(a.first>=0)turn('o','x',a.first,a.second);\n    auto b=x();\n    if(b.first>=0)turn('x','o',b.first,b.second);\n    if(a.first==-1&&b.first==-1)break;\n  }\n  print();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define x first \n#define y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 8;\n\nint dx[] = {1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    vs b(N);\n\n    for(; cin >> b[0];){\n        range(i, 1, N) cin >> b[i];\n\n        bool mamiT = true;\n        rep(turncnt, N * N){\n            char mine = mamiT ? 'o':'x', enemy = mamiT ? 'x':'o';\n\n            vector< vector< pair<int, vi> > > stat(N, vector< pair<int, vi> >(N));\n            rep(y, N){\n                rep(x, N){\n                    stat[y][x].second = vi(8, 0);\n                    if(b[y][x] != '.') continue;\n\n                    rep(i, 8){\n                        bool ok = false;\n\n                        range(j, 1, N){\n                            pii next = mp(x + dx[i] * j, y + dy[i] * j);\n                            if(next.x < 0 || N <= next.x ||\n                               next.y < 0 || N <= next.y) break;\n                            if(b[next.y][next.x] == enemy){\n                                stat[y][x].first++;\n                                stat[y][x].second[i]++;\n                            }\n                            else if(b[next.y][next.x] == mine){\n                                ok = true;\n                                break;\n                            }\n                            else break;\n                        }\n                        \n                        if(!ok){\n                            stat[y][x].first -= stat[y][x].second[i];\n                            stat[y][x].second[i] = 0;\n                        }\n                    }\n                }\n            }\n\n            pii p;\n            int maxs = 0;\n            rep(y, N){\n                rep(x, N){\n                    if((mamiT && maxs < stat[y][x].first) ||\n                      (!mamiT && maxs <=stat[y][x].first)){\n                        p = mp(x, y);\n                        maxs = stat[y][x].first;\n                    }\n                }\n            }\n\n            if(maxs != 0){\n                rep(i, 8){\n                    if(stat[p.y][p.x].first == 0) continue;\n                    do{\n                        int k = stat[p.y][p.x].second[i];\n                        b[p.y + k * dy[i]][p.x + k * dx[i]] = mine;\n                    } while(0 <= --stat[p.y][p.x].second[i]);\n                }\n            }\n\n            mamiT = !mamiT;\n        }\n\n        rep(y, N){\n            cout << b[y] << endl;\n        }\n        cout << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nvoid solve(vector<string>& s){\n    for(bool turn=true, pass=false; ; turn=!turn){\n        tuple<int, int, int, vector<string> > best = {0, turn? -8: 0, turn? -8: 0, s};\n        rep(x, 8)rep(y, 8)if(s[x][y] == '.'){\n            char my = turn? 'o': 'x', your = turn? 'x': 'o';\n            int cnt = 0;\n            vector<string> t = s; t[x][y] = my;\n            for(int dx=-1; dx<=1; ++dx){\n                for(int dy=-1; dy<=1; ++dy){\n                    int nx = x + dx, ny = y + dy;\n                    if((dx|dy) == 0 || !inrect(nx, ny) || s[nx][ny] != your)continue;\n                    vector<string> tmp = t;\n                    while(inrect(nx, ny) && s[nx][ny] == your){\n                        tmp[nx][ny] = my; nx += dx; ny += dy;\n                    }\n                    if(inrect(nx, ny) && s[nx][ny] == my){\n                        cnt += max(abs(x - nx) - 1, abs(y - ny) - 1);\n                        t.swap(tmp);\n                    }\n                }\n            }\n            if(cnt)chmax(best, {cnt, turn? -x: x, turn? -y: y, t});\n        }\n        if(get<0>(best) == 0){\n            if(pass)break; else pass = true;\n        }\n        else{\n            if(pass)pass = false;\n            s.swap(get<3>(best));\n        }\n    }\n}\n\nint main(){\n    vector<string> s(8);\n    rep(i, 8)cin >> s[i];\n    solve(s);\n    rep(i, 8)cout << s[i] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<sstream>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int x,y;\n  P(int x=0,int y =0):x(x),y(y){}\n};\nstring G[8];\nint dx[] = {0,1,0,-1,1,1,-1,-1};\nint dy[] = {1,0,-1,0,1,-1,1,-1};\n\nint getValue(int x,int y,const bool phase)\n{\n  int cnt = 0;\n  rep(i,8)\n    {\n      int nx = x;\n      int ny = y;\n      int dirCost = 0;\n      while(true)\n\t{\n\t  nx += dx[i];\n\t  ny += dy[i];\n\t  if(!(0 <= nx && nx < 8 && 0 <= ny && ny < 8))\n\t    {\n\t      dirCost = 0; \n\t      break;\n\t    }\n\t  if(!phase)\n\t    {\n\t      if(G[ny][nx] == 'o')break;\n\t      if(G[ny][nx] == '.')\n\t\t{\n\t\t  dirCost = 0;\n\t\t  break;\n\t\t}\n\t      if(G[ny][nx] == 'x')dirCost++;\t      \n\t    }\n\n\t  if(phase)\n\t    {\n\t      if(G[ny][nx] == 'x')break;\n\t      if(G[ny][nx] == '.')\n\t\t{\n\t\t  dirCost = 0;\n\t\t  break;\n\t\t}\n\t      if(G[ny][nx] == 'o')dirCost++;\t      \n\t    }\n\t}\n      cnt += dirCost;\n    }\n  return cnt;\n}\n\nbool draw(P p,const bool phase,const int dir)\n{\n  if(!(0 <= p.x && p.x < 8 && 0 <= p.y && p.y < 8))return false;\n  if(G[p.y][p.x] == '.')return false;\n  if(phase && G[p.y][p.x] == 'x')return true;\n  else if(!phase && G[p.y][p.x] == 'o')return true;\n  bool res;\n  if(res = draw(P(p.x+dx[dir],p.y+dy[dir]),phase,dir))G[p.y][p.x] = (phase?'x':'o');\n  return res;\n}\n\nvoid print()\n{\n  rep(i,8)cout << G[i] << endl;\n}\n\nint main()\n{\n  bool phase = false;\n  bool passM,passW;\n  int maxCostM,maxCostW;\n  rep(i,8)\n    cin >> G[i];\n\n  while(true)\n    {\n      passM = passW = false;\n      maxCostM = maxCostW = 0;\n      P M,W;\n      phase = false;\n\n      rep(i,8)\n\t{\n\t  rep(j,8)\n\t    {\n\t      if(G[i][j] != '.')continue;\n\t      int v = getValue(j,i,phase); \n\t      if(v > maxCostM)\n\t\t{\n\t\t  M = P(j,i);\n\t\t  maxCostM = v;\n\t\t}\n\t    }\n\t}\n\n      if(!maxCostM)passM = true;\n      else \n\t{\n\t  G[M.y][M.x] = 'o';\n\t  rep(k,8)draw(P(M.x+dx[k],M.y+dy[k]),phase,k);\n\t}\n\n      //cout << \"MaMi\" << endl;\n      //print();\n\n      phase = !phase;\t\n\n      for(int i=7;i>=0;i--)\n\t{\n\t  for(int j=7;j>=0;j--)\n\t    {\n\t      if(G[i][j] != '.')continue;\n\t      int v = getValue(j,i,phase); \n\t      if(v > maxCostW)\n\t\t{\n\t\t  W = P(j,i);\n\t\t  maxCostW = v;\n\t\t}\n\t    }\n\t}\n\n      if(!maxCostW)passW = true;\n      else \n\t{\n\t  G[W.y][W.x] = 'x';\n\t  rep(k,8)draw(P(W.x+dx[k],W.y+dy[k]),phase,k);\n\t}\n\n      if(passW & passM)break;\n      //cout << \"WitCh\" << endl;\n      //print();\n    }\n\n  print();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pq priority_queue\nusing namespace std; typedef pair<int, int> P; typedef pair<int, P> P2;\ntypedef pair<int, P2> P3; typedef long long ll; typedef long double ld;\nconstexpr long long gcd(long long a, long long b){return b ? gcd(b, a % b) : a;}\nconstexpr long long lcm(long long a, long long b){return a / gcd(a, b) * b;}\nconstexpr int INF = 1e9, MOD = INF + 7, around[] = {0, 1, 1, -1, -1, 0, -1, 1, 0, 0};\nconstexpr int mod_pow(long long x, long long n, const int mod){long long ret=1;while(n){if(n&1)(ret*=x)%=mod;(x*=x)%=mod;n>>=1;}return ret;}\ntemplate<int n> struct Prime{bool arr[n+1];constexpr bool operator[](int k){return arr[k];}constexpr Prime():arr(){for(int i=2;i<n;i++){arr[i]=true;for(int j=2;j*j<=i;j++){if(!(i%j))arr[i]=false;}}}};\ntemplate<int n> struct Factorial{long long arr[n+1],ary[n+1];constexpr Factorial():arr(),ary(){arr[0]=1;ary[0]=1;for(int i=0;i<n;i++){arr[i+1]=arr[i]*(i+1)%MOD;ary[i+1]=mod_pow(arr[i+1],MOD-2,MOD);}}};\nconstexpr Factorial<10> fact; constexpr Prime<10> prime;\nconstexpr int comb(int a, int b){long long pos = fact.arr[a], pot = fact.ary[a - b], por = fact.ary[b];return pos * pot % MOD * por % MOD;}\ntemplate<int n> struct Bernoulli{long long arr[n+1];constexpr Bernoulli():arr(){arr[0]=1;for(int i=1;i<=n;i++){long long sum=0;for(int j=0;j<i;j++){(sum+=comb(i+1,j)*arr[j]%MOD)%=MOD;}arr[i]=(MOD-mod_pow(i+1,MOD-2,MOD))%MOD*sum%MOD;}}};\nconstexpr int vx[] = {1, 0, -1, 0}, vy[] = {0, 1, 0, -1};\nconstexpr int sqrtN = 512, logN = 32;\nconstexpr ld PI = abs(acos(-1));\nconstexpr ll LINF=1e18;\n\nstring s[8];\n\nint count(int x, int y, char z){\n\tif(s[x][y] != '.') return -1;\n\t\n\tint c = 0;\n\tfor(int i = 1; x - i >= 0; i++){\n\t\tif(s[x - i][y] == '.') break;\n\t\tif(s[x - i][y] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; x + i < 8; i++){\n\t\tif(s[x + i][y] == '.') break;\n\t\tif(s[x + i][y] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; y - i >= 0; i++){\n\t\tif(s[x][y - i] == '.') break;\n\t\tif(s[x][y - i] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; y + i < 8; i++){\n\t\tif(s[x][y + i] == '.') break;\n\t\tif(s[x][y + i] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i + x < 8 and i + y < 8; i++){\n\t\tif(s[i + x][i + y] == '.') break;\n\t\tif(s[i + x][i + y] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; x - i >= 0 and y - i >= 0; i++){\n\t\tif(s[x - i][y - i] == '.') break;\n\t\tif(s[x - i][y - i] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; x + i < 8 and y - i >= 0; i++){\n\t\tif(s[x + i][y - i] == '.') break;\n\t\tif(s[x + i][y - i] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; x - i >= 0 and y + i < 8; i++){\n\t\tif(s[x - i][y + i] == '.') break;\n\t\tif(s[x - i][y + i] == z){\n\t\t\tc += i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn !c ? -1 : c;\n}\n\nvoid color(int x, int y, char z){\n\tbool f = false;\n\t\n\tfor(int i = 1; x - i >= 0; i++){\n\t\tif(s[x - i][y] == '.') break;\n\t\tif(s[x - i][y] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; x - i >= 0; i++){\n\t\tif(s[x - i][y] == z) break;\n\t\ts[x - i][y] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; x + i < 8; i++){\n\t\tif(s[x + i][y] == '.') break;\n\t\tif(s[x + i][y] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; x + i < 8; i++){\n\t\tif(s[x + i][y] == z) break;\n\t\ts[x + i][y] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; y - i >= 0; i++){\n\t\tif(s[x][y - i] == '.') break;\n\t\tif(s[x][y - i] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; y - i >= 0; i++){\n\t\tif(s[x][y - i] == z) break;\n\t\ts[x][y - i] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; y + i < 8; i++){\n\t\tif(s[x][y + i] == '.') break;\n\t\tif(s[x][y + i] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; y + i < 8; i++){\n\t\tif(s[x][y + i] == z) break;\n\t\ts[x][y + i] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; i + x < 8 and i + y < 8; i++){\n\t\tif(s[i + x][i + y] == '.') break;\n\t\tif(s[i + x][i + y] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; i + x < 8 and i + y < 8; i++){\n\t\tif(s[i + x][i + y] == z) break;\n\t\ts[i + x][i + y] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; x - i >= 0 and y - i >= 0; i++){\n\t\tif(s[x - i][y - i] == '.') break;\n\t\tif(s[x - i][y - i] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; x - i >= 0 and y - i >= 0; i++){\n\t\tif(s[x - i][y - i] == z) break;\n\t\ts[x - i][y - i] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; x + i < 8 and y - i >= 0; i++){\n\t\tif(s[x + i][y - i] == '.') break;\n\t\tif(s[x + i][y - i] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; x + i < 8 and y - i >= 0; i++){\n\t\tif(s[x + i][y - i] == z) break;\n\t\ts[x + i][y - i] = z;\n\t}\n\t\n\tf = false;\n\tfor(int i = 1; x - i >= 0 and y + i < 8; i++){\n\t\tif(s[x - i][y + i] == '.') break;\n\t\tif(s[x - i][y + i] == z){f = true; break;}\n\t}\n\t\n\tif(f)\n\tfor(int i = 1; x - i >= 0 and y + i < 8; i++){\n\t\tif(s[x - i][y + i] == z) break;\n\t\ts[x - i][y + i] = z;\n\t}\n}\nvoid solve(char x, char y){\n\tint ma = -1, ma2 = -1;\n\tfor(int i = 0; i < 8; i++){\n\t\tfor(int j = 0; j < 8; j++){\n\t\t\tif(s[i][j] != '.') continue;\n\t\t\tma = max(ma, count(i, j, x));\n\t\t\tma2 = max(ma2, count(i, j, y));\n\t\t}\n\t}\n\t\n\tif(ma == -1 and ma2 == -1) return;\n\tif(ma == -1){\n\t\tsolve(y, x);\n\t\treturn;\n\t}\n\t\n\tif(x == 'o'){\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tif(s[i][j] != '.') continue;\n\t\t\t\tif(count(i, j, x) < ma) continue;\n\t\t\t\ts[i][j] = x;\n\t\t\t\tcolor(i, j, x);\n\t\t\t\ti = j = INF;\n\t\t\t}\n\t\t}\n\t}else if(x == 'x'){\n\t\tfor(int i = 7; i >= 0; i--){\n\t\t\tfor(int j = 7; j >= 0; j--){\n\t\t\t\tif(s[i][j] != '.') continue;\n\t\t\t\tif(count(i, j, x) < ma) continue;\n\t\t\t\ts[i][j] = x;\n\t\t\t\tcolor(i, j, x);\n\t\t\t\ti = j = -INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsolve(y, x);\n}\n\nint main(){\n\tfor(int i = 0; i < 8; i++) cin >> s[i];\n\t\n\tsolve('o', 'x');\n\tfor(int i = 0; i < 8; i++) cout << s[i] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) {\n        ll d = euclid(b, a % b, y, x);\n        return y -= a / b * x, d;\n    }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1)\n            ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1);\n        return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e)\n            return Mod(1);\n        Mod r = *this ^ (e / 2);\n        r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nchar board[8][8], board2[8][8];\nconst int dir[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n\nvoid apply(char board[8][8], int i, int j, char player) {\n    board[i][j] = player;\n    rep(d, 0, 8) {\n        int ii, jj;\n        for (ii = i + dir[d][0], jj = j + dir[d][1]; 0 <= ii && ii < 8 && 0 <= jj && jj < 8 && board[ii][jj] == (player ^ 'x' ^ 'o'); ii += dir[d][0], jj += dir[d][1]) ;\n        // cout << dir[d][0] << \" \" << dir[d][1] << \" \" << ii << \" \" << jj << endl;\n        if (!(0 <= ii && ii < 8 && 0 <= jj && jj < 8 && board[ii][jj] == player)) {\n            continue;\n        }\n        for (int p = i, q = j; p != ii || q != jj; p += dir[d][0], q += dir[d][1])\n            board[p][q] = player;\n    }\n}\n\nint score(int i, int j, char player) {\n    if (board[i][j] != '.')\n        return -100;\n    char other = player ^ 'x' ^ 'o';\n    int before = 0, after = 0;\n    rep(i, 0, 8) rep(j, 0, 8) if (board[i][j] == other) before++;\n    rep(i, 0, 8) rep(j, 0, 8) board2[i][j] = board[i][j];\n    apply(board2, i, j, player);\n    rep(i, 0, 8) rep(j, 0, 8) if (board2[i][j] == other) after++;\n    return before - after;\n}\n\nint main() {\n    rep(i, 0, 8) rep(j, 0, 8) cin >> skipws >> board[i][j];\n\n    char player = 'o';\n    int fail = 0;\n\n    while (true) {\n        int mi = 0, mj = 0, ms = -100;\n        rep(i, 0, 8) rep(j, 0, 8) {\n            int s = score(i, j, player);\n            if (player == 'o' && s > ms || player == 'x' && s >= ms)\n                ms = s, mi = i, mj = j;\n        }\n        if (ms <= 0) {\n            fail++;\n            player = player ^ 'x' ^ 'o';\n            if (fail >= 2) {\n                break;\n            }\n            continue;\n        } else fail = 0;\n\n        apply(board, mi, mj, player);\n\n        player = player ^ 'x' ^ 'o';\n    }\n    rep(i, 0, 8) {\n        rep(j, 0, 8) cout << board[i][j];\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Point    //  x, y\n{\n  int x;\n  int y;\n};\n\n//  --------------------------------class Points\nclass Points\n{\n  public:\n    Points(int n = 64);\n    ~Points();\n    Point Get(int i);\n    void Set(int x, int y, int i);\n    int Size();\n    void Add_last(int x, int y);\n    void Add_last(Points& other);\n    void operator=(const Points& other);\n\n  private:\n    Point* m_points;\n    int m_size;\n};\n\nPoints::Points(int n)\n{\n  m_points = new Point[n];\n  m_size = 0;\n}\n\nPoints::~Points()\n{\n  delete[] m_points;\n}\n\ninline Point Points::Get(int i)\n{\n  return m_points[i];\n}\n\ninline void Points::Set(int x, int y, int i)\n{\n  m_points[i].x = x;\n  m_points[i].y = y;\n  ++m_size;\n}\n\ninline int Points::Size()\n{\n  return m_size;\n}\n\nvoid Points::Add_last(int x, int y)\n{\n  Set(x, y, m_size);\n}\n\nvoid Points::Add_last(Points& other)\n{\n  Point buf;\n  for (int i = 0, size = other.Size(); i < size; ++i)\n  {\n    buf = other.Get(i);\n    Add_last(buf.x, buf.y);\n  }\n}\n\nvoid Points::operator=(const Points& other)\n{\n  Point* new_points = new Point[64];\n\n  delete[] m_points;\n  m_points = new_points;\n  m_size = other.m_size;\n\n  copy(other.m_points, other.m_points + m_size, m_points);\n}\n\n//  --------------------------------class TableCloth\nclass TableCloth\n{\n  public:\n    TableCloth();\n    ~TableCloth();\n\n  public:\n    bool Turn();\n    void Show() const;\n\n  private:\n    bool put_coockie(Points& reverse_list);\n    void reverse_cookie(int x, int y);\n    void Find_place(Point& start, int x_dir, int y_dir, char cookie, Points& p);\n    bool CheckIndex(int i, int j);\n\n  private:\n    char** m_table_cloth;\n    bool m_turn_player;   //  true => マミ, false => CHARLOTTE\n};\n\nTableCloth::TableCloth()\n{\n  m_turn_player = true;\n  m_table_cloth = new char*[8];\n  for (int i = 0; i < 8; ++i)\n  {\n    m_table_cloth[i] = new char[8];\n  }\n\n  for (int i = 0; i < 8; ++i)\n  {\n    for (int j = 0; j < 8; ++j)\n    {\n      cin >> m_table_cloth[i][j];\n    }\n  }\n}\n\nTableCloth::~TableCloth()\n{\n  for (int i = 0; i < 8; ++i)\n  {\n    delete[] m_table_cloth[i];\n  }\n  delete[] m_table_cloth;\n}\n\nbool TableCloth::Turn()\n{\n  Points reverse_list;\n  if (! put_coockie(reverse_list) )\n  {\n    m_turn_player = !m_turn_player;\n    return false;\n  }\n\n  for (int i = 0, size = reverse_list.Size(); i < size; ++i)\n  {\n    reverse_cookie(reverse_list.Get(i).x, reverse_list.Get(i).y);\n  }\n\n  m_turn_player = !m_turn_player;\n  return true;\n}\n\nvoid TableCloth::Show() const\n{\n  for (int i = 0; i < 8; ++i)\n  {\n    for (int j = 0; j < 8; ++j)\n    {\n      cout << m_table_cloth[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool TableCloth::put_coockie(Points& reverse_list)\n{\n  char cookie = m_turn_player ? 'o' : 'x';\n  Point put_point = { -1, -1, };\n\n  int start_i_j  = ( m_turn_player ? 0 : 7 );\n  int end_i_j    = ( m_turn_player ? 8 : -1);\n  int change_num = ( m_turn_player ? 1 : -1);\n  for (int i = start_i_j; i != end_i_j; i += change_num)\n  {\n    for (int j = start_i_j; j != end_i_j; j += change_num)\n    {\n      if ( m_table_cloth[i][j] != '.' ) continue;\n      Point start = { i, j, };\n      Points buf_list;\n      for (int x = -1; x <= 1; ++x)\n      {\n        for (int y = -1; y <= 1; ++y)\n        {\n          if ( x == 0 and y == 0 ) continue;\n          Find_place(start, x, y, cookie, buf_list);\n        }\n      }\n      if (reverse_list.Size() < buf_list.Size() )\n      {\n        reverse_list = buf_list;\n        put_point.x = i;\n        put_point.y = j;\n      }\n    }\n  }\n\n  if ( put_point.x == -1 and put_point.y == -1 ) return false;\n  m_table_cloth[put_point.x][put_point.y] = cookie;\n  return true;\n}\n\ninline void TableCloth::reverse_cookie(int x, int y)\n{\n  m_table_cloth[x][y] = m_table_cloth[x][y] == 'o' ? 'x' : 'o';\n}\n\nvoid TableCloth::Find_place(Point& start, int x_dir, int y_dir, char cookie, Points& list)\n{\n  Points buf_points(8);\n  for (int i = start.x + x_dir, j = start.y + y_dir; ; i += x_dir, j += y_dir)\n  {\n    if (! CheckIndex(i, j) ) return;\n    if ( m_table_cloth[i][j] == '.') return;\n    if ( m_table_cloth[i][j] == cookie)\n    {\n      list.Add_last(buf_points);\n      return;\n    }\n    buf_points.Add_last(i, j);\n  }\n}\n\ninline bool TableCloth::CheckIndex(int i, int j)\n{\n  return (0 <= i and i < 8) and (0 <= j and j < 8);\n}\n\nint main(void)\n{\n  TableCloth table_cloth;\n  while (true)\n  {\n    bool mami = table_cloth.Turn();\n    bool charlotte = table_cloth.Turn();\n    if (! (mami or charlotte) ) break;\n  }\n\n  table_cloth.Show();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint cnt;\nvector<string> board(8);\nconst int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nbool search(vector<string>& brd, int x, int y, int d, char stone) {\n\tif(x < 0 || y < 0 || x >= 8 || y >= 8)\n\t\treturn false;\n\n\tif(brd[y][x] == '.')\n\t\treturn false;\n\n\tif(brd[y][x] == stone)\n\t\treturn true;\n\n\tif(search(brd, x + dx[d], y + dy[d], d, stone)) {\n\t\t++cnt;\n\t\tbrd[y][x] = stone;\n\t\treturn true;\n\t}\n\n\telse\n\t\treturn false;\n}\n\nint simulate(int x, int y, char stone) {\n\tvector<string> tmp(board);\n\tcnt = 0;\n\tfor(int d = 0; d < 8; ++d)\n\t\tsearch(tmp, x + dx[d], y + dy[d], d, stone);\n\n\treturn cnt;\n}\n\nvoid put(int x, int y, char stone) {\n\tboard[y][x] = stone;\n\tfor(int d = 0; d < 8; ++d)\n\t\tsearch(board, x + dx[d], y + dy[d], d, stone);\t\t\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int i = 0; i < 8; ++i)\n\t\tcin >> board[i];\n\n\twhile(true) {\n\t\tbool pass = false;\n\t\tint mx = 0, x, y;\n\t\tfor(int i = 0; i < 8; ++i) {\n\t\t\tfor(int j = 0; j < 8; ++j) {\n\t\t\t\tif(board[i][j] != '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst int num = simulate(j, i, 'o');\n\t\t\t\tif(mx < num) {\n\t\t\t\t\tmx = num;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(mx)\n\t\t\tput(x, y, 'o');\n\t\telse\n\t\t\tpass = true;\n\n\t\tmx = 0;\n\t\tfor(int i = 7; i >= 0; --i) {\n\t\t\tfor(int j = 7; j >= 0; --j) {\n\t\t\t\tif(board[i][j] != '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst int num = simulate(j, i, 'x');\n\t\t\t\tif(mx < num) {\n\t\t\t\t\tmx = num;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(mx)\n\t\t\tput(x, y, 'x');\n\t\telse if(pass)\n\t\t\tbreak;\n\t}\n\n\tfor(int i = 0; i < 8; ++i)\n\t\tcout << board[i] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n = 8;\nstring s[8];\nstring c = \"ox\";\nint dy[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dx[8] = {1, 0, -1, 1, -1, 1, -1, 0};\nbool contain(int y, int x){\n   return (0 <= y && y < n && 0 <= x && x < n);\n}\n\nint calc(char now, char op, int y, int x){\n    int res = 0;\n    rep(i, 0, 8){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        int cnt = 0;\n        rep(j, 0, 8){\n            if(!contain(ny, nx)) break;\n            if(s[ny][nx] == '.') break;\n            if(s[ny][nx] == now){\n                res += cnt;\n                break;\n            }\n            if(s[ny][nx] == op){\n                cnt++;\n            }\n            ny += dy[i];\n            nx += dx[i];\n        }\n    }\n    return res;\n}\n\nvoid update(char now, char op, int y, int x){\n    s[y][x] = now;\n    rep(i, 0, 8){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        int cnt = 0;\n        rep(j, 0, 8){\n            if(!contain(ny, nx)) break;\n            if(s[ny][nx] == '.') break;\n            if(s[ny][nx] == now){\n                int ty = y + dy[i];\n                int tx = x + dx[i];\n                rep(k, 0, cnt){\n                    s[ty][tx] = now;\n                    ty += dy[i];\n                    tx += dx[i];\n                }\n                break;\n            }\n            if(s[ny][nx] == op){\n                cnt++;\n            }\n            ny += dy[i];\n            nx += dx[i];\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    rep(i, 0, n){\n        cin >> s[i];\n    }\n    for(int ij = 0; ij < n * n; ij++){\n        char now = c[ij % 2];\n        char op = c[(ij + 1) % 2];\n        int MAX = 0, y = -1, x = -1;\n        if(ij % 2 == 0){\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    if(s[i][j] != '.') continue;\n                    int tmp = calc(now, op, i, j);\n                    if(tmp > MAX){\n                        MAX = tmp; y = i; x = j;\n                    }\n                }\n            }\n        }else{\n            repb(i, n - 1, 0){\n                repb(j, n - 1, 0){\n                    if(s[i][j] != '.') continue;\n                    int tmp = calc(now, op, i, j);\n                    if(tmp > MAX){\n                        MAX = tmp; y = i; x = j;\n                    }\n                }\n            }\n        }\n        if(MAX != 0){\n            update(now, op, y, x);\n            // cout << MAX << \" \" << y << \" \" << x << endl;\n            // rep(i, 0, 8){\n            //     cout << s[i] << endl;\n            // }    \n        }\n    }\n    rep(i, 0, n){\n        cout << s[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nvoid solve(vector<string>& s){\n    for(bool turn=true, pass=false; ; turn=!turn){\n        tuple<int, int, int, vector<string> > best = make_tuple(0, turn? -8: 0, turn? -8: 0, s); // {0, turn? -8: 0, turn? -8: 0, s}\n        rep(x, 8)rep(y, 8)if(s[x][y] == '.'){\n            char my = turn? 'o': 'x', your = turn? 'x': 'o';\n            int cnt = 0;\n            vector<string> t = s; t[x][y] = my;\n            for(int dx=-1; dx<=1; ++dx){\n                for(int dy=-1; dy<=1; ++dy){\n                    int nx = x + dx, ny = y + dy;\n                    if((dx|dy) == 0 || !inrect(nx, ny) || s[nx][ny] != your)continue;\n                    vector<string> tmp = t;\n                    while(inrect(nx, ny) && s[nx][ny] == your){\n                        tmp[nx][ny] = my; nx += dx; ny += dy;\n                    }\n                    if(inrect(nx, ny) && s[nx][ny] == my){\n                        cnt += max(abs(x - nx) - 1, abs(y - ny) - 1);\n                        t.swap(tmp);\n                    }\n                }\n            }\n            if(cnt)chmax(best, make_tuple(cnt, turn? -x: x, turn? -y: y, t)); // {cnt, turn? -x: x, turn? -y: y, t};\n        }\n        if(get<0>(best) == 0){\n            if(pass)break; else pass = true;\n        }\n        else{\n            if(pass)pass = false;\n            s.swap(get<3>(best));\n        }\n    }\n}\n\nint main(){\n    vector<string> s(8);\n    rep(i, 8)cin >> s[i];\n    solve(s);\n    rep(i, 8)cout << s[i] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n#define INF (1<<30)\n#define LINF (1LL <<60)\n\nint dy[8] = { 0,1,1,1,0,-1,-1,-1 };\nint dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nvector<vector<char>> masu(10, vector<char>(10, '.'));\n\nint get_cookie(int h, int w, int dicy, int dicx, char c) {\n\tint ret = 0;\n\tfor (int i = 0;;i++) {\n\t\tchar C = masu[h + dicy*i][w + dicx*i];\n\t\tif (C == c) {\n\t\t\tret++;\n\t\t}\n\t\telse if (C == '.') {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nvoid set_cookie(int h, int w, int dicy, int dicx, char c1,char c2) {\n\tfor (int i = 0;;i++) {\n\t\tchar C = masu[h + dicy*i][w + dicx*i];\n\t\tif (C == c1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (C == '.') {\n\t\t\treturn ;\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j <= i;j++) {\n\t\t\t\tmasu[h + dicy*j][w + dicx*j] = c2;\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tfor (int i = 1; i <= 8;i++)for (int j = 1; j <= 8;j++) cin >> masu[i][j];\n\n\tbool f = true;\n\twhile (f) {\n\t\tf = false;\n\t\tint mami[10][10] = { 0 };\n\t\tint mami_max = 0;\n\t\tfor (int r = 0; r < 2; r++) {\n\t\t\tfor (int i = 1; i <= 8;i++) {\n\t\t\t\tfor (int j = 1; j <= 8;j++) {\n\t\t\t\t\tif (masu[i][j] != '.')continue;\n\t\t\t\t\tint Sum = 0;\n\t\t\t\t\tfor (int k = 0; k < 8;k++) {\n\t\t\t\t\t\tif (masu[i + dy[k]][j + dx[k]] != 'x')continue;\n\t\t\t\t\t\tif (r == 0) {\n\t\t\t\t\t\t\tSum += get_cookie(i + dy[k], j + dx[k], dy[k], dx[k], 'x');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mami[i][j] == mami_max) {\n\t\t\t\t\t\t\tif (masu[i][j] != 'o') masu[i][j] = 'o';\n\t\t\t\t\t\t\tset_cookie(i + dy[k], j + dx[k], dy[k], dx[k], 'x', 'o');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (r == 0) {\n\t\t\t\t\t\tmami[i][j] = Sum;\n\t\t\t\t\t\tmami_max = max(mami[i][j], mami_max);\n\t\t\t\t\t}\n\t\t\t\t\telse if (mami[i][j] == mami_max) {\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tr = 2; i = 9; j = 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mami_max == 0) break;\n\t\t}\n\n\t\tint majo[10][10] = { 0 };\n\t\tint majo_max = 0;\n\t\tfor (int r = 0; r < 2; r++) {\n\t\t\tfor (int i = 8; i >= 1;i--) {\n\t\t\t\tfor (int j = 8; j >= 1;j--) {\n\t\t\t\t\tif (masu[i][j] != '.')continue;\n\t\t\t\t\tint Sum = 0;\n\t\t\t\t\tfor (int k = 0; k < 8;k++) {\n\t\t\t\t\t\tif (masu[i + dy[k]][j + dx[k]] != 'o')continue;\n\t\t\t\t\t\tif (r == 0) {\n\t\t\t\t\t\t\tSum += get_cookie(i + dy[k], j + dx[k], dy[k], dx[k], 'o');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (majo_max == majo[i][j]) {\n\t\t\t\t\t\t\tif (masu[i][j] != 'x') masu[i][j] = 'x';\n\t\t\t\t\t\t\tset_cookie(i + dy[k], j + dx[k], dy[k], dx[k], 'o', 'x');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (r == 0) {\n\t\t\t\t\t\tmajo[i][j] = Sum;\n\t\t\t\t\t\tmajo_max = max(majo[i][j], majo_max);\n\t\t\t\t\t}\n\t\t\t\t\telse if (majo_max == majo[i][j]) {\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tr = 2; i = 0; j = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (majo_max == 0)break;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 8;i++) {\n\t\tfor (int j = 1; j <= 8;j++) {\n\t\t\tcout << masu[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 1, 0, -1, -1, -1, 0, 1};\nvector<int> dx = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<vector<char>> place(vector<vector<char>> s, char c, int y, int x){\n  char c2;\n  if (c == 'o'){\n    c2 = 'x';\n  }\n  if (c == 'x'){\n    c2 = 'o';\n  }\n  s[y][x] = c;\n  for (int i = 0; i < 8; i++){\n    if (s[y + dy[i]][x + dx[i]] == c2){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      while (s[y2][x2] == c2){\n        y2 += dy[i];\n        x2 += dx[i];\n      }\n      if (s[y2][x2] == c){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        while (s[y2][x2] == c2){\n          s[y2][x2] = c;\n          y2 += dy[i];\n          x2 += dx[i];\n        }\n      }\n    }\n  }\n  return s;\n}\nint main(){\n  vector<vector<char>> s(10, vector<char>(10, '#'));\n  for (int i = 1; i <= 8; i++){\n    for (int j = 1; j <= 8; j++){\n      cin >> s[i][j];\n    }\n  }\n  bool prev = false;\n  char c = 'o';\n  while (1){\n    int cnt = 0;\n    for (int i = 1; i <= 8; i++){\n      for (int j = 1; j <= 8; j++){\n        if (s[i][j] == c){\n          cnt++;\n        }\n      }\n    }\n    vector<vector<char>> next;\n    int mx = -1;\n    if (c == 'o'){\n      for (int i = 1; i <= 8; i++){\n        for (int j = 1; j <= 8; j++){\n          if (s[i][j] == '.'){\n            vector<vector<char>> s2 = place(s, c, i, j);\n            int cnt2 = 0;\n            for (int k = 1; k <= 8; k++){\n              for (int l = 1; l <= 8; l++){\n                if (s2[k][l] == c){\n                  cnt2++;\n                }\n              }\n            }\n            if (cnt2 > cnt + 1 && cnt2 > mx){\n              mx = cnt2;\n              next = s2;\n            }\n          }\n        }\n      }\n      c = 'x';\n    } else {\n      for (int i = 8; i >= 1; i--){\n        for (int j = 8; j >= 1; j--){\n          if (s[i][j] == '.'){\n            vector<vector<char>> s2 = place(s, c, i, j);\n            int cnt2 = 0;\n            for (int k = 1; k <= 8; k++){\n              for (int l = 1; l <= 8; l++){\n                if (s2[k][l] == c){\n                  cnt2++;\n                }\n              }\n            }\n            if (cnt2 > cnt + 1 && cnt2 > mx){\n              mx = cnt2;\n              next = s2;\n            }\n          }\n        }\n      }\n      c = 'o';\n    }\n    if (mx == -1){\n      if (prev){\n        break;\n      } else {\n        prev = true;\n      }\n    } else {\n      prev = false;\n      swap(s, next);\n    }\n  }\n  for (int i = 1; i <= 8; i++){\n    for (int j = 1; j <= 8; j++){\n      cout << s[i][j];\n    }\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\ntypedef pair<int,int> pii;\nstruct cookie{\n  int x, y, n;\n};\nconst int dx[] = {1, 1, 1, 0, 0, -1, -1, -1}, dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\nconst char C[] = {'x', 'o'};\n  \nbool comp1(const cookie &a, const cookie &b)\n{\n  if(a.n != b.n)\n    return a.n > b.n;\n  else if(a.x != b.x)\n    return a.x < b.x;\n  else\n    return a.y < b.y;\n}\n\nbool comp2(const cookie &a, const cookie &b)\n{\n  if(a.n != b.n)\n    return a.n > b.n;\n  else if(a.x != b.x)\n    return a.x > b.x;\n  else\n    return a.y > b.y;\n}\n\nint main()\n{\n  char table[8][8];\n  REP(i,8) cin >> table[i];\n\n  bool t = false;\n  int pass = 0;\n  while(1){\n    set<pii> s;\n    REP(i,8){\n      REP(j,8){\n        if(table[i][j] == C[t]){\n          REP(k,8){\n            int x = i+dx[k], y = j+dy[k];\n            if(x >= 0 && x < 8 && y >= 0 && y < 8 && table[x][y] == '.')\n              s.insert(pii(x,y));\n          }\n        }\n      }\n    }\n    vector<cookie> v;\n    for(set<pii>::iterator i = s.begin(); i != s.end(); i++){\n      int r = 0;\n      REP(j,8){\n        int x = (*i).first+dx[j], y = (*i).second+dy[j];\n        if(x >= 0 && x < 8 && y >= 0 && y < 8 && table[x][y] == C[t]){\n          int n = 0;\n          bool flag = false;\n          while(x >= 0 && x < 8 && y >= 0 && y < 8){\n            if(table[x][y] == C[t]){\n              n++;\n            }else if(table[x][y] == '.'){\n              break;\n            }else{\n              flag = true;\n              break;\n            }\n            x += dx[j];\n            y += dy[j];\n          }\n          if(flag)\n            r += n;\n        }\n      }\n      if(r != 0){\n        struct cookie a;\n        a.x = (*i).first;\n        a.y = (*i).second;\n        a.n = r;\n        v.push_back(a);\n      }\n    }\n    if(v.empty()){\n      if(pass == 1){\n        REP(i,8){\n          REP(j,8){\n            cout << table[i][j];\n          }\n          cout << endl;\n        }\n        break;\n      }else{\n        pass++;\n        t = !t;\n        continue;\n      }\n    }\n    pass = 0;\n\n    if(t) sort(v.begin(),v.end(),comp2);\n    else sort(v.begin(),v.end(),comp1);\n    \n    struct cookie a = v[0];\n    table[v[0].x][v[0].y] = C[!t];\n    REP(i,8){\n      int x = a.x+dx[i], y = a.y+dy[i];\n      while(x >= 0 && x < 8 && y >= 0 && y < 8 && table[x][y] == C[t]){\n        x += dx[i];\n        y += dy[i];\n      }\n      if(x >= 0 && x < 8 && y >= 0 && y < 8 && table[x][y] == C[!t]){\n        x -= dx[i];\n        y -= dy[i];\n        while(x != a.x || y != a.y){\n          table[x][y] = C[!t];\n          x -= dx[i];\n          y -= dy[i];\n        }\n      }\n    }\n    t = !t;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nauto chmax = [](auto&& l, auto r) { return l < r ? l = r, 1 : 0; };\n\ntemplate <class It> auto rle(It first, It last) {\n  vector<pair<decltype(*first), int>> res;\n  for (; first != last; ++first) {\n    if (res.empty() or res.back().first != *first) {\n      res.emplace_back(*first, 1);\n    } else {\n      ++res.back().second;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  vector<string> s(8);\n  for (auto&& e : s) {\n    cin >> e;\n  }\n  auto in = [](int i, int j) {\n    return 0 <= i and i < 8 and 0 <= j and j < 8;\n  };\n  auto fn = [&](int i, int j, char c, bool ch = false) {\n    int res = 0;\n    for (int di = -1; di <= 1; ++di) {\n      for (int dj = -1; dj <= 1; ++dj) {\n        if (di or dj) {\n          string t;\n          for (int ni = i + di, nj = j + dj; in(ni, nj); ni += di, nj += dj) {\n            t += s[ni][nj];\n          }\n          auto v = rle(begin(t), end(t));\n          if (v.size() >= 2 and v[0].first == (c ^ 'o' ^ 'x') and v[1].first == c) {\n            res += v[0].second;\n            if (ch) {\n              s[i][j] = c;\n              for (int ni = i + di, nj = j + dj; in(ni, nj) and s[ni][nj] != c; ni += di, nj += dj) {\n                s[ni][nj] = c;\n              }\n            }\n          }\n        }\n      }\n    }\n    return res;\n  };\n  while (true) {\n    bool fo = false;\n    {\n      int mx = 0, mi = -1, mj = -1;\n      for (int i = 0; i < 8; ++i) {\n        for (int j = 0; j < 8; ++j) {\n          if (s[i][j] == '.' and chmax(mx, fn(i, j, 'o'))) {\n            mi = i, mj = j;\n          }\n        }\n      }\n      if (mx) {\n        fn(mi, mj, 'o', true);\n        fo = true;\n      }\n    }\n    bool fx = false;\n    {\n      int mx = 0, mi = -1, mj = -1;\n      for (int i = 8; i--; ) {\n        for (int j = 8; j--; ) {\n          if (s[i][j] == '.' and chmax(mx, fn(i, j, 'x'))) {\n            mi = i, mj = j;\n          }\n        }\n      }\n      if (mx) {\n        fn(mi, mj, 'x', true);\n        fx = true;\n      }\n    }\n    if (not fo and not fx) {\n      break;\n    }\n  }\n  for (auto e : s) {\n    cout << e << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing reversePiece = pair<pair<int, int>, vector<pair<int, int>>>;\n\n// 8x8 + 場外\nvector<vector<char>> board(10, vector<char>(10, '#'));\n\nvoid show() {\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 8; j++) {\n            cout << board[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvector<reversePiece> canMove(char myPiece) {\n    char enemiesPiece = myPiece == 'o' ? 'x' : 'o';\n    vector<reversePiece> moveList;\n    vector<int> dx = {-1, -1, 0, 1, 1, 1, 0, -1};\n    vector<int> dy = {0, 1, 1, 1, 0, -1, -1, -1};\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 8; j++) {\n            vector<pair<int, int>> cnt;\n            if (board[i][j] != '.') continue;\n            for (int k = 0; k < 8; k++) {\n                int y = i;\n                int x = j;\n                vector<pair<int, int>> oneWayCnt;\n                // int oneWayCnt = 0;\n                while (true) {\n                    y += dy[k];\n                    x += dx[k];\n                    if (board[y][x] == enemiesPiece)\n                        oneWayCnt.push_back(make_pair(y, x));\n                    else if (board[y][x] == myPiece && oneWayCnt.size()) {\n                        for (auto i : oneWayCnt) {\n                            cnt.push_back(i);\n                        }\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            if (cnt.size()) moveList.push_back(make_pair(make_pair(i, j), cnt));\n        }\n    }\n    return moveList;\n}\n\nreversePiece choosePut(char myPiece, vector<reversePiece> candidate) {\n    reversePiece ret = candidate[0];\n\n    // 貪欲に選択\n    for (int i = 0; i < candidate.size(); i++) {\n        if (ret.second.size() < candidate[i].second.size()) {\n            ret = candidate[i];\n        } else if (ret.second.size() == candidate[i].second.size()) {\n            if (myPiece == 'x') {\n                // お菓子の魔女は下左を優先\n                if (candidate[i].first.first > ret.first.first ||\n                    (candidate[i].first.first == ret.first.first &&\n                     candidate[i].first.second > ret.first.second))\n                    ret = candidate[i];\n            } else {\n                // まみは上右を優先\n                if (candidate[i].first.first < ret.first.first ||\n                    (candidate[i].first.first == ret.first.first &&\n                     candidate[i].first.second < ret.first.second))\n                    ret = candidate[i];\n            }\n        }\n    }\n    return ret;\n}\n\nvoid turnOver(char myPiece, reversePiece selectPiece) {\n    board[selectPiece.first.first][selectPiece.first.second] = myPiece;\n    for (auto i : selectPiece.second) {\n        board[i.first][i.second] = myPiece;\n    }\n}\n\nvoid game() {\n    // false でマミ\n    bool turn = false;\n    char myPiece, enemiesPiece;\n    int skipCnt = 0;\n    while (1) {\n        if (turn) {\n            myPiece = 'x';\n            enemiesPiece = 'o';\n        } else {\n            myPiece = 'o';\n            enemiesPiece = 'x';\n        }\n        // 動ける座標と候補を列挙\n        vector<reversePiece> canditate = canMove(myPiece);\n        // 打つ手がなければスキップ、どちらも打つ手がなければ終了\n        if (!canditate.size()) {\n            turn = !turn;\n            skipCnt++;\n            if (skipCnt == 2) break;\n            continue;\n        }\n        skipCnt = 0;\n        // 貪欲な方針に従って、選択\n        reversePiece selectPiece = choosePut(myPiece, canditate);\n        // ひっくり返す\n        turnOver(myPiece, selectPiece);\n        turn = !turn;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 8; j++) {\n            cin >> board[i][j];\n        }\n    }\n    game();\n    show();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> P;\n\nint cho,che;\nchar table[8][8];\nvector<P> v;\n\nconst int dx[8] = {0,0,1,1,1,-1,-1,-1};\nconst int dy[8] = {1,-1,0,-1,1,-1,0,1};\nconst char ch[3] = {'x','o'};\n\nvoid check(int x,int y,int turn,vector<P> &v){\n  char c = ch[turn],d = ch[1-turn];\n  int count = 0;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int cnt = 0;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tif(table[nx][ny] == c){\n\t  count += cnt;\n\t}\n\tbreak;\n      }\n\n      cnt++;\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }   \n\n  if(count == 0){\n    return;\n  }\n\n  if(turn){\n    v.push_back(P(-count,PA(x,y)));\n  }else{\n    v.push_back(P(-count,PA(-x,-y)));\n  }\n}\n\nvoid change(P a,int turn){\n  char c = ch[turn],d = ch[1-turn];\n\n  a.first = -a.first;\n\n  if(!turn){\n    a.second.first = -a.second.first;\n    a.second.second = -a.second.second;\n  }\n\n  table[a.second.first][a.second.second] = c;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int nx = a.second.first + dx[i];\n    int ny = a.second.second + dy[i];\n    vector<PA> v;\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tbreak;\n      }\n\n      v.push_back(PA(nx,ny));\n      nx += dx[i];\n      ny += dy[i];\n    }\n\n    if(!(0 > nx || 0 > ny || nx >= 8 || ny >= 8) && table[nx][ny] == c){\n      while(true){     \n\tif(nx == a.second.first && ny == a.second.second){\n\t  break;\n\t}\n\ttable[nx][ny] = c;  \n\tnx -= dx[i];\n\tny -= dy[i];\n      }\n    }\n\n  } \n\n  if(turn){\n    cho += a.first+1;\n    che -= a.first;\n  }else{\n    cho -= a.first;\n    che += a.first+1;\n  }\n}\n\nint main(){\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cin >> table[i][j];\n\n      if(table[i][j] == 'o'){\n\tcho++;\n      }else if(table[i][j] == 'x'){\n\tche++;\n      }\n    }\n  }\n\n  //true mami ------ false witch\n  bool turn = true;\n\n  while(true){\n    vector<P> v;\n \n    if(!cho || !che || cho+che == 64){\n      break;\n    }\n \n    for(int i = 0 ; i < 8 ; i++){\n      for(int j = 0 ; j < 8 ; j++){\n\tif(table[i][j] == '.'){\n\t  int n = turn ? 1 : 0;\n\t  check(i,j,n,v);\n\t}\n      }\n    }\n  \n    if(v.size() > 0){\n      int n = turn ? 1 : 0;\n      sort(v.begin(),v.end());\n      change(v[0],n);\n    }\n\n    turn = !turn;\n  }\n\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cout << table[i][j];\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  vector<vector<int>> field(8,vector<int>(8,0));\n  int vecx[8]={-1,-1,-1,0,0,1,1,1};\n  int vecy[8]={-1,0,1,-1,1,-1,0,1};\n  string s;\n  for(int i=0;i<8;i++){\n    cin >> s;\n    for(int j=0;j<8;j++){\n      if(s[j]=='o'){\n        field[i][j]=1;\n      }else if(s[j]=='x'){\n        field[i][j]=2;\n      }\n    }\n  }\n  bool turn=true; //true:o false:x\n  bool passed=false;\n  int count,okikae,maxokikae,x,y;\n  int posx,posy;\n  int flag,f;\n  while(1){\n    posx=posy=-1;\n    maxokikae=0;\n    flag=0;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n        if(!field[i][j]){\n          okikae=0;\n          f=0;\n          for(int k=0;k<8;k++){\n            x=j+vecx[k];\n            y=i+vecy[k];\n            count=0;\n            if(0<=y&&y<=7&&0<=x&&x<=7){\n              while(field[y][x]==(turn?2:1)){\n                count++;\n                x+=vecx[k];\n                y+=vecy[k];\n                if(y<0||y>7||x<0||x>7){\n                  x-=vecx[k];\n                  y-=vecy[k];\n                  break;\n                }\n              }\n              if(field[y][x]==(turn?1:2)){\n                okikae+=count;\n                f+=(1<<k);\n              }\n            }\n          }\n          if(okikae>maxokikae){\n            maxokikae=okikae;\n            posx=j;\n            posy=i;\n            flag=f;\n          }else if(okikae==maxokikae){\n            if(!turn){\n              posx=j;\n              posy=i;\n              flag=f;\n            }\n          }\n        }\n      }\n    }\n    if(maxokikae==0){\n      if(passed){\n        for(int i=0;i<8;i++){\n          for(int j=0;j<8;j++){\n            cout << (field[i][j]?(field[i][j]==1?'o':'x'):'.');\n          }\n          cout <<endl;\n        }\n        return 0;\n      }else{\n        cout << (turn?'o':'x') << endl;\n        passed=true;\n      }\n    }else{\n      // cout << (turn?'o':'x') << endl;\n      // cout << \"(\" << posx << \",\" << posy << \")\" << endl;\n      passed=false;\n      field[posy][posx]=(turn?1:2);\n      for(int k=0;k<8;k++){\n        if(flag&(1<<k)){\n          x=posx+vecx[k];\n          y=posy+vecy[k];\n          if(0<=y&&y<=7&&0<=x&&x<=7){\n            while(field[y][x]==(turn?2:1)){\n              field[y][x]=(turn?1:2);\n              x+=vecx[k];\n              y+=vecy[k];\n              if(y<0||y>7||x<0||x>7){\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    turn=(!turn);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n\n  int dx[8] = { -1, -1, -1,  0,  0,  1,  1,  1 };\n  int dy[8] = { -1,  0,  1, -1,  1, -1,  0,  1 };\n\n  vector< string > map;\n\n  string input;\n\n  for ( int i = 0; i < 8; i++ ) {\n\n    cin >> input;\n\n    map.push_back( input );\n\n  }\n\n  while( true ) {\n\n    bool flag = false;\n\n    for ( int i = 0; i < 2; i++ ) {\n      char my, en;\n      if ( i == 0 ) {\n\tmy = 'o';\n\ten = 'x';\n      }else {\n\tmy = 'x';\n\ten = 'o';\n      }\n      int cnt = 0;\n      int cx, cy, dr = 0;\n      for ( int y = 0; y < 8; y++ ) {\n\tfor ( int x = 0; x < 8; x++ ) {\n\t  if ( map[y][x] != '.' ) continue;\n\n\t  int cc = 0;\n\t  int cdr = 0;\n\t  for ( int j = 0; j < 8; j++ ) {\n\t    int c = 0;\n\t    while( true ) {\n\t      int hx = x+dx[j]*(c+1);\n\t      int hy = y+dy[j]*(c+1);\n\t      if ( hx < 0 || hx >= 8 || hy < 0 || hy >= 8 ) break;\n\t      if ( map[hy][hx] == en ) {\n\t\tc++;\n\t\tcontinue;\n\t      }else if ( map[hy][hx] == my ) {\n\t\tcc += c;\n\t\tcdr |= ( 1 << j );\n\t      }\n\t      break;\n\t    }\n\t  }\n\t  if ( cc == 0 ) continue;\n\t  if ( cc == cnt ) {\n\t    if ( i == 0 ) {\n\t      if ( y > cy ) continue;\n\t      if ( y == cy && x > cx ) continue;\n\t    }else {\n\t      if ( y < cy ) continue;\n\t      if ( y == cy && x < cx ) continue;\n\t    }\n\t  }else if ( cc < cnt ) {\n\t    continue;\n\t  }\n\t  cx = x;\n\t  cy = y;\n\t  dr = cdr;\n\t  cnt = cc;\n\t}\n      }\n\n      if ( cnt > 0 ) {\n\tflag = true;\n\tmap[cy][cx] = my;\n\tfor ( int j = 0; j < 8; j++ ) {\n\t  if ( ( dr & ( 1 << j ) ) != 0 ) {\n\t    for ( int k = 1; true; k++ ) {\n\t      int hx = cx+dx[j]*k;\n\t      int hy = cy+dy[j]*k;\n\t      if ( map[hy][hx] == my ) break;\n\t      map[hy][hx] = my;\n\t    }\n\t  }\n\t}\n      }\n\n    }\n\n    if ( flag == false ) break;\n\n  }\n\n  for ( int i = 0; i < 8; i++ ) {\n    cout << map[i] << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nchar board[8][8];\n\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\nint mami_dfs(int x,int y,int cnt,int idx){\n  int nx=x+dx[idx],ny=y+dy[idx];\n  if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n    cnt++;\n    return mami_dfs(nx,ny,cnt,idx);\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n    return cnt;\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n    return 0;\n  }\n  return 0;\n}\n\nint magi_dfs(int x,int y,int cnt,int idx){\n  int nx=x+dx[idx],ny=y+dy[idx];\n  if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n    cnt++;\n    return magi_dfs(nx,ny,cnt,idx);\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n    return cnt;\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n    return 0;\n  }\n  return 0;\n}\n\nint mami_count(int x,int y){//(x,y)??????????????¨?????????????????°\n  int res=0;\n  for(int i=0;i<8;i++) res+=mami_dfs(x,y,0,i);\n  return res;\n}\n\nint magi_count(int x,int y){//(x,y)??????????????¨?????????????????°\n  int res=0;\n  for(int i=0;i<8;i++) res+=magi_dfs(x,y,0,i);\n  return res;\n}\n\nint mami_solve(){//???????????????????????¶???\n  int ma=-1,x,y;\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n    if(board[i][j]=='.' && mami_count(i,j)>ma){\n      ma=mami_count(i,j);\n      x=i;y=j;\n    }\n  }//?????§?????????????????´???\n  if(ma<1) return false;\n  board[x][y]=='o';\n  for(int i=0;i<8;i++){\n    int tmp=mami_dfs(x,y,0,i);\n    for(int j=1;j<=tmp;j++){\n      board[x+dx[i]*j][y+dy[i]*j]='o';\n    }\n  }\n  return true;\n}\n\nbool magi_solve(){//???????????????????????¶???\n  int ma=-1,x,y;\n  for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n    if(board[i][j]=='.'&&magi_count(i,j)>ma){\n      ma=magi_count(i,j);\n      x=i;y=j;\n    }\n  }//?????§?????????????????´???\n  if(ma<1) return false;\n  board[x][y]='x';\n  for(int i=0;i<8;i++){\n    int tmp=magi_dfs(x,y,0,i);\n    for(int j=1;j<=tmp;j++){\n      board[x+dx[i]*j][y+dy[i]*j]='x';\n    }\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=mami_solve();\n    magi_flag=magi_solve();\n  //  cout<<mami_flag<<\" \"<<magi_flag<<endl;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX_N 12\n#define MAX_T 10000\n\nint x[MAX_N][MAX_N];\nint z[8],y[8];\nchar c,T[4]=\".ox\";\n\nint main(){\n\tfor(int i=1;i<=8;i++){\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tcin>>c;\n\t\t\tif(c=='o'){\n\t\t\t\tx[i][j]=1;\n\t\t\t}\n\t\t\tif(c=='x'){\n\t\t\t\tx[i][j]=2;\n\t\t\t}\n\t\t\tif(c=='.'){\n\t\t\t\tx[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<MAX_T;i++){\n\t\tint dx[8]={0,1,1,1,0,-1,-1,-1};\n\t\tint dy[8]={-1,-1,0,1,1,1,0,-1};\n\t\tfor(int h=2;h>0;h--){\n\t\t\tint score=0,maxn=0,cnt=0,X=0,Y=0,cx=0,cy=0;\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tfor(int k=1;k<=8;k++){\n\t\t\t\t\tif(x[j][k]==0){\n\t\t\t\t\t\tscore=0;\n\t\t\t\t\t\tfor(int l=0;l<8;l++){\n\t\t\t\t\t\t\tz[l]=0;\n\t\t\t\t\t\t\tcnt=0;\n\t\t\t\t\t\t\tcx=j+dx[l];cy=k+dy[l];\n\t\t\t\t\t\t\twhile(cx>=1 && cx<=8 && cy>=1 && cy<=8){\n\t\t\t\t\t\t\t\tif(x[cx][cy]==0){\n\t\t\t\t\t\t\t\t\tgoto E;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(x[cx][cy]!=h){\n\t\t\t\t\t\t\t\t\tgoto F;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\tcx+=dx[l];cy+=dy[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto E;\nF:;\n\t\t\t\t\t\t\tscore+=cnt;\n\t\t\t\t\t\t\tz[l]=1;\nE:;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(score>maxn || (score==maxn && h==1)){\n\t\t\t\t\t\t\tmaxn=score;X=j;Y=k;\n\t\t\t\t\t\t\tfor(int l=0;l<8;l++){y[l]=z[l];}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxn>=1){\n\t\t\t\tx[X][Y]=(3-h);\n\t\t\t\tfor(int l=0;l<8;l++){\n\t\t\t\t\tif(y[l]==1){\n\t\t\t\t\t\tcx=X+dx[l];cy=Y+dy[l];\n\t\t\t\t\t\twhile(cx>=1 && cx<=8 && cy>=1 && cy<=8){\n\t\t\t\t\t\t\tif(x[cx][cy]!=h){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx[cx][cy]=(3-h);\n\t\t\t\t\t\t\tcx+=dx[l];cy+=dy[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=8;i++){\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tcout<<T[x[i][j]];\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<string> v(8);\n\tREP(i, 8)cin >> v[i];\n\t\n\t\n\tREP(t, INF) {\n\t\tint cnt = 0;\n\t\tREP(i, 8)REP(j, 8)if (v[i][j] == '.')cnt++;\n\t\tif (cnt == 0)break;\n\t\tint p = -1, q = -1, cmax = -1;\n\t\tif (t % 2 == 0) {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'x')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\tif (tmp != 0)s.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax < c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\n\t\t\t\tv[p][q] = 'o';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'x')v[ni][nj] = 'o';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tvi m;\n\t\t\tREP(i, 8) {\n\t\t\t\tREP(j, 8) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tvi s;\n\t\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\t\tint ni = i, nj = j;\n\t\t\t\t\t\t\tint tmp = 0;\n\n\t\t\t\t\t\t\tREP(l, INF) {\n\t\t\t\t\t\t\t\tni += dx[k], nj += dy[k];\n\t\t\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= 8 || nj >= 8)break;\n\t\t\t\t\t\t\t\tif (v[ni][nj] == 'o')tmp++;\n\t\t\t\t\t\t\t\telse if (v[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\tif (tmp != 0)s.push_back(k);\n\t\t\t\t\t\t\t\t\tc += tmp;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cmax <= c) {\n\t\t\t\t\t\t\tcmax = c, p = i, q = j;\n\t\t\t\t\t\t\tm = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmax <= 0)continue;\n\t\t\telse {\n\n\t\t\t\tv[p][q] = 'x';\n\t\t\t\tREP(j, m.size()) {\n\t\t\t\t\tint ni = p, nj = q;\n\t\t\t\t\tREP(i, INF) {\n\t\t\t\t\t\tni += dx[m[j]], nj += dy[m[j]];\n\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < 8 && nj < 8 && v[ni][nj] == 'o')v[ni][nj] = 'x';\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nvector<vector<int>> v;\nvector<int> dx{1, 1, 1, 0, -1, -1, -1, 0};\nvector<int> dy{-1, 0, 1, 1, 1, 0, -1, -1};\n\npair<int, vector<vector<int>>> put(int x, int y, int side){\n    if(v[x][y] != 0)\n        return make_pair(0, v);\n    auto w = v;\n    w[x][y] = side;\n    int cnt = 0;\n    for(int d = 0; d < 8; ++d){\n        int px = x, py = y;\n        bool fl = true;\n        while(1){\n            int nx = px + dx[d];\n            int ny = py + dy[d];\n            px = nx, py = ny;\n            if(px < 0 || py < 0 || px >= 8 || py >= 8 || w[px][py] == 0){\n                fl = false;\n                break;\n            }\n            if(w[px][py] == side)\n                break;\n        }\n        if(fl){\n            while(px != x || py != y){\n                if(w[px][py] != side)\n                    ++cnt;\n                w[px][py] = side;\n                px -= dx[d];\n                py -= dy[d];\n            }\n        }\n    }\n    return make_pair(cnt, w);\n}\n\nvector<vector<int>> sim(int side){\n    vector<vector<int>> w(8, vector<int>(8, 0));\n    for(int i = 0; i < 8; ++i)\n        for(int j = 0; j < 8; ++j)\n            w[i][j] = put(i, j, side).first;\n    return w;\n}\n\nbool solve(){\n    v.assign(8, vector<int>(8, 0));\n    for(int i = 0; i < 8; ++i){\n        string s;\n        cin >> s;\n        for(int j = 0; j < 8; ++j){\n            if(s[j] == 'o')\n                v[i][j] = 1;\n            if(s[j] == 'x')\n                v[i][j] = 2;\n            if(s[j] == '.')\n                v[i][j] = 0;\n        }\n    }\n\n    auto c1 = [](auto x, auto y){\n        if(x.first != y.first)\n            return x > y;\n        return x.second < y.second;\n    };\n    auto c2 = [](auto x, auto y){\n        if(x.first != y.first)\n            return x > y;\n        return x.second > y.second;\n    };\n\n    for(int i = 0; i < 100; ++i){\n        auto res = sim(i % 2 + 1);\n        vector<pair<int,pair<int,int>>> g;\n        for(int j = 0; j < 8; ++j)\n            for(int k = 0; k < 8; ++k)\n                g.emplace_back(res[j][k], make_pair(j, k));\n        if(i % 2 == 0)\n            sort(g.begin(), g.end(), c1);\n        else\n            sort(g.begin(), g.end(), c2);\n        if(g[0].first == 0)\n            continue;\n        v = put(g[0].second.first, g[0].second.second, i % 2 + 1).second;\n    }\n    string st = \".ox\";\n    for(int i = 0; i < 8; ++i){\n        for(int j = 0; j < 8; ++j)\n            cout << st[v[i][j]];\n        cout << endl;\n    }\n    return true;\n}\n\nsigned main(){\n    solve();\n    // while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++)\n#define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++)\n#define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n#define len(x) ((ll)(x).length())\n\nstruct Choice {\n    ll x, y, cnt;\n};\n\nconst ll d[8][2] = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}};\nvector<string> s;\n\nll g(ll x, ll y, char c) {\n    ll ans = 0;\n    rep(i, 8) {\n        ll ny = y, nx = x, cnt = 0;\n        bool clr = false;\n        while(true) {\n            ny += d[i][1];\n            nx += d[i][0];\n            if ((ny < 0) || (ny >= 8) || (nx < 0) || (nx >= 8)) {\n                break;\n            }\n            if (s[ny][nx] == '.') {\n                break;\n            }\n            if (s[ny][nx] == c) {\n                clr = true;\n                break;\n            }\n            else {\n                cnt++;\n            }\n        }\n        if (clr) ans += cnt;\n    }\n    return ans;\n}\n\nChoice f(char c) {\n    Choice ans;\n    ans.cnt = 0;\n    ll plus = (c == 'o') ? 1 : -1;\n    ll x, y = (plus == 1) ? 0 : 7;\n    while((y >= 0) && (y < 8)) {\n        x = (plus == 1) ? 0 : 7;\n        while((x >= 0) && (x < 8)) {\n            if (s[y][x] != '.') {\n                x += plus;\n                continue;\n            }\n            ll v = g(x, y, c);\n            if (v > ans.cnt) {\n                ans.cnt = v;\n                ans.x = x;\n                ans.y = y;\n            }\n            x += plus;\n        }\n        y += plus;\n    }\n    return ans;\n}\n\nvoid h(ll x, ll y, char c) {\n    s[y][x] = c;\n    rep(i, 8) {\n        ll ny = y, nx = x;\n        bool rev = false;\n        while(true) {\n            ny += d[i][1];\n            nx += d[i][0];\n            if ((ny < 0) || (ny >= 8) || (nx < 0) || (nx >= 8)) break;\n            if (s[ny][nx] == '.') break;\n            if (s[ny][nx] == c) {\n                rev = true;\n                break;\n            }\n        }\n        if (!rev) continue;\n        ny = y; nx = x;\n        while(true) {\n            ny += d[i][1];\n            nx += d[i][0];\n            if ((ny < 0) || (ny >= 8) || (nx < 0) || (nx >= 8)) break;\n            if (s[ny][nx] == c) break;\n            s[ny][nx] = c;\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // ifstream in(\"input.txt\");\n    // cin.rdbuf(in.rdbuf());\n    s.resize(8);\n    rep(i, 8) cin >> s[i];\n    while(true) {\n        Choice co = f('o');\n        if (co.cnt > 0) h(co.x, co.y, 'o');\n        Choice cx = f('x');\n        if (cx.cnt > 0) h(cx.x, cx.y, 'x');\n        if ((co.cnt == 0) && (cx.cnt == 0)) break;\n    }\n    rep(i, 8) cout << s[i] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint diffField(vs beforeField, vs afterField) {\n\tint diffPoint = -1;\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tif(beforeField[i][j] != afterField[i][j]) {\n\t\t\t\tdiffPoint++;\n\t\t\t}\n\t\t}\n\t}\n\treturn diffPoint;\n}\n\nvs updateField(vs field, int x, int y, char c) {\n\tREP(d, 8) {\n\t\tint nx = x, ny = y, step = 1;\n\t\twhile(true) {\n\t\t\tnx = x+dx[d]*step, ny = y+dy[d]*step;\n\t\t\tif(nx < 0 || 8 <= nx || ny < 0 || 8 <= ny || field[ny][nx] == '.') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[ny][nx] == c) {\n\t\t\t\tFOR(i, 1, step) {\n\t\t\t\t\tfield[y+dy[d]*i][x+dx[d]*i] = c;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t}\n\n\tfield[y][x] = c;\n\treturn field;\n}\n\npii searchOPoint(vs field) {\n\tpii res(-1, -1);\n\tint maxDiff = 0;\n\tREP(i, 8) {\n\t\tREP(j, 8) {\n\t\t\tif(field[i][j] == '.') {\n\t\t\t\tvs newField = updateField(field, j, i, 'o');\n\t\t\t\tint newDiff = diffField(field, newField);\n\t\t\t\tif(maxDiff < newDiff) {\n\t\t\t\t\tmaxDiff = newDiff;\n\t\t\t\t\tres = pii(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\npii searchXPoint(vs field) {\n\tpii res(-1, -1);\n\tint maxDiff = 0;\n\tfor(int i = 7; i >= 0; i--) {\n\t\tfor(int j = 7; j >= 0; j--) {\n\t\t\tif(field[i][j] == '.') {\n\t\t\t\tvs newField = updateField(field, j, i, 'x');\n\t\t\t\tint newDiff = diffField(field, newField);\n\t\t\t\tif(maxDiff < newDiff) {\n\t\t\t\t\tmaxDiff = newDiff;\n\t\t\t\t\tres = pii(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tvs field(8);\n\tREP(i, 8) {\n\t\tcin >> field[i];\n\t}\n\n\tbool updated = true;\n\twhile(updated) {\n\t\tupdated = false;\n\t\tpii oPoint = searchOPoint(field);\n\t\tif(oPoint.first != -1) {\n\t\t\tupdated = true;\n\t\t\tfield = updateField(field, oPoint.first, oPoint.second, 'o');\n\t\t}\n\n\t\tpii xPoint = searchXPoint(field);\n\t\tif(xPoint.first != -1) {\n\t\t\tupdated = true;\n\t\t\tfield = updateField(field, xPoint.first, xPoint.second, 'x');\n\t\t}\n\t}\n\t\n\tREP(i, 8) {\n\t\tcout << field[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#include <array>\n\nusing namespace std;\nvector<vector<char>>data;\n\nint dx[] = { 0 , 1 , 1 , 1 , 0 , -1 , -1 , -1 };\nint dy[] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 };\n\nint check ( int i , int j , char x , char y , int z )\n{\n\t//vector<vector<char>>data2 = data;\n\tif( data[i][j] != '.' )return 0;\n\tint memo = 0;\n\tfor( size_t k = 0; k < 8; k++ )\n\t{\n\t\tint t = 1;\n\t\twhile( data[i + t* dx[k]][j + t*dy[k]] == y )\n\t\t{\n\t\t\tt++;\n\t\t}\n\t\tif( data[i + t* dx[k]][j + t*dy[k]] == x )\n\t\t{\n\t\t\tmemo += t - 1;\n\n\t\t\tif( z )\n\t\t\t{\n\t\t\t\tfor( size_t l = 0; l < t; l++ )\n\t\t\t\t{\n\t\t\t\t\tdata[i + l* dx[k]][j + l*dy[k]] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo;\n}\n\nint func ( bool x )\n{\n\tint memo = 0;\n\tpair<int , int>d;\n\tif( x )\n\t{\n\t\tfor( int i = 8; i > 0; i-- )\n\t\t{\n\t\t\tfor( int j = 8; j > 0; j-- )\n\t\t\t{\n\t\t\t\tint memo2 = check ( i , j , 'x' , 'o' , 0 );\n\t\t\t\tif( memo < memo2 )\n\t\t\t\t{\n\t\t\t\t\td.first = i;\n\t\t\t\t\td.second = j;\n\t\t\t\t\tmemo = memo2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( memo )\n\t\tcheck ( d.first , d.second , 'x' , 'o' , 1 );\n\t} else\n\t{\n\t\tfor( int i = 1; i < 9; i++ )\n\t\t{\n\t\t\tfor( int j = 1; j < 9; j++ )\n\t\t\t{\n\t\t\t\tint memo2 = check ( i , j , 'o' , 'x' , 0 );\n\t\t\t\tif( memo < memo2 )\n\t\t\t\t{\n\t\t\t\t\td.first = i;\n\t\t\t\t\td.second = j;\n\t\t\t\t\tmemo = memo2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( memo )\n\t\tcheck ( d.first , d.second , 'o' , 'x' , 1 );\n\t}\n\treturn memo;\n}\n\nint main ()\n{\n\tdata.resize ( 10 );\n\tfor( size_t i = 0; i < 10; i++ )\n\t{\n\t\tdata[i].resize ( 10 );\n\t\tfor( size_t j = 0; j < 10; j++ )\n\t\t{\n\t\t\tif( i == 0 || i == 9 || j == 0 || j == 9 )\n\t\t\t{\n\t\t\t\tdata[i][j] = '#';\n\t\t\t} else\n\t\t\t{\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint f = 1;\n\twhile( f )\n\t{\n\t\tf = 0;\n\t\tf += func ( 0 );\n\t\tf += func ( 1 );\n\n\t}\n\tfor( size_t i = 1; i <= 8; i++ )\n\t{\n\t\tfor( size_t j = 1; j <= 8; j++ )\n\t\t{\n\t\t\tcout << data[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define all(i) i.rbegin(), i.rend()\n\nusing namespace std;\n\nint cri = 0;\nstruct max_st { int x, y, in_x, in_y, num; };\nbool com_m(max_st &t0, max_st &t1)\n{\n\tif (t0.num == t1.num)\n\t{\n\t\tif (t0.y == t1.y) { return t0.x > t1.x; }\n\t\treturn t0.y > t1.y;\n\t}\n\treturn t0.num < t1.num;\n}\nbool com_w(max_st &t0, max_st &t1)\n{\n\tif (t0.num == t1.num)\n\t{\n\t\tif (t0.y == t1.y) { return t0.x < t1.x; }\n\t\treturn t0.y < t1.y;\n\t}\n\treturn t0.num < t1.num;\n}\nvoid m_body(int tar, int x, int y, int in_x, int in_y, vector<max_st> &max, vector<vector<int>> &dat)\n{\n\tint max_num = 0;\n\twhile (1)\n\t{\n\t\tx += in_x; y += in_y;\n\t\tif (x < 0 || x >= 7 || y < 0 || y >= 7) { return; }\n\t\telse if (dat[x][y] != tar && max_num == 0) {  return; }\n\t\telse if (dat[x][y] == tar) { max_num++; continue; }\n\t\telse if (dat[x][y] > 0 && max_num > 0)\n\t\t{\n\t\t\tmax.push_back({ x - (in_x * (max_num + 1)), y - (in_y * (max_num + 1)), in_x, in_y, max_num });\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid m_head(int tar, vector<vector<int>> &dat)\n{\n\tvector<max_st> max(1);\n\trep(y, 8) rep(x, 8)\n\t{\n\t\tif (dat[x][y] == 0)\n\t\t{\n\t\t\tm_body(tar, x, y, 0, 1, max, dat);\n\t\t\tm_body(tar, x, y, 1, 1, max, dat);\n\t\t\tm_body(tar, x, y, 1, 0, max, dat);\n\t\t\tm_body(tar, x, y, 1, -1, max, dat);\n\t\t\tm_body(tar, x, y, 0, -1, max, dat);\n\t\t\tm_body(tar, x, y, -1, -1, max, dat);\n\t\t\tm_body(tar, x, y, -1, 0, max, dat);\n\t\t\tm_body(tar, x, y, -1, 1, max, dat);\n\t\t}\n\t}\n\tint cc = 0;\n\tif (tar == 1) { cc = 2; sort(all(max), com_m); }\n\telse if (tar == 2) { cc = 1; sort(all(max), com_w); }\n\tif (cri >= 2)\n\t{\n\t\trep(y, 8)\n\t\t{\n\t\t\trep(x, 8)\n\t\t\t{\n\t\t\t\tif (dat[x][y] == 0) { printf(\".\"); }\n\t\t\t\telse if (dat[x][y] == 1) { printf(\"x\"); }\n\t\t\t\telse if (dat[x][y] == 2) { printf(\"o\"); }\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t\texit(0);\n\t}\n\telse if (max[0].num == 0) { cri++; }\n\telse\n\t{\n\t\trep(i, max[0].num + 1)\n\t\t{\n\t\t\tdat[max[0].x][max[0].y] = cc;\n\t\t\tmax[0].x += max[0].in_x;\n\t\t\tmax[0].y += max[0].in_y;\n\t\t}\n\t\tprintf(\"(%d, %d) (%d, %d) %d %d\\n\", max[0].x, max[0].y, max[0].in_x, max[0].in_y, max[0].num, cri);\n\t\trep(y, 8)\n\t\t{\n\t\t\trep(x, 8)\n\t\t\t{\n\t\t\t\tif (dat[x][y] == 0) { printf(\".\"); }\n\t\t\t\telse if (dat[x][y] == 1) { printf(\"x\"); }\n\t\t\t\telse if (dat[x][y] == 2) { printf(\"o\"); }\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t}\n}\nint main()\n{\n\tvector<vector<int>> dat(8, vector<int>(8, 0));\n\trep(y, 8) rep(x, 8) \n\t{\n\t\tchar ch; cin >> ch;\n\t\tif (ch == 'o') { dat[x][y] = 2; }\n\t\telse if (ch == 'x') { dat[x][y] = 1; }\n\t}\n\twhile (1)\n\t{\n\t\tm_head(1, dat); // ?????????????????????\n\t\tm_head(2, dat); // ????\\??????????\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nint dx[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n\nvector<vector<int>>field(8, vector<int>(8));\nbool ok(int y, int x) {\n\treturn y >= 0 && y <= 7 && x >= 0 && x <= 7;\n}\n\nint turn(bool mami,vector<vector<int>>&field,const int y,const int x) {\n\n\tfield[y][x] = mami ? 1 : 2;\n\tint changenum = 0;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tint num = 0;\n\t\tif (!ok(ny, nx))continue;\n\t\tif ((mami&&field[ny][nx] == 2) || (!mami&&field[ny][nx] == 1)) {\n\t\t\twhile (1) {\n\t\t\t\tnx += dx[i];\n\t\t\t\tny += dy[i];\n\t\t\t\tnum++;\n\t\t\t\tif (!ok(ny, nx))break;\n\t\t\t\tif ((mami&&field[ny][nx] == 2) || (!mami&&field[ny][nx] == 1)) {\n\n\t\t\t\t}\n\t\t\t\telse if (!field[ny][nx]) {\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int a = 1; a <= num; ++a) {\n\t\t\t\t\t\tfield[y + dy[i] * a][x + dx[i] * a] = mami ? 1 : 2;\n\t\t\t\t\t}\n\t\t\t\t\tchangenum += num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn changenum;\n}\nint main() {\n\tfor (int i = 0; i < 8; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (st[j] == 'o') {\n\n\t\t\t\tfield[i][j] = 1;\n\t\t\t}\n\t\t\telse if (st[j] == 'x') {\n\t\t\t\tfield[i][j] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tbool mami = true;\n\tbool flag = true;\n\twhile (flag) {\n\t\tflag = false;\n\n\n\t\tvector<vector<int>>nums(8,vector<int>(8));\n\n\t\tfor (int y = 0; y < 8; ++y) {\n\t\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\t\tif (!field[y][x]) {\n\t\t\t\t\tvector<vector<int>>cfield(field);\n\t\t\t\t\tnums[y][x] = turn(mami, cfield, y, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = 0;\n\t\tint max_y;\n\t\tint max_x = 0;\n\t\tif (mami) {\n\t\t\tfor (int y = 0; y < 8; ++y) {\n\t\t\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\t\t\tif (nums[y][x]>amax) {\n\t\t\t\t\t\tamax = nums[y][x];\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int y = 7; y >=0; --y) {\n\t\t\t\tfor (int x = 7; x >=0; --x) {\n\t\t\t\t\tif (nums[y][x]>amax) {\n\t\t\t\t\t\tamax = nums[y][x];\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amax == 0)break;\n\t\telse {\n\t\t\tflag = true;\n\t\t\tturn(mami, field, max_y, max_x);\n\t\t\t\n\t\t}\n\t\tmami = !mami;\n\t}\n\tfor (int y = 0; y < 8; ++y) {\n\t\tfor (int x = 0; x < 8; ++x) {\n\t\t\tif (field[y][x] == 2) {\n\t\t\t\tcout << 'x';\n\t\t\t}\n\t\t\telse if (field[y][x] == 1) {\n\t\t\t\tcout << 'o';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << '.';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nchar c[9][9];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\trep(i,8)cin>>c[i];\n\tchar me='o',ene='x';\n\tint pass=0;\n\twhile(1){\n\t\trep(i,8)cout<<c[i]<<endl;\n\t\tcout<<endl;\n\t\tint Y=-1,X=-1,best=0;\n\t\trep(i,8)rep(j,8)if(c[i][j]=='.'){\n\t\t\tint flip=0;\n\t\t\trep2(dy,-1,2)rep2(dx,-1,2)if(dy||dx){\n\t\t\t\tint y=i,x=j,f=0;\n\t\t\t\twhile(1){\n\t\t\t\t\ty+=dy,x+=dx;\n\t\t\t\t\tif(y<0 || 7<y || x<0 || 7<x)break;\n\t\t\t\t\tif(c[y][x]!=ene){\n\t\t\t\t\t\tif(c[y][x]==me)flip+=f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tf++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(me=='o'){\n\t\t\t\tif(flip>best)best=flip,Y=i,X=j;\n\t\t\t}else{\n\t\t\t\tif(flip>=best)best=flip,Y=i,X=j;\n\t\t\t}\n\t\t}\n\t\tif(best==0){\n\t\t\tpass++;\n\t\t\tif(pass==2)break;\n\t\t\tswap(me,ene);\n\t\t\tcontinue;\n\t\t}\n\t\tc[Y][X]=me;\n\t\trep2(dy,-1,2)rep2(dx,-1,2)if(dy||dx){\n\t\t\tint y=Y,x=X,ok=0;\n\t\t\twhile(1){\n\t\t\t\ty+=dy,x+=dx;\n\t\t\t\tif(y<0 || 7<y || x<0 || 7<x)break;\n\t\t\t\tif(c[y][x]!=ene){\n\t\t\t\t\tif(c[y][x]==me)ok=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ty=Y,x=X;\n\t\t\t\twhile(1){\n\t\t\t\t\ty+=dy,x+=dx;\n\t\t\t\t\tif(y<0 || 7<y || x<0 || 7<x)break;\n\t\t\t\t\tif(c[y][x]!=ene)break;\n\t\t\t\t\tc[y][x]=me;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpass=0;\n\t\tswap(me,ene);\n\t}\n\trep(i,8)cout<<c[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n/* vim: set foldmethod=marker: */\n\n// constant\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double PI = acos(-1);\n#define EPS 1e-14\n\n// typedef\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n\n// input\ninline int inputi(){ int x; scanf(\"%d\", &x); return x; }\ninline ll inputl(){ ll x; scanf(\"%lld\", &x); return x; }\ninline double inputd(){ double x; scanf(\"%lf\", &x); return x; }\ninline string inputs(){ string x; cin >> x; return x; }\ntemplate <class T> inline T input(){ T x; cin >> x; return x; }\n\n// short\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define sec second\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define RFOR(i, a, b) for (int i = (b) - 1; i >= (a); i--)\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define RREP(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define REPit(type, i, obj) for (type::iterator i = (obj).begin(); i != (obj).end(); i++)\n#define RREPit(type, i, obj) for (type::iterator i = (obj).rbegin(); i != (obj).rend(); i++)\n\n// container util\n#define all(obj) (obj).begin(), (obj).end()\n#define rall(obj) (obj).rbegin(), (obj).rend()\n#define sz(obj) obj.size()\n#define sza(ary) (sizeof(ary) / sizeof(*ary))\n#define sort(obj) sort(all(obj))\n#define exist(obj, key) ((obj).find(key) != (obj).end())\n#define clear(ary) memset((ary), 0, sizeof(ary))\n\n// print util\n#define print(x) cout << (x) << endl\n#define printd(x, d) cout << fixed << setprecision(d) << (x) << endl\n#define printv(v) REP(i, sz(v)) cout << v[i] << \"\\n \"[i < sz(v) - 1]\n#define printa(ary) REP(i, sza(ary)) cout << ary[i] << \"\\n \"[i < sza(ary) - 1]\n#define dump(x) cerr << #x << \": \" << (x) << endl\n#define debug(x) cerr << #x << \": \" << (x) << \" (\" << __LINE__ << \")\" << endl\n\n//template }}}\n\nvector<string> board(8);\n\nbool in_board(int y, int x)\n{\n    return 0 <= y && y < 8 && 0 <= x && x < 8;\n}\n\nint get(int y, int x, bool mami, int dy, int dx)\n{\n    int cnt = 0;\n    do {\n        y += dy;\n        x += dx;\n        cnt++;\n    } while (in_board(y, x) && board[y][x] == \"ox\"[mami]);\n    if (in_board(y, x) && board[y][x] == \"xo\"[mami]){\n        return cnt - 1;\n    }\n    else {\n        return 0;\n    }\n}\n\nint get(int y, int x, bool mami)\n{\n    if (board[y][x] != '.') return 0;\n    int cnt = 0;\n    FOR(i, -1, 2) FOR(j, -1, 2){\n        if (!(i | j)){\n            continue;\n        }\n        cnt += get(y, x, mami, i, j);\n    }\n    return cnt;\n}\n\nvoid put(int y, int x, bool mami, int dy, int dx)\n{\n    int cnt = 0;\n    do {\n        y += dy;\n        x += dx;\n        cnt++;\n    } while (in_board(y, x) && board[y][x] == \"ox\"[mami]);\n    if (!in_board(y, x) || board[y][x] != \"xo\"[mami]) return;\n    while (--cnt){\n        y -= dy;\n        x -= dx;\n        board[y][x] = \"xo\"[mami];\n    }\n}\n\nvoid put(int y, int x, bool mami)\n{\n    board[y][x] = \"xo\"[mami];\n    FOR(i, -1, 2) FOR(j, -1, 2){\n        if (!(i | j)){\n            continue;\n        }\n        put(y, x, mami, i, j);\n    }\n}\n\nbool put(bool mami)\n{\n    int maxi = 0;\n    pii p;\n    if (mami){\n        REP(i, 8) REP(j, 8){\n            int tmp = get(i, j, mami);\n            if (maxi < tmp){\n                maxi = tmp;\n                p = pii(i, j);\n            }\n        }\n    }\n    else {\n        RREP(i, 8) RREP(j, 8){\n            int tmp = get(i, j, mami);\n            if (maxi < tmp){\n                maxi = tmp;\n                p = pii(i, j);\n            }\n        }\n    }\n    if (maxi){\n        // cout << \"xo\"[mami] << \" \" << p.fst << \" \" << p.sec << '\\n';\n        put(p.fst, p.sec, mami);\n        return true;\n    }\n    else return false;\n}\n\nsigned main()\n{\n    REP(i, 8) cin >> board[i];\n    bool mami = true;\n    bool passed = false;\n    while (1){\n        if (!put(mami)){\n            if (passed) break;\n            else passed = true;\n            // cout << \"xo\"[mami] << \" passed\" << '\\n';\n        }\n        else {\n            passed = false;\n        }\n        // REP(i, 8) cout << board[i] << '\\n';\n        // cout << '\\n';\n        mami = !mami;\n    }\n    REP(i, 8) cout << board[i] << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nchar fie[9][9];\nconst char *dat=\"ox\";\nint dx[8]={0,1,0,-1,1,1,-1,-1};\nint dy[8]={1,0,-1,0,1,-1,1,-1};\n\nint check(int x,int y,int t){\n\tint cnt=0;\n\tfor(int i=0;i<8;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tint cc=0;\n\t\twhile(nx>=0 && nx<8 && ny>=0 && ny<8){\n\t\t\tif(fie[nx][ny]=='.')break;\n\t\t\tif(fie[nx][ny]==dat[t]){\n\t\t\t\tcnt+=cc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(fie[nx][ny]==dat[1-t]){\n\t\t\t\tcc++;\n\t\t\t}\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid flip(int x,int y,int t){\n\tfie[x][y]=dat[t];\n\tfor(int i=0;i<8;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\twhile(nx>=0 && nx<8 && ny>=0 && ny<8){\n\t\t\tif(fie[nx][ny]=='.')break;\n\t\t\tif(fie[nx][ny]==dat[t]){\n\t\t\t\tfor(int j=x+dx[i],k=y+dy[i];j!=nx;j+=dx[i],k+=dy[i]){\n\t\t\t\t\tfie[j][k]=dat[t];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t}\n}\n\nint main(void){\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tscanf(\"%c\",&fie[j][i]);\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tint turn=0,pass=0;\n\twhile(pass<2){\n\t\tint nx=-1,ny=-1;\n\t\tint nc=0;\n\t\tif(turn==0){\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(fie[j][i]=='.'){\n\t\t\t\t\t\tint cc=check(j,i,turn);\n\t\t\t\t\t\tif(cc>nc){\n\t\t\t\t\t\t\tnx=j;\n\t\t\t\t\t\t\tny=i;\n\t\t\t\t\t\t\tnc=cc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=7;i>=0;i--){\n\t\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\t\tif(fie[j][i]=='.'){\n\t\t\t\t\t\tint cc=check(j,i,turn);\n\t\t\t\t\t\tif(cc>nc){\n\t\t\t\t\t\t\tnx=j;\n\t\t\t\t\t\t\tny=i;\n\t\t\t\t\t\t\tnc=cc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d\\n\",nx,ny,nc);\n\t\tif(nc==0){\n\t\t\tpass++;\n\t\t}else{\n\t\t\tflip(nx,ny,turn);\n\t\t\tpass=0;\n\t\t}\n\t\tturn=1-turn;\n\t\t/*\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tprintf(\"%c\",fie[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t}\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tprintf(\"%c\",fie[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MA_DEFINES\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define inf (1ll<<60)\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nbool is_valid(int x,int y){\n    return 0<=x&&x<8&&0<=y&&y<8;\n}\n\nbool process(vector<string> &s, char c){\n    char cc=(c=='o'?'x':'o');\n    int dx[]={1,1,0,-1,-1,-1,0,1},dy[]={0,1,1,1,0,-1,-1,-1};\n    vp mem;\n    rep(i,8){\n        rep(j,8){\n            int ii=i,jj=j;\n            if(c=='x')ii=7-ii,jj=7-jj;\n            vp tmp;\n            tmp.pb({ii,jj});\n            if(s[ii][jj]=='.'){\n                rep(k,8){\n                    vp t;\n                    int nx=jj+dx[k],ny=ii+dy[k];\n                    while(true){\n                        if(!is_valid(nx,ny)||s[ny][nx]=='.'){\n                          t.resize(0);\n                          break;\n                        }\n                        else if(s[ny][nx]==cc)t.pb({ny,nx});\n                        else if(s[ny][nx]==c)break;\n                        nx+=dx[k],ny+=dy[k];\n                    }\n                    for(pi p:t)tmp.pb(p);\n                }\n            }\n            if(tmp.size()!=1&&mem.size()<tmp.size()){\n                mem=tmp;\n            }\n        }\n    }\n    if(mem.empty())return false;\n    for(pi p:mem){\n        int nx=p.se,ny=p.fi;\n        s[ny][nx]=c;\n    }\n    return true;\n}\n\nvoid solve(vector<string> &s){\n    bool f=false;\n    do{\n        f=process(s,'o');\n        f|=process(s,'x');\n    }while(f);\n}\n\nvoid run(){\n    vector<string> s(8);\n    rep(i,8)cin>>s[i];\n    solve(s);\n    rep(i,8)cout<<s[i]<<endl;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nchar a[10][10];\nint xdir[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint ydir[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nstruct St{\n  int c, x, y;\n  vector<int> dir;\n  St() {}\n  St(int _y, int _x, int _c): y(_y), x(_x), c(_c) {}\n};\nvector<St> vec;\n\nbool mcomp(const St& s1, const St& s2)\n{\n  if(s1.c == s2.c){\n    if(s1.y == s2.y) return s1.x < s2.x;\n    return s1.y < s2.y;\n  }\n  \n  return s1.c > s2.c;\n}\n\nbool ccomp(const St& s1, const St& s2)\n{\n  if(s1.c == s2.c){\n    if(s1.y == s2.y) return s1.x > s2.x;\n    return s1.y > s2.y;\n  }\n\n  return s1.c > s2.c;\n}\n\nvoid aprint()\n{\n  for(int i = 0; i < 8; ++i){\n    for(int j = 0; j < 8; ++j)\n      cout << a[i][j];\n    cout << endl;\n  }\n\n  return ;\n}\n\nint dfs(int y, int x, int d, int c, char gl)\n{\n  int dy = y+ydir[d], dx = x+xdir[d];\n\n  if(0 <= dy && dy < 8 && 0 <= dx && dx < 8){\n    if(a[dy][dx] == gl) return c;\n    if(a[dy][dx] == '.') return 0;\n\n    return dfs(dy, dx, d, c+1, gl);\n  }\n\n  return 0;\n}\n\nvoid check(char ch)\n{\n  int res;\n\n  for(int i = 0; i < 8; ++i)\n    for(int j = 0; j < 8; ++j)\n      if(a[i][j] == '.'){\n\tSt st = St(i, j, 0);\n\tfor(int k = 0; k < 8; ++k){\n\t  res = dfs(i, j, k, 0, ch);\n\t  if(res > 0){\n\t    st.dir.push_back(k);\n\t    st.c += res;\n\t  }\n\t}\n\tif(st.c > 0) vec.push_back(st);\n      }\n\n  return ;\n}\n\nvoid dfs2(int y, int x, int d, char ch)\n{\n  if(a[y][x] != ch){\n    a[y][x] = ch;\n    dfs2(y+ydir[d], x+xdir[d], d, ch);\n  }\n  return ;\n}\n\nvoid update(St st, char ch)\n{\n  a[st.y][st.x] = ch;\n  for(int i = 0; i < st.dir.size(); i++){\n    int dy = st.y+ydir[st.dir[i]], dx = st.x+xdir[st.dir[i]];\n    dfs2(dy, dx, st.dir[i], ch);\n  }\n\n  return ;\n}\n\nvoid solve()\n{\n  int cnt = 0, tm = 0;\n  bool tn = true;\n\n  for(int i = 0; i < 8; ++i)\n    for(int j = 0; j < 8; ++j)\n      if(a[i][j] == '.') ++cnt;\n  \n  for(int i = 0; i < cnt && tm < 2; ++i, tn = !tn){\n    vec.clear();\n    check((tn? 'o': 'x'));\n    if(vec.empty()){\n      --i;\n      tm++;\n      continue;\n    }\n\n    if(tn) sort(vec.begin(), vec.end(), mcomp);\n    else sort(vec.begin(), vec.end(), ccomp);\n\n    update(vec[0], (tn? 'o': 'x'));\n    tm = 0;\n  }\n\n  return ;\n}\n\nint main()\n{\n  while(cin>>a[0][0]){\n    for(int i = 1; i < 8; ++i) cin >> a[0][i];\n    for(int j = 1; j < 8; ++j)\n      for(int i = 0; i < 8; ++i) cin >> a[j][i];\n\n    solve();\n    aprint();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst char cs[] = \"xo\";\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n    state(){}\n};\n\nstate flip(const int x, const int y, state s, bool turn){\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        while (valid(cx, cy) && s.g[cy][cx] == cs[1 - turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cy, cx) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i]; \n                !(ix == cx && iy == cy); \n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[1 - turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n    }\n    return s;\n}\n\nint main()\n{\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    for (size_t turn = 1; turn <= 64; turn++){\n        bool ok = false;\n        state next = cur;\n        for (size_t y = 0; y < 8; y++){\n            for (size_t x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 0 && next.score[1] >= cand.score[1]) ||\n                        ((turn & 1) == 1 && next.score[0] > cand.score[0])){\n                        ok = true;\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        cur = next;\n    }\n\n    for (size_t i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<set>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n//int dx[4] = { 1,0,0,-1 };\n//int dy[4] = { 0,1,-1,0 };\n#define MOD 1000000007\n#define ARRAY_MAX 100005\n\nconst int INF = 1e9 + 7;\n\n\nint dx[8] = { 0,1,1,1,0,-1,-1,-1 };\nint dy[8] = { 1,1,0,-1,-1,-1,0,1 };\n\n\nchar mp[10][10];\n\nint dfs(int x, int y, char c, int flag) {\n\n\t//現在のクッキーの配置状況の時に\n\t//マス(x,y)にクッキーcを置いた時に得られるクッキーの数\n\t//flagが1の場合は実際に置く\n\t//flagが0の場合はクッキーを置けるかどうかの探索に相当し、クッキーは置かない\n\n\tint cnt = 0;\n\tchar cokkie;//相手のクッキー\n\tif (c == 'o')\n\t{\n\t\tcokkie = 'x';\n\t}\n\telse\n\t{\n\t\tcokkie = 'o';\n\t}\n\tif (mp[x][y] == '.')\n\t{\n\t\t//まだ置いていないマスがあった場合は置けるか調べる\n\t\tfor (int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint r = 1;//現在いるマスからdx[i],dy[i]方向にrマス分先に進む\n\t\t\t//周辺を調べる\n\t\t\tint nx = x + r * dx[i];\n\t\t\tint ny = y + r * dy[i];\n\t\t\twhile (0 <= nx && nx < 8 && 0 <= ny && ny < 8)\n\t\t\t{\n\n\t\t\t\tchar focus = mp[nx][ny];\n\n\t\t\t\tif (focus == c)\n\t\t\t\t{\n\t\t\t\t\t//自分のクッキーが見つかった場合はその間が自分のクッキーに変わる\n\n\t\t\t\t\tif (flag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t//置くのが確定しているため、置いていく\n\t\t\t\t\t\tmp[x][y] = c;\n\t\t\t\t\t\tfor (int tm = 1; tm < r; tm++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmp[x + tm * dx[i]][y + tm * dy[i]] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//置ける候補になるかの確認なので置かない\n\t\t\t\t\t}\n\t\t\t\t\tcnt += r - 1;//間が自分のクッキーに変わる\n\t\t\t\t\tbreak;//自分のクッキーを見つけたのでその先は見なくて良い（見てもその先はこの操作でひっくり返らないので）\n\n\t\t\t\t}\n\t\t\t\telse if (focus == cokkie)\n\t\t\t\t{\n\t\t\t\t\t//相手のクッキーだった場合はさらにその先を調べる\n\t\t\t\t\tr++;\n\t\t\t\t\tnx += dx[i];\n\t\t\t\t\tny += dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//それ以外のもの(ないはずだけど)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//どこにも置けない場合（パスに相当）は0が返る\n\t//それ以外は0より大きい整数が返る\n\treturn cnt;\n}\n\n\n\n\nbool charlotte() {\n\n\tint cnt = 0;//反転させてもらえるクッキーの数\n\tint x = -1, y = -1;\n\tchar c = 'x';//CHARLOTTEのクッキーはxに相当\n\n\n\t//問題よりCHARLOTTEは最大化できるマスが複数ある場合は右下に近いほうが最適なので右下から調べる\n\tfor (int i = 7; i >= 0; i--)\n\t{\n\t\tfor (int j = 7; j >= 0; j--)\n\t\t{\n\t\t\tint tmp = dfs(i, j, c, 0);\n\t\t\tif (cnt < tmp)\n\t\t\t{\n\t\t\t\tcnt = tmp;\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (x >= 0)\n\t{\n\t\t//置ける場所があったので実際にお置いていく（この時x,yは置き換えられる最大のクッキーが最大化されるようになっている）\n\t\tdfs(x, y, c, 1);\n\t}\n\n\tif (cnt > 0)\n\t{\n\t\t//置ける場所があった（次の手番に移るのに相当）\n\t\treturn true;\n\t}\n\telse {\n\t\t//置けなかった（パスに相当）\n\t\treturn false;\n\t}\n}\n\n\n\nbool tomoe() {\n\n\tint cnt = 0;\n\tint x = -1, y = -1;\n\tchar c = 'o';//巴マミのクッキーはoに相当\n\n\t//問題より巴マミは最大化できるマスが複数ある場合は左上に近いほうが最適なので右下から調べる\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < 8; j++)\n\t\t{\n\t\t\tint tmp = dfs(i, j, c, 0);\n\t\t\t//cout << i << \" \" << j << \" tmp=\" << tmp << endl;\n\t\t\tif (cnt < tmp)\n\t\t\t{\n\t\t\t\tcnt = tmp;\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (x >= 0)\n\t{\n\t\t//置ける場所があったので実際にお置いていく（この時x,yは置き換えられる最大のクッキーが最大化されるようになっている）\n\t\tdfs(x, y, c, 1);\n\t}\n\n\tif (cnt > 0)\n\t{\n\t\t//置ける場所があった（次の手番に移るのに相当）\n\t\treturn true;\n\t}\n\telse {\n\t\t//置けなかった（パスに相当）\n\t\treturn false;\n\t}\n}\n\n\n\nint main() {\n\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//char mp[10][10];\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < 8; j++)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tbool T = true;\n\tbool C = true;\n\n\twhile (T || C) {\n\t\t//何も置けなくなるまでシミュレーション\n\n\t\tT = tomoe();\n\t\tC = charlotte();\n\t}\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < 8; j++)\n\t\t{\n\t\t\tcout << mp[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nvector<string> vs(8);\nstring t = \"ox\";\nint MAX, MAXy, MAXx, my, op;\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {1, 0, -1, -1, 1, 1, -1, 0};\n\nbool contain(int y, int x) {\n  return (0 <= y && y < 8 && 0 <= x && x < 8);\n}\n\nvoid check(int y, int x, int dg) {\n  if(dg == 0 && vs[y][x] != '.') return;\n  int cnt = 0;\n  FOR(i,0,8) {\n    int tmp = 0;\n    FOR(j,1,8) {\n      int ny = y + dy[i] * j;\n      int nx = x + dx[i] * j;\n      if(!contain(ny,nx) || vs[ny][nx] == '.') break;\n      if(vs[ny][nx] == t[op]) tmp++;\n      else {\n        if(dg == 1) {\n          FOR(k,1,j+1) {\n            vs[y+dy[i]*k][x+dx[i]*k] = t[my];\n          }\n        }\n        cnt += tmp;\n        break;\n      }\n    }\n  }\n  if(MAX < cnt) {\n    MAXy = y;\n    MAXx = x;\n    MAX = cnt;\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  FOR(i,0,8) cin >> vs[i];\n  int g = 0;\n  for(int i = 0;;i++) {\n    my = i % 2;\n    op = (i + 1) % 2;\n    MAX = 0;\n    MAXy = 0;\n    MAXx = 0;\n    if(my == 0) {\n      FOR(j,0,8) FOR(k,0,8) check(j,k,0);\n    } else {\n      for(int j = 7; j >= 0; j--) for(int k = 7; k >= 0; k--) check(j,k,0);\n    }\n    if(MAX == 0) g++;\n    else g = 0;\n    if(g == 2) break;\n    if(MAX != 0) {\n      vs[MAXy][MAXx] = t[my];\n      check(MAXy,MAXx,1);\n    }\n  }\n  FOR(i,0,8) cout << vs[i] << endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[]={1, 1, 0, -1, -1, -1, 0, 1};\nint dy[]={0, 1, 1, 1, 0, -1, -1, -1};\nint s[9][9];\n\nint dfs(int x, int y, int c){\n    int count=0;\n    for(int now=0; now<8; now++){\n        for(int i=1; i<=8; i++){\n            if(y+dy[now]*i<1||y+dy[now]*i>8||x+dx[now]*i<1||x+dx[now]*i>8) break;\n            if(s[y+dy[now]*i][x+dx[now]*i]==c){\n                for(int j=1; j<i; j++){\n                    count++;\n                }\n                break;\n            }\n            if(s[y+dy[now]*i][x+dx[now]*i]==0){\n                break;\n            }\n        }\n    }\n    return count;\n}\n\nvoid dfs1(int x, int y, int c){\n    for(int now=0; now<8; now++){\n        for(int i=1; i<=8; i++){\n            if(y+dy[now]*i<1||y+dy[now]*i>8||x+dx[now]*i<1||x+dx[now]*i>8) break;\n            if(s[y+dy[now]*i][x+dx[now]*i]==c){\n                for(int j=1; j<i; j++){\n                    s[y+dy[now]*j][x+dx[now]*j]=c;\n                }\n                break;\n            }\n            if(s[y+dy[now]*i][x+dx[now]*i]==0){\n                break;\n            }\n        }\n    }\n}\n\nint main(void){\n    for(int i=1; i<=8; i++){\n        string str;\n        cin >> str;\n        for(int j=1; j<=8; j++){\n            s[i][j]=(str[j-1]=='o'?1:(str[j-1]=='x'?-1:0));\n        }\n    }\n    int c=-1, jud=0, turn=0;\n    while(true){\n        c*=-1;\n        turn++;\n        if(turn%2==1) jud=0;\n        int max=0, mx=-1, my=-1;\n        for(int i=1; i<=8; i++){\n            for(int j=1; j<=8; j++){\n                if(s[i][j]!=0) continue;\n                int ret=dfs(j, i, c);\n                if(max<ret){\n                    max=ret;\n                    mx=j; my=i;\n                }\n                if(max==ret&&c==-1){\n                    mx=j; my=i;\n                }\n            }\n        }\n        if(max>0){\n            s[my][mx]=c;\n            dfs1(mx, my, c);\n        }\n        //-----------------------\n        // for(int i=1; i<=8; i++){\n        //     for(int j=1; j<=8; j++){\n        //         cout << (s[i][j]==1?'o':(s[i][j]==-1?'x':'.'));\n        //     }\n        //     cout << \"\\n\";\n        // }\n        // cout << \"\\n\";\n        //-----------------------\n        if(max==0) jud++;\n        if(jud==2) break;\n    }\n    \n    for(int i=1; i<=8; i++){\n        for(int j=1; j<=8; j++){\n            cout << (s[i][j]==1?'o':(s[i][j]==-1?'x':'.'));\n        }\n        cout << \"\\n\";\n    }\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nint dx[8]={1,0,0,-1,1,1,-1,-1};\nint dy[8]={0,1,-1,0,1,-1,-1,1};\n\nint main(void)\n{\n\tchar f[10][10];\n\tint i1,i2,i3;\n\tint cnt;\n\tint xx,yy;\n\tint c;\n\tint witch,mami;\n\tint mamix,mamiy;\n\tint witchx,witchy;\n\tint sizee;\n\tint check1,check2;\n\tvector<int> mamiv;\n\tvector<int> witchv;\n\n\tfor(i1=0;i1<10;i1++){\n\t\tfor(i2=0;i2<10;i2++){\n\t\t\tif(i1==0 || i2==0 || i1==9 || i2==9) f[i1][i2]='n';\n\t\t\telse cin>>f[i1][i2];\n\t\t}\n\t}\n\n\tcheck1=0;\n\tcheck2=0;\n\twhile(1){\n\n\t\tmami=0;\n\t\tsizee=0;\n\t\tfor(i1=1;i1<=8;i1++){\n\t\t\tfor(i2=1;i2<=8;i2++){\n\n\t\t\t\tif(f[i1][i2]=='.'){\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tfor(i3=0;i3<8;i3++){\n\t\t\t\t\t\txx=i2+dx[i3];\n\t\t\t\t\t\tyy=i1+dy[i3];\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(f[yy][xx]=='x') {\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tyy+=dy[i3];\n\t\t\t\t\t\t\txx+=dx[i3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f[yy][xx]=='o'){\n\t\t\t\t\t\t\tcnt+=c;\n\t\t\t\t\t\t\tv.pb(i3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(mami<cnt){\n\t\t\t\t\t\tmami=cnt;\n\t\t\t\t\t\tmamix=i2;\n\t\t\t\t\t\tmamiy=i1;\n\t\t\t\t\t\tsizee=v.size();\n\t\t\t\t\t\tmamiv.clear();\n\t\t\t\t\t\tmamiv.reserve(v.size());//先にメモリ領域を確保する。\n\t\t\t\t\t\tcopy(v.begin(), v.end(), back_inserter(mamiv));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mami!=0){ \n\n\n\n\t\t\tfor(i1=0;i1<sizee;i1++){\n\t\t\t\tyy=mamiy;\n\t\t\t\txx=mamix;\n\t\t\t\tf[yy][xx]='x';\n\t\t\t\twhile(f[yy][xx]=='x'){\n\t\t\t\t\tf[yy][xx]='o';\n\t\t\t\t\tyy+=dy[mamiv[i1]];\n\t\t\t\t\txx+=dx[mamiv[i1]];\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheck1=0;\n\t\t}\n\t\telse check1=1;\n\n\t\tif((check1+check2)==2) break;\n\n\n\n\t\twitch=0;\n\t\tsizee=0;\n\t\tfor(i1=8;i1>=1;i1--){\n\t\t\tfor(i2=8;i2>=1;i2--){\n\n\t\t\t\tif(f[i1][i2]=='.'){\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tvector<int> v;\n\t\t\t\t\tfor(i3=0;i3<8;i3++){\n\t\t\t\t\t\txx=i2+dx[i3];\n\t\t\t\t\t\tyy=i1+dy[i3];\n\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(f[yy][xx]=='o') {\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tyy+=dy[i3];\n\t\t\t\t\t\t\txx+=dx[i3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f[yy][xx]=='x'){\n\t\t\t\t\t\t\tcnt+=c;\n\t\t\t\t\t\t\tv.pb(i3);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout<<i1<<\" \"<<i2<<\" \"<<c<<\" \"<<witchy<<endl;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(witch<cnt){\n\t\t\t\t\t\twitch=cnt;\n\t\t\t\t\t\twitchx=i2;\n\t\t\t\t\t\twitchy=i1;\n\t\t\t\t\t\tsizee=v.size();\n\t\t\t\t\t\twitchv.clear();\n\t\t\t\t\t\twitchv.reserve(v.size());//先にメモリ領域を確保する。\n\t\t\t\t\t\tcopy(v.begin(), v.end(), back_inserter(witchv));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(witch!=0){\n\t\t\tfor(i1=0;i1<sizee;i1++){\n\t\t\t\tyy=witchy;\n\t\t\t\txx=witchx;\n\t\t\t\tf[yy][xx]='o';\n\t\t\t\twhile(f[yy][xx]=='o'){\n\t\t\t\t\tf[yy][xx]='x';\n\t\t\t\t\tyy+=dy[witchv[i1]];\n\t\t\t\t\txx+=dx[witchv[i1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheck2=0;\n\t\t}\n\t\telse check2=1;\n\n\t\tif((check1+check2)==2) break;\t\n\t}\n\t\t\n\tfor(i1=1;i1<9;i1++){\n\t\tfor(i2=1;i2<9;i2++){\n\t\t\tcout<<f[i1][i2];\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint puttable(vector<string>& t, bool mami, int i, int j) {\n  if (t[i][j] != '.') return 0;\n  int puttable_num = 0;\n  for(int di=-1;di<=1;++di)\n    for(int dj=-1;dj<=1;++dj){\n      if(di==dj&&di==0)continue;\n      for(int k=1;k<8;++k){\n        int pi=i+di*k;\n        int pj=j+dj*k;\n        if(pi<0||pj<0||pi>=8||pj>=8)break;\n        if(t[pi][pj]=='.')break;\n        if((t[pi][pj] == 'o') == mami){\n          puttable_num += k-1;\n          break;\n        }\n      }\n    }\n  return puttable_num;\n}\n\nvoid put_i(vector<string>& t, bool mami, int i, int j) {\n  t[i][j] = (mami?'o':'x');\n  for(int di=-1;di<=1;++di)\n    for(int dj=-1;dj<=1;++dj){\n      if(di==dj&&di==0)continue;\n      for(int k=1;k<8;++k){\n        int pi=i+di*k;\n        int pj=j+dj*k;\n        if(pi<0||pj<0||pi>=8||pj>=8)break;\n        if(t[pi][pj]=='.')break;\n        if((t[pi][pj] == 'o') == mami){\n          for(int l=1;l<k;++l){\n            int li=i+di*l;\n            int lj=j+dj*l;\n            t[li][lj]=(mami?'o':'x');\n          }\n          break;\n        }\n      }\n    }\n}\n\nvoid put(vector<string>& t, bool mami) {\n  int num=0,pi=0,pj=0;\n  if(mami){\n    REP(i,8)REP(j,8){\n      int n=puttable(t,mami,i,j);\n      if(n > num){\n        num=n;\n        pi=i;pj=j;\n      }\n    }\n  }else{\n    REP(i,8)REP(j,8){\n      int n=puttable(t,mami,7-i,7-j);\n      if(n > num){\n        num=n;\n        pi=7-i;pj=7-j;\n      }\n    }\n  }\n  put_i(t,mami,pi,pj);\n}\n\nbool puttable_all(vector<string>& t, bool mami) {\n  REP(i,8)REP(j,8)\n    if(puttable(t,mami,i,j) > 0) return true;\n  return false;\n}\n\nint main() {\n  vector<string> t(8);\n  REP(i,8) cin>>t[i];\n  bool passed = false;\n  bool mami = true;\n  while(1){\n    if(!puttable_all(t,mami)){\n      if(passed) break;\n      passed = true;\n      mami = !mami;\n      continue;\n    }\n    passed = false;\n    put(t,mami);\n    mami = !mami;\n  }\n  for(auto& s:t) cout<<s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\n//int dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n }; */\n\n\n/** Problem2311 : Dessert Witch **/\nenum {\n\tWHITE = 0,\n\tBLACK,\n\tNONE,\n};\n\nint board[8][8];\nint board_tmp[8][8];\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nvoid print_board()\n{\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (board[j][i] == WHITE) cout << \"o\";\n\t\t\telse if (board[j][i] == BLACK) cout << \"x\";\n\t\t\telse cout << \".\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nbool range_valid(int x, int y)\n{\n\tif (x < 0 || 8 <= x || y < 0 || 8 <= y) return false;\n\treturn true;\n}\n\nbool can_reverse(int x, int y, int d, int turn)\n{\n\tif (!range_valid(x, y) || board[x][y] == NONE) return false;\n\tif (board[x][y] == turn) return true;\n\t\n\treturn can_reverse(x+dx[d], y+dy[d], d, turn);\n}\n\nvoid do_reverse(int x, int y, int d, int turn)\n{\n\tif (board[x][y] == turn) return;\n\tboard[x][y] = turn;\n\tdo_reverse(x+dx[d], y+dy[d], d, turn);\n}\n\nbool can_put(int x, int y, int turn)\n{\n\tif (board[x][y] != NONE) return false;\n\t\n\tfor (int i=0; i<8; i++) {\n\t\tint nx = x+dx[i], ny=y+dy[i];\n\t\tif (board[nx][ny] == 1-turn && can_reverse(x+dx[i], y+dy[i], i, turn)) return true;\n\t}\n\treturn false;\n}\n\nbool can_put_all(int turn)\n{\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (can_put(j, i, turn)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool gameover()\n{\n\treturn !can_put_all(WHITE) && !can_put_all(BLACK);\n}\n\nPII count_stone()\n{\n\tPII res = PII(0, 0);\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (board[i][j] == WHITE) res.first++;\n\t\t\telse if (board[i][j] == BLACK) res.second++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint turn=WHITE;\n\t\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif (c=='.')\t\t board[j][i] = NONE;\n\t\t\telse if (c=='o') board[j][i] = WHITE;\n\t\t\telse\t\t\t board[j][i] = BLACK;\n\t\t}\n\t}\n\t\n\twhile (true) {\n\t\tif (gameover()) {\n\t\t\tprint_board();\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (!can_put_all(turn)) {\n\t\t\tturn = 1-turn;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint target_x = -1, target_y = -1, cnt_max=0;\n\t\t\n\t\tfor (int y=0; y<8; y++) {\n\t\t\tfor (int x=0; x<8; x++) {\n\t\t\t\tif (board[x][y] != NONE) continue;\n\t\t\t\t\n\t\t\t\tmemcpy(board_tmp, board, sizeof(board));\n\t\t\t\t\n\t\t\t\tbool ok=false;\n\t\t\t\tfor (int i=0; i<8; i++) {\n\t\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\t\tif (board[nx][ny] != 1-turn) continue;\n\t\t\t\t\t\n\t\t\t\t\tif (can_reverse(nx, ny, i, turn)) {\n\t\t\t\t\t\tdo_reverse(nx, ny, i, turn);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ok) {\n\t\t\t\t\tboard[x][y] = turn;\n\t\t\t\t\tPII cnt = count_stone();\n\t\t\t\t\t\n\t\t\t\t\tif (turn == WHITE) {\n\t\t\t\t\t\tif (cnt_max < cnt.first) {\n\t\t\t\t\t\t\ttarget_x = x;\n\t\t\t\t\t\t\ttarget_y = y;\n\t\t\t\t\t\t\tcnt_max = cnt.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cnt_max <= cnt.second) {\n\t\t\t\t\t\t\ttarget_x = x;\n\t\t\t\t\t\t\ttarget_y = y;\n\t\t\t\t\t\t\tcnt_max = cnt.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmemcpy(board, board_tmp, sizeof(board));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<8; i++) {\n\t\t\tint nx = target_x+dx[i], ny = target_y+dy[i];\n\t\t\tif (board[nx][ny] != 1-turn) continue;\n\t\t\t\n\t\t\tif (can_reverse(nx, ny, i, turn)) {\n\t\t\t\tdo_reverse(nx, ny, i, turn);\n\t\t\t}\n\t\t}\n\t\tboard[target_x][target_y] = turn;\n\t\tturn = 1-turn;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2311.cc: Dessert Witch\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int N = 8;\n\nconst int dxs[] = {1,  1,  0, -1, -1, -1, 0, 1};\nconst int dys[] = {0, -1, -1, -1,  0,  1, 1, 1};\n\n/* typedef */\n\n/* global variables */\n\nstring flds[N];\n\n/* subroutines */\n\nvoid print_flds() {\n  for (int y = 0; y < N; y++) cout << flds[y] << endl;\n}\n\nint repnum(int x0, int y0, char myc) {\n  int sum = 0;\n  for (int di = 0; di < 8; di++) {\n    int dx = dxs[di], dy = dys[di], cnt = 0;\n    for (int x = x0 + dx, y = y0 + dy;\n\t x >= 0 && x < N && y >= 0 && y < N;\n\t x += dx, y += dy) {\n      if (flds[y][x] == '.') break;\n      if (flds[y][x] == myc) {\n\tsum += cnt;\n\tbreak;\n      }\n      cnt++;\n    }\n  }\n  return sum;\n}\n\nvoid put(int x0, int y0, char myc) {\n  if (flds[y0][x0] != '.') return;\n  flds[y0][x0] = myc;\n\n  for (int di = 0; di < 8; di++) {\n    int dx = dxs[di], dy = dys[di], cnt = 0, x1, y1;\n    bool flip = false;\n    for (x1 = x0 + dx, y1 = y0 + dy;\n\t x1 >= 0 && x1 < N && y1 >= 0 && y1 < N;\n\t x1 += dx, y1 += dy) {\n      if (flds[y1][x1] == '.') break;\n      if (flds[y1][x1] == myc) {\n\tflip = true;\n\tbreak;\n      }\n      cnt++;\n    }\n\n    if (flip && cnt > 0)\n      for (int x = x0 + dx, y = y0 + dy; x != x1 || y != y1; x += dx, y += dy)\n\tflds[y][x] = myc;\n  }\n}\n\n/* main */\n\nint main() {\n  for (int y = 0; y < N; y++) cin >> flds[y];\n\n  bool o = true, x = true;\n\n  while (o || x) {\n    o = x = false;\n    int maxon = 0, maxxn = 0;\n    int ox, oy, xx, xy;\n\n    for (int y = 0; y < N; y++)\n      for (int x = 0; x < N; x++)\n\tif (flds[y][x] == '.') {\n\t  int on = repnum(x, y, 'o');\n\t  if (maxon < on) maxon = on, ox = x, oy = y;\n\t}\n    if (maxon > 0) {\n      put(ox, oy, 'o');\n      o = true;\n      //printf(\"put(%d,%d,%c)\\n\", ox, oy, 'o');\n      //print_flds();\n    }\n\n    for (int y = N - 1; y >= 0; y--)\n      for (int x = N - 1; x >= 0; x--)\n\tif (flds[y][x] == '.') {\n\t  int xn = repnum(x, y, 'x');\n\t  if (maxxn < xn) maxxn = xn, xx = x, xy = y;\n\t}\n    if (maxxn > 0) {\n      put(xx, xy, 'x');\n      x = true;\n      //printf(\"put(%d,%d,%c)\\n\", xx, xy, 'x');\n      //print_flds();\n    }\n  }\n\n  print_flds();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nchar inv(char c)\n{\n\tchar s[]={\".ox\"};\n\treturn \".xo\"[strchr(s,c)-s];\n}\n\nint count(const vector<string>& grid,char c,int i,int j,int di,int dj)\n{\n\tif(i<0 || 8<=i || j<0 || 8<=j || grid[i][j]=='.') return -1;\n\tif(grid[i][j]==c) return 0;\n\tint res=count(grid,c,i+di,j+dj,di,dj);\n\tif(res!=-1) res++;\n\treturn res;\n}\nint count(const vector<string>& grid,char c,int i,int j)\n{\n\tif(grid[i][j]!='.') return 0;\n\tint di[]={0,-1,-1,-1,0,1,1,1};\n\tint dj[]={1,1,0,-1,-1,-1,0,1};\n\tint sum=0;\n\tfor(int k=0;k<8;k++){\n\t\tint x=count(grid,c,i+di[k],j+dj[k],di[k],dj[k]);\n\t\tif(x!=-1) sum+=x;\n\t}\n\treturn sum;\n}\n\nbool flip(vector<string>& grid,char c,int i,int j,int di,int dj)\n{\n\tif(i<0 || 8<=i || j<0 || 8<=j || grid[i][j]=='.') return false;\n\tif(grid[i][j]==c) return true;\n\tbool res=flip(grid,c,i+di,j+dj,di,dj);\n\tif(res) grid[i][j]=c;\n\treturn res;\n}\nvoid flip(vector<string>& grid,char c,int i,int j)\n{\n\tif(grid[i][j]!='.') return;\n\tgrid[i][j]=c;\n\tint di[]={0,-1,-1,-1,0,1,1,1};\n\tint dj[]={1,1,0,-1,-1,-1,0,1};\n\tfor(int k=0;k<8;k++)\n\t\tflip(grid,c,i+di[k],j+dj[k],di[k],dj[k]);\n}\n\nint main()\n{\n\tvector<string> grid(8);\n\tfor(int i=0;i<8;i++)\n\t\tcin>>grid[i];\n\t\n\tfor(int turn=1;turn<=8*8*2;turn++){\n\t\tint mx=0,i0=0,j0=0;\n\t\tif(turn&1){\n\t\t\tfor(int i=0;i<8;i++) for(int j=0;j<8;j++){\n\t\t\t\tint x=count(grid,'o',i,j);\n\t\t\t\tif(x>mx) mx=x,i0=i,j0=j;\n\t\t\t}\n\t\t\tif(mx) flip(grid,'o',i0,j0);\n\t\t}\n\t\telse{\n\t\t\tfor(int i=8;i--;) for(int j=8;j--;){\n\t\t\t\tint x=count(grid,'x',i,j);\n\t\t\t\tif(x>mx) mx=x,i0=i,j0=j;\n\t\t\t}\n\t\t\tif(mx) flip(grid,'x',i0,j0);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<8;i++)\n\t\tcout<<grid[i]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T>inline bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>inline bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int SIZE = 8;\nenum Turn{MAMI, MAJO, };\nconst int dx[] = {0, 0, -1, -1, -1, 1, 1, 1};\nconst int dy[] = {1 ,-1, 1, 0, -1, 1, 0, -1};\n\nbool inside(const int ii, const int jj) {\n    return 0 <= ii && ii < SIZE && 0 <= jj && jj < SIZE;\n}\n\nTurn change(Turn now) {\n    switch (now) {\n    case MAMI:\n        return MAJO;\n        break;\n    case MAJO:\n        return MAMI;\n        break;\n    }\n}\n\nbool check(vector<string> S, Turn now) {\n    char target = (now == MAMI ? 'x' : 'o');\n    char me = (target == 'o' ? 'x' : 'o');\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (S[i][j] == '.') {\n                for (int d = 0; d < 8; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    int cnt = 0;\n                    while (inside(ni, nj) && S[ni][nj] == target) {\n                        ni += dx[d];\n                        nj += dy[d];\n                        cnt++;\n                    }\n                    if (inside(ni, nj) && S[ni][nj] == me && cnt != 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nusing State = pair<pair<int, int>, vector<string>>;//<<revnum, point>, board>\n//point MAMI ?????¨????¬?????????¢\nState change(vector<string> S, int i, int j, Turn now) {\n    char target = (now == MAMI ? 'x' : 'o');\n    char me = (target == 'o' ? 'x' : 'o');\n    State res;\n    const int idx1d = i * SIZE + j;\n    res.first = make_pair(0, (now == MAMI ? -idx1d : idx1d));\n    assert(S[i][j] == '.');\n    S[i][j] = me;\n    for (int d = 0; d < 8; d++) {\n        int ni = i + dx[d];\n        int nj = j + dy[d];\n        int cnt = 0;\n        while (inside(ni, nj) && S[ni][nj] == target) {\n            ni += dx[d];\n            nj += dy[d];\n            cnt++;\n        }\n        if (inside(ni, nj) && S[ni][nj] == me && cnt != 0) {\n            res.first.first += cnt;\n            for (int rev = 0, ii = i + dx[d], jj = j + dy[d]; rev < cnt; rev++, ii += dx[d], jj += dy[d]) {\n                assert(S[ii][jj] == target);\n                S[ii][jj] = me;\n            }\n        }\n    }\n    res.second = S;\n    return res;\n}\n\nvector<string> play(vector<string> S, Turn now) {\n    priority_queue<State> pq;\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (S[i][j] == '.') {\n                State res = change(S, i, j, now);\n                if (res.first.first != 0) {\n                    pq.push(res);\n                }\n            }\n        }\n    }\n    return pq.top().second;\n}\n\nint main(void) {\n    vector<string> S(SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        cin >> S[i];\n    }\n    bool prevSkip = false;\n    Turn now = MAMI;\n    int cnt = 0;\n    while (true) {\n        //DEBUG(cnt++)\n        if (!check(S, now)) {\n            if (prevSkip) break;\n            prevSkip = true;\n            now = change(now);\n            continue;\n        }\n        prevSkip = false;\n        S = play(S, now);\n        now = change(now);\n\n        // for (int i = 0; i < SIZE; i++) {\n        //     cout << S[i] << endl;\n        // }\n    }\n    for (int i = 0; i < SIZE; i++) {\n        cout << S[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define RREP(i, a, n) for(int i=n-1; i>=0; i--)\n#define RANGE(a, low, high) (low<=a && a<high)\n#define MP(a, b) make_pair(a, b)\n\nint dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nint dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nchar cake[2] = { 'o', 'x' };\nchar table[8][8];\nbool mami[8][8], charlotte[8][8];\n\npair<int, int> check_mami() {\n\tint maxi = 0;\n\tpair<int, int> p = MP(-1, -1);\n\n\tREP(i, 0, 8) {\n\t\tREP(j, 0, 8) {\n\t\t\tif (table[i][j] != '.') continue;\n\n\t\t\tint cnt = 0;\n\t\t\tREP(k, 0, 8) {\n\t\t\t\tint y = i + dy[k];\n\t\t\t\tint x = j + dx[k];\n\t\t\t\tint chain = 0;\n\t\t\t\t\n\t\t\t\tbool flag = false;\n\t\t\t\twhile (RANGE(y, 0, 8) && RANGE(x, 0, 8) && table[y][x] != '.') {\n\n\t\t\t\t\tif (table[y][x] == 'x') chain++;\n\t\t\t\t\telse if (table[y][x] == 'o') {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ty += dy[k];\n\t\t\t\t\tx += dx[k];\n\t\t\t\t}\n\n\t\t\t\tif (flag) cnt += chain;\n\t\t\t}\n\n\t\t\tif (cnt > maxi) {\n\t\t\t\tmaxi = cnt;\n\t\t\t\tp = MP(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p;\n}\n\npair<int, int> check_charlotte() {\n\tint maxi = 0;\n\tpair<int, int> p = MP(-1, -1);\n\n\tRREP(i, 0, 8) {\n\t\tRREP(j, 0, 8) {\n\t\t\tif (table[i][j] != '.') continue;\n\n\t\t\tint cnt = 0;\n\t\t\tREP(k, 0, 8) {\n\t\t\t\tint y = i + dy[k];\n\t\t\t\tint x = j + dx[k];\n\t\t\t\tint chain = 0;\n\n\t\t\t\tbool flag = false;\n\t\t\t\twhile (RANGE(y, 0, 8) && RANGE(x, 0, 8) && table[y][x] != '.') {\n\t\t\t\t\tif (table[y][x] == 'o') chain++;\n\t\t\t\t\telse if (table[y][x] == 'x') {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ty += dy[k];\n\t\t\t\t\tx += dx[k];\n\t\t\t\t}\n\n\t\t\t\tif (flag) cnt += chain;\n\t\t\t}\n\n\t\t\tif (cnt > maxi) {\n\t\t\t\tmaxi = cnt;\n\t\t\t\tp = MP(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p;\n}\n\nvoid change(int y, int x, bool idx) {\n\ttable[y][x] = cake[idx];  // false:'o', true:'x'\n\tREP(k, 0, 8) {\n\t\tint ny = y + dy[k];\n\t\tint nx = x + dx[k];\n\n\t\tint cnt = 0;\n\t\twhile (RANGE(ny, 0, 8) && RANGE(nx, 0, 8) && table[ny][nx] != '.') {\n\t\t\tif (table[ny][nx] == cake[true-idx]) cnt++;\n\n\t\t\telse if (table[y][x] == cake[idx]) {\n\t\t\t\tRREP(l, 0, cnt) {\n\t\t\t\t\tny += dy[(k + 4) % 8];\n\t\t\t\t\tnx += dx[(k + 4) % 8];\n\t\t\t\t\ttable[ny][nx] = cake[idx];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tny += dy[k];\n\t\t\tnx += dx[k];\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main() {\n\tREP(i, 0, 8) REP(j, 0, 8) cin >> table[i][j];\n\n\twhile (1) {\n\t\tpair<int, int> mami = check_mami();\n\t\tif (mami.first != -1) change(mami.first, mami.second, false);\n\t\t\n\t\tpair<int, int> charlotte = check_charlotte();\n\t\tif (charlotte.first != -1) change(charlotte.first, charlotte.second, true);\n\n\t\tif (mami.first == -1 && charlotte.first == -1) break;\n\t}\n\n\tREP(i, 0, 8) {\n\t\tREP(j, 0, 8) {\n\t\t\tcout << table[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\nstring F[8];\n//char F[8][9];\nbool used[8][8];\nint turn;\n\nbool debug;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n  cerr << \"runtime error !! \\n\";\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  /*\n  rep(i, 8) rep(j, 8){\n    cin >> F[i][j];\n  }\n  //  */\n  rep(i, 8) cin >> F[i];\n  \n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7)\n      DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        \n        if(mx < r) {\n          memcpy(u, used, sizeof u);\n          mx = r;\n          pl = turn&1;\n        }\n        \n      }\n    }\n    if(mx > 0) {\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      \n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  \n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\nvector<vector<char> > v(8);\nint xa[8] = {1,1,1,-1,-1,-1,0,0};\nint ya[8] = {1,0,-1,1,0,-1,1,-1};\nint xx, yy;\n\nint xcount(point poi, int xa, int ya){\n  int cnt = 0;\n  int judge = 0;\n  int x = poi.x, y = poi.y;\n  while(1){\n    x += xa; y += ya;\n    if(x > 7 || y > 7 || x < 0 || y < 0) return 0;\n    if(v[y][x] == '.') return 0;\n    else if(v[y][x] == 'x'){\n      cnt++;\n    }else if(v[y][x] == 'o'){\n      judge = 1;\n      break;\n    }\n  }\n  if(judge == 1)\n    return cnt;\n  else return 0;\n}\n\nint ocount(point poi, int xa, int ya){\n  int cnt = 0;\n  int judge = 0;\n  int x = poi.x, y = poi.y;\n  //  cout << \"hoge\" << endl;;\n  while(1){\n    x += xa; y += ya;\n    if(x > 7 || y > 7 || x < 0 || y < 0) return 0;\n    if(v[y][x] == '.') return 0;\n    else if(v[y][x] == 'o'){\n      cnt++;\n    }else if(v[y][x] == 'x'){\n      judge = 1;\n      break;\n    }\n  }\n  // cout << \"hoge\" << endl;;\n  if(judge == 1)\n    return cnt;\n  else return 0;\n}\n\nint osolve(point poi){\n  int ans = 0;\n  // cout << \"hoge\" << endl;;\n  for(int i = 0; i < 8; i++){\n    int x = poi.x + xa[i], y = poi.y + ya[i];\n    if(x >= 0 && y >= 0 && x < 8 && y < 8 && v[y][x] == 'x'){\n      int cp = xcount(poi,xa[i],ya[i]);\n    \n\tans += cp;\n\txx = xa[i]; yy = ya[i];\n    \n    }\n  }\n  return ans;\n}\n\nint xsolve(point poi){\n  int ans = 0;\n  for(int i = 0; i < 8; i++){\n    int x = poi.x + xa[i], y = poi.y + ya[i];\n    if(x >= 0 && y >= 0 && x < 8 && y < 8 && v[y][x] == 'o'){\n      int cp = ocount(poi,xa[i],ya[i]);\n    \n\tans += cp;\n\txx = xa[i]; yy = ya[i];\n    \n    }\n  }\n  return ans;\n\n}\n\n\nvoid change1(point poi){\n  int xo = poi.x, yo = poi.y;\n  v[yo][xo] = 'x';\n  int judge = -1;\n  for(int i = 0; i < 8; i++){\n    //    int x = xo + xa[i], y = yo + ya[i];\n    int cnt = ocount(poi,xa[i],ya[i]);\n    int xxx = poi.x, yyy = poi.y;\n    if( cnt > 0){\n      while(cnt--){\n\txxx+=xa[i]; yyy+=ya[i];\n\tv[yyy][xxx] = 'x';\n      }\n    }\n  }\n}\nvoid change2(point poi){\n  int xo = poi.x, yo = poi.y;\n  v[yo][xo] = 'o';\n  int judge = -1;\n  for(int i = 0; i < 8; i++){\n    //  int x = xo + xa[i], y = yo + ya[i];\n    int cnt = xcount(poi,xa[i],ya[i]);\n    int xxx = poi.x, yyy = poi.y;\n    // cout << cnt << endl;\n    if( cnt > 0){\n      while(cnt--){\n\txxx+=xa[i]; yyy+=ya[i];\n\tv[yyy][xxx] = 'o';\n      }\n    }\n  }\n}\n\n\n\n\n\n\nint main(){\n  //return 0;\n  vector<vector<char> > vcp(8);\n\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      char ch;\n      cin >> ch;\n      v[i].push_back(ch);\n      vcp[i].push_back(ch);\n    }\n  }\n  \n\n  int judge = 0;\n  int ss = 0;\n\n\n  while(1){\n    int cnt1 = 0, cnt2 = 0, cnt3 = 0;\n    //cout << \"hoge\" << endl;;\n    for(int i = 0; i < 8; i++){\n      for(int j = 0; j < 8; j++){\n\tif(v[i][j] == 'o') cnt1++;\n\telse if(v[i][j] == 'x') cnt2++;\n\t\n      }\n    }\n    \n    if(cnt1+cnt2 == 64) break;\n    else if((cnt1 == 0 && cnt2 != 0) || (cnt2 == 0 && cnt1 != 0)) break;\n    else if(cnt1 == 0 && cnt2 == 0) break;\n\n    int ret = 0;\n    point cp;\n    point t;\n    int s;\n\n    xx = 11; yy = 11;\n    for(int i = 0; i < 8; i++){\n      for(int j = 0; j < 8; j++){\n\tif(judge%2 == 0){\n\t  if(v[i][j] == '.'){\n\t    cp.x = j; cp.y = i;\n\t    s = osolve(cp);\n\t    if(ret < s && s != 0){\n\t      ret = s;\n\t      t = cp;\n\t    }\n\n\t  }\n\t}else {\n\t  if(v[i][j] == '.'){\n\t    cp.x = j; cp.y = i;\n\t    s = xsolve(cp);\n\t    if(ret <= s && s != 0){\n\t      ret = s;\n\t      t = cp;\n\t    }\n\n\t  }\n\t}\n      }\n    }\n    judge++;\n\n    /*  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      cout << v[i][j];\n    }\n    cout << endl;\n  }\n    \n  cout << t.x << \" \" << t.y << endl;\n  cout << ret << endl;\n    */\n  // if(xx == 11 || yy == 11) continue;\n  if(ret != 0){\n    if(judge%2 == 0)\n      change1(t);\n    else\n      change2(t);\n  }\n  //   break;\n    // cout << \"hoge\";\n    if(vcp == v) ss++;\n    else{\n      ss = 0;\n      vcp = v;\n    }\n    //cout << xx << \" \" << yy << endl;\n    if(ss >= 2) break;\n\n  }\n\n\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      cout << v[i][j];\n    }\n    cout << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool infield(int h, int w){\n    return 0<=h && h<8 && 0<=w && w<8;\n}\n\nint turn_field(vector<string> &field, bool flip, int h, int w, char myc, char opc){\n    if(field[h][w] != '.')\n        return 0;\n    \n    int count = 0;\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            if(i==0 && j==0) continue;\n            \n            int l = 0;\n            int nh = h, nw = w;\n            do{\n                l++;\n                nh = h + i*l;\n                nw = w + j*l;\n            }while(infield(nh, nw) && field[nh][nw] == opc);\n            \n            if(infield(nh, nw) && field[nh][nw] == myc){\n                count += l - 1;\n                if(flip)\n                    for(int k=0; k<l; k++)\n                        field[h+k*i][w+k*j] = myc;\n            }\n        }\n    }\n    return count;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    char turnc[] = {'o', 'x'};\n    int yt[] = {0, 7};\n    int xt[] = {1, -1};\n    \n    \n    vector<string> field(8);\n    for(string &s: field)\n        cin >> s;\n    \n    int pass = 0;\n    int turn = 0;\n    while (pass < 2) {\n        bool update = false;\n        char myc = turnc[turn];\n        char opc = turnc[turn^1];\n        \n        int count = 0;\n        int th, tw;\n        \n        for(int i=0; i<8; i++){\n            for(int j=0; j<8; j++){\n                int h = yt[turn] + xt[turn]*i;\n                int w = yt[turn] + xt[turn]*j;\n                int tcount = turn_field(field, false, h, w, myc, opc);\n                if(count < tcount){\n                    count = tcount;\n                    th = h;\n                    tw = w;\n                    update = true;\n                }\n            }\n        }\n        \n        if(update){\n            turn_field(field, true, th, tw, myc, opc);\n            pass = 0;\n        }else{\n            pass++;\n        }\n        \n        turn ^= 1;\n    }\n    \n    for(string s: field)\n        cout << s << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\nusing namespace std;\nstatic const int H = 8;\nstatic const int W = 8;\n\nstring s[H];\n\nint dy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nchar ch[2] = {'o', 'x'};\n\nbool inside(int y, int x){\n\treturn y >= 0 && y < H && x >= 0 && x < W;\n}\n\nint main(){\n\tfor(int i = 0; i < H; i++) cin >> s[i];\n\tint cnt = 0;\n\tint turn = 0;\n\tfor(;;){\n\t\tif(cnt >= 2) break;\n\t\tcnt++;\n\t\tint y = -1, x = -1, num = 0;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tint cy = i, cx = j;\n\t\t\t\tif(turn == 0){\n\t\t\t\t\tcy = H - i - 1;\n\t\t\t\t\tcx = W - j - 1;\n\t\t\t\t}\n\t\t\t\tif(s[cy][cx] == 'o' || s[cy][cx] == 'x') continue;\n\t\t\t\tint num2 = 0;\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tint ny = cy + dy[k];\n\t\t\t\t\tint nx = cx + dx[k];\n\t\t\t\t\tint cnt2 = 0;\n\t\t\t\t\twhile(inside(ny, nx) && s[ny][nx] == ch[(turn + 1) % 2]){\n\t\t\t\t\t\tny += dy[k];\n\t\t\t\t\t\tnx += dx[k];\n\t\t\t\t\t\tcnt2++;\n\t\t\t\t\t}\n\t\t\t\t\tif(inside(ny, nx) && s[ny][nx] == ch[turn]) num2 += cnt2;\n\t\t\t\t}\n\t\t\t\tif(num2 >= num){\n\t\t\t\t\ty = cy;\n\t\t\t\t\tx = cx;\n\t\t\t\t\tnum = num2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tturn = (turn + 1) % 2;\n\t\tif(num == 0) continue;\n\t\tcnt = 0;\n\t\ts[y][x] = ch[(turn + 1) % 2];\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tint cy = y + dy[i];\n\t\t\tint cx = x + dx[i];\n\t\t\twhile(inside(cy, cx) && s[cy][cx] == ch[turn]){\n\t\t\t\tcy += dy[i];\n\t\t\t\tcx += dx[i];\n\t\t\t}\n\t\t\tif(inside(cy, cx) && s[cy][cx] == ch[(turn + 1) % 2]){\n\t\t\t\tint cy2 = y + dy[i];\n\t\t\t\tint cx2 = x + dx[i];\n\t\t\t\tfor(;;){\n\t\t\t\t\tif(inside(cy2, cx2) && s[cy2][cx2] == ch[(turn + 1) % 2]) break;\n\t\t\t\t\ts[cy2][cx2] = ch[(turn + 1) % 2];\n\t\t\t\t\tcy2 += dy[i];\n\t\t\t\t\tcx2 += dx[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < H; i++) cout << s[i] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;i++)\n#define for_d(i,a,b) for(int i=a-1;i>=b;i--)\n#define minit(a,b) memset(a,b,sizeof(b));\n\nstring board[8];\nint dx[8] = {-1,-1,-1,0,1,1,1,0};\nint dy[8] = {1,0,-1,-1,-1,0,1,1};\n\nint getnum(char c, int x, int y) {\n\tint res = 0;\n\tchar target = (c == 'o') ? 'x' : 'o';\n\t\n\tfor_(d,0,8) {\n\t\tint cnt = 0;\n\t\tbool able = false;\n\t\t\n\t\tfor (int i = 0; i < 8 && !able; i++) {\n\t\t\tint _x = x + (i + 1) * dx[d], _y = y + (i + 1) * dy[d];\n\t\t\tif (!(0 <= _x && _x < 8 && 0 <= _y && _y < 8)) break;\n\t\t\t\t\n\t\t\tif (board[_y][_x] == c) able = true;\n\t\t\tif (board[_y][_x] == target) cnt++;\n\t\t\tif (board[_y][_x] == '.') break;\n\t\t}\n\t\t\n\t\tif (able) res += cnt;\n\t}\n\t\n\treturn res;\n}\n\nvoid simulate(char c, int x, int y) {\n\tboard[y][x] = c;\n\tchar target = (c == 'o') ? 'x' : 'o';\n\t\n\tfor_(d,0,8) {\n\t\tint cnt = 0;\n\t\tbool able = false;\n\t\t\n\t\tfor (int i = 0; i < 8 && !able; i++) {\n\t\t\tint _x = x + (i + 1) * dx[d], _y = y + (i + 1) * dy[d];\n\t\t\tif (!(0 <= _x && _x < 8 && 0 <= _y && _y < 8)) break;\n\t\t\t\t\n\t\t\tif (board[_y][_x] == c) able = true;\n\t\t\tif (board[_y][_x] == target) cnt++;\n\t\t\tif (board[_y][_x] == '.') break;\n\t\t}\n\t\t\n\t\tif (able) {\n\t\t\tfor_(i,0,cnt) {\n\t\t\t\tint _x = x + (i + 1) * dx[d], _y = y + (i + 1) * dy[d];\n\t\t\t\tboard[_y][_x] = c;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor_(i,0,8) cout << board[i] << endl;\n\tcout << endl;\n\t*/\n}\n\nbool MAMI() {\n\tint x = -1, y = -1;\n\tint maxi = 0;\n\t\n\tfor_(i,0,8) {\n\t\tfor_(j,0,8) {\n\t\t\tif (board[i][j] != '.') continue;\n\t\t\tint gn = getnum('o', j, i);\n\t\t\tif (maxi < gn) {\n\t\t\t\tmaxi = gn;\n\t\t\t\tx = j; y = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (x == -1) return false;\n\tsimulate('o', x, y);\n\treturn true;\n}\n\nbool CHARLOTTE() {\n\tint x = -1, y = -1;\n\tint maxi = 0;\n\t\n\tfor_d(i,8,0) {\n\t\tfor_d(j,8,0) {\n\t\t\tif (board[i][j] != '.') continue;\n\t\t\tint gn = getnum('x', j, i);\n\t\t\tif (maxi < gn) {\n\t\t\t\tmaxi = gn;\n\t\t\t\tx = j; y = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (x == -1) return false;\t\n\tsimulate('x', x, y);\n\treturn true;\n}\n\nvoid solve() {\n\tbool run = true;\n\twhile (run) {\n\t\trun &= MAMI();\n\t\trun |= CHARLOTTE();\n\t}\n\t//cout << \"answer\\n\\n\";\n\tfor_(i,0,8) cout << board[i] << endl;\n}\n\nint main() {\n\tfor_(i,0,8) cin >> board[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nint dx[]={-1,0,1,1,1,0,-1,-1},dy[]={-1,-1,-1,0,1,1,1,0};\nint get_num(vs &f,int y,int x,int d,char move){\n\tint ret=0;\n\tint cy=y+dy[d];\n\tint cx=x+dx[d];\n\tint flipped=0;\n\twhile(cy>=0&&cx>=0&&cy<8&&cx<8&&f[cy][cx]!=move&&f[cy][cx]!='.'){\n\t\tcy+=dy[d];\n\t\tcx+=dx[d];\n\t\tflipped++;\n\t}\n\tif(cy>=0&&cx>=0&&cy<8&&cx<8&&f[cy][cx]!='.'){\n\t\tret+=flipped;\n\t}\n\treturn ret;\n}\n\nvoid flip(vs &f,int y,int x,char move){\n\tf[y][x]=move;\n\tREP(d,8){\n\t\tif(get_num(f,y,x,d,move)){\n\t\t\tint cy=y+dy[d];\n\t\t\tint cx=x+dx[d];\n\t\t\twhile(cy>=0&&cx>=0&&cy<8&&cx<8&&f[cy][cx]!=move&&f[cy][cx]!='.'){\n\t\t\t\tf[cy][cx]=move;\n\t\t\t\tcy+=dy[d];\n\t\t\t\tcx+=dx[d];\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar moves[]={'o','x'};\nint main(){\n\tvs f(8);\n\tREP(i,8){\n\t\tcin>>f[i];\n\t}\n\tint changed=2;\n\tint move_i=0;\n\twhile(changed){\n\t\tchanged--;\n\t\tpii best_pos;\n\t\tint best_num=0;\n\t\tREP(i,8){\n\t\t\tREP(j,8){\n\t\t\t\tif(f[i][j]=='.'){\n\t\t\t\t\tint num=0;\n\t\t\t\t\tREP(d,8){\n\t\t\t\t\t\tnum+=get_num(f,i,j,d,moves[move_i]);\n\t\t\t\t\t}\n\t\t\t\t\tif(num){\n\t\t\t\t\t\tchanged=2;\n\t\t\t\t\t}\n\t\t\t\t\tif(num>best_num){\n\t\t\t\t\t\tbest_num=num;\n\t\t\t\t\t\tbest_pos=make_pair(i,j);\n\t\t\t\t\t}else if(num==best_num){\n\t\t\t\t\t\tif(move_i==1){\n\t\t\t\t\t\t\tbest_num=num;\n\t\t\t\t\t\t\tbest_pos=make_pair(i,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(changed==2){\n\t\t\tflip(f,best_pos.first,best_pos.second,moves[move_i]);\n\t\t}\n\t\tmove_i=(move_i+1)%2;\n\t}\n\tREP(i,8){\n\t\tcout<<f[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n//#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n//#define EXIST(s, e) ((s).find(e)!=(s).end())\n//#define SORT(c) sort(begin(c),end(c))\n//#define pb emplace_back\n//#define MP make_pair\n//#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\nint H = 8, W = 8;\nvector<string> vs(H);\n\n\nint count_one(int h, int w, char mark, int dh, int dw) {\n    char enemy = (mark == 'o') ? 'x' : 'o';\n\n    string str = \"\";\n    for (int i = h + dh, j = w + dw; j >= 0 && j < W && i >= 0 && i < H; i += dh, j += dw) {\n        str += vs[i][j];\n        if (vs[i][j] == enemy) {\n            continue;\n        } else {\n            break;\n        }\n    }\n\n    if (str.back() == mark) {\n        return static_cast<int>(str.size() - 1);\n    } else {\n        return 0;\n    }\n\n}\n\nint count(int h, int w, char mark) {\n    int dh[] = {1, 1, 0, -1, -1, -1, 0, 1};\n    int dw[] = {0, 1, 1, 1, 0, -1, -1, -1};\n    int ret = 0;\n    rep(i, 0, 8) {\n        ret += count_one(h, w, mark, dh[i], dw[i]);\n    }\n    return ret;\n}\n\nvoid reverse(int h, int w, char mark, int dh, int dw) {\n    char enemy = (mark == 'o') ? 'x' : 'o';\n    for (\n            int i = h + dh, j = w + dw;\n            vs[i][j] != mark;\n            i += dh, j += dw) {\n        vs[i][j] = mark;\n    }\n}\n\nvoid pt(int h, int w, char mark) {\n    int dh[] = {1, 1, 0, -1, -1, -1, 0, 1};\n    int dw[] = {0, 1, 1, 1, 0, -1, -1, -1};\n    vs[h][w] = mark;\n    rep(i, 0, 8) {\n        if (count_one(h, w, mark, dh[i], dw[i]) > 0) {\n            reverse(h, w, mark, dh[i], dw[i]);\n        }\n    }\n}\n\nbool solve() {\n\n    rep(i, 0, H) {\n        cin >> vs[i];\n    }\n\n    int turn = 1;\n    int rest = 64;\n    while (rest--) {\n        int max_v = 0;\n        int max_h = -1;\n        int max_w = -1;\n        bool put = false;\n        if (turn) {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (vs[i][j] == '.') {\n                        int tmp = count(i, j, 'o');\n                        put = true;\n                        if (max_v < tmp) {\n                            max_v = tmp;\n                            max_h = i;\n                            max_w = j;\n                        }\n                    }\n                }\n            }\n            if (max_h != -1) {\n                pt(max_h, max_w, 'o');\n            }\n        } else {\n            for (int i = H - 1; i >= 0; i--) {\n                for (int j = W - 1; j >= 0; j--) {\n                    if (vs[i][j] == '.') {\n                        int tmp = count(i, j, 'x');\n                        put = true;\n                        if (max_v < tmp) {\n                            max_v = tmp;\n                            max_h = i;\n                            max_w = j;\n                        }\n                    }\n\n                }\n            }\n            if (max_h != -1) {\n                pt(max_h, max_w, 'x');\n            }\n        }\n\n        turn ^= 1;\n\n        if (false) {\n            rep(i, 0, H) {\n                cout << vs[i] << endl;\n            }\n            cout << \"---\" << endl;\n        }\n    }\n\n    rep(i, 0, H) {\n        cout << vs[i] << endl;\n    }\n\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int Size=8;\nchar coma[2]={'o','x'};\n\nbool isRange(int i){\n  return 0<=i && i< Size;\n}\nbool isRange(int i,int j){\n  return isRange(i) && isRange(j);\n}\n\nint inc(int &i){return ++i;};\nint decr(int &i){return --i;};\nint dx[8]={1,1,1,-1,-1,-1,0,0};\nint dy[8]={1,0,-1,1,0,-1,1,-1};\n\nint check(int i,int j,vector<string> &s,int turn){\n  if(s[i][j]!='.') return -1;\n  int res=0;\n  for(int dir=0;dir<8;dir++){\n    for(int k=1;k<Size;k++){\n      int tox=i+dx[dir]*k;\n      int toy=j+dy[dir]*k;\n      if(!isRange(tox,toy)){\n\tbreak;\n      }\n      if(s[tox][toy]==coma[turn]){\n\tres+=k-1;\n\tbreak;\n      }\n      else if(s[tox][toy]=='.'){\n\tbreak;\n      }\n    }\n\n  }\n  return res;\n}\n\nvoid game(vector<string> &s,int turn){\n  int start_h=turn*(Size-1);\n  int start_w=turn*(Size-1);\n  auto op=decr;\n  if(turn==0){\n    op=inc;\n  }\n  int max_put=0;\n  pair<int,int> res;\n  for(int i=start_h;isRange(i);op(i)){\n    for(int j=start_w;isRange(j);op(j)){\n      int cnt=check(i,j,s,turn);\n      if(cnt>max_put){\n\tmax_put=cnt;\n\tres=make_pair(i,j);\n      }\n    }\n  }\n  if(max_put==0) return;\n  s[res.first][res.second]=coma[turn];\n  for(int i=0;i<8;i++){\n    for(int j=1;j<Size;j++){\n      int tox=res.first+dx[i]*j;\n      int toy=res.second+dy[i]*j;\n      if(!isRange(tox,toy)) break;\n      if(s[tox][toy]==coma[turn]){\n\tfor(;j>=1;j--){\n\t  int x=res.first+dx[i]*j;\n\t  int y=res.second+dy[i]*j;\n\t  s[x][y]=coma[turn];\n\t}\n\tbreak;\n      }\n      else if(s[tox][toy]=='.'){\n\tbreak;\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n  vector<string> s(Size);\n  for(int i=0;i<Size;i++){\n    cin>>s[i];\n  }\n\n  for(int i=0;i<Size*Size;i++){\n    game(s,i%2);\n  }\n  for(int i=0;i<Size;i++){\n    cout<<s[i]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tint qx = x, qy = y, q = 0;\n\t\t\twhile (qx != px || qy != py) {\n\t\t\t\tif(m) c[qy][qx] = t;\n\t\t\t\tqx += dx[i];\n\t\t\t\tqy += dy[i];\n\t\t\t\tif (q++ > 0) ret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1 && t % 2 == 1) { x = j; y = i; r = p; }\n\t\t\t\t\telse if (p > r && p >= 1) { x = j; y = i; r = p; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) { if (v == 0) { v = 1; t++; continue; } break; }\n\t\telse { place(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0; }\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int board[8][8]={{}};\n  string buf;\n  int i,j,k;\n  char cs[]={'.','o','x'};\n  for(i=0;i<8;i++){\n    cin>>buf;\n    for(j=0;j<8;j++){\n      if(buf[j]=='.') board[j][i]=0;\n      if(buf[j]=='o') board[j][i]=1;\n      if(buf[j]=='x') board[j][i]=2;\n    }\n  }\n  int f=1;\n  int ax[]={ 1, 1, 1, 0, 0,-1,-1,-1};\n  int ay[]={ 0, 1,-1, 1,-1,-1, 1, 0};\n  while(f!=0){\n    f=0;\n    int x,y,bx,by,m=0,c,s;\n    for(j=0;j<8;j++){\n      for(i=0;i<8;i++){\n\tc=0;s=0;\n\tx=i;\n\ty=j;\n\tif(board[x][y]!=0) continue;\n\tfor(k=0;k<8;k++){\n\t  s=0;\n\t  x=i;\n\t  y=j;\n\t  //cout << x+ax[k];\n\t  while(0<=x+ax[k]&&x+ax[k]<8&&\n\t\t0<=y+ay[k]&&y+ay[k]<8){\n\t    //cout << board[x+ax[k]][y+ay[k]];\n\t    if(board[x+ax[k]][y+ay[k]]==2){\n\t      s++;\n\t      //cout << s << endl;\n\t      x+=ax[k];y+=ay[k];\n\t    }\n\t    else if(board[x+ax[k]][y+ay[k]]==1) {\n\t      c+=s;\n\t      break;\n\t    }else break;\n\t    \n\t  }\t  \n\t}\n\tif(m<c){\n\t  bx=i;\n\t  by=j;\n\t  m=c;\n\t}\n      }\n    }\n    \n    //cout << m << \" \"<<bx << \" \" << by<< endl;\n    if(m!=0){\n      for(k=0;k<8;k++){\n\ts=0;\n\tx=bx;\n\ty=by;\n\twhile(0<=x+ax[k]&&x+ax[k]<8&&\n\t      0<=y+ay[k]&&y+ay[k]<8){\n\t  if(board[x+ax[k]][y+ay[k]]==2){\n\t    s++;\n\t    x+=ax[k];y+=ay[k];\n\t  }else if(board[x+ax[k]][y+ay[k]]==1) {\n\t    for(int a=0;a<=s;a++) board[bx+ax[k]*a][by+ay[k]*a]=1;\n\t    break;\n\t  }else break;\n\t  \n\t}\n      }\n      f=1;\n    }\n    m=0;\n    for(j=7;j>=0;j--){\n      for(i=7;i>=0;i--){\n\tc=0;s=0;\n\tx=i;\n\ty=j;\n\t\n\tif(board[x][y]!=0) continue;\n\tfor(k=0;k<8;k++){\n\t  s=0;\n\t  x=i;\n\t  y=j;\n\t  while(0<=x+ax[k]&&x+ax[k]<8&&\n\t\t0<=y+ay[k]&&y+ay[k]<8){\n\t    if(board[x+ax[k]][y+ay[k]]==1){\n\t      s++;\n\t      //cout << s << endl;\n\t      x+=ax[k];y+=ay[k];\n\t    }\n\t    else if(board[x+ax[k]][y+ay[k]]==2) {\n\t      c+=s;\n\t      break;\n\t    }else break;\n\t  }\n\t}\n\tif(m<c){\n\t  bx=i;\n\t  by=j;\n\t  m=c;\n\t}\n      }\n    }\n    if(m!=0){\n      for(k=0;k<8;k++){\n\ts=0;\n\tx=bx;\n\ty=by;\n\twhile(0<=x+ax[k]&&x+ax[k]<8&&\n\t      0<=y+ay[k]&&y+ay[k]<8){\n\t  if(board[x+ax[k]][y+ay[k]]==1){\n\t    s++;\n\t    x+=ax[k];y+=ay[k];\n\t  }else if(board[x+ax[k]][y+ay[k]]==2) {\n\t    for(int a=0;a<=s;a++) board[bx+ax[k]*a][by+ay[k]*a]=2;\n\t    break;\n\t  }else break;\n\t  \n\t}\n      }\n      f=1;\n    }\n    //cout << m << \" \"<<bx << \" \" << by<< endl;\n    //f*=0;\n  }\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++){\n      cout << cs[board[j][i]];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dd[] = {1, 2, 4, 8, 16, 32, 64, 128};\nconst char color[] = {'o', '\\0', 'x'};\n\n\nclass Point\n{\npublic:\n  int x, y, dir, v;\n  Point(int xx, int yy, int dd, int vv)\n    :x(xx), y(yy), dir(dd), v(vv) {}\n};\n\nclass Mami\n{\npublic:\n  bool operator() (const Point& lhs, const Point& rhs) const\n  {\n    if (lhs.v == rhs.v) {\n      if (lhs.y == rhs.y)\n\treturn lhs.x < rhs.x;\n      return lhs.y < rhs.y;\n    }\n    return lhs.v > rhs.v;\n  }\n};\n\nclass Charlotte\n{\npublic:\n  bool operator() (const Point& lhs, const Point& rhs) const\n  {\n    if (lhs.v == rhs.v) {\n      if (lhs.y == rhs.y)\n\treturn lhs.x > rhs.x;\n      return lhs.y > rhs.y;\n    }\n    return lhs.v > rhs.v;\n  }\n};\n\nint main()\n{\n  vector<string> board;\n  board.push_back(\"##########\");\n  for (int i = 0; i < 8; ++i) {\n    string s;\n    cin >> s;\n    s = \"#\" + s + \"#\";\n    board.push_back(s);\n  }\n  board.push_back(\"##########\");\n  \n  int player = -1;\n  bool mamitta = false;\n  for ( ; ; ) {\n    vector<Point> c;\n    for (int y = 1; y <= 8; ++y) {\n      for (int x = 1; x <= 8; ++x) {\n\tif (board[y][x] == '.') {\n\t  int dir = 0, flip = 0;\n\t  for (int k = 0; k < 8; ++k) {\n\t    int cnt = 0;\n\t    int xx = x + dx[k];\n\t    int yy = y + dy[k];\n\t    if (board[yy][xx] == color[-player+1]) {\n\t      while (board[yy][xx] == color[-player+1]) {\n\t\t++cnt;\n\t\txx += dx[k];\n\t\tyy += dy[k];\n\t      }\n\t      if (board[yy][xx] == color[player+1]) {\n\t\tflip += cnt;\n\t\tdir |= dd[k];\n\t      }\n\t    }\n\t  }\n\t  \n\t  if (dir != 0)\n\t    c.push_back(Point(x, y, dir, flip));\n\t}\n      }\n    }\n\n    if (c.empty()) {\n      if (mamitta)\n\tbreak;\n      mamitta = true;\n      player = -player;\n      continue;\n    }\n\n    mamitta = false;\n    if (player == -1)\n      sort(c.begin(), c.end(), Mami());\n    else\n      sort(c.begin(), c.end(), Charlotte());\n\n    board[c[0].y][c[0].x] = color[player+1];\n    for (int k = 0; k < 8; ++k) {\n      if (c[0].dir & dd[k]) {\n\tint xx = c[0].x + dx[k];\n\tint yy = c[0].y + dy[k];\n\twhile (board[yy][xx] != color[player+1]) {\n\t  board[yy][xx] = color[player+1];\n\t  xx += dx[k];\n\t  yy += dy[k];\n\t}\n      }\n    }\n    player = -player;\n  }\n\n  board.erase(board.begin());\n  board.erase(board.end()-1);\n  for (int i = 0; i < 8; ++i) {\n    board[i].erase(board[i].begin());\n    board[i].erase(board[i].end()-1);\n    cout << board[i] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nstring fi[8];\nbool range88(int x,int y){\n  return 0<=x && x<8 && 0<=y && y<8;\n}\nint mov(int x,int y,bool d,char t){\n  if(!range88(x,y)||fi[x][y]!='.') return 0;\n  int answer=0;\n  FOR(dx,-1,2) FOR(dy,-1,2){\n    if(!dx&&!dy) continue;\n    FOR(st,1,10){\n      int tx=x+dx*st,ty=y+dy*st;\n      if(!range88(tx,ty)||fi[tx][ty]=='.') break;\n      if(fi[tx][ty]==t){\n\tif(d) FOR(tst,1,st) fi[x+dx*tst][y+dy*tst]=t;\n\tanswer+=st-1;\n\tbreak;\n      }\n    }\n  }\n  if(answer){\n    if(d) fi[x][y]=t;\n    return answer+1;\n  }\n  return 0;\n}\n\nint main(void)\n{\n  REP(i,8) cin >> fi[i];\n  char turn[2]={'o','x'};\n  REP(i,128){\n    int tmpm=0,tmpx=-1,tmpy=-1;\n    REP(j,8) REP(k,8){\n      int tx=j,ty=k;\n      if(i%2){\n\ttx=7-tx,ty=7-ty;\n      }\n      if(fi[tx][ty]!='.') continue;\n      int tmp=mov(tx,ty,false,turn[i%2]);\n      if(tmp>tmpm){\n\ttmpm=tmp;\n\ttmpx=tx;\n\ttmpy=ty;\n      }\n    }\n    mov(tmpx,tmpy,true,turn[i%2]);\n    if(false && i<10 && tmpm){\n      cout << tmpx << ' ' << tmpy << endl;\n      REP(i,8) cout << fi[i] << endl;\n      cout << endl;\n    }\n  }\n  REP(i,8) cout << fi[i] << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n\ninline bool inside(int i, int j, int n){\n  return 0 <= i && i < n && 0 <= j && j < n;\n}\n\npair<int, vector<string> > flip(const vector<string> &field, int x, int y, char c){\n  int n = field.size();\n  \n  int ans = 0;\n  vector<string> board = field;\n  board[x][y] = c;\n  \n  REP2(dx, -1, 2)REP2(dy, -1, 2){\n    if(dx == 0 && dy == 0) continue;\n    int tx = x + dx, ty = y + dy;\n    \n    while(inside(tx, ty, n) && board[tx][ty] != '.' && board[tx][ty] != c){\n      tx += dx;\n      ty += dy;\n    }\n    \n    if(inside(tx, ty, n) && board[tx][ty] == c){\n      tx = x + dx, ty = y + dy;\n      while(inside(tx, ty, n) && board[tx][ty] != '.' && board[tx][ty] != c) {\n        board[tx][ty] = c;\n        tx += dx;\n        ty += dy; \n        ans++;\n      }\n    }\n  }\n  return make_pair(ans, board);\n}\n\nint main(){\n  vector<string> field(8);\n  int  bad = 0;\n  bool mami = true;  \n  REP(i, 8) cin >> field[i];\n\n  while(true){\n    int best = 0;\n    vector<string> bestboard;\n    \n    REP(i, 8) REP(j, 8)if(field[i][j] == '.'){\n      pair<int, vector<string> > p = flip(field, i, j, mami ? 'o' : 'x');\n      if(p.first > best || (!mami && p.first >= best)){\n        best = p.first;\n        bestboard = p.second;\n      }\n    }\n    \n    if(best > 0){\n      bad = 0;\n      field = bestboard;\n    }\n    \n    if(best == 0 && bad++ > 10) break;\n    mami = !mami;\n  }\n  REP(i, 8) cout << field[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <functional>\nusing namespace std;\ntypedef tuple<int,int,int> tiii;\n\ntypedef struct{\n\tint x;\n\tint y;\n}dir;\nvector<dir>D={\n\t{-1,-1},{0,-1},{1,-1},\n\t{-1,0},{1,0},\n\t{-1,1},{0,1},{1,1},\n};\n\nconst int H=8,W=8;\nvector<function<bool(tiii&,tiii&)> >sorter={\n\t[](tiii &a,tiii &b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)>get<2>(b))return true;\n\t\tif(get<2>(a)<get<2>(b))return false;\n\t\tif(get<1>(a)>get<1>(b))return true;\n\t\tif(get<1>(a)<get<1>(b))return false;\n\t\treturn false;\n\t},\n\t[](tiii &a,tiii &b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)<get<2>(b))return true;\n\t\tif(get<2>(a)>get<2>(b))return false;\n\t\tif(get<1>(a)<get<1>(b))return true;\n\t\tif(get<1>(a)>get<1>(b))return false;\n\t\treturn false;\n\t}\n};\n\nint check2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=check2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\treturn r+1;\n}\nint check1(int color,int x,int y,vector<string>&m){\n\tint R=-1;\n\tfor(auto &d:D){\n\t\tint r=check2(color,d,x+d.x,y+d.y,m);\n\t\tif(r>0){\n\t\t\tif(R<0)R=0;\n\t\t\tR+=r;\n\t\t}\n\t}\n\treturn R;\n}\n\nint fill2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=fill2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\tm[y][x]=color;\n\treturn r+1;\n}\nvoid fill1(int color,int x,int y,vector<string>&m){\n\tfor(auto &d:D){\n\t\tfill2(color,d,x+d.x,y+d.y,m);\n\t}\n}\n\nint main(){\n\tstring color=\"ox\";\n\tvector<string>m(H);\n\tfor(int h=0;h<H;h++)cin>>m[h];\n\tint turn=0,pass=0;\n\tfor(;;){\n\t\tvector<tiii>v;\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)if(m[y][x]=='.'){\n\t\t\tint r=check1(color[turn],x,y,m);\n\t\t\tif(r>0)v.push_back(make_tuple(r,x,y));\n\t\t}\n\t\tif(v.empty()){\n\t\t\tpass++;\n\t\t\tif(pass>1)break;\n\t\t}else{\n\t\t\tpass=0;\n\t\t\tsort(v.begin(),v.end(),sorter[turn]);\n\t\t\ttiii &t=*v.rbegin();\n\t\t\tfill1(color[turn],get<1>(t),get<2>(t),m);\n\t\t\tm[get<2>(t)][get<1>(t)]=color[turn];\n\t\t}\n\t\tturn^=1;\n\t}\n\tfor(int h=0;h<H;h++)cout<<m[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> mov;\n\nchar S[8][8];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < 8 && 0 <= x && x < 8;\n}\n\nint main(void) {\n  REP(i, 0, 8) cin >> S[i];\n\n  char me = 'o';\n  char op = me == 'x' ? 'o' : 'x';\n  char em = '.';\n  int pass = 0;\n  while(1) {\n    int ans = 0, ay = -1, ax = -1;\n    vector<mov> mv;\n    REP(i, 0, 8) REP(j, 0, 8) {\n      if(S[i][j] != em) continue;\n      int cnt = 0;\n      vector<mov> v;\n      REP(k, -1, 2) REP(l, -1, 2) {\n        int y = i, x = j;\n        if(k == 0 && l == 0) continue;\n        int q = 0;\n        while(1) {\n          y += k;\n          x += l;\n          if(!isin(y, x)) break;\n          if(S[y][x] == op) q++;\n          else break;\n        }\n        if(!(isin(y, x) && S[y][x] == me)) q = 0;\n        cnt += q;\n        if(q > 0) v.push_back(mov(pii(k, l), q));\n      }\n      if((me == 'o' && ans < cnt) || (me == 'x' && ans <= cnt)) {\n        mv = v;\n        ans = cnt;\n        ay = i;\n        ax = j;\n      }\n    }\n    if(mv.size() > 0) {\n      S[ay][ax] = me;\n      REP(i, 0, mv.size()) {\n        int y = ay, x = ax;\n        REP(j, 0, mv[i].se) {\n          y += mv[i].fi.fi;\n          x += mv[i].fi.se;\n          S[y][x] = me;\n        }\n      }\n      pass = 0;\n    } else {\n      if(pass == 1) break;\n      pass = 1;\n    }\n    swap(me, op);\n\n    REP(i, 0, 8) {\n      REP(j, 0, 8) cout << S[i][j];\n      cout << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> b;\nint turn(int);\nint loo(int,int,int,char,int);\nint chan(int,int,char,int);\nint main(){\n  b=vector<string>(8);\n  for(int i=0;i<b.size();i++){\n    cin >> b[i];\n  }\n  int o=1;\n  int x=0;\n  int co=0;\n  while(1){\n    if(turn(o)==-1)co++;\n    else co=0;\n    if(co==2)break;\n    swap(o,x);\n  }\n  for(int i=0;i<b.size();i++){\n    cout << b[i] << endl;\n  }\n  return 0;\n}\nint turn(int pl){\n  char a;\n  int dx[]={-1,0,1,-1,1,-1,0,1};\n  int dy[]={-1,-1,-1,0,0,1,1,1};\n  int x[3];\n  int ma=0;\n  pair<int,int> mp;\n  if(pl==1){\n    a='o';\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tif(b[i][j]!='.')continue;\n\tint cha=0;\n\tfor(int k=0;k<8;k++){\n\t  cha+=loo(i+dx[k],j+dy[k],0,a,k);\n\t}\n\t//cout << cha << endl;\n\tif(cha>ma){\n\t  ma=cha;\n\t  mp={i,j};\n\t}\n      }\n    }\n  }\n  else{\n    a='x';\n    for(int i=b.size()-1;i>=0;i--){\n      for(int j=b[i].size()-1;j>=0;j--){\n\tif(b[i][j]!='.')continue;\n\tint cha=0;\n\tfor(int k=0;k<8;k++){\n\t  cha+=loo(i+dx[k],j+dy[k],0,a,k);\n\t}\n\tif(cha>ma){\n\t  ma=cha;\n\t  mp={i,j};\n\t}\n      }\n    }\n  }\n\n  if(ma==0)return -1;\n  //cout << mp.first << \" \" << mp.second << endl;\n  b[mp.first][mp.second]=a;\n  for(int k=0;k<8;k++){\n    chan(mp.first+dx[k],mp.second+dy[k],a,k);\n  }\n  return 0;\n}\nint loo(int I,int J,int c,char a,int k){\n\n  int dx[]={-1,0,1,-1,1,-1,0,1};\n  int dy[]={-1,-1,-1,0,0,1,1,1};\n  if(I<0||I>7||J<0||J>7)return 0;\n  //cout << \"look\"<< I << J << endl;\n  if(b[I][J]==a)return c;\n  else if(b[I][J]=='.')return 0;\n  return loo(I+dx[k],J+dy[k],c+1,a,k);\n}\nint chan(int I,int J,char a,int k){\n  //cout << \"look\"<< I << J << endl;\n  int dx[]={-1,0,1,-1,1,-1,0,1};\n  int dy[]={-1,-1,-1,0,0,1,1,1};\n  if(I<0||I>7||J<0||J>7)return -1;\n  if(b[I][J]==a)return 1;\n  else if(b[I][J]=='.')return -1;\n  if(chan(I+dx[k],J+dy[k],a,k)==1){\n    b[I][J]=a;\n    return 1;\n  }\n  return -1;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 1<<29;\n\nstring brd[8];\n\nchar r(char c) { return c=='o'?'x':'o'; }\n\nint dx[] = { 0, 0, -1, -1, -1, 1, 1, 1 };\nint dy[] = { -1, 1, -1, 0, 1, -1, 0, 1 };\n\nclass node {\npublic:\n\tchar t;\n\tint n, x, y;\n\tnode(char t, int n, int x, int y):t(t), n(n), x(x), y(y) {}\n\n\tbool operator>(const node &r) const {\n\t\tif (t == 'o')\n\t\t\treturn n>r.n \n\t\t\t\t|| (n == r.n && y < r.y)\n\t\t\t\t|| (n == r.n && y == r.y && x < r.x);\n\t\telse\n\t\t\treturn n>r.n \n\t\t\t\t|| (n == r.n && y > r.y)\n\t\t\t\t|| (n == r.n && y == r.y && x > r.x);\n\t}\n};\n\nint num(char t, int x, int y, int d, int n)\n{\n\tint nx = x + (n+1)*dx[d];\n\tint ny = y + (n+1)*dy[d];\n\tif (!(0 <= nx && nx < 8)) return 0;\n\tif (!(0 <= ny && ny < 8)) return 0;\n\tif (brd[ny][nx] == '.') return 0;\n\tif (brd[ny][nx] == t) return n;\n\treturn num(t, x, y, d, n+1);\n}\n\nbool can_put(char t)\n{\n\trep(y, 8)\n\t\trep(x, 8)\n\t\t\tif (brd[y][x] == '.')\n\t\t\t\trep(d, 8)\n\t\t\t\t\tif (num(t, x, y, d, 0) > 0)\n\t\t\t\t\t\treturn true;\n\treturn false;\n}\n\nvoid paint(char t, int x, int y, int d, int n)\n{\n\tint nx = x + (n+1)*dx[d];\n\tint ny = y + (n+1)*dy[d];\n\tif (!(0 <= nx && nx < 8)) return;\n\tif (!(0 <= ny && ny < 8)) return;\n\tif (brd[ny][nx] == '.') return;\n\tif (brd[ny][nx] == t) return;\n\tif (brd[ny][nx] == r(t)) {\n\t\tbrd[ny][nx] = t;\n\t\treturn paint(t, x, y, d, n+1);\n\t}\n}\n\nvoid change(char t, int x, int y)\n{\n\tbrd[y][x] = t;\n\trep(d, 8)\n\t\tif (num(t, x, y, d, 0) > 0)\n\t\t\tpaint(t, x, y, d, 0);\n}\n\nint main()\n{\n\trep(i, 8)\n\t\tgetline(cin, brd[i]);\n\n\tfor (char turn = 'o'; ; turn=r(turn)) {\n\t\tif (!can_put(turn)) {\n\t\t\tif (!can_put(r(turn)))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tnode p = node(turn, -INF, -INF, -INF);\n\t\trep(y, 8)\n\t\t\trep(x, 8)\n\t\t\t\tif (brd[y][x] == '.') {\n\t\t\t\t\tint n = 0;\n\t\t\t\t\trep(d, 8)\n\t\t\t\t\t\tn += num(turn, x, y, d, 0);\n\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\tnode buf = node(turn, n, x, y);\n\t\t\t\t\t\tif (buf > p)\n\t\t\t\t\t\t\tp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tchange(turn, p.x, p.y);\n\t}\n\trep(i, 8)\n\t\tcout << brd[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nvector<string> turn(vector<string> board) {\n  vector<string> next(8);\n  rep (i, 8) {\n    rep (j, 8) {\n      switch (board[7 - i][7 - j]) {\n      case 'o':\n\tnext[i] += \"x\";\n\tbreak;\n      case 'x':\n\tnext[i] += \"o\";\n\tbreak;\n      case '.':\n\tnext[i] += \".\";\n\tbreak;\n      }\n    }\n  }\n  return next;\n}\n\nint dx[] = {1, 1, 1, 0, 0, -1, -1, -1};\nint dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nvector<string> move(vector<string> board) {\n  int ii = -1, jj = -1, mx = 0, mb;\n  rep (i, 8) rep (j, 8) if (board[i][j] == '.') {\n    int c = 0, bit = 0;\n    rep (k, 8) {\n      int cc = 0;\n      for (int l = 1; l < 8; ++l) {\n\tif (i + l * dy[k] < 0 || 8 <= i + l * dy[k]) break;\n\tif (j + l * dx[k] < 0 || 8 <= j + l * dx[k]) break;\n\tif (board[i + l * dy[k]][j + l * dx[k]] == 'o') {\n\t  c += cc;\n\t  bit |= 1 << k;\n\t  break;\n\t}\n\tif (board[i + l * dy[k]][j + l * dx[k]] == 'x') {\n\t  ++cc;\n\t}\n\tif (board[i + l * dy[k]][j + l * dx[k]] == '.') {\n\t  break;\n\t}\n      }\n    }\n    if (mx < c) {\n      mx = c;\n      mb = bit;\n      ii = i;\n      jj = j;\n    }\n  }\n  if (ii == -1 && jj == -1) return board;\n  board[ii][jj] = 'o';\n  rep (k, 8) if (mb & (1 << k)) {\n    for (int l = 1; l < 8; ++l) {\n      if (board[ii + l * dy[k]][jj + l * dx[k]] == 'o') break;\n      board[ii + l * dy[k]][jj + l * dx[k]] = 'o';\n    }\n  }\n  return board;\n}\n\nint main() {\n  vector<string> board(8);\n  rep (i, 8) cin >> board[i];\n  rep (iii, 100) {\n    board = move(board);\n    board = turn(board);\n    board = move(board);\n    board = turn(board);\n  }\n  rep (i, 8) cout << board[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nenum PLAYER{\n\tEnemy,\n\tWizzard,\n\tDid,\n\tPassed,\n};\n\nenum DIST{\n\tMigi,\n\tHidari,\n\tUe,\n\tShita,\n\tMigiue,\n\tHidarishita,\n\tMigishita,\n\tHidariue,\n};\n\nstruct Info{\n\tint row,col,num;\n\tbool checkTable[8];\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 7 && col >= 0 && col <= 7)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\tchar table[8][9],mine,yours;\n\tInfo work[64];\n\tint work_index;\n\tbool FLG;\n\n\tfor(int i = 0; i < 8; i++){\n\t\tscanf(\"%s\",table[i]);\n\t}\n\n\tPLAYER player = Enemy,state = Did;\n\n\twhile(true){\n\n\t\tif(player == Enemy){\n\t\t\tmine = 'o';\n\t\t\tyours = 'x';\n\t\t}else{\n\t\t\tmine = 'x';\n\t\t\tyours = 'o';\n\t\t}\n\n\t\tfor(int i = 0; i < 64; i++){\n\t\t\twork[i].num = 0;\n\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\twork[i].checkTable[k] = false;\n\t\t\t}\n\t\t}\n\n\t\twork_index = 0;\n\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int k = 0,p; k < 8; k++){\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i,k+1) == true && table[i][k+1] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i,k+1+p) == true && table[i][k+1+p] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i,k+1+p) == true &&table[i][k+1+p] == mine){\n\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\twork[work_index].checkTable[Migi] = true;\n\t\t\t\t\t\twork_index++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i,k-1) == true && table[i][k-1] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i,k-1-p) == true && table[i][k-1-p] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i,k-1-p) == true && table[i][k-1-p] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Hidari] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Hidari] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i-1,k) == true && table[i-1][k] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i-1-p,k) == true && table[i-1-p][k] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i-1-p,k) == true && table[i-1-p][k] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Ue] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Ue] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i+1,k) == true && table[i+1][k] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i+1+p,k) == true && table[i+1+p][k] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i+1+p,k) == true && table[i+1+p][k] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Shita] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Shita] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i+1,k+1) == true && table[i+1][k+1] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i+1+p,k+1+p) == true && table[i+1+p][k+1+p] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i+1+p,k+1+p) == true && table[i+1+p][k+1+p] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Migishita] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Migishita] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i-1,k-1) == true && table[i-1][k-1] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i-1-p,k-1-p) == true && table[i-1-p][k-1-p] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i-1-p,k-1-p) == true && table[i-1-p][k-1-p] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Hidariue] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Hidariue] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i-1,k+1) == true && table[i-1][k+1] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i-1-p,k+1+p) == true && table[i-1-p][k+1+p] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i-1-p,k+1+p) == true && table[i-1-p][k+1+p] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Migiue] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Migiue] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(table[i][k] == '.' && rangeCheck(i+1,k-1) == true && table[i+1][k-1] == yours){\n\t\t\t\t\tfor(p = 0; rangeCheck(i+1+p,k-1-p) == true && table[i+1+p][k-1-p] == yours;p++);\n\t\t\t\t\tif(rangeCheck(i+1+p,k-1-p) == true && table[i+1+p][k-1-p] == mine){\n\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tfor(int a = 0; a < work_index;a++){\n\t\t\t\t\t\t\tif(work[a].row == i && work[a].col == k){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twork[a].num += p;\n\t\t\t\t\t\t\t\twork[a].checkTable[Hidarishita] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\t\twork[work_index].row = i;\n\t\t\t\t\t\t\twork[work_index].col = k;\n\t\t\t\t\t\t\twork[work_index].num += p;\n\t\t\t\t\t\t\twork[work_index].checkTable[Hidarishita] = true;\n\t\t\t\t\t\t\twork_index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(work_index == 0){\n\t\t\tif(state == Did){\n\t\t\t\tstate = Passed;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else{\n\t\t\tstate = Did;\n\n\t\t\tif(player == Enemy){\n\t\t\t\tfor(int a = 1; a <= work_index-1; a++){\n\t\t\t\t\tfor(int b = work_index-1; b >=a; b--){\n\t\t\t\t\t\tif((work[b].num > work[b-1].num) || (work[b].num == work[b-1].num && work[b].row < work[b-1].row) ||\n\t\t\t\t\t\t\t\t (work[b].num == work[b-1].num && work[b].row == work[b-1].row && work[b].col < work[b-1].col)){\n\t\t\t\t\t\t\tswap(work[b],work[b-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tfor(int a = 1; a <= work_index-1; a++){\n\t\t\t\t\tfor(int b = work_index-1; b >=a; b--){\n\t\t\t\t\t\tif((work[b].num > work[b-1].num) || (work[b].num == work[b-1].num && work[b].row > work[b-1].row) ||\n\t\t\t\t\t\t\t\t (work[b].num == work[b-1].num && work[b].row == work[b-1].row && work[b].col > work[b-1].col)){\n\t\t\t\t\t\t\tswap(work[b],work[b-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\ttable[work[0].row][work[0].col] = mine;\n\n\t\t\tif(work[0].checkTable[Migi] == true){\n\t\t\t\tfor(int c = work[0].col+1;table[work[0].row][c] == yours; c++){\n\t\t\t\t\ttable[work[0].row][c] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Hidari] == true){\n\t\t\t\tfor(int c = work[0].col-1;table[work[0].row][c] == yours; c--){\n\t\t\t\t\ttable[work[0].row][c] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Ue] == true){\n\t\t\t\tfor(int c = work[0].row-1;table[c][work[0].col] == yours; c--){\n\t\t\t\t\ttable[c][work[0].col] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Shita] == true){\n\t\t\t\tfor(int c = work[0].row+1;table[c][work[0].col] == yours; c++){\n\t\t\t\t\ttable[c][work[0].col] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Migishita] == true){\n\t\t\t\tfor(int c = 1;table[work[0].row+c][work[0].col+c] == yours;c++){\n\t\t\t\t\ttable[work[0].row+c][work[0].col+c] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Hidariue] == true){\n\t\t\t\tfor(int c = 1;table[work[0].row-c][work[0].col-c] == yours;c++){\n\t\t\t\t\ttable[work[0].row-c][work[0].col-c] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Migiue] == true){\n\t\t\t\tfor(int c = 1;table[work[0].row-c][work[0].col+c] == yours;c++){\n\t\t\t\t\ttable[work[0].row-c][work[0].col+c] = mine;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(work[0].checkTable[Hidarishita] == true){\n\t\t\t\tfor(int c = 1;table[work[0].row+c][work[0].col-c] == yours;c++){\n\t\t\t\t\ttable[work[0].row+c][work[0].col-c] = mine;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(player == Enemy){\n\t\t\tplayer = Wizzard;\n\t\t}else{\n\t\t\tplayer = Enemy;\n\t\t}\n\n\t}\n\n\tfor(int i = 0; i < 8; i++){\n\t\tfor(int k = 0; k < 8; k++)printf(\"%c\",table[i][k]);\n\t\tprintf(\"\\n\");\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\n\tchar s[10][10];\n\tint x[8] = {-1,0,1,-1,1,-1,0,1};\n\tint y[8] = {1,1,1,0,0,-1,-1,-1};\n\nbool check(){\n\tint dcount = 0;\n\tint ocount = 0;\n\tint xcount = 0;\n\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tif(s[i][j] == 'o'){\n\t\t\t\tocount++;\n\t\t\t}\n\t\t\telse if(s[i][j] == 'x'){\n\t\t\t\txcount++;\n\t\t\t}\n\t\t\telse if(s[i][j] == '.'){\n\t\t\t\tdcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(dcount == 0 || ocount == 0 || xcount == 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid witch(){\n\tint imax = 0,jmax = 0,kmax,maxcount = 0,count1,count2;\n\tint ax,ay;\n\tvector<int> vec,maxvec;\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tcount2 = 0;\n\t\t\tif(s[i][j] == '.'){\n\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\tay = i+y[k];\n\t\t\t\t\tax = j+x[k];\n\t\t\t\t\tif(s[ay][ax] == 'o'){\n\t\t\t\t\t\tcount1 = 1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tay += y[k];\n\t\t\t\t\t\t\tax += x[k];\n\t\t\t\t\t\t\tif(s[ay][ax] == 'o')count1++;\n\t\t\t\t\t\t\telse if(s[ay][ax] == 'x'){\n\t\t\t\t\t\t\t\tcount2 += count1;\n\t\t\t\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count2 >= maxcount){\n\t\t\t\t\tmaxcount = count2;\n\t\t\t\t\timax = i;\n\t\t\t\t\tjmax = j;\n\t\t\t\t\tmaxvec.clear();\n\t\t\t\t\tcopy(vec.begin(),vec.end(),back_inserter(maxvec));\n\t\t\t\t}\n\t\t\t\tvec.clear();\n\t\t\t}\n\t\t}\n\t}\n\tif(maxcount > 0){\n\t\ts[imax][jmax] = 'x';\n\t\tfor(int i = 0;i < maxvec.size();i++){\n\t\t\tay = imax;\n\t\t\tax = jmax;\n\t\t\twhile(1){\n\t\t\t\tay += y[maxvec[i]];\n\t\t\t\tax += x[maxvec[i]];\n\t\t\t\tif(s[ay][ax] == 'x')break;\n\t\t\t\telse s[ay][ax] = 'x';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mami(){\n\tint imax = 0,jmax = 0,kmax,maxcount = 0,count1,count2;\n\tint ax,ay;\n\tvector<int> vec,maxvec;\n\tfor(int i = 8;i >= 1;i--){\n\t\tfor(int j = 8;j >= 1;j--){\n\t\t\tcount2 = 0;\n\t\t\tif(s[i][j] == '.'){\n\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\tay = i+y[k];\n\t\t\t\t\tax = j+x[k];\n\t\t\t\t\tif(s[ay][ax] == 'x'){\n\t\t\t\t\t\tcount1 = 1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tay += y[k];\n\t\t\t\t\t\t\tax += x[k];\n\t\t\t\t\t\t\tif(s[ay][ax] == 'x')count1++;\n\t\t\t\t\t\t\telse if(s[ay][ax] == 'o'){\n\t\t\t\t\t\t\t\tcount2 += count1;\n\t\t\t\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count2 >= maxcount){\n\t\t\t\t\tmaxcount = count2;\n\t\t\t\t\timax = i;\n\t\t\t\t\tjmax = j;\n\t\t\t\t\tmaxvec.clear();\n\t\t\t\t\tcopy(vec.begin(),vec.end(),back_inserter(maxvec));\n\t\t\t\t}\n\t\t\t\tvec.clear();\n\t\t\t}\n\t\t}\n\t}\n\tif(maxcount > 0){\n\t\ts[imax][jmax] = 'o';\n\t\tfor(int i = 0;i < maxvec.size();i++){\n\t\t\tay = imax;\n\t\t\tax = jmax;\n\t\t\twhile(1){\n\t\t\t\tay += y[maxvec[i]];\n\t\t\t\tax += x[maxvec[i]];\n\t\t\t\tif(s[ay][ax] == 'o')break;\n\t\t\t\telse s[ay][ax] = 'o';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid game(){\n\twhile(1){\n\t\tif(check()){\n\t\t\tbreak;\n\t\t}\n\t\tmami();\n\t\tif(check()){\n\t\t\tbreak;\n\t\t}\n\t\twitch();\n\t}\n}\n\nint main(){\n\tfor(int i = 0;i < 10;i++){\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\ts[i][j] = ',';\n\t\t}\n\t}\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\n\tgame();\n\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint dx[] = { 1,1,0,-1,-1,-1,0,1 };\nint dy[] = { 0,1,1,1,0,-1,-1,-1 };\n\nchar map[8][8];\n\nint count(int y, int x, char my, char enemy)\n{\n\tint cnt = 0;\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tint temp = 0;\n\n\t\twhile (true) {\n\t\t\tif (ny < 0 || ny >= 8 || nx < 0 || nx >= 8) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (map[ny][nx] == '.') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (map[ny][nx] == enemy) {\n\t\t\t\ttemp++;\n\t\t\t}\n\t\t\telse if (map[ny][nx] == my) {\n\t\t\t\tcnt += temp;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tny += dy[i];\n\t\t\tnx += dx[i];\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nvoid change(int y, int x, char my, char enemy)\n{\n\tmap[y][x] = my;\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tbool flag = false;\n\t\tint count = 0;\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\twhile (true) {\n\t\t\tif (ny < 0 || ny >= 8 || nx < 0 || nx >= 8) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (map[ny][nx] == '.') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (map[ny][nx] == enemy) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if (map[ny][nx] == my) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tny += dy[i];\n\t\t\tnx += dx[i];\n\t\t}\n\n\t\tif (flag == true) {\n\t\t\tny = y + dy[i];\n\t\t\tnx = x + dx[i];\n\n\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\tmap[ny][nx] = my;\n\t\t\t\tny += dy[i];\n\t\t\t\tnx += dx[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool play(char my, char enemy)\n{\n\tbool flag = false;\n\tint max_change = 0;\n\tint puty, putx;\n\n\tif (my == 'o') {\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (map[i][j] == '.') {\n\t\t\t\t\tint cnt = count(i, j, my, enemy);\n\n\t\t\t\t\tif (cnt > max_change) {\n\t\t\t\t\t\tmax_change = cnt;\n\t\t\t\t\t\tputy = i;\n\t\t\t\t\t\tputx = j;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\tfor (int j = 7; j >= 0; j--) {\n\t\t\t\tif (map[i][j] == '.') {\n\t\t\t\t\tint cnt = count(i, j, my, enemy);\n\n\t\t\t\t\tif (cnt > max_change) {\n\t\t\t\t\t\tmax_change = cnt;\n\t\t\t\t\t\tputy = i;\n\t\t\t\t\t\tputx = j;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flag == true) {\n\t\tchange(puty, putx, my, enemy);\n\t}\n\n\treturn flag;\n}\n\nint main()\n{\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tcin >> map[y][x];\n\t\t}\n\t}\n\n\tbool mami = true;\n\tbool charlotte = true;\n\n\twhile (mami == true || charlotte == true) {\n\t\tmami = play('o', 'x');\n\t\tcharlotte = play('x', 'o');\n\t}\n\n\n\tfor (int y = 0; y < 8; y++) {\n\t\tfor (int x = 0; x < 8; x++) {\n\t\t\tcout << map[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring board[8];\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\n\ninline bool ranges(int x,int y){\n\tif(x<0||8<=x)\n\t\treturn false;\n\tif(y<0||8<=y)\n\t\treturn false;\n\treturn true;\n}\n\nvoid move(char f,char e){\n\tint cmax=0;\n\tpii ans;\n\tbool rev=(f=='x');\n\tint s=(rev?-7:0);\n\tint t=(rev? 0:7);\n\n\tfor(int ii=s;ii<=t;ii++){\n\t\tfor(int jj=s;jj<=t;jj++){\n\t\t\tint i=abs(ii),j=abs(jj);\n\t\t\tif(board[i][j]!='.')\n\t\t\t\tcontinue;\n\t\t\tint cur=0;\n\t\t\trep(k,8){\n\t\t\t\tint cx=i,cy=j;\n\t\t\t\tint tmp=0;\n\t\t\t\twhile(ranges(cx+dx[k],cy+dy[k])){\n\t\t\t\t\tcx+=dx[k],cy+=dy[k];\n\t\t\t\t\tif(board[cx][cy]==e)\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ranges(cx,cy)&&board[cx][cy]==f)\n\t\t\t\t\tcur+=tmp;\n\t\t\t}\n\t\t\tif(cur>cmax){\n\t\t\t\tcmax=cur;\n\t\t\t\tans.first=i;\n\t\t\t\tans.second=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(cmax>0){\n\t\trep(i,8){\n\t\t\tint cx=ans.first,cy=ans.second;\n\t\t\tboard[cx][cy]=f;\n\t\t\twhile(ranges(cx+dx[i],cy+dy[i])){\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t\tif(board[cx][cy]!=e)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(board[cx][cy]==f){\n\t\t\t\tcx=ans.first,cy=ans.second;\n\t\t\t\twhile(ranges(cx+dx[i],cy+dy[i])){\n\t\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t\t\tif(board[cx][cy]==e)\n\t\t\t\t\t\tboard[cx][cy]=f;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\trep(i,8) cin >> board[i];\n\tchar f='o',e='x';\n\trep(loop,128){\n\t\tmove(f,e);\n\t\tswap(f,e);\n\t}\n\trep(i,8) cout <<  board[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//??????URL http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311&lang=jp\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nchar board[8][8];\n\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\nchar memo[2]={'o','x'};\n//player 0:mami 1:magi\nint dfs(int x,int y,int cnt,int idx,int player){\n    int nx=x+dx[idx],ny=y+dy[idx];\n    if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]==memo[1-player]){\n      cnt++;\n      return dfs(nx,ny,cnt,idx,player);\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]==memo[player]){\n      return cnt;\n    }\n    else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n      return 0;\n    }\n    return 0;\n}\n\nint count(int x,int y,int player){\n    int res=0;\n    for(int i=0;i<8;i++) res+=dfs(x,y,0,i,player);\n    return res;\n}\n\nint solve(int player){\n    int ma=-1,x,y;\n    if(player==1){\n        for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n          if(board[i][j]=='.'&&count(i,j,player)>ma){\n            ma=count(i,j,player);\n            x=i;y=j;\n          }\n        }\n    }\n    if(player==0){\n        for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n            if(board[i][j]=='.' && count(i,j,player)>ma){\n                ma=count(i,j,player);\n                x=i;y=j;\n            }\n        }//?????§?????????????????´???\n    }\n    if(ma<1) return 0;\n    board[x][y]=memo[player];\n    for(int i=0;i<8;i++){\n      int tmp=dfs(x,y,0,i,player);\n      for(int j=1;j<=tmp;j++){\n        board[x+dx[i]*j][y+dy[i]*j]=memo[player];\n      }\n    }\n    return 1;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=solve(0);\n    magi_flag=solve(1);\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  char F[8][8];\n  int mx=0,my=0,ii,jj,a=0,b=0,sum=0,flag=0,sumi=0;\n  int muki[8][2]={{-1,-1},{1,1},{1,-1},{-1,1},{1,0},{-1,0},{0,1},{0,-1}};\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++)cin>>F[i][j];\n  }\n  while(1){\n    mx=0;my=0;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tsum=0;\n        if(F[i][j]=='.'){\n          for(int k=0;k<8;k++){\n\t    sumi=0;\n\t    a=i+muki[k][0];b=j+muki[k][1];\n\t    if(a>=0 && b>=0 && a<8 && b<8){\n\t      while(1){\n\t\tif(a<0 || b<0 || a>7 || b>7 || F[a][b]=='.'){\n\t\t  sumi=0;\n\t\t  break;\n\t\t}\n\t\tif(F[a][b]=='x')sumi++;\n\t\tif(F[a][b]=='o')break;\n\t\ta+=muki[k][0];b+=muki[k][1];\n\t      }\n\t    }\n\t    sum+=sumi;\n\t  }\n\t  if(sum>mx){\n\t    mx=sum;ii=i;jj=j;\n\t  }\n\t}\n      }\n    }\n    if(mx!=0){\n      for(int i=0;i<8;i++){\n\ta=ii+muki[i][0];b=jj+muki[i][1];flag=0;\n\tif(a>=0 && b>=0 && a<8 && b<8){\n\t  while(1){\n\t    if(a<0 || b<0 || b>7 || a>7||F[a][b]=='.')break;\n\t    if(F[a][b]=='o'){\n\t      flag=1;\n\t      break;\n\t    }\n\t    a+=muki[i][0];b+=muki[i][1];\n\t  }\n\t  if(flag==1){\n\t    a=ii+muki[i][0];b=jj+muki[i][1];\n\t    while(F[a][b]=='x'){\n\t      F[a][b]='o';\n\t      a+=muki[i][0];b+=muki[i][1];\n\t    }\n\t  }\n\t}\n      }\n      F[ii][jj]='o';\n    }\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tsum=0;\n        if(F[i][j]=='.'){\n          for(int k=0;k<8;k++){\n\t    sumi=0;\n\t    a=i+muki[k][0];b=j+muki[k][1];\n\t    if(a>=0 && b>=0 && a<8 && b<8){\n\t      while(1){\n\t\tif(a<0 ||b<0 ||a>7 || b>7 ||F[a][b]=='.'){\n\t\t  sumi=0;\n\t\t  break;\n\t\t}\n\t\tif(F[a][b]=='o')sumi++;\n\t\tif(F[a][b]=='x')break;\n\t\ta+=muki[k][0];b+=muki[k][1];\n\t      }\n\t    }\n\t    sum+=sumi;\n\t  }\n\t  if(sum>=my){\n\t    my=sum;ii=i;jj=j;\n\t  }\n\t}\n      }\n    }\n    if(my!=0){\n      for(int i=0;i<8;i++){\n\ta=ii+muki[i][0];b=jj+muki[i][1];flag=0;\n\tif(a>=0 && b>=0 && a<8 && b<8){\n\t  while(1){\n\t    if(F[a][b]=='x'){\n\t      flag=1;\n\t      break;\n\t    }\n\t    if(a<0 || b<0 || b>7 || a>7 || F[a][b]=='.')break;\n\t    a+=muki[i][0];b+=muki[i][1];\n\t  }\n\t  if(flag==1){\n\t    a=ii+muki[i][0];b=jj+muki[i][1];\n\t    while(F[a][b]=='o'){\n\t      F[a][b]='x';\n\t      a+=muki[i][0];b+=muki[i][1];\n\t    }\n\t  }\n\t}\n      }\n      F[ii][jj]='x';\n    }\n    if(mx==0 && my==0)break;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++)cout<<F[i][j];\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nconst int N=8;\n\nclass GameMgr{\n  char board[N][N];\n  bool CanAccess(int r,int c){\n    if(r<0||N<=r) return false;\n    if(c<0||N<=c) return false;\n    return true;\n  }\npublic:\n  void Init(void){\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        char c;\n        cin>>c;\n        board[i][j]=c;\n      }\n    }\n  }\n  int PutChoco(int r,int c){\n    if(board[r][c]!='.'){\n      return 0;\n    }\n\n    board[r][c]='o';\n\n    int result=0;\n\n    for(int vec_r=-1;vec_r<=1;vec_r++){\n      for(int vec_c=-1;vec_c<=1;vec_c++){\n\n        if(vec_c==0&&vec_r==0) continue;\n\n        int search_r=r,search_c=c;\n\n        while(CanAccess(search_r+vec_r,search_c+vec_c)){\n\n          search_r+=vec_r;\n          search_c+=vec_c;\n\n          if(board[search_r][search_c]=='.'){\n            break;\n          }\n\n          if(board[search_r][search_c]=='o'){\n            int turn_r=r+vec_r,turn_c=c+vec_c;\n            int to_r=search_r,to_c=search_c;\n            while(turn_r!=to_r||turn_c!=to_c){\n              board[turn_r][turn_c]='o';\n              result++;\n              turn_r+=vec_r;\n              turn_c+=vec_c;\n            }\n            break;\n          }\n        }\n\n      }\n    }\n    return result;\n  }\n  int PutCheese(int r,int c){\n    if(board[r][c]!='.'){\n      return 0;\n    }\n\n    board[r][c]='x';\n\n    int result=0;\n\n    for(int vec_r=-1;vec_r<=1;vec_r++){\n      for(int vec_c=-1;vec_c<=1;vec_c++){\n\n        if(vec_c==0&&vec_r==0) continue;\n\n        int search_r=r,search_c=c;\n\n        while(CanAccess(search_r+vec_r,search_c+vec_c)){\n\n          search_r+=vec_r;\n          search_c+=vec_c;\n\n          if(board[search_r][search_c]=='.'){\n            break;\n          }\n\n          if(board[search_r][search_c]=='x'){\n            int turn_r=r+vec_r,turn_c=c+vec_c;\n            int to_r=search_r,to_c=search_c;\n            while(turn_r!=to_r||turn_c!=to_c){\n              board[turn_r][turn_c]='x';\n              result++;\n              turn_r+=vec_r;\n              turn_c+=vec_c;\n            }\n            break;\n          }\n        }\n\n      }\n    }\n    return result;\n  }\n  void Output(void){\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        cout<<board[i][j];\n      }\n      cout<<endl;\n    }\n  }\n};\n\nbool MamiPlay(GameMgr& mgr){\n  int max=0;\n  int final_r=0,final_c=0;\n  for(int r=0;r<N;r++){\n    for(int c=0;c<N;c++){\n      GameMgr new_mgr=mgr;\n      int count=new_mgr.PutChoco(r,c);\n      if(count>max){\n        final_r=r;\n        final_c=c;\n        max=count;\n      }\n    }\n  }\n  if(max==0){\n    return false;\n  }else{\n    mgr.PutChoco(final_r,final_c);\n    return true;\n  }\n}\nbool CharPlay(GameMgr& mgr){\n  int max=0;\n  int final_r=0,final_c=0;\n  for(int r=N-1;r>=0;r--){\n    for(int c=N-1;c>=0;c--){\n      GameMgr new_mgr=mgr;\n      int count=new_mgr.PutCheese(r,c);\n      if(count>max){\n        final_r=r;\n        final_c=c;\n        max=count;\n      }\n    }\n  }\n  if(max==0){\n    return false;\n  }else{\n    mgr.PutCheese(final_r,final_c);\n    return true;\n  }\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  GameMgr mgr;\n  mgr.Init();\n  while(true){\n    bool m=MamiPlay(mgr);\n    bool c=CharPlay(mgr);\n    if(!m&&!c){\n      break;\n    }\n  }\n\n  mgr.Output();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst ll MOD = 1e9+7;\nchar s[8][8];\n\nint sch(int a,int b,char o,char x){\n  int res=0;\n  for(int i=-1;i<2;i++)\n\tfor(int j=-1;j<2;j++){\n\t  if(i==0&&j==0)continue;\n\t  int ti=i+a,tj=j+b;\n\t  int cnt=0;\n\t  while(1){\n\t\tif(ti<0||7<ti||tj<0||7<tj)break;\n\t\tif(s[ti][tj]=='.')break;\n\t\tif(s[ti][tj]==x)cnt++;\n\t\tif(s[ti][tj]==o){\n\t\t  res+=cnt;\n\t\t  break;\n\t\t}\n\t\tti+=i;\n\t\ttj+=j;\n\t  }\n\t}\n  return res;\n}\n\nvoid chg(int a,int b,char o,char x){\n  s[a][b]=o;\n  for(int i=-1;i<2;i++)\n\tfor(int j=-1;j<2;j++){\n\t  if(i==0&&j==0)continue;\n\t  int ti=i+a,tj=j+b;\n\t  while(1){\n\t\tif(ti<0||7<ti||tj<0||7<tj)break;\n\t\tif(s[ti][tj]=='.')break;\n\t\tif(s[ti][tj]==o){\n\t\t  int tx=a+i,ty=b+j;\n\t\t  for(;s[tx][ty]!=o;tx+=i,ty+=j){\n\t\t\ts[tx][ty]=o;\n\t\t  }\n\t\t  break;\n\t\t}\n\t\tti+=i;\n\t\ttj+=j;\n\t  }\n\t}\n}\n\nint main(){\n  \n  for(int i=0;i<8;i++)\n\tfor(int j=0;j<8;j++)\n\t  cin>>s[i][j];\n  \n  while(1){\n\tint f=1;\n\tint ma=0;\n\tint x=-1,y=-1;\n\n\tfor(int i=7;i>=0;i--){\n\t  for(int j=7;j>=0;j--){\n\t\tif(s[i][j]!='.')continue;\n\t\tint t=sch(i,j,'o','x');\n\t\tif(t==0)continue;\n\t\tf=0;\n\t\tif(t>=ma){\n\t\t  ma=t;\n\t\t  x=i,y=j;\n\t\t}\n\t  }\n\t}\n\tif(x!=-1)chg(x,y,'o','x');\n\t/*\n  for(int i=0;i<8;i++){\n\tfor(int j=0;j<8;j++){\n\t  cout<<s[i][j];\n\t}\n\tcout<<endl;\n  }\n\t*/\n\tma=0;\n\tx=-1,y=-1;\n\t\n\tfor(int i=0;i<8;i++){\n\t  for(int j=0;j<8;j++){\n\t\tif(s[i][j]!='.')continue;\n\t\tint t=sch(i,j,'x','o');\n\t\tif(t==0)continue;\n\t\tf=0;\n\t\tif(t>=ma){\n\t\t  ma=t;\n\t\t  x=i,y=j;\n\t\t}\n\t  }\n\t}\n\tif(x!=-1)chg(x,y,'x','o');\n\t/*\n  for(int i=0;i<8;i++){\n\tfor(int j=0;j<8;j++){\n\t  cout<<s[i][j];\n\t}\n\tcout<<endl;\n  }\n\t*/\n\tif(f)break;\n  }\n  \n  for(int i=0;i<8;i++){\n\tfor(int j=0;j<8;j++){\n\t  cout<<s[i][j];\n\t}\n\tcout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> a(9);\nint dy[8] = {-1,-1, 0, 1, 1, 1, 0,-1};\nint dx[8] = { 0, 1, 1, 1, 0,-1,-1,-1};\nchar c[2] = {'x', 'o'};\n\n// x first o second\n\nbool q(int y, int x) {\n    if (y >= 0 && y < 8 && x >= 0 && x < 8) return true;\n    else return false;\n}\n\nint check(int y, int x, int type) {\n    int ret = 0;\n    for (int k = 0; k < 8; k++) {\n        int ty = y+dy[k], tx = x+dx[k];\n        if (q(ty, tx) && a[ty][tx] == c[type]) {\n            int cnt = 1;\n            ty += dy[k], tx += dx[k];\n            while (1) {\n                if (q(ty, tx) && a[ty][tx] == c[type]) {\n                    cnt++;\n                    ty += dy[k]; tx += dx[k];\n                }\n                else break;\n            }\n            if (q(ty, tx) && a[ty][tx] == c[(type+1)%2]) {\n                ret += cnt;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid draw(int y, int x, int type) {\n    //cerr << \"y=\" << y << \" x=\" << x << \" type=\" << type << endl;\n    a[y][x] = c[(type+1)%2];\n    for (int k = 0; k < 8; k++) {\n        int ty = y+dy[k], tx = x+dx[k];\n        if (q(ty, tx) && a[ty][tx] == c[type]) {\n            ty += dy[k], tx += dx[k];\n            while (1) {\n                if (q(ty, tx) && a[ty][tx] == c[type]) {\n                    ty += dy[k]; tx += dx[k];\n                }\n                else break;\n            }\n            if (q(ty, tx) && a[ty][tx] == c[(type+1)%2]) {\n                while (ty != y || tx != x) {\n                    ty -= dy[k]; tx -= dx[k];\n                    a[ty][tx] = c[(type+1)%2];\n                    //cerr << \" draw = \" << ty << \" \" << tx << endl;\n                }\n            }\n        }\n    }\n    /*\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            cerr << a[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n}\n\nint main(void){\n    for (int i = 0; i < 8; i++) cin >> a[i];\n    \n    bool f[2];\n    while (1) {\n        f[0] = false; f[1] = false;\n        for (int k = 0; k < 2; k++) {\n            int p = 0;\n            int bx, by;\n            for (int i = 0; i < 8; i++) {\n                for (int j = 0; j < 8; j++) {\n                    if (a[i][j] == 'o' || a[i][j] == 'x') continue;\n                    int tp = check(i,j,k);\n                    if (tp) {\n                        //cerr << \"i=\" << i << \" j= \" << j << endl;\n                        f[k] = true;\n                        if (tp > p) {\n                            p = tp; by = i; bx = j;\n                        }\n                        else if (tp == p) {\n                            if (k == 0) {\n                                if (i < by) {\n                                    by = i; bx = j;\n                                }\n                                else if (i == by && j < bx) {\n                                    by = i; bx = j;\n                                }\n                            }\n                            else if (k == 1) {\n                                if (i > by) {\n                                    by = i; bx = j;\n                                }\n                                else if (i == by && j > bx) {\n                                    by = i; bx = j;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            //cerr << \"P=\" << p << \" \";\n            if (f[k] == true) draw(by, bx, k);\n        }\n        if (f[0] == false && f[1] == false) break;\n    }\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            cout << a[i][j];\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maximaize(char table[8][8], int turn)\n{\n  char cookie[2] = {'o', 'x'};\n\n  int dx[] = {0, 1, 0, -1, -1, 1, -1, 1};\n  int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n  \n  int maxget = 0;\n  int maxgetx = -1, maxgety = -1;\n  vector<int> maxgetdir;\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++){\n      if(table[i][j] == '.'){\n\tint get = 0;\n\tvector<int> dir;\n\tfor(int k = 0; k < 8; k++){\n\t  int nx = j + dx[k], ny = i + dy[k];\n\t  int cnt = 0;\n\t  while(1){\n\t    if(nx < 0 || 8 <= nx ||\n\t       ny < 0 || 8 <= ny ||\n\t       table[ny][nx] == '.'){\n\t      cnt = 0;\n\t      break;\n\t    } else if(table[ny][nx] == cookie[turn]){\n\t      dir.push_back(k);\n\t      get += cnt;\n\t      break;\n\t    } else if(table[ny][nx] == cookie[(turn+1)%2]){\n\t      cnt++;\n\t      nx += dx[k], ny += dy[k];\n\t    }\n\t  }\n\t}\n\tif(get > maxget && get > 0){\n\t  maxget = get, maxgetdir = dir;\n\t  maxgety = i, maxgetx = j;\n\t} else if(get == maxget && get > 0){\n\t  if(turn == 0){\n\t    if(maxgetx == -1 || i < maxgety || i == maxgety && j <= maxgetx) maxgety = i, maxgetx = j, maxgetdir = dir;\n\t  } else if(turn == 1){\n\t    if(maxgetx == -1 || maxgety < i || maxgety == i && maxgetx <= j) maxgety = i, maxgetx = j, maxgetdir = dir;\n\t  }\n\t}\n      }\n    }\n  }\n  if(maxget > 0){\n    table[maxgety][maxgetx] = cookie[turn];\n    for(int i = 0; i < maxgetdir.size(); i++){\n      int nx = maxgetx + dx[maxgetdir[i]], ny = maxgety + dy[maxgetdir[i]];\n      while(table[ny][nx] != cookie[turn]){\n\ttable[ny][nx] = cookie[turn];\n\tnx += dx[maxgetdir[i]], ny += dy[maxgetdir[i]];\n      }\n    }\n  }/*\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++) cout << table[i][j];\n    cout << endl;\n  }\n  cout << endl;*/\n  return maxget;\n}\n\nbool mami(char table[8][8])\n{\n  return maximaize(table, 0) > 0;\n}\n\nbool majo(char table[8][8])\n{\n  return maximaize(table, 1) > 0;\n}\n\nvoid game(char table[8][8])\n{\n  int flag = false;\n  flag |= mami(table);\n  flag |= majo(table);\n  if(flag) game(table);\n}\n\nint main()\n{\n  char table[8][8];\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++) cin >> table[i][j];\n  }\n  game(table);\n  for(int i = 0; i < 8; i++){\n    for(int j = 0; j < 8; j++) cout << table[i][j];\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> check(vector<vector<char>> &field, int turn) {\n    char ore = 'o';\n    char teki = 'x';\n    if (turn%2 == 0) {\n        ore = 'x';\n        teki = 'o';\n    }\n    \n    pair<int, int> ret = {-1, -1};\n    int ma = 0;\n    if (turn % 2) {\n        for (int i = 1; i <= 8; i++) {\n            for (int j = 1; j <= 8; j++) {\n                if (field[i][j] != '.') continue;\n                int sum = 0;\n                int cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i - k;\n                    int nj = j;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i + k;\n                    int nj = j;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i - k;\n                    int nj = j + k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i + k;\n                    int nj = j - k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i;\n                    int nj = j + k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i;\n                    int nj = j - k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i + k;\n                    int nj = j + k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i - k;\n                    int nj = j - k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                if (ma < sum) {\n                    ma = sum;\n                    ret = {i, j};\n                }\n            }\n        }\n    } else {\n        for (int i = 8; i >= 1; i--) {\n            for (int j = 8; j >= 1; j--) {\n                if (field[i][j] != '.') continue;\n                int sum = 0;\n                int cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i - k;\n                    int nj = j;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i + k;\n                    int nj = j;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i - k;\n                    int nj = j + k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i + k;\n                    int nj = j - k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i;\n                    int nj = j + k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i;\n                    int nj = j - k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i + k;\n                    int nj = j + k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                cnt = 0;\n                for (int k = 1; k < 10; k++) {\n                    int ni = i - k;\n                    int nj = j - k;\n                    if (field[ni][nj] == teki) cnt++;\n                    else if (field[ni][nj] == ore) {\n                        sum += cnt;\n                        break;\n                    } else {\n                        break;\n                    }\n                }\n                if (ma < sum) {\n                    ma = sum;\n                    ret = {i, j};\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid attack(pair<int, int> p, vector<vector<char>> &field, int turn) {\n    char ore = 'o';\n    char teki = 'x';\n    if (turn%2 == 0) {\n        ore = 'x';\n        teki = 'o';\n    }\n    \n    pair<int, int> ret = {-1, -1};\n    int ma = 0;\n    vector<vector<pair<int, int>>> st;\n    for (int i = p.first; i <= p.first; i++) {\n        for (int j = p.second; j <= p.second; j++) {\n            field[i][j] = ore;\n            int sum = 0;\n            int cnt = 0;\n            vector<pair<int, int>> tmp;\n            for (int k = 1; k < 10; k++) {\n                int ni = i - k;\n                int nj = j;\n                if (field[ni][nj] == teki) {\n                    cnt++;\n                    tmp.push_back({ni, nj});\n                }\n                else if (field[ni][nj] == ore) {\n                    sum += cnt;\n                    st.push_back(tmp);\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i + k;\n                int nj = j;\n                if (field[ni][nj] == teki) {\n                    cnt++;\n                    tmp.push_back({ni, nj});\n                }\n                else if (field[ni][nj] == ore) {\n                    sum += cnt;\n                    st.push_back(tmp);\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i - k;\n                int nj = j + k;\n                if (field[ni][nj] == teki) {\n                    cnt++;\n                    tmp.push_back({ni, nj});\n                }\n                else if (field[ni][nj] == ore) {\n                    st.push_back(tmp);\n                    sum += cnt;\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i + k;\n                int nj = j - k;\n                if (field[ni][nj] == teki) {\n                    tmp.push_back({ni, nj});\n                    cnt++;\n                }\n                else if (field[ni][nj] == ore) {\n                    st.push_back(tmp);\n                    sum += cnt;\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i;\n                int nj = j + k;\n                if (field[ni][nj] == teki) {\n                    tmp.push_back({ni, nj});\n                    cnt++;\n                } else if (field[ni][nj] == ore) {\n                    st.push_back(tmp);\n                    sum += cnt;\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i;\n                int nj = j - k;\n                if (field[ni][nj] == teki) {\n                    cnt++;\n                    tmp.push_back({ni, nj});\n                } else if (field[ni][nj] == ore) {\n                    st.push_back(tmp);\n                    sum += cnt;\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i + k;\n                int nj = j + k;\n                if (field[ni][nj] == teki) {\n                    cnt++;\n                    tmp.push_back({ni, nj});\n                } else if (field[ni][nj] == ore) {\n                    st.push_back(tmp);\n                    sum += cnt;\n                    break;\n                } else {\n                    break;\n                }\n            }\n            cnt = 0;\n            tmp.clear();\n            for (int k = 1; k < 10; k++) {\n                int ni = i - k;\n                int nj = j - k;\n                if (field[ni][nj] == teki) {\n                    cnt++;\n                    tmp.push_back({ni, nj});\n                } else if (field[ni][nj] == ore) {\n                    st.push_back(tmp);\n                    sum += cnt;\n                    break;\n                } else {\n                    break;\n                }\n            }\n            if (ma < sum) {\n                ma = sum;\n                ret = {i, j};\n            }\n        }\n    }\n    for (int i = 0; i < st.size(); i++) {\n        for (auto &p : st[i]) {\n            field[p.first][p.second] = ore;\n        }\n    }\n    return;\n}\n\nint main(void) {\n    vector<vector<char>> field(10, vector<char>(10, '#'));\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 8; j++) {\n            cin >> field[i][j];\n        }\n    }\n\n    for (int turn = 1; turn < 150; turn++) {\n        pair<int, int> p = check(field, turn);\n        if (p.first != -1) {\n            attack(p, field, turn);\n        }\n    }\n    \n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 8; j++) {\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\nstring s[8];\n\nbool dfsa(){\n  int cnt=0, linecnt[8]={}, tx = -1, ty = -1;\n  REP(i,0,8){\n    REP(j,0,8){\n      if(s[i][j] != '.') continue;\n      int line[8] = {};\n      REP(k,0,8){\n        if(!CH(j + dx[k], 0, 8) || !CH(i + dy[k], 0, 8)) continue;\n        //if(s[i + dy[k]][j + dx[k]] != 'x') continue;\n        int posx = j + dx[k], posy = i + dy[k];\n        int tmpline = 1;\n        bool flag = false;\n        while(s[posy][posx] == 'x'){\n          if(!CH(posx + dx[k], 0, 8) || !CH(posy + dy[k], 0, 8)) break;\n          if(s[posy + dy[k]][posx + dx[k]] == 'o'){\n            flag = true;\n            break;\n          }\n          tmpline++;\n          posx += dx[k];\n          posy += dy[k];\n        }\n        if(flag){\n          line[k] = tmpline;\n        }\n      }\n      int tmpcnt = 0;\n      REP(k,0,8) tmpcnt += line[k];\n      if(cnt < tmpcnt){\n        cnt = tmpcnt;\n        REP(k,0,8) linecnt[k] = line[k];\n        tx = j; ty = i;\n      }\n    }\n  }\n  if(cnt != 0){\n    s[ty][tx] = 'o';\n    REP(k,0,8){\n      int posx = tx, posy = ty;\n      REP(i,0,linecnt[k]){\n        posx += dx[k];\n        posy += dy[k];\n        s[posy][posx] = 'o';\n      }\n    }\n  }\n  return (cnt != 0) ? true : false;\n}\n\nbool dfsb(){\n  int cnt=0, linecnt[8]={}, tx = -1, ty = -1;\n  RREP(i,0,8){\n    RREP(j,0,8){\n      if(s[i][j] != '.') continue;\n      int line[8] = {};\n      REP(k,0,8){\n        if(!CH(j + dx[k], 0, 8) || !CH(i + dy[k], 0, 8)) continue;\n        //if(s[i + dy[k]][j + dx[k]] != 'o') continue;\n        int posx = j + dx[k], posy = i + dy[k];\n        int tmpline = 1;\n        bool flag = false;\n        while(s[posy][posx] == 'o'){\n          if(!CH(posx + dx[k], 0, 8) || !CH(posy + dy[k], 0, 8)) break;\n          if(s[posy + dy[k]][posx + dx[k]] == 'x'){\n            flag = true;\n            break;\n          }\n          tmpline++;\n          posx += dx[k];\n          posy += dy[k];\n        }\n        if(flag){\n          line[k] = tmpline;\n        }\n      }\n      int tmpcnt = 0;\n      REP(k,0,8) tmpcnt += line[k];\n      if(cnt < tmpcnt){\n        cnt = tmpcnt;\n        REP(k,0,8) linecnt[k] = line[k];\n        tx = j; ty = i;\n      }\n    }\n  }\n  if(cnt != 0){\n    s[ty][tx] = 'x';\n    REP(k,0,8){\n      int posx = tx, posy = ty;\n      REP(i,0,linecnt[k]){\n        posx += dx[k];\n        posy += dy[k];\n        s[posy][posx] = 'x';\n      }\n    }\n  }\n  return (cnt != 0) ? true : false;\n}\n\n\n\nint main() {\n\n  for(int i=0; i<8; i++){\n    cin>>s[i];\n  }\n\n  int turn = 0;\n  bool bflag = true;\n\n  while(1){\n    bool nflag;\n    if(turn % 2 == 0){\n      nflag = dfsa();\n      //test\n      /*\n      cout<<\"A\"<<endl;\n      for(int i=0; i<8; i++){\n        cout<<s[i]<<endl;\n      }\n      */\n    }else{\n      nflag = dfsb();\n      //test\n      /*\n      cout<<\"B\"<<endl;\n      for(int i=0; i<8; i++){\n        cout<<s[i]<<endl;\n      }\n      */\n    }\n    if(!bflag && !nflag) break;\n    bflag = nflag;\n    turn++;\n  }\n\n  for(int i=0; i<8; i++){\n    cout<<s[i]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\nstring F[8];\nbool used[8][8];\nint turn;\n\nbool debug;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n  \n  if(x == 4 && y == 2 && dx == 0 && dy == 1) {\n    cerr << \"pass\\n\";\n  }\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    if(cnt) cerr << \"hit \" << cnt << \"\\n\";\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  \n  rep(i, 8) {\n    cin >> F[i];\n  }\n  \n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    cerr << \"ox\"[turn&1] << endl;\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7)\n      DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        \n        if(mx < r) {\n          cerr << \"update mx \";\n          memcpy(u, used, sizeof u);\n          mx = r;\n          cerr << mx << endl;\n          pl = turn&1;\n        }\n        \n      }\n    }\n    if(mx > 0) {\n      cerr << \"update field\\n\";\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      \n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  \n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (n) ; ++i)\n#define Rrep(i,n) for(int i = (n) ; i >= 0 ; --i)\nint dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1},nx,ny,flg,java[8][8];\nchar mas[8][8];\nint rec(int x,int y,int way,bool pl,int cnt,bool ura){\n  if( x<0 || y<0 || x>=8 || y>=8 ) return 0;\n  if(mas[x][y] == (pl ? 'o' : 'x')) return cnt - 1;\n  if(mas[x][y] == (pl ? 'x' : 'o')){\n    int res = 0;\n    if(res = rec(x+dx[way],y+dy[way],way,pl,cnt+1,ura)){\n      if(ura) mas[x][y] = pl ? 'o' : 'x';\n      return res;\n    }\n  }\n  return 0;\n}\nint judge(int x,int y,bool pl,bool ura){\n  int res = 0;\n  rep(i,8){\n    nx = x + dx[i] , ny = y + dy[i];\n    if(mas[nx][ny]==(pl?'x':'o')) res += rec(nx,ny,i,pl,1,ura);\n  }\n  if(ura) mas[x][y] = pl ? 'o' : 'x';\n  return res;\n}\nbool info(bool p){\n  int big = 0;\n  memset(java,0,sizeof(java));\n  rep(i,8) rep(j,8){\n    int xx = p?i:7-i , yy = p?j:7-j;\n    if(mas[xx][yy] == '.'){\n      java[xx][yy] = judge(xx,yy,p,false);\n      big = max(big,java[xx][yy]);\n    }\n  }\n  if(!big) return false;\n  rep(i,8) rep(j,8){\n    int xx = p?i:7-i , yy = p?j:7-j;\n    if(java[xx][yy] == big ) return judge(xx,yy,p,true);\n  }\n}\nint main(){\n  rep(i,8) rep(j,8){\n    cin >> mas[i][j];\n  }\n  while(flg < 2){\n    flg = info(true) ? 0 : flg + 1;\n    flg = info(false) ? 0 : flg + 1;\n  }\n  rep(i,8){\n    rep(j,8) cout << mas[i][j];\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px), abs(y - py));\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px && qy != py) {\n\t\t\t\t\tc[qx][qy] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) break;\n\t\tplace(y, x, t++ % 2 == 0 ? 'o' : 'x', true);\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  vector<vector<int>> field(8,vector<int>(8,0));\n  int vecx[8]={-1,-1,-1,0,0,1,1,1};\n  int vecy[8]={-1,0,1,-1,1,-1,0,1};\n  string s;\n  for(int i=0;i<8;i++){\n    cin >> s;\n    for(int j=0;j<8;j++){\n      if(s[j]=='o'){\n        field[i][j]=1;\n      }else if(s[j]=='x'){\n        field[i][j]=2;\n      }\n    }\n  }\n  bool turn=true; //true:o false:x\n  bool passed=false;\n  int count,okikae,maxokikae,x,y;\n  int posx,posy;\n  int flag,f;\n  while(1){\n    posx=posy=-1;\n    maxokikae=0;\n    flag=0;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n        if(!field[i][j]){\n          okikae=0;\n          f=0;\n          for(int k=0;k<8;k++){\n            x=j+vecx[k];\n            y=i+vecy[k];\n            count=0;\n            if(0<=y&&y<=7&&0<=x&&x<=7){\n              while(field[y][x]==(turn?2:1)){\n                count++;\n                x+=vecx[k];\n                y+=vecy[k];\n                if(y<0||y>7||x<0||x>7){\n                  x-=vecx[k];\n                  y-=vecy[k];\n                  break;\n                }\n              }\n              if(field[y][x]==(turn?1:2)){\n                okikae+=count;\n                f+=(1<<k);\n              }\n            }\n          }\n          if(okikae>maxokikae){\n            maxokikae=okikae;\n            posx=j;\n            posy=i;\n            flag=f;\n          }else if(okikae==maxokikae){\n            if(!turn){\n              posx=j;\n              posy=i;\n              flag=f;\n            }\n          }\n        }\n      }\n    }\n    if(maxokikae==0){\n      if(passed){\n        for(int i=0;i<8;i++){\n          for(int j=0;j<8;j++){\n            cout << (field[i][j]?(field[i][j]==1?'o':'x'):'.');\n          }\n          cout <<endl;\n        }\n        return 0;\n      }else{\n        // cout << (turn?'o':'x') << endl;\n        passed=true;\n      }\n    }else{\n      // cout << (turn?'o':'x') << endl;\n      // cout << \"(\" << posx << \",\" << posy << \")\" << endl;\n      passed=false;\n      field[posy][posx]=(turn?1:2);\n      for(int k=0;k<8;k++){\n        if(flag&(1<<k)){\n          x=posx+vecx[k];\n          y=posy+vecy[k];\n          if(0<=y&&y<=7&&0<=x&&x<=7){\n            while(field[y][x]==(turn?2:1)){\n              field[y][x]=(turn?1:2);\n              x+=vecx[k];\n              y+=vecy[k];\n              if(y<0||y>7||x<0||x>7){\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    turn=(!turn);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//??????URL http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311&lang=jp\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nchar board[8][8];\n\nint dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nchar memo[2] = {'o', 'x'};\n//player 0:mami 1:magi\nint dfs(int x, int y, int cnt, int idx, int player)\n{\n    int nx = x + dx[idx], ny = y + dy[idx];\n    if (0 <= nx && nx <= 7 && 0 <= ny && ny <= 7 && board[nx][ny] == memo[1 - player])\n    {\n        cnt++;\n        return dfs(nx, ny, cnt, idx, player);\n    }\n    else if (0 <= nx && nx <= 7 && 0 <= ny && ny <= 7 && board[nx][ny] == memo[player])\n    {\n        return cnt;\n    }\n    else if (0 <= nx && nx <= 7 && 0 <= ny && ny <= 7 && board[nx][ny] == '.')\n    {\n        return 0;\n    }\n    return 0;\n}\n\nint count(int x, int y, int player)\n{\n    int res = 0;\n    for (int i = 0; i < 8; i++)\n        res += dfs(x, y, 0, i, player);\n    return res;\n}\n\nint solve(int player)\n{\n    int ma = -1, x, y;\n    if (player == 1)\n    {\n        for (int i = 7; i >= 0; i--)\n            for (int j = 7; j >= 0; j--)\n            {\n                if (board[i][j] == '.' && count(i, j, player) > ma)\n                {\n                    ma = count(i, j, player);\n                    x = i;\n                    y = j;\n                }\n            }\n    }\n    if (player == 0)\n    {\n        for (int i = 0; i < 8; i++)\n            for (int j = 0; j < 8; j++)\n            {\n                if (board[i][j] == '.' && count(i, j, player) > ma)\n                {\n                    ma = count(i, j, player);\n                    x = i;\n                    y = j;\n                }\n            } //?????§?????????????????´???\n    }\n    if (ma < 1)\n        return 0;\n    board[x][y] = memo[player];\n    for (int i = 0; i < 8; i++)\n    {\n        int tmp = dfs(x, y, 0, i, player);\n        for (int j = 1; j <= tmp; j++)\n        {\n            board[x + dx[i] * j][y + dy[i] * j] = memo[player];\n        }\n    }\n    return 1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for (int i = 0; i < 8; i++)\n        for (int j = 0; j < 8; j++)\n            cin >> board[i][j];\n    bool mami_flag = true, magi_flag = true;\n    while (mami_flag || magi_flag)\n    {\n        mami_flag = solve(0);\n        magi_flag = solve(1);\n    }\n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 8; j++)\n        {\n            cout << board[i][j];\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool stop;\nint board[8][8];\nint dr[] = {0,1,1,1,0,-1,-1,-1};\nint dc[] = {1,1,0,-1,-1,-1,0,1};\n\nstruct poc {\n\tint row;\n\tint col;\n\tint count;\n\tvector<int> dir;\n\tbool operator<(const poc& right) const {\n\t\tif (count == right.count) {\n\t\t\tif (row == right.row) {\n\t\t\t\treturn (col < right.col);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (row < right.row);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (count > right.count);\n\t\t}\n\t}\n};\n\nvoid update_board(int p, poc c) {\n\tboard[c.row][c.col] = p;\n\tfor (int i = 0; i < (c.dir).size(); ++i) {\n\t\tint nr = c.row + dr[c.dir[i]];\n\t\tint nc = c.col + dc[c.dir[i]];\n\t\tbool find = false;\n\t\twhile (!find) {\n\t\t\tboard[nr][nc] = p;\n\t\t\tnr += dr[c.dir[i]];\n\t\t\tnc += dc[c.dir[i]];\n\t\t\tif (board[nr][nc] == p) {\n\t\t\t\tfind = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid play_turn(int p) {\n\tvector<poc> cand;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (board[i][j] == 0) {\n\t\t\t\tint count = 0;\n\t\t\t\tvector<int> ds;\n\t\t\t\tfor (int d = 0; d < 8; ++d) {\n\t\t\t\t\tint nr = i + dr[d];\n\t\t\t\t\tint nc = j + dc[d];\n\t\t\t\t\tint rcmin = min(nr,nc);\n\t\t\t\t\tint rcmax = max(nr,nc);\n\t\t\t\t\tif (rcmax < 8 && rcmin >= 0 && board[nr][nc] == -p) {\n\t\t\t\t\t\tbool find = false; \n\t\t\t\t\t\tint tc = 0;\n\t\t\t\t\t\twhile (!find) {\n\t\t\t\t\t\t\tif (board[nr][nc] == p) {\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\tstop = false;\n\t\t\t\t\t\t\t\tds.push_back(d);\n\t\t\t\t\t\t\t\tcount += tc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (board[nr][nc] == -p) {\n\t\t\t\t\t\t\t\t++tc;\n\t\t\t\t\t\t\t\tnr += dr[d];\n\t\t\t\t\t\t\t\tnc += dc[d];\n\t\t\t\t\t\t\t\trcmin = min(nr,nc);\n\t\t\t\t\t\t\t\trcmax = max(nr,nc);\n\t\t\t\t\t\t\t\tif (rcmax >= 8 || rcmin < 0) {\n\t\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ds.size() > 0) {\n\t\t\t\t\tcand.push_back({i,j,count,ds});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cand.size() > 0) {\n\t\tsort(cand.begin(),cand.end());\n\t\tpoc prop = cand[0];\n\t\tif (p == -1) {\n\t\t\tint max_c = cand[0].count;\n\t\t\tfor (int i = 0; i < cand.size() && cand[i].count == max_c; ++i) {\n\t\t\t\tprop = cand[i];\n\t\t\t}\n\t\t}\n\t\tupdate_board(p,prop);\n\t}\n\treturn;\n}\n\nint main(void) {\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tchar c; \n\t\t\tcin >> c;\n\t\t\tif (c == 'x') {\n\t\t\t\tboard[i][j] = -1;\n\t\t\t}\n\t\t\telse if (c == '.') {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboard[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tstop = false;\n\twhile (!stop) {\n\t\tstop = true;\n\t\tplay_turn(1);\n\t\tplay_turn(-1);\n\t}\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\tif (board[i][j] == -1) {\n\t\t\t\tcout << \"x\";\n\t\t\t}\n\t\t\telse if (board[i][j] == 0) {\n\t\t\t\tcout << \".\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"o\";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\n\nchar s[10][10];\nint a[10][10];\nint dx[8]={0,1,0,-1,1,1,-1,-1};\nint dy[8]={1,0,-1,0,1,-1,1,-1};\n\n\nint g(int y,int x,int b){\n  int res=0;\n \n  for(int k=0;k<8;k++){\n    int i=y+dy[k],j=x+dx[k];\n//   if(y==4&&x==4) cout<<b<<' '<<i<<\"  \"<<j<<endl;\n    while(0<=j&&j<8&&0<=i&&i<8&&b*a[i][j]==2){\n      i+=dy[k];\n      j+=dx[k];\n    }\n    if(0<=j&&j<8&&0<=i&&i<8&&b==a[i][j]){\n      if(max(abs(j-x),abs(i-y))>1)\n        res+=max(abs(j-x),abs(i-y));\n    }\n  }\n//  if(x==4&&y==4) cout<<\"         \"<<res<<endl;\n  return res;\n}\n\n\n\nvoid h(int y,int x,int b){\n//  cout<<y<<' '<<x<<endl;\n  a[y][x]=b;\n  /*\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<a[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  for(int k=0;k<8;k++){\n    int i=y+dy[k],j=x+dx[k];\n    while(0<=j&&j<8&&0<=i&&i<8&&b*a[i][j]==2){\n      i+=dy[k];\n      j+=dx[k];\n    }\n    if(0<=j&&j<8&&0<=i&&i<8&&b==a[i][j]){\n     \n      i=y+dy[k];\n      j=x+dx[k];\n      while(b*a[i][j]==2){\n        a[i][j]=b;\n        i+=dy[k];\n        j+=dx[k];\n      }\n    }\n  }\n  /*\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<a[i][j];\n    }\n    cout<<endl;\n  }\n  */\n}\n\nvoid f(){\n\n  int c=0;\n  int flag=2,flag1=2;\n  vector<int> v,w,z;\n  while(flag1){\n     \n    bool hoge=false;\n    v.clear();\n    w.clear();\n    z.clear();\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n    \n        if(a[i][j]!=0) continue;\n        int res=g(i,j,flag);\n        if(res>0){\n          hoge=true;\n          v.push_back(res);\n          w.push_back(i);\n          z.push_back(j);\n        }\n      }\n    }\n    if(hoge){\n//      cout<<v.size()<<endl;\n      int resi=-1,resj=-1,s=0;\n      for(int i=0;i<v.size();i++){\n        if(flag==2&&s<v[i]){\n          resi=w[i];\n          resj=z[i];\n          s=v[i];\n        }\n\n        if(flag==1&&s<=v[i]){\n          resi=w[i];\n          resj=z[i];\n          s=v[i];\n        }\n\n      }\n      h(resi,resj,flag);\n      flag=(flag==2?1:2);\n\n      flag1=2;\n    }\n    else{\n      flag1--; \n      flag=(flag==2?1:2);\n    }\n  }\n}\n\n\nint main(){\n  for(int i=0;i<8;i++){\n    cin>>s[i];\n    for(int j=0;j<8;j++){\n      if(s[i][j]=='o')\n        a[i][j]=2;\n      else if(s[i][j]=='x')\n        a[i][j]=1;\n      else\n        a[i][j]=0;\n    }\n  }\n\n  f();\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      if(a[i][j]==2) s[i][j]='o';\n      if(a[i][j]==1) s[i][j]='x';\n      if(a[i][j]==0) s[i][j]='.';\n    }\n  }\n\n  for(int i=0;i<8;i++){\n    cout<<s[i]<<endl;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nconst int dr[8] = {-1, -1, 1, 1, 0, 0, 1, -1};\nconst int dc[8] = {-1, 1, -1, 1, -1, 1, 0, 0};\n  \nint board[8][8];\n\nint count_lock(int r, int c, int k) {\n  int cnt = 0;\n  \n  REP(i, 8) {\n    int nr = r+dr[i], nc = c+dc[i];\n    while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1))\n      nr += dr[i], nc += dc[i];\n    if (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == k) {\n      nr -= dr[i], nc -= dc[i];\n      while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1)) {\n\tcnt++;\n\tnr -= dr[i], nc -= dc[i];\n      }\n    }\n  }\n  return cnt;\n}\n  \nvoid put_lock(int r, int c, int k){\n  board[r][c] = k;\n  REP(i, 8) {\n    int nr = r+dr[i], nc = c+dc[i];\n    while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1))\n      nr += dr[i], nc += dc[i];\n    if (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == k) {\n      nr -= dr[i], nc -= dc[i];\n      while (0 <= nr && nr < 8 && 0 <= nc && nc < 8 && board[nr][nc] == (k^1)) {\n\tboard[nr][nc] = k;\n\tnr -= dr[i], nc -= dc[i];\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i, 8) {\n    string row;\n    cin >> row;\n    REP(j, 8) {\n      switch(row[j]) {\n      case '.':\n\tboard[i][j] = -1;\n\tbreak;\n      default:\n\tboard[i][j] = row[j] == 'o' ? 0 : 1;\n\tbreak;\n      }\n    }\n  }\n\n  bool flag = true;\n  while (flag) {\n    flag = false;\n    REP(k, 2) {\n      int f = 0;\n      P f_p;\n      REP(r, 8) REP(c, 8) {\n\tif (board[r][c] == -1) {\n\t  int cnt = count_lock(r, c, k);\n\t  if ((k == 0 && cnt > f) || (k == 1 && cnt > 0 && cnt >= f)) {\n\t    f = cnt;\n\t    f_p = make_pair(r, c);\n\t  }\n\t}\n      }\n      if (f > 0) {\n\tput_lock(f_p.first, f_p.second, k);\n\tflag = true;\n      }\n    }\n    \n  }\n  REP(r, 8) {\n    REP(c, 8) {\n      switch(board[r][c]) {\n      case -1:\n\tcout << '.';\n\tbreak;\t\n      default:\n\tcout << (board[r][c] == 0 ? 'o' : 'x');\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[8][9];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n\tfor(int i=0;i<8;i++)scanf(\"%s\",str[i]);\n\tbool ok=false;\n\tdo{\n\t\tok=false;\n\t\tint t=0;\n\t\tint row=0;\n\t\tint col=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(str[i][j]=='.'){\n\t\t\t\t\tint m=0;\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tint n=0;\n\t\t\t\t\t\tint R=i+dx[k];\n\t\t\t\t\t\tint C=j+dy[k];\n\t\t\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\t\t\tif(str[R][C]=='x')n++;\n\t\t\t\t\t\t\tif(str[R][C]=='o'){\n\t\t\t\t\t\t\t\tm+=n;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\t\t\tR+=dx[k];\n\t\t\t\t\t\t\tC+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m>t){\n\t\t\t\t\t\tt=m;\n\t\t\t\t\t\trow=i;\n\t\t\t\t\t\tcol=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t){\n\t\t\tstr[row][col]='o';\n\t\t\tok=true;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tbool B=false;\n\t\t\t\tint R=row+dx[k];\n\t\t\t\tint C=col+dy[k];\n\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\tif(str[R][C]=='o'){\n\t\t\t\t\t\tB=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t\tif(!B)continue;\n\t\t\t\tR=row+dx[k];\n\t\t\t\tC=col+dy[k];\n\t\t\t\twhile(str[R][C]=='x'){\n\t\t\t\t\tstr[R][C]='o';\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d %d %d o\\n\",row,col,t);\n//\tfor(int i=0;i<8;i++)printf(\"%s\\n\",str[i]);\n\t\t}\n\t\tt=0;\n\t\trow=0;\n\t\tcol=0;\n\t\tfor(int i=7;i>=0;i--){\n\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\tif(str[i][j]=='.'){\n\t\t\t\t\tint m=0;\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tint n=0;\n\t\t\t\t\t\tint R=i+dx[k];\n\t\t\t\t\t\tint C=j+dy[k];\n\t\t\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\t\t\tif(str[R][C]=='o')n++;\n\t\t\t\t\t\t\tif(str[R][C]=='x'){\n\t\t\t\t\t\t\t\tm+=n;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\t\t\tR+=dx[k];\n\t\t\t\t\t\t\tC+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m>t){\n\t\t\t\t\t\tt=m;\n\t\t\t\t\t\trow=i;\n\t\t\t\t\t\tcol=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t){\n\t\t\tstr[row][col]='x';\n\t\t\tok=true;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tbool B=false;\n\t\t\t\tint R=row+dx[k];\n\t\t\t\tint C=col+dy[k];\n\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\tif(str[R][C]=='x'){\n\t\t\t\t\t\tB=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t\tif(!B)continue;\n\t\t\t\tR=row+dx[k];\n\t\t\t\tC=col+dy[k];\n\t\t\t\twhile(str[R][C]=='o'){\n\t\t\t\t\tstr[R][C]='x';\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d %d %d x\\n\",row,col,t);\n//\tfor(int i=0;i<8;i++)printf(\"%s\\n\",str[i]);\n\t\t}\n\t}while(ok);\n\tfor(int i=0;i<8;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <functional>\n#include <algorithm>\nusing namespace std;\ntypedef tuple<int,int,int> tiii;\n\ntypedef struct{\n\tint x;\n\tint y;\n}dir;\nvector<dir>D={\n\t{-1,-1},{0,-1},{1,-1},\n\t{-1,0},{1,0},\n\t{-1,1},{0,1},{1,1},\n};\n\nconst int H=8,W=8;\nvector<function<bool(tiii&,tiii&)> >sorter={\n\t[](tiii &a,tiii &b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)>get<2>(b))return true;\n\t\tif(get<2>(a)<get<2>(b))return false;\n\t\tif(get<1>(a)>get<1>(b))return true;\n\t\tif(get<1>(a)<get<1>(b))return false;\n\t\treturn false;\n\t},\n\t[](tiii &a,tiii &b)->bool{\n\t\tif(get<0>(a)<get<0>(b))return true;\n\t\tif(get<0>(a)>get<0>(b))return false;\n\t\tif(get<2>(a)<get<2>(b))return true;\n\t\tif(get<2>(a)>get<2>(b))return false;\n\t\tif(get<1>(a)<get<1>(b))return true;\n\t\tif(get<1>(a)>get<1>(b))return false;\n\t\treturn false;\n\t}\n};\n\nint check2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=check2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\treturn r+1;\n}\nint check1(int color,int x,int y,vector<string>&m){\n\tint R=-1;\n\tfor(auto &d:D){\n\t\tint r=check2(color,d,x+d.x,y+d.y,m);\n\t\tif(r>0){\n\t\t\tif(R<0)R=0;\n\t\t\tR+=r;\n\t\t}\n\t}\n\treturn R;\n}\n\nint fill2(int color,dir&d,int x,int y,vector<string>&m){\n\tif(x<0||W<=x||y<0||H<=y||m[y][x]=='.')return -1;\n\tif(m[y][x]==color)return 0;\n\tint r=fill2(color,d,x+d.x,y+d.y,m);\n\tif(r<0)return r;\n\tm[y][x]=color;\n\treturn r+1;\n}\nvoid fill1(int color,int x,int y,vector<string>&m){\n\tfor(auto &d:D){\n\t\tfill2(color,d,x+d.x,y+d.y,m);\n\t}\n}\n\nint main(){\n\tstring color=\"ox\";\n\tvector<string>m(H);\n\tfor(int h=0;h<H;h++)cin>>m[h];\n\tint turn=0,pass=0;\n\tfor(;;){\n\t\tvector<tiii>v;\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)if(m[y][x]=='.'){\n\t\t\tint r=check1(color[turn],x,y,m);\n\t\t\tif(r>0)v.push_back(make_tuple(r,x,y));\n\t\t}\n\t\tif(v.empty()){\n\t\t\tpass++;\n\t\t\tif(pass>1)break;\n\t\t}else{\n\t\t\tpass=0;\n\t\t\tsort(v.begin(),v.end(),sorter[turn]);\n\t\t\ttiii &t=*v.rbegin();\n\t\t\tfill1(color[turn],get<1>(t),get<2>(t),m);\n\t\t\tm[get<2>(t)][get<1>(t)]=color[turn];\n\t\t}\n\t\tturn^=1;\n\t}\n\tfor(int h=0;h<H;h++)cout<<m[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dy[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dx[8] = {0, 1, 0, -1, 1, -1, -1, 1};\n\nint check(char s[][16], int y, int x, char c)\n{\n    if (s[y][x] != '.') return (-1);\n    \n    int num = 0;\n    \n    for (int r = 0; r < 8; r++){\n        bool success = true;\n        int i;\n        for (i = 1; ; i++){\n            int ny = y + i * dy[r], nx = x + i * dx[r];\n            if (!(0 <= ny && ny <= 7 && 0 <= nx && nx <= 7) ||\n                s[ny][nx] == '.'){\n                success = false;\n                break;\n            }\n            if (s[ny][nx] == c) break;\n        }\n        if (success) num += i - 1;\n    }\n    return (!num ? -1 : num);\n}\n\nvoid put(char s[][16], int y, int x, char c)\n{\n    s[y][x] = c;\n    for (int r = 0; r < 8; r++){\n        bool success = true;\n        int i;\n        for (i = 1; ; i++){\n            int ny = y + i * dy[r], nx = x + i * dx[r];\n            if (!(0 <= ny && ny <= 7 && 0 <= nx && nx <= 7) ||\n                s[ny][nx] == '.'){\n                success = false;\n                break;\n            }\n            if (s[ny][nx] == c) break;\n        }\n        if (success){\n            for (i = 1; ; i++){\n                int ny = y + i * dy[r], nx = x + i * dx[r];\n                if (s[ny][nx] == c) break;\n                s[ny][nx] = c;\n            }\n        }\n    }\n}\n\nint main()\n{\n    char s[16][16];\n    \n    for (int i = 0; i < 8; i++){\n        scanf(\"%s\", s + i);\n    }\n    \n    while (1){\n        bool upd = false;\n        \n        int maxnum = 0, posi = 0, posj = 0;\n        for (int i = 0; i < 8; i++){\n            for (int j = 0; j < 8; j++){\n                if (maxnum < check(s, i, j, 'o')){\n                    maxnum = check(s, i, j, 'o');\n                    posi = i; posj = j;\n                    upd = true;\n                }\n            }\n        }\n        if (maxnum) put(s, posi, posj, 'o');\n        \n        maxnum = posi = posj = 0;\n        \n        for (int i = 0; i < 8; i++){\n            for (int j = 0; j < 8; j++){\n                if (maxnum <= check(s, i, j, 'x')){\n                    maxnum = check(s, i, j, 'x');\n                    posi = i; posj = j;\n                    upd = true;\n                }\n            }\n        }\n        if (maxnum) put(s, posi, posj, 'x');\n        \n        if (!upd) break;\n    }\n    \n    for (int i = 0; i < 8; i++){\n        printf(\"%s\\n\", s[i]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tint qx = x, qy = y, q = 0;\n\t\t\twhile (qx != px || qy != py) {\n\t\t\t\tif(m) c[qy][qx] = t;\n\t\t\t\tqx += dx[i];\n\t\t\t\tqy += dy[i];\n\t\t\t\tif (q++ > 0) ret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1 && t % 2 == 1) { x = j; y = i; r = p; }\n\t\t\t\t\telse if (p > r && p >= 1) { x = j; y = i; r = p; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) { v = 1; t++; continue; }\n\t\t\tbreak;\n\t\t}\n\t\telse { place(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0; }\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint dx[] = { -1, 0, 1,-1, 1,-1, 0 ,1 };\nint dy[] = { -1,-1,-1, 0, 0, 1, 1, 1 };\nstring field[8];\n\nint count(int x, int y, char s) {\n\tint sum = 0;\n\trep(i, 8) {\n\t\tint rx = x, ry = y;\n\t\tint score = 0;\n\t\twhile (true) {\n\t\t\t//??¨?????¢??????????????????????????¢?????????????????????????????????\n\t\t\tif (0 > ry + dy[i] || ry + dy[i] >= 8 || 0 > rx + dx[i] || rx + dx[i] >= 8) {\n\t\t\t\tscore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//?????¨?¢?????????????????????????????????????\n\t\t\trx += dx[i];\n\t\t\try += dy[i];\n\t\t\t//?¬??????????????????????????????¢?¢????\n\t\t\tif(field[ry][rx] == s) score++;\n\t\t\t//??????????????????????????¢????????????\n\t\t\telse if(field[ry][rx]=='.'){\n\t\t\t\tscore = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//????????????????????¢????¢????\n\t\t\telse break;\n\t\t}\n\t\tsum += score;\n\t}\n\treturn sum;\n}\n\nvoid reverse(int x, int y, char s) {\n\trep(i, 8) {\n\t\t//cnt?????????????????°?????°????????????????????°\n\t\tint rx = x, ry = y, cnt = 0;\n\t\twhile (true) {\n\t\t\t//??¨?????¢????????§????????????????????????????????????????????????\n\t\t\tif (0 > ry + dy[i] || ry + dy[i] >= 8 || 0 > rx + dx[i] || rx + dx[i] >= 8) break;\n\t\t\t//?????¨?¢????????????????????????????????????????\n\t\t\trx += dx[i];\n\t\t\try += dy[i];\n\t\t\t//?¬???????????????????????????????????¢?????????????????¶????\n\t\t\tif (field[ry][rx] == s) {\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//????????????????????????????????????????????????????????????\n\t\t\telse if (field[ry][rx] == '.') break;\n\t\t\t//??????????????°??\\????????¨?????¢???????????????????????????\n\t\t\telse {\n\t\t\t\t//tx,ty??????????????´????????????????????????????¨??????????\n\t\t\t\tint tx = x, ty = y;\n\t\t\t\t//cnt(????????????????????°)????????°????????????\n\t\t\t\tfor (int j\t = 0; j < cnt; j++) {\n\t\t\t\t\t//????????¨?????£???????????£???????????????\n\t\t\t\t\tif (s == 'x') field[ty + dy[i]][tx + dx[i]] = 'o';\n\t\t\t\t\telse field[ty + dy[i]][tx + dx[i]] = 'x';\n\t\t\t\t\ttx += dx[i];\n\t\t\t\t\tty += dy[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//?????????????????????x,y?????§?¨????????????´??°\n\tif (s == 'x') field[y][x] = 'o';\n\telse field[y][x] = 'x';\n}\n\nint main() {\n\t//??¨?????¢?????±??\\???\n\trep(i, 8) getline(cin, field[i]);\n\t//true????????????????????????false????????£???????????????\n\tbool turn = true;\n\t//mx,my????????§???????????¢????????????x,y??§?¨????????´????????????°\n\tint score, mx, my;\n\t//flag1???????????????????????????????????°false\n\t//flag0????????£?????????????????????????????°false?????????????????´??°?????????\n\tbool flag0 = true, flag1 = true;\n\n\twhile (flag0 || flag1) {\n\t\tint MAX = 0;\n\t\trep(y, 8) {\n\t\t\trep(x, 8) {\n\t\t\t\tif (field[y][x] == '.') {\n\t\t\t\t\t//????????¨?????£?????§????????????\n\t\t\t\t\t//o:?????????x:?????£?????????\n\t\t\t\t\tif (turn) {\n\t\t\t\t\t\tscore = count(x, y, 'x');\n\t\t\t\t\t\tif (score > MAX) {\n\t\t\t\t\t\t\tMAX = max(MAX, score);\n\t\t\t\t\t\t\tmx = x;\n\t\t\t\t\t\t\tmy = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tscore = count(x, y, 'o');\n\t\t\t\t\t\tif (score >= MAX) {\n\t\t\t\t\t\t\tMAX = max(MAX, score);\n\t\t\t\t\t\t\tmx = x;\n\t\t\t\t\t\t\tmy = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//????????????????????????\n\t\t//?????¬????????????????????????????????£?????´?????????\n\t\tif (MAX == 0) {\n\t\t\t//????????????\n\t\t\tif (turn) {\n\t\t\t\tflag1 = false;\n\t\t\t\tturn = !turn;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag0 = false;\n\t\t\t\tturn = !turn;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tflag1 = true;\n\t\t\tflag0 = true;\n\t\t}\n\t\t//??¨?????¢??´??°\n\t\tif (turn) reverse(mx, my, 'x');\n\t\telse reverse(mx, my, 'o');\n\t\t//??????????????£\n\t\tturn = !turn;\n\t}\n\trep(i, 8) cout << field[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px) - 1, abs(y - py) - 1);\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px || qy != py) {\n\t\t\t\t\tc[qy][qx] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1 && t % 2 == 1) { x = j; y = i; r = p; }\n\t\t\t\t\telse if (p > r && p >= 1) { x = j; y = i; r = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) { v = 1; t++; continue; }\n\t\t\tbreak;\n\t\t}\n\t\telse { place(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0; }\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\nusing namespace std;\n\ntypedef unsigned long long BitBoard;\n\nint bitCount(BitBoard bits){\n\tbits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n\tbits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n\tbits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n\tbits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n\tbits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n\treturn ((int)bits & 0xffffffff) + (int)(bits >>32);\n}\nint put(BitBoard *oneself,BitBoard *opponent,BitBoard pos){\n\tBitBoard a;\n\tBitBoard rev=0;\n\tBitBoard w = *opponent & 0x7e7e7e7e7e7e7e7e; \n\tBitBoard t = w & (pos << 1);\n\tdo{\n\t\ta=t;\n\t\tt |= w & (t << 1);\n\t}while(a!=t);\n\tif(*oneself & t<<1)rev|=t;\n\tt = w & (pos >> 1);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t >> 1);\n\t}while(a!=t);\n\tif(*oneself & t>>1)rev|=t;\n\tw = *opponent & 0x00ffffffffffff00;\n\tt = w & (pos << 8);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t << 8);\n\t}while(a!=t);\n\tif(*oneself & t<<8)rev|=t;\n\tt = w & (pos >> 8);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t >> 8);\n\t}while(a!=t);\n\tif(*oneself & t>>8)rev|=t;\n\tw= *opponent & 0x007e7e7e7e7e7e00;\n\tt = w & (pos << 7);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t << 7);\n\t}while(a!=t);\n\tif(*oneself & t<<7)rev|=t;\n\tt = w & (pos >> 7);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t >> 7);\n\t}while(a!=t);\n\tif(*oneself & t>>7)rev|=t;\n\tt = w & (pos << 9);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t << 9);\n\t}while(a!=t);\n\tif(*oneself & t<<9)rev|=t;\n\tt = w & (pos >> 9);         \n\tdo{\n\t\ta=t;\n\t\tt |= w & (t >> 9);\n\t}while(a!=t);\n\tif(*oneself & t>>9)rev|=t;\n\t*oneself ^= rev | pos;\n\t*opponent ^= rev;\n\treturn bitCount(rev);\n}\nBitBoard putPosition(BitBoard oneself,BitBoard opponent){\n\tBitBoard mobility;\n\tBitBoard blank= ~(oneself|opponent);\n\tBitBoard w = opponent & 0x7e7e7e7e7e7e7e7e; \n\tBitBoard t = w & (oneself << 1 | oneself>>1);         \n\tt |= w & (t << 1 | t >> 1);\n\tt |= w & (t << 1 | t >> 1);\n\tt |= w & (t << 1 | t >> 1);\n\tt |= w & (t << 1 | t >> 1);\n\tt |= w & (t << 1 | t >> 1);\n\tmobility = blank & (t << 1 | t>>1);\n\n\tw= opponent & 0x00ffffffffffff00;\n\tt = w & (oneself << 8 | oneself>>8); \n \tt |= w & (t << 8 | t >> 8); \n\tt |= w & (t << 8 | t >> 8); \n\tt |= w & (t << 8 | t >> 8);\n\tt |= w & (t << 8 | t >> 8);\n\tt |= w & (t << 8 | t >> 8);\n\tmobility |= blank & (t << 8 | t>>8);\n\n\tw= opponent & 0x007e7e7e7e7e7e00;\n\tt = w & (oneself << 7 | oneself>>7); \n\tt |= w & (t << 7 | t >> 7); \n\tt |= w & (t << 7 | t >> 7); \n\tt |= w & (t << 7 | t >> 7);\n\tt |= w & (t << 7 | t >> 7);\n\tt |= w & (t << 7 | t >> 7);\n\tmobility |= blank & (t << 7 | t>>7);\n\n\tt = w & (oneself << 9 | oneself>>9); \n\tt |= w & (t << 9 | t >> 9); \n\tt |= w & (t << 9 | t >> 9); \n\tt |= w & (t << 9 | t >> 9);\n\tt |= w & (t << 9 | t >> 9);\n\tt |= w & (t << 9 | t >> 9);\n\tmobility |= blank & (t << 9 | t >> 9);\n\treturn mobility;\n}\n\ntemplate<class C>\nbool put(BitBoard *oneself,BitBoard *opponent,C cmp){\n\tBitBoard maxpos,pos=putPosition(*oneself,*opponent);\n\tif(!pos)return false;\n\tint maxn=0;\n\twhile(pos){\n\t\tBitBoard p=pos&-pos;\n\t\tpos &= ~p;\n\t\tBitBoard one=*oneself,opp=*opponent;\n\t\tint n=put(&one,&opp,p);\n\t\tif(cmp(maxn,n)){\n\t\t\tmaxn=n;\n\t\t\tmaxpos=p;\n\t\t}\n\t}\n\tput(oneself,opponent,maxpos);\n\treturn true;\n}\nint main(){\n\tBitBoard maru=0,batu=0;\n\tfor(int i=0;i<64;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='o')maru |= 1ull<<i;\n\t\telse if(c=='x')batu |= 1ull<<i;\n\t}\n\tbool passed=false;\n\tint turn=0;\n\twhile(1){\n\t\tbool f;\n\t\tturn^=1;\n\t\tif(turn)f=put(&maru,&batu,less<int>());\n\t\telse f=put(&batu,&maru,less_equal<int>());\n\t\tif(passed && !f)break;\n\t\tpassed = !f;\n\t}\n\tfor(int i=0;i<64;i++){\n\t\tif(maru>>i&1)cout<<'o';\n\t\telse if(batu>>i&1)cout<<'x';\n\t\telse cout<<'.';\n\t\tif((i+1)%8==0)cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n#include <assert.h>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\n\nconst ll dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst ll dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\npair<ll, ll> best_pos_mami(vector<string> &s){\n    pair<ll, ll> res = {-1, -1};\n    ll maxx = 0;\n    \n    REP(i, 8){\n        REP(j, 8){\n            if(s[i][j] != '.') continue;\n            ll sum = 0;\n            REP(k, 8){\n                ll y = i + dy[k], x = j + dx[k], cnt = 0;\n                while(y >= 0 && y < 8 && x >= 0 && x < 8 && s[y][x] != '.' && s[y][x] != 'o'){\n                    cnt++;\n                    y += dy[k];\n                    x += dx[k];\n                }\n                if(y >= 0 && y < 8 && x >= 0 && x < 8 && s[y][x] == 'o'){\n                    sum += cnt;\n                }\n            }\n            if(maxx < sum){\n                maxx = sum;\n                res = {i, j};\n            }\n        }\n    }\n    \n    return res;\n}\n\npair<ll, ll> best_pos_witch(vector<string> &s){\n    pair<ll, ll> res = {-1, -1};\n    ll maxx = 0;\n    \n    for(ll i = 7; i >= 0; i--){\n        for(ll j = 7; j >= 0; j--){\n            if(s[i][j] != '.') continue;\n            ll sum = 0;\n            REP(k, 8){\n                ll y = i + dy[k], x = j + dx[k], cnt = 0;\n                while(y >= 0 && y < 8 && x >= 0 && x < 8 && s[y][x] != '.' && s[y][x] != 'x'){\n                    cnt++;\n                    y += dy[k];\n                    x += dx[k];\n                }\n                if(y >= 0 && y < 8 && x >= 0 && x < 8 && s[y][x] == 'x'){\n                    sum += cnt;\n                }\n            }\n            if(maxx < sum){\n                maxx = sum;\n                res = {i, j};\n            }\n        }\n    }\n    \n    return res;\n}\n\nvoid return_cookie(vector<string> &s, pair<ll, ll> p, char c){\n    ll i = p.first, j = p.second;\n    s[i][j] = c;\n    \n    REP(k, 8){\n        ll y = i + dy[k], x = j + dx[k];\n        while(y >= 0 && y < 8 && x >= 0 && x < 8 && s[y][x] != '.' && s[y][x] != s[i][j]){\n            y += dy[k];\n            x += dx[k];\n        }\n        if(y >= 0 && y < 8 && x >= 0 && x < 8 && s[y][x] == s[i][j]){\n            ll yy = i + dy[k], xx = j + dx[k];\n            while(yy >= 0 && yy < 8 && xx >= 0 && xx < 8 && s[yy][xx] != '.' && s[yy][xx] != s[i][j]){\n                s[yy][xx] = s[i][j];\n                yy += dy[k];\n                xx += dx[k];\n            }\n        }\n    }\n}\n\n\nint main(){\n    vector<string> s(8);\n    REP(i, 8){\n        cin >> s[i];\n    }\n    \n    bool ok = true;\n    while(ok){\n        ok = false;\n        \n        auto res = best_pos_mami(s);\n        if(res.first != -1){\n            ok = true;\n            return_cookie(s, res, 'o');\n        }\n        \n        res = best_pos_witch(s);\n        if(res.first != -1){\n            ok = true;\n            return_cookie(s, res, 'x');\n        }\n    }\n    \n    REP(i, 8){\n        cout << s[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int dat[8][8];\n  for ( int i = 0; i < 8; i++ ) {\n    string s;\n    cin >> s;\n    for ( int j = 0; j < 8; j++ ) {\n      if ( s[j] == 'o' ) dat[i][j] = 0;\n      if ( s[j] == 'x' ) dat[i][j] = 1;\n      if ( s[j] == '.' ) dat[i][j] = 2;\n    }\n  }\n\n  int t = 0;\n  int con = 0;  \n  bool flag = true;\n  while ( con < 2 ) {\n    flag = false;\n    int ma = 0;\n    int y, x;    \n    for ( int i = 0; i < 8; i++ ) {\n      for ( int j = 0; j < 8; j++ ) {\n\tif ( dat[i][j] != 2 ) continue;\n\tint sum = 0;\n\tfor ( int d = 0; d < 8; d++ ) {\n\t  int ny = i+dy[d], nx = j+dx[d];\n\t  if ( ny < 0 || nx < 0 || ny >= 8 || nx >= 8 ) continue;\n\t  if ( dat[ny][nx] != !t ) continue;\n\t  int cnt = 1;\n\t  while ( 1 ) {\t    \n\t    ny += dy[d]; nx += dx[d];\n\t    if ( ny < 0 || nx < 0 || ny >= 8 || nx >= 8 ) break;\n\t    if ( dat[ny][nx] == t ) {\n\t      sum += cnt;\n\t      break;\n\t    } else if ( dat[ny][nx] == 2 ) {\n\t      break;\n\t    }\n\t    cnt++;\t    \n\t  }\n\t}\n\tif ( sum ) flag = true;\n\tif ( !t && sum > ma ) {\n\t  ma = sum;\n\t  y = i;\n\t  x = j;\t  \n\t}\n\tif ( t && sum >= ma ) {\n\t  ma = sum;\n\t  y = i;\n\t  x = j;\t  \n\t}\n      }\n    }\n\n    if ( !flag ) {\n      con++;\n      t = !t;\n      continue;      \n    }\n    con = 0;    \n    dat[y][x] = t;    \n    for ( int d = 0; d < 8; d++ ) {\n      int ny = y+dy[d], nx = x+dx[d];\n      if ( ny < 0 || nx < 0 || ny >= 8 || nx >= 8 ) continue;\n      if ( dat[ny][nx] != !t ) continue;\n      bool flag2 = false;\n      while ( 1 ) {\t    \n\tny += dy[d]; nx += dx[d];\n\tif ( ny < 0 || nx < 0 || ny >= 8 || nx >= 8 ) break;\n\tif ( dat[ny][nx] == t ) {\n\t  flag2 = true;\n\t  break;\n\t} else if ( dat[ny][nx] == 2 ) {\n\t  break;\n\t}\t    \n      }\n      if ( !flag2 ) continue;\n      ny = y+dy[d]; nx = x+dx[d];      \n      if ( ny < 0 || nx < 0 || ny >= 8 || nx >= 8 ) continue;\n      dat[ny][nx] = t;      \n      while ( 1 ) {\t    \n\tny += dy[d]; nx += dx[d];\n\tif ( ny < 0 || nx < 0 || ny >= 8 || nx >= 8 ) break;\n\tif ( dat[ny][nx] == t ) {\n\t  break;\n\t} else if ( dat[ny][nx] == 2 ) {\n\t  break;\n\t}\n\tdat[ny][nx] = t;\t\n      }\n    }\n    t = !t;\n  }\n\n  for ( int i = 0; i < 8; i++ ) {\n    for ( int j = 0; j < 8; j++ ) {\n      if ( dat[i][j] == 0 ) cout << 'o';\n      if ( dat[i][j] == 1 ) cout << 'x';\n      if ( dat[i][j] == 2 ) cout << '.';\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std; \nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nvector< vector <char> > board(8,vector<char>(8));\nint check(int x,int y,char c)\n{\n  int res=0;\n  if(board[y][x] !='.'){return 0;}\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      int count=0;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[ny][nx]==c){res+=count;break;}\n\t  if(board[ny][nx]=='.'){break;}\n\t  count++;\n\t}\n    }\n  return res;\n}\nvoid put(int x,int y,char c)\n{\n  board[y][x]=c;\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[ny][nx]==c){\n\t    while(1)\n\t      {\n\t\tnx -=dx[k];\n\t\tny -=dy[k];\n\t\tif(nx == x && ny == y){break;}\n\t\tboard[ny][nx]= c;\n\t      }\n\t    break;\n\t  }\n\t  if(board[ny][nx]=='.'){break;}\n\t}\n    }\n}\n\nbool win()\n{\n  int o_count=0;\n  int x_count=0;\n  for(int x=0;x<8;x++)\n    {\n      for(int y=0;y<8;y++)\n\t{\n\t  if(board[x][y]=='o'){o_count++;}\n\t  if(board[x][y]=='x'){x_count++;}\n\t}\n    }\n  return o_count==0 || x_count==0 || o_count+x_count==64;\n}\n    \nint main()\n{\n  for(int i=0;i<8;i++)\n    {\n      for(int j=0;j<8;j++)\n\t{\n\t  cin >> board[i][j];\n\t}\n    }\n  int turn=1;\n  int max_x,max_y;\n  int pass=0;\n  while(1)\n    {\n      char player=(turn % 2) ? 'o' : 'x';\n      int num=0;max_x=-1,max_y=-1;\n      if(player == 'o')\n\t{\n\t  for(int y=0;y<8;y++)\n\t    {\n\t      for(int x=0;x<8;x++)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for(int y=7;y>=0;y--)\n\t    {\n\t      for(int x=7;x>=0;x--)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(max_x != -1)\n\t{\n\t  pass=0;\n\t  put(max_x,max_y,player);\n\t}\n      else\n\t{\n\t  pass++;\n\t}\n      turn++;\n      if(pass>1){break;}\n      if(win()){break;}\n    }\n    \n  for(int y=0;y<8;y++)\n    {\n      for(int x=0;x<8;x++)\n\t{\n\t  cout << board[y][x];\n\t}\n      cout << endl;\n    }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint n = 8;\nvvi f;\n\nint count(int y, int x, int dy, int dx, int p) {\n\tint ny = y+dy;\n\tint nx = x+dx;\n\tint res = 0;\n\twhile( f[ny][nx] == 3-p ) {\n\t\tres++;\n\t\tny += dy;\n\t\tnx += dx;\n\t}\n\tif( f[ny][nx] == p ) {\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nvoid fill(int y, int x, int dy, int dx, int p) {\n\tint ny = y + dy;\n\tint nx = x + dx;\n\twhile(f[ny][nx]==3-p) {\n\t\tny += dy;\n\t\tnx += dx;\n\t}\n\tif( f[ny][nx] == p ) {\n\t\tny = y + dy;\n\t\tnx = x + dx;\n\t\twhile(f[ny][nx] == 3-p) {\n\t\t\tf[ny][nx] = p;\n\t\t\tny += dy;\n\t\t\tnx += dx;\n\t\t}\n\t}\n}\n\nbool passed = false;\n\nvoid solve(bool turn) {\n\tconst int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tconst int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n\tif(turn) {\n\t\tint maxi = 0, my=0, mx=0;\n\t\tfor(int y=1; y<=n; y++) {\n\t\t\tfor(int x=1; x<=n; x++) {\n\t\t\t\tif(f[y][x] != 0) continue;\n\t\t\t\tint c = 0;\n\t\t\t\trep(i, 8) {\n\t\t\t\t\tc += count(y, x, dy[i], dx[i], 1);\n\t\t\t\t}\n\t\t\t\tif(maxi < c) {\n\t\t\t\t\tmaxi = c;\n\t\t\t\t\tmy = y;\n\t\t\t\t\tmx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(maxi > 0) {\n\t\t\tpassed = false;\n\t\t\tf[my][mx] = 1;\n\t\t\trep(i, 8) {\n\t\t\t\tfill(my, mx, dy[i], dx[i], 1);\n\t\t\t}\n\t\t\tsolve(!turn);\n\t\t} else {\n\t\t\tif(passed) return;\n\t\t\tpassed = true;\n\t\t\tsolve(!turn);\n\t\t}\n\t} else {\n\t\tint maxi = 0, my=0, mx=0;\n\t\tfor(int y=n; y>=1; y--) {\n\t\t\tfor(int x=n; x>=1; x--) {\n\t\t\t\tif(f[y][x] != 0) continue;\n\t\t\t\tint c = 0;\n\t\t\t\trep(i, 8) {\n\t\t\t\t\tc += count(y, x, dy[i], dx[i], 2);\n\t\t\t\t}\n\t\t\t\tif(maxi < c) {\n\t\t\t\t\tmaxi = c;\n\t\t\t\t\tmy = y;\n\t\t\t\t\tmx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(maxi > 0) {\n\t\t\tpassed = false;\n\t\t\tf[my][mx] = 2;\n\t\t\trep(i, 8) {\n\t\t\t\tfill(my, mx, dy[i], dx[i], 2);\n\t\t\t}\n\t\t\tsolve(!turn);\n\t\t} else {\n\t\t\tif(passed) return;\n\t\t\tpassed = true;\n\t\t\tsolve(!turn);\n\t\t}\n\t}\n}\n\nint main() {\n\tf.resize(n+2);\n\trep(y, n+2) {\n\t\tf[y].resize(n+2);\n\t}\n\trep(x,n+2) {\n\t\tf[0][x] = 3;\n\t\tf[n+1][x] = 3;\n\t}\n\tfor(int y=1; y<=n; y++) {\n\t\tstring in;\n\t\tcin >> in;\n\t\tf[y][0] = 3;\n\t\tf[y][n+1] = 3;\n\t\tfor(int x=1; x<=n; x++) {\n\t\t\tif( in[x-1] == 'o' ) {\n\t\t\t\tf[y][x] = 1;\n\t\t\t} else if( in[x-1] == 'x' ) {\n\t\t\t\tf[y][x] = 2;\n\t\t\t} else {\n\t\t\t\tf[y][x] = 0;\n\t\t\t}\n\t\t\t//cout << f[y][x];\n\t\t}\n\t\t//cout << endl;\n\t}\n\tsolve(true);\n\tstring ch = \".ox\";\n\tfor(int y=1; y<=n; y++) {\n\t\tfor(int x=1; x<=n; x++) {\n\t\t\tcout << ch[ f[y][x] ];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nvector< vector<char> > field(8,vector<char>(8));\nint dx[8] = {1,1,0,-1,-1,-1,0,1};\nint dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint check(int x, int y, char c)\n{\n\tint res=0;\n\tif(field[y][x] != '.'){ return 0; }\n\trep(i,8)\n\t{\n\t\tint nx = x;\n\t\tint ny = y;\n\t\tint cnt=0;\n\t\twhile(true)\n\t\t{\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8){ break; }\n\t\t\tif(field[ny][nx] == c){ res += cnt; break; }\n\t\t\tif(field[ny][nx] == '.'){ break; }\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid put(int x, int y, char c)\n{\n\tfield[y][x] = c;\n\trep(i,8)\n\t{\n\t\tint nx = x;\n\t\tint ny = y;\n\t\twhile(true)\n\t\t{\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t\tif(nx < 0 || nx >= 8 || ny < 0 || ny >= 8){ break; }\n\t\t\tif(field[ny][nx] == c){\n\t\t\t\twhile(true)\n\t\t\t\t{\n\t\t\t\t\tnx -= dx[i];\n\t\t\t\t\tny -= dy[i];\n\t\t\t\t\tif(nx == x && ny == y){ break; }\n\t\t\t\t\tfield[ny][nx] = c;\n\t\t\t\t}\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tif(field[ny][nx] == '.'){ break; }\n\t\t}\n\t}\n}\n\nbool win()\n{\n\tint o_cnt=0;\n\tint x_cnt=0;\n\trep(y,8){\n\t\trep(x,8){\n\t\t\tif(field[y][x] == 'o'){ o_cnt++; }\n\t\t\tif(field[y][x] == 'x'){ x_cnt++; }\n\t\t}\n\t}\n\treturn o_cnt==0 || x_cnt==0 || o_cnt+x_cnt==64;\n}\n\nint main()\n{\n\trep(y,8){\n\t\trep(x,8){\n\t\t\tcin >> field[y][x];\n\t\t}\n\t}\n\n\tint turn=1;\n\tint max_x, max_y;\n\twhile(true)\n\t{\n\t\tchar player = (turn % 2) ? 'o' : 'x';\n\t\tint num=0, max_x=-1, max_y=-1;\n\t\tif(player == 'o')\n\t\t{\n\t\t\trep(y,8){\n\t\t\t\trep(x,8){\n\t\t\t\t\tint tmp = check(x,y,player);\n\t\t\t\t\tif(num < tmp){\n\t\t\t\t\t\tnum = tmp;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int y=7;y>=0;y--){\n\t\t\t\tfor(int x=7;x>=0;x--){\n\t\t\t\t\tint tmp = check(x,y,player);\n\t\t\t\t\tif(num < tmp){\n\t\t\t\t\t\tnum = tmp;\n\t\t\t\t\t\tmax_x = x;\n\t\t\t\t\t\tmax_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_x != -1){ put(max_x, max_y, player); }\n\t\tturn++;\n\t\tif(win()){ break; }\n\t}\n\n\t\n\trep(y,8){\n\t\trep(x,8){\n\t\t\tcout << field[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst char cs[] = \"xo\";\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n    state(){}\n};\n\nstate flip(const int x, const int y, state s, bool turn){\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        while (valid(cx, cy) && s.g[cy][cx] == cs[1 - turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cy, cx) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i]; \n                !(ix == cx && iy == cy); \n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[1 - turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n    }\n    return s;\n}\n\nint main()\n{\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    int bad = 0;\n    for (size_t turn = 1; turn <= 64; turn++){\n        bool ok = false;\n        state next = cur;\n        for (size_t y = 0; y < 8; y++){\n            for (size_t x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 0 && next.score[1] >= cand.score[1]) ||\n                        ((turn & 1) == 1 && next.score[0] > cand.score[0])){\n                        ok = true;\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        if (!ok) bad++;\n        else bad = 0;\n        if (bad == 2){\n            break;\n        }\n        cur = next;\n    }\n\n    for (size_t i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<tuple>\n#include<functional>\n\nusing namespace std;\n\ntypedef tuple<int, int, int, vector<int>> TP;;\n\nchar field[8][8];\nint H = 8, W = 8;\n\nint vy[8] = { -1,-1,0,1,1,1,0,-1 }, vx[8] = { 0,-1,-1,-1,0,1,1,1 };\n\nbool isupdate = false;\n\n//candidate of their choice.\n\nauto Mami_ai = [](TP& a, TP& b) {\n\tif (get<0>(a) < get<0>(b))return false;\n\telse if (get<0>(a) > get<0>(b))return true;\n\telse {\n\t\tif (get<1>(a) < get<1>(b))return true;\n\t\telse if (get<1>(a) > get<1>(b))return false;\n\t\telse {\n\t\t\tif (get<2>(a) < get<2>(b))return true;\n\t\t\telse return false;\n\t\t}\n\t}\n};\n\nauto Witch_ai = [](TP& a, TP& b) {\n\tif (get<0>(a) < get<0>(b))return false;\n\telse if (get<0>(a) > get<0>(b))return true;\n\telse {\n\t\tif (get<1>(a) < get<1>(b))return false;\n\t\telse if (get<1>(a) > get<1>(b))return true;\n\t\telse {\n\t\t\tif (get<2>(a) < get<2>(b))return false;\n\t\t\telse return true;\n\t\t}\n\t}\n};\n\nvoid execute(bool type) {\n\t//type == false -> Mami  true -> Witch\n\t//line W\n\t\n\tvector<TP> candidate;\n\n\tchar mytoken, opptoken;\n\tif (!type)mytoken = 'o', opptoken = 'x';\n\telse mytoken = 'x', opptoken = 'o';\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (field[i][j] != '.')continue;\n\t\t\tint cnt = 0;\n\t\t\tvector<int> place;\n\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\tplace.push_back(0);\n\t\t\t\tint nx = i + vx[k], ny = j + vy[k];\n\t\t\t\tbool flg = false;\n\t\t\t\tbool flg2 = true;\n\t\t\t\tint C = 0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tC++;\n\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= H || ny >= W) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!flg && field[nx][ny] == opptoken) {\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!flg && field[nx][ny] != opptoken){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flg && field[nx][ny] == mytoken) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tcnt += (C - 1);\n\t\t\t\t\t\tplace[k] = C - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flg && field[nx][ny] == '.') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnx += vx[k], ny += vy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt != 0)candidate.push_back(make_tuple(cnt, i, j, place));\n\t\t}\n\n\t}\n\n\tif (candidate.size() != 0)isupdate = true;\n\telse return;\n\n\tif (!type) {\n\t\t//Mamiの思考ルーチン通りにソートしておく\n\t\tsort(candidate.begin(), candidate.end(), Mami_ai);\n\t}\n\telse {\n\t\tsort(candidate.begin(), candidate.end(), Witch_ai);\n\t}\n\n\tint i = get<1>(candidate[0]), j = get<2>(candidate[0]);\n\n\tfield[i][j] = mytoken;\n\n\tfor (int k = 0; k < 8; k++) {\n\t\tif (get<3>(candidate[0])[k] == 0)continue;\n\t\tint nx = i + vx[k], ny = j + vy[k];\n\t\tint ct = 0;\n\t\twhile (1) {\n\t\t\tif (ct == get<3>(candidate[0])[k])break;\n\t\t\tfield[nx][ny] = mytoken;\n\t\t\t\n\t\t\tnx += vx[k], ny += vy[k];\n\t\t\tct++;\n\t\t}\n\t}\n\n}\n\nint main() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tisupdate = false;\n\t\t//Tomoe Mami's turn\n\t\texecute(0);\n\n\t\t//Witch's turn\n\t\texecute(1);\n\n\t\tif (!isupdate) {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tcout << field[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define FOR(i,n1,n2) for(ll i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(ll i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\ntypedef tuple<ll,ll,ll> Tu;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst double PI=3.14151926535;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nconst ll tMOD=(ll)998244353;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint mdx[8]={0,1,0,-1,1,1,-1,-1},mdy[8]={-1,0,1,0,1,-1,1,-1};\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nchar s[8][8];\nchar reverse_coo(char c){\n    if(c=='o')return 'x';\n    if(c=='x')return 'o';\n}\nint count_check(char c,int ly,int lx){\n    if(s[ly][lx]!='.')return 0;\n    int co=0;\n    REP(i,8){\n        if(!(ly+mdy[i]>=0&&8>ly+mdy[i]&&lx+mdx[i]>=0&&8>lx+mdx[i])){\n            continue;\n        }else if(s[ly+mdy[i]][lx+mdx[i]]!=reverse_coo(c)){\n            continue;\n        }\n        int ty=ly+mdy[i],tx=lx+mdx[i];\n        int ddx=0;\n        while(ty>=0&&8>ty&&tx>=0&&8>tx&&s[ty][tx]==reverse_coo(c)){\n            ty+=mdy[i],tx+=mdx[i];\n            ddx++;\n        }\n        if(!(ty>=0&&8>ty&&tx>=0&&8>tx)){}\n        else if(s[ty][tx]==c)co+=ddx;\n        \n    }\n    return co;\n}\nvoid change_check(char c,int ly,int lx){\n    int co=0;\n    REP(i,8){\n        if(!(ly+mdy[i]>=0&&8>ly+mdy[i]&&lx+mdx[i]>=0&&8>lx+mdx[i])){\n            continue;\n        }else if(s[ly+mdy[i]][lx+mdx[i]]!=reverse_coo(c)){\n            continue;\n        }\n        int ty=ly+mdy[i],tx=lx+mdx[i];\n        int ddx=0;\n        while(ty>=0&&8>ty&&tx>=0&&8>tx&&s[ty][tx]==reverse_coo(c)){\n            ty+=mdy[i],tx+=mdx[i];\n            ddx++;\n        }\n        if(!(ty>=0&&8>ty&&tx>=0&&8>tx)){}\n        else if(s[ty][tx]==c){\n            ty=ly+mdy[i],tx=lx+mdx[i];\n            while(ty>=0&&8>ty&&tx>=0&&8>tx&&s[ty][tx]==reverse_coo(c)){\n                s[ty][tx]=c;\n                ty+=mdy[i],tx+=mdx[i];\n        }\n        }\n        \n    }\n    s[ly][lx]=c;\n}\nint main(){\n    REP(i,8)REP(j,8)cin>>s[i][j];\n    char turn='o';\n    int check_finish=1;\n    while(check_finish){\n        check_finish=0;\n        int lly=-1,llx=-1;\n        int cou=0;\n        turn='o';\n        REP(i,8){\n            REP(j,8){\n                if(cou<count_check(turn,i,j)){\n                    lly=i,llx=j,cou=count_check(turn,i,j);\n                }\n            }\n        }\n        if(cou!=0){\n            change_check(turn,lly,llx);\n            check_finish=1;\n        }\n        lly=-1,llx=-1;\n        cou=0;\n        turn='x';\n        for(int i=7;i>=0;i--){\n            for(int j=7;j>=0;j--){\n                if(cou<count_check(turn,i,j)){\n                    lly=i,llx=j,cou=count_check(turn,i,j);\n                }\n            }\n        }\n        if(cou!=0){\n            change_check(turn,lly,llx);\n            check_finish=1;\n        }\n    }\n\n    \n    REP(i,8){\n        REP(j,8){\n            cout<<s[i][j];\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int dx[] = { 0, 0,+1,+1,+1,-1,-1,-1};\nconst int dy[] = {+1,-1,+1, 0,-1,+1, 0,-1};\n\nint main()\n{\n\tint f[10][10]={0};\n\tfor(int y=1; y<=8; y++)\n\tfor(int x=1; x<=8; x++)\n\t{\n\t\tchar c; cin>>c;\n\t\tif(c=='o') f[y][x]= 1;\n\t\tif(c=='x') f[y][x]=-1;\n\t}\n\n\tint turn=1,pass=0;\n\twhile(pass<2)\n\t{\n\t\tint mx,my,mdcnt,mcnt=0;\n\t\tfor(int y=1; y<=8; y++)\n\t\tfor(int x=1; x<=8; x++)\n\t\t{\n\t\t\tif(f[y][x]!=0) continue;\n\n\t\t\tint dcnt=0,cnt=0;\n\t\t\tfor(int d=0; d<8; d++)\n\t\t\t{\n\t\t\t\tint c=1;\n\t\t\t\twhile(turn*f[y+c*dy[d]][x+c*dx[d]]==-1) c++;\n\t\t\t\tif(f[y+c*dy[d]][x+c*dx[d]]!=0)\n\t\t\t\t{\n\t\t\t\t\tcnt+=(c-1); dcnt|=(c-1)<<(d*3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn== 1 && mcnt< cnt) { mx=x; my=y; mdcnt=dcnt; mcnt=cnt; }\n\t\t\tif(turn==-1 && mcnt<=cnt) { mx=x; my=y; mdcnt=dcnt; mcnt=cnt; }\n\t\t}\n\n\t\tif(mcnt==0)\n\t\t{\n\t\t\tpass++; turn*=-1; continue;\n\t\t}\n\n\t\tfor(int d=0; d<8; d++)\n\t\tfor(int c=0; c<=((mdcnt>>(d*3))&7); c++)\n\t\t{\n\t\t\tf[my+c*dy[d]][mx+c*dx[d]] = turn;\n\t\t}\n\n\t\tpass=0; turn*=-1;\n\t}\n\n\tconst char s[3]={'x','.','o'};\n\tfor(int y=1; y<=8; y++)\n\t{\n\t\tfor(int x=1; x<=8; x++)\n\t\t{\n\t\t\tcout << s[f[y][x]+1];\n\t\t}\n\t\tcout << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> v;\nstring s[8];\nstring cp[8];\nint res[8][8];\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nvoid bancp()\n{\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tcp[i]=s[i];\n\t}\n\treturn;\n}\n\nint check2(int x,int y)\n{\n\tint ret=0;\n\tchar jiban=s[x][y];\n\tchar taban;\n\tif(jiban=='x')\n\t\ttaban='o';\n\telse\n\t\ttaban='x';\n\t//上下左右斜め順番に調べる\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tint nx=x;\n\t\tint ny=y;\n\t\tint cnt=0;\n\t\twhile(1)\n\t\t{\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t\tif(nx>=0 && nx<8 && ny>=0 && ny<8)\n\t\t\t{\n\t\t\t\tif(s[nx][ny]!=taban)\n\t\t\t\t\tbreak;\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nx>=0 && nx<8 && ny>=0 && ny<8)\n\t\t{\n\t\t\tif(s[nx][ny]==jiban)\n\t\t\t{\n\t\t\t\tnx=x;ny=y;\n\t\t\t\tfor(int j=0;j<cnt+2;j++)\n\t\t\t\t{\n\t\t\t\t\ts[nx][ny]=jiban;\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t}\n\t\t\t\tret+=cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint check(int x,int y)\n{\n\tint ret=0;\n\tchar jiban=cp[x][y];\n\tchar taban;\n\tif(jiban=='x')\n\t\ttaban='o';\n\telse\n\t\ttaban='x';\n\t//上下左右斜め順番に調べる\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tint nx=x;\n\t\tint ny=y;\n\t\tint cnt=0;\n\t\twhile(1)\n\t\t{\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t\tif(nx>=0 && nx<8 && ny>=0 && ny<8)\n\t\t\t{\n\t\t\t\tif(cp[nx][ny]!=taban)\n\t\t\t\t\tbreak;\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nx>=0 && nx<8 && ny>=0 && ny<8)\n\t\t{\n\t\t\tif(cp[nx][ny]==jiban)\n\t\t\t{\n\t\t\t\tnx=x;ny=y;\n\t\t\t\tfor(int j=0;j<cnt+2;j++)\n\t\t\t\t{\n\t\t\t\t\tcp[nx][ny]=jiban;\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t}\n\t\t\t\tret+=cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nP senteAI()\n{\n\tv.clear();\n\tfill(res[0],res[8],-1);\n\t//すべての場所に置く\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tfor(int j=0;j<8;j++)\n\t\t{\n\t\t\tif(s[i][j]!='.')\n\t\t\t\tcontinue;\n\t\t\tbancp();\n\t\t\tcp[i][j]='o';\n\t\t\t//置いた場所から消せるマスを調べて消す\n\t\t\tint cnt=check(i,j);\n\t\t\t//cerr<<cnt<<endl;\n\t\t\tif(cnt>0)\n\t\t\t{\n\t\t\t\tv.push_back(cnt);\n\t\t\t\tres[i][j]=cnt;\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<v.size()<<endl;\n\tif(v.size()==0)\n\t\treturn P(-1,-1);\n\tsort(v.begin(),v.end());\n\treverse(v.begin(),v.end());\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tfor(int j=0;j<8;j++)\n\t\t{\n\t\t\tif(res[i][j]==v[0])\n\t\t\t\treturn P(i,j);\n\t\t}\n\t}\n\treturn P(-10,-10);\n}\n\nP goteAI()\n{\n\tv.clear();\n\tfill(res[0],res[8],-1);\n\t//すべての場所に置く\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tfor(int j=0;j<8;j++)\n\t\t{\n\t\t\tif(s[i][j]!='.')\n\t\t\t\tcontinue;\n\t\t\tbancp();\n\t\t\tcp[i][j]='x';\n\t\t\t//置いた場所から消せるマスを調べて消す\n\t\t\tint cnt=check(i,j);\n\t\t\tif(cnt>0)\n\t\t\t{\n\t\t\t\tv.push_back(cnt);\n\t\t\t\tres[i][j]=cnt;\n\t\t\t}\n\t\t}\n\t}\n\tif(v.size()==0)\n\t\treturn P(-1,-1);\n\tsort(v.begin(),v.end());\n\treverse(v.begin(),v.end());\n\tfor(int i=7;i>=0;i--)\n\t{\n\t\tfor(int j=7;j>=0;j--)\n\t\t{\n\t\t\tif(res[i][j]==v[0])\n\t\t\t\treturn P(i,j);\n\t\t}\n\t}\n\treturn P(-10,-10);\n}\n\nint main()\n{\n\tfor(int i=0;i<8;i++)\n\t\tcin>>s[i];\n\tP p;\n\tbool f[2]={true,true};\n\twhile(1)\n\t{\n\t\t//cerr<<\"sente\"<<endl;\n\t\t//先手番\n\t\tf[0]=false;\n\t\tp=senteAI();\n\t\t//cerr<<p.first<<\" \"<<p.second<<endl;\n\t\tif(p>P(-1,-1))\n\t\t{\n\t\t\tf[0]=true;\n\t\t\ts[p.first][p.second]='o';\n\t\t\tcheck2(p.first,p.second);\n\t\t}\n\t\tif(!(f[0] || f[1]))\n\t\t\tbreak;\n\t\tf[1]=false;\n\t\t//cerr<<\"gote\"<<endl;\n\t\tp=goteAI();\n\t\tif(p>P(-1,-1))\n\t\t{\n\t\t\tf[1]=true;\n\t\t\ts[p.first][p.second]='x';\n\t\t\tcheck2(p.first,p.second);\n\t\t}\n\t\tif(!(f[0] || f[1]))\n\t\t\tbreak;\n\t}\n\tfor(int i=0;i<8;i++)\n\t\tcout<<s[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n  \nusing namespace std;\n\nchar s[8][8];\nint dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint reversenum(int x, int y, char c)\n{\n    int ans = 0, cookienum;\n    char rc;\n    if(c == 'o') rc = 'x';\n    else rc = 'o';\n    for(int i = 0; i < 8; i++){\n        cookienum = 0;\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        while(nx >= 0 && ny >= 0 && nx < 8 && ny < 8 && s[nx][ny] == rc){\n            nx += dx[i];\n            ny += dy[i];\n            cookienum++;\n        }\n        if(nx >= 0 && ny >= 0 && nx < 8 && ny < 8 && s[nx][ny] == c) ans += cookienum;\n    }\n    return ans;\n}\n\nvoid reverse(int x, int y, char c)\n{\n    char rc;\n    if(c == 'o') rc = 'x';\n    else rc = 'o';\n    s[x][y] = c;\n    for(int i = 0; i < 8; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        int cookienum = 0;\n        while(nx >= 0 && ny >= 0 && nx < 8 && ny < 8 && s[nx][ny] == rc){\n            nx += dx[i];\n            ny += dy[i];\n            cookienum++;\n        }\n        if(nx >= 0 && ny >= 0 && nx < 8 && ny < 8 && s[nx][ny] == c){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            for(int j = 0; j < cookienum; j++){\n                s[nx][ny] = c;\n                nx += dx[i];\n                ny += dy[i];\n            }\n        }\n    }\n    return;\n}\n\nbool mami()\n{\n    int maxcookie = 0;\n    int maxx, maxy;\n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            if(s[i][j] != '.') continue;\n            int revnum = reversenum(i, j, 'o');\n            // cout << \"mami \" << revnum << endl;\n            if(maxcookie < revnum){\n                maxcookie = revnum;\n                maxx = i;\n                maxy = j;\n            }\n        }\n    }\n    if(maxcookie == 0) return false;\n    reverse(maxx, maxy, 'o');\n    return true;\n}\n\nbool charlotte()\n{\n    int maxcookie = 0;\n    int maxx, maxy;\n    for(int i = 7; i >= 0; i--){\n        for(int j = 7; j >= 0; j--){\n            if(s[i][j] != '.') continue;\n            int revnum = reversenum(i, j, 'x');\n            if(maxcookie < revnum){\n                maxcookie = revnum;\n                maxx = i;\n                maxy = j;\n            }\n        }\n    }\n    if(maxcookie == 0) return false;\n    reverse(maxx, maxy, 'x');\n    return true; \n}\n\nint main()\n{\n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            cin >> s[i][j];\n        }\n    }\n    int flag = 0;\n    while(flag != 2){\n        flag = 0;\n        if(!mami()) flag++;\n        if(!charlotte()) flag++;\n    }\n    for(int i = 0; i < 8; i++){\n        for(int j = 0; j < 8; j++){\n            cout << s[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Dessert Witch\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// #define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\n\nstruct P {\n  int x, y;\n  vpi l;\n  int score;\n};\n\nchar field[8][8];\n\nint dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nint dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate <typename T> bool select(T t, char c1, char c2){\n  vector<P> v;\n\n  REP(y, 8) REP(x, 8){\n    if(field[y][x] != '.') continue;\n\n    vpi l;\n    REP(i, 8){\n      int sx = x + dx[i];\n      int sy = y + dy[i];\n      if(0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == c2) {\n        vpi ll;\n        while(0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == c2) {\n          ll.push_back({sx, sy});\n          sx += dx[i];\n          sy += dy[i];\n        }\n        if(0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == c1) {\n          for(pii p : ll) {\n            l.push_back(p);\n          }\n        }\n      }\n    }\n\n    if (!l.empty()) {\n      LOG(\"(%d %d) %d\\n\", x, y, (int)l.size());\n      l.push_back({x, y});\n      v.push_back({x, y, l, (int)l.size()});\n    }\n  }\n\n  LOG(\"size() %d\\n\", (int)v.size());\n  if (v.empty()) return true;\n  sort(RALL(v), t);\n  LOG(\"(%d %d)\\n\", v[0].x, v[0].y);\n  for(pii p : v[0].l) {\n    LOG(\"\\t(%d %d) %c\\n\", p.first, p.second, c1);\n    field[p.second][p.first] = c1;\n  }\n  return false;\n}\n\nvoid printWorld(){\n  REP(y, 8) {\n    REP(x, 8){\n      cout << field[y][x];\n    }\n    cout << endl;\n  }\n}\n\nint main() {\n  auto A = [](P a, P b){\n             return a.score * 1000 - a.y * 10 - a.x < b.score * 1000 - b.y * 10 - b.x;\n           };\n  auto B = [](P a, P b){\n             return a.score * 1000 + a.y * 10 + a.x < b.score * 1000 + b.y * 10 + b.x;\n           };\n\n  REP(y, 8) REP(x, 8){\n    cin >> field[y][x];\n  }\n\n  while(1) {\n    int flag = 0;\n\n    if(select(A, 'o', 'x')) flag |= 1;\n    if(select(B, 'x', 'o')) flag |= 2;\n\n    if(flag == 3) break;\n  }\n\n  printWorld();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=2e9;\ndouble EPS=1e-10;\nchar fld[8][8];\nchar rev(char c){\n      return c=='o'?'x':'o';\n}\nchar turn(int k){\n      return k==0?'x':'o';\n}\nbool pos(int x,int y){\n      return 0<=x&&x<8&&0<=y&&y<8;\n}\nint cnt(int x,int y,int dx,int dy,char k){\n      int res=0;\n      char l=rev(k);\n      x+=dx;y+=dy;\n      while(1){\n            if(fld[x][y]==l)res++;\n            else break;\n            x+=dx;y+=dy;\n            if(!pos(x,y)){\n                  return 0;\n            }\n      }\n      if(fld[x][y]==k){\n            return res;\n      }\n      return 0;\n}\nint rec(int x,int y,char k){\n      int res=0;\n      for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                  if(i==0&&j==0)continue;\n                  res+=cnt(x,y,i,j,k);\n            }\n      }\n      return res;\n}\nvoid change(int x,int y,char k){\n      for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                  if(i==0&&j==0)continue;\n                  int res=cnt(x,y,i,j,k);\n                  if(res==0)continue;\n                  REP(l,res+1){\n                        fld[x+i*l][y+j*l]=k;\n                  }\n            }\n      }\n      return;\n}\nint main(){\n      REP(i,8)REP(j,8)cin>>fld[j][i];\n      int t=0;\n      int c=0;\n      while(1){\n            int ma=0,mx,my;\n            if(t==0){\n                  for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n                        if(fld[j][i]!='.')continue;\n                        int res=rec(j,i,turn(t));\n                        if(res>=ma){\n                              mx=j;my=i;ma=res;\n                        }\n                  }\n            }else{\n                  REP(i,8)REP(j,8){\n                        if(fld[j][i]!='.')continue;\n                        int res=rec(j,i,turn(t));\n                        if(res>=ma){\n                              mx=j;my=i;ma=res;\n                        }\n                  }\n            }\n            if(ma==0){\n                  c++;\n                  t^=1;\n                  if(c>=2)break;\n                  continue;\n            }else c=0;\n            change(mx,my,turn(t));\n            t^=1;\n      }\n      REP(i,8){REP(j,8)printf(\"%c\",fld[j][i]);cout<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n, m, l;\nint k[2000];\nint s[100000];\nint f[100000];\n\nll *sbuff;\nll *mbuff;\n\nll *sum[2000];\nll *memo[2000];\n\nvoid init(){\n  int nn = n * (n + 1) / 2;\n  sbuff = (ll*)malloc(sizeof(ll) * nn);\n  mbuff = (ll*)malloc(sizeof(ll) * nn);\n\n  REP(i,n) sum[i] = (ll*)&sbuff[i * (i + 1) / 2];\n  REP(i,n) memo[i] = (ll*)&mbuff[i * (i + 1) / 2];\n}\n\nll solve(int l, int r){\n  if(l < r) swap(l, r);\n  if(memo[l][r] != -1) return memo[l][r];\n\n  int next = max(l, r) + 1;\n  ll ret = 0;\n\n  if(next == n){\n    ret = sum[l][r];\n  }else{\n    ret = sum[next][l] + solve(next, r);\n    ret = min(ret, sum[next][r] + solve(l, next));\n  }\n\n  return memo[l][r] = ret;\n}\n\nint main(){\n  scanf(\"%d%d%d\", &n, &m, &l);\n  REP(i,n){scanf(\"%d\", k+i); k[i]--;}\n  REP(i,m){scanf(\"%d\", s+i);}\n\n  sort(k, k+n);\n\n  init();\n\n  for(int i = 0; i < n; i++){\n    sum[i][i] = s[k[i]];\n    if(i != n - 1){\n      for(int j = k[i]; j <= k[i+1]; j++){\n\tsum[i+1][i] += s[j];\n      }\n    }\n  }\n  for(int len = 2; len < n; len++){\n    for(int i = 0; i + len < n; i++){\n      sum[i+len][i] = sum[i+1][i] + sum[i+len][i+1] - s[k[i+1]];\n    }\n  }\n\n  REP(i,n) REP(j,n) if(i >= j) sum[i][j] /= l;\n\n  // REP(i,n) { REP(j,n) printf(\"%3d \", (int)sum[i][j]); puts(\"\"); }\n  // REP(i,n) printf(\"%d (%d)\\n\", k[i], s[k[i]]);\n\n  REP(i,n) REP(j,n) if(i >= j) memo[i][j] = -1;\n\n  ll ans = solve(0, 0);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vector<string> S(8);\n    for (int i=0;i<8;++i) cin >> S[i];\n    int seq=0;\n    for (int t=0;;++t){\n        if (seq==2) break;\n        int M=0,sx,sy;\n        for (int i=0;i<8;++i){\n            for (int j=0;j<8;++j){\n                if (S[i][j]!='.') continue;\n                int cnt=0;\n                for (int k=0;k<8;++k){\n                    int x=i+dx[k],y=j+dy[k],cnt0=0;\n                    while(0<=x&&x<8&&0<=y&&y<8&&S[x][y]==(t&1?'o':'x')){\n                        ++cnt0; x+=dx[k],y+=dy[k];\n                    }\n                    if (0<=x&&x<8&&0<=y&&y<8&&S[x][y]==(t&1?'x':'o')) cnt+=cnt0;\n                }\n                if (M<cnt) M=cnt,sx=i,sy=j;\n                else if ((t&1)&&M==cnt) sx=i,sy=j;\n            }\n        }\n        if (!M){++seq; continue;}\n        seq=0;\n        S[sx][sy]=(t&1?'x':'o');\n        for (int k=0;k<8;++k){\n            int x=sx+dx[k],y=sy+dy[k];\n            while(0<=x&&x<8&&0<=y&&y<8&&S[x][y]==(t&1?'o':'x')){\n                x+=dx[k],y+=dy[k];\n            }\n            if (0<=x&&x<8&&0<=y&&y<8&&S[x][y]==(t&1?'x':'o')){\n                while(x!=sx||y!=sy){\n                    x-=dx[k],y-=dy[k];\n                    S[x][y]=(t&1?'x':'o');\n                }\n            }\n        }\n    }\n    for (int i=0;i<8;++i) cout << S[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n\n#define INF 100000000\n#define EPS 1e-9\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define MAX_H 8\n#define MAX_W 8\n\nstring maze[MAX_H];\n\nint board[MAX_H][MAX_W];\n\nint main(){\n  \n  for (int i = 0; i < 8; i++){\n    cin >> maze[i];\n    for (int j = 0; j < 8; j++){\n      if (maze[i][j] == 'o')\n\tboard[i][j] = 1;\n      else if (maze[i][j] == 'x')\n\tboard[i][j] = -1;\n      else\n\tboard[i][j] = 0;\n    }\n  }\n  \n  int pass = 0;\n  int turn = 1;\n  \n  while (pass < 2){\n    \n    int enemy = -1 * turn;\n    \n    int x = -1, y = -1;\n    int sum = 0;\n    \n    if (turn == 1){\n      for (int i = 0; i < 8; i++){\n\tfor (int j = 0; j < 8; j++){\n\t  if (board[i][j] != 0)\n\t    continue;\n\t  int res = 0;\n\t  for (int dx = -1; dx <= 1; dx++){\n\t    for (int dy = -1; dy <= 1; dy++){\n\t      if (dx == 0 && dy == 0)\n\t\tcontinue;\n\t      if (i + dy >= 0 && i + dy < 8 && \n\t\t  j + dx >= 0 && j + dx < 8 && \n\t\t  board[i + dy][j + dx] == enemy){\n\t\tfor (int d = 1; i + dy*d >= 0 && i + dy*d < 8 && \n\t\t       j + dx*d >= 0 && j + dx*d < 8; d++){\n\t\t  if (board[i + dy*d][j + dx*d] == 0)\n\t\t    break;\n\t\t  if (board[i + dy*d][j + dx*d] == turn){\n\t\t    res += d-1;\n\t\t    break;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if (sum < res){\n\t    sum = res;\n\t    x = j;\n\t    y = i;\n\t  }\n\t}\n      }\n    }\n    \n    else{\n      for (int i = 7; i >= 0; i--){\n\tfor (int j = 7; j >= 0; j--){\n\t  if (board[i][j] != 0)\n\t    continue;\n\t  int res = 0;\n\t  for (int dx = -1; dx <= 1; dx++){\n\t    for (int dy = -1; dy <= 1; dy++){\n\t      if (dx == 0 && dy == 0)\n\t\tcontinue;\n\t      if (i + dy * 1 >= 0 && i + dy * 1 < 8 && \n\t\t  j + dx * 1 >= 0 && j + dx * 1 < 8 && \n\t\t  board[i + dy][j + dx] == enemy){\n\t\tfor (int d = 1; i + dy*d >= 0 && i + dy*d < 8 && \n\t\t       j + dx*d >= 0 && j + dx*d < 8; d++){\n\t\t  if (board[i + dy*d][j + dx*d] == 0)\n\t\t    break;\n\t\t  if (board[i + dy*d][j + dx*d] == turn){\n\t\t    res += d-1;\n\t\t    break;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if (sum < res){\n\t    sum = res;\n\t    x = j;\n\t    y = i;\n\t  }\n\t}\n      }\n    }\n    \n    if (x == -1){\n      pass++;\n      turn *= -1;\n      continue;\n    }\n    \n    board[y][x] = turn;\n    \n    for (int dx = -1; dx <= 1; dx++){\n      for (int dy = -1; dy <= 1; dy++){\n\tif (dx == 0 && dy == 0)\n\t  continue;\n\tif (y + dy >= 0 && y + dy < 8 && \n\t    x + dx >= 0 && x + dx < 8 && \n\t    board[y + dy][x + dx] == enemy){\n\t  bool flag = false;\n\t  for (int d = 2; y + dy*d >= 0 && y + dy*d < 8 && \n\t\t x + dx*d >= 0 && x + dx*d < 8; d++){\n\t    if(board[y+dy*d][x+dx*d] == 0)\n\t      break;\n\t    if(board[y+dy*d][x+dx*d] == turn){\n\t      flag = true;\n\t      break;\n\t    }\n\t  }\n\t  if(flag){\n\t    for (int d = 1; y + dy*d >= 0 && y + dy*d < 8 && \n\t\t   x + dx*d >= 0 && x + dx*d < 8; d++){\n\t      board[y+dy*(d-1)][x+dx*(d-1)] = turn;\n\t      if(board[y+dy*d][x+dx*d] == turn){\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    turn *= -1;\n    pass = 0;\n    \n  }\n  \n  for (int i = 0; i < 8; i++){\n    for (int j = 0; j < 8; j++){\n      if (board[i][j] == 1)\n\tcout << 'o';\n      else if (board[i][j] == -1)\n\tcout << 'x';\n      else\n\tcout << '.';\n    }\n    cout << endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\nstring q = \"ox\";\nint dx[8] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dy[8] = {1, -1, 1, 0, -1, 1, 0, -1};\n\nvector<string> rev(vector<string> s, int turn, int y, int x){\n  char c = q[(turn+1)%2];\n  s[y][x] = q[turn%2];\n  int cnt = 0;\n  for(int dir=0; dir<8; dir++){\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) continue;\n    if( s[ny][nx] == '.' ) continue;\n    bool f = false;\n    while( s[ny][nx] == c ){\n      cnt++;\n      // s[ny][nx] = q[turn%2];\n      ny += dy[dir];\n      nx += dx[dir];\n\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) break;\n      if( s[ny][nx] == q[turn%2] ){\n        f = true;\n        break;\n      }\n      if( s[ny][nx] == '.' ) break;\n    }\n    while( f ){\n      if( ny == y && nx == x ) break;\n      s[ny][nx] = q[turn%2];\n      ny -= dy[dir];\n      nx -= dx[dir];\n    }\n  }\n  return s;\n}\n\n\nint calc(vector<string> s, int turn, int y, int x){\n  char c = 'x';\n  if( turn % 2 == 1 ) c = 'o';\n  int cnt = 0;\n  for(int dir=0; dir<8; dir++){\n    int ny = y + dy[dir];\n    int nx = x + dx[dir];\n    if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) continue;\n    int tmp = 0;\n    bool f = false;\n    while( s[ny][nx] == c ){\n      tmp++;\n      ny += dy[dir];\n      nx += dx[dir];\n\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) break;\n      if( s[ny][nx] == q[turn%2] ) f = true;\n    }\n    cnt += tmp * f;\n  }\n  return cnt;\n}\n\nvector<string> func(vector<string> s, int turn){\n  int a = -1;\n  int rx = -1, ry = -1;\n  for(int i=0; i<8; i++){\n    for(int j=0; j<8; j++){\n      int x = j, y = i;\n      if( turn % 2 == 1 ) x = 7 - j;\n      if( turn % 2 == 1 ) y = 7 - i;\n      if( s[y][x] != '.' ) continue;\n\n      int r = calc(s, turn, y, x);\n      if( a < r ){\n        a = r;\n        rx = x;\n        ry = y;\n      }\n    }\n  }\n  // cerr << a << \" \" << rx << \" \" << ry << endl;\n  if( a <= 0 ) return s;\n  return rev(s, turn, ry, rx);\n}\n\nint main(void) {\n\n  vector<string> s(8);\n  for(int i=0; i<8; i++) cin >> s[i];\n  int q = 0;\n  int turn = 0;\n  while( true ){\n    vector<string> t = func(s, turn);\n    turn++;\n    if( s == t ) q++;\n    s = t;\n    if( q > 3 ) break;\n    // for(int i=0; i<8; i++) cerr << s[i] << endl;\n    // cerr << endl;\n  }\n\n  for(int i=0; i<8; i++){\n    cout << s[i] << endl;\n  }\n\n  return 0;\n}\n\n\n// EOF"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nint di[] = {-1,-1,-1,0,0,1,1,1};\nint dj[] = {-1,0,1,-1,1,-1,0,1};\n\nvoid copyArray(char to[10][10],char from[10][10]){\n  rep(i,10){\n    rep(j,10){\n      to[i][j] = from[i][j];\n    }\n  }\n}\n\nint count(char t[10][10],char ch){\n  int res = 0;\n  rep(i,8){\n    rep(j,8){\n      if(t[i][j] == ch){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nvoid draw(char t[10][10],char ch,int si,int sj){\n  t[si][sj] = ch;\n\n  rep(k,8){\n    int i = si;\n    int j = sj;\n    bool drawFlg = false;\n\n    while(1){\n      int ni = i + di[k];\n      int nj = j + dj[k];\n      if(ni < 0 || 8 <= ni || nj < 0 || 8 <= nj || t[ni][nj] == '.'){\n        break;\n      }\n      if(t[ni][nj] == ch){\n        if(i != si || j != sj) drawFlg = true;\n        break;\n      }\n\n      i = ni;\n      j = nj;\n    }\n\n    if(!drawFlg) continue;\n\n    i = si;\n    j = sj;\n    while(1){\n      int ni = i + di[k];\n      int nj = j + dj[k];\n      if(t[ni][nj] == ch){\n        drawFlg = true;\n        break;\n      }\n      t[ni][nj] = ch;\n      i = ni;\n      j = nj;\n    }\n  }\n}\n\nint main(void){\n  char t[10][10],s[10][10];\n\n  while(1){\n    rep(i,8){\n      if(scanf(\"%s\",t[i]) == EOF) return 0;\n    }\n\n    char now = 'o';\n    bool prePass = false;\n\n    while(1){\n      int batu = count(t,'x');\n      if(batu == 0) break;\n      int maru = count(t,'o');\n      if(maru == 0) break;\n\n      int maxCnt = (now == 'x' ? batu : maru) + 1;\n      int mi=-1,mj=-1;\n\n      if(now == 'o'){\n        for(int i=0;i<8;i++){\n          for(int j=0;j<8;j++){\n            if(t[i][j] != '.') continue;\n            copyArray(s,t);\n            draw(s,now,i,j);\n            int tmp = count(s,now);\n            if(maxCnt < tmp){\n              maxCnt = tmp;\n              mi = i;\n              mj = j;\n            }\n          }\n        }\n      }\n      else{\n        for(int i=7;i>=0;i--){\n          for(int j=7;j>=0;j--){\n            if(t[i][j] != '.') continue;\n            copyArray(s,t);\n            draw(s,now,i,j);\n            int tmp = count(s,now);\n            if(maxCnt < tmp){\n              maxCnt = tmp;\n              mi = i;\n              mj = j;\n            }\n          }\n        }\n      }\n\n      bool pass = false;\n\n      if(mi != -1){\n        draw(t,now,mi,mj);\n      }\n      else{\n        pass = true;\n        if(prePass && pass) break;\n      }\n\n      prePass = pass;\n      now = (now == 'x' ? 'o' : 'x');\n    }\n\n    rep(i,8){\n      printf(\"%s\\n\",t[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nchar c[9][9];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\trep(i,8)cin>>c[i];\n\tchar me='o',ene='x';\n\tint pass=0;\n\twhile(1){\n\t\t/*rep(i,8)cout<<c[i]<<endl;\n\t\tcout<<endl;*/\n\t\tint Y=-1,X=-1,best=0;\n\t\trep(i,8)rep(j,8)if(c[i][j]=='.'){\n\t\t\tint flip=0;\n\t\t\trep2(dy,-1,2)rep2(dx,-1,2)if(dy||dx){\n\t\t\t\tint y=i,x=j,f=0;\n\t\t\t\twhile(1){\n\t\t\t\t\ty+=dy,x+=dx;\n\t\t\t\t\tif(y<0 || 7<y || x<0 || 7<x)break;\n\t\t\t\t\tif(c[y][x]!=ene){\n\t\t\t\t\t\tif(c[y][x]==me)flip+=f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tf++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(me=='o'){\n\t\t\t\tif(flip>best)best=flip,Y=i,X=j;\n\t\t\t}else{\n\t\t\t\tif(flip>=best)best=flip,Y=i,X=j;\n\t\t\t}\n\t\t}\n\t\tif(best==0){\n\t\t\tpass++;\n\t\t\tif(pass==2)break;\n\t\t\tswap(me,ene);\n\t\t\tcontinue;\n\t\t}\n\t\tc[Y][X]=me;\n\t\trep2(dy,-1,2)rep2(dx,-1,2)if(dy||dx){\n\t\t\tint y=Y,x=X,ok=0;\n\t\t\twhile(1){\n\t\t\t\ty+=dy,x+=dx;\n\t\t\t\tif(y<0 || 7<y || x<0 || 7<x)break;\n\t\t\t\tif(c[y][x]!=ene){\n\t\t\t\t\tif(c[y][x]==me)ok=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ty=Y,x=X;\n\t\t\t\twhile(1){\n\t\t\t\t\ty+=dy,x+=dx;\n\t\t\t\t\tif(y<0 || 7<y || x<0 || 7<x)break;\n\t\t\t\t\tif(c[y][x]!=ene)break;\n\t\t\t\t\tc[y][x]=me;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpass=0;\n\t\tswap(me,ene);\n\t}\n\trep(i,8)cout<<c[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstring s[10];\n\tfor (int i = 1; i <= 8; i++) {\n\t\tcin >> s[i];\n\t\ts[i] = 'A' + s[i] + 'A';\n\t}\n\tfor (int i = 0; i < 10; i++) {\n\t\ts[0] += 'A';\n\t\ts[9] += 'A';\n\t}\n\tint field[10][10] = {};\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (s[i][j] == '.')field[i][j] = 0;\n\t\t\telse if (s[i][j] == 'o')field[i][j] = 1;\n\t\t\telse if (s[i][j] == 'x')field[i][j] = 2;\n\t\t\telse field[i][j] = 3;\n\t\t}\n\t}\n\tint dx[8] = { -1,0,1,1,1,0,-1,-1 };\n\tint dy[8] = { -1,-1,-1,0,1,1,1,0 };\n\tint player = 1;\n\tbool pass = false;\n\twhile (1) {\n\t\tbool pas = true;\n\t\tint rev[10][10] = {};\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tif (!field[i][j]) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tbool cnt = false;\n\t\t\t\t\t\tint loop = 1;\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tif (field[i + dy[k] * loop][j + dx[k] * loop] != (player ^ 3)) {\n\t\t\t\t\t\t\t\tif (field[i + dy[k] * loop][j + dx[k] * loop] == player)cnt = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse loop++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt)rev[i][j] += loop - 1;\n\t\t\t\t\t\tif (rev[i][j])pas = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"hi\";\n\t\tif (pas) {\n\t\t\t//cout << \"hi\";\n\t\t\tif (pass)break;\n\t\t\tpass = true;\n\t\t\tplayer ^= 3;\n\t\t\tcontinue;\n\t\t}\n\t\tpass = false;\n\t\tset<pair<int, pair<int, int>>>se;\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tif(player==2)se.insert({ rev[i][j], { i,j } });\n\t\t\t\telse se.insert({ 100 - rev[i][j], { i,j } });\n\t\t\t}\n\t\t}\n\t\tint cx, cy;\n\t\tif (player == 2) {\n\t\t//\tcout << (*se.rbegin()).first << endl;\n\t\t\tcx = (*se.rbegin()).second.second;\n\t\t\tcy = (*se.rbegin()).second.first;\n\t\t}\n\t\telse {\n\t\t\tcx = (*se.begin()).second.second;\n\t\t\tcy = (*se.begin()).second.first;\n\t\t}\n\t\tfor (int k = 0; k < 8; k++) {\n\t\t\tbool cnt = false;\n\t\t\tint loop = 1;\n\t\t\twhile (1) {\n\t\t\t\tif (field[cy + dy[k] * loop][cx + dx[k] * loop] != (player ^ 3)) {\n\t\t\t\t\tif (field[cy + dy[k] * loop][cx + dx[k] * loop] == player)cnt = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tif (cnt) {\n\t\t\t\twhile (loop) {\n\t\t\t\t\tloop--;\n\t\t\t\t\tfield[cy + dy[k] * loop][cx + dx[k] * loop] = player;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplayer ^= 3;\n\t}\n\tfor (int i = 1; i <= 8; i++) {\n\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\tif (field[i][j] == 0)cout << '.';\n\t\t\telse if (field[i][j] == 1)cout << 'o';\n\t\t\telse cout << \"x\";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef pair<int,int> PA;\ntypedef pair<int,PA> P;\n \nint cho,che;\nchar table[8][8];\nvector<P> v;\n \nconst int dx[8] = {0,0,1,1,1,-1,-1,-1};\nconst int dy[8] = {1,-1,0,-1,1,-1,0,1};\nconst char ch[3] = {'x','o'};\n \nvoid check(int x,int y,int turn,vector<P> &v){\n    char c = ch[turn],d = ch[1-turn];\n    int count = 0;\n \n    for(int i = 0 ; i < 8 ; i++){\n\tint cnt = 0;\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n \n\twhile(true){\n\t    if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\t\tbreak;\n\t    }\n\t    if(table[nx][ny] != d){\n\t\tif(table[nx][ny] == c){\n\t\t    count += cnt;\n\t\t}\n\t\tbreak;\n\t    }\n\t    cnt++;\n\t    nx += dx[i];\n\t    ny += dy[i];\n\t}\n    }   \n \n    if(count == 0) return;\n    \n    if(turn){\n\tv.push_back(P(-count,PA(x,y)));\n    }else{\n\tv.push_back(P(-count,PA(-x,-y)));\n    }\n}\n \nvoid change(P a,int turn){\n    char c = ch[turn],d = ch[1-turn];\n \n    a.first = -a.first;\n \n    if(!turn){\n\ta.second.first = -a.second.first;\n\ta.second.second = -a.second.second;\n    }\n    table[a.second.first][a.second.second] = c;\n \n    for(int i = 0 ; i < 8 ; i++){\n\tint nx = a.second.first + dx[i];\n\tint ny = a.second.second + dy[i];\n\tvector<PA> v;\n \n\twhile(true){\n\t    if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\t\tbreak;\n\t    }\n\t    if(table[nx][ny] != d){\n\t\tbreak;\n\t    }\n\t    v.push_back(PA(nx,ny));\n\t    nx += dx[i];\n\t    ny += dy[i];\n\t}\n \n\tif(!(0 > nx || 0 > ny || nx >= 8 || ny >= 8) && table[nx][ny] == c){\n\t    while(true){     \n\t\tif(nx == a.second.first && ny == a.second.second){\n\t\t    break;\n\t\t}\n\t\ttable[nx][ny] = c;  \n\t\tnx -= dx[i];\n\t\tny -= dy[i];\n\t    }\n\t}\n    } \n \n    if(turn){\n\tcho += a.first+1;\n\tche -= a.first;\n    }else{\n\tcho -= a.first;\n\tche += a.first+1;\n    }\n}\n \nint main(){\n    for(int i = 0 ; i < 8 ; i++){\n\tfor(int j = 0 ; j < 8 ; j++){\n\t    cin >> table[i][j];\n \n\t    if(table[i][j] == 'o'){\n\t\tcho++;\n\t    }else if(table[i][j] == 'x'){\n\t\tche++;\n\t    }\n\t}\n    }\n \n    //true mami ------ false witch\n    bool turn = true;\n    int pass = 0;\n \n    while(true){\n\tvector<P> v;\n  \n\tif(pass == 2 || !cho || !che || cho+che == 64){\n\t    break;\n\t}\n  \n\tfor(int i = 0 ; i < 8 ; i++){\n\t    for(int j = 0 ; j < 8 ; j++){\n\t\tif(table[i][j] == '.'){\n\t\t    int n = turn ? 1 : 0;\n\t\t    check(i,j,n,v);\n\t\t}\n\t    }\n\t}  \n \n\tint size = (int)v.size();\n \n\tif(size == 0){\n\t    pass++;\n\t}else{\n\t    pass = 0;\n\t    int n = turn ? 1 : 0;\n\t    sort(v.begin(),v.end());\n\t    change(v[0],n);\n\t}\n \n\tturn = !turn;\n    }\n \n    for(int i = 0 ; i < 8 ; i++){\n\tfor(int j = 0 ; j < 8 ; j++){\n\t    cout << table[i][j];\n\t}\n\tcout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nchar s[] = { 'o', 'x' };\nstring B[10];\nint dx[] = {  0, -1, -1, -1, 0, 1, 1, 1  };\nint dy[] = { -1, -1,  0,  1, 1, 1, 0, -1 };\n\nint count(int t, int ii, int jj)\n{\n    if (B[ii][jj] != '.') return 0;\n    int ans = 0;\n    loop (8, p) {\n        int i = ii + dx[p], j = jj + dy[p];\n        int cnt = 0;\n        while (B[i][j] == s[!t]) i += dx[p], j += dy[p], cnt++;\n        if (B[i][j] == s[t]) ans += cnt;\n    }\n    return ans;\n}\n\nint move(int t, int ii, int jj)\n{\n    B[ii][jj] = s[t];\n    loop (8, p) {\n        int i = ii, j = jj;\n        i += dx[p], j += dy[p];\n        while (B[i][j] == s[!t]) i += dx[p], j += dy[p];\n        if (B[i][j] != s[t]) continue;\n        i = ii + dx[p], j = jj + dy[p];\n        while (B[i][j] == s[!t]) B[i][j] = s[t], i += dx[p], j += dy[p];\n    }\n}\n\nint main()\n{\n    B[0] = \"----------\";\n    B[9] = \"----------\";\n    loop (8, i) {\n        string s; cin >> s;\n        B[i+1] = \"-\" + s + \"-\";\n    }\n\n    int t = 0;\n    int end = 0;\n    while (1) {\n        int m_cnt = 0, x = -1, y = -1;\n        loop (8, ii) loop (8, jj) {\n            int i = ii + 1, j = jj + 1;\n            if (t) i = 8 - ii, j = 8 - jj;\n\n            int cnt = count(t, i, j);\n            if (cnt > m_cnt) m_cnt = cnt, x = i, y = j;\n        }\n        if (m_cnt) end = 0, move(t, x, y);\n        else end++;\n        t ^= 1;\n        if (end > 1) break;\n    }\n    loop (8, i) {\n        cout << B[i+1].substr(1, 8) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[8][9];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nint main(){\n\tfor(int i=0;i<8;i++)scanf(\"%s\",str[i]);\n\tbool ok=false;\n\tdo{\n\t\tok=false;\n\t\tint t=0;\n\t\tint row=0;\n\t\tint col=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\tif(str[i][j]=='.'){\n\t\t\t\t\tint m=0;\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tint n=0;\n\t\t\t\t\t\tint R=i+dx[k];\n\t\t\t\t\t\tint C=j+dy[k];\n\t\t\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\t\t\tif(str[R][C]=='x')n++;\n\t\t\t\t\t\t\tif(str[R][C]=='o'){\n\t\t\t\t\t\t\t\tm+=n;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\t\t\tR+=dx[k];\n\t\t\t\t\t\t\tC+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m>t){\n\t\t\t\t\t\tt=m;\n\t\t\t\t\t\trow=i;\n\t\t\t\t\t\tcol=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t){\n\t\t\tstr[row][col]='o';\n\t\t\tok=true;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tbool B=false;\n\t\t\t\tint R=row+dx[k];\n\t\t\t\tint C=col+dy[k];\n\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\tif(str[R][C]=='o'){\n\t\t\t\t\t\tB=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t\tif(!B)continue;\n\t\t\t\tR=row+dx[k];\n\t\t\t\tC=col+dy[k];\n\t\t\t\twhile(str[R][C]=='x'){\n\t\t\t\t\tstr[R][C]='o';\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d %d %d o\\n\",row,col,t);\n//\tfor(int i=0;i<8;i++)printf(\"%s\\n\",str[i]);\n\t\t}\n\t\tt=0;\n\t\trow=0;\n\t\tcol=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\tif(str[i][j]=='.'){\n\t\t\t\t\tint m=0;\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tint n=0;\n\t\t\t\t\t\tint R=i+dx[k];\n\t\t\t\t\t\tint C=j+dy[k];\n\t\t\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\t\t\tif(str[R][C]=='o')n++;\n\t\t\t\t\t\t\tif(str[R][C]=='x'){\n\t\t\t\t\t\t\t\tm+=n;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\t\t\tR+=dx[k];\n\t\t\t\t\t\t\tC+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m>t){\n\t\t\t\t\t\tt=m;\n\t\t\t\t\t\trow=i;\n\t\t\t\t\t\tcol=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t){\n\t\t\tstr[row][col]='x';\n\t\t\tok=true;\n\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\tbool B=false;\n\t\t\t\tint R=row+dx[k];\n\t\t\t\tint C=col+dy[k];\n\t\t\t\twhile(0<=R&&R<8&&0<=C&&C<8){\n\t\t\t\t\tif(str[R][C]=='x'){\n\t\t\t\t\t\tB=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[R][C]=='.')break;\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t\tif(!B)continue;\n\t\t\t\tR=row+dx[k];\n\t\t\t\tC=col+dy[k];\n\t\t\t\twhile(str[R][C]=='o'){\n\t\t\t\t\tstr[R][C]='x';\n\t\t\t\t\tR+=dx[k];\n\t\t\t\t\tC+=dy[k];\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d %d %d x\\n\",row,col,t);\n//\tfor(int i=0;i<8;i++)printf(\"%s\\n\",str[i]);\n\t\t}\n\t}while(ok);\n\tfor(int i=0;i<8;i++)printf(\"%s\\n\",str[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint dr[] = { 1, 1, 1, 0, -1, -1, -1, 0 };\nint dc[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nstring b[8];\n\nbool ok(int r, int c) {\n    return 0 <= r and r < 8 and 0 <= c and c < 8;\n}\n\nint f1(bool turn, int r, int c, int dir, int sum) {\n    int res = 0;\n    if (dir == -1) {\n        rep(d, 8) {\n            int nr = r+dr[d], nc = c+dc[d];\n            if (!ok(nr, nc) or b[nr][nc] != (turn ? 'x' : 'o')) continue;\n            res += f1(turn, nr, nc, d, sum+1);\n        }\n        return res;\n    }\n    else {\n        int nr = r + dr[dir], nc = c + dc[dir];\n        if (!ok(nr, nc)) return 0;\n        if (b[nr][nc] == (turn ? 'o' : 'x')) {\n            return sum;\n        }\n        else if (b[nr][nc] == (turn ? 'x' : 'o')) {\n            res += f1(turn, nr, nc, dir, sum+1);\n        }\n        return res;\n    }\n}\n\nbool f2(bool turn, int r, int c, int dir) {\n    if (dir == -1) {\n        rep(d, 8) {\n            int nr = r+dr[d], nc = c+dc[d];\n            if (!ok(nr, nc) or b[nr][nc] != (turn ? 'x' : 'o')) continue;\n            bool f = f2(turn, nr, nc, d);\n            if (f) b[nr][nc] = (turn ? 'o' : 'x');\n        }\n        return true;\n    }\n    else {\n        int nr = r + dr[dir], nc = c + dc[dir];\n        if (!ok(nr, nc)) return false;\n        if (b[nr][nc] == (turn ? 'o' : 'x')) {\n            b[nr][nc] = (turn ? 'o' : 'x');\n            return true;\n        }\n        else if (b[nr][nc] == (turn ? 'x' : 'o')) {\n            bool f = f2(turn, nr, nc, dir);\n            if (f) b[nr][nc] = (turn ? 'o' : 'x');\n            return f;\n        }\n    }\n    return false;\n}\n\nint main() {\n    rep(d, 8) cin >> b[d];\n    bool turn = true, update = true;\n    int cnt = 0;\n    while (true) {\n        if (cnt >= 2) break;\n        int ma = 0, tr, tc;\n\n        rep(rr, 8) rep(cc, 8) {\n            int r = (turn ? rr : 7-rr);\n            int c = (turn ? cc : 7-cc);\n            if (b[r][c] == '.') {\n                int tmp = f1(turn, r, c, -1, 0);\n                if (tmp > ma) {\n                    ma = tmp;\n                    tr = r, tc = c;\n                }\n            }\n        }\n\n        if (ma > 0) {\n            f2(turn, tr, tc, -1);\n            b[tr][tc] = (turn ? 'o' : 'x');\n        }\n\n        if (ma > 0) cnt = 0;\n        else ++cnt;\n\n        turn = !turn;\n    }\n    rep(r, 8) cout << b[r] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//?????????\n//????£?????????????\n// o:= ?????????x:= ??????\n// {'o', 'x', '.'} = {0, 1, 2}\n//????£??????????????????§10x10??????\n// o:= ?????????????????§?????????\n// x:= ?????????????????§?????????\n\n\nint di[8] = {0, -1, -1, -1, 0, 1, 1, 1};\nint dj[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint h;\n\nint ex(int i, int j, int p, int o, vector<vector<int> > osero){ //?????£?????????????????°?????????\n\n    if(osero[i][j] != 2) return 0;\n    int ans = 0;\n    for(int k = 0; k < 8; k++){\n        int ni = i + di[k];\n        int nj = j + dj[k];\n        int temp = 0;\n        while(1){\n            \n            if(osero[ni][nj] == p){\n                ans += temp;\n                break;\n            }else if(osero[ni][nj] == 2){\n                break;\n            }else{\n                temp++;\n            }\n\n            ni += di[k];\n            nj += dj[k];\n        }\n    }\n\n    return ans;\n}\n\nbool play(int i, int j, int p, int o, vector<vector<int> >& osero){ //??????????????£??°?????????\n\n    \n    int ni = i + di[h];\n    int nj = j + dj[h];\n\n    //????????????????????????????????§0?????????\n    if(osero[ni][nj] == 2){\n        return false;\n    }\n        \n    //?????????????????????????????????????????§1?????????\n    if(osero[ni][nj] == p){\n        return true;\n    }\n\n    //???????????????????¬??????????\n    if(osero[ni][nj] == o){\n        bool flag = play(ni, nj, p, o, osero);\n\n        if(flag){ //1?????°??£???????????????????????¢\n            osero[ni][nj] = p;\n            return 1;\n        }\n    }\n    \n\n    return 0;\n}\n\n\nint main(){\n    \n    //??\\???\n    vector<vector<int> > osero(10, vector<int> (10, 2));\n    for(int i = 1; i <= 8; i++){\n        for(int j = 1; j <= 8; j++){\n            char input; cin >> input;\n            if(input == 'o') osero[i][j] = 0;\n            else if(input == 'x') osero[i][j] = 1;\n        }\n    }\n\n    bool flag = true;\n\n    while(flag){\n\n        flag = false;\n        //??????????????????\n        int MAX = 0;\n        int MAX_i = 0, MAX_j = 0;\n        for(int i = 1; i <= 8; i++){\n            for(int j = 1; j <= 8; j++){\n                int temp = ex(i, j, 0, 1, osero);\n                if(temp > MAX){\n                    MAX = temp;\n                    MAX_i = i;\n                    MAX_j = j;\n                    flag = true;\n                }\n            }\n        }\n\n        if(MAX > 0) for(h = 0; h < 8; h++){\n            play(MAX_i, MAX_j, 0, 1, osero);\n            osero[MAX_i][MAX_j] = 0;\n        }\n\n\n        //????\\?????????????\n        MAX = 0;\n        for(int i = 8; i >= 1; i--){\n            for(int j = 8; j >= 1; j--){\n                int temp = ex(i, j, 1, 0, osero);\n                if(temp > MAX){\n                    MAX = temp;\n                    MAX_i = i;\n                    MAX_j = j;\n                    flag = true;\n                }\n            }\n        }\n\n        \n\n        if(MAX > 0) for(h = 1; h < 8; h++){\n            play(MAX_i, MAX_j, 1, 0, osero);\n            osero[MAX_i][MAX_j] = 1;\n        }\n\n        \n        /*for(int i = 1; i <= 8; i++){\n            for(int j = 1; j <= 8; j++){\n                if(osero[i][j] == 0) cout << 'o';\n                if(osero[i][j] == 1) cout << 'x';\n                if(osero[i][j] == 2) cout << '.';\n            }\n            cout << endl;\n        }\n        int input; cin >> input;*/\n\n    }\n    cout << endl;\n    //??????\n    for(int i = 1; i <= 8; i++){\n        for(int j = 1; j <= 8; j++){\n            if(osero[i][j] == 0) cout << 'o';\n            if(osero[i][j] == 1) cout << 'x';\n            if(osero[i][j] == 2) cout << '.';\n        }\n        cout << endl;\n    }   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\n\tvector< vector<char> > mp(8, vector<char>(8));\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tbool turn = true;\n\n\tbool end = false;\n\n\tint dx[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tint dy[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\n\twhile (true) {\n\n\t\tint toku = 0;\n\t\tP pos = P(-1, -1);\n\n\t\tvector<int> dxy(8, 0);\n\n\t\tif (turn) {\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tif (mp[y][x] == '.') {\n\t\t\t\t\t\tint ttoku = 0;\n\t\t\t\t\t\tvector<int> tdxy(8, 0);\n\t\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\t\tbool hh = false;\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tP pp = P(x, y);\n\t\t\t\t\t\t\twhile (0 <= pp.first + dx[k] && pp.first + dx[k] < 8 && 0 <= pp.second + dy[k] && pp.second + dy[k] < 8) {\n\t\t\t\t\t\t\t\tpp.first += dx[k];\n\t\t\t\t\t\t\t\tpp.second += dy[k];\n\t\t\t\t\t\t\t\tif (mp[pp.second][pp.first] == 'o') {\n\t\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if (mp[pp.second][pp.first] == 'x') {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hh) {\n\t\t\t\t\t\t\t\ttdxy[k] = 1;\n\t\t\t\t\t\t\t\tttoku += count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ttoku > toku) {\n\t\t\t\t\t\t\ttoku = ttoku;\n\t\t\t\t\t\t\tpos.first = x;\n\t\t\t\t\t\t\tpos.second = y;\n\t\t\t\t\t\t\tdxy = tdxy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int y = 7; y >= 0; y--) {\n\t\t\t\tfor (int x = 7; x >= 0; x--) {\n\t\t\t\t\tif (mp[y][x] == '.') {\n\t\t\t\t\t\tint ttoku = 0;\n\t\t\t\t\t\tvector<int> tdxy(8, 0);\n\t\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\t\tbool hh = false;\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tP pp = P(x, y);\n\t\t\t\t\t\t\twhile (0 <= pp.first + dx[k] && pp.first + dx[k] < 8 && 0 <= pp.second + dy[k] && pp.second + dy[k] < 8) {\n\t\t\t\t\t\t\t\tpp.first += dx[k];\n\t\t\t\t\t\t\t\tpp.second += dy[k];\n\t\t\t\t\t\t\t\tif (mp[pp.second][pp.first] == 'x') {\n\t\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if (mp[pp.second][pp.first] == 'o') {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hh) {\n\t\t\t\t\t\t\t\ttdxy[k] = 1;\n\t\t\t\t\t\t\t\tttoku += count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ttoku > toku) {\n\t\t\t\t\t\t\ttoku = ttoku;\n\t\t\t\t\t\t\tpos.first = x;\n\t\t\t\t\t\t\tpos.second = y;\n\t\t\t\t\t\t\tdxy = tdxy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toku == 0) {\n\t\t\tif (end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t//cout << pos.first << ' ' << pos.second << endl;\n\t\t\tif (turn) {\n\t\t\t\tmp[pos.second][pos.first] = 'o';\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (dxy[k] == 1) {\n\t\t\t\t\t\tP pp = pos;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tpp.first += dx[k];\n\t\t\t\t\t\t\tpp.second += dy[k];\n\t\t\t\t\t\t\tif (mp[pp.second][pp.first] == 'x') {\n\t\t\t\t\t\t\t\tmp[pp.second][pp.first] = 'o';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[pos.second][pos.first] = 'x';\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (dxy[k] == 1) {\n\t\t\t\t\t\tP pp = pos;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tpp.first += dx[k];\n\t\t\t\t\t\t\tpp.second += dy[k];\n\t\t\t\t\t\t\tif (mp[pp.second][pp.first] == 'o') {\n\t\t\t\t\t\t\t\tmp[pp.second][pp.first] = 'x';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = false;\n\t\t}\n\n\t\tturn = !turn;\n\t}\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcout << mp[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * dessert_witch.cpp\n *\n *  Created on: 2017/02/21\n *      Author: Nishio\n */\n#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<b)\n#define F first\n#define S second\nusing namespace std;\n\n\nint main(){\n\tchar field[8][8];\n\tint dx[8]={1,1,1,0,0,-1,-1,-1};\n\tint dy[8]={1,0,-1,1,-1,1,0,-1};\n\tbool d=1,flag1=1,flag2=1;\n\tpair<int,pair<int,int>> cnt,mx;//value,(x,y)\n\tmx.F=0;\n\tmap<bool,char> m;\n\tint i,j,lx=7,ly=7,rx=0,ry=0;\n\tm[true]='o';\n\tm[false]='x';\n\tREP(l,0,8)\t{\n\t\tREP(n,0,8){\n\t\t\tcin>>field[l][n];\n\t\t\tif(field[l][n]!='.'){\n\t\t\t\tlx=min(lx,n-1);\n\t\t\t\trx=max(rx,n+1);\n\t\t\t\tly=min(ly,l-1);\n\t\t\t\try=max(ry,l+1);\n\t\t\t}\n\t\t}\n\t}\n\tlx=max(lx,0);\n\trx=min(rx,7);\n\tly=max(ly,0);\n\try=min(ry,7);\n\twhile(flag2){\n\t\tmx.F=0;\n\t\tvector<pair<int,int>> vt;\n\t\tREP(l,ly,ry+1){\n\t\t\tif(d) i=l;\n\t\t\telse i=ry-l+ly;\n\t\t\tREP(n,lx,rx+1){\n\t\t\t\tif(d) j=n;\n\t\t\t\telse j=rx-n+lx;\n\t\t\t\tif(field[i][j]!='.') continue;\n\t\t\t\tvector<pair<int,int>> change;\n\t\t\t\tcnt.F=0;\n\t\t\t\tcnt.S={j,i};\n\t\t\t\tREP(k,0,8){//8houi\n\t\t\t\t\tint nx=j+dx[k],ny=i+dy[k];\n\t\t\t\t\tif(!ck(nx,0,8)||!ck(ny,0,8)||field[ny][nx]!=m[!d]) continue;\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tvector<pair<int,int>> tmpch;\n\t\t\t\t\twhile(field[ny][nx]!=m[d]){\n\t\t\t\t\t\tif(field[ny][nx]==m[!d]){\n\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t\ttmpch.push_back({nx,ny});\n\t\t\t\t\t\t\tnx+=dx[k]; ny+=dy[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ck(nx,0,8)||!ck(ny,0,8)||field[ny][nx]=='.'){\n\t\t\t\t\t\t\ttmp=0;\n\t\t\t\t\t\t\ttmpch.clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tcnt.F+=tmp;\n\t\t\t\t\tREP(ii,0,(int)tmpch.size()) change.push_back(tmpch[ii]);\n\t\t\t\t}\n\t\t\t\tif(mx.F<cnt.F){\n\t\t\t\t\tmx=cnt;\n\t\t\t\t\tvt=change;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vt.size()!=0){\n\t\t\tfield[mx.S.S][mx.S.F]=m[d];\n\t\t\tflag1=true;\n\t\t\tlx=min(lx,mx.S.F-1);\n\t\t\trx=max(rx,mx.S.F+1);\n\t\t\tly=min(ly,mx.S.S-1);\n\t\t\try=max(ry,mx.S.S+1);\n\t\t\tlx=max(lx,0);\n\t\t\trx=min(rx,7);\n\t\t\tly=max(ly,0);\n\t\t\try=min(ry,7);\n\n\t\t}else{\n\t\t\tif(!flag1) flag2=false;\n\t\t\telse flag1=false;\n\t\t}\n\t\tREP(l,0,(int)vt.size()){\n\t\t\tfield[vt[l].S][vt[l].F]=m[d];\n\t\t}\n\t\td=!d;\n\t}\n\tREP(l,0,8){\n\t\tREP(n,0,8){\n\t\t\tcout<<field[l][n];\n\t\t}\n\t\tp(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\n\nchar s[10][10];\nint a[10][10];\nint dx[8]={0,1,0,-1,1,1,-1,-1};\nint dy[8]={1,0,-1,0,1,-1,1,-1};\n\n\nint g(int y,int x,int b){\n  int res=0;\n\n  for(int k=0;k<8;k++){\n    int i=y+dy[k],j=x+dx[k];\n    //   if(y==4&&x==4) cout<<b<<' '<<i<<\"  \"<<j<<endl;\n    while(0<=j&&j<8&&0<=i&&i<8&&b*a[i][j]==2){\n      i+=dy[k];\n      j+=dx[k];\n    }\n    if(0<=j&&j<8&&0<=i&&i<8&&b==a[i][j]){\n\n      res+=max(abs(j-x),abs(i-y))-1;\n\n    }\n  }\n\n//  if(x==4&&y==4) cout<<\"         \"<<res<<endl;\n//cout<<x<<\"  \"<<y<<' '<<res<<endl;\nreturn res;\n}\n\n\n\nvoid h(int y,int x,int b){\n//  cout<<y<<' '<<x<<endl;\n  a[y][x]=b;\n  /*\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<a[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  for(int k=0;k<8;k++){\n    int i=y+dy[k],j=x+dx[k];\n    while(0<=j&&j<8&&0<=i&&i<8&&b*a[i][j]==2){\n      i+=dy[k];\n      j+=dx[k];\n    }\n    if(0<=j&&j<8&&0<=i&&i<8&&b==a[i][j]){\n     \n      i=y+dy[k];\n      j=x+dx[k];\n      while(b*a[i][j]==2){\n        a[i][j]=b;\n        i+=dy[k];\n        j+=dx[k];\n      }\n    }\n  }\n /* \n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<<a[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n}\n\nvoid f(){\n\n  int c=0;\n  int flag=2,flag1=2;\n  vector<int> v,w,z;\n  while(flag1){\n     \n    bool hoge=false;\n    v.clear();\n    w.clear();\n    z.clear();\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n    \n        if(a[i][j]!=0) continue;\n        int res=g(i,j,flag);\n        if(res>0){\n          hoge=true;\n          v.push_back(res);\n          w.push_back(i);\n          z.push_back(j);\n        }\n      }\n    }\n    if(hoge){\n//      cout<<v.size()<<endl;\n      int resi=-1,resj=-1,s=0;\n      for(int i=0;i<v.size();i++){\n//        cout<<v[i]<<' '<<w[i]<<' '<<z[i]<<endl;\n        if(flag==2&&s<v[i]){\n          resi=w[i];\n          resj=z[i];\n          s=v[i];\n        }\n\n        if(flag==1&&s<=v[i]){\n          resi=w[i];\n          resj=z[i];\n          s=v[i];\n        }\n\n      }\n//      cout<<resi<<' '<<resj<<' '<<s<<endl;\n      h(resi,resj,flag);\n      flag=(flag==2?1:2);\n\n      flag1=2;\n    }\n    else{\n      flag1--; \n      flag=(flag==2?1:2);\n    }\n  }\n}\n\n\nint main(){\n  for(int i=0;i<8;i++){\n    cin>>s[i];\n    for(int j=0;j<8;j++){\n      if(s[i][j]=='o')\n        a[i][j]=2;\n      else if(s[i][j]=='x')\n        a[i][j]=1;\n      else\n        a[i][j]=0;\n    }\n  }\n\n  f();\n\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      if(a[i][j]==2) s[i][j]='o';\n      if(a[i][j]==1) s[i][j]='x';\n      if(a[i][j]==0) s[i][j]='.';\n    }\n  }\n\n  for(int i=0;i<8;i++){\n    cout<<s[i]<<endl;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nstring s[8], t = \"ox\";\nint MAX, MAXy, MAXx, my, op;\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {1, 0, -1, -1, 1, 1, -1, 0};\n\nbool contain(int y, int x){\n    return (0 <= y && y < 8 && 0 <= x && x < 8);\n}\n\nvoid check(int y, int x, int dg){\n    if(dg == 0 && s[y][x] != '.') return;\n    int cnt = 0;\n    rep(i, 0, 8){\n        int tmp = 0;\n        rep(j, 1, 8){\n            int ny = y + dy[i] * j;\n            int nx = x + dx[i] * j;\n            if(!contain(ny, nx) || s[ny][nx] == '.') break;\n            if(s[ny][nx] == t[op]){\n                // if(dg == 1) s[ny][nx] = t[my];\n                tmp++;\n            }else{\n                if(dg == 1){\n                    rep(k, 1, j + 1){\n                        s[y + dy[i] * k][x + dx[i] * k] = t[my];\n                    }\n                }\n                cnt += tmp;\n                break;\n            }\n        }\n    }\n    if(MAX < cnt){\n        MAX = cnt;\n        MAXy = y;\n        MAXx = x;\n    }\n}\n\nsigned main(){\n    rep(i, 0, 8) cin >> s[i];\n    int g = 0;\n    for(int i = 0;; i++){\n        my = i % 2;\n        op = (i + 1) % 2;\n        MAX = 0; MAXy = 0; MAXx = 0;\n        if(my == 0){\n            rep(j, 0, 8){\n                rep(k, 0, 8){\n                    check(j, k, 0);\n                }\n            }\n        }else{\n            repb(j, 7, 0){\n                repb(k, 7, 0){\n                    check(j, k, 0);\n                }\n            }\n        }\n        if(MAX == 0) g++;\n        else g = 0;\n        if(g == 2) break;\n        if(MAX != 0){\n            s[MAXy][MAXx] = t[my];\n            check(MAXy, MAXx, 1);\n        }\n        // rep(j, 0, 8) cout << s[j] << endl;\n        // cout << endl;\n        \n    }\n    rep(i, 0, 8) cout << s[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility> // pair make_pair\nusing std::pair;\nusing std::make_pair;\n#include <tuple> // tuple(c++11) make_tuple(c++11)\nusing std::tuple; // get<address>(variable)\nusing std::make_tuple;\n#include <string> // string stoi(c++11) stoll(c++11) to_string(c++11)\nusing std::string;\nusing std::stoi;\nusing std::stoll;\nusing std::to_string;\n#include <queue> // queue priority_queue\nusing std::queue;\nusing std::priority_queue;\n#include <stack> // stack\nusing std::stack;\n#include <vector> // vector\nusing std::vector;\n#include <map> // map\nusing std::map;\n#include <set> // set\nusing std::set; // insert erase find count\n#include <algorithm> // min max\nusing std::sort;\nusing std::lower_bound; // iterator,  >=\nusing std::upper_bound; // iterator,  >\nusing std::min;\nusing std::max;\nusing std::min_element; // iterator\nusing std::max_element; // iterator\n#include <complex> // complex\nusing std::complex; // real imag\n#include <iostream> // cin cout\nusing std::cin;\nusing std::cout;\nusing std::endl;\n#include <iomanip> // setprecision fixed(manipulator)\nusing std::setprecision;\nusing std::fixed;\n#include <cmath>\n#include <cstdio>\n\n#define lli long long int\n#define INF (int)1e09\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define EFOR(i, m, n) for (int i = m; i <= n; i++)\n#define RFOR(i, m, n) for (int i = m; i > n; i--)\n#define REFOR(i, m, n) for (int i = m; i >= n; i--)\n#define VSORT(v) sort((v).begin(), (v).end()) // sort vector\ntypedef pair<int, int> PI;\ntypedef tuple<int, int, int> TI;\ntemplate <typename T> using Vec = vector<T>; // c++11\n\nint dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nvoid dump (Vec<Vec<char>>& table) {\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            cout << table[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool change(Vec<Vec<char>>& table, char me, char you) {\n    int ans_i = 0;\n    int ans_j = 0;\n    int ans_cnt = 0;\n\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            if (table[i][j] != '.') {\n                continue;\n            }\n            int cnt = 0;\n            FOR(k, 0, 8) {\n                int now_cnt = 0;\n                int mul = 1;\n                while (1) {\n                    int cy = i + mul * dy[k];\n                    int cx = j + mul * dx[k];\n                    char moji = table[cy][cx];\n                    if (moji == me) {\n                        cnt += now_cnt;\n                        break;\n                    } else if (moji != you) {\n                        break;\n                    } else {\n                        mul++;\n                        now_cnt++;\n                    }\n                }\n            }\n            if (cnt > ans_cnt || (cnt == ans_cnt && me == 'x')) {\n                ans_i = i;\n                ans_j = j;\n                ans_cnt = cnt;\n            }\n        }\n    }\n\n    if (ans_cnt == 0) {\n        return false;\n    } else {\n        table[ans_i][ans_j] = me;\n        FOR(i, 0, 8) {\n            int mul = 1;\n            while (1) {\n                int cy = ans_i + mul * dy[i];\n                int cx = ans_j + mul * dx[i];\n                char moji = table[cy][cx];\n                if (moji == me) {\n                    RFOR(j, mul, 0) {\n                        cy -= dy[i];\n                        cx -= dx[i];\n                        table[cy][cx] = me;\n                    }\n                    break;\n                } else if (moji == you) {\n                    mul++;\n                } else {\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n}\n\nint main(void) {\n    Vec<Vec<char>> table(10, Vec<char>(10, '#'));\n    FOR(i, 1, 9) {\n        FOR(j, 1, 9) {\n            cin >> table[i][j];\n        }\n    }\n\n    bool tomoe_check = true;\n    bool majyo_check = true;\n    //dump(table);\n    //cout << endl;\n    while (1) {\n        tomoe_check = change(table, 'o', 'x');\n        if (tomoe_check == false && majyo_check == false) {\n            break;\n        }\n        //dump(table);\n        //cout << endl;\n        majyo_check = change(table, 'x', 'o');\n        if (tomoe_check == false && majyo_check == false) {\n            break;\n        }\n        //dump(table);\n        //cout << endl;\n    }\n    dump(table);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nvector<string> v(8);\n\nconst int n = 8;\nint dx[8] = {1,1,0,-1,-1,-1, 0, 1};\nint dy[8] = {0,1,1, 1, 0,-1,-1,-1};\n\nbool can(int y,int x) {\n    if(0 <= y && y < n && 0 <= x && x < n) return true;\n    return false;\n}\n\nvector<pair<pair<int,pair<int,int> >,pair<int,pair<int,int> > > > vv;\n\nint res = 0;\n\nint main() {\n    rep(i,n) cin >> v[i];\n\n    int cnt = -1;\n    int check = 0;\n\n    while(true) {\n        vv.clear();\n        cnt++;\n        \n        vector<pair<int,pair<int,int> > > vvv;\n        rep(i,n) {\n            rep(j,n) {\n\n                if(cnt%2 == 0 && v[i][j] == '.') {\n                    res = 0;\n                    rep(k,8) {\n                        int ni = i;\n                        int nj = j;\n                        int s = 0;\n                        \n                        while(can(ni+dy[k],nj+dx[k]) && v[ni+dy[k]][nj+dx[k]] == 'x') {\n                            s++;\n                            ni += dy[k];\n                            nj += dx[k];\n                        }\n                        \n                        int gi = ni + dy[k];\n                        int gj = nj + dx[k];\n\n                        if(can(gi,gj) && v[gi][gj] == 'o') {\n                            res += s;\n                        }\n                    }\n\n                    if(res > 0) {\n                        vvv.push_back(mp(-res,mp(i,j)));\n                    }\n                }\n\n                if(cnt%2 == 1 && v[i][j] == '.') {\n                    res = 0;\n                    rep(k,8) {\n                        int ni = i;\n                        int nj = j;\n                        int s = 0;\n\n                        while(can(ni+dy[k],nj+dx[k]) && v[ni+dy[k]][nj+dx[k]] == 'o') {\n                            s++;\n                            ni += dy[k];\n                            nj += dx[k];\n                        }\n\n                        int gi = ni + dy[k];\n                        int gj = nj + dx[k];\n\n                        if(can(gi,gj) && v[gi][gj] == 'x') {\n                            res += s;\n                        }\n                    }\n\n                    if(res > 0) {\n                        vvv.push_back(mp(-res,mp(-i,-j)));\n                    }\n                }\n            }\n        }\n\n        if(vvv.size() != 0) {\n            sort(vvv.begin(),vvv.end());\n            \n            int i = vvv[0].second.first;\n            int j = vvv[0].second.second;\n            check = 0;\n\n            if(cnt%2 == 0) {\n                rep(k,8) {\n                    int ni = i;\n                    int nj = j;\n                    int len = 0;\n\n                    while(can(ni+dy[k],nj+dx[k]) && v[ni+dy[k]][nj+dx[k]] == 'x') {\n                        len++;\n                        ni += dy[k];\n                        nj += dx[k];\n                    }\n\n                    int gi = ni + dy[k];\n                    int gj = nj + dx[k];\n\n                    if(can(gi,gj) && v[gi][gj] == 'o') {\n                        ni = i;\n                        nj = j;\n\n                        rep(l,len+1) {\n                            v[ni][nj] = 'o';\n                            ni += dy[k];\n                            nj += dx[k];\n                        }\n                    }\n                }\n            }\n            else {\n                i *= -1;\n                j *= -1;\n\n                rep(k,8) {\n                    int ni = i;\n                    int nj = j;\n                    int len = 0;\n\n                    while(can(ni+dy[k],nj+dx[k]) && v[ni+dy[k]][nj+dx[k]] == 'o') {\n                        len++;\n                        ni += dy[k];\n                        nj += dx[k];\n                    }\n\n                    int gi = ni + dy[k];\n                    int gj = nj + dx[k];\n\n                    if(can(gi,gj) && v[gi][gj] == 'x') {\n                        ni = i;\n                        nj = j;\n\n                        rep(l,len+1) {\n                            v[ni][nj] = 'x';\n                            ni += dy[k];\n                            nj += dx[k];\n                        }\n                    }\n                }\n            }\n        }else {\n            check++;\n            if(check == 2) break;\n        }\n    }\n\n    rep(i,8) cout << v[i] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, -1, 0, 1, 1, 1, 0, -1 }; const int dy[] = { 0, -1, -1, -1, 0, 1, 1, 1 };\n\nint main() {\n\tvector<string> cell(8);\n\tREP(i, 8){\n\t\tcin >> cell[i];\n\t}\n\tbool first = true;\n\tint able = 0;\n\twhile (able < 2){\n\t\tint turn_n = 0;\n\t\tint x, y, w;\n\t\tfor (int i = (first ? 0 : 7); 0 <= i&&i < 8;i+=(first?1:-1)){\n\t\t\tfor (int j = (first ? 0 : 7); 0 <= j&&j < 8; j += (first ? 1 : -1)){\n\t\t\t\tif (cell[i][j] == '.'){\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tint w2 = 0;\n\t\t\t\t\tREP(k, 8){\n\t\t\t\t\t\tif (0 <= j + dx[k] && j + dx[k] < 8 && 0 <= i + dy[k] && i + dy[k] < 8 && cell[i + dy[k]][j + dx[k]] != '.'){\n\t\t\t\t\t\t\tint count2 = 0;\n\t\t\t\t\t\t\tint x2 = j + dx[k];\n\t\t\t\t\t\t\tint y2 = i + dy[k];\n\t\t\t\t\t\t\twhile (0 <= y2 && y2 < 8 && 0 <= x2 && x2 < 8){\n\t\t\t\t\t\t\t\tif (cell[y2][x2] == '.')\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tif (first){\n\t\t\t\t\t\t\t\t\tif (cell[y2][x2] == 'o'){\n\t\t\t\t\t\t\t\t\t\tcount += count2;\n\t\t\t\t\t\t\t\t\t\tw2 += 1 << k;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tif (cell[y2][x2] == 'x'){\n\t\t\t\t\t\t\t\t\t\tcount += count2;\n\t\t\t\t\t\t\t\t\t\tw2 += 1 << k;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tx2 += dx[k];\n\t\t\t\t\t\t\t\ty2 += dy[k];\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (count > turn_n){\n\t\t\t\t\t\tturn_n = count;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tw = w2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (turn_n == 0){\n\t\t\table++;\n\t\t}\n\t\telse{\n\t\t\table = 0;\n\t\t\tcell[y][x] = first ? 'o' : 'x';\n\t\t\tREP(i, 8){\n\t\t\t\tif ((w >> i) & 1){\n\t\t\t\t\tint x2 = x+dx[i];\n\t\t\t\t\tint y2 = y + dy[i];\n\t\t\t\t\twhile (0 <= x2 + dx[i] && x2 + dx[i] < 8 && 0 <= y2 + dy[i] && y2 + dy[i] < 8 && cell[y2][x2] == (first ? 'x' : 'o')){\n\t\t\t\t\t\tcell[y2][x2] = first ? 'o' : 'x';\n\t\t\t\t\t\tx2 += dx[i];\n\t\t\t\t\t\ty2 += dy[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfirst = !first;\n\t}\n\tREP(i, 8){\n\t\tcout << cell[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntypedef vector<string> Board;\n\nbool reverse_rec(Board& board, char stone,int x,int y, int dx,int dy) {\n    if(x>7 || y>7) return false;\n    if(x<0 || y<0) return false;\n    if(board[y][x]=='.') return false;\n    if(board[y][x]==stone) return true;\n\n    bool flag = reverse_rec(board, stone, x+dx,y+dy,dx,dy);\n\n    if(flag) {\n        board[y][x]=stone;\n    }\n        \n    return flag;\n}\nint count(Board& board, char stone) {\n    int res=0;\n    rep(i,board.size()) rep(j,board[i].size()) if(board[i][j]==stone) res++;\n    return res;\n}\nvoid plot(Board& board) {\n    rep(i,board.size()) {\n        rep(j,board[i].size()) {\n            cout<<board[i][j];\n        }\n        cout<<endl;\n    }\n\n}\nvoid reverse(Board &board, char stone, int x, int y) {\n    if(board[y][x]!='.') return;\n    for(int dx=-1;dx<=1;dx++) {\n        for(int dy=-1;dy<=1;dy++) {\n            if(!(0<=x+dx&&x+dx<8)) continue;\n            if(!(0<=y+dy&&y+dy<8)) continue;\n            // cout<<dx<<\",\"<<dy<<endl;\n\n            if(board[dy+y][dx+x]!=stone && reverse_rec(board,stone,x+dx,y+dy,dx,dy)) {\n                board[y][x]=stone;\n\n            }\n        }\n    }\n\n}\n\nbool mami(Board &board) {\n    int maxi = count(board, 'o');\n    bool flag = false;\n    Board res = board;\n    rep(i,8) {\n        rep(j,8) {\n            Board tmp = board;\n            reverse(tmp, 'o', j, i);\n            if(maxi < count(tmp,'o')) {\n                maxi = count(tmp,'o');\n                res = tmp;\n                flag = true;\n\n            }\n        }\n    }\n    board = res;\n    return flag;\n}\nbool majo(Board &board) {\n    int maxi = count(board, 'x');\n    bool flag = false;\n    Board res = board;\n    for(int i=7;i>=0;i--) {\n        for(int j=7;j>=0;j--) {\n            Board tmp = board;\n            reverse(tmp, 'x', j, i);\n            if(maxi < count(tmp,'x')) {\n                maxi = count(tmp,'x');\n                res = tmp;\n                flag = true;\n            }\n        }\n    }\n    board = res;\n    return flag;\n}\n\nint main() {\n    Board board;\n    rep(i,8) {\n        string str;\n        cin>>str;\n        board.pb(str);\n    }\n\n    while(1) {\n        bool f = mami(board);\n        f |= majo(board);\n        if(!f) {\n            plot(board);\n            break;\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst char cs[] = \"xo\";\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < 8 && 0 <= y && y < 8;\n}\n\nstruct state {\n    vi score;\n    vs g;\n    state(){}\n};\n\nstate flip(const int x, const int y, state s, bool turn){\n    bool update = false;\n    for (size_t i = 0; i < 8; i++){\n        int cx = x + dx[i];\n        int cy = y + dy[i];\n        while (valid(cx, cy) && s.g[cy][cx] == cs[1 - turn]){\n            cx += dx[i];\n            cy += dy[i];\n        }\n        if (valid(cx, cy) && s.g[cy][cx] == cs[turn]){\n            update = true;\n            for (int ix = x + dx[i], iy = y + dy[i];\n                !(ix == cx && iy == cy);\n                ix += dx[i], iy += dy[i]){\n                s.g[iy][ix] = cs[turn];\n                s.score[turn]++;\n                s.score[1 - turn]--;\n            }\n        }\n    }\n    if (update){\n        s.g[y][x] = cs[turn];\n    }\n    return s;\n}\n\nint main()\n{\n    state cur;\n    cur.score = vector < int > {0, 0};\n    for (size_t i = 0; i < 8; i++){\n        string s; cin >> s;\n        cur.g.push_back(s);\n        cur.score[0] += count(s.begin(), s.end(), 'x');\n        cur.score[1] += count(s.begin(), s.end(), 'o');\n    }\n\n    for (size_t turn = 1; turn <= 64; turn++){\n        bool ok = false;\n        state next = cur;\n        for (size_t y = 0; y < 8; y++){\n            for (size_t x = 0; x < 8; x++){\n                if (cur.g[y][x] == '.'){\n                    state cand = flip(x, y, cur, turn & 1);\n                    if (((turn & 1) == 1 && next.score[1] < cand.score[1]) ||\n                        ((turn & 1) == 0 && next.score[0] <= cand.score[0])){\n                        ok = true;\n                        next = cand;\n                    }\n                }\n            }\n        }\n\n        cur = next;\n    }\n\n    for (size_t i = 0; i < 8; i++){\n        cout << cur.g[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<sstream>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int x,y;\n  P(int x=0,int y =0):x(x),y(y){}\n};\nstring G[8];\nint dx[] = {0,1,0,-1,1,1,-1,-1};\nint dy[] = {1,0,-1,0,1,-1,1,-1};\n\nint getValue(int x,int y,const bool phase)\n{\n  int cnt = 0;\n  rep(i,8)\n    {\n      int nx = x;\n      int ny = y;\n      int dirCost = 0;\n      while(true)\n\t{\n\t  nx += dx[i];\n\t  ny += dy[i];\n\t  if(!(0 <= nx && nx < 8 && 0 <= ny && ny < 8))\n\t    {\n\t      dirCost = 0; \n\t      break;\n\t    }\n\t  if(!phase)\n\t    {\n\t      if(G[ny][nx] == 'o')break;\n\t      if(G[ny][nx] == '.')\n\t\t{\n\t\t  dirCost = 0;\n\t\t  break;\n\t\t}\n\t      if(G[ny][nx] == 'x')dirCost++;\t      \n\t    }\n\n\t  if(phase)\n\t    {\n\t      if(G[ny][nx] == 'x')break;\n\t      if(G[ny][nx] == '.')\n\t\t{\n\t\t  dirCost = 0;\n\t\t  break;\n\t\t}\n\t      if(G[ny][nx] == 'o')dirCost++;\t      \n\t    }\n\t}\n      cnt += dirCost;\n    }\n  return cnt;\n}\n\nbool draw(P p,const bool phase,const int dir)\n{\n  if(!(0 <= p.x && p.x < 8 && 0 <= p.y && p.y < 8))return false;\n  if(G[p.y][p.x] == '.')return false;\n  if(phase && G[p.y][p.x] == 'x')return true;\n  else if(!phase && G[p.y][p.x] == 'o')return true;\n  bool res;\n  if(res = draw(P(p.x+dx[dir],p.y+dy[dir]),phase,dir))G[p.y][p.x] = (phase?'x':'o');\n  return res;\n}\n\nvoid print()\n{\n  rep(i,8)cout << G[i] << endl;\n}\n\nint main()\n{\n  bool phase = false;\n  bool passM,passW;\n  int maxCostM,maxCostW;\n  rep(i,8)\n    cin >> G[i];\n\n  while(true)\n    {\n      passM = passW = false;\n      maxCostM = maxCostW = 0;\n      P M,W;\n      phase = false;\n\n      rep(i,8)\n\t{\n\t  rep(j,8)\n\t    {\n\t      if(G[i][j] != '.')continue;\n\t      int v = getValue(j,i,phase); \n\t      if(v > maxCostM)\n\t\t{\n\t\t  M = P(j,i);\n\t\t  maxCostM = v;\n\t\t}\n\t    }\n\t}\n\n      if(!maxCostM)passM = true;\n      else \n\t{\n\t  G[M.y][M.x] = 'o';\n\t  rep(k,8)draw(P(M.x+dx[k],M.y+dy[k]),phase,k);\n\t}\n\n      //cout << \"MaMi\" << endl;\n      //print();\n\n      phase = !phase;\t\n\n      for(int i=7;i>=0;i--)\n\t{\n\t  for(int j=7;j>=0;j--)\n\t    {\n\t      if(G[i][j] != '.')continue;\n\t      int v = getValue(j,i,phase); \n\t      if(v > maxCostW)\n\t\t{\n\t\t  W = P(j,i);\n\t\t  maxCostW = v;\n\t\t}\n\t    }\n\t}\n\n      if(!maxCostW)passW = true;\n      else \n\t{\n\t  G[W.y][W.x] = 'x';\n\t  rep(k,8)draw(P(W.x+dx[k],W.y+dy[k]),phase,k);\n\t}\n\n      if(passW & passM)break;\n      //cout << \"WitCh\" << endl;\n      //print();\n    }\n\n  print();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> Point;\ntypedef pair<int, Point> Point2;\n\nchar field[10][10];\nchar now;\n\nvoid output(){\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid Change(Point2 p){\n  int x = p.s.f, y = p.s.s;\n  bool hassame = false;\n  int cnt = 0;\n  \n  if(field[y-1][x] != '.' && field[y-1][x] != now){\n    for(int i = y-1 ; i >= 0 ; i--){\n      if(field[i][x] == '.') break;\n      if(field[i][x] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][x] != '.' && field[i][x] != now) cnt++;\n    }\n  }\n  if(hassame){\n    for(int i = y-1 ; i >= 0 && cnt >= 0; i--, cnt--){\n      field[i][x] = now;\n    }\n  }\n  hassame = false;\n  cnt = 0;  \n  \n  if(field[y+1][x] != '.' && field[y+1][x] != now){\n    for(int i = y+1 ; i < 8 ; i++){\n      if(field[i][x] == '.') break;\n      if(field[i][x] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][x] != '.' && field[i][x] != now) cnt++;\n    }\n  }\n  if(hassame){\n    for(int i = y+1 ; i < 8 && cnt >= 0 ; i++, cnt--){\n      field[i][x] = now;\n    }\n  }\n  hassame = false;\n  cnt = 0;   \n  \n  if(field[y][x-1] != '.' && field[y][x-1] != now){\n    for(int j = x-1 ; j >= 0 ; j--){\n      if(field[y][j] == '.') break;\n      if(field[y][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[y][j] != '.' && field[y][j] != now) cnt++;    \n    }\n  }\n  if(hassame){\n    for(int j = x-1 ; j >= 0 && cnt >= 0; j--, cnt--){\n      field[y][j] = now;\n    }\n  }\n      \n  hassame = false;\n  cnt = 0;\n  \n  if(field[y][x+1] != '.' && field[y][x+1] != now){\n    for(int j = x+1 ; j < 8 ; j++){\n      if(field[y][j] == '.') break;\n      if(field[y][j] == now){\n\thassame = true;\n\tbreak;\n      }   \n      if(field[y][j] != '.' && field[y][j] != now) cnt++;    \n    }\n  }\n  if(hassame){\n    for(int j = x+1 ; j < 8 && cnt >= 0; j++, cnt--){\n      field[y][j] = now;\n    }\n  }\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y-1][x+1] != '.' && field[y-1][x+1] != now){\n    for(int i = y-1, j = x+1 ; i >= 0 && j < 8 ; i--, j++){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame){\n    for(int i = y-1, j = x+1 ; i >= 0 && j < 8 && cnt >= 0 ; i--, j++, cnt--){\n      field[i][j] = now;\n    }\n  }\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y+1][x+1] != '.' && field[y+1][x+1] != now){\n    for(int i = y+1, j = x+1 ; i < 8 && j < 8 ; i++, j++){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame){\n    for(int i = y+1, j = x+1 ; i < 8 && j < 8 && cnt >= 0 ; i++, j++, cnt--){\n\tfield[i][j] = now;\n      }\n\t  }\n    hassame = false;\n  cnt = 0;\n  \n  if(field[y+1][x-1] != '.' && field[y+1][x-1] != now){\n    for(int i = y+1, j = x-1 ; i < 8 && j >= 0 ; i++, j--){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame){\n    for(int i = y+1, j = x-1 ; i < 8 && j >= 0 && cnt >= 0; i++, j--, cnt--){\n      field[i][j] = now;\n    }\n  }\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y-1][x-1] != '.' && field[y-1][x-1] != now){\n    for(int i = y-1, j = x-1 ; i >= 0 && j >= 0 ; i--, j--){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame){\n    for(int i = y-1, j = x-1 ; i >= 0 && j >= 0 && cnt >= 0; i--, j--, cnt--){\n      field[i][j] = now;\n    }\n  }\n  hassame = false;\n  cnt = 0;\n}\n\n\n\n\n\nint countDiffCookie(Point p){\n  int x = p.f, y = p.s;\n  int ret = 0, cnt = 0;\n  bool hassame = false;\n  \n  if(field[y-1][x] != '.' && field[y-1][x] != now){\n    for(int i = y-1 ; i >= 0 ; i--){\n      if(field[i][x] == '.') break;\n      if(field[i][x] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][x] != '.' && field[i][x] != now) cnt++;\n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;  \n  \n  if(field[y+1][x] != '.' && field[y+1][x] != now){\n    for(int i = y+1 ; i < 8 ; i++){\n      if(field[i][x] == '.') break;\n      if(field[i][x] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][x] != '.' && field[i][x] != now) cnt++;\n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;   \n  \n  if(field[y][x-1] != '.' && field[y][x-1] != now){\n    for(int j = x-1 ; j >= 0 ; j--){\n      if(field[y][j] == '.') break;\n      if(field[y][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[y][j] != '.' && field[y][j] != now) cnt++;    \n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y][x+1] != '.' && field[y][x+1] != now){\n    for(int j = x+1 ; j < 8 ; j++){\n      if(field[y][j] == '.') break;\n      if(field[y][j] == now){\n\thassame = true;\n\tbreak;\n      }   \n      if(field[y][j] != '.' && field[y][j] != now) cnt++;    \n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y-1][x+1] != '.' && field[y-1][x+1] != now){\n    for(int i = y-1, j = x+1 ; i >= 0 && j < 8 ; i--, j++){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y+1][x+1] != '.' && field[y+1][x+1] != now){\n    for(int i = y+1, j = x+1 ; i < 8 && j < 8 ; i++, j++){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y+1][x-1] != '.' && field[y+1][x-1] != now){\n    for(int i = y+1, j = x-1 ; i < 8 && j >= 0 ; i++, j--){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;\n  \n  if(field[y-1][x-1] != '.' && field[y-1][x-1] != now){\n    for(int i = y-1, j = x-1 ; i >= 0 && j >= 0 ; i--, j--){\n      if(field[i][j] == '.') break;\n      if(field[i][j] == now){\n\thassame = true;\n\tbreak;\n      }\n      if(field[i][j] != '.' && field[i][j] != now) cnt++;\n    }\n  }\n  if(hassame) ret += cnt;\n  hassame = false;\n  cnt = 0;  \n  return ret;\n}  \n\nint main(){\n  for(int i = 0 ; i < 8 ; i++){\n    cin >> field[i];\n  }\n  \n  int M = 64;\n  for(int i = 0 ; i < 8 ; i++)\n    for(int j = 0 ; j < 8 ; j++) if(field[i][j] != '.') M--;\n  \n  bool Mami = false, Witch = false;\n  \n  for(int n = 0 ; M >= 0; n++){\n    //output();\n    bool pass = true;\n    now = n%2 ? 'x' : 'o';\n    Point2 decide = Point2(0,Point(-1,-1));\n    for(int i = 0 ; i < 8 ; i++){\n      for(int j = 0 ; j < 8 ; j++){\n\tif(field[i][j] == '.'){\n\t  int c = countDiffCookie(Point(j, i));\n\t  if(now == 'o'){\n\t    if(c != 0 && c > decide.f){\n\t      decide.f = c;\n\t      decide.s.f = j, decide.s.s = i;\n\t      pass = false;\n\t      Mami = false;\n\t    }\n\t  }\n\t  else{\n\t    if(c != 0 && c >= decide.f){\n\t      decide.f = c;\n\t      decide.s.f = j, decide.s.s = i;\n\t      pass = false;\n\t      Witch = false;\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(pass){\n      if(n%2) Witch = true;\n      else Mami = true;\n    }\n    else{\n      M--;\n      Change(decide);\n    }\n    if(Mami && Witch) goto END;\n    field[decide.s.s][decide.s.f] = now;\n  }\n  \n END:;\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0,-1,1,1,-1}, dy[] = {0,1,0,-1,-1,-1,1,1};\n\nint _flip(vvc& field, bool turn, int x, int y, int d) {\n    char cookie = turn ? 'o' : 'x';\n    char other_cookie = !turn ? 'o' : 'x';\n    if (0 <= x && x < 8 && 0 <= y && y < 8 && field[y][x] != '.') {\n        if (field[y][x] == other_cookie) {\n            int cnt = _flip(field, turn, x+dx[d], y+dy[d], d);\n            if (cnt == -1) {\n                return -1;\n            }\n            field[y][x] = cookie;\n            return cnt+1;\n        } else {\n            return 0;\n        }\n    }\n    return -1;\n}\n\nbool flip(vvc& field, bool turn) {\n    int ma = 0;\n    int X = -1, Y = -1;\n    char cookie = turn ? 'o' : 'x';\n    char other_cookie = !turn ? 'o' : 'x';\n    if (turn) {\n        REP(y, 8) REP(x, 8) {\n            if (field[y][x] != '.') continue;\n            bool ok = false;\n            REP(i, 8) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == other_cookie) {\n                    ok = true;\n                }\n            }\n            if (ok) {\n                vvc _field = field;\n                int cnt = 0;\n                REP(i, 8) {\n                    int sx = x + dx[i], sy = y + dy[i];\n                    cnt += max(0, _flip(_field, turn, sx, sy, i));\n                }\n                if (ma < cnt) {\n                    ma = cnt;\n                    X = x;\n                    Y = y;\n                }\n            }\n        }\n    } else {\n        RREP(y, 8) RREP(x, 8) {\n            if (field[y][x] != '.') continue;\n            bool ok = false;\n            REP(i, 8) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (0 <= sx && sx < 8 && 0 <= sy && sy < 8 && field[sy][sx] == other_cookie) {\n                    ok = true;\n                }\n            }\n            if (ok) {\n                vvc _field = field;\n                int cnt = 0;\n                REP(i, 8) {\n                    int sx = x + dx[i], sy = y + dy[i];\n                    cnt += max(0, _flip(_field, turn, sx, sy, i));\n                }\n                if (ma < cnt) {\n                    ma = cnt;\n                    X = x;\n                    Y = y;\n                }\n            }\n        }\n    }\n    if (X == -1) return false;\n    field[Y][X] = cookie;\n    REP(i, 8) {\n        int sx = X + dx[i], sy = Y + dy[i];\n        _flip(field, turn, sx, sy, i);\n    }\n    return true;\n}\n\nint main() {\n    vvc field(8, vc(8));\n    REP(y, 8) REP(x, 8) cin >> field[y][x];\n\n    bool turn = true;\n    bool passed = false;\n    while (1) {\n        if (!flip(field, turn)) {\n            if (passed) break;\n            passed = true;\n        } else {\n            passed = false;\n        }\n        turn = !turn;\n    }\n    REP(y, 8) {\n        REP(x, 8) {\n            printf(\"%c\", field[y][x]);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\n//int dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n }; */\n\n\n/** Problem2311 : Dessert Witch **/\nenum {\n\tWHITE = 0,\n\tBLACK,\n\tNONE,\n};\n\nint board[8][8];\nint board_tmp[8][8];\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nvoid print_board()\n{\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (board[j][i] == WHITE) cout << \"o\";\n\t\t\telse if (board[j][i] == BLACK) cout << \"x\";\n\t\t\telse cout << \".\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nbool range_valid(int x, int y)\n{\n\tif (x < 0 || 8 <= x || y < 0 || 8 <= y) return false;\n\treturn true;\n}\n\nbool can_reverse(int x, int y, int d, int turn)\n{\n\tif (!range_valid(x, y) || board[x][y] == NONE) return false;\n\tif (board[x][y] == turn) return true;\n\t\n\treturn can_reverse(x+dx[d], y+dy[d], d, turn);\n}\n\nvoid do_reverse(int x, int y, int d, int turn)\n{\n\tif (board[x][y] == turn) return;\n\tboard[x][y] = turn;\n\tdo_reverse(x+dx[d], y+dy[d], d, turn);\n}\n\nbool can_put(int x, int y, int turn)\n{\n\tif (board[x][y] != NONE) return false;\n\t\n\tfor (int i=0; i<8; i++) {\n\t\tint nx = x+dx[i], ny=y+dy[i];\n\t\tif (board[nx][ny] == 1-turn && can_reverse(x+dx[i], y+dy[i], i, turn)) return true;\n\t}\n\treturn false;\n}\n\nbool can_put_all(int turn)\n{\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (can_put(j, i, turn)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool gameover()\n{\n\treturn !can_put_all(WHITE) && !can_put_all(BLACK);\n}\n\nPII count_stone()\n{\n\tPII res = PII(0, 0);\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tif (board[i][j] == WHITE) res.first++;\n\t\t\telse if (board[i][j] == BLACK) res.second++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint turn=WHITE;\n\t\n\tfor (int i=0; i<8; i++) {\n\t\tfor (int j=0; j<8; j++) {\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif (c=='.')\t\t board[j][i] = NONE;\n\t\t\telse if (c=='o') board[j][i] = WHITE;\n\t\t\telse\t\t\t board[j][i] = BLACK;\n\t\t}\n\t}\n\t\n\twhile (true) {\n\t\tif (!can_put_all(turn)) {\n\t\t\tturn = 1-turn;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint target_x = -1, target_y = -1, cnt_max=0;\n\t\t\n\t\tfor (int y=0; y<8; y++) {\n\t\t\tfor (int x=0; x<8; x++) {\n\t\t\t\tif (board[x][y] != NONE) continue;\n\t\t\t\t\n\t\t\t\tmemcpy(board_tmp, board, sizeof(board));\n\t\t\t\t\n\t\t\t\tbool ok=false;\n\t\t\t\tfor (int i=0; i<8; i++) {\n\t\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\t\tif (board[nx][ny] != 1-turn) continue;\n\t\t\t\t\t\n\t\t\t\t\tif (can_reverse(nx, ny, i, turn)) {\n\t\t\t\t\t\tdo_reverse(nx, ny, i, turn);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ok) {\n\t\t\t\t\tboard[x][y] = turn;\n\t\t\t\t\tPII cnt = count_stone();\n\t\t\t\t\t\n\t\t\t\t\tif (turn == WHITE) {\n\t\t\t\t\t\tif (cnt_max < cnt.first) {\n\t\t\t\t\t\t\ttarget_x = x;\n\t\t\t\t\t\t\ttarget_y = y;\n\t\t\t\t\t\t\tcnt_max = cnt.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cnt_max <= cnt.second) {\n\t\t\t\t\t\t\ttarget_x = x;\n\t\t\t\t\t\t\ttarget_y = y;\n\t\t\t\t\t\t\tcnt_max = cnt.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmemcpy(board, board_tmp, sizeof(board));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<8; i++) {\n\t\t\tint nx = target_x+dx[i], ny = target_y+dy[i];\n\t\t\tif (board[nx][ny] != 1-turn) continue;\n\t\t\t\n\t\t\tif (can_reverse(nx, ny, i, turn)) {\n\t\t\t\tdo_reverse(nx, ny, i, turn);\n\t\t\t}\n\t\t}\n\t\tboard[target_x][target_y] = turn;\n\t\tturn = 1-turn;\n\t\t\n\t\tif (gameover()) {\n\t\t\tprint_board();\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n//変数\nconst int siz = 8;\nvector<string> s(siz);\n\n\n\n\n\n\n//サブ関数\n//入力\nvoid input()\n{\n\tREP(i, siz) {\n\t\tcin >> s[i];\n\t}\n}\n\nbool isOut(int h, int w)\n{\n\tif (h < 0 || w < 0)return true;\n\tif (7 < h || 7 < w)return true;\n\treturn false;\n}\n\nint evaluate(bool mami, int h, int w)\n{\n\tchar me = (mami ? 'o' : 'x');\n\tif (s[h][w] != '.')return 0;\n\n\tint sumValue = 0;\n\tint dy[8] = { -1,-1,-1,0,1,1,1,0 };\n\tint dx[8] = { -1,0,1,1,1,0,-1,-1 };\n\tREP(dir, 8) {\n\t\tint y = h;\n\t\tint x = w;\n\t\tint value = 0;\n\t\twhile (true) {\n\t\t\ty += dy[dir];\n\t\t\tx += dx[dir];\n\t\t\tif (isOut(y, x))break;\n\t\t\tif (s[y][x] == '.') break;\n\n\t\t\tif (s[y][x] != me)value++;\n\t\t\telse {\n\t\t\t\tsumValue += value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sumValue;\n}\n\nvoid put_cookie(bool mami, int h, int w)\n{\n\tchar me = (mami ? 'o' : 'x');\n\n\tint dy[8] = { -1,-1,-1,0,1,1,1,0 };\n\tint dx[8] = { -1,0,1,1,1,0,-1,-1 };\n\tREP(dir, 8) {\n\t\tint y = h;\n\t\tint x = w;\n\t\tbool change = false;\n\n\t\twhile (true) {\n\t\t\ty += dy[dir];\n\t\t\tx += dx[dir];\n\t\t\tif (isOut(y, x))break;\n\t\t\tif (s[y][x] == '.') break;\n\t\t\tif (s[y][x] == me) {\n\t\t\t\tchange = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (change) {\n\t\t\ty = h;\n\t\t\tx = w;\n\t\t\tdo {\n\t\t\t\ts[y][x] = me;\n\t\t\t\ty += dy[dir];\n\t\t\t\tx += dx[dir];\n\t\t\t} while (s[y][x] != me);\n\t\t}\n\t}\n}\n\nbool search(bool mami)\n{\n\tint maxH = 0;\n\tint maxW = 0;\n\tint maxV = 0;\n\tREP(i, siz)REP(j, siz) {\n\t\tint tmpV = evaluate(mami, i, j);\n\t\tif (mami) {\n\t\t\tif (maxV < tmpV) {\n\t\t\t\tmaxH = i;\n\t\t\t\tmaxW = j;\n\t\t\t\tmaxV = tmpV;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (maxV <= tmpV) {\n\t\t\t\tmaxH = i;\n\t\t\t\tmaxW = j;\n\t\t\t\tmaxV = tmpV;\n\t\t\t}\n\t\t}\n\t}\n\tif (maxV) {\n\t\tput_cookie(mami, maxH, maxW);\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n//計算\nvoid calc()\n{\n\tbool mami = true;\n\tint cnt = 0;\n\twhile (cnt < 2) {\n\t\tif (search(mami))cnt = 0;\n\t\telse cnt++;\n\n\t\tmami = !mami;\n\t}\n\n}\n\n\n//出力\nvoid output()\n{\n\t//cerr << endl << endl;\n\tfor (auto row : s) {\n\t\tcout << row << endl;\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tinput();\n\tcalc();\n\toutput();\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nchar board[8][8];\n\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\n\nint mami_dfs(int x,int y,int cnt,int idx){\n  int nx=x+dx[idx],ny=y+dy[idx];\n  if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n    cnt++;\n    return mami_dfs(nx,ny,cnt,idx);\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n    return cnt;\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n    return 0;\n  }\n  return 0;\n}\n\nint magi_dfs(int x,int y,int cnt,int idx){\n  int nx=x+dx[idx],ny=y+dy[idx];\n  if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='o'){\n    cnt++;\n    return magi_dfs(nx,ny,cnt,idx);\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='x'){\n    return cnt;\n  }\n  else if(0<=nx && nx<=7 && 0<=ny &&ny<=7 && board[nx][ny]=='.'){\n    return 0;\n  }\n  return 0;\n}\n\nint mami_count(int x,int y){//(x,y)??????????????¨?????????????????°\n  int res=0;\n  for(int i=0;i<8;i++) res+=mami_dfs(x,y,0,i);\n  return res;\n}\n\nint magi_count(int x,int y){//(x,y)??????????????¨?????????????????°\n  int res=0;\n  for(int i=0;i<8;i++) res+=magi_dfs(x,y,0,i);\n  return res;\n}\n\nint mami_solve(){//???????????????????????¶???\n  int ma=-1,x,y;\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++){\n    if(board[i][j]=='.' && mami_count(i,j)>ma){\n      ma=mami_count(i,j);\n      x=i;y=j;\n    }\n  }//?????§?????????????????´???\n  if(ma<1) return false;\n  board[x][y]='o';\n  for(int i=0;i<8;i++){\n    int tmp=mami_dfs(x,y,0,i);\n    for(int j=1;j<=tmp;j++){\n      board[x+dx[i]*j][y+dy[i]*j]='o';\n    }\n  }\n  return true;\n}\n\nbool magi_solve(){//???????????????????????¶???\n  int ma=-1,x,y;\n  for(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n    if(board[i][j]=='.'&&magi_count(i,j)>ma){\n      ma=magi_count(i,j);\n      x=i;y=j;\n    }\n  }//?????§?????????????????´???\n  if(ma<1) return false;\n  board[x][y]='x';\n  for(int i=0;i<8;i++){\n    int tmp=magi_dfs(x,y,0,i);\n    for(int j=1;j<=tmp;j++){\n      board[x+dx[i]*j][y+dy[i]*j]='x';\n    }\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  for(int i=0;i<8;i++)for(int j=0;j<8;j++) cin>> board[i][j];\n  bool mami_flag=true,magi_flag=true;\n  while(mami_flag || magi_flag){\n    mami_flag=mami_solve();\n    magi_flag=magi_solve();\n  //  cout<<mami_flag<<\" \"<<magi_flag<<endl;\n  }\n  for(int i=0;i<8;i++){\n    for(int j=0;j<8;j++){\n      cout<< board[i][j];\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <typeinfo>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <map>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint a[8][8]={};\nint x[8]={1,1,1,0,0,-1,-1,-1};\nint y[8]={1,0,-1,1,-1,1,0,-1};\n\nint count(int X,int Y,int p){\n\tint ans(0);\n\tif(a[X][Y]!=0){return 0;}\n\telse\n\t{\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tint q(0);\n\t\t\tfor(int j=1;j<8;j++)\n\t\t\t{\n\t\t\t\tif(X+j*x[i]>7||X+j*x[i]<0||Y+j*y[i]>7||Y+j*y[i]<0){break;}\n\t\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==p){ans+=q;break;}\n\t\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==3-p){q++;}\n\t\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==0){break;}\n\t\t\t}\n\t\t}\n\treturn ans;\n\t}\n}\n\nvoid replace(int X,int Y,int p)\n{\n\ta[X][Y]=p;\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tfor(int j=1;j<8;j++)\n\t\t{\n\t\t\tif(X+j*x[i]>7||X+j*x[i]<0||Y+j*y[i]>7||Y+j*y[i]<0){break;}\n\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==0){break;}\n\t\t\telse if(a[X+j*x[i]][Y+j*y[i]]==p)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\t{\n\t\t\t\t\ta[X+k*x[i]][Y+k*y[i]]=p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() \n{\n\tREP(i,8){\n\t\tstring s;cin>>s;\n\t\tREP(j,8){\n\t\t\tif(s[j]=='o')a[j][i]=1;\n\t\t\telse if(s[j]=='x')a[j][i]=2;\n\t\t}\n\t}\n\t\n\tfor(;;)\n\t{\n\t\tbool flag1(false),flag2(false);\n\t\t\n\t\tint ans1(0),x1(0),y1(0);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(ans1<count(j,i,1)){\n\t\t\t\t\tans1=count(j,i,1);\n\t\t\t\t\tx1=j,y1=i;\n\t\t}}}\n\t\tif(ans1>0){\n\t\t\treplace(x1,y1,1);\n\t\t}else{\n\t\t\tflag1=true;\n\t\t}\n\t\t\n\t\tint ans2(0),x2(0),y2(0);\n\t\tfor(int i=7;i>-1;i--){\n\t\t\tfor(int j=7;j>-1;j--){\n\t\t\t\tif(ans2<count(j,i,2)){\n\t\t\t\t\tans2=count(j,i,2);\n\t\t\t\t\tx2=j,y2=i;\n\t\t}}}\n\t\tif(ans2>0){\n\t\t\treplace(x2,y2,2);\n\t\t}else{\n\t\t\tflag2=true;\n\t\t}\n\t\t\n\t\tif(flag1&&flag2)break;\n\t}\n\t\n\tREP(i,8)\n\t{\n\t\tREP(j,8)\n\t\t{\n\t\t\tif(a[j][i]==0)cout<<'.';\n\t\t\telse if(a[j][i]==1)cout<<'o';\n\t\t\telse if(a[j][i]==2)cout<<'x';\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////////////////////\n\nconst vector<int> dy = {-1,-1,-1,0,0,1,1,1};\nconst vector<int> dx = {-1,0,1,-1,1,-1,0,1};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr); //入出力高速化\n    vector<vector<char>> S(10, vector<char>(10,'#'));\n    rep(i,8) rep(j,8) cin >> S[i+1][j+1];\n    int q = 0;\n    while (q < 1000) {\n        if (q % 2 == 0) {\n            int count,fy,fx;\n            count = fy = fx = 0;\n            for (int i = 1; i <= 8; i++) {\n                for (int j = 1; j <= 8; j++) {\n                    if (S[i][j] != '.') continue;\n                    int z = 0;\n                    rep(k,8) {\n                        int y = i;\n                        int x = j;\n                        int p = 0;\n                        while (S[y+dy[k]][x+dx[k]] == 'x') {\n                            p++;\n                            y += dy[k];\n                            x += dx[k];\n                        }\n                        if (S[y+dy[k]][x+dx[k]] == 'o') {\n                            z += p;\n                        }\n                    }\n                    if(chmax(count,z)) {\n                        fy = i;\n                        fx = j;\n                    }\n                }\n            }\n            if (count == 0) {\n\t\t\t\tq++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tS[fy][fx] = 'o';\n                rep(k,8) {\n                    int y = fy;\n                    int x = fx;\n                    int p = 0;\n                    while (S[y+dy[k]][x+dx[k]] == 'x') {\n                        S[y+dy[k]][x+dx[k]] = 'o';\n                        y += dy[k];\n                        x += dx[k];\n                        p++;\n                    }\n                    if (S[y+dy[k]][x+dx[k]] != 'o') {\n                        rep(i,p) {\n                            S[y][x] = 'x';\n                            y -= dy[k];\n                            x -= dx[k];\n                        }\n                    }\n                }\n            }\n        } else {\n            int count,fy,fx;\n            count = fy = fx = 0;\n            for (int i = 8; i >= 1; i--) {\n                for (int j = 8; j >= 1; j--) {\n                    if (S[i][j] != '.') continue;\n                    int z = 0;\n                    rep(k,8) {\n                        int y = i;\n                        int x = j;\n                        int p = 0;\n                        while (S[y+dy[k]][x+dx[k]] == 'o') {\n                            p++;\n                            y += dy[k];\n                            x += dx[k];\n                        }\n                        if (S[y+dy[k]][x+dx[k]] == 'x') z += p;\n                    }\n                    if(chmax(count,z)) {\n                        fy = i;\n                        fx = j;\n                    }\n                }\n            }\n            if (count == 0) {\n\t\t\t\tq++;\n\t\t\t\tcontinue;\n\t\t\t}\n            else {\n\t\t\t\tS[fy][fx] = 'x';\n                rep(k,8) {\n                    int y = fy;\n                    int x = fx;\n                    int p = 0;\n                    while (S[y+dy[k]][x+dx[k]] == 'o') {\n                        S[y+dy[k]][x+dx[k]] = 'x';\n                        p++;\n                        y += dy[k];\n                        x += dx[k];\n                    }\n                    if (S[y+dy[k]][x+dx[k]] != 'x') {\n                        rep(i,p) {\n                            S[y][x] = 'o';\n                            y -= dy[k];\n                            x -= dx[k];\n                        }\n                    }\n                }\n            }\n        }\n        q++;\n    }\n\n  rep(i,8) {\n    rep(j,8) cout << S[i+1][j+1];\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring s[8];\nint dx[]={0,1,0,-1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\nmain()\n{\n\tfor(int i=0;i<8;i++)cin>>s[i];\n\tint f=1;\n\twhile(f)\n\t{\n\t\tf=0;\n\t\tint mcnt=0,mini=-1,minj=-1;\n\t\tfor(int i=0;i<8;i++)for(int j=0;j<8;j++)\n\t\t{\n\t\t\tif(s[i][j]!='.')continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int r=0;r<8;r++)\n\t\t\t{\n\t\t\t\tint nowcnt=0;\n\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\twhile(x>=0&&x<8&&y>=0&&y<8&&s[x][y]=='x')\n\t\t\t\t\tnowcnt++,x+=dx[r],y+=dy[r];\n\t\t\t\tif(x>=0&&y>=0&&x<8&&y<8&&s[x][y]=='o')cnt+=nowcnt;\n\t\t\t}\n\t\t\tif(mcnt<cnt)\n\t\t\t{\n\t\t\t\tmcnt=cnt;\n\t\t\t\tmini=i,minj=j;\n\t\t\t}\n\t\t}\n\t\tif(mcnt)\n\t\t{\n\t\t\tint i=mini,j=minj;f++;\n\t\t\ts[i][j]='o';\n\t\t\tfor(int r=0;r<8;r++)\n\t\t\t{\n\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\twhile(x>=0&&x<8&&y>=0&&y<8&&s[x][y]=='x')\n\t\t\t\t\tx+=dx[r],y+=dy[r];\n\t\t\t\tif(x>=0&&y>=0&&x<8&&y<8&&s[x][y]=='o')\n\t\t\t\t{\n\t\t\t\t\tx=i+dx[r],y=j+dy[r];\n\t\t\t\t\twhile(x>=0&&x<8&&y>=0&&y<8&&s[x][y]=='x')\n\t\t\t\t\t\ts[x][y]='o',x+=dx[r],y+=dy[r];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmcnt=0,mini=-1,minj=-1;\n\t\tfor(int i=8;i--;)for(int j=8;j--;)\n\t\t{\n\t\t\tif(s[i][j]!='.')continue;\n\t\t\tint cnt=0;\n\t\t\tfor(int r=0;r<8;r++)\n\t\t\t{\n\t\t\t\tint nowcnt=0;\n\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\twhile(x>=0&&x<8&&y>=0&&y<8&&s[x][y]=='o')\n\t\t\t\t\tnowcnt++,x+=dx[r],y+=dy[r];\n\t\t\t\tif(x>=0&&y>=0&&x<8&&y<8&&s[x][y]=='x')cnt+=nowcnt;\n\t\t\t}\n\t\t\tif(mcnt<cnt)\n\t\t\t{\n\t\t\t\tmcnt=cnt;\n\t\t\t\tmini=i,minj=j;\n\t\t\t}\n\t\t}\n\t\tif(mcnt)\n\t\t{\n\t\t\tint i=mini,j=minj;f++;\n\t\t\ts[i][j]='x';\n\t\t\tfor(int r=0;r<8;r++)\n\t\t\t{\n\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\twhile(x>=0&&x<8&&y>=0&&y<8&&s[x][y]=='o')\n\t\t\t\t\tx+=dx[r],y+=dy[r];\n\t\t\t\tif(x>=0&&y>=0&&x<8&&y<8&&s[x][y]=='x')\n\t\t\t\t{\n\t\t\t\t\tx=i+dx[r],y=j+dy[r];\n\t\t\t\t\twhile(x>=0&&x<8&&y>=0&&y<8&&s[x][y]=='o')\n\t\t\t\t\t\ts[x][y]='x',x+=dx[r],y+=dy[r];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<8;i++)cout<<s[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define x first \n#define y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 8;\n\nint dx[] = {1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = {0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    vs b(N);\n\n    for(; cin >> b[0];){\n        range(i, 1, N) cin >> b[i];\n\n        bool mamiT = true;\n        rep(turncnt, N * N){\n            char mine = mamiT ? 'o':'x', enemy = mamiT ? 'x':'o';\n\n            vector< vector< pair<int, vi> > > stat(N, vector< pair<int, vi> >(N));\n            rep(y, N){\n                rep(x, N){\n                    stat[y][x].second = vi(8, 0);\n                    if(b[y][x] != '.') continue;\n\n                    rep(i, 8){\n                        bool ok = false;\n\n                        range(j, 1, N){\n                            pii next = mp(x + dx[i] * j, y + dy[i] * j);\n                            if(next.x < 0 || N <= next.x ||\n                               next.y < 0 || N <= next.y) break;\n                            if(b[next.y][next.x] == enemy){\n                                stat[y][x].first++;\n                                stat[y][x].second[i]++;\n                            }\n                            else if(b[next.y][next.x] == mine){\n                                ok = true;\n                                break;\n                            }\n                            else break;\n                        }\n                        \n                        if(!ok){\n                            stat[y][x].first -= stat[y][x].second[i];\n                            stat[y][x].second[i] = 0;\n                        }\n                    }\n                }\n            }\n\n            pii p;\n            int maxs = 0;\n            rep(y, N){\n                rep(x, N){\n                    if((mamiT && maxs < stat[y][x].first) ||\n                      (!mamiT && maxs <=stat[y][x].first)){\n                        p = mp(x, y);\n                        maxs = stat[y][x].first;\n                    }\n                }\n            }\n\n            if(maxs != 0){\n                rep(i, 8){\n                    if(stat[p.y][p.x].first == 0) continue;\n                    do{\n                        int k = stat[p.y][p.x].second[i];\n                        b[p.y + k * dy[i]][p.x + k * dx[i]] = mine;\n                    } while(0 <= --stat[p.y][p.x].second[i]);\n                }\n            }\n\n            mamiT = !mamiT;\n        }\n\n        rep(y, N){\n            cout << b[y] << endl;\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\n\tchar s[10][10];\n\tint x[8] = {-1,0,1,-1,1,-1,0,1};\n\tint y[8] = {1,1,1,0,0,-1,-1,-1};\n\n\nvoid witch(){\n\tint imax = 0,jmax = 0,kmax,maxcount = 0,count1,count2;\n\tint ax,ay;\n\tvector<int> vec,maxvec;\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tcount2 = 0;\n\t\t\tif(s[i][j] == '.'){\n\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\tay = i+y[k];\n\t\t\t\t\tax = j+x[k];\n\t\t\t\t\tif(s[ay][ax] == 'o'){\n\t\t\t\t\t\tcount1 = 1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tay += y[k];\n\t\t\t\t\t\t\tax += x[k];\n\t\t\t\t\t\t\tif(s[ay][ax] == 'o')count1++;\n\t\t\t\t\t\t\telse if(s[ay][ax] == 'x'){\n\t\t\t\t\t\t\t\tcount2 += count1;\n\t\t\t\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count2 >= maxcount){\n\t\t\t\t\tmaxcount = count2;\n\t\t\t\t\timax = i;\n\t\t\t\t\tjmax = j;\n\t\t\t\t\tmaxvec.clear();\n\t\t\t\t\tcopy(vec.begin(),vec.end(),back_inserter(maxvec));\n\t\t\t\t}\n\t\t\t\tvec.clear();\n\t\t\t}\n\t\t}\n\t}\n\tif(maxcount > 0){\n\t\ts[imax][jmax] = 'x';\n\t\tfor(int i = 0;i < maxvec.size();i++){\n\t\t\tay = imax;\n\t\t\tax = jmax;\n\t\t\twhile(1){\n\t\t\t\tay += y[maxvec[i]];\n\t\t\t\tax += x[maxvec[i]];\n\t\t\t\tif(s[ay][ax] == 'x')break;\n\t\t\t\telse s[ay][ax] = 'x';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mami(){\n\tint imax = 0,jmax = 0,kmax,maxcount = 0,count1,count2;\n\tint ax,ay;\n\tvector<int> vec,maxvec;\n\tfor(int i = 8;i >= 1;i--){\n\t\tfor(int j = 8;j >= 1;j--){\n\t\t\tcount2 = 0;\n\t\t\tif(s[i][j] == '.'){\n\t\t\t\tfor(int k = 0;k < 8;k++){\n\t\t\t\t\tay = i+y[k];\n\t\t\t\t\tax = j+x[k];\n\t\t\t\t\tif(s[ay][ax] == 'x'){\n\t\t\t\t\t\tcount1 = 1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tay += y[k];\n\t\t\t\t\t\t\tax += x[k];\n\t\t\t\t\t\t\tif(s[ay][ax] == 'x')count1++;\n\t\t\t\t\t\t\telse if(s[ay][ax] == 'o'){\n\t\t\t\t\t\t\t\tcount2 += count1;\n\t\t\t\t\t\t\t\tvec.push_back(k);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count2 >= maxcount){\n\t\t\t\t\tmaxcount = count2;\n\t\t\t\t\timax = i;\n\t\t\t\t\tjmax = j;\n\t\t\t\t\tmaxvec.clear();\n\t\t\t\t\tcopy(vec.begin(),vec.end(),back_inserter(maxvec));\n\t\t\t\t}\n\t\t\t\tvec.clear();\n\t\t\t}\n\t\t}\n\t}\n\tif(maxcount > 0){\n\t\ts[imax][jmax] = 'o';\n\t\tfor(int i = 0;i < maxvec.size();i++){\n\t\t\tay = imax;\n\t\t\tax = jmax;\n\t\t\twhile(1){\n\t\t\t\tay += y[maxvec[i]];\n\t\t\t\tax += x[maxvec[i]];\n\t\t\t\tif(s[ay][ax] == 'o')break;\n\t\t\t\telse s[ay][ax] = 'o';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid game(int d){\n\tint d1 = d,d2;\n\twhile(1){\n\t\tmami();\n\t\twitch();\n\t\td2 = 0;\n\t\tfor(int i = 1;i <= 8;i++){\n\t\t\tfor(int j = 1;j <= 8;j++){\n\t\t\t\tif(s[i][j] == '.')d2++;\n\t\t\t}\n\t\t}\n\t\tif(d1 == d2)break;\n\t\td1 = d2;\n\t}\n}\n\nint main(){\n\tint d = 0;\n\tfor(int i = 0;i < 10;i++){\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\ts[i][j] = ',';\n\t\t}\n\t}\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tcin >> s[i][j];\n\t\t\tif(s[i][j] == '.'){\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t}\n\n\tgame(d);\n\n\tfor(int i = 1;i <= 8;i++){\n\t\tfor(int j = 1;j <= 8;j++){\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar S[11][11];\n\nint dx[8]= {-1, 0, 1,-1, 1,-1,0,1};\t      \nint dy[8]= {-1,-1,-1, 0, 0, 1, 1, 1};\n\t  \n\nint check(int id,int x,int y){\n  // cout << id << \" \" << \" \" << x << \" \"<< y << \" \"<< S[x][y] << endl;\n  if( S[x][y] != '.'  ) return 0;\n  int res = 0;\n  for(int i=0;i<8;i++){\n    int nx = x, ny = y;\n    int cnt = 0; bool f = true;\n    do{\n      cnt++;\n      nx = nx + dx[i], ny = ny + dy[i];\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) {\n\tf = false;\n\tbreak;\n      }\n    }while( S[nx][ny] == (id==0?'x':'o') );\n    if( f && S[nx][ny] == (id==0?'o':'x') ){\n      res += cnt - 1;\n    }\n  }\n  return res;\n}\nvoid ume(int id,int x,int y){\n  S[x][y] = (id==0?'o':'x');\n  for(int i=0;i<8;i++){\n    int nx = x, ny = y;\n    bool f = true;\n    do{\n      nx = nx + dx[i], ny = ny + dy[i];\n      if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 ) {\n\tf = false;\n\tbreak;\n      }\n    }while( S[nx][ny] == (id==0?'x':'o') );\n\n    if( f && S[nx][ny] == (id==0?'o':'x') ){\n      nx = x + dx[i],  ny = y + dy[i];\n      // cout << \"st \" << nx << \" \"<< ny << endl;\n      while( S[nx][ny] != (id==0?'o':'x') ){\n\tS[nx][ny] = (id==0?'o':'x');\n\tnx = nx + dx[i]; ny = ny + dy[i];\n\t//cout << nx << \" \"<< ny << endl;\n      }\n    }\n  }\n}\n\nbool solve(int id,int t){\n  if( t == 2 ){\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++)\n\tcout << S[j][i];\n      cout << endl;\n    }\n    return true;\n  }\n  if( id == 0 ){\n    int ix=0,jx=0,resx=0;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++){\n\tint ret = check(id,j,i);\n\tif( resx < ret ){\n\t  resx = ret; jx = j; ix = i;\n\t}\n      }\n    }\n    if( resx == 0 ) solve(1-id,t+1);\n    else {\n      ume(id,jx,ix);\n      solve(1-id,0);\n    }\n  } else {\n    int ix=7,jx=7,resx=0;\n    for(int i=7;i>=0;i--){\n      for(int j=7;j>=0;j--){\n\tint ret = check(id,j,i);\n\tif( resx < ret ){\n\t  resx = ret; jx = j; ix = i;\n\t}\n      }\n    }\n    if( resx == 0 ) solve(1-id,t+1);\n    else {\n      ume(id,jx,ix);\n      solve(1-id,0);\n    }\n  }\n}\n\nint main(){\n  for(int i=0;i<8;i++)\n    for(int j=0;j<8;j++)\n      cin >> S[j][i];\n\n  solve(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std; \n#define MAXA 100000000\n#define MAXB 100000000\n#define MAXC 100000000\n#define MAXD 100000000\n#define MAXN 50\n#define MAXM 50\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nchar board[8][8];\nint check(int x,int y,char c)\n{\n  int res=0;\n  if(board[y][x] !='.'){return 0;}\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      int count=0;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[ny][nx]==c){res+=count;break;}\n\t  if(board[ny][nx]=='.'){break;}\n\t  count++;\n\t}\n    }\n  return res;\n}\nvoid put(int x,int y,char c)\n{\n  board[y][x]=c;\n  for(int k=0;k<8;k++)\n    {\n      int nx=x;\n      int ny=y;\n      while(true)\n\t{\n\t  nx +=dx[k];\n\t  ny +=dy[k];\n\t  if(nx < 0|| nx>=8 || ny<0 || ny>=8){ break;}\n\t  if(board[nx][ny]==c){\n\t    while(1)\n\t      {\n\t\tnx -=dx[k];\n\t\tny -=dy[k];\n\t\tif(nx == x && ny == y){break;}\n\t\tboard[ny][nx]= c;\n\t      }\n\t    break;\n\t  }\n\t  if(board[ny][nx]=='.'){break;}\n\t}\n    }\n}\n\nbool win()\n{\n  int o_count=0;\n  int x_count=0;\n  for(int x=0;x<8;x++)\n    {\n      for(int y=0;y<8;y++)\n\t{\n\t  if(board[x][y]=='o'){o_count++;}\n\t  if(board[x][y]=='x'){x_count++;}\n\t}\n    }\n  return o_count==0 || x_count==0 || o_count+x_count==64;\n}\n    \nint main(int argc,char const* argv[])\n{\n  for(int i=0;i<8;i++)\n    {\n      for(int j=0;j<8;j++)\n\t{\n\t  cin >> board[i][j];\n\t}\n    }\n  int turn=1;\n  int max_x,max_y;\n  int pass=0;\n  while(1)\n    {\n      char player=(turn % 2) ? 'o' : 'x';\n      int num=0;max_x=-1,max_y=-1;\n      if(player == 'o')\n\t{\n\t  for(int y=0;y<8;y++)\n\t    {\n\t      for(int x=0;x<8;x++)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for(int y=7;y>=0;y--)\n\t    {\n\t      for(int x=7;x>=0;x--)\n\t\t{\n\t\t  int tmp=check(x,y,player);\n\t\t  if(num <tmp)\n\t\t    {\n\t\t      num=tmp;\n\t\t      max_x=x;\n\t\t      max_y=y;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(max_x != -1)\n\t{\n\t  pass=0;\n\t  put(max_x,max_y,player);\n\t}\n      else\n\t{\n\t  pass++;\n\t}\n      turn++;\n      if(pass>1){break;}\n      if(win()){break;}\n    }\n    \n  for(int y=0;y<8;y++)\n    {\n      for(int x=0;x<8;x++)\n\t{\n\t  cout << board[y][x];\n\t}\n      cout << endl;\n    }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector< vector<char> >V(8,vector<char>(8));\nint dx[8]={-1,1,0,0,-1,-1,1,1};\nint dy[8]={0,0,-1,1,-1,1,-1,1};\n\nbool update;\nint idx,idy,count;\nbool can[8];\n\nbool in(int x,int y){\n\treturn x>=0 && y>=0 && x<8 && y<8;\n}\n\nvoid check(int k){\n\tchar me,you;\n\tbool tcan[8];\n\tcount=0;\n\tmemset(can,false,sizeof(can));\n\tif(k==0){me='o';you='x';}\n\telse{me='x';you='o';}\n\tif(k==0){\n\tfor(int y=0;y<8;y++){\n\t\tint tcount,ttcount;\n\t\tfor(int x=0;x<8;x++){\n\t\t\ttcount=0;\n\t\t\tmemset(tcan,false,sizeof(tcan));\n\t\t\tif(V[y][x]!='.')\n\t\t\t\tcontinue;\n\t\t\tfor(int d=0;d<8;d++){\n\t\t\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\t\t\tttcount=0;\n\t\t\t\twhile(in(nx,ny)&&V[ny][nx]==you){\n\t\t\t\t\tnx+=dx[d];ny+=dy[d];ttcount++;\n\t\t\t\t}\n\t\t\t\tif(in(nx,ny) && V[ny][nx]==me &&ttcount>0){\n\t\t\t\t\ttcount+=ttcount;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\ttcan[d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tcount>count){\n\t\t\t\tidx=x;idy=y;count=tcount;update=true;\n\t\t\t\tfor(int i=0;i<8;i++) can[i]=tcan[i];\n\t\t\t}\n\t\t}\n\t}\n\t}\n\telse{\n\tfor(int y=7;y>=0;y--){\n\t\tint tcount,ttcount;\n\t\tfor(int x=7;x>=0;x--){\n\t\t\ttcount=0;\n\t\t\tmemset(tcan,false,sizeof(tcan));\n\t\t\tif(V[y][x]!='.')\n\t\t\t\tcontinue;\n\t\t\tfor(int d=0;d<8;d++){\n\t\t\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\t\t\tttcount=0;\n\t\t\t\twhile(in(nx,ny)&&V[ny][nx]==you){\n\t\t\t\t\tnx+=dx[d];ny+=dy[d];ttcount++;\n\t\t\t\t}\n\t\t\t\tif(in(nx,ny) && V[ny][nx]==me &&ttcount>0){\n\t\t\t\t\ttcount+=ttcount;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\ttcan[d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tcount>count){\n\t\t\t\tidx=x;idy=y;count=tcount;update=true;\n\t\t\t\tfor(int i=0;i<8;i++) can[i]=tcan[i];\n\t\t\t}\n\t\t}\n\t}\n\t}\n}\n\nvoid put(int k){\n\tchar me,you;\n\tif(count==0)\n\t\treturn;\n\tif(k==0){me='o';you='x';}\n\telse{me='x';you='o';}\n\tV[idy][idx]=me;\n\tfor(int d=0;d<8;d++){\n\t\tif(can[d]){\n\t\t\tint nx=idx+dx[d],ny=idy+dy[d];\n\t\t\twhile(in(nx,ny) && V[ny][nx]==you){\n\t\t\t\tV[ny][nx]=me;nx+=dx[d];ny+=dy[d];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print(){\n\tfor(int y=0;y<8;y++){\n\t\tfor(int x=0;x<8;x++)\n\t\t\tcout<<V[y][x];\n\t\tcout<<endl;\n\t}\n}\n\n\nint main()\n{\n\tfor(int y=0;y<8;y++)\n\t\tfor(int x=0;x<8;x++)\n\t\t\tcin>>V[y][x];\n\n\tupdate=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tcheck(0);\n\t\tput(0);\n\t\tcheck(1);\n\t\tput(1);\n\t}\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int W = 8;\nconst int dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst int dy[] = {0, -1, -1, -1, 0, 1, 1, 1};\nvector<string> board(W);\n\nint Check(int x, int y, int d, char c)\n{\n    if (x < 0 || x >= W || y < 0 || y >= W)\n        return -1;\n    if (board[y][x] == '.')\n        return -1;\n\n    if (board[y][x] == c)\n        return 0;\n    else if (board[y][x] != c) {\n        int res = Check(x + dx[d], y + dy[d], d, c);\n        if (res == -1)\n            return -1;\n        else {\n            return res + 1;\n        }\n    }\n}\n\nvoid Change(int x, int y, int d, char c)\n{\n    if (board[y][x] == c)\n        return ;\n    board[y][x] = c;\n    Change(x + dx[d], y + dy[d], d, c);\n}\n\nbool Hand(char c)\n{\n    bool change = false;\n    int num, x, y, mask;\n\n    num = mask = 0;\n    if (c == 'o') {\n        for (int i = 0; i < W; ++i) {\n            for (int j = 0; j < W; ++j) {\n                int tmp_sum = 0, tmp = 0, tmp_mask = 0;\n                if (board[i][j] == '.')\n                    for (int d = 0; d < 8; ++d) {\n                        tmp = Check(j + dx[d], i + dy[d], d, c);\n                        if (tmp > 0) {\n                            tmp_sum += tmp;\n                            tmp_mask |= 1 << d;\n                        }\n                    }\n\n                if (tmp_sum > num) {\n                    num = tmp_sum;\n                    mask = tmp_mask;\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n    }\n    else if (c == 'x') {\n        for (int i = W - 1; i >= 0; --i) {\n            for (int j = W - 1; j >= 0; --j) {\n                int tmp_sum = 0, tmp = 0, tmp_mask = 0;\n                if (board[i][j] == '.')\n                    for (int d = 0; d < 8; ++d) {\n                        tmp = Check(j + dx[d], i + dy[d], d, c);\n                        if (tmp > 0) {\n                            tmp_sum += tmp;\n                            tmp_mask |= 1 << d;\n                        }\n                    }\n\n                if (tmp_sum > num) {\n                    num = tmp_sum;\n                    mask = tmp_mask;\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n    }\n\n    if (num != 0) {\n        change = true;\n        board[y][x] = c;\n\n        for (int d = 0; d < 8; ++d)\n            if (mask >> d & 1)\n                Change(x + dx[d], y + dy[d], d, c);\n    }\n\n    return change;\n}\n\nint main()\n{\n    // Input\n    for (int i = 0; i < W; ++i)\n        cin >> board[i];\n\n    while (true) {\n        bool change = false;\n        change |= Hand('o');\n        change |= Hand('x');\n\n        if (!change)\n            break;\n    }\n\n    // Output\n    for (int i = 0; i < W; ++i)\n        cout << board[i] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define RREP(i,n) for(int i=(int)(n)-1;i>=0;i--)\nusing namespace std;\nconst int MAX_V=8;\nchar s[MAX_V][MAX_V];\nint iter(char mine,char rival,int x,int y,int vx,int vy,int n=0){\n  x+=vx;y+=vy;\n  if(x<0||x>=MAX_V||y<0||y>=MAX_V)return 0;\n  if(s[x][y]==mine)return n;\n  if(s[x][y]==rival)\n    return iter(mine,rival,x,y,vx,vy,n+1);\n  return 0;\n}\nbool iterturn(char mine,char rival,int x,int y,int vx,int vy){\n  x+=vx;y+=vy;\n  if(x<0||x>=MAX_V||y<0||y>=MAX_V)return false;\n  if(s[x][y]==mine)return true;\n  if(s[x][y]==rival){\n    if(iterturn(mine,rival,x,y,vx,vy)){\n      s[x][y]=mine;\n      return true;\n    }else return false;\n  }\n  return false;\n}\nint reversable(char mine,char rival,int x,int y){\n  return iter(mine,rival,x,y,-1,-1)+\n    iter(mine,rival,x,y,-1,0)+\n    iter(mine,rival,x,y,-1,1)+\n    iter(mine,rival,x,y,0,-1)+\n    iter(mine,rival,x,y,0,1)+\n    iter(mine,rival,x,y,1,-1)+\n    iter(mine,rival,x,y,1,0)+\n    iter(mine,rival,x,y,1,1);\n}\nvoid turn(char mine,char rival,int x,int y){\n  s[x][y]=mine;\n  iterturn(mine,rival,x,y,-1,-1);\n  iterturn(mine,rival,x,y,-1,0);\n  iterturn(mine,rival,x,y,-1,1);\n  iterturn(mine,rival,x,y,0,-1);\n  iterturn(mine,rival,x,y,0,1);\n  iterturn(mine,rival,x,y,1,-1);\n  iterturn(mine,rival,x,y,1,0);\n  iterturn(mine,rival,x,y,1,1);\n}\npair<int,int> o(){\n  int m=1,tmpm;\n  pair<int,int> pos=make_pair(-1,-1);\n  RREP(i,MAX_V)RREP(j,MAX_V){\n    if(s[i][j]=='x'||s[i][j]=='o')continue;\n    tmpm=reversable('o','x',i,j);\n    if(tmpm>=m){\n      m=tmpm;\n      pos=make_pair(i,j);\n    }\n  }\n  return pos;\n}\npair<int,int> x(){\n  int m=1,tmpm;\n  pair<int,int> pos=make_pair(-1,-1);\n  REP(i,MAX_V)REP(j,MAX_V){\n    if(s[i][j]=='x'||s[i][j]=='o')continue;\n    tmpm=reversable('x','o',i,j);\n    if(tmpm>=m){\n      m=tmpm;\n      pos=make_pair(i,j);\n    }\n  }\n  return pos;\n}\nvoid print(){\n  REP(i,MAX_V){\n    REP(j,MAX_V)\n      cout<<s[i][j];\n    cout<<endl;\n  }\n  cout<<endl;\n}\nint main(){ _;\n  REP(i,MAX_V)REP(j,MAX_V)cin>>s[i][j];\n  for(;;){\n    auto a=o();\n    if(a.first>=0)turn('o','x',a.first,a.second);\n    auto b=x();\n    if(b.first>=0)turn('x','o',b.first,b.second);\n    if(a.first==-1&&b.first==-1)break;\n  }\n  print();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\nint dx[] = { 0, 1, 1, 1, 0, -1, -1, -1, };\nint dy[] = { -1, -1, 0, 1, 1, 1, 0, -1, };\n\nint d[9][9];\nvector<P> solve_pos(int t, int x, int y)\n{\n\tvector<P> res;\n\tres.push_back(P(x, y));\n\tif (d[y][x])\n\t\treturn res;\n\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tvector<P> p;\n\t\tint tx, ty;\n\t\ttx = x + dx[i];\n\t\tty = y + dy[i];\n\t\twhile (true)\n\t\t{\n\t\t\tif (d[ty][tx] == -t)\n\t\t\t\tp.push_back(P(tx, ty));\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (d[ty][tx] == t)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < p.size(); ++j)\n\t\t\t\t\t\tres.push_back(p[j]);\n\t\t\t\t}\n\t\t\t\tp.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (d[ty][tx] != -t)\n\t\t\t\tbreak;\n\n\t\t\ttx += dx[i];\n\t\t\tty += dy[i];\n\t\t}\n\t}\n\tunique(res.begin(), res.end());\n\treturn res;\n}\nint main()\n{\n\tfor (int i = 1; i <= 8; ++i)\n\t{\n\t\tchar buf[16];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 1; j <= 8; ++j)\n\t\t\tif (buf[j-1] == 'o')\n\t\t\t\td[i][j] = 1;\n\t\t\telse if (buf[j-1] == 'x')\n\t\t\t\td[i][j] = -1;\n\t\t\telse\n\t\t\t\td[i][j] = 0;\n\t}\n\n\tint turn = 1;\n\tfor (int pass = 0; pass != 2; turn *= -1)\n\t{\n\t\tvector<P> m;\n\t\tm.push_back(P(-100000, -10000));\n\t\tif (turn == 1)\n\t\t{\n\t\t\tfor (int i = 1; i <= 8; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j <= 8; ++j)\n\t\t\t\t{\n\t\t\t\t\tvector<P> r = solve_pos(turn, j, i);\n\t\t\t\t\tif (r.size() > m.size())\n\t\t\t\t\t\tm = r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 8; i >= 1; --i)\n\t\t\t{\n\t\t\t\tfor (int j = 8; j >= 1; --j)\n\t\t\t\t{\n\t\t\t\t\tvector<P> r = solve_pos(turn, j, i);\n\t\t\t\t\tif (r.size() > m.size())\n\t\t\t\t\t\tm = r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m.size() > 1)\n\t\t{\n\t\t\tfor (int i = 0; i < m.size(); ++i)\n\t\t\t\td[m[i].second][m[i].first] = turn;\n\t\t\tpass = 0;\n\t\t}\n\t\telse\n\t\t\t++pass;\n\t}\n\n\tfor (int i = 1; i <= 8; ++i)\n\t{\n\t\tfor (int j = 1; j <= 8; ++j)\n\t\t\tif (d[i][j] == 1)\n\t\t\t\tputchar('o');\n\t\t\telse if (d[i][j] == -1)\n\t\t\t\tputchar('x');\n\t\t\telse\n\t\t\t\tputchar('.');\n\t\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};char t[10][10],mark[2]={'o','x'};l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}else r 0;}o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}main(){for(i=0;i<10;i++)t[0][i]=t[9][i]='0';for(i=1;i<9;t[i][0]=t[i++][9]='0')scanf(\"%s\",&t[i][1]);f[1]=-1;for(n=0;;n=(n+1)%2){f[n]=-1;for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,mark[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,mark[n],0):0;f[n]!=0?o(0,0,f[2+n],f[4+n],mark[n],0):0;if(f[0]==0&&f[1]==0)break;}for(i=1;i<9;i++){for(j=1;j<9;j++)printf(\"%c\",t[i][j]);puts(\"\");}r 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> P;\n\nint cho,che;\nchar table[8][8];\nvector<P> v;\n\nconst int dx[8] = {0,0,1,1,1,-1,-1,-1};\nconst int dy[8] = {1,-1,0,-1,1,-1,0,1};\nconst char ch[3] = {'x','o'};\n\nvoid check(int x,int y,int turn,vector<P> &v){\n  char c = ch[turn],d = ch[1-turn];\n  int count = 0;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int cnt = 0;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tif(table[nx][ny] == c){\n\t  count += cnt;\n\t}\n\tbreak;\n      }\n\n      cnt++;\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }   \n\n  if(count == 0){\n    return;\n  }\n\n  if(turn){\n    v.push_back(P(-count,PA(x,y)));\n  }else{\n    v.push_back(P(-count,PA(-x,-y)));\n  }\n}\n\nvoid change(P a,int turn){\n  char c = ch[turn],d = ch[1-turn];\n\n  a.first = -a.first;\n\n  if(!turn){\n    a.second.first = -a.second.first;\n    a.second.second = -a.second.second;\n  }\n\n  table[a.second.first][a.second.second] = c;\n\n  for(int i = 0 ; i < 8 ; i++){\n    int nx = a.second.first + dx[i];\n    int ny = a.second.second + dy[i];\n    vector<PA> v;\n\n    while(true){\n      if(0 > nx || 0 > ny || nx >= 8 || ny >= 8){\n\tbreak;\n      }\n      if(table[nx][ny] != d){\n\tif(table[nx][ny] == c){\n\t  for(int i = 0 ; i < (int)v.size() ; i++){\n\t    table[v[i].first][v[i].second] = c;\n\t  }\n\t}\n\n\tbreak;\n      }\n\n      v.push_back(PA(nx,ny));\n      nx += dx[i];\n      ny += dy[i];\n    }\n  } \n\n  if(turn){\n    cho += a.first+1;\n    che -= a.first;\n  }else{\n    cho -= a.first;\n    che += a.first+1;\n  }\n}\n\nint main(){\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cin >> table[i][j];\n\n      if(table[i][j] == 'o'){\n\tcho++;\n      }else if(table[i][j] == 'x'){\n\tche++;\n      }\n    }\n  }\n\n  //true mami ------ false witch\n  bool turn = true;\n \n  while(true){\n    vector<P> v;\n \n    if(!cho || !che || cho+che == 64){\n      break;\n    }\n\n    for(int i = 0 ; i < 8 ; i++){\n      for(int j = 0 ; j < 8 ; j++){\n\tif(table[i][j] == '.'){\n\t  int n = turn ? 1 : 0;\n\t  check(i,j,n,v);\n\t}\n      }\n    }\n  \n    if(v.size() > 0){\n      int n = turn ? 1 : 0;\n      sort(v.begin(),v.end());\n      change(v[0],n);\n    }\n\n    turn = !turn;\n  }\n\n  for(int i = 0 ; i < 8 ; i++){\n    for(int j = 0 ; j < 8 ; j++){\n      cout << table[i][j];\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<iomanip>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nstring s[8];\nint dx[] = {-1, 0, 1, 1, 1, 0, -1, -1}, dy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint f1(int x, int y, bool ismami, int v) {\n\tint ret = 0;\n\tbool fl = false;\n\twhile(true) {\n\t\tx += dx[v]; y += dy[v];\n\t\tif(x < 0 || x >= 8 || y < 0 || y >= 8 || s[y][x] == '.') return 0;\n\t\tif(s[y][x] == (ismami ? 'x' : 'o')) {\n\t\t\tret++;\n\t\t}\n\t\tif(s[y][x] == (ismami ? 'o' : 'x')) {\n\t\t\tfl = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(fl) return ret;\n\treturn 0;\n}\n\nvoid f2(int x, int y, bool ismami, int v) {\n\twhile(true) {\n\t\tx += dx[v]; y += dy[v];\n\t\tif(s[y][x] == (ismami ? 'x' : 'o')) {\n\t\t\ts[y][x] = (ismami ? 'o' : 'x');\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nsigned main(void)\n{\n\tREP(i, 8) cin >> s[i];\n\n\tbool mami = true, end = false;\n\t//???????????¶??????????????´???????????????????????????????????????\n\twhile(true) {\n\t\t//????????????????????????\n\t\tif(mami) {\n\t\t\tint ma = 0, x = -1, y = -1;\n\t\t\t//?????????????????????????????¨???????????¢???\n\t\t\t//(i, j)??????????????¨???\n\t\t\tREP(i, 8) REP(j, 8) {\n\t\t\t\tif(s[i][j] != '.') continue;\n\t\t\t\t//(i, j)???????????????????????°?????¢?´¢\n\t\t\t\tint tmp = 0;\n\t\t\t\tREP(k, 8) {\n\t\t\t\t\ttmp += f1(j, i, mami, k);\n\t\t\t\t}\n\t\t\t\tif(tmp > ma) {\n\t\t\t\t\tma = tmp;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\t//cout << i << \" \" << j << \" \" << tmp << endl;\n\t\t\t}\n\t\t\t//cout << \"mami\" << x << \" \" << y << endl;\n\t\t\tif(x == -1 && y == -1) {\n\t\t\t\tif(end) break;\n\t\t\t\tend = true;\n\t\t\t} else {\n\t\t\t\tend = false;\n\t\t\t}\n\t\t\t//(y, x)??????????????¨????????????????????¶???\n\t\t\tif(!end) {\n\t\t\t\ts[y][x] = 'o';\n\t\t\t\tREP(i, 8) {\n\t\t\t\t\tif(f1(x, y, mami, i) >= 1) f2(x, y, mami, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << (mami ? \"mami \" : \"majo \") << x << \" \" << y << \" \" << ma << endl;\n\t\t\tmami = false;\n\t\t} else {\n\t\t\tint ma = 0, x = -1, y = -1;\n\t\t\t//?????????????????????????????¨???????????¢???\n\t\t\t//(i, j)??????????????¨???\n\t\t\tfor(int i=7; i>=0; --i) {\n\t\t\t\tfor(int j=7; j>=0; --j) {\n\t\t\t\t\tif(s[i][j] != '.') continue;\n\t\t\t\t\t//(i, j)???????????????????????°?????¢?´¢\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tREP(k, 8) {\n\t\t\t\t\t\ttmp += f1(j, i, mami, k);\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp > ma) {\n\t\t\t\t\t\tma = tmp;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"majo\" << x << \" \" << y << endl;\n\t\t\tif(x == -1 && y == -1) {\n\t\t\t\tif(end) break;\n\t\t\t\tend = true;\n\t\t\t} else {\n\t\t\t\tend = false;\n\t\t\t}\n\t\t\tif(!end) {\n\t\t\t\t//(y, x)??????????????¨????????????????????¶???\n\t\t\t\ts[y][x] = 'x';\n\t\t\t\tREP(i, 8) {\n\t\t\t\t\tif(f1(x, y, mami, i) >= 1) f2(x, y, mami, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << (mami ? \"mami\" : \"majo\") << x << \" \" << y << \" \" << ma << endl;\n\t\t\tmami = true;\n\t\t}\n\t\t//REP(i, 8) cout << s[i] << endl;\n\t\t//cout << \"a \" << (end ? \"true \" : \"false \") << (mami ? \"mami\" : \"majo\") << endl;\n\t}\n\n\tREP(i, 8) cout << s[i] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2311\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid game(char s[8][8]);\nint repcheck(int r,int x,int y,int& si,int& sj,int i,int j,char c,char s[8][8]);\nvoid repcookie(char s[8][8],int ri,int rj,int x,int y,int r,char w);\nbool allcheck(char w,char s[8][8]);\nint main()\n{\n\tconst int size=8;\n\tchar table[size][size];\t//[i][j]\n\tstring inputbuf;\n\tfor(int i=0;i<size;i++){//y??????\n\t\tcin >> inputbuf;\n\t\tfor(int j=0;j<size;j++){\n\t\t\ttable[i][j]=inputbuf[j];\n\t\t}\n\t}\n\tgame(table);\n\tfor(int i=0;i<size;i++){\n\t\tfor(int j=0;j<size;j++){\n\t\t\tcout << table[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcin.get();\n\tcin.get();\n\treturn 0;\n}\nvoid game(char s[8][8]){\n\tint irepcookie;\t//????????????????????????????????°\n\tint si,sj;\t\t//?¨????????????????\n\tint rx,ry;\t//?¨??????????\n\tint failc=0;\t\t//?¨????????????§1?¢???????2??§while??±???\n\tbool filled=true;\t//??¨???????????£???????????´??????true\n\twhile(true){\n\t\t//---??????????????????????¨????(x) (o) ???????????????\n\t\t//??????????????¢?´¢?????????????????°???????????°?¬???????si sj?????´??°?????????\n\t\tsi=0;\n\t\tsj=0;\n\t\trx=0;\n\t\try=0;\n\t\tirepcookie=0;\n\t\tfilled = true;\t//???????????????????????£?????¨????????????\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i][j] == '.'){\n\t\t\t\t\tfilled = false;//?????????????????´??????false\n\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t123\n\t\t\t\t\t\t\t4 5\n\t\t\t\t\t\t\t678 ???????????§??¢?´¢\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif(i == 0 && y == -1){break;}\n\t\t\t\t\t\t\tif(i == 7 && y == 1){break;}\n\t\t\t\t\t\t\tif(j == 0 && x == -1 || j == 7 && x == 1){//x??§?¨???§????????????????????´????£???°???\n\t\t\t\t\t\t\t\t//?????????????????§??\\???????£???°???\n\t\t\t\t\t\t\t}else{//\n\t\t\t\t\t\t\t\tif(x!=0||y!=0){//??????????£???°???\n\t\t\t\t\t\t\t\t\tif(s[i+y][j+x]=='o'){\n\t\t\t\t\t\t\t\t\t\tint repbuf = repcheck(irepcookie,x,y,si,sj,i,j,'x',s);\n\t\t\t\t\t\t\t\t\t\tif(repbuf>=irepcookie){//irepcookie????????§????????´??????\n\t\t\t\t\t\t\t\t\t\t\tif(irepcookie>0){\n\t\t\t\t\t\t\t\t\t\t\t\tfailc=0;\t//1??\\???????¨????????????¨????????????????????????\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tirepcookie = repbuf;\n\t\t\t\t\t\t\t\t\t\t\trx = x;\n\t\t\t\t\t\t\t\t\t\t\try = y;\n\t\t\t\t\t\t\t\t\t\t\trepbuf = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}//---if s[i][j]?????????\n\t\t\t}\n\n\n\t\t}\n\t\t//??????????????????????????¨???\n\t\tif(irepcookie>0){\n\t\t\ts[si][sj] = 'x';\n\t\t\trepcookie(s,si,sj,rx,ry,irepcookie,'x');\t//???????????§?????????\n\t\t}else{//??????????????°0????¨??????????????????§\n\t\t\tfailc++;\n\t\t}\n\t\t//----??????????????¨???\n\t\tif(failc >= 2){\n\t\t\t//break;\n\t\t}\n\t\tif(filled == true){\n\t\t\tbreak;\n\t\t}\n\t\tif(true==allcheck('x',s)){\n\t\t\tbreak;\n\t\t}\n\t\t//---?????§????????????????¨????(o) (x) ???????????????\n\t\t//??????????????¢?´¢?????????????????°???????????°?¬???????si sj?????´??°?????????\n\t\tsi=0;\n\t\tsj=0;\n\t\trx=0;\n\t\try=0;\n\t\tirepcookie=0;\n\t\tfilled = true;\t//???????????????????????£?????¨????????????\n\t\tfor(int i=7;i>=0;i--){\n\t\t\tfor(int j=7;j>=0;j--){\n\t\t\t\tif(s[i][j] == '.'){\n\t\t\t\t\tfilled = false;//?????????????????´??????false\n\t\t\t\t\tfor(int y=-1;y<=1;y++){\n\t\t\t\t\t\tfor(int x=-1;x<=1;x++){\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t123\n\t\t\t\t\t\t\t4 5\n\t\t\t\t\t\t\t678 ???????????§??¢?´¢\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif(i == 0 && y == -1){break;}\n\t\t\t\t\t\t\tif(i == 7 && y == 1){break;}\n\t\t\t\t\t\t\tif(j == 0 && x == -1 || j == 7 && x == 1){//x??§?¨???§????????????????????´????£???°???\n\t\t\t\t\t\t\t\t//?????????????????§??\\???????£???°???\n\t\t\t\t\t\t\t}else{//\n\t\t\t\t\t\t\t\tif(x!=0||y!=0){//??????????£???°???\n\t\t\t\t\t\t\t\t\tif(s[i+y][j+x]=='x'){\n\t\t\t\t\t\t\t\t\t\tint repbuf=repcheck(irepcookie,x,y,si,sj,i,j,'o',s);\n\t\t\t\t\t\t\t\t\t\tif(repbuf>=irepcookie){//irepcookie????????§????????´??????\n\t\t\t\t\t\t\t\t\t\t\tif(irepcookie>0){\n\t\t\t\t\t\t\t\t\t\t\t\tfailc=0;\t//1??\\???????¨????????????¨????????????????????????\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tirepcookie = repbuf;\n\t\t\t\t\t\t\t\t\t\t\trx = x;\n\t\t\t\t\t\t\t\t\t\t\try = y;\n\t\t\t\t\t\t\t\t\t\t\trepbuf = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}//---if s[i][j]?????????\n\t\t\t}\n\t\t}\n\t\t//??????????????????????????¨???\n\t\tif(irepcookie>0){\n\t\t\ts[si][sj] = 'o';\n\t\t\trepcookie(s,si,sj,rx,ry,irepcookie,'o');\t//???????????§?????????\n\t\t}else{//??????????????°0????¨??????????????????§\n\t\t\tfailc++;\n\t\t}\n\t\tif(failc >= 2){\n\t\t\t//break;\n\t\t}\n\t\tif(filled == true){\n\t\t\tbreak;\n\t\t}\n\t\tif(true==allcheck('o',s)){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n//??¨??????????¨???????????????????????????????\n//???????¨??????§????????°true\nbool allcheck(char w,char s[8][8]){\n\tchar chk;\n\tbool allc=true;\n\tif(w=='o'){\n\t\tchk = 'x';\n\t}else{\n\t\tchk = 'o';\n\t}\n\t//.???????????????????????´???(??¨?????????)???true\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tif(s[i][j]=='o'||s[i][j]=='w'){\n\t\t\t}else{\n\t\t\t\tallc=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(allc==false){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(allc==true){return true;}\n\t//???????¨???????????????§??????????????????false\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tif(s[i][j]==w){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n/*\nrepcheck\nfor?????§char c??¨???????\\´???x,y?????£?¶????????¶??????°??????????????????\nx,y????§???????????????????\nr???????????????????????????????????????????????°\nr??¨repcheck????????§?????????????????§????????????r?????£??\\\nc????¨?????????????????????????\n*/\nint repcheck(int r,int x,int y,int& si,int& sj,int i,int j,char c,char s[8][8]){//si sj????¨???????????????????????´????i??¨j????¨????????????????????????????????????????????????°\n\tchar rep;\n\tif(c=='x'){\n\t\trep = 'o';\n\t}else{\n\t\trep = 'x';\n\t}\n\tfor(int k=1;k<8;k++){//?§??????° ?????????1????????????????????????????????° ?????????1?????´????????£?¶???????????????????break\n\t\tif(k*y+i<0 || k*y+i >7 || k*x+j <0 || k*x+j >7){return 0;}//???????????§??¢?´¢???????????£?????´??????break\n\t\tif(s[k*y+i][k*x+j]=='.'){return 0;}\n\t\tif(s[k*y+i][k*x+j]==c){//1??\\????§????????????????????\\´?????£?????´???\n\t\t\tif(k==1){return 0;}//??£??\\??????????????´?????????????????????????????§?????????\n\t\t\tif(r<=k-1){//?????????????????????????????????????????°??¨????????§?????????????????????????????°????????????\n\t\t\t\tsi = i;\n\t\t\t\tsj = j;\t//????????§?¨???????????????£??\\\n\t\t\t\treturn k-1;//??????????????°??????\n\t\t\t}else if(r>k-1){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n???????????????????¨??????????????????????\nchar *s[8] ????????????????±?\nri,rj ?¨??????????\nx,y ?§??????° -1 0 1\nr ?????????????????°\nw ????????????????????§????????????\n*/\nvoid repcookie(char s[8][8],int ri,int rj,int x,int y,int r,char w){\n\tfor(int i=1;i<=r;i++){\n\t\ts[i*y+ri][i*x+rj] = w;\n\t}\n\t//???????????°\n/*\tcout << \"-----\"<<endl;\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}*/\n}\n/*\nchar table[i][j]\ns[i][j]\n?????§???????????????\t'o'\n???????????±??????\t'x'\n????????????\t\t'.'\n\nvoid nantoka\n????????????????????????????????§????????????\n?????????????????????????????????????????´?????¨??????????????????\n?¨??????´???????????????????????°????????§?????´???????¨????\n??????????????§????????´?????????????????????????????????????????????????????????????????????\n?¨????????????´???????´¢???????¨????????????´?????????1??¢????????´???????¨???????????????´??????????£???¨?????????\n??????????????????1????????????????????????????¨?????????´???????????????????????????'.'?????´???????????¢??????????¨?????????´????????????????????°???????´?\n?¨????????????¨????´????????????°????¨????????¨???????????¨??????¨????????????????????´?????????\n??????????????´???????????????????????¢?´¢??????????????§????????????????????¢?´¢?????????\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int A = 8;\n\nint count (int x, int y, char mark, char fld[][12]) {\n    static int dx[A] = {1, 1, 0, -1, -1, -1, 0, 1};\n    static int dy[A] = {0, 1, 1, 1, 0, -1, -1, -1};\n    int ret = 0;\n    for(int i = 0; i < A; ++i) {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        while(0 <= xx && xx < A && 0 <= yy && yy < A) { \n            if(fld[xx][yy] == '.' || fld[xx][yy] == mark) break;\n            xx += dx[i];\n            yy += dy[i];\n        }\n        if(0 <= xx && xx < A && 0 <= yy && yy < A &&\n                fld[xx][yy] == mark) { \n            ret += max(abs(x - xx), abs(y - yy)) - 1;\n        }\n    }\n    return ret;\n}\n\nvoid set_cookie(int x, int y, char mark, char fld[][12]) {\n    fld[x][y] = mark;\n    static int dx[A] = {1, 1, 0, -1, -1, -1, 0, 1};\n    static int dy[A] = {0, 1, 1, 1, 0, -1, -1, -1};\n    for(int i = 0; i < A; ++i) {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        while(0 <= xx && xx < A && 0 <= yy && yy < A) { \n            if(fld[xx][yy] == '.' || fld[xx][yy] == mark) break;\n            xx += dx[i];\n            yy += dy[i];\n        }\n        if(0 <= xx && xx < A && 0 <= yy && yy < A &&\n                fld[xx][yy] == mark) { \n            for(int m = x + dx[i], n = y + dy[i]; m != xx || n != yy;\n                    m += dx[i], n += dy[i]) {\n                fld[m][n] = mark;\n            }\n        }\n    }\n}\n\nint main() {\n    char fld[8][12];\n    for (int i = 0; i < A; ++i) {\n        scanf(\"%s\", fld[i]);\n    }\n    int v_mami, x_mami, y_mami;\n    int v_witch, x_witch, y_witch;\n    int t;\n    while(true) {\n        v_mami = 0;\n        v_witch = 0;\n        for(int i = 0; i < A; ++i) {\n            for(int j = 0; j < A; ++j) {\n                if(fld[i][j] == '.') {\n                    t = count(i, j, 'o', fld);\n                    if(v_mami < t) {\n                        x_mami = i;\n                        y_mami = j;\n                        v_mami = t;\n                    }\n                }\n            }\n        }\n        if(v_mami > 0) {\n            set_cookie(x_mami, y_mami, 'o', fld);\n        }\n        for(int i = 0; i < A; ++i) {\n            for(int j = 0; j < A; ++j) {\n                if(fld[i][j] == '.') {\n                    t = count(i, j, 'x', fld);\n                    if(v_witch <= t) {\n                        x_witch = i;\n                        y_witch = j;\n                        v_witch = t;\n                    }\n                }\n            }\n        }\n        if(v_witch > 0) {\n            set_cookie(x_witch, y_witch, 'x', fld);\n        }\n        if(v_mami == 0 && v_witch == 0) {\n            break;\n        }\n    }\n    for(int i = 0; i < A; ++i) {\n        printf(\"%s\\n\", fld[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv;\nint dd1[]={0,1,0,-1,0};\nint dd2[]={1,-1,-1,1,1};\nint foo(int a,int b,int c){\n\tint ret=0;\n\trep(i,4){\n\t\tint aa=a+dd1[i];\n\t\tint bb=b+dd1[i+1];\n\t\tint tt=0;\n\t\twhile(0<=aa&&aa<8&&0<=bb&&bb<8){\n\t\t\tif(vv[aa][bb]==c){\n\t\t\t\tret+=tt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vv[aa][bb]==-1) break;\n\t\t\taa+=dd1[i];\n\t\t\tbb+=dd1[i+1];\n\t\t\ttt++;\n\t\t}\n\t}\n\trep(i,4){\n\t\tint aa=a+dd2[i];\n\t\tint bb=b+dd2[i+1];\n\t\tint tt=0;\n\t\twhile(0<=aa&&aa<8&&0<=bb&&bb<8){\n\t\t\tif(vv[aa][bb]==c){\n\t\t\t\tret+=tt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vv[aa][bb]==-1) break;\n\t\t\taa+=dd2[i];\n\t\t\tbb+=dd2[i+1];\n\t\t\ttt++;\n\t\t}\n\t}\n\treturn ret;\n}\nvoid foo2(int a,int b,int c){\n\t// cout<<\"hoge\\n\";\n\tvv[a][b]=c;\n\trep(i,4){\n\t\tint aa=a+dd1[i];\n\t\tint bb=b+dd1[i+1];\n\t\tint tt=0;\n\t\twhile(0<=aa&&aa<8&&0<=bb&&bb<8){\n\t\t\tif(vv[aa][bb]==c){\n\t\t\t\tint a1=a+dd1[i];\n\t\t\t\tint b1=b+dd1[i+1];\n\t\t\t\trep(j,tt){\n\t\t\t\t\tvv[a1][b1]=c;\n\t\t\t\t\ta1+=dd1[i];\n\t\t\t\t\tb1+=dd1[i+1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vv[aa][bb]==-1) break;\n\t\t\taa+=dd1[i];\n\t\t\tbb+=dd1[i+1];\n\t\t\ttt++;\n\t\t}\n\t}\n\trep(i,4){\n\t\tint aa=a+dd2[i];\n\t\tint bb=b+dd2[i+1];\n\t\tint tt=0;\n\t\twhile(0<=aa&&aa<8&&0<=bb&&bb<8){\n\t\t\tif(vv[aa][bb]==c){\n\t\t\t\tint a1=a+dd2[i];\n\t\t\t\tint b1=b+dd2[i+1];\n\t\t\t\trep(j,tt){\n\t\t\t\t\tvv[a1][b1]=c;\n\t\t\t\t\ta1+=dd2[i];\n\t\t\t\t\tb1+=dd2[i+1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vv[aa][bb]==-1) break;\n\t\t\taa+=dd2[i];\n\t\t\tbb+=dd2[i+1];\n\t\t\ttt++;\n\t\t}\n\t}\n}\nvoid disp(){\n\tcout<<\"disp\\n\";\n\trep(i,8){\n\t\trep(j,8){\n\t\t\tif(vv[i][j]==0) cout<<\"o\";\n\t\t\telse if(vv[i][j]==1) cout<<\"x\";\n\t\t\telse cout<<\".\";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n}\nvoid mainmain(){\n\tvector<string> s(8);\n\trep(i,8) cin>>s[i];\n\tinitvv(vv,8,8);\n\trep(i,8) rep(j,8){\n\t\tif(s[i][j]=='o') vv[i][j]=0;\n\t\telse if(s[i][j]=='x') vv[i][j]=1;\n\t\telse vv[i][j]=-1;\n\t}\n\t// rep(i,8) cout<<s[i]<<endl;\n\t// cout<<endl;\n\tint update=1;\n\twhile(update){\n\t\tupdate=0;\n\t\tvvint tmp;\n\t\tinitvv(tmp,8,8,-1);\n\t\trep(i,8){\n\t\t\trep(j,8){\n\t\t\t\tif(vv[i][j]==-1) tmp[i][j]=foo(i,j,0);\n\t\t\t}\n\t\t}\n\t\tint M=-1;\n\t\tbool f=false;\n\t\trep(i,8) rep(j,8) M=max(M,tmp[i][j]);\n\t\t// cout<<\"M = \"<<M<<endl;\n\t\tif(M>=1) rep(i,8){\n\t\t\trep(j,8){\n\t\t\t\tif(M==tmp[i][j]){\n\t\t\t\t\tfoo2(i,j,0);\n\t\t\t\t\tupdate=1;\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f) break;\n\t\t}\n\t\t// disp();\n\t\tinitvv(tmp,8,8,-1);\n\t\trep(i,8){\n\t\t\trep(j,8){\n\t\t\t\tif(vv[i][j]==-1) tmp[i][j]=foo(i,j,1);\n\t\t\t}\n\t\t}\n\t\tM=-1;\n\t\trep(i,8) rep(j,8) M=max(M,tmp[i][j]);\n\t\tif(M>=1){\n\t\t\tint x=-1,y=-1;\n\t\t\trep(i,8){\n\t\t\t\trep(j,8){\n\t\t\t\t\tif(M==tmp[i][j]){\n\t\t\t\t\t\tx=i;\n\t\t\t\t\t\ty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate=1;\n\t\t\tfoo2(x,y,1);\n\t\t}\n\t\t// disp();\n\t}\n\trep(i,8){\n\t\trep(j,8){\n\t\t\tif(vv[i][j]==0) cout<<\"o\";\n\t\t\telse if(vv[i][j]==1) cout<<\"x\";\n\t\t\telse cout<<\".\";\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y) {\n  return (0<=x&&x<8) && (0<=y&&y<8);\n}\n\nstring F[8];\nbool used[8][8];\nint turn;\n\nint dx, dy;\nint dfs(int x, int y, char me, int cnt) {\n  x += dx, y += dy;\n  if(!inrange(x, y)) { return 0; }\n  if(F[y][x] == '.') { return 0; }\n  if(F[y][x] == me) {\n    return cnt;\n  }\n  used[y][x] = 1;\n  int r = dfs(x, y, me, cnt+1);\n  if(r == 0) { used[y][x] = 0; }\n  return r;\n}\n\n#define DREP(i, a, b, c, d)                                 \\\n  for(int i=turn&1?a:c; turn&1?i>=b:i<=d; turn&1?i--:i++)\n\nint main() {\n  rep(i, 8) cin >> F[i];\n  int ucnt = 0;\n  for(turn=0; turn<=64; turn++) {\n    int pl;\n    bool u[8][8] = {};\n    int mx = 0;\n    DREP(i, 7, 0, 0, 7) DREP(j, 7, 0, 0, 7) {\n      if(F[i][j] == '.') {\n        rep(a, 8) rep(b, 8) used[a][b] = 0;\n        used[i][j] = 1;\n        int r = 0;\n        for(dy=-1; dy<2; dy++) for(dx=-1; dx<2; dx++) {\n          if(dx == 0 && dy == 0) { continue; }\n          r += dfs(j, i, \"ox\"[turn&1], 0);\n        }            \n        if(mx < r) {\n          memcpy(u, used, sizeof u);\n          mx = r; pl = turn&1;\n        }\n      }\n    }\n    if(mx > 0) {\n      rep(i, 8) rep(j, 8)\n        if(u[i][j]) { F[i][j] = \"ox\"[pl]; }\n      ucnt = 0;\n    }\n    else {\n      if(ucnt) { break; }\n      ucnt ++;\n    }\n  }\n  rep(i, 8) {\n    rep(j, 8) {\n      cout << F[i][j];\n    }\n    puts(\"\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h = 8;\nint w = 8;\nint field[10][10];\nint tempField[10][10];\nint dx[8] = { 1, 1, 1, 0, -1, -1, -1, 0 };\nint dy[8] = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\nvoid PrintField(int field[10][10]) {\n  REP(y, h) {\n    REP(x, w) {\n      int c = field[y][x];\n      if (c == -1) { putchar('.'); }\n      if (c == 0) { putchar('o'); }\n      if (c == 1) { putchar('x'); }\n    }\n    puts(\"\");\n  }\n}\n\nint Put(int sx, int sy, int player) {\n  int ret = 0;\n  if (field[sy][sx] != -1) { return 0; }\n  memcpy(tempField, field, sizeof(field));\n  tempField[sy][sx] = player;\n  REP(dir, 8) {\n    int lcnt = 0;\n    int nx = sx;\n    int ny = sy;\n    while (true) {\n      nx += dx[dir];\n      ny += dy[dir];\n      if (nx < 0 || nx >= w || ny < 0 || ny >= h || tempField[ny][nx] == -1) {\n        lcnt = 0;\n        break;\n      }\n      if (tempField[ny][nx] == player) { break; }\n      lcnt++;\n    }\n    if (lcnt == 0) { continue; }\n    nx = sx;\n    ny = sy;\n    while (true) {\n      nx += dx[dir];\n      ny += dy[dir];\n      if (tempField[ny][nx] == player) { break; }\n      tempField[ny][nx] ^= 1;\n    }\n    ret += lcnt;\n  }\n  return ret;\n}\n\nvoid calc(int player, int pass) {\n  if (pass == 2) { return; }\n  //PrintField(field);\n  //puts(\"\");\n  int cnt = 0;\n  int ansy = -1;\n  int ansx = -1;\n  int sy = player == 0 ? 0 : h - 1;\n  int sx = player == 0 ? 0 : w - 1;\n  int dir = player == 0 ? 1: -1;\n  for (int y = sy; 0 <= y && y < h; y += dir) {\n    for (int x = sx; 0 <= x && x < w; x += dir) {\n      int lcnt = Put(x, y, player);\n      if (lcnt > cnt) {\n        cnt = lcnt;\n        ansx = x;\n        ansy = y;\n      }\n    }\n  }\n  if (cnt == 0) {\n    calc(player ^ 1, pass + 1);\n  } else {\n    Put(ansx, ansy, player);\n    memcpy(field, tempField, sizeof(field));\n    calc(player ^ 1, 0);\n  }\n}\n\nint main() {\n  while (true) {\n    MEMSET(field, -1);\n    REP(y, h) {\n      REP(x, w) {\n        char c;\n        int v = scanf(\" %c \", &c);\n        if (v != 1) { return 0; }\n        if (c == 'o') { field[y][x] = 0; }\n        if (c == 'x') { field[y][x] = 1; }\n      }\n    }\n    calc(0, 0);\n    PrintField(field);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 8;\nconst int W = 8;\nconst int di[8] = {0,1,1,1,0,-1,-1,-1};\nconst int dj[8] = {1,1,0,-1,-1,-1,0,1};\nvector<string> G(H);\n\nint check(int i, int j, int di, int dj, char c) {\n  int length = 0;\n  while(1) {\n    i += di;\n    j += dj;\n    if(i < 0 || i >= H) return 0;\n    if(j < 0 || j >= W) return 0;\n    if(G[i][j] == c) return length;\n    if(G[i][j] == '.') return 0;\n    ++length;\n  }\n}\n\nint canPut(int i, int j, char c) {\n  if(G[i][j] != '.') return 0;\n  int res = 0;\n  for(int k = 0; k < 8; ++k) {\n    res += check(i, j, di[k], dj[k], c);\n  }\n  return res;\n}\n\nvoid reverse(int i, int j, int di, int dj, char c) {\n  while(1) {\n    i += di;\n    j += dj;\n    if(G[i][j] == c) return;\n    G[i][j] = c;\n  }\n}\n\nvoid put(int i, int j, char c) {\n  G[i][j] = c;\n  for(int k = 0; k < 8; ++k) {\n    if(!check(i, j, di[k], dj[k], c)) continue;\n    reverse(i, j, di[k], dj[k], c);\n  }\n}\n\nint main() {\n  for(int i = 0; i < H; ++i) cin >> G[i];\n  while(1) {\n    int pass = 0;\n    {\n      int maxi = 0, pi, pj;\n      for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n          int tmp = canPut(i, j, 'o');\n          if(tmp > maxi) {\n            maxi = tmp;\n            pi = i; pj = j;\n          }\n        }\n      }\n      if(maxi) put(pi, pj, 'o');\n      else ++pass;\n    }\n    {\n      int maxi = 0, pi, pj;\n      for(int i = H-1; i >= 0; --i) {\n        for(int j = W-1; j >= 0; --j) {\n          int tmp = canPut(i, j, 'x');\n          if(tmp > maxi) {\n            maxi = tmp;\n            pi = i; pj = j;\n          }\n        }\n      }\n      if(maxi) put(pi, pj, 'x');\n      else ++pass;\n    }\n    if(pass == 2) break;\n  }\n  for(int i = 0; i < H; ++i) cout << G[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint s[8][8];\n\nconst int dx[] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nconst int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\nint count(int x, int y, int tu) {\n\tint res = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 1;; j++) {\n\t\t\tint tx = x + dx[i] * j, ty = y + dy[i] * j;\n\t\t\tif (tx >= 0 && tx < 8 && ty >= 0 && ty < 8 && s[tx][ty]) {\n\t\t\t\tif (s[tx][ty] == tu) {\n\t\t\t\t\tres += j - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid pu(int x, int y, int tu) {\n\ts[x][y] = tu;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 1;; j++) {\n\t\t\tint tx = x + dx[i] * j, ty = y + dy[i] * j;\n\t\t\tif (tx >= 0 && tx < 8 && ty >= 0 && ty < 8 && s[tx][ty]) {\n\t\t\t\tif (s[tx][ty] == tu) {\n\t\t\t\t\tfor (int k = j - 1; k > 0; k--) {\n\t\t\t\t\t\ts[x + dx[i] * k][y + dy[i] * k] = tu;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tchar c;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'o') {\n\t\t\t\ts[i][j] = 1;\n\t\t\t}\n\t\t\telse if (c == 'x') {\n\t\t\t\ts[i][j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint tu = 1, tc = 0;\n\twhile (true) {\n\t\tint px, py, cha = 0;\n\t\tif (tu == 1) {\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (s[i][j] == 0) {\n\t\t\t\t\t\tint cnt = count(i, j, tu);\n\t\t\t\t\t\tif (cnt > cha) {\n\t\t\t\t\t\t\tcha = cnt;\n\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\tpy = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\t\tfor (int j = 7; j >= 0; j--) {\n\t\t\t\t\tif (s[i][j] == 0) {\n\t\t\t\t\t\tint cnt = count(i, j, tu);\n\t\t\t\t\t\tif (cnt > cha) {\n\t\t\t\t\t\t\tcha = cnt;\n\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\tpy = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cha == 0) {\n\t\t\tif (tc == 0) {\n\t\t\t\ttc++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttc = 0;\n\t\t\tpu(px, py, tu);\n\t\t}\n\t\ttu = -tu;\n\t}\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcout << (s[i][j] ? s[i][j] > 0 ? 'o' : 'x' : '.');\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//$g++ -std=c++11 Template.cpp \n\n//#include <bits/stdc++.h>\n#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <iomanip>\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define ROF(i, j, k) for(int i = (int)(j); i >= (int)(k); --i)\n#define FORLL(i, n, m) for(long long i = n; i < (long long)(m); i++)\n#define SORT(v, n) sort(v, v+n)\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nusing namespace std;\nusing ll = long long;\nconst ll MOD=1000000007LL;\ntypedef pair<int, int> P;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n\npriority_queue<int> q_descending;\npriority_queue<int, vector<int>, greater<int> > q_ascending;\n\nchar t[8][9];\nint n = 8;\nint all_turn;\nint dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};\n\nbool check(int row, int col){\n  return (row >= 0 && row <= 7 && col >= 0 && col <= 7);\n}\nvoid turn(int x, int y, char c){\n  char e_c = (c == 'o' ? 'x' : 'o');\n  //8-directions\n  REP(i,n){\n    int res = 1;\n    while(check(x+res*dx[i], y+res*dy[i])){\n      char focus = t[x+res*dx[i]][y+res*dy[i]];\n      if(focus == c){\n\tt[x][y] = c;\n\tFOR(j,1,res) t[x+j*dx[i]][y+j*dy[i]] = c;\n\tbreak;\n      }\n      else if(focus == e_c) res++;\n      else break;\n    }\n  }    \n}\n\nint simulate(int x, int y, char c){\n  int ret = 0;\n  char e_c = (c == 'o' ? 'x' : 'o');\n  //8-directions\n  REP(i,n){\n    int res = 1;\n    while(check(x+res*dx[i], y+res*dy[i])){\n      char focus = t[x+res*dx[i]][y+res*dy[i]];\n      if(focus == c){\n\tret += res-1;\n\tbreak;\n      }\n      else if(focus == e_c) res++;\n      else break;\n    }\n  }  \n  return ret;\n}\nbool solve(){\n  int max_n=0, max_x=-1, max_y=-1;\n  char c = 'o';\n\n  REP(i,n) REP(j,n){\n    if(t[i][j] == '.'){      \n      int num = simulate(i,j,c);\n      if(max_n<num){\n\tmax_n = num;\n\tmax_x = i;\n\tmax_y = j;\n      }\n    }\n  }\n  if(max_x >= 0) turn(max_x, max_y, c);  \n  return (max_n > 0);\n}\n\nbool _solve(){\n  int max_n=0, max_x=-1, max_y=-1;\n  char c = 'x';\n\n  ROF(i,7,0) ROF(j,7,0){\n    if(t[i][j] == '.'){          \n    int num = simulate(i,j,c);\n    if(max_n<num){\n      max_n = num;\n      max_x = i;\n      max_y = j;\n    }\n    }\n  }\n  if(max_x >= 0) turn(max_x, max_y, c);  \n  return (max_n > 0); \n}\n\nint\nmain(void){  \n  ios_base::sync_with_stdio(false);\n\n  REP(i, n) cin >> t[i];\n\n  bool first = true, second = true;\n  while(first || second){\n    first = solve();\n    second = _solve();\n  }\n\n  REP(i,n) {\n    REP(j,n) cout << t[i][j];\n    cout << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j,k,l;\n  vector<string> s(8);\n  rep(i,8)cin>>s[i];\n  rep(k,64){//odd:x even:o \n    int m=0;//num of reversible place\n    vector<vi> num(8,vi(8,0));\n    int dx[8]={-1,-1, 0, 1, 1, 1, 0,-1};\n    int dy[8]={ 0, 1, 1, 1, 0,-1,-1,-1};\n    rep(i,8)rep(j,8){\n      if(s[i][j]!='.')continue;\n      rep(l,8){\n\tint a=1;\n\tbool r=false;\n\twhile(1){\n\t  int nx=i+dx[l]*a;\n\t  int ny=j+dy[l]*a;\n\t  if(nx<0 || nx>7 || ny<0 || ny>7 || s[nx][ny]=='.')break;\n\t  if((k%2 && s[nx][ny]=='o') ||(k%2==0 && s[nx][ny]=='x'))r=true;\n\t  if((k%2 && s[nx][ny]=='x') ||(k%2==0 && s[nx][ny]=='o')){\n\t    if(r)num[i][j]+=a-1;\n\t    break;\n\t  }\n\t  a++;\n\t}\n      }\n      m=max(m,num[i][j]);\n    }\n    if(m==0)continue;\n    if(k%2){//'x'\n      for(i=7;i>=0;i--)for(j=7;j>=0;j--)if(num[i][j]==m){\n\t    rep(l,8){\n\t      int a=1;\n\t      while(1){\n\t\tint nx=i+dx[l]*a;\n\t\tint ny=j+dy[l]*a;\n\t\tif(nx<0 || nx>7 || ny<0 || ny>7 || s[nx][ny]=='.')break;\n\t\tif(k%2 && s[nx][ny]=='x'){\n\t\t  for(;a>=0;a--)s[i+dx[l]*a][j+dy[l]*a]='x';\n\t\t  break;\n\t\t}\n\t\ta++;\n\t      }\n\t    }\n\t    goto END;\n\t  }\n    }else{//'o'\n      rep(i,8)rep(j,8)if(num[i][j]==m){\n\t    rep(l,8){\n\t      int a=1;\n\t      while(1){\n\t\tint nx=i+dx[l]*a;\n\t\tint ny=j+dy[l]*a;\n\t\tif(nx<0 || nx>7 || ny<0 || ny>7 || s[nx][ny]=='.')break;\n\t\tif(k%2==0 && s[nx][ny]=='o'){\n\t\t  for(;a>=0;a--)s[i+dx[l]*a][j+dy[l]*a]='o';\n\t\t  break;\n\t\t}\n\t\ta++;\n\t      }\n\t    }\n\t    goto END;\n\t  }\n    }\n  END:;\n  }\n  rep(i,8)cout<<s[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int MAX = 8;\nchar m[MAX][MAX];\nint dx[] = {0,0,1,-1,1,1,-1,-1};\nint dy[] = {1,-1,0,0,1,-1,1,-1};\nstruct Pos{\n  int x,y,n;\n  Pos(int a,int b,int c):x(a),y(b),n(c){}\n};\n\nvoid input(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      cin >> m[i][j];\n}\n\n\nbool isInside(int x, int y){return 0<=x&&x<MAX&&0<=y&&y<MAX;}\n\n\nbool turnable(int x, int y, char c, int dir){\n  \n  int nx = x+dx[dir];\n  int ny = y+dy[dir];\n  bool flg = false;\n  while(isInside(nx,ny) && m[ny][nx] != '.'){\n    if(c != m[ny][nx]) flg = true;\n    if(c == m[ny][nx]) return flg;\n    nx += dx[dir];\n    ny += dy[dir];\n  }\n  return false;\n}\n\nint turn(int y, int x, char c){\n\n  if(m[y][x] != '.') return -1;\n\n  int tmp = -1;\n  int sum = 0;\n  bool valid = false;\n  for(int i = 0; i < 8; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    bool flg = false;\n    int step = 0;\n    while(isInside(nx,ny) && m[ny][nx] != '.'){\n      step++;\n      if(c != m[ny][nx]) flg = true;\n      if(c == m[ny][nx]){\n\tvalid = valid||flg;\n\tif(flg) sum += step-1;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  if(valid) tmp = max(tmp,sum);\n  return tmp;\n}\n\nvoid choose(Pos& p,char c){\n\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++){\n      int tmp = turn(i,j,c);\n      if(c == 'x' && tmp >= p.n) p = Pos(j,i,tmp);\n      if(c == 'o' && tmp > p.n) p = Pos(j,i,tmp);\n    }\n}\n\n\nvoid put(int x, int y, char c){\n\n  m[y][x] = c;\n\n  for(int i = 0; i < 8; i++)\n    if(turnable(x,y,c,i)){\n      int nx = x;\n      int ny = y;\n      while(m[ny+=dy[i]][nx+=dx[i]] != c) m[ny][nx] = c; \n\n    }\n}\n\nvoid print(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++) cout << m[i][j];\n    cout << endl;\n  }\n}\n\nvoid solve(){\n\n  int rev = 0;\n  while(1){\n    char c[] = {'o','x'};\n    bool update = false;\n    for(int i = 0; i < 2; i++){\n      Pos p(0,0,-1);\n      choose(p,c[i]);\n      if(p.n != -1){\n\tupdate = true;\n\tput(p.x,p.y,c[i]);\n      }\n    }\n    if(!update) break;\n  }\n}\n\n\n\nint main(){\n\n  input();\n  solve();\n  print();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 8;\nchar m[8][9];\nchar op[]={'o','x'};\nenum{MAMI=0,CHA=1};\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\n\nvoid output(){\n  rep(i,8)cout << m[i] << endl;\n  cout <<\"output end \" << endl;\n}\n\nbool ok(int who,int y,int x,int i,int j){\n  if (who == MAMI){\n    if (y != i)return i < y;//ue\n    return j < x;//hidari\n  }else {\n    if (y != i)return i > y;//sita\n    return j > x;//migi\n  }\n  return false;\n}\n\nint configure(int me,int you,int y,int x,bool isCount){\n  int cnt=0;\n  rep(i,8){\n    int nex=x+dx[i],ney=y+dy[i];\n    int tmp=0;\n    bool isok=false;\n    while(nex != -1 && ney != -1 && nex != N && ney != N){\n      if (m[ney][nex] == op[me]){isok=true;break;}\n      else if(m[ney][nex] == op[you])tmp++;\n      else break;\n      nex+=dx[i];\n      ney+=dy[i];\n    }\n    if (isok)cnt+=tmp;\n    if (!isok)continue;\n    if (isCount)continue;\n    nex=x+dx[i];\n    ney=y+dy[i];\n    while(nex != -1 && ney != -1 && nex != N && ney != N){\n      if (m[ney][nex] == op[me]){break;}\n      else if(m[ney][nex] == op[you])m[ney][nex]=op[me];\n      else break;\n      nex+=dx[i];\n      ney+=dy[i];\n    }\n  }\n  return cnt;\n}\n\nbool canput(int who){\n  int get=0,y=-1,x=-1;\n  rep(i,8){\n    rep(j,8){\n      if (m[i][j] != '.')continue;\n      int cnt=configure(who,1-who,i,j,true);\n      if (cnt == 0)continue;\n      if (cnt > get){\n        y=i;\n        x=j;\n        get=cnt;\n      }else if (cnt == get && ok(who,y,x,i,j)){\n        y=i;\n        x=j;\n        get=cnt;\n      }\n    }\n  }\n  //output();\n  if (get != 0)configure(who,1-who,y,x,false),m[y][x]=op[who];\n  //cout << y <<\" \" << x <<\" \" << get << endl;\n  //output();\n  //exit(1);\n  return get != 0;\n}\n\nmain(){\n  while(cin>>m[0]){\n    REP(i,1,8)cin>>m[i];\n    int now=0,fail=0;;\n    while(fail < 2){\n      //output();\n      if (!canput(now))fail++;\n      else fail=0;\n      now=(now+1)%2;\n      //cout << now <<\" \" << fail << endl;\n    }\n    rep(i,8)cout << m[i]<<endl;\n    \n#ifdef DEBUG\n    cout <<\"end\" << endl;\n#endif\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nchar map[10][10];\n\nint dx[]={-1,0,1,-1,0,1,-1,0,1}, dy[]={1,1,1,0,0,0,-1,-1,-1};\nint cnt(int x, int y, int n, int dir, char me) {\n    if(!(x>=0 && y>=0 && x<8 && y<8)) return 0;\n    if(map[y][x] == '.') return 0;\n    if(map[y][x] == me) return n-1;\n    return cnt(x+dx[dir], y+dy[dir], n+1, dir, me);\n}\nint cnt(int x, int y, char me) {\n    int res=0;\n    for(int i=0; i<9; i++)\n        res+=cnt(x+dx[i],y+dy[i],1,i,me);\n    return res;\n}\nbool replace(int x, int y, int n, int dir, char me) {\n    if(!(x>=0 && y>=0 && x<8 && y<8)) return false;\n    if(map[y][x] == '.') return false;\n    if(map[y][x] == me) return true;\n\n    bool res=replace(x+dx[dir], y+dy[dir], n+1, dir, me);\n    if(res)\n        map[y][x] = me;\n    return res;\n}\nvoid replace(int x, int y, char me) {\n    map[y][x] = me;\n    for(int i=0; i<9; i++)\n        replace(x+dx[i],y+dy[i],1,i,me);\n}\nbool finish() {\n    for(int i=0; i<8; i++)\n        for(int j=0; j<8; j++)\n            if(map[j][i] == '.') return false;\n    return true;\n}\nint main(void) {\n    for(int j=0; j<8; j++)\n        scanf(\"%s\",map[j]);\n\n    char c[]={'o','x'};\n    bool flag=false;\n    for(int turn=0; ; turn=1-turn) {\n        int rx,ry,max=0;\n        for(int i=0; i<8; i++)\n            for(int j=0; j<8; j++) {\n                if(map[i][j] != '.') continue;\n                int t = cnt(j,i,c[turn]);\n                if(turn)\n                    if(max<=t)\n                        max=t, rx=j, ry=i;\n                    else;\n                else\n                    if(max<t)\n                        max=t, rx=j, ry=i;\n            }\n        if(max) replace(rx, ry, c[turn]),flag=false;\n        else\n            if(flag) break;\n            else flag=true;\n    }\n\n    for(int j=0; j<8; j++)\n        printf(\"%s\\n\",map[j]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px) - 1, abs(y - py) - 1);\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px || qy != py) {\n\t\t\t\t\tc[qy][qx] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) {\n\t\t\t\tv = 1; t++; continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tplace(x, y, t++ % 2 == 0 ? 'o' : 'x', true);\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n;i++)\nvector<vector<char>>s(8,vector<char>(8));\nbool inrange(int y,int x){return (0<=y&&y<8&&0<=x&&x<8);}\nbool foo=false;\nint cnt,ty,tx;\nvoid init(){foo=false; cnt=0;}\nvoid _set(int a,int b){ty=a;tx=b;cnt=0; foo=false;}\nvoid update(int y,int x,char key){\n    vector<vector<char>>temp;\n    temp=s;\n    init();\n    temp[y][x]=key;\n    for(int i=x+1; i<8;i++){\n        if(temp[y][i]==key){foo=true; break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y][x+1+i]=key;\n    init();\n    for(int i=x-1; i>=0; i--){\n        if(temp[y][i]==key){foo=true;break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y][x-1-i]=key;\n    init();\n    for(int i=y+1; i<8;i++){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+i+1][x]=key;\n    init();\n    for(int i=y-1;i>=0;i--){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-1-i][x]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+1+i][x+1+i]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y+1+i][x-1-i]=key;\n    _set(y, x);\n    for(int i=0; i<8;i++){\n        --ty;--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-1-i][x-1-i]=key;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        --ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)rep(i,cnt)temp[y-i-1][x+1+i]=key;\n    s=temp;\n    \n}\nint cal(int y,int x, char key){\n    vector<vector<char>>temp;\n    temp=s;\n    temp[y][x]=key;\n    int ans=0;\n    init();\n    for(int i=x+1; i<8;i++){\n        if(temp[y][i]==key){foo=true; break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=x-1; i>=0; i--){\n        if(temp[y][i]==key){foo=true;break;}\n        if(temp[y][i]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=y+1; i<8;i++){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    for(int i=y-1;i>=0;i--){\n        if(temp[i][x]==key){foo=true; break;}\n        if(temp[i][x]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    init();\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        ++ty,--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y, x);\n    for(int i=0; i<8;i++){\n        --ty;--tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    _set(y,x);\n    for(int i=0; i<8;i++){\n        --ty,++tx;\n        if(!inrange(ty,tx))break;\n        if(temp[ty][tx]==key){foo=true;break;}\n        if(temp[ty][tx]=='.')break;\n        cnt++;\n    }\n    if(foo)ans+=cnt;\n    return ans;\n}\n\nint main(){\n    rep(i,8)rep(j,8)cin>>s[i][j];\n    char key='o';\n    bool flag=false;\n    while(true){\n        int maxi=0;\n        pair<int,int>let;\n        if(key=='o'){\n            for(int i=0; i<8;i++){\n                for(int j=0; j<8;j++){\n                    if(s[i][j]!='.')continue;\n                    int t=cal(i,j,key);\n                    if(t>maxi){\n                        maxi=t;\n                        let=pair<int,int>(i,j);\n                    }\n                }\n            }\n        }else{\n            for(int i=7; i>=0;i--){\n                for(int j=7; j>=0;j--){\n                    if(s[i][j]!='.')continue;\n                    int t=cal(i,j,key);\n                    if(t>maxi){\n                        maxi=t;\n                        let=pair<int,int>(i,j);\n                    }\n                }\n            }\n            \n        }\n        if(flag&&maxi==0)break;\n        else flag=false;\n        if(maxi==0){flag=true;continue;}\n        update(let.first,let.second,key);\n        key=(key=='o'?'x':'o');\n    }\n    rep(i,8){rep(j,8)cout<<s[i][j]; cout<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\n\nbool outrange(int x, int y) {\n    return x < 0 || y < 0 || x > 7 || y > 7;\n}\n\nbool act(vector<string>& fld, bool turn) {\n    const char myCookie = turn ? 'x' : 'o';\n    const char eneCookie = turn ? 'o' : 'x';\n    tuple<int, int, int, int, int> score(-1, -1, -1, 0, 0);\n    rep(y, 8) rep(x, 8) if(fld[y][x] == '.') {\n        REP(i, -1, 2) REP(j, -1, 2) {\n            if(i == 0 && j == 0) continue;\n            int nx = x + i, ny = y + j;\n            if(outrange(nx, ny)) continue;\n            if(fld[ny][nx] != eneCookie) continue;\n            int cnt = 1;\n            while(!outrange(nx, ny) && fld[ny][nx] == eneCookie)\n              cnt++, nx += i, ny += j;\n            if(!outrange(nx, ny) && fld[ny][nx] == myCookie) {\n                if(turn)\n                  score = max(score, make_tuple(cnt, y, x, j, i));\n                else\n                  score = max(score, make_tuple(cnt, -y, -x, j, i));\n            }\n        }\n    }\n    int a, ny, nx, i, j; tie(a, ny, nx, j, i) = score;\n    if(a == -1) return true;\n    else {\n        if(!turn) ny *= -1, nx *= -1;\n        fld[ny][nx] = myCookie;\n        nx += i, ny += j;\n        while(fld[ny][nx] == eneCookie)\n          fld[ny][nx] = myCookie, nx += i, ny += j;\n        return false;\n    }\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    vector<string> fld(8);\n    for(auto& s : fld) cin >> s;\n    bool flag = false;\n    for(int turn = 0; ; turn++) {\n        if(act(fld, turn & 1)) {\n            if(flag) break;\n            flag = true;\n        }\n        else\n          flag = false;\n    }\n    for(const auto& s : fld) cout << s << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\ntypedef vector<string> VS;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\ntemplate<typename T>\nvoid dump(T a, int n) { for (int i = 0; i < n; i++) cout << a[i] << (i == n - 1 ? '\\n' : ' '); }\n\ntemplate<typename T>\nvoid dump(T a) { dump<T>(a, a.size()); }\n\nconstexpr int dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconstexpr int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nbool can_reverse(VS &S, int y, int x, int di, bool is_mami) {\n\tint i = 0;\n\twhile (true) {\n\t\tx += dx[di];\n\t\ty += dy[di];\n\n\t\tif (x < 0 || y < 0 || x >= 8 || y >= 8 || S[y][x] == '.') {\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\n\t\tif (S[y][x] == (is_mami ? 'o' : 'x')) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\nbool simulation(VS &S, int y0, int x0, bool is_mami) {\n\tif (S[y0][x0] != '.') {\n\t\treturn false;\n\t}\n\t\n\tS[y0][x0] = is_mami ? 'o' : 'x';\n\n\tbool flg = false;\n\tfor (int i = 0; i < 8; i++) {\n\t\tif (!can_reverse(S, y0, x0, i, is_mami)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = x0;\n\t\tint y = y0;\n\t\t\n\n\t\twhile (true) {\n\t\t\tx += dx[i];\n\t\t\ty += dy[i];\n\n\t\t\tif (x < 0 || y < 0 || x >= 8 || y >= 8\n\t\t\t\t\t|| S[y][x] == '.'\n\t\t\t\t\t|| S[y][x] == (is_mami ? 'o' : 'x')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[y][x] = is_mami ? 'o' : 'x';\n\t\t\tflg |= true;\n\t\t}\n\t}\n\n\treturn flg;\n}\n\nint counter(VS &S, bool is_mami) {\n\tint cnt = 0;\n\t\n\tfor (int i = 0; i < 8; i++) {\n\t\tcnt += count(S[i].begin(), S[i].end(), is_mami ? 'o' : 'x');\n\t}\n\n\treturn cnt;\n}\n\nint main(void) {\n\tVS S(8);\n\tfor (auto &s : S) cin >> s;\n\n\tbool is_mami = true;\n\tbool cannot = false;\n\twhile(true) {\n\t\tVS max_next;\n\t\tint now = counter(S, is_mami);\n\t\tint max_cookie = -1;\n\t\t\n\t\tfor (int y = 0; y < 8; y++) {\n\t\t\tfor (int x = 0; x < 8; x++) {\t\n\t\t\t\tVS next(S);\n\n\t\t\t\tif (!simulation(next, y, x, is_mami)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint cookie = counter(next, is_mami);\n\t\t\t\tif (cookie != now &&\n\t\t\t\t\t\t((is_mami && cookie > max_cookie) || \n\t\t\t\t\t\t (!is_mami && cookie >= max_cookie))) {\n\t\t\t\t\tmax_cookie = cookie;\n\t\t\t\t\tmax_next = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (max_cookie == -1) {\n\t\t\tif (cannot) {\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tcannot = true;\n\t\t\t\tis_mami = !is_mami;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tcannot = false;\n\t\tS = max_next;\n\t\tis_mami = !is_mami;\n\t}\n\n\tfor (auto s : S) cout << s << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <cstring>\n#include <queue>\n#include <sys/time.h>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\n#define gcd(a,b) __gcd((a),(b))\n#define lcm(a,b) ( (a)/__gcd((a),(b))*(b) )\n\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nint board[10][10];\nint dx[] = {0,1,0,-1,1,-1,1,-1};\nint dy[] = {1,0,-1,0,1,-1,-1,1};\n\nint rev(int c,int x,int y,int d ,int depth,int flag){\n\tif(depth == 0 && board[y][x] != -1 && flag == 0) return 0;\n\t//cout << x << \" \" << y << \" \" << board[y][x] << endl;\n\tif(depth != 0 && board[y][x] == -1) return 0;\n\tif(depth == 1 && board[y][x] == c) return 0;\n\tif(depth >= 2 && c == board[y][x]){ return depth-1; }\n\tint r = rev(c,x+dx[d],y+dy[d],d,depth+1,flag);\n\tif(r){\n\t\tif(flag) board[y][x] = c;\n\t\t\n\t\treturn r;\n\t}\n\treturn 0;\n\t\n}\n\nint ableCnt(int c,int x,int y,bool flag){\n\tint cnt = 0;\n\trep(i,8){\n\t\tcnt += rev(c,x,y,i,0,flag);\n\t}\n\treturn cnt;\n}\n\n\nint main(){\n\tint turn = 0;\n\trep(i,10)rep(j,10)board[i][j] = -1;\n\tfor(int i = 1 ; i <= 8 ; i++)\n\tfor(int j = 1 ; j <= 8 ; j++){char c; cin >> c; board[i][j] = c == '.' ? -1 : c == 'o' ? 0 : 1;}\n\tbool prev_passed = 0;\n\n\twhile(1){\n\t\tint mx = -1 , px = -1, py = -1;\n\t\tif(turn == 0){\n\t\t\trep(i,8)rep(j,8){\n\t\t\t\t int get = ableCnt(turn,j+1,i+1,0);\n\t\t\t\t if( mx < get){\n\t\t\t\t\tmx = get;\n\t\t\t\t\tpx = j+1;\n\t\t\t\t\tpy = i+1;\n\t\t\t\t }\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 7 ; i >= 0 ; i--){\n\t\t\t\tfor(int j = 7 ; j >= 0 ; j--){\n\t\t\t\t int get = ableCnt(turn,j+1,i+1,0);\n\t\t\t\t if( mx < get){\n\t\t\t\t\tmx = get;\n\t\t\t\t\tpx = j+1;\n\t\t\t\t\tpy = i+1;\n\t\t\t\t }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mx == 0){\n\t\t\tif(prev_passed)break;\n\t\t\telse prev_passed = true;\n\t\t}else{\n\t\t\tableCnt(turn,px,py,1);\n\t\t\tprev_passed = false;\n\t\t}\n\t\tturn ^= 1;\n\t}\n\trep(i,8){ rep(j,8) cout << (board[i+1][j+1]==-1?'.':board[i+1][j+1]==0?'o':'x');cout << endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n\n#define BLACK 1\n#define WHITE 10\n#define NORMAL 0\n\n#define DEBUG 0\n\nusing namespace std;\n\nclass Point{\n\npublic:\n\tint x, y;\n\n};\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint isIn(int x, int y){\n\tif (x < 0 || 9<=x || y < 0 || 9<=y){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}\n\nint isEqualColor(int x, int y, int **data,int color){\n\tif (data[y][x] == color){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint changeColorNum(Point start, Point end){\n\treturn max(abs(start.x - end.x)-1, abs(start.y - end.y)-1);\n}\n\nPoint searchNextCookie(Point start, int **data, int direction,int color){\n\n\tint dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\tint dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\tPoint p;\n\tp.x = -1;\n\tp.y = -1;\n\n\tfor (int i = 1;; i++){\n\t\tint nowX = start.x + dx[direction] * i;\n\t\tint nowY = start.y + dy[direction] * i;\n\t\tif (isIn(nowX, nowY)==0){\n\t\t\tbreak;\n\t\t}\n\t\tif (isEqualColor(nowX, nowY, data, NORMAL)){\n\t\t\tbreak;\n\t\t}\n\n\t\tif (isEqualColor(nowX, nowY, data, color)){\n\t\t\tp.x = nowX;\n\t\t\tp.y = nowY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nvoid changeData(Point point, int **data,int turn){\n\n\tdata[point.y][point.x] = turn;\n\t\n\tint dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\tint dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\tfor (int i = 0; i < 8; i++){\n\t\tif (searchNextCookie(point, data, i, turn).x != -1){\n\n\t\t\tfor (int j = 1;; j++){\n\t\t\t\tPoint next;\n\t\t\t\tnext.x = point.x + dx[i] * j;\n\t\t\t\tnext.y = point.y + dy[i] * j;\n\t\t\t\tif (isEqualColor(next.x, next.y, data, turn)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdata[next.y][next.x] = turn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid show(int **data){\n\tfor (int i = 1; i < 9; i++){\n\t\tfor (int j = 1; j < 9; j++){\n\t\t\tif (data[i][j] == BLACK){\n\t\t\t\tcout << 'o';\n\t\t\t}\n\t\t\telse if (data[i][j] == WHITE){\n\t\t\t\tcout << 'x';\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << '.';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tif (DEBUG)cout << endl;\n}\n\nint changeTurn(int turn){\n\tif (turn == BLACK){\n\t\treturn WHITE;\n\t}\n\telse{\n\t\treturn BLACK;\n\t}\n}\n\nint main(){\n\n\tint **data = new int *[10];\n\tfor (int i = 0; i < 10; i++){\n\t\tdata[i] = new int[10];\n\t}\n\tchar tmp;\n\n\tfor (int i = 1; i < 9; i++){\n\t\tfor (int j = 1; j < 9; j++){\n\t\t\tcin >> tmp;\n\t\t\tif (tmp == 'o'){\n\t\t\t\tdata[i][j] = BLACK;\n\t\t\t}\n\t\t\telse if (tmp == 'x'){\n\t\t\t\tdata[i][j] = WHITE;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdata[i][j] = NORMAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (DEBUG)show(data);\n\n\tint turn = WHITE;\n\tint breakCnt = 0;\n\twhile (1){\n\t\tturn = changeTurn(turn);\n\t\tif (breakCnt >= 2){\n\t\t\tbreak;\n\t\t}\n\n\n\t\tint changeNum = 0;\n\t\tPoint maxP;\n\t\tmaxP.x = -1;\n\t\tmaxP.y = -1;\n\n\t\t//????????´???????±?????????????\n\t\tfor (int i = 1; i < 9; i++){\n\t\t\tfor (int j = 1; j < 9; j++){\n\t\t\t\tif (isEqualColor(j, i, data, NORMAL)){\n\t\t\t\t\tint nowChangeNum = 0;\n\t\t\t\t\tPoint start;\n\t\t\t\t\tstart.x = j, start.y = i;\n\t\t\t\t\tfor (int k = 0; k < 8; k++){\n\t\t\t\t\t\tPoint next = searchNextCookie(start, data, k, turn);\n\t\t\t\t\t\tif (next.x == -1)continue;\n\n\t\t\t\t\t\tnowChangeNum += changeColorNum(start, next);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (turn == BLACK){\n\t\t\t\t\t\tif (changeNum < nowChangeNum && nowChangeNum != 0){\n\t\t\t\t\t\t\tmaxP.x = start.x;\n\t\t\t\t\t\t\tmaxP.y = start.y;\n\t\t\t\t\t\t\tchangeNum = nowChangeNum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (changeNum <= nowChangeNum && nowChangeNum != 0){\n\t\t\t\t\t\t\tmaxP.x = start.x;\n\t\t\t\t\t\t\tmaxP.y = start.y;\n\t\t\t\t\t\t\tchangeNum = nowChangeNum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (maxP.x == -1){\n\t\t\tbreakCnt++;\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tbreakCnt = 0;\n\t\t}\n\n\n\t\tchangeData(maxP, data, turn);\n\n\t\tif (DEBUG)show(data);\n\t}\n\n\tshow(data);\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst long long MOD = 1000000007;\nconst long long INF = MOD + 1;\nconst long double PI = 3.1415926;\n#define FOR(i, r, n) for(int i=(ll)(r); i<(ll)(n); i++) \n#define REP(i, n) FOR(i, (0), n)\n#define ALL(r) r.begin(), r.end()\n#define ll long long int\nusing namespace std;\nstring s;\nvector<ll> v;\nvector<pair<ll, ll>> vp;\nvector<vector<ll>> vv(110, vector<ll>(110, INF));\nvector<tuple<ll, ll, ll>> vt;\nset<ll> st;\nmap<char, ll> mp;\n\nvector<string> vs;\n\nint solve(bool ismami)\n{\n\tint x, y, dir, tmp, point = 0, px = -1, py = -1, pdir = -1;\n\tmap<pair<int, int>, int> mdir;\n\tREP(i, 8)\n\t\tREP(j, 8)\n\t{\n\t\tif (vs[i][j] == '.')\n\t\t{\n\t\t\tdir = 9;\n\t\t\tint cnt = 0;\n\t\t\twhile (dir--) {\n\t\t\t\ttmp = 0;\n\t\t\t\tif (!dir) break;\n\t\t\t\tx = i; y = j;\n\t\t\t\tif (dir == 8)\n\t\t\t\t{\n\t\t\t\t\tx--; y--;\n\t\t\t\t}\n\t\t\t\telse if (dir == 7) y--;\n\t\t\t\telse if (dir == 6)\n\t\t\t\t{\n\t\t\t\t\tx++; y--;\n\t\t\t\t}\n\t\t\t\telse if (dir == 5) x++;\n\t\t\t\telse if (dir == 4)\n\t\t\t\t{\n\t\t\t\t\tx++; y++;\n\t\t\t\t}\n\t\t\t\telse if (dir == 3) y++;\n\t\t\t\telse if (dir == 2)\n\t\t\t\t{\n\t\t\t\t\tx--; y++;\n\t\t\t\t}\n\t\t\t\telse if (dir == 1) x--;\n\t\t\t\twhile (x > -1 && y > -1 && x < 8 && y < 8)\n\t\t\t\t{\n\t\t\t\t\tif (ismami) {\n\t\t\t\t\t\tif (vs[x][y] == 'x') tmp++;\n\t\t\t\t\t\telse if (vs[x][y] == '.') break;\n\t\t\t\t\t\telse if (vs[x][y] == 'o') {\n\t\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\t\tcnt += tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (vs[x][y] == 'o') tmp++;\n\t\t\t\t\t\telse if (vs[x][y] == '.') break;\n\t\t\t\t\t\telse if (vs[x][y] == 'x') {\n\t\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\t\tcnt += tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dir == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tx--; y--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == 7) y--;\n\t\t\t\t\telse if (dir == 6)\n\t\t\t\t\t{\n\t\t\t\t\t\tx++; y--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == 5) x++;\n\t\t\t\t\telse if (dir == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tx++; y++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == 3) y++;\n\t\t\t\t\telse if (dir == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tx--; y++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == 1) x--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (point < cnt&&ismami)\n\t\t\t{\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t\tpoint = cnt;\n\t\t\t}\n\t\t\telse if (point <= cnt && !ismami) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t\tpoint = cnt;\n\t\t\t}\n\t\t}\n\t}\n\tif (!point) return 1;\n\telse {\n\t\tx = px, y = py;\n\t\tif (ismami) {\n\t\t\tvs[x][y] = 'o';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvs[x][y] = 'x';\n\t\t}\n\t\tdir = 9;\n\t\twhile (dir--) {\n\t\t\tif (!dir) break;\n\t\t\tint step = 0;\n\t\t\tx = px, y = py;\n\t\t\tif (dir == 8)\n\t\t\t{\n\t\t\t\tx--; y--;\n\t\t\t}\n\t\t\telse if (dir == 7) y--;\n\t\t\telse if (dir == 6)\n\t\t\t{\n\t\t\t\tx++; y--;\n\t\t\t}\n\t\t\telse if (dir == 5) x++;\n\t\t\telse if (dir == 4)\n\t\t\t{\n\t\t\t\tx++; y++;\n\t\t\t}\n\t\t\telse if (dir == 3) y++;\n\t\t\telse if (dir == 2)\n\t\t\t{\n\t\t\t\tx--; y++;\n\t\t\t}\n\t\t\telse if (dir == 1) x--;\n\t\t\twhile (x > -1 && y > -1 && x < 8 && y < 8)\n\t\t\t{\n\t\t\t\tif (ismami) {\n\t\t\t\t\tif (vs[x][y] == 'x') step++;\n\t\t\t\t\telse if (vs[x][y] == '.') break;\n\t\t\t\t\telse if (vs[x][y] == 'o') {\n\t\t\t\t\t\tif(step)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tREP(i,step)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (dir == 8)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx++; y++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 7) y++;\n\t\t\t\t\t\t\t\telse if (dir == 6)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx--; y++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 5) x--;\n\t\t\t\t\t\t\t\telse if (dir == 4)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx--; y--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 3) y--;\n\t\t\t\t\t\t\t\telse if (dir == 2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx++; y--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 1) x++;\n\t\t\t\t\t\t\t\tvs[x][y] = 'o';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (vs[x][y] == 'o') step++;\n\t\t\t\t\telse if (vs[x][y] == '.') break;\n\t\t\t\t\telse if (vs[x][y] == 'x') {\n\t\t\t\t\t\tif (step)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tREP(i, step)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (dir == 8)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx++; y++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 7) y++;\n\t\t\t\t\t\t\t\telse if (dir == 6)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx--; y++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 5) x--;\n\t\t\t\t\t\t\t\telse if (dir == 4)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx--; y--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 3) y--;\n\t\t\t\t\t\t\t\telse if (dir == 2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx++; y--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dir == 1) x++;\n\t\t\t\t\t\t\t\tvs[x][y] = 'x';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dir == 8)\n\t\t\t\t{\n\t\t\t\t\tx--; y--;\n\t\t\t\t}\n\t\t\t\telse if (dir == 7) y--;\n\t\t\t\telse if (dir == 6)\n\t\t\t\t{\n\t\t\t\t\tx++; y--;\n\t\t\t\t}\n\t\t\t\telse if (dir == 5) x++;\n\t\t\t\telse if (dir == 4)\n\t\t\t\t{\n\t\t\t\t\tx++; y++;\n\t\t\t\t}\n\t\t\t\telse if (dir == 3) y++;\n\t\t\t\telse if (dir == 2)\n\t\t\t\t{\n\t\t\t\t\tx--; y++;\n\t\t\t\t}\n\t\t\t\telse if (dir == 1) x--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tvs.resize(8);\n\tREP(i, 8) cin >> vs[i];\n\tint cnt = 0;\n\twhile (cnt < 2)\n\t{\n\t\tcnt = 0;\n\t\tcnt += solve(true);\n\t\tcnt += solve(false);\n\t}\n\tREP(i, 8) cout << vs[i] << endl;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nusing namespace std;\n\nint di[]={-1,0,1,0,-1,1,1,-1};\nint dj[]={0,1,0,-1,1,1,-1,-1};\n\nchar t[8][8],ch,turn='o';\n\nchar u[8][8];\n\nint calc(int I,int J,char turn){\n  u[I][J]=turn;\n  int i,j,k,l,sum=0,cnt;\n  for(k=0;k<8;k++){\n    i=I;\n    j=J;\n    cnt=0;\n    while(1){\n      i+=di[k];\n      j+=dj[k];      \n      if(i<0||j<0||i>=8||j>=8||t[i][j]=='.'){\n        cnt=0;\n        break;\n      }\n      if(t[i][j]==turn){\n        break;\n      }\n      cnt++;\n    }\n    sum+=cnt;\n    i=I;\n    j=J;\n    for(l=0;l<cnt;l++){\n      i+=di[k];\n      j+=dj[k];      \n      u[i][j]=turn;\n    }\n  }\n  return sum;\n}\n\nint func(){\n  int i,j,I,J,X;\n  int ci,cj,maxm=0;\n\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++){\n      I=i;\n      J=j;\n      if(turn=='x'){\n        I=7-i;\n        J=7-j;\n      }\n      if(t[I][J]!='.')continue;\n      X=calc(I,J,turn);    \n      if(X <= maxm)continue;\n      maxm=X;\n      ci=I;\n      cj=J;\n    }\n  }\n\n  if(maxm==0)return 0;\n  \n  for(i=0;i<8;i++)for(j=0;j<8;j++)u[i][j]=t[i][j];\n  calc(ci,cj,turn);\n  for(i=0;i<8;i++)for(j=0;j<8;j++)t[i][j]=u[i][j];\n  \n  return 1;\n}\n\nint main(){\n  int i,j;\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++)scanf(\"%c\",&t[i][j]);\n    scanf(\"%c\",&ch);\n  }\n  int c=0;\n  while(1){\n    if(c==2)break;\n    int x=func();\n    if(x==0)c++;\n    else c=0;\n    if(turn=='o')turn='x';\n    else turn='o';\n  }\n  \n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++)printf(\"%c\",t[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define n 8\nchar a[n+2][n+2];\nint main(void)\n{\n    int i, j, mami, pass;\n    for(i=1;i<=n;++i)\n        scanf(\"%s\", a[i]+1);\n    mami=1;\n    pass=0;\n    while (pass<2) {\n        int besti=-1, bestj=-1, maxcnt=0;\n        if (mami) {\n            for(i=1;i<=n;++i) for(j=1;j<=n;++j) if (a[i][j]=='.') {\n                int k, l, cnt=0;\n                for(k=-1;k<2;++k) for(l=-1;l<2;++l) {\n                    int ii=i+k, jj=j+l, c=0;\n                    if (k==0&&l==0) continue;\n                    if (a[ii][jj]!='x') continue;\n                    while (ii>=1 && jj>=1 && ii<=n && jj<=n && a[ii][jj]=='x') {\n                        ii+=k;\n                        jj+=l;\n                        ++c;\n                    }\n                    if (a[ii][jj]=='o') cnt+=c;\n                }\n                if (maxcnt<cnt) { maxcnt=cnt; besti=i; bestj=j; }\n            }\n            if (maxcnt) {\n                int k, l;\n                for(k=-1;k<2;++k) for(l=-1;l<2;++l) {\n                    int ii=besti+k, jj=bestj+l, c=0;\n                    if (k==0&&l==0) continue;\n                    if (a[ii][jj]!='x') continue;\n                    while (ii>=1 && jj>=1 && ii<=n && jj<=n && a[ii][jj]=='x') {\n                        ii+=k;\n                        jj+=l;\n                    }\n                    if (a[ii][jj]=='o') {\n                        while (ii!=besti || jj!=bestj) {\n                            a[ii][jj]='o';\n                            ii-=k;\n                            jj-=l;\n                        }\n                        a[ii][jj]='o';\n                    }\n                }\n                pass=0;\n            }\n            else {\n                pass++;\n            }\n        }\n        else {\n            for(i=n;i>0;--i) for(j=n;j>0;--j) if (a[i][j]=='.') {\n                int k, l, cnt=0;\n                for(k=-1;k<2;++k) for(l=-1;l<2;++l) {\n                    int ii=i+k, jj=j+l, c=0;\n                    if (k==0&&l==0) continue;\n                    if (a[ii][jj]!='o') continue;\n                    while (ii>=1 && jj>=1 && ii<=n && jj<=n && a[ii][jj]=='o') {\n                        ii+=k;\n                        jj+=l;\n                        ++c;\n                    }\n                    if (a[ii][jj]=='x') cnt+=c;\n                }\n                if (maxcnt<cnt) { maxcnt=cnt; besti=i; bestj=j; }\n            }\n            if (maxcnt) {\n                int k, l;\n                for(k=-1;k<2;++k) for(l=-1;l<2;++l) {\n                    int ii=besti+k, jj=bestj+l, c=0;\n                    if (k==0&&l==0) continue;\n                    if (a[ii][jj]!='o') continue;\n                    while (ii>=1 && jj>=1 && ii<=n && jj<=n && a[ii][jj]=='o') {\n                        ii+=k;\n                        jj+=l;\n                    }\n                    if (a[ii][jj]=='x') {\n                        while (ii!=besti || jj!=bestj) {\n                            a[ii][jj]='x';\n                            ii-=k;\n                            jj-=l;\n                        }\n                        a[ii][jj]='x';\n                    }\n                }\n                pass=0;\n            }\n            else {\n                pass++;\n            }\n        }\n        mami=1-mami;\n    }\n    for(i=1;i<=n;++i) {\n        for(j=1;j<=n;++j) putchar(a[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\ni,j,n,max[6];\ndx[8]={1,1,0,-1,-1,-1,0,1};\ndy[8]={0,1,1,1,0,-1,-1,-1};\nchar table[10][10],mark[2]={'o','x'};\n \nint l(int dx,int dy,int x,int y,char m,int count){\n  if(table[x][y]=='.'||table[x][y]=='0')return 0;\n  if(table[x][y]==m)r count;\n  r l(dx,dy,x+dx,y+dy,m,count+1);\n}\nint search(int x,int y,char m){\n  int k,count;\n  count = 0;\n  if(table[x][y]!='.')return 0;\n  for(k=0;k<8;k++){\n    count += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  return count;\n}\nint okikae2(int dx,int dy,int x,int y,char m){\n  if(table[x][y]=='0'||table[x][y]=='.')return 0;\n  else if(table[x][y]==m)return 1;\n  else if(okikae2(dx,dy,x+dx,y+dy,m)){\n    table[x][y]=m;\n    return 1;\n  }\n  else return 0;\n}\nint okikae(int x,int y,char m){\n  int k;\n  table[x][y]=m;\n  for(k=0;k<8;k++){\n    okikae2(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  return 0;\n}\n \nint main(){\n  for(i=0;i<10;i++)table[0][i]=table[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&table[i][1]);\n    table[i][0]='0';\n    table[i][9]='0';\n  }\n  max[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    max[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(max[n]<search(i,j,mark[n])){\n          max[2+n]=i;\n          max[4+n]=j;\n          max[n]=search(i,j,mark[n]);\n        }\n      }\n    }\n    if(max[n]!=0)okikae(max[2+n],max[4+n],mark[n]);\n    if(max[0]==0&&max[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",table[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int u,int v,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};char t[10][10],g[2]={'o','x'};l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(u,v,x+u,y+v,m,c+1);}s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(u,v,x+u,y+v,m,0)){t[x][y]=m;r 1;}else r 0;}o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}main(){for(i=0;i<10;)t[0][i]=t[9][i++]='0';for(i=1;i<9;t[i][0]=t[i++][9]='0')scanf(\"%s\",&t[i][1]);for(n=f[1]=-1;f[n]=-1;n=(n+1)%2){for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,g[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,g[n],0):0;f[n]!=0?o(0,0,f[2+n],f[4+n],g[n],0):0;if(f[0]==0&&f[1]==0)break;}for(i=1;i<9;i++,puts(\"\"))for(j=1;j<9;j++)printf(\"%c\",t[i][j]);r 0;}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};char t[10][10],mark[2]={'o','x'};l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}else r 0;}o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}main(){for(i=0;i<10;i++)t[0][i]=t[9][i]='0';for(i=1;i<9;i++){scanf(\"%s\",&t[i][1]);t[i][0]='0';t[i][9]='0';}f[1]=-1;for(n=0;;n=(n+1)%2){f[n]=-1;for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,mark[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,mark[n],0):0;f[n]!=0?o(0,0,f[2+n],f[4+n],mark[n],0):0;if(f[0]==0&&f[1]==0)break;}for(i=1;i<9;i++){for(j=1;j<9;j++)printf(\"%c\",t[i][j]);puts(\"\");}r 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//start o\nint i,j,n,max[6];\nchar table[10][10],mark[2]={'o','x'};\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\n\nint l(int dx,int dy,int x,int y,char m,int count){\n  if(table[x][y]=='.'||table[x][y]=='0')return 0;\n  if(table[x][y]==m)return count;\n  return l(dx,dy,x+dx,y+dy,m,count+1);\n}\nint search(int x,int y,char m){\n  //mの長さを取る\n  int k,count;\n  count = 0;\n  if(table[x][y]!='.')return 0;\n  for(k=0;k<8;k++){\n    count += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  return count;\n}\nint okikae2(int dx,int dy,int x,int y,char m){\n  if(table[x][y]=='0'||table[x][y]=='.')return 0;\n  else if(table[x][y]==m)return 1;\n  else if(okikae2(dx,dy,x+dx,y+dy,m)){\n    table[x][y]=m;\n    return 1;\n  }\n  else return 0;\n}\nint okikae(int x,int y,char m){\n  //mに置き換えていく\n  int k;\n  table[x][y]=m;\n  for(k=0;k<8;k++){\n    okikae2(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  return 0;\n}\n\nint main(){\n  for(i=0;i<10;i++)table[0][i]=table[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&table[i][1]);\n    table[i][0]='0';\n    table[i][9]='0';\n  }\n  for(n=0;;n=(n+1)%2){\n    max[n]=0;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(max[n]<search(i,j,mark[n])){\n          max[2+n]=i;\n          max[4+n]=j;\n          max[n]=search(i,j,mark[n]);\n        }\n      }\n    }\n    if(max[n]!=0)okikae(max[2+n],max[4+n],mark[n]);\n    if(max[0]==0&&max[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",table[i][j]);\n    }\n    puts(\"\");\n  }\n  \n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int u,int v,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};char t[10][10],g[2]={'o','x'};l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(u,v,x+u,y+v,m,c+1);}s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(u,v,x+u,y+v,m,0)){t[x][y]=m;r 1;}else r 0;}o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}main(){for(i=0;i<10;)t[0][i]=t[9][i++]='0';for(i=1;i<9;t[i][0]=t[i++][9]='0')scanf(\"%s\",&t[i][1]);for(n=f[1]=-1;f[n]=-1;n=(n+1)%2){for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,g[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,g[n],0):0;f[n]!=0?o(0,0,f[2+n],f[4+n],g[n],0):0;if(f[0]==0&&f[1]==0)break;}for(i=1;i<9;i++){for(j=1;j<9;j++)printf(\"%c\",t[i][j]);puts(\"\");}r 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar map[9][9];\nint dx[8] = {0,0,1,1,1,-1,-1,-1};\nint dy[8] = {1,-1,1,-1,0,0,-1,1};\nchar turn,turn2;\nint max,flag = 0;\nint max2;\n\nint check(int x,int y,int dirx,int diry) {\n  //  printf(\"star check();\\n\");\n  int i,j;\n  int sum;\n  int dxt,dyt,f;\n\n  dxt = dirx;\n  dyt = diry;\n  //  printf(\"x(%d) y(%d) dirx(%d) diry(%d)\",x,y,dirx,diry);\n  \n  sum  = 0;\n  f = 0;\n  \n  while(1){\n    \n    // printf(\"[%d+%d][%d+%d]\\n\",x,dirx,y,diry);    \n    if(f == 1 ||x+dirx < 0 || y+diry <0 || x+dirx >= 8 || y+diry >= 8 ) return 0;\n    \n\n    if(map[x+dirx][y+diry] == turn) return sum;\n    \n    \n    // printf(\"map[%d][%d](%c) == %c\\n\",x+dirx,y+diry,map[x+dirx][y+diry],turn2);\n    if(x+dirx >= 0 && y+diry >= 0, x+dirx < 8 && y+diry < 8 ) {\n    if(map[x+dirx][y+diry] == turn2) sum++;\n    else return 0;\n    }\n    \n    dirx += dxt;\n    diry += dyt;\n    \n    if(map[x+dirx][y+diry] == '.') return 0;\n    \n  }\n}\n\n \n\n\nint Xturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  max2 = 0;  \n  sum = 0;\n  max =0;\n  \n  for(k=7;k>=0;k--) {\n    for(l=7;l>=0;l--) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\t  \n\t  if(l + dx[i]>=0 &&k +  dy[i] >=0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t\t     t = check(l,k,dx[i],dy[i]);\n\t\t     sum += t;\n\t    }\n\t  }\n\t\t \n\t  if(max2 < sum){\n\t    max2 = sum;\n\t    max = l*8+k;\n\t  }\n\t}\n      }\n    }\n  }\n\n  return max;\n}\n\n\n\n\n\n\nint Oturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  \n  sum = 0;\n  max = 0;\n  max2= 0;\n  \n  for(k=0;k<8;k++) {\n    for(l=0;l<8;l++) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\n\t  //\t  printf(\"%d+%d\\n\",l,dx[i]);\n\t  if(l + dx[i] >= 0 && k +  dy[i] >= 0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t      //\t      printf(\"\\n%cturn check [%d][%d]\\ndx[%d](%d) dy[%d](%d)\\n\",turn,l,k,i,dx[i],i,dy[i]);\n\t      t = check(l,k,dx[i],dy[i]);\n\t      //  printf(\"Otrun t = %d\\n (l=%d k=%d\\n\",t,l,k);\n\t      sum += t;\n\t\t     \n\t    }\t    \n\n\t  }\n\t}\n\tif(max2 < sum) {\n\t  max = l*8+k;\n\t  max2 = sum;\n\t  //\t  printf(\"#########\\nin Oturn max = %d\\n\",max);\n\t}\n\n      }\n    }\n  }\n  \n  return max;\n}\n\n\nvoid rev(int xy) {\n  int i,j,k,l;\n  int sum;\n  int dxx,dyy;\n  int dxt,dyt,t;\n  \n  // printf(\"inrev(xy) x(%d) y(%d)\\n\",xy/8,xy%8);\n  \n  map[xy/8][xy%8] = turn;\n  \n  sum = 0;\n  for(k=0;k<8;k++) {\n    t = check(xy/8,xy%8,dx[k],dy[k]);\n    // printf(\"inrev t = %d\\n\",t);\n    sum = t;\n    dxx = dx[k] ;\n    dyy = dy[k];\n    dxt = dxx;\n    dyt = dyy;\n    \n    for(i=0;i<sum;i++) {\n      map[xy/8+dxx][xy%8+dyy] = turn;\n      dxx += dxt;\n      dyy += dyt;\n    }\n  }\n\n\n  /*  printf(\"############\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n    } */\n  \n}\n\n\t\n\t\n\n      \n  \n\nint main() {\n  int i,j;\n  char a[9];\n  int xy;\n\n  //\\ for(i=0;i<8;i++)printf(\"dx[%d](%d) dy[%d](%d)\\n\",i,dx[i],i,dy[i]);\n  \n  for(i=0;i<8;i++){\n    scanf(\"%s\",a);\n    for(j=0;j<8;j++) {\n      map[j][i] = a[j];\n    }\n  }\n\n  printf(\"input Check\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n  \n\n  while(flag <= 2){\n    \n    turn = 'o';\n    turn2 = 'x';\n    max = 0;\n    xy = Oturn();\n    // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n     \n   }\n\n   turn = 'x';\n   turn2 = 'o';\n   max = 0;\n   xy = Xturn();\n   // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n   }\n\n  }\n\n\n  //  printf(\"result\\n\");\n\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n\n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2311\nTitle Dessert Witch\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nchar ban[8][9];\nint dir8x[8]={1,1,0,-1,-1,-1,0,1};\nint dir8y[8]={0,1,1,1,0,-1,-1,-1};\n\n//\nvoid printban()\n{\n        int i;\n        for(i=0;i<8;i++)\n                printf(\"%s\\n\",&ban[i][0]);\n\n}\nint take_most(int turn,int * y,int * x)\n{\n        int i,j,i1,j1;\n        int most=0,start,end,offset,ret;\n\n        if(!turn)\n        {\n                start=0;end=8;offset=1;\n        }\n        else\n        {\n                start=7;end=-1;offset=-1;\n        }\n        for(i=start;i!=end;i+=offset)\n                for(j=start;j!=end;j+=offset)\n                {\n                        //printf(\"yx %d %d\\n\",i,j);\n                        if(ban[i][j]=='.')\n                        {\n                                ret=count_take(i,j,turn);\n#if DEBUG4\n                                if(ret)\n                                        printf(\":yxt %d %d %d\\n\",i,j,ret);\n#endif\n                                if(most < ret)\n                                { \n                                        i1=i;j1=j;\n                                        most = ret;\n                                }\n                        }\n                }\n        if(!most)\n                return(0);\n        else\n        {\n                *y=i1;\n                *x=j1;\n                return(-1);\n        }\n}\nvoid reverse_dessert(int y,int x,int dy,int dx,int times,char dessert)\n{\n        int i;\n\n        for(i=1;i<=times;i++)\n        {\n                ban[y+i*dy][x+i*dx]=dessert;\n                //printf(\"::yxc %d %d %c\",y+i*dy,x+i*dx,dessert);\n        }\n}\nvoid put_dessert(int y,int x,int turn)\n{\n        int i,j;\n        char opsit,self,t,ttotal;\n        int newx,newy;\n\n        opsit=(turn)?'o':'x';\n        self =(turn)?'x':'o';\n\n        ban[y][x]=self;\n  \n        for(i=0;i<8;i++)\n        {\n                t=0;\n\n                for(j=1;j<9;j++)\n                {\n                        newy=y+dir8y[i]*j;\n                        newx=x+dir8x[i]*j;\n\n                        if(newy < 0 || newy > 7 ||newx <0|| newx >7||ban[newy][newx]=='.')\n                        {\n                                t=0;\n                                break;\n                        }\n                        if(ban[newy][newx]==self)\n                                break;\n                        if(ban[newy][newx]==opsit)\n                        {\n                                 t++;\n                        }\n                }\n                if(t)\n                {\n                        //printf(\"yxt=%d %d %d\\n\",y,x,t);\n                        reverse_dessert(y,x,dir8y[i],dir8x[i],t,self);\n                }\n        }\n}\nint count_take(int y,int x,int turn)\n{\n        int i,j;\n        char opsit,self,t,ttotal;\n        int newx,newy;\n\n        opsit=(turn)?'o':'x';\n        self =(turn)?'x':'o';\n\n        ttotal=0;\n        for(i=0;i<8;i++)\n        {\n                t=0;\n#ifdef DEBUG2                        \n                printf(\":iyx %d %d %d\\n\",i,dir8y[i],dir8x[i]);\n#endif\n\n                for(j=1;j<9;j++)\n                {\n                        newy=y+dir8y[i]*j;\n                        newx=x+dir8x[i]*j;\n#ifdef DEBUG2                        \n                        printf(\":yxc %d %d %c\\n\",newy,newx,ban[newy][newx]);\n#endif\n                        if(newy < 0 || newy > 7 ||newx <0|| newx >7||ban[newy][newx]=='.')\n                        {\n                                t=0;\n                                break;\n                        }\n                        if(ban[newy][newx]==self)\n                                break;\n                        if(ban[newy][newx]==opsit)\n                        {\n                                 t++;\n                        }\n                }\n                ttotal += t;\n        }\n        return(ttotal);\n}\nvoid play()\n{\n        int turn;\n        int x,y;\n        int pass=0;\n\n        turn=0;\n        while(1)\n        {\n                if(take_most(turn,&y,&x))\n                {\n                        pass=0;\n                        //printf(\"%d %d\\n\",y,x);\n                        put_dessert(y,x,turn);\n#ifdef DEBUG3\n                        printf(\"----------\\n\");\n                        printban();\n                        \n#endif\n                }\n                else\n                        pass++;\n                if(pass>=2)\n                        break;\n                turn = 1-turn;\n        }\n}\nmain()\n{\n        int i;\n\n        for(i=0;i<8;i++)\n                scanf(\"%s\",&ban[i][0]);\n\n        play();\n\n        printban();\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[10][10]={{0}};\nint X[8]={-1,0,1,1, 1, 0,-1,-1};\nint Y[8]={ 1,1,1,0,-1,-1,-1, 0};\nint f(char w,char c,int y,int x){\n  int a=0,i,j;\n  for(i=0;i<8;i++){\n    for(j=1;s[y+Y[i]*j][x+X[i]*j]==c;j++);\n    if(s[y+Y[i]*j][x+X[i]*j]==w)a+=j-1;\n  }\n  return a;\n}\nvoid g(char w,char c,int y,int x){\n  int i,j;\n  s[y][x]=w;\n  for(i=0;i<8;i++){\n    for(j=1;s[y+Y[i]*j][x+X[i]*j]==c;j++);\n    if(s[y+Y[i]*j][x+X[i]*j]==w){\n      for(;j>0;j--)s[y+Y[i]*j][x+X[i]*j]=w;\n    }\n  }\n}\nint main(){\n  int i,j,mi,mj,max,a,c;\n  for(i=0;i<8;i++){\n    scanf(\"%s\",s[i+1]+1);\n  }\n  //printf(\"%c\",s[1][1]);\n  a=0;\n  while(1){\n    max=0;\n    for(i=1;i<9;i++){\n      for(j=1;j<9;j++){\n\tif(s[i][j]=='.'){\n\t  c=f('o','x',i,j);\n\t  if(max<c){\n\t    mi=i;\n\t    mj=j;\n\t    max=c;//printf(\"%d : %d : %d\\n\",mi,mj,c);\n\t  }\n\t}\n      }\n    }\n    //if(i==9&&j==9)break;\n    a++;\n    if(max!=0){//printf(\"%d:%d\\n\",mi,mj);\n      g('o','x',mi,mj);\n      a=0;\n    }\n    if(a==2)break;\n    max=0;\n    for(i=8;i>0;i--){\n      for(j=8;j>0;j--){\n\tif(s[i][j]=='.'){\n\t  c=f('x','o',i,j);\n\t  if(max<c){\n\t    mi=i;\n\t    mj=j;\n\t    max=c;\n\t  }\n\t}\n      }\n    }\n    //if(i==0&&j==0)break;\n    a++;\n    if(max!=0){\n      g('x','o',mi,mj);\n      a=0;\n    }\n    if(a==2)break;\t\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",s[i][j]);\n    }\n    printf(\"\\n\");\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define n 8\nchar a[n+2][n+2], player, opponent;\n\nvoid search(int i, int j, int* maxcnt, int* besti, int* bestj)\n{\n    int k, l, cnt=0;\n    for(k=-1;k<2;++k) for(l=-1;l<2;++l) {\n        int ii=i+k, jj=j+l, c=0;\n        if (k==0&&l==0) continue;\n        if (a[ii][jj]!=opponent) continue;\n        while (ii>=1 && jj>=1 && ii<=n && jj<=n && a[ii][jj]==opponent) {\n            ii+=k;\n            jj+=l;\n            ++c;\n        }\n        if (a[ii][jj]==player) cnt+=c;\n    }\n    if (*maxcnt<cnt) { *maxcnt=cnt; *besti=i; *bestj=j; }\n}\nvoid flip(int i, int j)\n{\n    int k, l;\n    for(k=-1;k<2;++k) for(l=-1;l<2;++l) {\n        int ii=i+k, jj=j+l, c=0;\n        if (k==0&&l==0) continue;\n        if (a[ii][jj]!=opponent) continue;\n        while (ii>=1 && jj>=1 && ii<=n && jj<=n && a[ii][jj]==opponent) {\n            ii+=k;\n            jj+=l;\n        }\n        if (a[ii][jj]==player) {\n            while (ii!=i || jj!=j) {\n                a[ii][jj]=player;\n                ii-=k;\n                jj-=l;\n            }\n            a[ii][jj]=player;\n        }\n    }\n}\n\nint main(void)\n{\n    int i, j, pass;\n    for(i=1;i<=n;++i)\n        scanf(\"%s\", a[i]+1);\n    pass=0;\n    player='o', opponent='x';\n    while (pass<2) {\n        int besti=-1, bestj=-1, maxcnt=0;\n        if (player=='o') {\n            for(i=1;i<=n;++i) for(j=1;j<=n;++j) if (a[i][j]=='.')\n                search(i, j, &maxcnt, &besti, &bestj);\n        }\n        else {\n            for(i=n;i>0;--i) for(j=n;j>0;--j) if (a[i][j]=='.')\n                search(i, j, &maxcnt, &besti, &bestj);\n        }\n        if (maxcnt) {\n            flip(besti, bestj);\n            pass=0;\n        }\n        else {\n            pass++;\n        }\n        { char t=player; player=opponent; opponent=t; }\n    }\n    for(i=1;i<=n;++i) {\n        for(j=1;j<=n;++j) putchar(a[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\ni,j,n,max[6];\ndx[8]={1,1,0,-1,-1,-1,0,1};\ndy[8]={0,1,1,1,0,-1,-1,-1};\nchar table[10][10],mark[2]={'o','x'};\n \nint l(int dx,int dy,int x,int y,char m,int c){\n  if(table[x][y]=='.'||table[x][y]=='0')r 0;\n  if(table[x][y]==m)r c;\n  r l(dx,dy,x+dx,y+dy,m,c+1);\n}\nint search(int x,int y,char m){\n  int k,c;\n  c = 0;\n  if(table[x][y]!='.')r 0;\n  for(k=0;k<8;k++){\n    c += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  r c;\n}\nint okikae2(int dx,int dy,int x,int y,char m){\n  if(table[x][y]=='0'||table[x][y]=='.')r 0;\n  else if(table[x][y]==m)r 1;\n  else if(okikae2(dx,dy,x+dx,y+dy,m)){\n    table[x][y]=m;\n    r 1;\n  }\n  else r 0;\n}\nint okikae(int x,int y,char m){\n  int k;\n  table[x][y]=m;\n  for(k=0;k<8;k++){\n    okikae2(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  r 0;\n}\n \nint main(){\n  for(i=0;i<10;i++)table[0][i]=table[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&table[i][1]);\n    table[i][0]='0';\n    table[i][9]='0';\n  }\n  max[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    max[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(max[n]<search(i,j,mark[n])){\n          max[2+n]=i;\n          max[4+n]=j;\n          max[n]=search(i,j,mark[n]);\n        }\n      }\n    }\n    if(max[n]!=0)okikae(max[2+n],max[4+n],mark[n]);\n    if(max[0]==0&&max[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",table[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a a;\ni,j,n,f[6];\nw[8]={1,1,0,-1,-1,-1,0,1};\nh[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\n \nint l(int dx,int dy,int x,int y,char m,int c){\nif(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}\nint s(int dx,int dy,int x,int y,char m,int c){\n  int k,d;d=0;if(t[x][y]!='.')r 0;\n  for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);\n  r d;\n}\nint p(int dx,int dy,int x,int y,char m,int c){\n  if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;\n  if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}\n  else r 0;\n}\nint o(int dx,int dy,int x,int y,char m,int c){\n  int k;\n  t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);\n  r 0;\n}\n \nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&t[i][1]);\n    t[i][0]='0';\n    t[i][9]='0';\n  }\n  f[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    f[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(f[n]<s(0,0,i,j,mark[n],0)){\n          f[2+n]=i;\n          f[4+n]=j;\n          f[n]=s(0,0,i,j,mark[n],0);\n        }\n      }\n    }\n    if(f[n]!=0)o(0,0,f[2+n],f[4+n],mark[n],0);\n    if(f[0]==0&&f[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\nchar t[10][10],a[2]={'o','x'};\nint i,j,n,v[6],w[8]={1,1,0,-1,-1,-1,0,1},h[8]={0,1,1,1,0,-1,-1,-1};\nl(int dx,int dy,int x,int y,char m,int c){\n  if(t[x][y]=='.'|t[x][y]=='0')r 0;\n  if(t[x][y]==m)r c;\n  r l(dx,dy,x+dx,y+dy,m,c+1);\n}\nint s(int x,int y,char m){\n  int k,c;\n  c=0;\n  if(t[x][y]!='.')r 0;\n  for(k=0;k<8;k++){\n    c += l(w[k],h[k],x+w[k],y+h[k],m,0);\n  }\n  r c;\n}\nint p(int dx,int dy,int x,int y,char m){\n  if(t[x][y]=='0'|t[x][y]==48)r 0;\n  else if(t[x][y]==m)r 1;\n  else if(p(dx,dy,x+dx,y+dy,m)){\n    t[x][y]=m;\n    r 1;\n  }\n  else r 0;\n}\nint o(int x,int y,char m){\n  int k;\n  t[x][y]=m;\n  for(k=0;k<8;k++){\n    p(w[k],h[k],x+w[k],y+h[k],m);\n  }\n  r 0;\n}\n\nint main(){\n  for(i=0;i<10;)t[0][i]=t[9][i++]='0';\n  for(i=1;i<9;t[i][0]=t[i++][9]='0')scanf(\"%s\",&t[i][1]);\n  v[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    v[n]=-1;for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)if(v[n]<s(i,j,a[n]))v[2+n]=i;v[4+n]=j;v[n]=s(i,j,a[n]);\n    if(v[n]!=0)o(v[2+n],v[4+n],a[n]);\n    if(v[0]==0&v[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar map[9][9];\nint dx[8] = {0,0,1,1,1,-1,-1,-1};\nint dy[8] = {1,-1,1,-1,0,0,-1,1};\nchar turn,turn2;\nint max,flag = 0;\nint max2;\n\nint check(int x,int y,int dirx,int diry) {\n  //  printf(\"star check();\\n\");\n  int i,j;\n  int sum;\n  int dxt,dyt,f;\n\n  dxt = dirx;\n  dyt = diry;\n  //  printf(\"x(%d) y(%d) dirx(%d) diry(%d)\",x,y,dirx,diry);\n  \n  sum  = 0;\n  f = 0;\n  \n  while(1){\n    \n    // printf(\"[%d+%d][%d+%d]\\n\",x,dirx,y,diry);    \n    if(f == 1 ||x+dirx < 0 || y+diry <0 || x+dirx >= 8 || y+diry >= 8 ) return 0;\n    \n\n    if(map[x+dirx][y+diry] == turn) return sum;\n    \n    \n    // printf(\"map[%d][%d](%c) == %c\\n\",x+dirx,y+diry,map[x+dirx][y+diry],turn2);\n    if(x+dirx >= 0 && y+diry >= 0, x+dirx < 8 && y+diry < 8 ) {\n    if(map[x+dirx][y+diry] == turn2) sum++;\n    else return 0;\n    }\n    \n    dirx += dxt;\n    diry += dyt;\n    \n    if(map[x+dirx][y+diry] == '.') return 0;\n    \n  }\n}\n\n \n\n\nint Xturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  max2 = 0;  \n  sum = 0;\n  max =0;\n  \n  for(k=7;k>=0;k--) {\n    for(l=7;l>=0;l--) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\t  \n\t  if(l + dx[i]>=0 &&k +  dy[i] >=0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t\t     t = check(l,k,dx[i],dy[i]);\n\t\t     sum += t;\n\t    }\n\t  }\n\t\t \n\t  if(max2 < sum){\n\t    max2 = sum;\n\t    max = l*8+k;\n\t  }\n\t}\n      }\n    }\n  }\n\n  return max;\n}\n\n\n\n\n\n\nint Oturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  \n  sum = 0;\n  max = 0;\n  max2= 0;\n  \n  for(k=0;k<8;k++) {\n    for(l=0;l<8;l++) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\n\t  //\t  printf(\"%d+%d\\n\",l,dx[i]);\n\t  if(l + dx[i] >= 0 && k +  dy[i] >= 0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t      //\t      printf(\"\\n%cturn check [%d][%d]\\ndx[%d](%d) dy[%d](%d)\\n\",turn,l,k,i,dx[i],i,dy[i]);\n\t      t = check(l,k,dx[i],dy[i]);\n\t      //  printf(\"Otrun t = %d\\n (l=%d k=%d\\n\",t,l,k);\n\t      sum += t;\n\t\t     \n\t    }\t    \n\n\t  }\n\t}\n\tif(max2 < sum) {\n\t  max = l*8+k;\n\t  max2 = sum;\n\t  //\t  printf(\"#########\\nin Oturn max = %d\\n\",max);\n\t}\n\n      }\n    }\n  }\n  \n  return max;\n}\n\n\nvoid rev(int xy) {\n  int i,j,k,l;\n  int sum;\n  int dxx,dyy;\n  int dxt,dyt,t;\n  \n  // printf(\"inrev(xy) x(%d) y(%d)\\n\",xy/8,xy%8);\n  \n  map[xy/8][xy%8] = turn;\n  \n  sum = 0;\n  for(k=0;k<8;k++) {\n    t = check(xy/8,xy%8,dx[k],dy[k]);\n    // printf(\"inrev t = %d\\n\",t);\n    sum = t;\n    dxx = dx[k] ;\n    dyy = dy[k];\n    dxt = dxx;\n    dyt = dyy;\n    \n    for(i=0;i<sum;i++) {\n      map[xy/8+dxx][xy%8+dyy] = turn;\n      dxx += dxt;\n      dyy += dyt;\n    }\n  }\n\n\n  /*  printf(\"############\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n    } */\n  \n}\n\n\t\n\t\n\n      \n  \n\nint main() {\n  int i,j;\n  char a[9];\n  int xy;\n\n  //\\ for(i=0;i<8;i++)printf(\"dx[%d](%d) dy[%d](%d)\\n\",i,dx[i],i,dy[i]);\n  \n  for(i=0;i<8;i++){\n    scanf(\"%s\",a);\n    for(j=0;j<8;j++) {\n      map[j][i] = a[j];\n    }\n  }\n\n  printf(\"input Check\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n  \n\n  while(flag <= 2){\n    \n    turn = 'o';\n    turn2 = 'x';\n    max = 0;\n    xy = Oturn();\n    // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n     \n   }\n\n   turn = 'x';\n   turn2 = 'o';\n   max = 0;\n   xy = Xturn();\n   // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n   }\n\n  }\n\n\n  //  printf(\"result\\n\");\n\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n\n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\nint l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}\nint s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}\nint p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}else r 0;}\nint o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}\nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){scanf(\"%s\",&t[i][1]);t[i][0]='0';t[i][9]='0';}\n  f[1]=-1;for(n=0;;n=(n+1)%2){f[n]=-1;\n  for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,mark[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,mark[n],0):0;\n    if(f[n]!=0)o(0,0,f[2+n],f[4+n],mark[n],0);\n    if(f[0]==0&&f[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//start o\nint i,j,n,max[6];\nchar table[10][10],mark[2]={'o','x'};\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\n\nint l(int dx,int dy,int x,int y,char m,int count){\n  if(table[x][y]=='.'||table[x][y]=='0')return 0;\n  if(table[x][y]==m)return count;\n  return l(dx,dy,x+dx,y+dy,m,count+1);\n}\nint search(int x,int y,char m){\n  //mの長さを取る\n  int k,count;\n  count = 0;\n  if(table[x][y]!='.')return 0;\n  for(k=0;k<8;k++){\n    count += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  return count;\n}\nint okikae2(int dx,int dy,int x,int y,char m){\n  if(table[x][y]=='0'||table[x][y]=='.')return 0;\n  else if(table[x][y]==m)return 1;\n  else if(okikae2(dx,dy,x+dx,y+dy,m)){\n    table[x][y]=m;\n    return 1;\n  }\n  else return 0;\n}\nint okikae(int x,int y,char m){\n  //mに置き換えていく\n  int k;\n  table[x][y]=m;\n  for(k=0;k<8;k++){\n    okikae2(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  return 0;\n}\n\nint main(){\n  for(i=0;i<10;i++)table[0][i]=table[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&table[i][1]);\n    table[i][0]='0';\n    table[i][9]='0';\n  }\n  max[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    max[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(max[n]<search(i,j,mark[n])){\n          max[2+n]=i;\n          max[4+n]=j;\n          max[n]=search(i,j,mark[n]);\n        }\n      }\n    }\n    if(max[n]!=0)okikae(max[2+n],max[4+n],mark[n]);\n    /*\n    printf(\"%d:%d:%d[%d]\\n\",n,max[0],max[1],search(6,7,mark[1]));\n    for(i=1;i<9;i++){\n      for(j=1;j<9;j++){\n        printf(\"%c\",table[i][j]);\n      }\n      puts(\"\");\n      }/*/\n    if(max[0]==0&&max[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",table[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[10][10]={{0}};\nint X[8]={-1,0,1,1, 1, 0,-1,-1};\nint Y[8]={ 1,1,1,0,-1,-1,-1, 0};\nint f(char w,char c,int y,int x){\n  int a=0,i,j;\n  for(i=0;i<8;i++){\n    for(j=1;s[y+Y[i]*j][x+X[i]*j]==c;j++);\n    if(s[y+Y[i]*j][x+X[i]*j]==w)a+=j-1;\n  }\n  return a;\n}\nvoid g(char w,char c,int y,int x){\n  int i,j;\n  s[y][x]=w;\n  for(i=0;i<8;i++){\n    for(j=1;s[y+Y[i]*j][x+X[i]*j]==c;j++);\n    if(s[y+Y[i]*j][x+X[i]*j]==w){\n      for(;j>0;j--)s[y+Y[i]*j][x+X[i]*j]=w;\n    }\n  }\n}\nint main(){\n  int i,j,mi,mj,max,a,c;\n  for(i=0;i<8;i++){\n    scanf(\"%s\",s[i+1]+1);\n  }\n  //printf(\"%c\",s[1][1]);\n  a=0;\n  while(1){\n    max=0;\n    for(i=1;i<9;i++){\n      for(j=1;j<9;j++){\n\tif(s[i][j]=='.'){\n\t  c=f('o','x',i,j);\n\t  if(max<c){\n\t    mi=i;\n\t    mj=j;\n\t    max=c;//printf(\"%d : %d : %d\\n\",mi,mj,c);\n\t  }\n\t}\n      }\n    }\n    //if(i==9&&j==9)break;\n    a++;\n    if(max!=0){//printf(\"%d:%d\\n\",mi,mj);\n      g('o','x',mi,mj);\n      a=0;\n    }\n    if(a==2)break;\n    max=0;\n    for(i=8;i>0;i--){\n      for(j=8;j>0;j--){\n\tif(s[i][j]=='.'){\n\t  c=f('x','o',i,j);\n\t  if(max<c){\n\t    mi=i;\n\t    mj=j;\n\t    max=c;\n\t  }\n\t}\n      }\n    }\n    //if(i==0&&j==0)break;\n    a++;\n    if(max!=0){\n      g('x','o',mi,mj);\n      a=0;\n    }\n    if(a==2)break;\t\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",s[i][j]);\n    }\n    printf(\"\\n\");\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};char t[10][10],mark[2]={'o','x'};l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}else r 0;}o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}main(){for(i=0;i<10;i++)t[0][i]=t[9][i]='0';for(i=1;i<9;t[i][0]=t[i++][9]='0')scanf(\"%s\",&t[i][1]);f[1]=-1;for(n=0;;n=(n+1)%2){f[n]=-1;for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,mark[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,mark[n],0):0;f[n]!=0?o(0,0,f[2+n],f[4+n],mark[n],0):0;if(f[0]==0&&f[1]==0)break;}for(i=1;i<9;i++){for(j=1;j<9;j++)printf(\"%c\",t[i][j]);puts(\"\");}r 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)((n>>m)&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\n\nchar s[10][10];\nll dir[9]={0,1,1,-1,0,-1,-1,1,0};\n\nll f(char c){\n\tchar cc='x'^'o'^c;\n\tll a[10][10]={};\n\tll M=0;\n\trep(i,0,8)rep(j,0,8)if(s[i][j]=='.'){\n\t\tll cnt=0;\n\t\trep(k,0,8){\n\t\t\tll ci=i+dir[k],cj=j+dir[k+1],ccnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(!(0<=ci&&ci<8&&0<=cj&&cj<8)||s[ci][cj]=='.'){\n\t\t\t\t\tccnt=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(s[ci][cj]==c)break;\n\t\t\t\tif(s[ci][cj]==cc){\n\t\t\t\t\tccnt++;\n\t\t\t\t\tci+=dir[k];\n\t\t\t\t\tcj+=dir[k+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt+=ccnt;\n\t\t}\n\t\ta[i][j]=cnt;\n\t\tM=max(M,cnt);\n\t}\n\t\n\tif(M==0)return 0;\n\t\n\tll Mi,Mj;\n\tif(c=='o'){\n\t\trep(i,0,8)rep(j,0,8)if(a[i][j]==M){\n\t\t\tMi=i;\n\t\t\tMj=j;\n\t\t\ti=j=8;\n\t\t}\n\t}else{\n\t\tfor(ll i=7;i>=0;i--)for(ll j=7;j>=0;j--)if(a[i][j]==M){\n\t\t\tMi=i;\n\t\t\tMj=j;\n\t\t\ti=j=-1;\n\t\t}\n\t}\n\t\t\n\ts[Mi][Mj]=c;\n\trep(k,0,8){\n\t\tll ci=Mi+dir[k],cj=Mj+dir[k+1],ccnt=0;\n\t\twhile(0<=ci&&ci<8&&0<=cj&&cj<8&&s[ci][cj]==cc){\n\t\t\tci+=dir[k];\n\t\t\tcj+=dir[k+1];\n\t\t}\n\t\tif(0<=ci&&ci<8&&0<=cj&&cj<8&&s[ci][cj]==c){\n\t\t\twhile(ci!=Mi||cj!=Mj){\n\t\t\t\tci-=dir[k];\n\t\t\t\tcj-=dir[k+1];\n\t\t\t\ts[ci][cj]=c;\n\t\t\t}\n\t\t}\n\t}\n\treturn M;\n}\n\n\nint main(){\n\trep(i,0,8)scanf(\"%s\",s[i]);\n\tll flag=1;\n\twhile(flag){\n\t\tflag=0;\n\t\tflag|=f('o');\n//\t\trep(i,0,8)puts(s[i]);puts(\"\");\n\t\tflag|=f('x');\n//\t\trep(i,0,8)puts(s[i]);puts(\"\");\n\t}\n\trep(i,0,8)puts(s[i]);puts(\"\");fflush(0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)((n>>m)&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\n\nchar s[10][10];\nll dir[9]={0,1,1,-1,0,-1,-1,1,0};\n\nll f(char c){\n\tchar cc='x'^'o'^c;\n\tll a[10][10]={};\n\tll M=0;\n\trep(i,0,8)rep(j,0,8)if(s[i][j]=='.'){\n\t\tll cnt=0;\n\t\trep(k,0,8){\n\t\t\tll ci=i+dir[k],cj=j+dir[k+1],ccnt=0;\n\t\t\twhile(1){\n\t\t\t\tif(!(0<=ci&&ci<8&&0<=cj&&cj<8)||s[ci][cj]=='.'){\n\t\t\t\t\tccnt=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(s[ci][cj]==c)break;\n\t\t\t\tif(s[ci][cj]==cc){\n\t\t\t\t\tccnt++;\n\t\t\t\t\tci+=dir[k];\n\t\t\t\t\tcj+=dir[k+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt+=ccnt;\n\t\t}\n\t\ta[i][j]=cnt;\n\t\tM=max(M,cnt);\n\t}\n\t\n\tif(M==0)return 0;\n\t\n\tll Mi,Mj;\n\tif(c=='o'){\n\t\trep(i,0,8)rep(j,0,8)if(a[i][j]==M){\n\t\t\tMi=i;\n\t\t\tMj=j;\n\t\t\ti=j=8;\n\t\t}\n\t}else{\n\t\tfor(ll i=7;i>=0;i--)for(ll j=7;j>=0;j--)if(a[i][j]==M){\n\t\t\tMi=i;\n\t\t\tMj=j;\n\t\t\ti=j=-1;\n\t\t}\n\t}\n\t\t\n\ts[Mi][Mj]=c;\n\trep(k,0,8){\n\t\tll ci=Mi+dir[k],cj=Mj+dir[k+1],ccnt=0;\n\t\twhile(0<=ci&&ci<8&&0<=cj&&cj<8&&s[ci][cj]==cc){\n\t\t\tci+=dir[k];\n\t\t\tcj+=dir[k+1];\n\t\t}\n\t\tif(0<=ci&&ci<8&&0<=cj&&cj<8&&s[ci][cj]==c){\n\t\t\twhile(ci!=Mi||cj!=Mj){\n\t\t\t\tci-=dir[k];\n\t\t\t\tcj-=dir[k+1];\n\t\t\t\ts[ci][cj]=c;\n\t\t\t}\n\t\t}\n\t}\n\treturn M;\n}\n\n\nint main(){\n\trep(i,0,8)scanf(\"%s\",s[i]);\n\tll flag=1;\n\twhile(flag){\n\t\tflag=0;\n\t\tflag|=f('o');\n//\t\trep(i,0,8)puts(s[i]);puts(\"\");\n\t\tflag|=f('x');\n//\t\trep(i,0,8)puts(s[i]);puts(\"\");\n\t}\n\trep(i,0,8)puts(s[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int x_plus[8]={-1, 0, 1,-1, 1,-1, 0, 1};\nconst int y_plus[8]={-1,-1,-1, 0, 0, 1, 1, 1};\n\nchar banmen[8][12];\n\nint in_range(int num){return 0<=num && num<8;}\n\nint put_count(int x,int y,char now) {\n\tint i,j;\n\tint count=0;\n\tchar aite=(now=='o')?'x':'o';\n\tif(banmen[y][x]!='.')return 0;\n\tfor(i=0;i<8;i++) {\n\t\tfor(j=1;in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j);j++) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]!=aite)break;\n\t\t}\n\t\tif(in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j)) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]==now)count+=j-1;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid put_commit(int x,int y,char now) {\n\tint i,j;\n\tchar aite=(now=='o')?'x':'o';\n\tbanmen[y][x]=now;\n\tfor(i=0;i<8;i++) {\n\t\tfor(j=1;in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j);j++) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]!=aite)break;\n\t\t}\n\t\tif(in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j)) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]==now) {\n\t\t\t\tfor(j--;j>0;j--) {\n\t\t\t\t\tbanmen[y+y_plus[i]*j][x+x_plus[i]*j]=now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint x,y;\n\tint max_x,max_y,max_num;\n\tint now_num;\n\tchar now_turn;\n\tint prev_is_pass;\n\tfor(y=0;y<8;y++)scanf(\"%s\",banmen[y]);\n\tnow_turn='o';\n\tprev_is_pass=0;\n\twhile(1) {\n\t\tmax_x=max_y=-1;\n\t\tmax_num=0;\n\t\tfor(y=0;y<8;y++) {\n\t\t\tfor(x=0;x<8;x++) {\n\t\t\t\tnow_num=put_count(x,y,now_turn);\n\t\t\t\tif(now_num>max_num ||\n\t\t\t\t\t\t(now_num==max_num && now_turn=='x')) {\n\t\t\t\t\tmax_num=now_num;\n\t\t\t\t\tmax_x=x;\n\t\t\t\t\tmax_y=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_num<=0) {\n\t\t\tif(prev_is_pass)break;\n\t\t\tprev_is_pass=1;\n\t\t} else {\n\t\t\tprev_is_pass=0;\n\t\t\tput_commit(max_x,max_y,now_turn);\n\t\t}\n\t\tnow_turn=(now_turn=='o')?'x':'o';\n\t}\n\tfor(y=0;y<8;y++)puts(banmen[y]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//start o\nint i,j,n,max[6];\nchar table[10][10],mark[2]={'o','x'};\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\n\nint l(int dx,int dy,int x,int y,char m,int count){\n  if(table[x][y]=='.'||table[x][y]=='0')return 0;\n  if(table[x][y]==m)return count;\n  return l(dx,dy,x+dx,y+dy,m,count+1);\n}\nint search(int x,int y,char m){\n  //mの長さを取る\n  int k,count;\n  count = 0;\n  if(table[x][y]!='.')return 0;\n  for(k=0;k<8;k++){\n    count += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  return count;\n}\nint okikae2(int dx,int dy,int x,int y,char m){\n  if(table[x][y]=='0'||table[x][y]=='.')return 0;\n  else if(table[x][y]==m)return 1;\n  else if(okikae2(dx,dy,x+dx,y+dy,m)){\n    table[x][y]=m;\n    return 1;\n  }\n  else return 0;\n}\nint okikae(int x,int y,char m){\n  //mに置き換えていく\n  int k;\n  table[x][y]=m;\n  for(k=0;k<8;k++){\n    okikae2(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  return 0;\n}\n\nint main(){\n  for(i=0;i<10;i++)table[0][i]=table[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&table[i][1]);\n    table[i][0]='0';\n    table[i][9]='0';\n  }\n  for(n=0;;n=(n+1)%2){\n    max[n]=0;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(max[n]<search(i,j,mark[n])){\n          max[2+n]=i;\n          max[4+n]=j;\n          max[n]=search(i,j,mark[n]);\n        }\n      }\n    }\n    if(max[n]!=0)okikae(max[2+n],max[4+n],mark[n]);\n    if(max[0]==0&&max[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",table[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define lim(n) n>=0&&n<8\nchar D[9][10]={0},x;\nint i,j,k,c,t,m=0,f,p,r,e;\n\nint dfs(int x,int y,char p,int f)\n{\n\tint mv[3]={-1,0,1},i,j,c,r=0,tx,ty;\n\tfor(i=0;i<4;i++)\n\t\tfor(j=0;j<4;j++)\n\t\t{\n\t\t\tif(f)D[y][x]=(p=='o'?'x':'o');\n\t\t\tfor(c=0,tx=x+mv[j],ty=y+mv[i];lim(tx)&&lim(ty)&&D[ty][tx]==p;tx+=mv[j],ty+=mv[i],c++);\n\t\t\tif(lim(tx)&&lim(ty)&&D[ty][tx]==(p=='o'?'x':'o'))\n\t\t\t{\n\t\t\t\tr+=c;\n\t\t\t\tif(f)\n\t\t\t\t\tfor(tx-=mv[j],ty-=mv[i];!(tx==x&&ty==y);tx-=mv[j],ty-=mv[i])\n\t\t\t\t\t\tD[ty][tx]=(p=='o'?'x':'o');\n\t\t\t}\n\t\t}\n\treturn r;\n}\n\nint main()\n{\n\tfor(i=c=t=0;i<8;i++)\n\t\t{\n\t\t\tgets(D[i]);\n\t\t}\n\t\n\tfor(f=0;f<100;f++)\n\t{\n\t\tif(f%2)//cheeze\n\t\t{\n\t\t\tfor(i=7,r=0,p=-1;i>=0;i--)\n\t\t\t\tfor(j=7;j>=0;j--)\n\t\t\t\t\tif(D[i][j]=='.'&&(e=dfs(j,i,'o',0))>r)r=e,p=i*10+j;\n\t\t\tif(p!=-1)\n\t\t\t\tdfs(p%10,p/10,'o',1);\n\t\t}\n\t\telse//chocolate\n\t\t{\n\t\t\tfor(i=r=0,p=-1;i<8;i++)\n\t\t\t\tfor(j=0;j<8;j++)\n\t\t\t\t\tif(D[i][j]=='.'&&(e=dfs(j,i,'x',0))>r)r=e,p=i*10+j;\n\t\t\tif(p!=-1)\n\t\t\t\tdfs(p%10,p/10,'x',1);\n\t\t}\n\t}\n\tfor(i=0;i<8;i++)puts(D[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\ni,j,n,f[6];\nw[8]={1,1,0,-1,-1,-1,0,1};\nh[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\n \nint l(int dx,int dy,int x,int y,char m,int c){\nif(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}\nint s(int x,int y,char m){\n  int k,c;c=0;if(t[x][y]!='.')r 0;\n  for(k=0;k<8;k++)c+=l(w[k],h[k],x+w[k],y+h[k],m,0);\n  r c;\n}\nint p(int dx,int dy,int x,int y,char m){\n  if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;\n  if(p(dx,dy,x+dx,y+dy,m)){t[x][y]=m;r 1;}\n  else r 0;\n}\nint o(int x,int y,char m){\n  int k;\n  t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m);\n  r 0;\n}\n \nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&t[i][1]);\n    t[i][0]='0';\n    t[i][9]='0';\n  }\n  f[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    f[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(f[n]<s(i,j,mark[n])){\n          f[2+n]=i;\n          f[4+n]=j;\n          f[n]=s(i,j,mark[n]);\n        }\n      }\n    }\n    if(f[n]!=0)o(f[2+n],f[4+n],mark[n]);\n    if(f[0]==0&&f[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\ni,j,n,max[6];\ndx[8]={1,1,0,-1,-1,-1,0,1};\ndy[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\n \nint l(int dx,int dy,int x,int y,char m,int c){\n  if(t[x][y]=='.'||t[x][y]=='0')r 0;\n  if(t[x][y]==m)r c;\n  r l(dx,dy,x+dx,y+dy,m,c+1);\n}\nint s(int x,int y,char m){\n  int k,c;\n  c = 0;\n  if(t[x][y]!='.')r 0;\n  for(k=0;k<8;k++){\n    c += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  r c;\n}\nint okikae2(int dx,int dy,int x,int y,char m){\n  if(t[x][y]=='0'||t[x][y]=='.')r 0;\n  else if(t[x][y]==m)r 1;\n  else if(okikae2(dx,dy,x+dx,y+dy,m)){\n    t[x][y]=m;\n    r 1;\n  }\n  else r 0;\n}\nint okikae(int x,int y,char m){\n  int k;\n  t[x][y]=m;\n  for(k=0;k<8;k++){\n    okikae2(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  r 0;\n}\n \nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&t[i][1]);\n    t[i][0]='0';\n    t[i][9]='0';\n  }\n  max[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    max[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(max[n]<s(i,j,mark[n])){\n          max[2+n]=i;\n          max[4+n]=j;\n          max[n]=s(i,j,mark[n]);\n        }\n      }\n    }\n    if(max[n]!=0)okikae(max[2+n],max[4+n],mark[n]);\n    if(max[0]==0&&max[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define SIZE_MAX 8\n\ntypedef unsigned int ui;\n\nchar s[SIZE_MAX][SIZE_MAX + 1];\n\nint isMami;\nint remain;\n\nui fucker;\n\nint isvalidcoor(int n){\n\treturn (0 <= n) && (n < SIZE_MAX);\n}\n\nchar cake(){\n\treturn (isMami ? 'o' : 'x');\n}\n\nvoid progress(int h, int w){\n\tint vects[8][2] = {\n\t\t{-1, -1},\n\t\t{-1,  0},\n\t\t{-1, +1},\n\t\t{ 0, -1},\n\t\t{ 0, +1},\n\t\t{+1, -1},\n\t\t{+1,  0},\n\t\t{+1, +1}\n\t};\n\tint v;\n\tchar c = cake();\n\ts[h][w] = c;\n\t// printf(\"fucker: %d\", fucker);\n\tfor (v = 0; v < 8; v++) {\n\t\tint i, j;\n\t\tint isLinable = fucker & 1;\n\t\tfucker /= 2;\n\t\tif (!isLinable) continue;\n\t\ti = h;\n\t\tj = w;\n\t\t// printf(\"%d \", v);\n\t\tfor (;;) {\n\t\t\ti += vects[v][0];\n\t\t\tj += vects[v][1];\n\t\t\tif (isvalidcoor(i) && isvalidcoor(j)) {\n\t\t\t\tif (s[i][j] == c) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ts[i][j] = c;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// putchar('\\n');\n\treturn;\n}\n\nui isvalidturn(int h, int w){\n\tui n = 0;\n\tchar c;\n\tint vects[8][2] = {\n\t\t{-1, -1},\n\t\t{-1,  0},\n\t\t{-1, +1},\n\t\t{ 0, -1},\n\t\t{ 0, +1},\n\t\t{+1, -1},\n\t\t{+1,  0},\n\t\t{+1, +1}\n\t};\n\tint v;\n\tchar k = cake();\n\tui raper = 0;\n\tfor (v = 0; v < 8; v++) {\n\t\tint i, j;\n\t\tint m = 0;\n\t\ti = h;\n\t\tj = w;\n\t\tfor (;;) {\n\t\t\ti += vects[v][0];\n\t\t\tj += vects[v][1];\n\t\t\tc = s[i][j];\n\t\t\tif (!isvalidcoor(i) || !isvalidcoor(j) || c == '.') {\n\t\t\t\tm = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (c == k) {\n\t\t\t\traper |= (1 << v);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tn += m;\n\t}\n\t// printf(\"r = %d\\n\", raper);\n\t// printf(\"n = %d\\n\", n);\n\treturn (n << 8) + raper;\n}\n\nint isBetter(int h, int w, int i, int j){\n\tif (isMami) {\n\t\treturn ((i < h) || (i == h && j < w));\n\t} else {\n\t\treturn ((i > h) || (i == h && j > w));\n\t}\n}\n\nint virtuoso(){\n\tint h = 0, w = -1;\n\tui n = 0;\n\tint i, j;\n\tui f;\n\tfor (i = 0; i < SIZE_MAX; i++)\n\t\tfor (j = 0; j < SIZE_MAX; j++) {\n\t\t\tui m;\n\t\t\tif (s[i][j] != '.')\n\t\t\t\tcontinue;\n\t\t\t// printf(\"%d %d\", i, j);\n\t\t\tm = isvalidturn(i, j);\n\t\t\tf = m % (1 << 8);\n\t\t\tm = m >> 8;\n\t\t\t// printf(\"f = %d\\n\", f);\n\t\t\t// printf(\"m = %d\\n\", m);\n\t\t\tif (m > n || (m == n && isBetter(h, w, i, j))) {\n\t\t\t\th = i, w = j;\n\t\t\t\tn = m;\n\t\t\t\tfucker = f;\n\t\t\t}\n\t\t}\n\treturn(n ? (h * SIZE_MAX + w) : SIZE_MAX * SIZE_MAX);\n}\n\nint output(){\n\tint i;\n\tfor (i = 0; i < SIZE_MAX; i++) {\n\t\tputs(s[i]);\n\t}\n\treturn! 810;\n}\n\nint hideous(){\n\tint n;\n\tint is_collapse = 2;\n\twhile (is_collapse && remain) {\n\t\t// printf(\"%d %d\", is_collapse, remain);\n\t\tisMami ^= 1;\n\t\tn = virtuoso();\n\t\t// printf(\"%d %d\\n\", n / 8, n % 8);\n\t\t// printf(\"%d\\n\", fucker);\n\t\tif (n == SIZE_MAX * SIZE_MAX) {\n\t\t\tis_collapse--;\n\t\t\tcontinue;\n\t\t}\n\t\tis_collapse = 2;\n\t\tprogress(n / 8, n % 8);\n\t\tremain--;\n\t\t// output();\n\t\t// putchar('\\n');\n\t}\n\treturn output();\n}\n\nint main(void){\n\tint i;\n\tfor (i = 0; i < SIZE_MAX; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t\t{\n\t\t\tchar *c = s[i];\n\t\t\twhile (*c) {\n\t\t\t\tif (*c == '.')\n\t\t\t\t\tremain++;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\thideous();\n\treturn! 114514;\n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];\nw[8]={1,1,0,-1,-1,-1,0,1};\nh[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\n \nint l a{\nif(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}\nint s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}\nint p a{\n  if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;\n  if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}\n  else r 0;\n}\nint o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}\n \nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&t[i][1]);\n    t[i][0]='0';\n    t[i][9]='0';\n  }\n  f[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    f[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(f[n]<s(0,0,i,j,mark[n],0)){\n          f[2+n]=i;\n          f[4+n]=j;\n          f[n]=s(0,0,i,j,mark[n],0);\n        }\n      }\n    }\n    if(f[n]!=0)o(0,0,f[2+n],f[4+n],mark[n],0);\n    if(f[0]==0&&f[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar map[9][9];\nint dx[8] = {0,0,1,1,1,-1,-1,-1};\nint dy[8] = {1,-1,1,-1,0,0,-1,1};\nchar turn,turn2;\nint max,flag = 0;\nint max2;\n\nint check(int x,int y,int dirx,int diry) {\n  //  printf(\"star check();\\n\");\n  int i,j;\n  int sum;\n  int dxt,dyt,f;\n\n  dxt = dirx;\n  dyt = diry;\n  //  printf(\"x(%d) y(%d) dirx(%d) diry(%d)\",x,y,dirx,diry);\n  \n  sum  = 0;\n  f = 0;\n  \n  while(1){\n    \n    // printf(\"[%d+%d][%d+%d]\\n\",x,dirx,y,diry);    \n    if(f == 1 ||x+dirx < 0 || y+diry <0 || x+dirx >= 8 || y+diry >= 8 ) return 0;\n    \n\n    if(map[x+dirx][y+diry] == turn) return sum;\n    \n    \n    // printf(\"map[%d][%d](%c) == %c\\n\",x+dirx,y+diry,map[x+dirx][y+diry],turn2);\n    if(x+dirx >= 0 && y+diry >= 0, x+dirx < 8 && y+diry < 8 ) {\n    if(map[x+dirx][y+diry] == turn2) sum++;\n    else return 0;\n    }\n    \n    dirx += dxt;\n    diry += dyt;\n    \n    if(map[x+dirx][y+diry] == '.') return 0;\n    \n  }\n}\n\n \n\n\nint Xturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  max2 = 0;  \n  sum = 0;\n  max =0;\n  \n  for(k=7;k>=0;k--) {\n    for(l=7;l>=0;l--) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\t  \n\t  if(l + dx[i]>=0 &&k +  dy[i] >=0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t\t     t = check(l,k,dx[i],dy[i]);\n\t\t     sum += t;\n\t    }\n\t  }\n\t\t \n\t  if(max2 < sum){\n\t    max2 = sum;\n\t    max = l*8+k;\n\t  }\n\t}\n      }\n    }\n  }\n\n  return max;\n}\n\n\n\n\n\n\nint Oturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  \n  sum = 0;\n  max = 0;\n  max2= 0;\n  \n  for(k=0;k<8;k++) {\n    for(l=0;l<8;l++) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\n\t  //\t  printf(\"%d+%d\\n\",l,dx[i]);\n\t  if(l + dx[i] >= 0 && k +  dy[i] >= 0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t      //\t      printf(\"\\n%cturn check [%d][%d]\\ndx[%d](%d) dy[%d](%d)\\n\",turn,l,k,i,dx[i],i,dy[i]);\n\t      t = check(l,k,dx[i],dy[i]);\n\t      //  printf(\"Otrun t = %d\\n (l=%d k=%d\\n\",t,l,k);\n\t      sum += t;\n\t\t     \n\t    }\t    \n\n\t  }\n\t}\n\tif(max2 < sum) {\n\t  max = l*8+k;\n\t  max2 = sum;\n\t  //\t  printf(\"#########\\nin Oturn max = %d\\n\",max);\n\t}\n\n      }\n    }\n  }\n  \n  return max;\n}\n\n\nvoid rev(int xy) {\n  int i,j,k,l;\n  int sum;\n  int dxx,dyy;\n  int dxt,dyt,t;\n  \n  // printf(\"inrev(xy) x(%d) y(%d)\\n\",xy/8,xy%8);\n  \n  map[xy/8][xy%8] = turn;\n  \n  sum = 0;\n  for(k=0;k<8;k++) {\n    t = check(xy/8,xy%8,dx[k],dy[k]);\n    // printf(\"inrev t = %d\\n\",t);\n    sum = t;\n    dxx = dx[k] ;\n    dyy = dy[k];\n    dxt = dxx;\n    dyt = dyy;\n    \n    for(i=0;i<sum;i++) {\n      map[xy/8+dxx][xy%8+dyy] = turn;\n      dxx += dxt;\n      dyy += dyt;\n    }\n  }\n\n\n  /*  printf(\"############\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n    } */\n  \n}\n\n\t\n\t\n\n      \n  \n\nint main() {\n  int i,j;\n  char a[9];\n  int xy;\n\n  //\\ for(i=0;i<8;i++)printf(\"dx[%d](%d) dy[%d](%d)\\n\",i,dx[i],i,dy[i]);\n  \n  for(i=0;i<8;i++){\n    scanf(\"%s\",a);\n    for(j=0;j<8;j++) {\n      map[j][i] = a[j];\n    }\n  }\n\n  printf(\"input Check\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n  \n\n  while(flag <= 2){\n    \n    turn = 'O';\n    turn2 = 'X';\n    max = 0;\n    xy = Oturn();\n    // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n     \n   }\n\n   turn = 'X';\n   turn2 = 'O';\n   max = 0;\n   xy = Xturn();\n   // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n   }\n\n  }\n\n\n  //  printf(\"result\\n\");\n\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n\n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar map[9][9];\nint dx[8] = {0,0,1,1,1,-1,-1,-1};\nint dy[8] = {1,-1,1,-1,0,0,-1,1};\nchar turn,turn2;\nint max,flag = 0;\nint max2;\n\nint check(int x,int y,int dirx,int diry) {\n  //  printf(\"star check();\\n\");\n  int i,j;\n  int sum;\n  int dxt,dyt,f;\n\n  dxt = dirx;\n  dyt = diry;\n  //  printf(\"x(%d) y(%d) dirx(%d) diry(%d)\",x,y,dirx,diry);\n  \n  sum  = 0;\n  f = 0;\n  \n  while(1){\n    \n    // printf(\"[%d+%d][%d+%d]\\n\",x,dirx,y,diry);    \n    if(f == 1 ||x+dirx < 0 || y+diry <0 || x+dirx >= 8 || y+diry >= 8 ) return 0;\n    \n\n    if(map[x+dirx][y+diry] == turn) return sum;\n    \n    \n    // printf(\"map[%d][%d](%c) == %c\\n\",x+dirx,y+diry,map[x+dirx][y+diry],turn2);\n    if(x+dirx >= 0 && y+diry >= 0, x+dirx < 8 && y+diry < 8 ) {\n    if(map[x+dirx][y+diry] == turn2) sum++;\n    else return 0;\n    }\n    \n    dirx += dxt;\n    diry += dyt;\n    \n    if(map[x+dirx][y+diry] == '.') return 0;\n    \n  }\n}\n\n \n\n\nint Xturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  max2 = 0;  \n  sum = 0;\n  max =0;\n  \n  for(k=7;k>=0;k--) {\n    for(l=7;l>=0;l--) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\t  \n\t  if(l + dx[i]>=0 &&k +  dy[i] >=0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t\t     t = check(l,k,dx[i],dy[i]);\n\t\t     sum += t;\n\t    }\n\t  }\n\t\t \n\t  if(max2 < sum){\n\t    max2 = sum;\n\t    max = l*8+k;\n\t  }\n\t}\n      }\n    }\n  }\n\n  return max;\n}\n\n\n\n\n\n\nint Oturn() {\n  int dirx,diry;\n  int i,j,k,l,t;\n  int sum;\n  \n  sum = 0;\n  max = 0;\n  max2= 0;\n  \n  for(k=0;k<8;k++) {\n    for(l=0;l<8;l++) {\n      \n      if(map[l][k] == '.') {\n\tsum = 0;\n\tfor(i=0;i<8;i++) {\n\n\t  //\t  printf(\"%d+%d\\n\",l,dx[i]);\n\t  if(l + dx[i] >= 0 && k +  dy[i] >= 0 && l + dx[i] < 8 && k + dy[i] < 8) {\n\t    if(map[l+dx[i]][k+dy[i]] == turn2) {\n\t      //\t      printf(\"\\n%cturn check [%d][%d]\\ndx[%d](%d) dy[%d](%d)\\n\",turn,l,k,i,dx[i],i,dy[i]);\n\t      t = check(l,k,dx[i],dy[i]);\n\t      //  printf(\"Otrun t = %d\\n (l=%d k=%d\\n\",t,l,k);\n\t      sum += t;\n\t\t     \n\t    }\t    \n\n\t  }\n\t}\n\tif(max2 < sum) {\n\t  max = l*8+k;\n\t  max2 = sum;\n\t  //\t  printf(\"#########\\nin Oturn max = %d\\n\",max);\n\t}\n\n      }\n    }\n  }\n  \n  return max;\n}\n\n\nvoid rev(int xy) {\n  int i,j,k,l;\n  int sum;\n  int dxx,dyy;\n  int dxt,dyt,t;\n  \n  // printf(\"inrev(xy) x(%d) y(%d)\\n\",xy/8,xy%8);\n  \n  map[xy/8][xy%8] = turn;\n  \n  sum = 0;\n  for(k=0;k<8;k++) {\n    t = check(xy/8,xy%8,dx[k],dy[k]);\n    // printf(\"inrev t = %d\\n\",t);\n    sum = t;\n    dxx = dx[k] ;\n    dyy = dy[k];\n    dxt = dxx;\n    dyt = dyy;\n    \n    for(i=0;i<sum;i++) {\n      map[xy/8+dxx][xy%8+dyy] = turn;\n      dxx += dxt;\n      dyy += dyt;\n    }\n  }\n\n\n  /*  printf(\"############\\n\");\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n    } */\n  \n}\n\n\t\n\t\n\n      \n  \n\nint main() {\n  int i,j;\n  char a[9];\n  int xy;\n\n  //\\ for(i=0;i<8;i++)printf(\"dx[%d](%d) dy[%d](%d)\\n\",i,dx[i],i,dy[i]);\n  \n  for(i=0;i<8;i++){\n    scanf(\"%s\",a);\n    for(j=0;j<8;j++) {\n      map[j][i] = a[j];\n    }\n  }\n\n  //printf(\"input Check\\n\");\n  /* for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n      \n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n    } */\n  \n\n  while(flag <= 2){\n    \n    turn = 'o';\n    turn2 = 'x';\n    max = 0;\n    xy = Oturn();\n    // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n     \n   }\n\n   turn = 'x';\n   turn2 = 'o';\n   max = 0;\n   xy = Xturn();\n   // printf(\"%c turn xy = %d\\n\",turn,xy);\n   if(max2 == 0) flag++;\n   else {\n     flag = 0;\n     rev(xy);\n   }\n\n  }\n\n\n  //  printf(\"result\\n\");\n\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++) {\n\n      printf(\"%c\",map[j][i]);\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\nint di[]={-1,0,1,0,-1,1,1,-1};\nint dj[]={0,1,0,-1,1,1,-1,-1};\n\nchar t[8][8],ch,turn='o';\n\nchar u[8][8];\n\nint calc(int I,int J,char turn){\n  u[I][J]=turn;\n  int i,j,k,l,sum=0,cnt;\n  for(k=0;k<8;k++){\n    i=I;\n    j=J;\n    cnt=0;\n    while(1){\n      i+=di[k];\n      j+=dj[k];      \n      if(i<0||j<0||i>=8||j>=8||t[i][j]=='.'){\n        cnt=0;\n        break;\n      }\n      if(t[i][j]==turn){\n        break;\n      }\n      cnt++;\n    }\n    sum+=cnt;\n    i=I;\n    j=J;\n    for(l=0;l<cnt;l++){\n      i+=di[k];\n      j+=dj[k];      \n      u[i][j]=turn;\n    }\n  }\n  return sum;\n}\n\nint func(){\n  int i,j,I,J,X;\n  int ci,cj,maxm=0;\n\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++){\n      I=i;\n      J=j;\n      if(turn=='x'){\n        I=7-i;\n        J=7-j;\n      }\n      if(t[I][J]!='.')continue;\n      X=calc(I,J,turn);    \n      if(X <= maxm)continue;\n      maxm=X;\n      ci=I;\n      cj=J;\n    }\n  }\n\n  if(maxm==0)return 0;\n  \n  for(i=0;i<8;i++)for(j=0;j<8;j++)u[i][j]=t[i][j];\n  calc(ci,cj,turn);\n  for(i=0;i<8;i++)for(j=0;j<8;j++)t[i][j]=u[i][j];\n  \n  return 1;\n}\n\nint main(){\n  int i,j;\n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++)scanf(\"%c\",&t[i][j]);\n    scanf(\"%c\",&ch);\n  }\n  int c=0;\n  while(1){\n    if(c==2)break;\n    int x=func();\n    if(x==0)c++;\n    else c=0;\n    if(turn=='o')turn='x';\n    else turn='o';\n  }\n  \n  for(i=0;i<8;i++){\n    for(j=0;j<8;j++)printf(\"%c\",t[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2311: Dessert Witch\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n\nchar map[8][10];\nint mv[8][2] = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\n\nint mami(int *rr, int *cc)\n{\n\tint i, r, c, r2, c2, f, f2, max;\n\n\tmax = 0;\n\tfor (r = 0; r < 8; r++) for (c = 0; c < 8; c++) {\n\t\tif (map[r][c] != '.') continue;\n\t\tf = 0; for (i = 0; i < 8; i++) {\n\t\t\tr2 = r, c2 = c, f2 = 0; while (1) {\n\t\t\t\tr2 += mv[i][0], c2 += mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= 8 || c2 < 0 || c2 >= 8) break;\n\t\t\t\tif (map[r2][c2] == '.') break;\n\t\t\t\tif (map[r2][c2] == 'o') { f += f2; break; }\n\t\t\t\tf2++;\n\t\t\t}\n\t\t}\n\t\tif (f > max) max = f, *rr = r, *cc = c;\n\t}\n\treturn max; \n}\n\nint majo(int *rr, int *cc)\n{\n\tint i, r, c, r2, c2, f, f2, max;\n\n\tmax = 0;\n\tfor (r = 7; r >= 0; r--) for (c = 7; c >= 0; c--) {\n\t\tif (map[r][c] != '.') continue;\n\t\tf = 0; for (i = 0; i < 8; i++) {\n\t\t\tr2 = r, c2 = c, f2 = 0; while (1) {\n\t\t\t\tr2 += mv[i][0], c2 += mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= 8 || c2 < 0 || c2 >= 8) break;\n\t\t\t\tif (map[r2][c2] == '.') break;\n\t\t\t\tif (map[r2][c2] == 'x') { f += f2; break; }\n\t\t\t\tf2++;\n\t\t\t}\n\t\t}\n\t\tif (f > max) max = f, *rr = r, *cc = c;\n\t}\n\treturn max; \n}\n\nvoid act(int rr, int cc, char m)\n{\n\tint i, r, c;\n\n\tmap[rr][cc] = m;\n\tfor (i = 0; i < 8; i++) {\n\t\tr = rr, c = cc;\n\t\twhile (1) {\n\t\t\tr += mv[i][0], c += mv[i][1];\n\t\t\tif (r < 0 || r >= 8 || c < 0 || c >= 8) break;\n\t\t\tif (map[r][c] == '.') break;\n\t\t\tif (map[r][c] == m) {\n\t\t\t\tr = rr, c = cc;\n\t\t\t\twhile (1) {\n\t\t\t\t\tr += mv[i][0], c += mv[i][1];\n\t\t\t\t\tif (map[r][c] == m) break;\n\t\t\t\t\tmap[r][c] = m;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint r, c, f;\n\t\n\tfor (r = 0; r < 8; r++) scanf(\"%s\", map[r]);\n\tf = 1; while (f) {\n\t\tf = 0;\n\t\tif (mami(&r, &c)) f = 1, act(r, c, 'o');\n\t\tif (majo(&r, &c)) f = 1, act(r, c, 'x');\n\t}\n\tfor (r = 0; r < 8; r++) puts(map[r]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 8\n\nchar s[ N ][ N ];\n\nint\ndraw (\n  const int x,\n  const int y,\n  const int p\n  )\n{\n  int i, j, k, l;\n  int res = 0;\n\n  for ( i = -1; i <= 1; ++i )\n  for ( j = -1; j <= 1; ++j )\n  {\n    if ( i == 0 && j == 0 ) continue ;\n\n    for ( k = 1; ; ++k )\n    {\n      const int a = x + i * k;\n      const int b = y + j * k;\n\n      if ( a < 0 || b < 0 || a >= N || b >= N\n        || s[ a ][ b ] == '.' )\n      {\n        k = 1;\n        break ;\n      }\n\n      if ( s[ a ][ b ] == p )\n        break ;\n    }\n    for ( l = 0; l < k; ++l )\n    {\n      const int a = x + i * l;\n      const int b = y + j * l;\n\n      s[ a ][ b ] = p;\n    }\n  }\n\n  return ( res );\n}\n\nint\nevaluate (\n  const int x,\n  const int y,\n  const int p\n  )\n{\n  int i, j, k;\n  int res = 0;\n\n  for ( i = -1; i <= 1; ++i )\n  for ( j = -1; j <= 1; ++j )\n  {\n    if ( i == 0 && j == 0 ) continue ;\n\n    for ( k = 1; ; ++k )\n    {\n      const int a = x + i * k;\n      const int b = y + j * k;\n\n      if ( a < 0 || b < 0 || a >= N || b >= N\n        || s[ a ][ b ] == '.' )\n      {\n        k = 1;\n        break ;\n      }\n\n      if ( s[ a ][ b ] == p )\n        break ;\n    }\n    res += k - 1;\n  }\n\n  return ( res );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i, j;\n\n  for ( i = 0; i < N; ++i )\n  for ( j = 0; j < N; ++j )\n    scanf ( \" %c\", &s[ i ][ j ] );\n\n  for ( ; ; )\n  {\n    int pass = 0;\n    int x, y;\n    int ev;\n\n    ev = x = y = 0;\n    for ( i = 0; i < N; ++i )\n    for ( j = 0; j < N; ++j )\n    {\n      int tev;\n      \n      if ( s[ i ][ j ] != '.' ) continue ;\n      \n      tev = evaluate ( i, j, 'o' );\n      if ( tev > ev )\n      {\n        ev = tev; x = i; y = j;\n      }\n    }\n    if ( ev > 0 ) { draw ( x, y, 'o' ); pass = 0; }\n    else ++pass;\n\n    ev = x = y = 0;\n    for ( i = N - 1; i >= 0; --i )\n    for ( j = N - 1; j >= 0; --j )\n    {\n      int tev;\n      \n      if ( s[ i ][ j ] != '.' ) continue ;\n      \n      tev = evaluate ( i, j, 'x' );\n      if ( tev > ev )\n      {\n        ev = tev; x = i; y = j;\n      }\n    }\n    if ( ev > 0 ) { draw ( x, y, 'x' ); pass = 0; }\n    else ++pass;\n\n    if ( pass >= 2 )\n      break ;\n  }\n\n  for ( i = 0; i < N; ++i )\n  {\n    for ( j = 0; j < N; ++j )\n      putchar ( s[ i ][ j ] );\n    puts ( \"\" );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#define r return\n#define a (int dx,int dy,int x,int y,char m,int c)\ni,j,n,f[6];w[8]={1,1,0,-1,-1,-1,0,1};h[8]={0,1,1,1,0,-1,-1,-1};char t[10][10],mark[2]={'o','x'};l a{if(t[x][y]=='.'||t[x][y]=='0')r 0;if(t[x][y]==m)r c;r l(dx,dy,x+dx,y+dy,m,c+1);}s a{int k,d;d=0;if(t[x][y]!='.')r 0;for(k=0;k<8;k++)d+=l(w[k],h[k],x+w[k],y+h[k],m,0);r d;}p a{if(t[x][y]=='0'||t[x][y]=='.')r 0;if(t[x][y]==m)r 1;if(p(dx,dy,x+dx,y+dy,m,0)){t[x][y]=m;r 1;}else r 0;}o a{int k;t[x][y]=m;for(k=0;k<8;k++)p(w[k],h[k],x+w[k],y+h[k],m,0);r 0;}main(){for(i=0;i<10;)t[0][i]=t[9][i++]='0';for(i=1;i<9;t[i][0]=t[i++][9]='0')scanf(\"%s\",&t[i][1]);for(n=f[1]=-1;;n=(n+1)%2){f[n]=-1;for(i=n?8:1;n?i>-1:i<9;n?i--:i++)for(j=n?8:1;n?j>-1:j<9;n?j--:j++)f[n]<s(0,0,i,j,mark[n],0)?f[2+n]=i,f[4+n]=j,f[n]=s(0,0,i,j,mark[n],0):0;f[n]!=0?o(0,0,f[2+n],f[4+n],mark[n],0):0;if(f[0]==0&&f[1]==0)break;}for(i=1;i<9;i++){for(j=1;j<9;j++)printf(\"%c\",t[i][j]);puts(\"\");}r 0;}"
  },
  {
    "language": "C",
    "code": "#define r return\ni,j,n,f[6];\ndx[8]={1,1,0,-1,-1,-1,0,1};\ndy[8]={0,1,1,1,0,-1,-1,-1};\nchar t[10][10],mark[2]={'o','x'};\n \nint l(int dx,int dy,int x,int y,char m,int c){\n  if(t[x][y]=='.'||t[x][y]=='0')r 0;\n  if(t[x][y]==m)r c;\n  r l(dx,dy,x+dx,y+dy,m,c+1);\n}\nint s(int x,int y,char m){\n  int k,c;\n  c = 0;\n  if(t[x][y]!='.')r 0;\n  for(k=0;k<8;k++){\n    c += l(dx[k],dy[k],x+dx[k],y+dy[k],m,0);\n  }\n  r c;\n}\nint p(int dx,int dy,int x,int y,char m){\n  if(t[x][y]=='0'||t[x][y]=='.')r 0;\n  else if(t[x][y]==m)r 1;\n  else if(p(dx,dy,x+dx,y+dy,m)){\n    t[x][y]=m;\n    r 1;\n  }\n  else r 0;\n}\nint o(int x,int y,char m){\n  int k;\n  t[x][y]=m;\n  for(k=0;k<8;k++){\n    p(dx[k],dy[k],x+dx[k],y+dy[k],m);\n  }\n  r 0;\n}\n \nint main(){\n  for(i=0;i<10;i++)t[0][i]=t[9][i]='0';\n  for(i=1;i<9;i++){\n    scanf(\"%s\",&t[i][1]);\n    t[i][0]='0';\n    t[i][9]='0';\n  }\n  f[1]=-1;\n  for(n=0;;n=(n+1)%2){\n    f[n]=-1;\n    for(i=n?8:1;n?i>-1:i<9;n?i--:i++){\n      for(j=n?8:1;n?j>-1:j<9;n?j--:j++){\n        if(f[n]<s(i,j,mark[n])){\n          f[2+n]=i;\n          f[4+n]=j;\n          f[n]=s(i,j,mark[n]);\n        }\n      }\n    }\n    if(f[n]!=0)o(f[2+n],f[4+n],mark[n]);\n    if(f[0]==0&&f[1]==0)break;\n  }\n  for(i=1;i<9;i++){\n    for(j=1;j<9;j++){\n      printf(\"%c\",t[i][j]);\n    }\n    puts(\"\");\n  }\n  r 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int x_plus[8]={-1, 0, 1,-1, 1,-1, 0, 1};\nconst int y_plus[8]={-1,-1,-1, 0, 0, 1, 1, 1};\n\nchar banmen[8][12];\n\nint in_range(int num){return 0<=num && num<8;}\n\nint put_count(int x,int y,char now) {\n\tint i,j;\n\tint count=0;\n\tchar aite=(now=='o')?'x':'o';\n\tif(banmen[y][x]!='.')return 0;\n\tfor(i=0;i<8;i++) {\n\t\tfor(j=1;in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j);j++) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]!=aite)break;\n\t\t}\n\t\tif(in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j)) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]==now)count+=j-1;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid put_commit(int x,int y,char now) {\n\tint i,j;\n\tchar aite=(now=='o')?'x':'o';\n\tbanmen[y][x]=now;\n\tfor(i=0;i<8;i++) {\n\t\tfor(j=1;in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j);j++) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]!=aite)break;\n\t\t}\n\t\tif(in_range(x+x_plus[i]*j) && in_range(y+y_plus[i]*j)) {\n\t\t\tif(banmen[y+y_plus[i]*j][x+x_plus[i]*j]==now) {\n\t\t\t\tfor(j--;j>0;j--) {\n\t\t\t\t\tbanmen[y+y_plus[i]*j][x+x_plus[i]*j]=now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint x,y;\n\tint max_x,max_y,max_num;\n\tint now_num;\n\tchar now_turn;\n\tint prev_is_pass;\n\tfor(y=0;y<8;y++)scanf(\"%s\",banmen[y]);\n\tnow_turn='o';\n\tprev_is_pass=0;\n\twhile(1) {\n\t\tmax_x=max_y=-1;\n\t\tmax_num=0;\n\t\tfor(y=0;y<8;y++) {\n\t\t\tfor(x=0;x<8;x++) {\n\t\t\t\tnow_num=put_count(x,y,now_turn);\n\t\t\t\tif(now_num>max_num ||\n\t\t\t\t\t\t(now_num==max_num && now_turn=='x')) {\n\t\t\t\t\tmax_num=now_num;\n\t\t\t\t\tmax_x=x;\n\t\t\t\t\tmax_y=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max_num<=0) {\n\t\t\tif(prev_is_pass)break;\n\t\t\tprev_is_pass=1;\n\t\t} else {\n\t\t\tput_commit(max_x,max_y,now_turn);\n\t\t}\n\t\tnow_turn=(now_turn=='o')?'x':'o';\n\t}\n\tfor(y=0;y<8;y++)puts(banmen[y]);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic final int W = 8;\n\tstatic final int H = 8;\n\tstatic char[][] board = new char[W + 2][H + 2];\n\n\tstatic int[] vx = {0,1,1,1,0,-1,-1,-1};\n\tstatic int[] vy = {1,1,0,-1,-1,-1,0,1};\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfor(int i = 0; i < board.length; i++){\n\t\t\tArrays.fill(board[i], '.');\n\t\t}\n\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tString str = sc.next();\n\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tboard[i][j] = str.charAt(j - 1);\n\t\t\t}\n\t\t}\n\n\t\tPlayer[] players = new Player[2];\n\n\t\tplayers[0] = new Player('o', 'x');\n\t\tplayers[1] = new Player('x', 'o');\n\n\t\tint pid = 0;\n\n\t\twhile(true){\n\t\t\tPlayer current = players[pid%players.length];\n\n\t\t\tint tmpMax = 0;\n\t\t\tint maxX = 0;\n\t\t\tint maxY = 0;\n\n\t\t\t//最適な場所を探す\n\t\t\tfor(int i = 1; i <= H; i++){\n\t\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\t\tif(board[i][j] != '.'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint tmpCount = countReversible(current, j, i);\n//\t\t\t\t\tSystem.out.println(tmpCount);\n\n\t\t\t\t\tif((pid%players.length == 0 &&  tmpMax < tmpCount) ||\n\t\t\t\t\t\t\tpid%players.length == 1 && tmpMax <= tmpCount){\n\t\t\t\t\t\ttmpMax = tmpCount;\n\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(tmpMax != 0){\n//\t\t\t\tSystem.out.println(\"put at \"+maxX+\", \"+maxY+\" expect \"+tmpMax);\n\t\t\t\treverse(current, maxX, maxY);\n\t\t\t\tcurrent.put = true;\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"cant fount\");\n\t\t\t\tcurrent.put = false;\n\t\t\t}\n\t\t\tpid++;\n\n\t\t\tif(!players[0].put && !players[1].put){\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tprintBoard();\n//\t\t\tSystem.out.println();\n//\t\t\tsc.next();\n\t\t}\n\n\t\tprintBoard();\n\t}\n\n\tstatic void printBoard (){\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tSystem.out.print(board[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int countReversible(Player player, int x, int y){\n\t\tint count = 0;\n\n//\t\tboard[y][x] = player.piece;\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tif(board[y + vy[i]][x + vx[i]] == player.enemy){\n\t\t\t\tint j = 1;\n\t\t\t\twhile(board[y + vy[i]*j][x + vx[i]*j] != '.'){\n\t\t\t\t\tif(board[y + vy[i]*j][x + vx[i]*j] == player.piece){\n\t\t\t\t\t\tcount += j - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tstatic void reverse(Player player, int x, int y){\n\t\tboard[y][x] = player.piece;\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tboolean reversible = false;\n\t\t\tif(board[y + vy[i]][x + vx[i]] == player.enemy){\n\t\t\t\tint j = 1;\n\t\t\t\twhile(board[y + vy[i]*j][x + vx[i]*j] != '.'){\n\t\t\t\t\tif(board[y + vy[i]*j][x + vx[i]*j] == player.piece){\n\t\t\t\t\t\treversible = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(reversible){\n//\t\t\t\tSystem.out.println(\"dir \"+i);\n\t\t\t\tint j = 1;\n\t\t\t\twhile(board[y + vy[i]*j][x + vx[i]*j] == player.enemy){\n\t\t\t\t\tboard[y + vy[i]*j][x + vx[i]*j] = player.piece;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Player {\n\tchar piece;\n\tchar enemy;\n\tboolean put = true;\n\n\tPlayer(char piece, char enemy){\n\t\tthis.piece = piece;\n\t\tthis.enemy = enemy;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[][] m = new char[8][];\n\t\tfor(int i=0;i<8;i++) {\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t}\n\t\t\n\t\tint pass = 0;\n\t\tint turn = 1;\n\t\twhile(true) {\n\t\t\tturn = 1 - turn;\n\t\t\tint max = 0;\n\t\t\tint maxi = -1;\n\t\t\tint maxj = -1;\n\t\t\tfor(int i=0;i<8;i++) {\n\t\t\t\tfor(int j=0;j<8;j++) {\n\t\t\t\t\tint x = num(m,i,j,turn);\n\t\t\t\t\tif (turn == 0) {\n\t\t\t\t\t\tif (x > max) {\n\t\t\t\t\t\t\tmax = x;\n\t\t\t\t\t\t\tmaxi = i;\n\t\t\t\t\t\t\tmaxj = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif (x >= max) {\n\t\t\t\t\t\t\tmax = x;\n\t\t\t\t\t\t\tmaxi = i;\n\t\t\t\t\t\t\tmaxj = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max == 0) {\n\t\t\t\tpass++;\n\t\t\t\tif (pass >= 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpass = 0;\n\t\t\tput(m, maxi, maxj, turn);\n//\t\t\tprint(m);\n\t\t}\n\t\tprint(m);\n\t}\n\t\n\tpublic static void print(char[][] m) {\n\t\tfor(int i=0;i<8;i++) {\n\t\t\tSystem.out.println(m[i]);\n\t\t}\n\t}\n\t\n\tpublic static int num(char[][] m,int si,int sj,int turn) {\n\t\tif (m[si][sj] != '.') {\n\t\t\treturn 0;\n\t\t}\n\t\tchar me = turn == 0 ? 'o' : 'x';\n\t\tchar opp = turn == 0 ? 'x' : 'o';\n\t\tint sum = 0;\n\t\tfor(int di=-1;di<=1;di++) {\n\t\t\tfor(int dj=-1;dj<=1;dj++) {\n\t\t\t\tif (di == 0 && dj == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ni = si + di;\n\t\t\t\tint nj = sj + dj;\n\t\t\t\tint count = 0;\n\t\t\t\twhile(0 <= ni && ni < 8 && 0 <= nj && nj < 8) {\n\t\t\t\t\tif (m[ni][nj] == opp) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else if(m[ni][nj] == me) {\n\t\t\t\t\t\tsum += count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tni += di;\n\t\t\t\t\tnj += dj;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void put(char[][] m,int si,int sj,int turn) {\n\t\tchar me = turn == 0 ? 'o' : 'x';\n\t\tchar opp = turn == 0 ? 'x' : 'o';\n\t\tm[si][sj] = me;\n\t\tfor(int di=-1;di<=1;di++) {\n\t\t\tfor(int dj=-1;dj<=1;dj++) {\n\t\t\t\tif (di == 0 && dj == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ni = si + di;\n\t\t\t\tint nj = sj + dj;\n\t\t\t\tint count = 0;\n\t\t\t\tboolean flag = false;\n\t\t\t\twhile(0 <= ni && ni < 8 && 0 <= nj && nj < 8) {\n\t\t\t\t\tif (m[ni][nj] == opp) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else if(m[ni][nj] == me) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tni += di;\n\t\t\t\t\tnj += dj;\n\t\t\t\t}\n\t\t\t\tif (count > 0 && flag) {\n\t\t\t\t\tni = si + di;\n\t\t\t\t\tnj = sj + dj;\n\t\t\t\t\twhile(0 <= ni && ni < 8 && 0 <= nj && nj < 8) {\n\t\t\t\t\t\tif (m[ni][nj] == opp) {\n\t\t\t\t\t\t\tm[ni][nj] = me;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tni += di;\n\t\t\t\t\t\tnj += dj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int[] dx = {0,0,1,-1,1,1,-1,-1};\n        int[] dy = {1,-1,0,0,1,-1,1,-1};\n\n        char[][] game = new char[8][8];\n        for(int i=0; i<8; i++){\n            String line = sc.next();\n            game[i] = line.toCharArray();\n        }\n\n        int turn = 0;\n        int conti = 0;\n        while(true){\n            int max = 0;\n            int x = -1, y = -1;\n            for(int i=0; i<8; i++){\n                for(int j=0; j<8; j++){\n                    if(game[i][j]!='.') continue;\n                    int cnt = 0;\n                    for(int k=0; k<8; k++){\n                        int nn = 1;\n                        while(true){\n                            int nx = j + dx[k]*nn, ny = i + dy[k]*nn;\n                            int nxx = j + dx[k]*(nn+1), nyy = i + dy[k]*(nn+1);\n                            if(nx<0 || nx>=8 || ny<0 || ny>=8 ||\n                               nxx<0 || nxx>=8 || nyy<0 || nyy>=8) break;\n                            if(turn==0){\n                                if(game[ny][nx]!='x') break;\n                                if(game[ny][nx]=='x' && game[nyy][nxx]=='o'){\n                                    cnt += nn;\n                                    break;\n                                }\n                            }\n                            if(turn==1){\n                                if(game[ny][nx]!='o') break;\n                                if(game[ny][nx]=='o' && game[nyy][nxx]=='x'){\n                                    cnt += nn;\n                                    break;\n                                }\n                            }\n                            nn++;\n                        }\n                    }\n                    if(turn==0 && cnt>max){\n                        max = cnt;\n                        x = j; y = i;\n                    }\n                    if(cnt!=0 && turn==1 && cnt>=max){\n                        max = cnt;\n                        x = j; y = i;\n                    }\n                }\n            }\n\n            if(x==-1){\n                if(conti==1) break;\n                conti = 1;\n                turn = 1 - turn;\n                continue;\n            }\n            conti = 0;\n\n            if(turn==0) game[y][x] = 'o';\n            else game[y][x] = 'x';\n\n            for(int i=0; i<8; i++){\n                boolean boo = false;\n                int nn = 1;\n                while(true){\n                    int nx = x + dx[i]*nn, ny = y + dy[i]*nn;\n                    int nxx = x + dx[i]*(nn+1), nyy = y + dy[i]*(nn+1);\n                    if(nx<0 || nx>=8 || ny<0 || ny>=8 ||\n                       nxx<0 || nxx>=8 || nyy<0 || nyy>=8) break;\n                    if(turn==0){\n                        if(game[ny][nx]!='x') break;\n                        if(game[ny][nx]=='x' && game[nyy][nxx]=='o'){\n                            boo = true;\n                            break;\n                        }\n                    }\n                    if(turn==1){\n                        if(game[ny][nx]!='o') break;\n                        if(game[ny][nx]=='o' && game[nyy][nxx]=='x'){\n                            boo = true;\n                            break;\n                        }\n                    }\n                    nn++;\n                }\n\n                nn = 1;\n                if(boo){\n                    while(true){\n                        int nx = x + dx[i]*nn, ny = y + dy[i]*nn;\n                        if(nx<0 || nx>=8 || ny<0 || ny>=8) break;\n                        if(turn==0){\n                            if(game[ny][nx]=='x') game[ny][nx] = 'o';\n                            else break;\n                        }\n                        if(turn==1){\n                            if(game[ny][nx]=='o') game[ny][nx] = 'x';\n                            else break;\n                        }\n                        nn++;\n                    }\n                }\n            }\n            turn = 1 - turn;\n        }\n\n        for(int i=0; i<8; i++){\n            System.out.println(String.valueOf(game[i]));\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static final int PANEL_SIZE = 8;\n\tstatic PrintStream out = System.out;\n\n\tpublic static final boolean MAMI = true;\n\tpublic static final boolean CHARROTTE = false;\n\n\tpublic static void main(String[] args) {\n\t\twrite(new Main(read()).solve());\n\t}\n\n\tstatic Boolean[][] read() {\n\t\tBoolean[][] boad = new Boolean[PANEL_SIZE][PANEL_SIZE];\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tchar[] row = sc.nextLine().toCharArray();\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tboad[i][j] = charToBool(row[j]);\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\treturn boad;\n\t}\n\n\tstatic void write(Boolean[][] boad) {\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tout.print(boolToChar(boad[i][j]));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tprivate static char boolToChar(Boolean bool) {\n\t\tif (bool == null) {\n\t\t\treturn '.';\n\t\t} else if (bool) {\n\t\t\treturn 'o';\n\t\t} else {\n\t\t\treturn 'x';\n\t\t}\n\t}\n\n\tprivate static Boolean charToBool(char panel) {\n\t\tswitch (panel) {\n\t\tcase 'o':\n\t\t\treturn true;\n\t\tcase 'x':\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate Boolean[][] boad;\n\tboolean player = MAMI;\n\n\tpublic DessertWitch(Boolean[][] boad) {\n\t\tthis.boad = boad;\n\t}\n\n\tpublic Boolean[][] solve() {\n\t\tBoolean[][] nextBoad;\n\t\tint passCount = 0;\n\t\tdo {\n\t\t\tnextBoad = next();\n\t\t\tif (nextBoad == null) {\n\t\t\t\tpassCount++;\n\t\t\t} else {\n\t\t\t\tpassCount = 0;\n\t\t\t}\n\t\t} while (passCount < 2);\n\t\treturn boad;\n\t}\n\n\tprotected Boolean[][] next() {\n\t\tBoolean[][] nextBoad = null;\n\t\tint maxScore = 0;\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tif (boad[i][j] == null) {\n\t\t\t\t\tCoordinate coordinate = new Coordinate(j, i);\n\t\t\t\t\tint score = getScore(coordinate);\n\t\t\t\t\tif (maxScore < score || (player == CHARROTTE && maxScore == score && maxScore > 0)) {\n\t\t\t\t\t\tmaxScore = score;\n\t\t\t\t\t\tnextBoad = nextBoad(coordinate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboad = nextBoad == null ? boad : nextBoad;\n\t\tplayer = !player;\n\t\treturn nextBoad;\n\t}\n\n\tBoolean[][] nextBoad(Coordinate coordinate) {\n\t\tif (boad[coordinate.y][coordinate.x] != null) {\n\t\t\treturn boad;\n\t\t}\n\n\t\tSet<Coordinate> panels = stepFunctions.stream()\n\t\t\t\t.flatMap(stepFunction -> getReversiblePanels(stepFunction, coordinate)).collect(Collectors.toSet());\n\t\tpanels.add(coordinate);\n\n\t\tBoolean[][] nextBoad = copyBoad();\n\t\tfor (Coordinate panel : panels) {\n\t\t\tnextBoad[panel.y][panel.x] = player;\n\t\t}\n\n\t\treturn nextBoad;\n\t}\n\n\tStream<Coordinate> getReversiblePanels(Function<Coordinate, Optional<Coordinate>> stepFunction,\n\t\t\tCoordinate startPos) {\n\t\tCoordinate tempPos = startPos;\n\t\tSet<Coordinate> tempPanels = new HashSet<>();\n\t\twhile (true) {\n\t\t\ttempPos = stepFunction.apply(tempPos).orElse(null);\n\t\t\tif (tempPos == null || boad[tempPos.y][tempPos.x] == null) {\n\t\t\t\treturn Stream.empty();\n\t\t\t} else if (boad[tempPos.y][tempPos.x] == player) {\n\t\t\t\treturn tempPanels.stream();\n\t\t\t} else {\n\t\t\t\ttempPanels.add(tempPos);\n\t\t\t}\n\t\t}\n\t}\n\n\tint getScore(Coordinate coordinate) {\n\t\tif (boad[coordinate.y][coordinate.x] != null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn stepFunctions.stream().mapToInt(function -> getScore(function, coordinate)).sum();\n\t}\n\n\tint getScore(Function<Coordinate, Optional<Coordinate>> stepFunction, Coordinate startPos) {\n\t\tint tempScore = 0;\n\t\tCoordinate tempPos = startPos;\n\t\twhile (true) {\n\t\t\ttempPos = stepFunction.apply(tempPos).orElse(null);\n\t\t\tif (tempPos == null || boad[tempPos.y][tempPos.x] == null) {\n\t\t\t\treturn 0;\n\t\t\t} else if (boad[tempPos.y][tempPos.x] == player) {\n\t\t\t\treturn tempScore;\n\t\t\t} else {\n\t\t\t\ttempScore++;\n\t\t\t}\n\t\t}\n\t}\n\n\tBoolean[][] copyBoad() {\n\t\tBoolean[][] nextBoad = new Boolean[PANEL_SIZE][PANEL_SIZE];\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tnextBoad[i][j] = boad[i][j];\n\t\t\t}\n\t\t}\n\t\treturn nextBoad;\n\t}\n\n\tstatic Function<Coordinate, Optional<Coordinate>> toTopLeft = coordinate -> coordinate.x > 0 && coordinate.y > 0\n\t\t\t? Optional.of(new Coordinate(coordinate.x - 1, coordinate.y - 1))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toTop = coordinate -> coordinate.y > 0\n\t\t\t? Optional.of(new Coordinate(coordinate.x, coordinate.y - 1))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toTopRight = coordinate -> coordinate.x < PANEL_SIZE - 1\n\t\t\t&& coordinate.y > 0 ? Optional.of(new Coordinate(coordinate.x + 1, coordinate.y - 1)) : Optional.empty();\n\n\tstatic Function<Coordinate, Optional<Coordinate>> toLeft = coordinate -> coordinate.x > 0\n\t\t\t? Optional.of(new Coordinate(coordinate.x - 1, coordinate.y))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toRight = coordinate -> coordinate.x < PANEL_SIZE - 1\n\t\t\t? Optional.of(new Coordinate(coordinate.x + 1, coordinate.y))\n\t\t\t: Optional.empty();\n\n\tstatic Function<Coordinate, Optional<Coordinate>> toBottomLeft = coordinate -> coordinate.x > 0\n\t\t\t&& coordinate.y < PANEL_SIZE - 1 ? Optional.of(new Coordinate(coordinate.x - 1, coordinate.y + 1))\n\t\t\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toBottom = coordinate -> coordinate.y < PANEL_SIZE - 1\n\t\t\t? Optional.of(new Coordinate(coordinate.x, coordinate.y + 1))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toBottomRight = coordinate -> coordinate.x < PANEL_SIZE - 1\n\t\t\t&& coordinate.y < PANEL_SIZE - 1 ? Optional.of(new Coordinate(coordinate.x + 1, coordinate.y + 1))\n\t\t\t\t\t: Optional.empty();\n\tstatic List<Function<Coordinate, Optional<Coordinate>>> stepFunctions = Arrays.asList(toTopLeft, toTop, toTopRight,\n\t\t\ttoLeft, toRight, toBottomLeft, toBottom, toBottomRight);\n\n\tstatic class Coordinate {\n\t\tint x, y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"[%d, %d]\", x, y);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\tstatic char[][] map = new char[8][8];\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tString tmp = stdIn.next();\n\t\t\tfor(int j = 0; j < 8; j++) {\n\t\t\t\tmap[i][j] = tmp.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true) {\n\t\t\tboolean M = cC();\n\t\t\tboolean C = cM();\n\n\t\t\t\n\t\t\tif(!M && !C) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tfor(int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic int[] xv = {1 ,0 ,-1,0 ,1 ,1 ,-1,-1};\n\tstatic int[] yv = {0 ,1 ,0 ,-1,1 ,-1,1 ,-1};\n\tpublic static boolean cM() {\n\t\tint max = 0;\n\t\tint maxX = 0;\n\t\tint maxY = 0;\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tfor(int j = 0; j < 8; j++) {\n\t\t\t\tif(map[i][j] != '.') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint NM = 0;\n\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\tfor(int l = 1; l < 10; l++) {\n\t\t\t\t\t\tint x = j + xv[k]*l;\n\t\t\t\t\t\tint y = i + yv[k]*l;\n\t\t\t\t\t\tif(x < 0 || y < 0 || x > 7 || y > 7) break;\n\t\t\t\t\t\tif(map[y][x] == '.') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[y][x] == 'x') {\n\t\t\t\t\t\t\tNM += (l-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//ch\n\t\t\t\tif(NM > max) {\n\t\t\t\t\tmax = NM;\n\t\t\t\t\tmaxX = j;\n\t\t\t\t\tmaxY = i;\n\t\t\t\t}\n\t\t\t\telse if(NM == max) {\n\t\t\t\t\tif(maxY < i) {\n\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if(maxY == i && maxX < j) {\n\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(max == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tIN:for(int l = 1; l < 10; l++) {\n\t\t\t\tint x = maxX + xv[k]*l;\n\t\t\t\tint y = maxY + yv[k]*l;\n\t\t\t\tif(x < 0 || y < 0 || x > 7 || y > 7) break;\n\t\t\t\tif(map[y][x] == '.') {\n\t\t\t\t\tbreak IN;\n\t\t\t\t}\n\t\t\t\tif(map[y][x] == 'x') {\n\t\t\t\t\tfor(int m = 0; m < l; m++) {\n\t\t\t\t\t\tmap[maxY + yv[k]*m][maxX + xv[k]*m] = 'x';\n\t\t\t\t\t}\n\t\t\t\t\tbreak IN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static boolean cC() {\n\t\tint max = 0;\n\t\tint maxX = 0;\n\t\tint maxY = 0;\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tfor(int j = 0; j < 8; j++) {\n\t\t\t\tif(map[i][j] != '.') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint NM = 0;\n\t\t\t\tfor(int k = 0; k < 8; k++) {\n\t\t\t\t\tfor(int l = 1; l < 10; l++) {\n\t\t\t\t\t\tint x = j + xv[k]*l;\n\t\t\t\t\t\tint y = i + yv[k]*l;\n\t\t\t\t\t\tif(x < 0 || y < 0 || x > 7 || y > 7) break;\n\t\t\t\t\t\tif(map[y][x] == '.') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[y][x] == 'o') {\n\t\t\t\t\t\t\tNM += (l-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(NM > max) {\n\t\t\t\t\tmax = NM;\n\t\t\t\t\tmaxX = j;\n\t\t\t\t\tmaxY = i;\n\t\t\t\t}\n\t\t\t\telse if(NM == max) {\n\t\t\t\t\tif(maxY > i) {\n\t\t\t\t\t\tmaxY = i;\n\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if(maxY == i && maxX > j) {\n\t\t\t\t\t\tmaxX = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(max == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tIN:for(int l = 1; l < 10; l++) {\n\t\t\t\tint x = maxX + xv[k]*l;\n\t\t\t\tint y = maxY + yv[k]*l;\n\t\t\t\tif(x < 0 || y < 0 || x > 7 || y > 7) break;\n\t\t\t\tif(map[y][x] == '.' ) {\n\t\t\t\t\tbreak IN;\n\t\t\t\t}\n\t\t\t\tif(map[y][x] == 'o') {\n\t\t\t\t\tfor(int m = 0; m < l; m++) {\n\t\t\t\t\t\tmap[maxY + yv[k]*m][maxX + xv[k]*m] = 'o';\n\t\t\t\t\t}\n\t\t\t\t\tbreak IN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static char[][] map = new char[8][8];\n    static char[] player = {'o', 'x'};\n\n    public static void main(String[] args) {\n        scanMap();\n        while (true) {\n            int o = playTurn(0);\n            int x = playTurn(1);\n\n            if (o == 0 && x == 0) break;\n        }\n        printMap();\n    }\n\n    static void scanMap() {\n        for (int i = 0; i < 8; i++) {\n            String st = s.next();\n            for (int j = 0; j < 8; j++)\n                map[i][j] = st.charAt(j);\n        }\n    }\n\n    static void printMap() {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++)\n                System.out.print(map[i][j]);\n            System.out.println();\n        }\n    }\n\n    static int checkPlace(int turn, int i, int j, int mode) {\n        int score = 0;\n        int opturn = turn + 1;\n        if (opturn == 2) opturn = 0;\n\n        if (map[i][j] != '.') return 0;\n\n        for (int n = i - 1; n <= i + 1; n++) {\n            for (int m = j - 1; m <= j + 1; m++) {\n                if (n < 0 || 7 < n || m < 0 || 7 < m) continue;\n                if (map[n][m] == player[opturn]) {\n                    score += scoreCount(i, j, n - i, m - j, turn, mode);\n                }\n            }\n        }\n        return score;\n    }\n\n    static int scoreCount(int i, int j, int imove, int jmove, int turn, int mode) {\n        int score = 0;\n        int opturn = turn + 1;\n        if (opturn == 2) opturn = 0;\n        int n = i;\n        int m = j;\n\n        while (true) {\n            i += imove;\n            j += jmove;\n            if (i < 0 || 7 < i || j < 0 || 7 < j) return 0;\n            if (map[i][j] == player[opturn]) {\n                score++;\n            } else if (map[i][j] == player[turn]) {\n                if (mode == 1) {\n                    while (i != n || j != m) {\n                        i -= imove;\n                        j -= jmove;\n                        map[i][j] = player[turn];\n                    }\n                }\n                return score;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    static int playTurn(int turn) {\n        int maxScore = 0;\n        int n = 0, m = 0;\n\n        if (turn == 0) {\n            for (int i = 0; i < 8; i++) {\n                for (int j = 0; j < 8; j++) {\n                    int score = checkPlace(turn, i, j, 0);\n                    if (maxScore < score) {\n                        maxScore = score;\n                        n = i;\n                        m = j;\n                    }\n                }\n            }\n        } else {\n            for (int i = 7; i > -1; i--) {\n                for (int j = 7; j > -1; j--) {\n                    int score = checkPlace(turn, i, j, 0);\n                    if (maxScore < score) {\n                        maxScore = score;\n                        n = i;\n                        m = j;\n                    }\n                }\n            }\n        }\n\n        if (maxScore != 0) {\n            changeMap(n, m, turn);\n            map[n][m] = player[turn];\n        }\n        return maxScore;\n    }\n\n    static void changeMap(int i, int j, int turn) {\n        int score = checkPlace(turn, i, j, 1);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] dy = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\t\tint[] dx = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\t\tchar[][] map = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tmap[i] = scanner.next().toCharArray();\n\t\tint flag = 0;\n\t\tint i = 0;\n\t\twhile (true) {\n\t\t\tchar my, en;\n\t\t\tif (i == 0) {\n\t\t\t\tmy = 'o';\n\t\t\t\ten = 'x';\n\t\t\t} else {\n\t\t\t\tmy = 'x';\n\t\t\t\ten = 'o';\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tint cx = 0, cy = 0, dr = 0;\n\t\t\tfor (int y = 0; y < 8; y++)\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tint hy = i == 0 ? y : 7 - y;\n\t\t\t\t\tint hx = i == 0 ? x : 7 - x;\n\t\t\t\t\tif (map[hy][hx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint cc = 0;\n\t\t\t\t\tint cdr = 0;\n\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint ny = hy + dy[j] * (c + 1);\n\t\t\t\t\t\t\tint nx = hx + dx[j] * (c + 1);\n\t\t\t\t\t\t\tif (nx < 0 || 8 <= nx || ny < 0 || 8 <= ny)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (map[ny][nx] == en) {\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else if (map[ny][nx] == my && c != 0) {\n\t\t\t\t\t\t\t\tcc += c;\n\t\t\t\t\t\t\t\tcdr |= (1 << j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (cc <= cnt)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcx = hx;\n\t\t\t\t\tcy = hy;\n\t\t\t\t\tdr = cdr;\n\t\t\t\t\tcnt = cc;\n\t\t\t\t}\n\t\t\ti = 1 - i;\n\t\t\tif (cnt == 0) {\n\t\t\t\tflag++;\n\t\t\t\tif(flag==2)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t\tmap[cy][cx] = my;\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (((dr >> j) & 1) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int k = 1; true; k++) {\n\t\t\t\t\tint nx = cx + dx[j] * k;\n\t\t\t\t\tint ny = cy + dy[j] * k;\n\t\t\t\t\tif (map[ny][nx] == my)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmap[ny][nx] = my;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tSystem.out.println(String.valueOf(map[j]));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tString[][] map = new String[8][8];\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tString line = sc.nextLine();\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tmap[i][j] = line.substring(j, j+1);\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tString tomoe = \"o\";\n\t\tString charlotte = \"x\";\n\t\t\n\t\tString now = tomoe;\n\t\tboolean tomoeC = true;\n\t\tString wait = charlotte;\n\t\tboolean charlotteC = true;\n\t\twhile(true){\n\t\t\tint max = 0;\n\t\t\tint maxI = 0;\n\t\t\tint maxJ = 0;\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\t\tif(map[i][j].equals(\".\")){ \n\t\t\t\t\t\tint c = check(i, j, now, wait, map);\n\t\t\t\t\t\tif(c == max && now.equals(tomoe)){\n\t\t\t\t\t\t\tif(i < maxI || (i == maxI && j < maxJ)){ \n\t\t\t\t\t\t\t\tmaxJ = j; maxI = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(c == max && now.equals(charlotte)){\n\t\t\t\t\t\t\tif(i > maxI || (i == maxI && j > maxJ)){\n\t\t\t\t\t\t\t\tmaxJ = j; maxI = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(c > max){\n\t\t\t\t\t\t\tmax = c;\n\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t\tmaxJ = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!tomoeC && !charlotteC) break;\n\t\t\tif(max == 0) {\n\t\t\t\tif(now.equals(tomoe)) tomoeC = false;\n\t\t\t\telse charlotteC = false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[maxI][maxJ] = now;\n\t\t\t\tturn(maxI, maxJ, now, wait, map);\n\t\t\t}\n\t\t\tString t = now;\n\t\t\tnow = wait;\n\t\t\twait = t;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tSystem.out.printf(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic int check(int i, int j, String now, String wait, String[][] map){\n\t\tint sum = 0;\n\t\tint[] x = { 0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint[] y = {-1,-1, 0, 1, 1, 1, 0,-1};\n\t\t\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tint nx = i + x[k];\n\t\t\tint ny = j + y[k];\n\t\t\tint s = 0;\n\t\t\twhile(nx < 8 && ny < 8 && nx >= 0 && ny >= 0){\n\t\t\t\tif(map[nx][ny].equals(wait)) \n\t\t\t\t\ts++;\n\t\t\t\telse if(map[nx][ny].equals(now))\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\ts = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnx = nx + x[k];\n\t\t\t\tny = ny + y[k];\n\t\t\t\tif(nx >= 8 || ny >= 8 || nx < 0 || ny < 0) s = 0;\n\t\t\t}\n\t\t\tsum += s;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic void turn(int i, int j, String now, String wait, String[][] map){\n\t\tint[] x = { 0, 1, 1, 1, 0,-1,-1,-1};\n\t\tint[] y = {-1,-1, 0, 1, 1, 1, 0,-1};\n\t\t\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tint nx = i + x[k];\n\t\t\tint ny = j + y[k];\n\t\t\tint s = 0;\n\t\t\twhile(nx < 8 && ny < 8 && nx >= 0 && ny >= 0){\n\t\t\t\tif(map[nx][ny].equals(wait)) \n\t\t\t\t\ts++;\n\t\t\t\telse if(map[nx][ny].equals(now))\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\ts = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnx = nx + x[k];\n\t\t\t\tny = ny + y[k];\n\t\t\t\tif(nx >= 8 || ny >= 8 || nx < 0 || ny < 0) s = 0;\n\t\t\t}\n\t\t\tif(s > 0){\n\t\t\t\tnx = i + x[k];\n\t\t\t\tny = j + y[k];\n\t\t\t\tfor(int t = 0; t < s; t++){\n\t\t\t\t\tmap[nx][ny] = now;\n\t\t\t\t\tnx = nx + x[k];\n\t\t\t\t\tny = ny + y[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tsolve();\n\t}\n\tpublic static void solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] s = new String[8];\n\t\tint[][] map = new int[8][8];\n\t\tboolean turn = true;\n\t\tboolean[] skip = {true, true};\n\t\tint[] dx = {1,1,1,0,-1,-1,-1,0};\n\t\tint[] dy = {1,0,-1,-1,-1,0,1,1};\n\t\tfor(int i=0;i<8;i++){\n\t\t\ts[i] = sc.next();\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i].charAt(j)=='.'){\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if(s[i].charAt(j)=='o'){\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(turn){\n\t\t\t\tskip[0] = true;\n\t\t\t\tskip[1] = true;\n\t\t\t}\n\t\t\tint nextmax = 0;\n\t\t\tint count = 0;\n\t\t\tint nextx = -1;\n\t\t\tint nexty = -1;\n\t\t\tif(turn){\n\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tif(i+dx[k]<0 || i+dx[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j+dy[k]<0 || j+dy[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i+dx[k]][j+dy[k]]==1){\n\t\t\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\t\t\tif(i+l*dx[k]<0 || i+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j+l*dy[k]<0 || j+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==0){\n\t\t\t\t\t\t\t\t\t\t\tcount += l - 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nextmax<count){\n\t\t\t\t\t\t\t\tnextx = i;\n\t\t\t\t\t\t\t\tnexty = j;\n\t\t\t\t\t\t\t\tnextmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextx==-1){\n\t\t\t\t\tskip[0] = false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tif(nextx+dx[k]<0 || nextx+dx[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nexty+dy[k]<0 || nexty+dy[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[nextx+dx[k]][nexty+dy[k]]==1){\n\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\tif(nextx+l*dx[k]<0 || nextx+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nexty+l*dy[k]<0 || nexty+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==0){\n\t\t\t\t\t\t\t\t\tfor(int m=0;m<l;m++){\n\t\t\t\t\t\t\t\t\t\tmap[nextx+m*dx[k]][nexty+m*dy[k]] = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnextmax=1;\n\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tif(i+dx[k]<0 || i+dx[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j+dy[k]<0 || j+dy[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i+dx[k]][j+dy[k]]==0){\n\t\t\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\t\t\tif(i+l*dx[k]<0 || i+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j+l*dy[k]<0 || j+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==1){\n\t\t\t\t\t\t\t\t\t\t\tcount += l - 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nextmax<=count){\n\t\t\t\t\t\t\t\tnextx = i;\n\t\t\t\t\t\t\t\tnexty = j;\n\t\t\t\t\t\t\t\tnextmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextx==-1){\n\t\t\t\t\tskip[1] = false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tif(nextx+dx[k]<0 || nextx+dx[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nexty+dy[k]<0 || nexty+dy[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[nextx+dx[k]][nexty+dy[k]]==0){\n\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\tif(nextx+l*dx[k]<0 || nextx+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nexty+l*dy[k]<0 || nexty+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==1){\n\t\t\t\t\t\t\t\t\tfor(int m=0;m<l;m++){\n\t\t\t\t\t\t\t\t\t\tmap[nextx+m*dx[k]][nexty+m*dy[k]] = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!skip[0] && !skip[1]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]==-1)\n\t\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tturn = !turn;\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]==0){\n\t\t\t\t\tSystem.out.print(\"o\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.print(\"x\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[][] map = new String[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tString line = br.readLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tmap[i][j] = line.substring(j, j + 1);\n\t\t\t}\n\t\t}\n\n\t\tString tomoe = \"o\";\n\t\tString charlotte = \"x\";\n\n\t\tString now = tomoe;\n\t\tboolean tomoeC = true;\n\t\tString wait = charlotte;\n\t\tboolean charlotteC = true;\n\t\twhile (true) {\n\t\t\tint max = 0;\n\t\t\tint maxI = 0;\n\t\t\tint maxJ = 0;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (map[i][j].equals(\".\")) {\n\t\t\t\t\t\tint c = ch(i, j, now, wait, map);\n\t\t\t\t\t\tif (c == max && now.equals(tomoe)) {\n\t\t\t\t\t\t\tif (i < maxI || (i == maxI && j < maxJ)) {\n\t\t\t\t\t\t\t\tmaxJ = j;\n\t\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (c == max && now.equals(charlotte)) {\n\t\t\t\t\t\t\tif (i > maxI || (i == maxI && j > maxJ)) {\n\t\t\t\t\t\t\t\tmaxJ = j;\n\t\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (c > max) {\n\t\t\t\t\t\t\tmax = c;\n\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t\tmaxJ = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!tomoeC && !charlotteC)\n\t\t\t\tbreak;\n\t\t\tif (max == 0) {\n\t\t\t\tif (now.equals(tomoe))\n\t\t\t\t\ttomoeC = false;\n\t\t\t\telse\n\t\t\t\t\tcharlotteC = false;\n\t\t\t} else {\n\t\t\t\tmap[maxI][maxJ] = now;\n\t\t\t\ttu(maxI, maxJ, now, wait, map);\n\t\t\t}\n\t\t\tString t = now;\n\t\t\tnow = wait;\n\t\t\twait = t;\n\t\t}\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.printf(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static int ch(int i, int j, String now, String wait, String[][] map) {\n\t\tint sum = 0;\n\t\tint[] x = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\tint[] y = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\t\tfor (int k = 0; k < 8; k++) {\n\t\t\tint nx = i + x[k];\n\t\t\tint ny = j + y[k];\n\t\t\tint s = 0;\n\t\t\twhile (nx < 8 && ny < 8 && nx >= 0 && ny >= 0) {\n\t\t\t\tif (map[nx][ny].equals(wait))\n\t\t\t\t\ts++;\n\t\t\t\telse if (map[nx][ny].equals(now))\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\ts = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnx = nx + x[k];\n\t\t\t\tny = ny + y[k];\n\t\t\t\tif (nx >= 8 || ny >= 8 || nx < 0 || ny < 0)\n\t\t\t\t\ts = 0;\n\t\t\t}\n\t\t\tsum += s;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic static void tu(int i, int j, String now, String wait, String[][] map) {\n\t\tint[] x = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\tint[] y = { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n\t\tfor (int k = 0; k < 8; k++) {\n\t\t\tint nx = i + x[k];\n\t\t\tint ny = j + y[k];\n\t\t\tint s = 0;\n\t\t\twhile (nx < 8 && ny < 8 && nx >= 0 && ny >= 0) {\n\t\t\t\tif (map[nx][ny].equals(wait))\n\t\t\t\t\ts++;\n\t\t\t\telse if (map[nx][ny].equals(now))\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\ts = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnx = nx + x[k];\n\t\t\t\tny = ny + y[k];\n\t\t\t\tif (nx >= 8 || ny >= 8 || nx < 0 || ny < 0)\n\t\t\t\t\ts = 0;\n\t\t\t}\n\t\t\tif (s > 0) {\n\t\t\t\tnx = i + x[k];\n\t\t\t\tny = j + y[k];\n\t\t\t\tfor (int t = 0; t < s; t++) {\n\t\t\t\t\tmap[nx][ny] = now;\n\t\t\t\t\tnx = nx + x[k];\n\t\t\t\t\tny = ny + y[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[][] field = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tString str = sc.next();\n\t\t\tchar[] c = str.toCharArray();\n\t\t\tfor (int j = 0; j < str.length(); j++) {\n\t\t\t\tfield[i][j] = c[j];\n\t\t\t}\n\t\t}\n\t\tchar turn = 'o';\n\t\tint[] result = { 0, 0, 0 };\n\t\tboolean opassed = false;\n\t\tboolean xpassed = false;\n\t\tdo {\n\t\t\tArrays.fill(result, 0);\n\t\t\tchar[][] tfield = new char[8][8];\n\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\t\ttfield[i][j] = field[i][j];\n\t\t\tint a = count(field, turn);\n\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (tfield[i][j] == '.')\n\t\t\t\t\t\tmove(tfield, turn, i, j);\n\t\t\t\t\tint b = count(tfield, turn);\n\t\t\t\t\tif (b - a > Math.max(result[0], 1)) {\n\t\t\t\t\t\tresult[0] = b - a;\n\t\t\t\t\t\tresult[1] = j;\n\t\t\t\t\t\tresult[2] = i;\n\t\t\t\t\t} else if (result[0] > 1 && b - a == result[0]) {\n\t\t\t\t\t\tif (turn == 'o') {\n\t\t\t\t\t\t\tif (i < result[2]\n\t\t\t\t\t\t\t\t\t|| (i == result[2] && j < result[1])) {\n\t\t\t\t\t\t\t\tresult[1] = j;\n\t\t\t\t\t\t\t\tresult[2] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (turn == 'x') {\n\t\t\t\t\t\t\tif (i > result[2]\n\t\t\t\t\t\t\t\t\t|| (i == result[2] && j > result[1])) {\n\t\t\t\t\t\t\t\tresult[1] = j;\n\t\t\t\t\t\t\t\tresult[2] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < 8; k++)\n\t\t\t\t\t\tfor (int l = 0; l < 8; l++)\n\t\t\t\t\t\t\ttfield[k][l] = field[k][l];\n\t\t\t\t}\n\t\t\tif (result[0] > 1) {\n\t\t\t\tmove(field, turn, result[2], result[1]);\n\t\t\t\tif (turn == 'o')\n\t\t\t\t\topassed = false;\n\t\t\t\tif (turn == 'x')\n\t\t\t\t\txpassed = false;\n\t\t\t} else {\n\t\t\t\tif (turn == 'o')\n\t\t\t\t\topassed = true;\n\t\t\t\tif (turn == 'x')\n\t\t\t\t\txpassed = true;\n\t\t\t}\n\t\t\tif (turn == 'o')\n\t\t\t\tturn = 'x';\n\t\t\telse\n\t\t\t\tturn = 'o';\n\t\t} while (!(opassed && xpassed));\n\t\tprintfield(field);\n\t\tsc.close();\n\t}\n\n\tstatic void printfield(char[][] field) {\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic int count(char[][] field, char turn) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\tif (field[i][j] == turn)\n\t\t\t\t\tresult++;\n\t\treturn result;\n\t}\n\n\tstatic void move(char[][] field, char turn, int x, int y) {\n\t\tint[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\tint[] dy = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\tfield[x][y] = turn;\n\t\tfor (int i = 0; i < dx.length; i++) {\n\t\t\tif (x + dx[i] >= 0 && x + dx[i] < 8 && y + dy[i] >= 0\n\t\t\t\t\t&& y + dy[i] < 8) {\n\t\t\t\tif ((turn == 'o' && field[x + dx[i]][y + dy[i]] == 'x')\n\t\t\t\t\t\t|| (turn == 'x' && field[x + dx[i]][y + dy[i]] == 'o')) {\n\t\t\t\t\tfor (int j = 2; j < 8; j++) {\n\t\t\t\t\t\tif (x + j * dx[i] >= 0 && x + j * dx[i] < 8\n\t\t\t\t\t\t\t\t&& y + j * dy[i] >= 0 && y + j * dy[i] < 8) {\n\t\t\t\t\t\t\tif (field[x + j * dx[i]][y + j * dy[i]] == '.')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (field[x][y] == field[x + j * dx[i]][y + j\n\t\t\t\t\t\t\t\t\t* dy[i]]) {\n\t\t\t\t\t\t\t\tfor (int k = 1; k < j; k++)\n\t\t\t\t\t\t\t\t\tfield[x + k * dx[i]][y + k * dy[i]] = field[x][y];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] dy = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\t\tint[] dx = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\t\tchar[][] map = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tmap[i] = scanner.next().toCharArray();\n\t\tchar my, en;\n\t\tint u = 0;\n\t\tint flag = 0;\n\t\twhile (true) {\n\t\t\tif (u == 0) {\n\t\t\t\tmy = 'o';\n\t\t\t\ten = 'x';\n\t\t\t} else {\n\t\t\t\tmy = 'x';\n\t\t\t\ten = 'o';\n\t\t\t}\n\t\t\tint cnt = 0, ey = 0, ex = 0, dir = 0;\n\t\t\tfor (int y = 0; y < 8; y++)\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tint hy = u == 0 ? y : 7 - y;\n\t\t\t\t\tint hx = u == 0 ? x : 7 - x;\n\t\t\t\t\tif (map[hy][hx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint cc = 0, ndir = 0;\n\t\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint ny = hy + dy[i] * (c + 1);\n\t\t\t\t\t\t\tint nx = hx + dx[i] * (c + 1);\n\t\t\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (map[ny][nx] == en) {\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else if (map[ny][nx] == my && c != 0) {\n\t\t\t\t\t\t\t\tcc += c;\n\t\t\t\t\t\t\t\tndir |= (1 << i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= cc)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcnt = cc;\n\t\t\t\t\tey = hy;\n\t\t\t\t\tex = hx;\n\t\t\t\t\tdir = ndir;\n\t\t\t\t}\n\t\t\tu = 1 - u;\n\t\t\tif (cnt == 0) {\n\t\t\t\tflag++;\n\t\t\t\tif (flag == 2)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmap[ey][ex] = my;\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tif (((dir >> i) & 1) == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint k = 1;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint ny = ey + dy[i] * k;\n\t\t\t\t\t\tint nx = ex + dx[i] * k;\n\t\t\t\t\t\tif (map[ny][nx] == my)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tmap[ny][nx] = my;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (char[] ans : map)\n\t\t\tSystem.out.println(ans);\n\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < 8 && 0 <= nx && nx < 8;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static final int PANEL_SIZE = 8;\n\tstatic PrintStream out = System.out;\n\n\tpublic static final boolean MAMI = true;\n\tpublic static final boolean CHARROTTE = false;\n\n\tpublic static void main(String[] args) {\n\t\twrite(new Main(read()).solve());\n\t}\n\n\tstatic Boolean[][] read() {\n\t\tBoolean[][] boad = new Boolean[PANEL_SIZE][PANEL_SIZE];\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tchar[] row = sc.nextLine().toCharArray();\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tboad[i][j] = charToBool(row[j]);\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\treturn boad;\n\t}\n\n\tstatic void write(Boolean[][] boad) {\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tout.print(boolToChar(boad[i][j]));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tprivate static char boolToChar(Boolean bool) {\n\t\tif (bool == null) {\n\t\t\treturn '.';\n\t\t} else if (bool) {\n\t\t\treturn 'o';\n\t\t} else {\n\t\t\treturn 'x';\n\t\t}\n\t}\n\n\tprivate static Boolean charToBool(char panel) {\n\t\tswitch (panel) {\n\t\tcase 'o':\n\t\t\treturn true;\n\t\tcase 'x':\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate Boolean[][] boad;\n\tboolean player = MAMI;\n\n\tpublic Main(Boolean[][] boad) {\n\t\tthis.boad = boad;\n\t}\n\n\tpublic Boolean[][] solve() {\n\t\tBoolean[][] nextBoad;\n\t\tint passCount = 0;\n\t\tdo {\n\t\t\tnextBoad = next();\n\t\t\tif (nextBoad == null) {\n\t\t\t\tpassCount++;\n\t\t\t} else {\n\t\t\t\tpassCount = 0;\n\t\t\t}\n\t\t} while (passCount < 2);\n\t\treturn boad;\n\t}\n\n\tprotected Boolean[][] next() {\n\t\tBoolean[][] nextBoad = null;\n\t\tint maxScore = 0;\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tif (boad[i][j] == null) {\n\t\t\t\t\tCoordinate coordinate = new Coordinate(j, i);\n\t\t\t\t\tint score = getScore(coordinate);\n\t\t\t\t\tif (maxScore < score || (player == CHARROTTE && maxScore == score && maxScore > 0)) {\n\t\t\t\t\t\tmaxScore = score;\n\t\t\t\t\t\tnextBoad = nextBoad(coordinate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboad = nextBoad == null ? boad : nextBoad;\n\t\tplayer = !player;\n\t\treturn nextBoad;\n\t}\n\n\tBoolean[][] nextBoad(Coordinate coordinate) {\n\t\tif (boad[coordinate.y][coordinate.x] != null) {\n\t\t\treturn boad;\n\t\t}\n\n\t\tSet<Coordinate> panels = stepFunctions.stream()\n\t\t\t\t.flatMap(stepFunction -> getReversiblePanels(stepFunction, coordinate)).collect(Collectors.toSet());\n\t\tpanels.add(coordinate);\n\n\t\tBoolean[][] nextBoad = copyBoad();\n\t\tfor (Coordinate panel : panels) {\n\t\t\tnextBoad[panel.y][panel.x] = player;\n\t\t}\n\n\t\treturn nextBoad;\n\t}\n\n\tStream<Coordinate> getReversiblePanels(Function<Coordinate, Optional<Coordinate>> stepFunction,\n\t\t\tCoordinate startPos) {\n\t\tCoordinate tempPos = startPos;\n\t\tSet<Coordinate> tempPanels = new HashSet<>();\n\t\twhile (true) {\n\t\t\ttempPos = stepFunction.apply(tempPos).orElse(null);\n\t\t\tif (tempPos == null || boad[tempPos.y][tempPos.x] == null) {\n\t\t\t\treturn Stream.empty();\n\t\t\t} else if (boad[tempPos.y][tempPos.x] == player) {\n\t\t\t\treturn tempPanels.stream();\n\t\t\t} else {\n\t\t\t\ttempPanels.add(tempPos);\n\t\t\t}\n\t\t}\n\t}\n\n\tint getScore(Coordinate coordinate) {\n\t\tif (boad[coordinate.y][coordinate.x] != null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn stepFunctions.stream().mapToInt(function -> getScore(function, coordinate)).sum();\n\t}\n\n\tint getScore(Function<Coordinate, Optional<Coordinate>> stepFunction, Coordinate startPos) {\n\t\tint tempScore = 0;\n\t\tCoordinate tempPos = startPos;\n\t\twhile (true) {\n\t\t\ttempPos = stepFunction.apply(tempPos).orElse(null);\n\t\t\tif (tempPos == null || boad[tempPos.y][tempPos.x] == null) {\n\t\t\t\treturn 0;\n\t\t\t} else if (boad[tempPos.y][tempPos.x] == player) {\n\t\t\t\treturn tempScore;\n\t\t\t} else {\n\t\t\t\ttempScore++;\n\t\t\t}\n\t\t}\n\t}\n\n\tBoolean[][] copyBoad() {\n\t\tBoolean[][] nextBoad = new Boolean[PANEL_SIZE][PANEL_SIZE];\n\t\tfor (int i = 0; i < PANEL_SIZE; i++) {\n\t\t\tfor (int j = 0; j < PANEL_SIZE; j++) {\n\t\t\t\tnextBoad[i][j] = boad[i][j];\n\t\t\t}\n\t\t}\n\t\treturn nextBoad;\n\t}\n\n\tstatic Function<Coordinate, Optional<Coordinate>> toTopLeft = coordinate -> coordinate.x > 0 && coordinate.y > 0\n\t\t\t? Optional.of(new Coordinate(coordinate.x - 1, coordinate.y - 1))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toTop = coordinate -> coordinate.y > 0\n\t\t\t? Optional.of(new Coordinate(coordinate.x, coordinate.y - 1))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toTopRight = coordinate -> coordinate.x < PANEL_SIZE - 1\n\t\t\t&& coordinate.y > 0 ? Optional.of(new Coordinate(coordinate.x + 1, coordinate.y - 1)) : Optional.empty();\n\n\tstatic Function<Coordinate, Optional<Coordinate>> toLeft = coordinate -> coordinate.x > 0\n\t\t\t? Optional.of(new Coordinate(coordinate.x - 1, coordinate.y))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toRight = coordinate -> coordinate.x < PANEL_SIZE - 1\n\t\t\t? Optional.of(new Coordinate(coordinate.x + 1, coordinate.y))\n\t\t\t: Optional.empty();\n\n\tstatic Function<Coordinate, Optional<Coordinate>> toBottomLeft = coordinate -> coordinate.x > 0\n\t\t\t&& coordinate.y < PANEL_SIZE - 1 ? Optional.of(new Coordinate(coordinate.x - 1, coordinate.y + 1))\n\t\t\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toBottom = coordinate -> coordinate.y < PANEL_SIZE - 1\n\t\t\t? Optional.of(new Coordinate(coordinate.x, coordinate.y + 1))\n\t\t\t: Optional.empty();\n\tstatic Function<Coordinate, Optional<Coordinate>> toBottomRight = coordinate -> coordinate.x < PANEL_SIZE - 1\n\t\t\t&& coordinate.y < PANEL_SIZE - 1 ? Optional.of(new Coordinate(coordinate.x + 1, coordinate.y + 1))\n\t\t\t\t\t: Optional.empty();\n\tstatic List<Function<Coordinate, Optional<Coordinate>>> stepFunctions = Arrays.asList(toTopLeft, toTop, toTopRight,\n\t\t\ttoLeft, toRight, toBottomLeft, toBottom, toBottomRight);\n\n\tstatic class Coordinate {\n\t\tint x, y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"[%d, %d]\", x, y);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] dy = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\t\tint[] dx = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\t\tchar[][] map = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tmap[i] = scanner.next().toCharArray();\n\t\twhile (true) {\n\t\t\tboolean flag = false;\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tchar my, en;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tmy = 'o';\n\t\t\t\t\ten = 'x';\n\t\t\t\t} else {\n\t\t\t\t\tmy = 'x';\n\t\t\t\t\ten = 'o';\n\t\t\t\t}\n\t\t\t\tint cnt = 0;\n\t\t\t\tint cx = 0, cy = 0, dr = 0;\n\t\t\t\tfor (int y = 0; y < 8; y++)\n\t\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\t\tint hy = i == 0 ? y : 7 - y;\n\t\t\t\t\t\tint hx = i == 0 ? x : 7 - x;\n\t\t\t\t\t\tif (map[hy][hx] != '.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint cc = 0;\n\t\t\t\t\t\tint cdr = 0;\n\t\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tint ny = hy + dy[j] * (c + 1);\n\t\t\t\t\t\t\t\tint nx = hx + dx[j] * (c + 1);\n\t\t\t\t\t\t\t\tif (nx < 0 || 8 <= nx || ny < 0 || 8 <= ny)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tif (map[ny][nx] == en) {\n\t\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else if (map[ny][nx] == my && c != 0) {\n\t\t\t\t\t\t\t\t\tcc += c;\n\t\t\t\t\t\t\t\t\tcdr |= (1 << j);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cc <= cnt)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcx = hx;\n\t\t\t\t\t\tcy = hy;\n\t\t\t\t\t\tdr = cdr;\n\t\t\t\t\t\tcnt = cc;\n\t\t\t\t\t}\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tmap[cy][cx] = my;\n\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\t\tif ((dr & (1 << j)) != 0) {\n\t\t\t\t\t\t\tfor (int k = 1; true; k++) {\n\t\t\t\t\t\t\t\tint nx = cx + dx[j] * k;\n\t\t\t\t\t\t\t\tint ny = cy + dy[j] * k;\n\t\t\t\t\t\t\t\tif (map[ny][nx] == my)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tmap[ny][nx] = my;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tbreak;\n\n\t\t}\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tSystem.out.println(String.valueOf(map[i]));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 8;\n\t\n\tpublic static boolean ok(int x, int y){\n\t\tif(x < 0 || x >= MAX || y < 0 || y >= MAX){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int check_dir(int x, int y, int color, int dx, int dy, int[][] board){\n\t\tif(board[y][x] != color){\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tx += dx;\n\t\t\ty += dy;\n\t\t\t\n\t\t\tif(!ok(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else if(board[y][x] == color){\n\t\t\t\treturn count;\n\t\t\t}else if(board[y][x] == 0){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}\n\t\t\t\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tpublic static void do_dir(int x, int y, int color, int dx, int dy, int[][] board){\n\t\tif(board[y][x] != color){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tx += dx;\n\t\t\ty += dy;\n\t\t\t\n\t\t\tif(!ok(x, y)){\n\t\t\t\treturn;\n\t\t\t}else if(board[y][x] == color){\n\t\t\t\treturn;\n\t\t\t}else if(board[y][x] == 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tboard[y][x] = color;\n\t\t}\n\t}\n\t\n\tpublic static boolean do_it(int color, int[][] board){\n\t\tint max = 0;\n\t\tint m_x = -1, m_y = -1;\n\t\t\n\t\tfor(int y = 0; y < MAX; y++){\n\t\t\tfor(int x = 0; x < MAX; x++){\n\t\t\t\tif(board[y][x] != 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboard[y][x] = color;\n\t\t\t\tint sum = 0;\n\t\t\t\t\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\t\t\tif(dy == 0 && dx == 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int cur = check_dir(x, y, color, dx, dy, board);\n\t\t\t\t\t\tif(cur > 0){\n\t\t\t\t\t\t\tsum += cur;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(color == 1){\n\t\t\t\t\tif(max < sum){\n\t\t\t\t\t\tmax = sum;\n\t\t\t\t\t\tm_x = x;\n\t\t\t\t\t\tm_y = y;\n\t\t\t\t\t}\n\t\t\t\t}else if(sum > 0){\n\t\t\t\t\tif(max <= sum){\n\t\t\t\t\t\tmax = sum;\n\t\t\t\t\t\tm_x = x;\n\t\t\t\t\t\tm_y = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboard[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(m_x != -1 && m_y != -1){\n\t\t\tboard[m_y][m_x] = color;\n\t\t\t\n\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\t\tif(dy == 0 && dx == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(check_dir(m_x, m_y, color, dx, dy, board) > 0){\n\t\t\t\t\t\tdo_dir(m_x, m_y, color, dx, dy, board);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static void draw(int[][] board){\n\t\tfor(int i = 0; i < MAX; i++){\n\t\t\tfor(int j = 0; j < MAX; j++){\n\t\t\t\tSystem.out.print(board[i][j] == 1 ? 'o' : board[i][j] == -1 ? 'x' : '.');\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\tint[][] board = new int[MAX][MAX];\n\t\t\n\t\tfor(int i = 0; i < MAX; i++){\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\n\t\t\tfor(int j = 0; j < MAX; j++){\n\t\t\t\tif(input[j] == 'o'){\n\t\t\t\t\tboard[i][j] = 1;\n\t\t\t\t}else if(input[j] == 'x'){\n\t\t\t\t\tboard[i][j] = -1;\n\t\t\t\t}else{\n\t\t\t\t\tboard[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint turn = 1;\n\t\tboolean before_skip = false;\n\t\twhile(true){\n\t\t\tif(!do_it(turn, board)){\n\t\t\t\tif(before_skip){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tbefore_skip = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbefore_skip = false;\n\t\t\t}\n\t\t\t\n\t\t\tturn = -turn;\n\t\t\t//draw(board);\n\t\t\t//System.out.println(\"--------\");\n\t\t}\n\t\t\n\t\tdraw(board);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[][] field = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tString str = sc.next();\n\t\t\tchar[] c = str.toCharArray();\n\t\t\tfor (int j = 0; j < str.length(); j++) {\n\t\t\t\tfield[i][j] = c[j];\n\t\t\t}\n\t\t}\n\t\tchar turn = 'o';\n\t\tint[] result = { 0, 0, 0 };\n\t\tboolean opassed = false;\n\t\tboolean xpassed = false;\n\t\tdo {\n\t\t\tArrays.fill(result, 0);\n\t\t\tchar[][] tfield = new char[8][8];\n\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\t\ttfield[i][j] = field[i][j];\n\t\t\tint a = count(field, turn);\n\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (tfield[i][j] == '.')\n\t\t\t\t\t\tmove(tfield, turn, i, j);\n\t\t\t\t\tint b = count(tfield, turn);\n\t\t\t\t\tif (b - a > Math.max(result[0], 1)) {\n\t\t\t\t\t\tresult[0] = b - a;\n\t\t\t\t\t\tresult[1] = j;\n\t\t\t\t\t\tresult[2] = i;\n\t\t\t\t\t} else if (result[0] > 1 && b - a == result[0]) {\n\t\t\t\t\t\tif (turn == 'o') {\n\t\t\t\t\t\t\tif (i < result[2]\n\t\t\t\t\t\t\t\t\t|| (i == result[2] && j < result[1])) {\n\t\t\t\t\t\t\t\tresult[1] = j;\n\t\t\t\t\t\t\t\tresult[2] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (turn == 'x') {\n\t\t\t\t\t\t\tif (i > result[2]\n\t\t\t\t\t\t\t\t\t|| (i == result[2] && j > result[1])) {\n\t\t\t\t\t\t\t\tresult[1] = j;\n\t\t\t\t\t\t\t\tresult[2] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < 8; k++)\n\t\t\t\t\t\tfor (int l = 0; l < 8; l++)\n\t\t\t\t\t\t\ttfield[k][l] = field[k][l];\n\t\t\t\t}\n\t\t\tif (result[0] > 1) {\n\t\t\t\tmove(field, turn, result[2], result[1]);\n\t\t\t\tif (turn == 'o')\n\t\t\t\t\topassed = false;\n\t\t\t\tif (turn == 'x')\n\t\t\t\t\txpassed = false;\n\t\t\t} else {\n\t\t\t\tif (turn == 'o')\n\t\t\t\t\topassed = true;\n\t\t\t\tif (turn == 'x')\n\t\t\t\t\txpassed = true;\n\t\t\t}\n\t\t\tif (turn == 'o')\n\t\t\t\tturn = 'x';\n\t\t\telse\n\t\t\t\tturn = 'o';\n\t\t} while (!(opassed && xpassed));\n\t\tprintfield(field);\n\t\tsc.close();\n\t}\n\n\tstatic void printfield(char[][] field) {\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int count(char[][] field, char turn) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\tif (field[i][j] == turn)\n\t\t\t\t\tresult++;\n\t\treturn result;\n\t}\n\n\tstatic void move(char[][] field, char turn, int x, int y) {\n\t\tint[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };\n\t\tint[] dy = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\t\tfield[x][y] = turn;\n\t\tfor (int i = 0; i < dx.length; i++) {\n\t\t\tif (x + dx[i] >= 0 && x + dx[i] < 8 && y + dy[i] >= 0\n\t\t\t\t\t&& y + dy[i] < 8) {\n\t\t\t\tif ((turn == 'o' && field[x + dx[i]][y + dy[i]] == 'x')\n\t\t\t\t\t\t|| (turn == 'x' && field[x + dx[i]][y + dy[i]] == 'o')) {\n\t\t\t\t\tfor (int j = 2; j < 8; j++) {\n\t\t\t\t\t\tif (x + j * dx[i] >= 0 && x + j * dx[i] < 8\n\t\t\t\t\t\t\t\t&& y + j * dy[i] >= 0 && y + j * dy[i] < 8) {\n\t\t\t\t\t\t\tif (field[x + j * dx[i]][y + j * dy[i]] == '.')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (field[x][y] == field[x + j * dx[i]][y + j\n\t\t\t\t\t\t\t\t\t* dy[i]]) {\n\t\t\t\t\t\t\t\tfor (int k = 1; k < j; k++)\n\t\t\t\t\t\t\t\t\tfield[x + k * dx[i]][y + k * dy[i]] = field[x][y];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static char[][] map = new char[8][8];\n    static char[] player = {'o', 'x'};\n\n    public static void main(String[] args) {\n        scanMap();\n        while (true) {\n            int o = playTurn(0);\n            int x = playTurn(1);\n\n            if (o == 0 && x == 0) break;\n        }\n        printMap();\n    }\n\n    static void scanMap() {\n        for (int i = 0; i < 8; i++) {\n            String st = s.next();\n            for (int j = 0; j < 8; j++)\n                map[i][j] = st.charAt(j);\n        }\n    }\n\n    static void printMap() {\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++)\n                System.out.print(map[i][j]);\n            if (i < 7)\n                System.out.println();\n        }\n    }\n\n    static int checkPlace(int turn, int i, int j, int mode) {\n        int score = 0;\n        int opturn = turn + 1;\n        if (opturn == 2) opturn = 0;\n\n        if (map[i][j] != '.') return 0;\n\n        for (int n = i - 1; n <= i + 1; n++) {\n            for (int m = j - 1; m <= j + 1; m++) {\n                if (n < 0 || 7 < n || m < 0 || 7 < m) continue;\n                if (map[n][m] == player[opturn]) {\n                    score += scoreCount(i, j, n - i, m - j, turn, mode);\n                }\n            }\n        }\n        return score;\n    }\n\n    static int scoreCount(int i, int j, int imove, int jmove, int turn, int mode) {\n        int score = 0;\n        int opturn = turn + 1;\n        if (opturn == 2) opturn = 0;\n        int n = i;\n        int m = j;\n\n        while (true) {\n            i += imove;\n            j += jmove;\n            if (i < 0 || 7 < i || j < 0 || 7 < j) return 0;\n            if (map[i][j] == player[opturn]) {\n                score++;\n            } else if (map[i][j] == player[turn]) {\n                if (mode == 1) {\n                    while (i != n || j != m) {\n                        i -= imove;\n                        j -= jmove;\n                        map[i][j] = player[turn];\n                    }\n                }\n                return score;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    static int playTurn(int turn) {\n        int maxScore = 0;\n        int n = 0, m = 0;\n\n        if (turn == 0) {\n            for (int i = 0; i < 8; i++) {\n                for (int j = 0; j < 8; j++) {\n                    int score = checkPlace(turn, i, j, 0);\n                    if (maxScore < score) {\n                        maxScore = score;\n                        n = i;\n                        m = j;\n                    }\n                }\n            }\n        } else {\n            for (int i = 7; i > -1; i--) {\n                for (int j = 7; j > -1; j--) {\n                    int score = checkPlace(turn, i, j, 0);\n                    if (maxScore < score) {\n                        maxScore = score;\n                        n = i;\n                        m = j;\n                    }\n                }\n            }\n        }\n\n        if (maxScore != 0) {\n            changeMap(n, m, turn);\n            map[n][m] = player[turn];\n        }\n        return maxScore;\n    }\n\n    static void changeMap(int i, int j, int turn) {\n        int score = checkPlace(turn, i, j, 1);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar map[][] = new char[8][];\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\n\t\tboolean t = true;\n\n\t\tint di[] = { -1, 1, 0, 0, 1, -1, -1, 1 };\n\t\tint dj[] = { 0, 0, 1, -1, 1, 1, -1, -1 };\n\t\tfor (;;) {\n\t\t\tint bmin = 0;\n\t\t\t{\n\t\t\t\tint minb = 0;\n\t\t\t\tint cj = 0;\n\t\t\t\tint ci = 0;\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n\n\t\t\t\t\t\tif (map[i][j] != '.') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int z = 0; z < 8; z++) {\n\t\t\t\t\t\t\tint ni = i + di[z];\n\t\t\t\t\t\t\tint nj = j + dj[z];\n\n\t\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {\n\t\t\t\t\t\t\t\tint b2 = 0;\n\t\t\t\t\t\t\t\tif (map[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\t\tni += di[z];\n\t\t\t\t\t\t\t\t\t\tnj += dj[z];\n\n\t\t\t\t\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0\n\t\t\t\t\t\t\t\t\t\t\t\t&& nj < 8) {\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (map[ni][nj] == '.') {\n\t\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tb += b2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b > minb) {\n\t\t\t\t\t\t\tminb = b;\n\t\t\t\t\t\t\tcj = j;\n\t\t\t\t\t\t\tci = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (minb > 0) {\n\t\t\t\t\tfor (int z = 0; z < 8; z++) {\n\t\t\t\t\t\tint ni = ci + di[z];\n\t\t\t\t\t\tint nj = cj + dj[z];\n\n\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {\n\t\t\t\t\t\t\tint b2 = 0;\n\t\t\t\t\t\t\tif (map[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\tni += di[z];\n\t\t\t\t\t\t\t\t\tnj += dj[z];\n\t\t\t\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (map[ni][nj] == '.') {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (b2 > 0) {\n\t\t\t\t\t\t\t\tni = ci + di[z];\n\t\t\t\t\t\t\t\tnj = cj + dj[z];\n\t\t\t\t\t\t\t\tmap[ci][cj] = 'o';\n\t\t\t\t\t\t\t\tfor (int i2 = 0; i2 < b2; i2++) {\n\t\t\t\t\t\t\t\t\t// System.out.println(ni+\" \"+nj);\n\t\t\t\t\t\t\t\t\tmap[ni][nj] = 'o';\n\t\t\t\t\t\t\t\t\tni += di[z];\n\t\t\t\t\t\t\t\t\tnj += dj[z];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbmin = minb;\n\t\t\t}\n\t\t\tint minw = 0;\n\t\t\t{\n\t\t\t\tint minb = 0;\n\t\t\t\tint cj = 0;\n\t\t\t\tint ci = 0;\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n\n\t\t\t\t\t\tif (map[i][j] != '.') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int z = 0; z < 8; z++) {\n\t\t\t\t\t\t\tint ni = i + di[z];\n\t\t\t\t\t\t\tint nj = j + dj[z];\n\n\t\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {\n\t\t\t\t\t\t\t\tint b2 = 0;\n\t\t\t\t\t\t\t\tif (map[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\t\tni += di[z];\n\t\t\t\t\t\t\t\t\t\tnj += dj[z];\n\n\t\t\t\t\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0\n\t\t\t\t\t\t\t\t\t\t\t\t&& nj < 8) {\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (map[ni][nj] == '.') {\n\t\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tb += b2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b >= minb) {\n\t\t\t\t\t\t\tminb = b;\n\t\t\t\t\t\t\tcj = j;\n\t\t\t\t\t\t\tci = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (minb > 0) {\n\t\t\t\t\tfor (int z = 0; z < 8; z++) {\n\t\t\t\t\t\tint ni = ci + di[z];\n\t\t\t\t\t\tint nj = cj + dj[z];\n\n\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {\n\t\t\t\t\t\t\tint b2 = 0;\n\t\t\t\t\t\t\tif (map[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\tni += di[z];\n\t\t\t\t\t\t\t\t\tnj += dj[z];\n\t\t\t\t\t\t\t\t\tif (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'o') {\n\t\t\t\t\t\t\t\t\t\tb2++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (map[ni][nj] == 'x') {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (map[ni][nj] == '.') {\n\t\t\t\t\t\t\t\t\t\tb2 = 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (b2 > 0) {\n\t\t\t\t\t\t\t\tni = ci + di[z];\n\t\t\t\t\t\t\t\tnj = cj + dj[z];\n\t\t\t\t\t\t\t\tmap[ci][cj] = 'x';\n\t\t\t\t\t\t\t\tfor (int i2 = 0; i2 < b2; i2++) {\n\t\t\t\t\t\t\t\t\t// System.out.println(ni+\" \"+nj);\n\t\t\t\t\t\t\t\t\tmap[ni][nj] = 'x';\n\t\t\t\t\t\t\t\t\tni += di[z];\n\t\t\t\t\t\t\t\t\tnj += dj[z];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tminw = minb;\n\t\t\t}\n\t\t\tif (bmin + minw == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint [] vx = {0,1,0,-1,1,1,-1,-1};\n\tint [] vy = {1,0,-1,0,1,-1,-1,1};\n\tchar [][] data;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = 8;\n\t\t\tdata = new char[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tboolean update = true;\n\t\t\twhile(update){\n\t\t\t\tupdate = false;\n\t\t\t\tint max = 0, x = 0, y = 0;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tif(data[i][j] != '.')continue;\n\t\t\t\t\t\tint temp = find(i,j, 'o');\n\t\t\t\t\t\tif(max < temp){\n\t\t\t\t\t\t\tmax = temp;\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max > 0){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdata[y][x] = 'o';\n\t\t\t\t\tpaint(x,y, 'o');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint max2 = 0, x2 = 0, y2 = 0;\n\t\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\t\tfor(int j = n-1; j >= 0; j--){\n\t\t\t\t\t\tif(data[i][j] != '.')continue;\n\t\t\t\t\t\tint temp = find(i, j, 'x');\n\t\t\t\t\t\tif(max2 < temp){\n\t\t\t\t\t\t\tmax2 = temp;\n\t\t\t\t\t\t\tx2 = j;\n\t\t\t\t\t\t\ty2 = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max2 > 0){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tdata[y2][x2] = 'x';\n\t\t\t\t\tpaint(x2,y2,'x');\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisp();\n\t\t}\n\t}\n\n\tprivate void disp() {\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tSystem.out.print(data[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate void paint(int x, int y, char c) {\n\t\tfor(int i = 0; i < vx.length; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tboolean flg = false;\n\t\t\twhile(true){\n\t\t\t\tif(! isOK(xx,yy))break;\n\t\t\t\tif(data[yy][xx] == c){\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(data[yy][xx] == '.'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\txx += vx[i];\n\t\t\t\tyy += vy[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(flg){\n\t\t\t\txx = x + vx[i];\n\t\t\t\tyy = y + vy[i];\n\t\t\t\twhile(true){\n\t\t\t\t\tif(! isOK(xx,yy))break;\n\t\t\t\t\tif(data[yy][xx] == c){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[yy][xx] == '.'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdata[yy][xx] = c;\n\t\t\t\t\txx += vx[i];\n\t\t\t\t\tyy += vy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int find(int y, int x, char c) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < vx.length; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tint now = 0;\n\t\t\twhile(true){\n\t\t\t\tif(! isOK(xx,yy))break;\n\t\t\t\tif(data[yy][xx] == c){\n\t\t\t\t\tcount += now;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(data[yy][xx] == '.'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnow++;\n\t\t\t\txx = xx + vx[i];\n\t\t\t\tyy = yy + vy[i];\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < 8 && 0 <= yy && yy < 8)return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[][]field;\n\tstatic char[]a={'o','x'};\n\tstatic int[]v1={-1,0,1,-1,1,-1,0,1};\n\tstatic int[]v2={-1,-1,-1,0,0,1,1,1};\n\tstatic int  turn;\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tfield=new char[8][];\n\t\tturn=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfield[i]=sc.next().toCharArray();\n\t\t}\n\t\tint pass=0;\n\t\tfor(;;){\n\t\t\t\n\t\t\tint x=0,y=0,max=0;\n\t\t\tif(turn==0){\n\t\t\t\tmax=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmax=1;\n\t\t\t}\n\t\t\tboolean isPass=true;;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tint[] put =putCount(i,j,a[turn]);\n\n\t\t\t\t\tif(put==null)continue;\n\t\t\t\t\tif(turn==0){\n\t\t\t\t\t\tif(max<put[0]){\n\t\t\t\t\t\t\tmax=put[0];\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t\tisPass=false;\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(max<=put[0]){\n\t\t\t\t\t\t\tmax=put[0];\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t\tisPass=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isPass){\n\t\t\t\tput(x,y,a[turn]);\n\t\t\t\tpass=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpass++;\n\t\t\t\tif(pass==2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tturn=1-turn;\n\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(field[i][j]!='.')cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==64)break;\n//\t\t\tSystem.out.println(pass);\n//\t\t\tSystem.out.println(isPass);\n//\t\t\toutput();\n\t\t}\n\t\t\n\t\toutput();\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\t\t\n\t}\n\tstatic void put(int x,int y,char c){\n\t\tfield[x][y]=(char)c;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(xx<0||yy<0||xx>=8||yy>=8)continue;\n\t\t\tif(field[xx][yy]==a[1-turn]){\n\t\t\t\tint u=uraCount(xx,yy,c,i);\n\t\t\t\tif(u!=-1){\n\t\t\t\t\tura(xx,yy,c,i,u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic void ura(int x,int y,int c,int dir,int count){\n\t\tfor(int i=0;i<count;i++){\n\t\t\tfield[x][y]=(char)c;\n\t\t\tx+=v1[dir];\n\t\t\ty+=v2[dir];\n\t\t}\n\t}\n\tstatic int[] putCount(int x,int y,char c){\n\t\t\n\t\t// テ・ツ?凝ヲツ閉ーテ」ツ??ヲツ鳴ケテ・ツ青?\n\t\tint[] re={0,0};\n\t\tif(field[x][y]!='.')return null;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(xx<0||yy<0||xx>=8||yy>=8)continue;\n\t\t\tif(field[xx][yy]==a[1-turn]){\n\t\t\t\tint u=uraCount(xx,yy,c,i);\n\t\t\t\tif(u!=-1){\n//\t\t\t\t\tSystem.out.println(u);\n\t\t\t\t\tre[0]+=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn re;\n\t}\n\tstatic int uraCount(int x,int y,int c,int dir){\n\t\tint re=1;\n\t\tfor(;;){\n\t\t\tx+=v1[dir];\n\t\t\ty+=v2[dir];\n\t\t\tif(x<0||y<0||x>=8||y>=8)break;\n\t\t\tif(field[x][y]==c){\n\t\t\t\treturn re;\n\t\t\t}\n\t\t\telse if(field[x][y]==a[1-turn]){\n\t\t\t\tre++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dessert Witch\npublic class Main{\n\n\tchar[][] s;\n\tint[][] d = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\t\n\tint[] put(int i, int j, char c){\n\t\tint[] r = new int[8];\n\t\tchar foe = c=='o'?'x':'o';\n\t\tfor(int k=0;k<8;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1], len = 0;\n\t\t\twhile(0<=ni&&ni<8&&0<=nj&&nj<8){\n\t\t\t\tif(s[ni][nj]==foe){\n\t\t\t\t\tlen++; ni+=d[k][0]; nj+=d[k][1];\n\t\t\t\t}\n\t\t\t\telse if(s[ni][nj]==c){\n\t\t\t\t\tr[k] = len; break;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = new char[8][];\n\t\tfor(int i=0;i<8;i++)s[i]=sc.next().toCharArray();\n\t\tfor(;;){\n\t\t\tboolean f1 = false, f2 = false;\n\t\t\tint pi = -1, pj = -1, max = 0;\n\t\t\tfor(int i=0;i<8;i++)for(int j=0;j<8;j++){\n\t\t\t\tif(s[i][j]!='.')continue;\n\t\t\t\tint[] r = put(i, j, 'o');\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int x:r)c+=x;\n\t\t\t\tif(max<c){\n\t\t\t\t\tmax = c; pi = i; pj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max==0)f1 = true;\n\t\t\telse{\n\t\t\t\ts[pi][pj] = 'o';\n\t\t\t\tint[] r = put(pi, pj, 'o');\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tif(r[k]==0)continue;\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\twhile(0<=ni&&ni<8&&0<=nj&&nj<8&&s[ni][nj]=='x'){\n\t\t\t\t\t\ts[ni][nj] = 'o'; ni+=d[k][0]; nj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tfor(int i=7;i>=0;i--)for(int j=7;j>=0;j--){\n\t\t\t\tif(s[i][j]!='.')continue;\n\t\t\t\tint[] r = put(i, j, 'x');\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int x:r)c+=x;\n\t\t\t\tif(max<c){\n\t\t\t\t\tmax = c; pi = i; pj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max==0)f2 = true;\n\t\t\telse{\n\t\t\t\ts[pi][pj] = 'x';\n\t\t\t\tint[] r = put(pi, pj, 'x');\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\tif(r[k]==0)continue;\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\twhile(0<=ni&&ni<8&&0<=nj&&nj<8&&s[ni][nj]=='o'){\n\t\t\t\t\t\ts[ni][nj] = 'x'; ni+=d[k][0]; nj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f1&&f2)break;\n\t\t}\n\t\tfor(int i=0;i<8;i++)System.out.println(new String(s[i]));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class DessertWitch {\n\tScanner in = new Scanner(System.in);\n\tchar[][] map = new char[10][10];\n\tboolean flag = true;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\t\n\tint put(char color, int y, int x) {\n\t\tint ret = 0;\n\t\tif (map[y][x] != '.') return ret;\n\t\tfor (int i = 0; i < dirx.length; i++) {\n\t\t\tint stoneNum = checkDir(color, x, y, i);\n\t\t\tret += stoneNum;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint checkDir(char color, int x, int y, int dir) {\n\t\tchar c = map[y+diry[dir]][x+dirx[dir]];\n\t\tif (c == 0 || c == '.' || c == color) return 0;\n\t\telse {\n\t\t\tfor (int j = 2; j < dirx.length; j++) {\n\t\t\t\tc = map[y+diry[dir]*j][x+dirx[dir]*j];\n\t\t\t\tif (c == 0 || c == '.') return 0;\n\t\t\t\telse if (c == color) return j - 1;\n\t\t\t\telse continue;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid flip(char color, int x, int y) {\n\t\tfor (int i = 0; i < dirx.length; i++) {\n\t\t\tint stoneNum = checkDir(color, x, y, i);\n\t\t\tfor (int k = stoneNum; k >= 0; k--) {\n\t\t\t\tmap[y+diry[i]*k][x+dirx[i]*k] = color;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tString s = in.next();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tmap[i][j+1] = s.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max;\n\t\tint x, y;\n\t\twhile (flag) {\n\t\t\tflag = false;\n\t\t\tmax = 0;\n\t\t\tx = -1; y = -1;\n\t\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\t\tif (max < put('o', i, j)) {\n\t\t\t\t\t\ty = i; x = j;\n\t\t\t\t\t\tmax = put('o', i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max != 0) {\n\t\t\t\tflip('o', x, y);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tx = -1; y = -1;\n\t\t\tfor (int i = 8; i > 0; i--) {\n\t\t\t\tfor (int j = 8; j > 0; j--) {\n\t\t\t\t\tif (max < put('x', i, j)) {\n\t\t\t\t\t\ty = i; x = j;\n\t\t\t\t\t\tmax = put('x', i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max != 0) {\n\t\t\t\tflip('x', x, y);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew DessertWitch().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                System.out.println(\"!\");\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        int y1 = y, x1 = x;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n            } else if (map[y][x] == a) {\n                break;\n            } else {\n                return;\n            }\n        }\n        for (int cnt=0;cnt<8;cnt++, y-=dy,x-=dx) {\n            if (y == y1 && x == x1) {\n                return;\n            }\n            map[y][x] = a;\n        }\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n=8;\n\t\tchar[][] map=ir.nextCharMap(n,n);\n\t\tint p=-1;\n\t\tfor(int m=0;;m^=1){\n\t\t\tint ma=0,x=-1,y=-1;\n\t\t\tif(m==0){\n\t\t\t\tfor(int i=n-1;i>=0;i--){\n\t\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ma==0&&p==0)\n\t\t\t\tbreak;\n\t\t\tif(ma!=0)\n\t\t\t\tget(x,y,m,map,true);\n\t\t\tp=ma;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print(Character.toString(map[i][j]));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tstatic int get(int x,int y,int m,char[][] map,boolean reverse){\n\t\tif(reverse)\n\t\t\tmap[x][y]=conv(m);\n\t\tint ret=0;\n\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\t\tif(dx==0&&dy==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint nx=x+dx*i;\n\t\t\t\t\tint ny=y+dy*i;\n\t\t\t\t\tif(!(nx>=0&&ny>=0&&nx<map.length&&ny<map.length))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]=='.')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]==conv(m)){\n\t\t\t\t\t\tret+=i-1;\n\t\t\t\t\t\tif(reverse){\n\t\t\t\t\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\t\t\t\t\tmap[x+dx*j][y+dy*j]=conv(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic char conv(int m){\n\t\treturn m==0?'o':'x';\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tsolve();\n\t}\n\tpublic static void solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] s = new String[8];\n\t\tint[][] map = new int[8][8];\n\t\tboolean turn = true;\n\t\tboolean judge = true;\n\t\tint nextx = -1;\n\t\tint nexty = -1;\n\t\tint nowcount = 0;\n\t\tint[] dx = {1,1,0,-1,-1,-1,0,1};\n\t\tint[] dy = {0,-1,-1,-1,0,1,1,1};\n\t\tfor(int i=0;i<8;i++){\n\t\t\tArrays.fill(map[i], -1);\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\ts[i] = sc.next();\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i].charAt(j)=='o'){\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(s[i].charAt(j)=='x'){\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean flag = false;\n\t\tboolean flags = false;\n\t\twhile(judge){\n\t\t\tString xxx = sc.next();\n\t\t\tnowcount = 1;\n\t\t\tnextx = -1;\n\t\t\tnexty = -1;\n\t\t\tif(turn){\n\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tif(i+dx[k]<0 || i+dx[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j+dy[k]<0 || j+dy[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i+dx[k]][j+dy[k]]==0){\n\t\t\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\t\t\tif(i+l*dx[k]<0 || i+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j+l*dy[k]<0 || j+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==1){\n\t\t\t\t\t\t\t\t\t\t\tcount += l - 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nowcount<=count){\n\t\t\t\t\t\t\t\tnextx = i;\n\t\t\t\t\t\t\t\tnexty = j;\n\t\t\t\t\t\t\t\tnowcount = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextx != -1){\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tif(nextx+dx[k]<0 || nextx+dx[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nexty+dy[k]<0 || nexty+dy[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[nextx+dx[k]][nexty+dy[k]]==0){\n\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\tif(nextx+l*dx[k]<0 || nextx+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nexty+l*dy[k]<0 || nexty+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==1){\n\t\t\t\t\t\t\t\t\twhile(l>0){\n\t\t\t\t\t\t\t\t\t\tl--;\n\t\t\t\t\t\t\t\t\t\tmap[nextx+l*dx[k]][nexty+l*dy[k]] = 1;\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnowcount = 0;\n\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tif(i+dx[k]<0 || i+dx[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j+dy[k]<0 || j+dy[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i+dx[k]][j+dy[k]]==1){\n\t\t\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\t\t\tif(i+l*dx[k]<0 || i+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j+l*dy[k]<0 || j+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==0){\n\t\t\t\t\t\t\t\t\t\t\tcount += l;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nowcount<count){\n\t\t\t\t\t\t\t\tnextx = i;\n\t\t\t\t\t\t\t\tnexty = j;\n\t\t\t\t\t\t\t\tnowcount = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextx != -1){\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tif(nextx+dx[k]<0 || nextx+dx[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nexty+dy[k]<0 || nexty+dy[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[nextx+dx[k]][nexty+dy[k]]==1){\n\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\tif(nextx+l*dx[k]<0 || nextx+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nexty+l*dy[k]<0 || nexty+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==0){\n\t\t\t\t\t\t\t\t\twhile(l>0){\n\t\t\t\t\t\t\t\t\t\tl--;\n\t\t\t\t\t\t\t\t\t\tmap[nextx+l*dx[k]][nexty+l*dy[k]] = 0;\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflags = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag && flags){\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t\tint counter = 0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]!=-1){\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\t/*if(map[i][j]==-1){\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tSystem.out.print(\"o\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tSystem.out.print(\"x\");\n\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t/*try{\n\t\t\t\tThread.sleep(1000);\n\t\t\t}catch(InterruptedException e){}*/\n\t\t\t//System.out.println(nextx+\" \"+nexty+\" \"+counter);\n\t\t\tif(counter>=64){\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t\tif(turn){\n\t\t\t\tflags = false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tturn = !turn;\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tSystem.out.print(\"o\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tSystem.out.print(\"x\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                stopCnt = 0;\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        int y1 = y, x1 = x;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n            } else if (map[y][x] == a) {\n                break;\n            } else {\n                return;\n            }\n        }\n        for (int cnt=0;cnt<8;cnt++, y-=dy,x-=dx) {\n            if (y == y1 && x == x1) {\n                return;\n            }\n            map[y][x] = a;\n        }\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        int y1 = y, x1 = x;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n            } else if (map[y][x] == a) {\n                break;\n            } else {\n                return;\n            }\n        }\n        for (int cnt=0;cnt<8;cnt++, y-=dy,x-=dx) {\n            if (y == y1 && x == x1) {\n                return;\n            }\n            map[y][x] = a;\n        }\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[8][8];\n\t\tfor(int i=0;i<8;i++){\n\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[j]=='x') map[i][j] = 1;\n\t\t\t\telse if(s[j]=='.') map[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] p = new int[]{1,1,1,0,-1,-1,-1,0};\n\t\tint[] q = new int[]{1,0,-1,-1,-1,0,1,1};\n\t\tint cnt, max, mx, my;\n\t\tboolean flag;\n\t\twhile(true){\n\t\t\tflag = false;\n\t\t\tfor(int z=0;z<2;z++){\n\t\t\t\tmx = -1;\n\t\t\t\tmy = -1;\n\t\t\t\tmax = 0;\n\t\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\t\tfor(int x=0;x<8;x++){\n\t\t\t\t\t\tif(map[y][x]==2){\n\t\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\t\t\t\tfor(int j=1;;j++){\n\t\t\t\t\t\t\t\t\tif(0<=x+j*p[i] && x+j*p[i]<8 && 0<=y+j*q[i] && y+j*q[i]<8){\n\t\t\t\t\t\t\t\t\t\tif(map[y+j*q[i]][x+j*p[i]]==z){\n\t\t\t\t\t\t\t\t\t\t\tcnt += (j-1);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(map[y+j*q[i]][x+j*p[i]]==2) break;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(cnt>0){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tif(cnt>max-z){\n\t\t\t\t\t\t\t\t\tmax = cnt;\n\t\t\t\t\t\t\t\t\tmx = x;\n\t\t\t\t\t\t\t\t\tmy = y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(mx!=-1){\n\t\t\t\t\tmap[my][mx] = z;\n\t\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\t\tfor(int j=1;;j++){\n\t\t\t\t\t\t\tif(0<=mx+j*p[i] && mx+j*p[i]<8 && 0<=my+j*q[i] && my+j*q[i]<8){\n\t\t\t\t\t\t\t\tif(map[my+j*q[i]][mx+j*p[i]]==2) break;\n\t\t\t\t\t\t\t\telse if(map[my+j*q[i]][mx+j*p[i]]==z){\n\t\t\t\t\t\t\t\t\tfor(int k=1;k<j;k++) map[my+k*q[i]][mx+k*p[i]] = z;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) break;\n\t\t}\n\t\t\n\t\tfor(int u=0;u<8;u++){\n\t\t\tfor(int v=0;v<8;v++){\n\t\t\t\tif(map[u][v]==0) System.out.print(\"o\");\n\t\t\t\telse if(map[u][v]==1) System.out.print(\"x\");\n\t\t\t\telse System.out.print(\".\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint num(int[][] s, int t, int x, int y) {\n\t\tif (s[x][y] != 0) return 0;\n\t\tint[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};\n\t\tint[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint c = 1, count = 0;\n\t\t\twhile (x+dx[i]*c >= 0 && x+dx[i]*c < 8 && y+dy[i]*c >= 0 && y+dy[i]*c < 8 && s[x+dx[i]*c][y+dy[i]*c] == -t) {\n\t\t\t\tcount++;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif (x+dx[i]*c >= 0 && x+dx[i]*c < 8 && y+dy[i]*c >= 0 && y+dy[i]*c < 8 && s[x+dx[i]*c][y+dy[i]*c] == t)\n\t\t\t\tres += count;\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tvoid renew(int[][] s, int t, int x, int y) {\n\t\tint[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};\n\t\tint[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint c = 1, count = 0;\n\t\t\twhile (x+dx[i]*c >= 0 && x+dx[i]*c < 8 && y+dy[i]*c >= 0 && y+dy[i]*c < 8 && s[x+dx[i]*c][y+dy[i]*c] == -t) {\n\t\t\t\tcount++;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif (x+dx[i]*c >= 0 && x+dx[i]*c < 8 && y+dy[i]*c >= 0 && y+dy[i]*c < 8 && s[x+dx[i]*c][y+dy[i]*c] == t) {\n\t\t\t\tfor (int j = 0; j <= count; j++) {\n\t\t\t\t\ts[x+dx[i]*j][y+dy[i]*j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean calc1(int[][] s) {\n\t\tint x = -1, y = -1;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tint n = num(s, 1, i, j);\n\t\t\t\tif (count < n) {\n\t\t\t\t\tcount = n;\n\t\t\t\t\tx = i; y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\trenew(s, 1, x, y);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean calc2(int[][] s) {\n\t\tint x = -1, y = -1;\n\t\tint count = 0;\n\t\tfor (int i = 7; i >= 0; i--) {\n\t\t\tfor (int j = 7; j >= 0; j--) {\n\t\t\t\tint n = num(s, -1, i, j);\n\t\t\t\tif (count < n) {\n\t\t\t\t\tcount = n;\n\t\t\t\t\tx = i; y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\trenew(s, -1, x, y);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run() {\n\t\tint[][] s = new int[8][8];\n\t\tString st;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tst = sc.nextLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (st.charAt(j) == 'o')\n\t\t\t\t\ts[i][j] = 1;\n\t\t\t\telse if (st.charAt(j) == 'x')\n\t\t\t\t\ts[i][j] = -1;\n\t\t\t\telse\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean mami = true, witch = true;\n\t\twhile (mami || witch) {\n\t\t\tmami = calc1(s);\n\t\t\twitch = calc2(s);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (s[i][j] == 1)\n\t\t\t\t\tout.print('o');\n\t\t\t\telse if (s[i][j] == -1)\n\t\t\t\t\tout.print('x');\n\t\t\t\telse\n\t\t\t\t\tout.print('.');\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n=8;\n\t\tchar[][] map=ir.nextCharMap(n,n);\n\t\tint p=-1;\n\t\tfor(int m=0;;m^=1){\n\t\t\tint ma=0,x=-1,y=-1;\n\t\t\tif(m==0){\n\t\t\t\tfor(int i=n-1;i>=0;i--){\n\t\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ma==0&&p==0)\n\t\t\t\tbreak;\n\t\t\tif(ma!=0)\n\t\t\t\tget(x,y,m,map,true);\n\t\t\tp=ma;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tout.print(Character.toString(map[i][j]));\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print(Character.toString(map[i][j]));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tstatic int get(int x,int y,int m,char[][] map,boolean reverse){\n\t\tif(reverse)\n\t\t\tmap[x][y]=conv(m);\n\t\tint ret=0;\n\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\t\tif(dx==0&&dy==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint nx=x+dx*i;\n\t\t\t\t\tint ny=y+dy*i;\n\t\t\t\t\tif(!(nx>=0&&ny>=0&&nx<map.length&&ny<map.length))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]=='.')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]==conv(m)){\n\t\t\t\t\t\tret+=i-1;\n\t\t\t\t\t\tif(reverse){\n\t\t\t\t\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\t\t\t\t\tmap[x+dx*j][y+dy*j]=conv(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic char conv(int m){\n\t\treturn m==0?'o':'x';\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic char[][] table;\n\tstatic int[] dx = { 0, 1, 1, 1, 0,-1,-1,-1};\n\tstatic int[] dy = { 1, 1, 0,-1,-1,-1, 0, 1};\n\n\tstatic int cnt(int turn, int x, int y) {\n\t\tint cnt = 0;\n\t\tfor (int d=0; d<8; d++) {\n\t\t\tint tmp = 0;\n\t\t\tint nx = x, ny = y;\n\t\t\twhile (true) {\n\t\t\t\tnx = nx + dx[d];\n\t\t\t\tny = ny + dy[d];\n\t\t\t\tif (nx < 0 || ny < 0 || 8 <= nx || 8 <= ny) break;\n\t\t\t\tif ((turn == 0 && table[ny][nx] == 'x') || (turn == 1 && table[ny][nx] == 'o')) tmp++;\n\t\t\t\tif ((turn != 0 && table[ny][nx] == 'x') || (turn != 1 && table[ny][nx] == 'o')) {\n\t\t\t\t\tcnt += tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (table[ny][nx] == '.') break;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tstatic boolean _draw(int turn, int d, int x, int y) {\n\t\tif (x < 0 || y < 0 || 8 <= x || 8 <= y) return false;\n\t\tif (table[y][x] == '.') return false;\n\t\tif (turn == 0 && table[y][x] == 'o') return true;\n\t\tif (turn == 1 && table[y][x] == 'x') return true;\n\t\tboolean f = _draw(turn, d, x+dx[d], y+dy[d]);\n\t\tif (f) {\n\t\t\ttable[y][x] = turn == 0 ? 'o' : 'x';\n\t\t}\n\t\treturn f;\n\t}\n\n\tstatic void draw(int turn, int x, int y) {\n\t\ttable[y][x] = turn == 0 ? 'o' : 'x';\n\t\tfor (int d=0; d<8; d++) {\n\t\t\t_draw(turn, d, x+dx[d], y+dy[d]);\n\t\t}\n\t}\n\n\tstatic boolean turnA() {\n\t\tint max = -1, mi = -1, mj = -1;\n\n\t\tfor (int i=0; i<8; i++) {\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tif (table[i][j] != '.') continue;\n\t\t\t\tint cnt = cnt(0, j, i);\n\t\t\t\tif (max < cnt) {\n\t\t\t\t\tmax = cnt;\n\t\t\t\t\tmi = i;\n\t\t\t\t\tmj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (max > 0) draw(0, mj, mi);\n\n\t\treturn max != -1;\n\t}\n\n\tstatic boolean turnB() {\n\t\tint max = -1, mi = -1, mj = -1;\n\n\t\tfor (int i=7; i>=0; i--) {\n\t\t\tfor (int j=7; j>=0; j--) {\n\t\t\t\tif (table[i][j] != '.') continue;\n\t\t\t\tint cnt = cnt(1, j, i);\n\t\t\t\tif (max < cnt) {\n\t\t\t\t\tmax = cnt;\n\t\t\t\t\tmi = i;\n\t\t\t\t\tmj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (max > 0) draw(1, mj, mi);\n\n\t\treturn max != -1;\n\t}\n\n\tstatic void solve() {\n\t\ttable = new char[8][8];\n\t\tfor (int i=0; i<8; i++) {\n\t\t\ttable[i] = in.next().toCharArray();\n\t\t}\n\n\t\tint turn = 0;\n\t\tboolean f = true;\n\t\tint p = 0;\n\t\twhile (f && p < 100) {\n\t\t\tif (turn == 0) f = turnA();\n\t\t\telse f = turnB();\n\t\t\tturn = (turn + 1)%2;\n\t\t\tp++;\n\t\t}\n\n\t\tfor (int i=0; i<8; i++) {\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tout.print(table[i][j]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n    public int getCount(int x,int y,char my,char enemy){\n    \tint D=0;\n    \tL:for(int i=0;i<8;i++){\n\t\t\tint ds=0;\n\t\t\tint px=x,py=y;\n\t\t\tpx+=d[i][0];\n\t\t\tpy+=d[i][1];\n\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\tcontinue L;\n\n\t\t\twhile(map[py][px]==enemy){\n\t\t\t\tds++;\n\t\t\t\tpx+=d[i][0];\n\t\t\t\tpy+=d[i][1];\n\t\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\t\tcontinue L;\n\t\t\t}\n\t\t\tif(map[py][px]==my)\n\t\t\t\tD+=ds;\n\t\t}\n    \treturn D;\n    }\n\n    public void setCookie(int x,int y,char my ,char enemy){\n    \tmap[y][x]=my;\n    \tD:for(int i=0;i<8;i++){\n\t\t\tint px=x,py=y;\n\t\t\tpx+=d[i][0];\n\t\t\tpy+=d[i][1];\n\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\tcontinue D;\n\t\t\twhile(map[py][px]==enemy){\n\t\t\t\tpx+=d[i][0];\n\t\t\t\tpy+=d[i][1];\n\t\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\t\tcontinue D;\n\t\t\t}\n\t\t\tif(map[py][px]==my){\n\t\t\t\tpx-=d[i][0];\n\t\t\t\tpy-=d[i][1];\n\t\t\t\twhile(!(px==x && py==y)){\n\t\t\t\t\tmap[py][px]=my;\n\t\t\t\t\tpx-=d[i][0];\n\t\t\t\t\tpy-=d[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    char[][] map;\n\tint[][] d;\n    public void run() {\n    \tmap=new char[8][8];\n    \tfor(int i=0;i<8;i++){\n    \t\tmap[i]=sc.next().toCharArray();\n    \t}\n\n    \tboolean mami=true;\n    \td=new int[][]{\n    \t\t\t{1,0},{1,1},\n    \t\t\t{0,1},{-1,1},\n    \t\t\t{-1,0},{-1,-1},\n    \t\t\t{0,-1},{1,-1}\n    \t};\n\n    \tboolean prevpass=false;\n\n    \twhile(true){\n    \t\tint max=0,resx=-1,resy=-1;\n    \t\tfor(int y=0;y<8;y++)for(int x=0;x<8;x++){\n    \t\t\tif(map[y][x]!='.')continue;\n    \t\t\tint D=getCount(x,y,mami?'o':'x',mami?'x':'o');\n    \t\t\tif(mami){\n\t    \t\t\tif(max<D){\n\t    \t\t\t\tmax=D;\n\t    \t\t\t\tresx=x;\n\t    \t\t\t\tresy=y;\n\t    \t\t\t}\n    \t\t\t}else{\n    \t\t\t\tif(max<=D){\n\t    \t\t\t\tmax=D;\n\t    \t\t\t\tresx=x;\n\t    \t\t\t\tresy=y;\n\t    \t\t\t}\n    \t\t\t}\n    \t\t}\n\n    \t\tif(max>0)\n    \t\t\tsetCookie(resx,resy,mami?'o':'x',mami?'x':'o');\n    \t\telse {\n    \t\t\tif(!prevpass)prevpass=true;\n    \t\t\telse{\n    \t\t\t\tfor(int y=0;y<8;y++){\n        \t\t\t\tfor(int x=0;x<8;x++)\n        \t\t\t\t\tpr(map[y][x]);\n\n        \t\t\t\tln();\n    \t\t\t\t}\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t}\n    \t\tmami=!mami;\n    \t}\n   }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public int[] nextIntArray(int n){\n        int[] res=new int[n];\n        for(int i=0;i<n;i++){\n            res[i]=sc.nextInt();\n        }\n        return res;\n    }\n    public static void pr(Object o) {\n        out.print(o);\n    }\n    public static void ln(Object o) {\n        out.println(o);\n    }\n    public static void ln() {\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                System.out.println(\"!\");\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        int y1 = y, x1 = x;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n            } else if (map[y][x] == a) {\n                break;\n            } else {\n                return;\n            }\n        }\n        for (int cnt=0;cnt<8;cnt++, y-=dy,x-=dx) {\n            if (y == y1 && x == x1) {\n                return;\n            }\n            map[y][x] = a;\n        }\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                System.out.println(\"!\");\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        int y1 = y, x1 = x;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n            } else if (map[y][x] == a) {\n                break;\n            } else {\n                return;\n            }\n        }\n        for (int cnt=0;cnt<8;cnt++, y-=dy,x-=dx) {\n            if (y == y1 && x == x1) {\n                return;\n            }\n            map[y][x] = a;\n        }\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tchar[][] map = new char[10][10];\n\tboolean flag = true;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\t\n\tint put(char color, int y, int x) {\n\t\tint ret = 0;\n\t\tif (map[y][x] != '.') return ret;\n\t\tfor (int i = 0; i < dirx.length; i++) {\n\t\t\tint stoneNum = checkDir(color, x, y, i);\n\t\t\tret += stoneNum;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint checkDir(char color, int x, int y, int dir) {\n\t\tchar c = map[y+diry[dir]][x+dirx[dir]];\n\t\tif (c == 0 || c == '.' || c == color) return 0;\n\t\telse {\n\t\t\tfor (int j = 2; j < dirx.length; j++) {\n\t\t\t\tc = map[y+diry[dir]*j][x+dirx[dir]*j];\n\t\t\t\tif (c == 0 || c == '.') return 0;\n\t\t\t\telse if (c == color) return j - 1;\n\t\t\t\telse continue;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid flip(char color, int x, int y) {\n\t\tfor (int i = 0; i < dirx.length; i++) {\n\t\t\tint stoneNum = checkDir(color, x, y, i);\n\t\t\tfor (int k = stoneNum; k >= 0; k--) {\n\t\t\t\tmap[y+diry[i]*k][x+dirx[i]*k] = color;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tString s = in.next();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tmap[i][j+1] = s.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max;\n\t\tint x, y;\n\t\twhile (flag) {\n\t\t\tflag = false;\n\t\t\tmax = 0;\n\t\t\tx = -1; y = -1;\n\t\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\t\tif (max < put('o', i, j)) {\n\t\t\t\t\t\ty = i; x = j;\n\t\t\t\t\t\tmax = put('o', i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max != 0) {\n\t\t\t\tflip('o', x, y);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tx = -1; y = -1;\n\t\t\tfor (int i = 8; i > 0; i--) {\n\t\t\t\tfor (int j = 8; j > 0; j--) {\n\t\t\t\t\tif (max < put('x', i, j)) {\n\t\t\t\t\t\ty = i; x = j;\n\t\t\t\t\t\tmax = put('x', i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max != 0) {\n\t\t\t\tflip('x', x, y);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\nimport javax.script.AbstractScriptEngine;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\t// public static Graph g;\n\tpublic static void main(String[] args) throws Exception{\n\t\t// ボードの入力を受ける\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tchar[][] table = new char[8][8];\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\ttable[i] = br.readLine().toCharArray();\n\t\t}\n\t\t\n\t\tBoard b = new Board(table);\n\t\tchar[] marks = {'o', 'x'};\n\t\tint turn = 0;\n\t\tboolean prev_finish_flag = false;\n\t\twhile(true){\n\t\t\tchar m = marks[turn];\n\t\t\tboolean curr_finish_flag = false;\n\t\t\tif(b.turn(m) == 0) curr_finish_flag = true;\n\t\t\tif(prev_finish_flag && curr_finish_flag) break;\n\t\t\t\n\t\t\tturn = (turn + 1) % 2;\n\t\t\tprev_finish_flag = curr_finish_flag;\n\t\t\t// b.print();\n\t\t\t// System.out.println();\n\t\t}\n\t\tb.print();\n\t}\n}\n\nclass Board{\n\tchar[][] table;\n\tBoard(char[][] table){\n\t\tthis.table = table;\n\t}\n\t\n\tvoid print(){\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tbuf.append(table[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println(buf.toString());\n\t\t}\n\t}\n\t\n\tint turn(char m){\n\t\tint max_i = -1, max_j = -1;\n\t\tint max_cnt = 0;\n\t\t\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tif(table[i][j] != '.') continue;\n\t\t\t\tint cnt = check(m, i, j, false);\n\t\t\t\tif(cnt > max_cnt && m == 'o' ||\n\t\t\t\t\t\tcnt >= max_cnt && m == 'x'){\n\t\t\t\t\tmax_cnt = cnt;\n\t\t\t\t\tmax_i = i;\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(\"\" + m + \" \" + max_cnt + \" \" + max_i + \" \" + max_j);\n\t\tif(max_cnt > 0){\n\t\t\tcheck(m, max_i, max_j, true);\n\t\t}\n\t\treturn max_cnt;\n\t}\n\t\n\tstatic int[] di = {-1,-1,-1,0,0,1,1,1};\n\tstatic int[] dj = {-1,0,1,-1,1,-1,0,1};\n\tint check(char m, int i, int j, boolean replace_flag){\n\t\tint sum = 0;\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tint cnt;\n\t\t\tfor(cnt = 1; cnt <= 8; cnt++){\n\t\t\t\ttry{\n\t\t\t\t\tchar table_mark = table[i + cnt*di[k]][j + cnt*dj[k]];\n\t\t\t\t\tif(table_mark == m){\n\t\t\t\t\t\t// 必要ならここで置き換える\n\t\t\t\t\t\tif(replace_flag){\n\t\t\t\t\t\t\ttable[i][j] = m;\n\t\t\t\t\t\t\tfor(int mult = cnt-1; mult > 0; mult--){\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\ttable[i + mult*di[k]][j + mult*dj[k]] = m;\n\t\t\t\t\t\t\t\t}catch(Exception e){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(table_mark == '.'){\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\t// マスを飛び出した場合\n\t\t\t\t\t// System.err.println(e);\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += (cnt - 1);\n\t\t}\n\t\treturn sum;\n\t}\n}\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil {\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n=8;\n\t\tchar[][] map=ir.nextCharMap(n,n);\n\t\tint p=-1;\n\t\tfor(int m=0;;m^=1){\n\t\t\tint ma=0,x=-1,y=-1;\n\t\t\tif(m==0){\n\t\t\t\tfor(int i=n-1;i>=0;i--){\n\t\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ma==0&&p==0)\n\t\t\t\tbreak;\n\t\t\tif(ma!=0)\n\t\t\t\tget(x,y,m,map,true);\n\t\t\tp=ma;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print(Character.toString(map[i][j]));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tstatic int get(int x,int y,int m,char[][] map,boolean reverse){\n\t\tif(reverse)\n\t\t\tmap[x][y]=conv(m);\n\t\tint ret=0;\n\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\t\tif(dx==0&&dy==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint nx=x+dx*i;\n\t\t\t\t\tint ny=y+dy*i;\n\t\t\t\t\tif(!(nx>=0&&ny>=0&&nx<map.length&&ny<map.length))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]=='.')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]==conv(m)){\n\t\t\t\t\t\tret+=i-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(reverse){\n\t\t\t\t\t\tmap[nx][ny]=conv(m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic char conv(int m){\n\t\treturn m==0?'o':'x';\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Dessert Witch\n */\npublic class Main {\n\n\tstatic final int[][] DIR = {\n\t\t\t{1, 1},     //0\n\t\t\t{1, 0},     //1\n\t\t\t{1, -1},    //2\n\t\t\t{0, 1},     //3\n\t\t\t{-1, -1},   //4\n\t\t\t{-1, 0},    //5\n\t\t\t{-1, 1},    //6\n\t\t\t{0, -1},    //7\n\t};\n\n\tstatic char[][] TABLE = new char[10][10];\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\t//String[] words;\n\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tArrays.fill(TABLE[i], ' ');\n\t\t}\n\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tTABLE[i][j + 1] = line.charAt(j);\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tboolean hasNext = true;\n\t\twhile (hasNext) {\n\t\t\thasNext = false;\n\t\t\thasNext |= Mami();\n\t\t\thasNext |= Witch();\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tsb.append(TABLE[i][j]);\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\n\t} //end main\n\n\tstatic boolean Mami() {\n\n\t\tList<int[]> list = search('o');\n\n\n\t\tif (!list.isEmpty()) {\n\t\t\tCollections.sort(list, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[4] != o2[4]) {\n\t\t\t\t\t\treturn Integer.compare(o2[4], o1[4]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tput('o', list);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic boolean Witch() {\n\n\t\tList<int[]> list = search('x');\n\n\t\tif (!list.isEmpty()) {\n\t\t\tCollections.sort(list, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[4] != o2[4]) {\n\t\t\t\t\t\treturn Integer.compare(o2[4], o1[4]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\t\treturn Integer.compare(o2[0], o1[0]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Integer.compare(o2[1], o1[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tput('x', list);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic List<int[]> search(char p) {\n\n\t\tchar t;\n\t\tList<int[]> list = new ArrayList<>();\n\n\t\tif (p == 'o') t = 'x';\n\t\telse t = 'o';\n\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tif (TABLE[i][j] == p) {\n\t\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\t\tint y, x;\n\t\t\t\t\t\ty = i + DIR[k][0];\n\t\t\t\t\t\tx = j + DIR[k][1];\n\t\t\t\t\t\tint[] res = null;\n\t\t\t\t\t\tif (TABLE[y][x] == t) {\n\t\t\t\t\t\t\tres = searchS(t, y, x, k, 1);\n\t\t\t\t\t\t\tif (res != null) {\n\t\t\t\t\t\t\t\tlist.add(res);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//sum up\n\t\tif (list.size() > 1) {\n\t\t\tint[][] sum = new int[10][10];\n\t\t\tfor (int[] l : list) {\n\t\t\t\tsum[l[0]][l[1]] += l[3];\n\t\t\t}\n\t\t\tfor (int[] l : list) {\n\t\t\t\tl[4] = sum[l[0]][l[1]];\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tstatic int[] searchS(char t, int y, int x, int dir, int c) {\n\n\t\tint ny, nx;\n\t\tny = y + DIR[dir][0];\n\t\tnx = x + DIR[dir][1];\n\n\t\tif (TABLE[ny][nx] == t) {\n\t\t\treturn searchS(t, ny, nx, dir, c + 1);\n\t\t} else if (TABLE[ny][nx] == '.') {\n\t\t\treturn new int[]{ny, nx, dir, c, c};\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tstatic void put(char p, List<int[]> list) {\n\n\t\tint sy, sx;\n\t\tsy = list.get(0)[0];\n\t\tsx = list.get(0)[1];\n\n\t\tTABLE[sy][sx] = p;\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tif (list.get(i)[0] == sy && list.get(i)[1] == sx) {\n\t\t\t\tint y, x, dir, c;\n\t\t\t\ty = sy;\n\t\t\t\tx = sx;\n\t\t\t\tdir = (list.get(i)[2] + 4) % 8;\n\t\t\t\tc = list.get(i)[3];\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\ty += DIR[dir][0];\n\t\t\t\t\tx += DIR[dir][1];\n\t\t\t\t\tTABLE[y][x] = p;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int a[][] = new int [8][8];\n\n\tpublic static int check(int x, int y, int k) {\n\t\tint sum = 0;\n\n\t\tint subsum = 0;\n\t\tfor (int i = 1; x + i < 8; i++) {\n\t\t\tif (a[y][x + i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y][x + i] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; 0 <= x - i; i++) {\n\t\t\tif (a[y][x - i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y][x - i] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; y + i < 8; i++) {\n\t\t\tif (a[y + i][x] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y + i][x] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; 0 <= y - i; i++) {\n\t\t\tif (a[y - i][x] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y - i][x] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; x + i < 8 && y + i < 8; i++) {\n\t\t\tif (a[y + i][x + i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y + i][x + i] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; x + i < 8 && 0 <= y - i; i++) {\n\t\t\tif (a[y - i][x + i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y - i][x + i] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; 0 <= x - i&& y + i < 8; i++) {\n\t\t\tif (a[y + i][x - i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y + i][x - i] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsubsum = 0;\n\t\tfor (int i = 1; 0 <= x - i && 0 <= y - i; i++) {\n\t\t\tif (a[y - i][x - i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y - i][x - i] != k) {\n\t\t\t\tsubsum++;\n\t\t\t} else {\n\t\t\t\tsum += subsum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic static void reverse(int x, int y, int k) {\n\t\tint f = 0;\n\t\tfor (int i = 1; x + i < 8; i++) {\n\t\t\tif (a[y][x + i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y][x + i] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y][x + j] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; 0 <= x - i; i++) {\n\t\t\tif (a[y][x - i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y][x - i] == k) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\ta[y][x - j] *= -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; y + i < 8; i++) {\n\t\t\tif (a[y + i][x] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y + i][x] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y + j][x] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; 0 <= y - i; i++) {\n\t\t\tif (a[y - i][x] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y - i][x] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y - j][x] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; x + i < 8 && y + i < 8; i++) {\n\t\t\tif (a[y + i][x + i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y + i][x + i] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y + j][x + j] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; x + i < 8 && 0 <= y - i; i++) {\n\t\t\tif (a[y - i][x + i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y - i][x + i] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y - j][x + j] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; 0 <= x - i&& y + i < 8; i++) {\n\t\t\tif (a[y + i][x - i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y + i][x - i] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y + j][x - j] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tfor (int i = 1; 0 <= x - i && 0 <= y - i; i++) {\n\t\t\tif (a[y - i][x - i] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[y - i][x - i] != k) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif (0 < f) {\n\t\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t\ta[y - j][x - j] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ta[y][x] = k;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tString s = sc.next();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (s.charAt(j) == 'x') {\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t} else if (s.charAt(j) == 'o') {\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mx, my, mr;\n\t\tint lx, ly, lr;\n\t\tboolean f = true;\n\t\twhile (true) {\n\t\t\tmx = my = mr = 0;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\tif (a[i][j] == 0) {\n\t\t\t\t\t\tint k = check(j, i, 1);\n\t\t\t\t\t\tif (mr < k) {\n\t\t\t\t\t\t\tmx = j;\n\t\t\t\t\t\t\tmy = i;\n\t\t\t\t\t\t\tmr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mr != 0) {\n\t\t\t\treverse(mx, my, 1);\n\t\t\t\tf = true;\n\t\t\t} else {\n\t\t\t\tif (!f) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf = false;\n\t\t\t}\n\n\t\t\tlx = ly = lr = 0;\n\t\t\tfor (int i = 7; 0 <= i; i--) {\n\t\t\t\tfor (int j = 7; 0 <= j; j--) {\n\t\t\t\t\tif (a[i][j] == 0) {\n\t\t\t\t\t\tint k = check(j, i, -1);\n\t\t\t\t\t\tif (lr < k) {\n\t\t\t\t\t\t\tlx = j;\n\t\t\t\t\t\t\tly = i;\n\t\t\t\t\t\t\tlr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lr != 0) {\n\t\t\t\treverse(lx, ly, -1);\n\t\t\t\tf = true;\n\t\t\t} else {\n\t\t\t\tif (!f) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\tSystem.out.print('o');\n\t\t\t\t} else if (a[i][j] == -1) {\n\t\t\t\t\tSystem.out.print('x');\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print('.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\n// 2011/10/20\n\n//@2311 IZÅ é âè¶©çÇÁ¿ªæè©í©çÈ¢\npublic class Main {\n\n\t\n\t// åÉèÔð\\·ÌÉg¤è\n\tpublic static final int BLANK = 0;\n\tpublic static final int BLACK = 1;\n\tpublic static final int WHITE = 2;\n\t\n\t\n\t// \"E4\"Ìæ¤È¶ñðsqnum(0-63)ÉÏ··é\n\t// s¾Í-1\n\tpublic static int getPos(String k) {\n\t\tk = k.toUpperCase();\n\t\tString xStr = \"ABCDEFGH\";\n\t\tString yStr = \"12345678\";\n\t\tint x = xStr.indexOf(k.charAt(0));\n\t\tint y = yStr.indexOf(k.charAt(1));\n\t\tif (x < 0 || y < 0)\n\t\t\treturn -1;\n\t\treturn y * 8 + x;\n\t}\n\n\t\n\t/**\n\t * sqnumðÔ·\n\t * @param x 0-7\n\t * @param y 0-7\n\t * @return sqnum 0-63\n\t */\n\tstatic int getSqnum(int x, int y) {\n\t\treturn x + y * 8; \n\t}\n\tstatic int getX(int sqnum) {\n\t\treturn sqnum % 8;\n\t}\n\tstatic int getY(int sqnum) {\n\t\treturn sqnum / 8;\n\t}\n\n\t\n\t// sqnumð\"E4\"Ìæ¤È¶ñÉ·é 0-63 ÈOÍ\"PA\"Æ·é \n\tpublic static String getPosStr(int sqnum) {\n\t\tint x = getX(sqnum);\n\t\tint y = getY(sqnum);\n\t\tif (0 <= x && x < 8 && 0 <= y && y < 8) {\n\t\t\tString xStr = \"ABCDEFGH\";\n\t\t\tString yStr = \"12345678\";\n\t\t\treturn xStr.substring(x, x + 1) + yStr.substring(y, y + 1);\n\t\t}\n\t\telse {\n\t\t\treturn \"PA\";\n\t\t}\n\t}\n\n\t// x y Åwè³êéêÌbitª1©Ç¤©\n\tprivate static boolean is(long bw, int x, int y) {\n\t\treturn (bw & (1L << (x + y * 8))) != 0; \n\t}\n\t\n\t\n\t\n\t// wèÌÓÌFðÔ·\n\tpublic static int getPos(long[] board, int sqnum) {\n\t\tlong bit = 1L << sqnum;\n\t\tif ((board[0] & bit) != 0) {\n\t\t\treturn BLACK;\n\t\t}\n\t\telse if ((board[1] & bit) != 0) {\n\t\t\treturn WHITE;\n\t\t}\n\t\telse \n\t\t\treturn BLANK;\n\t}\n\n\n\t// BLACK,WHITE,BLANKÌð¦é\n\tpublic static int getCount(long[] board, int color) {\n\t\tif (color == BLACK) {\n\t\t\treturn Long.bitCount(board[0]);\n\t\t}\n\t\telse if (color == WHITE) {\n\t\t\treturn Long.bitCount(board[1]);\n\t\t}\n\t\telse {\n\t\t\treturn Long.bitCount(~(board[0] | board[1]));\n\t\t}\n\t}\n\t\n\t\n\t// Î·ðßé ©ª©çÝ½Î· CO[\n\tpublic static int getSekisa(long mybd, long oppbd) {\n\t\tint b = Long.bitCount(mybd);\n\t\tint w = Long.bitCount(oppbd);\n\t\tint emp = 64 - b - w;\n\t\tint e = b - w;\n\t\t// CO[ ó«ÍÒ\n\t\tif (e > 0) {\n\t\t\te += emp;\n\t\t}\n\t\telse if (e < 0) {\n\t\t\te -= emp;\n\t\t}\n\t\treturn e;\n\t}\n\t// Î·ðßé ©çÝ½Î· CO[\n\tpublic static int getSekisa(long[] board) {\n\t\treturn getSekisa(board[0], board[1]);\n\t}\n\t\n\t// orðæ¾\n\tpublic static String getZchar(int color) {\n\t\tswitch(color) {\n\t\tcase BLACK:\n\t\t\treturn \"\";\n\t\tcase WHITE:\n\t\t\treturn \"\";\n\t\tcase BLANK:\n\t\t\treturn \"  \";\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\n\t/**\n\t * ÕÊðeLXgÅ\\»·é\n\t * @param b\n\t * @param w\n\t * @param te ÅIè_@gíÈ¢êÍ-1\n\t * @return\n\t */\n\tpublic static String toString(long b, long w, int te) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint cb = Long.bitCount(b);\n\t\tint cw = Long.bitCount(w);\n\t\tsb.append(String.format(\"  `abcdefg b=%d w=%d emp=%d b%016x w%016x\\n\", cb, cw, 64 - cb - cw, b, w));\n\t\tfor(int y = 0; y < 8; y++) {\n\t\t\tsb.append(String.format(\"%2d\", y + 1));\n\t\t\tfor(int x = 0; x < 8; x++) {\n\t\t\t\tboolean b1 = is(b, x, y);\n\t\t\t\tboolean b2 = is(w, x, y);\n\t\t\t\tboolean isLast = (y * 8 + x == te);\n\t\t\t\tif (b1) {\n\t\t\t\t\tif (b2) {\n\t\t\t\t\t\tsb.append(\"\"); // ÊíÈ¢\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isLast)\n\t\t\t\t\t\t\tsb.append(\"\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsb.append(\"\"); // \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (b2) {\n\t\t\t\t\tif (isLast)\n\t\t\t\t\t\tsb.append(\"\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsb.append(\"\"); // \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsb.append(\"E\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static String toString2(long b, long w) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int y = 0; y < 8; y++) {\n\t\t\tfor(int x = 0; x < 8; x++) {\n\t\t\t\tboolean b1 = is(b, x, y);\n\t\t\t\tboolean b2 = is(w, x, y);\n\t\t\t\tif (b1) {\n\t\t\t\t\tsb.append(\"o\"); // \n\t\t\t\t}\n\t\t\t\telse if (b2) {\n\t\t\t\t\tsb.append(\"x\"); // \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsb.append(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String toString(long b, long w) {\n\t\treturn toString(b, w, -1);\n\t}\n\n\tpublic static String toString(long board[], int te) {\n\t\treturn toString(board[0], board[1], te);\n\t}\t\n\tpublic static String toString(long board[]) {\n\t\treturn toString(board[0], board[1]);\n\t}\t\n\t\n\t\n\tpublic static void print(long b, long w) {\n\t\tSystem.out.println(toString(b, w));\n\t}\n\t\n\t\n\tpublic static void print(long board[]) {\n\t\tprint(board[0], board[1]);\n\t}\t\n\t\n\t// ú»Õð\\z·é\n\tpublic static long[] createNewBoard() {\n\t\tlong[] board = new long[2];\n\t\tboard[0] = 0x0000000810000000L;\n\t\tboard[1] = 0x0000001008000000L;\n\t\treturn board;\n\t\t\n\t}\n\t\n\t// ûÅwè³êéÕÊðìé\n\t// ÔÌóÔÉ·é\n\tpublic static long[] createBoardR(String kifu) {\n\t\tlong[] board = createNewBoard();\n\t\tfor(int i = 0; i < kifu.length() - 1; i += 2) {\n\t\t\tString s = kifu.substring(i, i + 2);\n\t\t\tint sqnum = getPos(s);\n\t\t\tlong rev = putB(board, board, sqnum);\n\t\t\tassert(rev != 0);\n\t\t\tlong mobB = getMobirity(board, BLACK);\n\t\t\tlong mobW = getMobirity(board, WHITE);\n\t\t\tif (mobB == 0 && mobW != 0) {\n\t\t\t\trevBW(board); // à¤êñ½]\n\t\t\t}\n\t\t}\n\t\treturn board;\n\t}\n\t\n\t\n\t\n\tpublic static long getMybd(long[] board, int color) {\n\t\tlong mybd = board[(color == BLACK) ? 0 : 1];\n\t\treturn mybd;\n\t}\n\tpublic static long getOppbd(long[] board, int color) {\n\t\tlong oppbd = board[(color == BLACK) ? 1 : 0];\n\t\treturn oppbd;\n\t}\n\tpublic static long[] getBoard(long mybd, long oppbd, int color) {\n\t\tlong[] board = new long[2];\n\t\tboard[0] = (color == BLACK) ? mybd : oppbd;\n\t\tboard[1] = (color == BLACK) ? oppbd : mybd;\n\t\treturn board;\n\t}\n\t\n\t\n\n\t// vXûü\n\tprivate static long _drctnlFlipsP(long mybd, long oppbd, long p, int inc)\n\t{\n\t\tlong t = (p << inc) & oppbd;\n\t\tt |= (t << inc) & oppbd;\n\t\tt |= (t << inc) & oppbd;\n\t\tt |= (t << inc) & oppbd;\n\t\tt |= (t << inc) & oppbd;\n\t\tt |= (t << inc) & oppbd;\n\t\tif (((t << inc) & mybd) != 0) {\n\t\t\treturn t;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\t// }CiXûü\n\tprivate static long _drctnlFlipsM(long mybd, long oppbd, long p, int inc)\n\t{\n\t\tlong t = (p >>> inc) & oppbd;\n\t\tt |= (t >>> inc) & oppbd;\n\t\tt |= (t >>> inc) & oppbd;\n\t\tt |= (t >>> inc) & oppbd;\n\t\tt |= (t >>> inc) & oppbd;\n\t\tt |= (t >>> inc) & oppbd;\n\t\tif (((t >>> inc) & mybd) != 0) {\n\t\t\treturn t;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\t\n\t//int nodeCnt = 0;\n\t/* The 8 legal directions: */  // Sûü\n//\tprivate final static int[] dirinc = {1, -1, 8, -8, 9, -9, 10, -10};\n\tprivate final static int[] DIRINC = {1, -1, 7, -7, 8, -8, 9, -9};\n\t\n\t// Ç»è}XN\n\tprivate final static long[] WALLMASK = { \n\t\t0x7e7e7e7e7e7e7e7eL, // ¡p\n\t\t0x007e7e7e7e7e7e00L, // ÈÈßp\n\t\t0x00ffffffffffff00L, // cp\n\t\t0x007e7e7e7e7e7e00L, // ÈÈßp\n\t};\n\n\t/* Bit masks for the directions squares can flip in,\n\t* for example dirmask[10]=81=64+16+1=(1<<6)+(1<<4)+(1<<0)\n\t* hence square 10 (A1) can flip in directions dirinc[0]=1,\n\t* dirinc[4]=9, and dirinc[6]=10: */\n\t// èÌÛÉÇÁ¿ÌûüðÔ¹é©Ìe[u\n\tprivate final static int[] DIRMASK/*[91]*/ = {\n\t\t81, 81, 87, 87, 87, 87, 22, 22, \n\t\t81, 81, 87, 87, 87, 87, 22, 22, \n\t\t121, 121, 255, 255, 255, 255, 182, 182, \n\t\t121, 121, 255, 255, 255, 255, 182, 182, \n\t\t121, 121, 255, 255, 255, 255, 182, 182, \n\t\t121, 121, 255, 255, 255, 255, 182, 182, \n\t\t41, 41, 171, 171, 171, 171, 162, 162, \n\t\t41, 41, 171, 171, 171, 171, 162, 162, \n\t};\n\t\n\t/* Do all flips involved in making a move to square sqnum of board,\n\t * and return their count. */\n\t// è·é  ½]·éÎðÔ·@Ôµ½ÎÍO[oÏflipCntÉÔ·\n\t// sqnum Í0-64\n\tpublic static long DoFlips(long mybd, long oppbd, int sqnum)\n\t{\n\t\t//nodeCnt++;\n\t\tint dirMask = DIRMASK[sqnum];\n\t\tlong p = 1L << sqnum;\n\t\tlong rev = 0;\n\t\t\n\t\tlong oppbd3 = oppbd & WALLMASK[3];\n\t\tlong oppbd2 = oppbd & WALLMASK[2];\n\t\tlong oppbd1 = oppbd & WALLMASK[1];\n\t\tlong oppbd0 = oppbd & WALLMASK[0];\n\t\t\n//\t\trev |= _drctnlFlips(mybd, oppbd3, p, DIRINC[6], dirMask >> 6);\n//\t\trev |= _drctnlFlips(mybd, oppbd2, p, DIRINC[4], dirMask >> 4);\n//\t\trev |= _drctnlFlips(mybd, oppbd1, p, DIRINC[2], dirMask >> 2);\n//\t\trev |= _drctnlFlips(mybd, oppbd0, p, DIRINC[0], dirMask);\n\t\t\n\t\tif ((dirMask & 128) != 0)\n\t\t\trev = _drctnlFlipsM(mybd, oppbd3, p, DIRINC[6]);\n\t\tif ((dirMask & 64) != 0)\n\t\t\trev |= _drctnlFlipsP(mybd, oppbd3, p, DIRINC[6]);\n\t\tif ((dirMask & 32) != 0)\n\t\t\trev |= _drctnlFlipsM(mybd, oppbd2, p, DIRINC[4]); // c\n\t\tif ((dirMask & 16) != 0)\n\t\t\trev |= _drctnlFlipsP(mybd, oppbd2, p, DIRINC[4]);\n\t\tif ((dirMask & 8) != 0)\n\t\t\trev |= _drctnlFlipsM(mybd, oppbd1, p, DIRINC[2]);\n\t\tif ((dirMask & 4) != 0)\n\t\t\trev |= _drctnlFlipsP(mybd, oppbd1, p, DIRINC[2]);\n\t\tif ((dirMask & 2) != 0)\n\t\t\trev |= _drctnlFlipsM(mybd, oppbd0, p, DIRINC[0]); // ¡\n\t\tif ((dirMask & 1) != 0)\n\t\t\trev |= _drctnlFlipsP(mybd, oppbd0, p, DIRINC[0]);\n\n\t   return rev;\n\t}\n\n\t\n\t/**\n\t * boardÉèµ½ÕÊboard2ðÔ·\n\t * board = board2ÅÄñÅàÇ¢\n\t * @param board\n\t * @param board2\n\t * @param sqnum\n\t * @param color\n\t * @return ½]bit\n\t */\n\tpublic static long put(long[] board, long[] board2, int sqnum, int color) {\n\t\tassert(0 <= sqnum && sqnum < 64);\n\t\tassert(color == BLACK || color == WHITE);\n\t\tlong rev;\n\n\t\tif (((board[0] | board[1]) & (1L << sqnum)) != 0)\n\t\t\treturn 0; // ùÉÎª é\n\t\tif (color == BLACK) {\n\t\t\trev = DoFlips(board[0], board[1], sqnum);\n\t\t\tif (rev != 0) {\n\t\t\t\tboard2[0] = board[0] ^ (rev | (1L << sqnum));\n\t\t\t\tboard2[1] = board[1] ^ rev;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trev = DoFlips(board[1], board[0], sqnum);\n\t\t\tif (rev != 0) {\n\t\t\t\tboard2[1] = board[1] ^ (rev | (1L << sqnum));\n\t\t\t\tboard2[0] = board[0] ^ rev;\n\t\t\t}\n\t\t}\n\t\treturn rev;\n\t}\n\t// ÔêpÅÅÁ½ã½]·é\n\t// pXÅà½]µÄµÜ¤\n\tpublic static long putB(long[] board, long[] board2, int sqnum) {\n\t\tassert(0 <= sqnum && sqnum < 64);\n\t\tlong rev;\n\n\t\tif (((board[0] | board[1]) & (1L << sqnum)) != 0)\n\t\t\treturn 0; // ùÉÎª é\n\t\trev = DoFlips(board[0], board[1], sqnum);\n\t\tif (rev != 0) {\n\t\t\tlong b = board[0] ^ (rev | (1L << sqnum));\n\t\t\tlong w = board[1] ^ rev;\n\t\t\tboard2[0] = w; // ½]\n\t\t\tboard2[1] = b;\n\t\t}\n\t\treturn rev;\n\t}\n\t\n\t\n\t// èÂ\\©Ç¤©Ô·\n\tpublic static boolean isPut(long[] board, int sqnum, int color) {\n\t\tassert(0 <= sqnum && sqnum < 64);\n\t\tassert(color == BLACK || color == WHITE);\n\t\tlong rev;\n\t\tif (((board[0] | board[1]) & (1L << sqnum)) != 0)\n\t\t\treturn false; // ùÉÎª é\n\t\tif (color == BLACK) {\n\t\t\trev = DoFlips(board[0], board[1], sqnum);\n\t\t}\n\t\telse {\n\t\t\trev = DoFlips(board[1], board[0], sqnum);\n\t\t}\n\t\treturn rev != 0;\n\t}\n\n\n\tprivate static long _scanMob(long mybd, long oppbd, int inc)\n\t{\n\t\t// vXûü\n\t\tlong tp = (mybd << inc) & oppbd;\n//\t\ttp |= (tp << inc) & oppbd;\n//\t\ttp |= (tp << inc) & oppbd;\n//\t\ttp |= (tp << inc) & oppbd;\n//\t\ttp |= (tp << inc) & oppbd;\n//\t\ttp |= (tp << inc) & oppbd;\n\t\t// ãÆºÍ¯¶\n\t\t{\n\t\t   long oppbd2 = (oppbd << inc) & oppbd; \n\t\t   tp |= (tp << inc) & oppbd; \n\t\t   tp |= (tp << inc*2) & oppbd2; \n\t\t   tp |= (tp << inc*2) & oppbd2;\n\t\t}\n\t\ttp <<= inc;\n\t\t\n\t\t// }CiXûü\n\t\tlong tm = (mybd >>> inc) & oppbd;\n\t\t{\n\t\t   long oppbd2 = (oppbd >>> inc) & oppbd; \n\t\t   tm |= (tm >>> inc) & oppbd; \n\t\t   tm |= (tm >>> inc*2) & oppbd2; \n\t\t   tm |= (tm >>> inc*2) & oppbd2;\n\t\t}\n\t\ttm >>>= inc;\n\t\t\n\t\treturn tp | tm;\n\t}\n\t\n\t// ÕÊÌèÂ\\_Ìbitðæ¾\n\tpublic static long getMobirity(long mybd, long oppbd) {\n\t\tlong t = 0;\n\t\tt |= _scanMob(mybd, oppbd & WALLMASK[3], DIRINC[6]);\n\t\tt |= _scanMob(mybd, oppbd & WALLMASK[2], DIRINC[4]);\n\t\tt |= _scanMob(mybd, oppbd & WALLMASK[1], DIRINC[2]);\n\t\tt |= _scanMob(mybd, oppbd & WALLMASK[0], DIRINC[0]);\n\t\t\n\t\tt &= ~(mybd | oppbd); // Îª éÆ±ëÍ­\n\t\treturn t;\n\t}\n\n\t// ÕÊÌèÂ\\_Ìbitðæ¾\n\tpublic static long getMobirity(long[] board, int color) {\n\t\tlong mybd = board[(color == BLACK) ? 0 : 1];\n\t\tlong oppbd = board[(color == BLACK) ? 1 : 0];\n\t\treturn getMobirity(mybd, oppbd);\n\t}\n\t\n\t\n\t// èÂ\\ÓðÔ·\n\tpublic static int countMobility(long mybd, long oppbd) {\n\t\tlong t = getMobirity(mybd, oppbd);\n\t\tint mobility = Long.bitCount(t);\n\t\treturn mobility;\n\t}\n\n\t// èÂ\\_Ìzñðæ¾·é\n\tpublic static int[] getMobirityArray(long mybd, long oppbd) {\n\t\tlong mb = getMobirity(mybd, oppbd);\n\t\tint cnt = Long.bitCount(mb);\n\t\tint[] a = new int[cnt];\n\t\tint idx = 0;\n\t\tfor(int sqnum = 0; sqnum < 64; sqnum++) {\n\t\t\tif (((1L << sqnum) & mb) != 0) {\n\t\t\t\ta[idx] = sqnum;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tassert(idx == cnt);\n\t\treturn a;\n\t}\n\t\n\n\t\n \n\t/**\n\t * bitÕ90xñ]  xª¶ûü@yªºûü@ÅºÊbitª´_Æ·éÆ¶ñèÅ é\n\t * 2x2ñ] 4x4ñ] 8x8ñ]ÌÉs¤\n\t * @param bd\n\t * @return\n\t */\n\tpublic static long round(long bd) {\n\t\t\n\t\tbd = bd <<  1 & 0xAA00AA00AA00AA00L |\n\t\t     bd >>> 1 & 0x0055005500550055L |\n\t         bd >>> 8 & 0x00AA00AA00AA00AAL |\n\t         bd <<  8 & 0x5500550055005500L;\n\t    bd = bd <<  2 & 0xCCCC0000CCCC0000L |\n\t         bd >>> 2 & 0x0000333300003333L |\n\t         bd >>>16 & 0x0000CCCC0000CCCCL |\n\t         bd << 16 & 0x3333000033330000L;\n\t    bd = bd <<  4 & 0xF0F0F0F000000000L |\n\t         bd >>> 4 & 0x000000000F0F0F0FL |\n\t         bd >>>32 & 0x00000000F0F0F0F0L |\n\t         bd << 32 & 0x0F0F0F0F00000000L;\n\t    return bd;\n\t}\n\t\n\t\n\t\n\t/**\n\t * 2ÊÌQm 0-7ÅÌÏ·\n\t * m = 0 PÏ·\n\t * m = 1 E90xñ]\n\t * m = 2 E180xñ]\n\t * m = 3 E270xñ]\n\t * m = 4 ãº½]\n\t * m = 5 zCgC½] == ãº½] + E90xñ]\n\t * m = 6 ¶E½] ==           ãº½] + E180xñ]\n\t * m = 7 ubNC½] == ãº½] + E270xñ]\n\t * \n\t * \n\t * @param te\n\t * @param m\n\t * @return\n\t */\n\tpublic static int hente(int te, int m)\n\t{\n\t\tassert(0 <= m && m < 8);\n\t    int x = te % 8;\n\t    int y = te / 8;\n\t    \n\t    if (m >= 4) {\n\t    \tm -= 4;\n\t    \ty = 7 - y; // c½]\n\t    }\n\t    for(int i = 0; i < m; i++) {\n\t\t    // 90xñ]\n\t\t    int y2 = x;\n\t\t    x = 7 - y;\n\t\t    y = y2;\n\t    }\n\t    return y * 8 + x;\n\t}\n\n\t//  2ÊÌQ Ï·µ½ÕÊðæ¾·é\n\t// ¿áñÆ¢½¯Ç@eXgpÉµ©gÁÄ¢È¢ compare()ÆZ·éH\n\tpublic static long[] getDihedralBoard(long[] board, int m) {\n\t\tassert(0 <= m && m < 8);\n\t\tlong[] res = new long[2]; \n\t\tif (m == 0) {\n\t\t\tres[0] = board[0];\n\t\t\tres[1] = board[1];\n\t\t}\n\t\telse if (m == 1) {\n\t\t\tres[0] = round(Long.reverse(board[0]));\n\t\t\tres[1] = round(Long.reverse(board[1]));\n\t\t}\n\t\telse if (m == 2) {\n\t\t\tres[0] = Long.reverse(board[0]);\n\t\t\tres[1] = Long.reverse(board[1]);\n\t\t}\n\t\telse if (m == 3) {\n\t\t\tres[0] = round(board[0]);\n\t\t\tres[1] = round(board[1]);\n\t\t}\n\t\telse if (m == 4) {\n\t\t\tres[0] = Long.reverseBytes(board[0]); // ãº½]\n\t\t\tres[1] = Long.reverseBytes(board[1]);\n\t\t}\n\t\telse if (m == 5) {\n\t\t\tres[0] = Long.reverseBytes(round(board[0]));\n\t\t\tres[1] = Long.reverseBytes(round(board[1]));\n\t\t}\n\t\telse if (m == 6) {\n\t\t\tres[0] = Long.reverse(Long.reverseBytes(board[0]));\n\t\t\tres[1] = Long.reverse(Long.reverseBytes(board[1]));\n\t\t}\n\t\telse if (m == 7) {\n\t\t\tres[0] = round(Long.reverseBytes(board[0]));\n\t\t\tres[1] = round(Long.reverseBytes(board[1]));\n\t\t}\n\t\treturn res;\n\t}\n\n\t// 2ÊÌQmÌt³\n\tpublic static int inv(int m) {\n\t\tassert(0 <= m && m < 8);\n\t\tswitch(m) {\n\t\tcase 0: // PÊ³\n\t\tcase 2: // ÎÌ²4{ÅÌÜèÔµÆ180xñ]\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\treturn m;\n\t\tcase 1: // 90xñ]\n\t\tcase 3:\n\t\t\treturn 4 - m;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\n\t/**\n\t * ÕÊðär·é  ÎÌðÜßÄêv·é©Ç¤©Ô·\n\t * èÎp\n\t * board0É2ÊÌQÌÏ·ðsÁÄêvµ½Æ«ÉÏ·èðÔ·\n\t * @param board0\n\t * @param board1\n\t * @return -1sêv 0-7êv\n\t */\n\tpublic static int compare(long[] board0, long[] board1) {\n\t\n\t\tif (board0[0] == board1[0] && board0[1] == board1[1]) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong bd0 = round(board0[0]);\n\t\tlong bd1 = round(board0[1]);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 3;\n\t\t}\n\t\tbd0 = round(bd0);\n\t\tbd1 = round(bd1);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 2;\n\t\t}\n\t\tbd0 = round(bd0);\n\t\tbd1 = round(bd1);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tbd0 = Long.reverseBytes(board0[0]); // ãº½]\n\t\tbd1 = Long.reverseBytes(board0[1]);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 4;\n\t\t}\n\t\tbd0 = round(bd0);\n\t\tbd1 = round(bd1);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 7;\n\t\t}\n\t\tbd0 = round(bd0);\n\t\tbd1 = round(bd1);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 6;\n\t\t}\n\t\tbd0 = round(bd0);\n\t\tbd1 = round(bd1);\n\t\tif (bd0 == board1[0] && bd1 == board1[1]) {\n\t\t\treturn 5;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\t// ÕÊ½]\n\tpublic static void revBW(long[] board) {\n\t\tlong t = board[0];\n\t\tboard[0] = board[1];\n\t\tboard[1] = t;\n\t}\n\t\n\t// clone copy\n\tpublic static long[] clone(long[] board) {\n\t\tlong[] b = new long[2];\n\t\tb[0] = board[0];\n\t\tb[1] = board[1];\n\t\treturn b;\n\t}\n\t\n\t\n\t\n\n\n\t\n\t// C return falseÅ¨µÜ¢\n\tboolean main() throws IOException {\n\n\t\tlong[] bd = new long[2];\n\t\t\n\t\t// read\n\t\tfor(int y = 0; y < 8; y++) {\n\t\t\tString s = reader.readLine();\n\t\t\tfor(int x = 0; x < 8; x++) {\n\t\t\t\tif (s.charAt(x) == 'o') {\n\t\t\t\t\tbd[0] += 1L << (y * 8 + x);\n\t\t\t\t}\n\t\t\t\telse if (s.charAt(x) == 'x') {\n\t\t\t\t\tbd[1] += 1L << (y * 8 + x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint color = BLACK;\n\t\tboolean isPass = false;\n\t\tfor(;;) {\n\t\t\n\t\t\tint maxCnt = 0;\n\t\t\tint maxPos = -1;\n\t\t\tfor(int x = 0; x < 64; x++) {\n\t\t\t\tint pos = x;\n\t\t\t\tif (color == WHITE) {\n\t\t\t\t\tpos = 63 - x; // ÍEº©ç¸\n\t\t\t\t}\n\t\t\t\tif (((bd[0] | bd[1]) & (1L << pos)) != 0)\n\t\t\t\t\tcontinue; // ·ÅÉÎª é\n\t\t\t\tlong rev;\n\t\t\t\tif (color == BLACK) {\n\t\t\t\t\trev = DoFlips(bd[0], bd[1], pos);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trev = DoFlips(bd[1], bd[0], pos);\n\t\t\t\t}\n\t\t\t\tint cnt = Long.bitCount(rev);\n\t\t\t\tif (cnt> maxCnt) {\n\t\t\t\t\tmaxCnt = cnt;\n\t\t\t\t\tmaxPos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxCnt == 0) {\n\t\t\t\tif (isPass)\n\t\t\t\t\tbreak; // I¹\n\t\t\t\t//pX\n\t\t\t\tisPass = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tput(bd, bd, maxPos, color);\n\t\t\t\tisPass = false;\n\t\t\t}\n\t\t\t//print(bd);\n\t\t\tcolor = BLACK + WHITE - color;\n\t\t}\n\t\t\n//\t\tlog.printf(\"%s\\n\", toString(b, w));\n\t\t\n\t\t\t\t\n\t\t// ðÌ\\¦\n\t\tString ban = toString2(bd[0], bd[1]);\n\t\tSystem.out.printf(\"%s\", ban);\n\t\t\n\t\t\n//\t\treturn true; // ³íI¹ Ö\n\t\treturn false;\n\t}\n\t\n\n//\tprivate final static boolean DEBUG = true;  // debug\n\tprivate final static boolean DEBUG = false; // release\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (DEBUG) {\n\t\t\tlog = System.out;\n\t\t\t\n\t\t\tString inputStr = \"ooox....\\n\"+\n\t\t\t\".x......\\n\"+\n\t\t\t\"ooo.....\\n\"+\n\t\t\t\"........\\n\"+\n\t\t\t\"........\\n\"+\n\t\t\t\"........\\n\"+\n\t\t\t\"........\\n\"+\n\t\t\t\"........\\n\";\n\t\t\treader = new BufferedReader(new StringReader(inputStr)); \n\n\t\t}\n\t\telse {\n\t\t\tlog = new PrintStream(new OutputStream() { public void write(int b) {} } ); // «ÌÄ\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in)); // R\\[©ç\n\t\t}\n\t\t\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; /*i < N*/; i++) {\n\t\t\tboolean b = new Main().main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\t\n\t\treader.close();\n\t}\n\n\t\n\tstatic PrintStream log;\n\tstatic BufferedReader reader;\n\t\n\n\t// WüÍæè1sªÌXy[XæØèÌ®lðÇÞ\n\t// EOFÌêÍnullðÔ·\n\tprivate static int[] readIntArray() throws IOException {\n\t\t\n\t\tString s = reader.readLine();\n\t\tif (s == null)\n\t\t\treturn null;\n\t\tString[] sp = s.split(\" \");\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tsolve();\n\t}\n\tpublic static void solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] s = new String[8];\n\t\tint[][] map = new int[8][8];\n\t\tboolean turn = true;\n\t\tboolean judge = true;\n\t\tint nextx = -1;\n\t\tint nexty = -1;\n\t\tint nowcount = 0;\n\t\tint[] dx = {1,1,0,-1,-1,-1,0,1};\n\t\tint[] dy = {0,-1,-1,-1,0,1,1,1};\n\t\tfor(int i=0;i<8;i++){\n\t\t\tArrays.fill(map[i], -1);\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\ts[i] = sc.next();\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(s[i].charAt(j)=='o'){\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(s[i].charAt(j)=='x'){\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean flag = false;\n\t\tboolean flags = false;\n\t\twhile(judge){\n\t\t\tnowcount = 1;\n\t\t\tnextx = -1;\n\t\t\tnexty = -1;\n\t\t\tif(turn){\n\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tif(i+dx[k]<0 || i+dx[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j+dy[k]<0 || j+dy[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i+dx[k]][j+dy[k]]==0){\n\t\t\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\t\t\tif(i+l*dx[k]<0 || i+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j+l*dy[k]<0 || j+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==1){\n\t\t\t\t\t\t\t\t\t\t\tcount += l - 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nowcount<=count){\n\t\t\t\t\t\t\t\tnextx = i;\n\t\t\t\t\t\t\t\tnexty = j;\n\t\t\t\t\t\t\t\tnowcount = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextx != -1){\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tif(nextx+dx[k]<0 || nextx+dx[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nexty+dy[k]<0 || nexty+dy[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[nextx+dx[k]][nexty+dy[k]]==0){\n\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\tif(nextx+l*dx[k]<0 || nextx+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nexty+l*dy[k]<0 || nexty+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==1){\n\t\t\t\t\t\t\t\t\twhile(l>0){\n\t\t\t\t\t\t\t\t\t\tl--;\n\t\t\t\t\t\t\t\t\t\tmap[nextx+l*dx[k]][nexty+l*dy[k]] = 1;\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnowcount = 0;\n\t\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\t\t\tif(i+dx[k]<0 || i+dx[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j+dy[k]<0 || j+dy[k]>7){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[i+dx[k]][j+dy[k]]==1){\n\t\t\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\t\t\tif(i+l*dx[k]<0 || i+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(j+l*dy[k]<0 || j+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(map[i+l*dx[k]][j+l*dy[k]]==0){\n\t\t\t\t\t\t\t\t\t\t\tcount += l;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(nowcount<count){\n\t\t\t\t\t\t\t\tnextx = i;\n\t\t\t\t\t\t\t\tnexty = j;\n\t\t\t\t\t\t\t\tnowcount = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextx != -1){\n\t\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\t\tif(nextx+dx[k]<0 || nextx+dx[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nexty+dy[k]<0 || nexty+dy[k]>7){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[nextx+dx[k]][nexty+dy[k]]==1){\n\t\t\t\t\t\t\tfor(int l=2;l<8;l++){\n\t\t\t\t\t\t\t\tif(nextx+l*dx[k]<0 || nextx+l*dx[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nexty+l*dy[k]<0 || nexty+l*dy[k]>7){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==-1){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(map[nextx+l*dx[k]][nexty+l*dy[k]]==0){\n\t\t\t\t\t\t\t\t\twhile(l>0){\n\t\t\t\t\t\t\t\t\t\tl--;\n\t\t\t\t\t\t\t\t\t\tmap[nextx+l*dx[k]][nexty+l*dy[k]] = 0;\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflags = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag && flags){\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t\tint counter = 0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(map[i][j]!=-1){\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\t/*if(map[i][j]==-1){\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tSystem.out.print(\"o\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tSystem.out.print(\"x\");\n\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t/*try{\n\t\t\t\tThread.sleep(1000);\n\t\t\t}catch(InterruptedException e){}*/\n\t\t\t//System.out.println(nextx+\" \"+nexty+\" \"+counter);\n\t\t\tif(counter>=64){\n\t\t\t\tjudge = false;\n\t\t\t}\n\t\t\tif(turn){\n\t\t\t\tflags = false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tturn = !turn;\n\t\t}\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(map[i][j]==-1){\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tSystem.out.print(\"o\");\n\t\t\t\t}\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tSystem.out.print(\"x\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n    public int getCount(int x,int y,char my,char enemy){\n    \tint D=0;\n    \tL:for(int i=0;i<8;i++){\n\t\t\tint ds=0;\n\t\t\tint px=x,py=y;\n\t\t\tpx+=d[i][0];\n\t\t\tpy+=d[i][1];\n\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\tcontinue L;\n\n\t\t\twhile(map[py][px]==enemy){\n\t\t\t\tds++;\n\t\t\t\tpx+=d[i][0];\n\t\t\t\tpy+=d[i][1];\n\t\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\t\tcontinue L;\n\t\t\t}\n\t\t\tif(map[py][px]==my)\n\t\t\t\tD+=ds;\n\t\t}\n    \treturn D;\n    }\n\n    public void setCookie(int x,int y,char my ,char enemy){\n    \tmap[y][x]=my;\n    \tD:for(int i=0;i<8;i++){\n\t\t\tint px=x,py=y;\n\t\t\tpx+=d[i][0];\n\t\t\tpy+=d[i][1];\n\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\tcontinue D;\n\t\t\twhile(map[py][px]==enemy){\n\t\t\t\tpx+=d[i][0];\n\t\t\t\tpy+=d[i][1];\n\t\t\t\tif(!(0<= px && px<8 && 0<= py && py<8))\n\t\t\t\t\tcontinue D;\n\t\t\t}\n\t\t\tif(map[py][px]==my){\n\t\t\t\tpx-=d[i][0];\n\t\t\t\tpy-=d[i][1];\n\t\t\t\twhile(!(px==x && py==y)){\n\t\t\t\t\tmap[py][px]=my;\n\t\t\t\t\tpx-=d[i][0];\n\t\t\t\t\tpy-=d[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    char[][] map;\n\tint[][] d;\n    public void run() {\n    \tmap=new char[8][8];\n    \tfor(int i=0;i<8;i++){\n    \t\tmap[i]=sc.next().toCharArray();\n    \t}\n\n    \tboolean mami=true;\n    \td=new int[][]{\n    \t\t\t{1,0},{1,1},\n    \t\t\t{0,1},{-1,1},\n    \t\t\t{-1,0},{-1,-1},\n    \t\t\t{0,-1},{1,-1}\n    \t};\n\n    \tboolean prevpass=false;\n\n    \twhile(true){\n    \t\tint max=0,resx=-1,resy=-1;\n    \t\tfor(int y=0;y<8;y++)for(int x=0;x<8;x++){\n    \t\t\tif(map[y][x]!='.')continue;\n    \t\t\tint D=getCount(x,y,mami?'o':'x',mami?'x':'o');\n    \t\t\tif(mami){\n\t    \t\t\tif(max<D){\n\t    \t\t\t\tmax=D;\n\t    \t\t\t\tresx=x;\n\t    \t\t\t\tresy=y;\n\t    \t\t\t}\n    \t\t\t}else{\n    \t\t\t\tif(max<=D){\n\t    \t\t\t\tmax=D;\n\t    \t\t\t\tresx=x;\n\t    \t\t\t\tresy=y;\n\t    \t\t\t}\n    \t\t\t}\n    \t\t}\n\n    \t\tif(max>0){\n    \t\t\tsetCookie(resx,resy,mami?'o':'x',mami?'x':'o');\n        \t\tprevpass=false;\n    \t\t}else{\n    \t\t\tif(!prevpass)\n    \t\t\t\tprevpass=true;\n    \t\t\telse{\n    \t\t\t\tfor(int y=0;y<8;y++){\n        \t\t\t\tfor(int x=0;x<8;x++)\n        \t\t\t\t\tpr(map[y][x]);\n\n        \t\t\t\tln();\n    \t\t\t\t}\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t}\n\n    \t\tmami=!mami;\n    \t}\n   }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public int[] nextIntArray(int n){\n        int[] res=new int[n];\n        for(int i=0;i<n;i++){\n            res[i]=sc.nextInt();\n        }\n        return res;\n    }\n    public static void pr(Object o) {\n        out.print(o);\n    }\n    public static void ln(Object o) {\n        out.println(o);\n    }\n    public static void ln() {\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                System.out.println(\"!\");\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n                System.out.println(\"Puts:turn:\"+turn+\":\"+mY+\",\"+mX);\n                for (int i=0;i<8;i++) {\n                    for (int j=0;j<8 ;j++) {\n                        switch (map[i][j]) {\n                            case 1:\n                                System.out.print('o');\n                                break;\n                            case -1:\n                                System.out.print('x');\n                                break;\n                            case 0:\n                                System.out.print('.');\n                                break;\n                        }\n                    }\n                    System.out.println(\"\");\n                }\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        int y1 = y, x1 = x;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n            } else if (map[y][x] == a) {\n                break;\n            } else {\n                return;\n            }\n        }\n        for (int cnt=0;cnt<8;cnt++, y-=dy,x-=dx) {\n            if (y == y1 && x == x1) {\n                return;\n            }\n            map[y][x] = a;\n        }\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\tstatic int[] DC = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tchar[][] b = new char[8][8];\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tb[i] = sc.next().toCharArray();\n\t\t}\n\t\tchar[] hand = { 'o', 'x' };\n\t\tfor (int t = 0; t < 64; ++t) {\n\t\t\tint pr = -1;\n\t\t\tint pc = -1;\n\t\t\tint best = -1;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\t\t\tint c = count(b, i, j, hand[t % 2]);\n\t\t\t\t\tif (c > 0 && (c > best || (t % 2 != 0 && c == best))) {\n\t\t\t\t\t\tbest = c;\n\t\t\t\t\t\tpr = i;\n\t\t\t\t\t\tpc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\t\t\tSystem.out.println(pr + \" \" + pc + \" \" + best);\n\t\t\tif (best != -1) put(b, pr, pc, hand[t % 2]);\n\t\t}\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tSystem.out.println(String.valueOf(b[i]));\n\t\t}\n\t}\n\n\tstatic int count(char[][] board, int r, int c, char hand) {\n\t\tif (board[r][c] != '.') return 0;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tint pr = r + DR[i];\n\t\t\tint pc = c + DC[i];\n\t\t\tint revert = 0;\n\t\t\twhile (0 <= pr && pr < 8 && 0 <= pc && pc < 8) {\n\t\t\t\tif (board[pr][pc] == hand) {\n\t\t\t\t\tcount += revert;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (board[pr][pc] == '.') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr += DR[i];\n\t\t\t\tpc += DC[i];\n\t\t\t\t++revert;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tstatic void put(char[][] board, int r, int c, char hand) {\n\t\tboard[r][c] = hand;\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tint pr = r + DR[i];\n\t\t\tint pc = c + DC[i];\n\t\t\twhile (0 <= pr && pr < 8 && 0 <= pc && pc < 8) {\n\t\t\t\tif (board[pr][pc] == hand) {\n\t\t\t\t\tpr -= DR[i];\n\t\t\t\t\tpc -= DC[i];\n\t\t\t\t\twhile (pr != r || pc != c) {\n\t\t\t\t\t\tboard[pr][pc] = hand;\n\t\t\t\t\t\tpr -= DR[i];\n\t\t\t\t\t\tpc -= DC[i];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (board[pr][pc] == '.') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr += DR[i];\n\t\t\t\tpc += DC[i];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n=8;\n\t\tchar[][] map=ir.nextCharMap(n,n);\n\t\tint p=-1;\n\t\tfor(int m=0;;m^=1){\n\t\t\tint ma=0,x=-1,y=-1;\n\t\t\tif(m==0){\n\t\t\t\tfor(int i=n-1;i>=0;i--){\n\t\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint c=get(i,j,m,map,false);\n\t\t\t\t\t\tif(c>=ma){\n\t\t\t\t\t\t\tma=c;\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ma==0&&p==0)\n\t\t\t\tbreak;\n\t\t\tif(ma!=0)\n\t\t\t\tget(x,y,m,map,true);\n\t\t\tp=ma;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print(Character.toString(map[i][j]));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\n\tstatic int get(int x,int y,int m,char[][] map,boolean reverse){\n\t\tif(reverse)\n\t\t\tmap[x][y]=conv(m);\n\t\tint ret=0;\n\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\t\tif(dx==0&&dy==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint nx=x+dx*i;\n\t\t\t\t\tint ny=y+dy*i;\n\t\t\t\t\tif(!(nx>=0&&ny>=0&&nx<map.length&&ny<map.length))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]=='.')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(map[nx][ny]==conv(m)){\n\t\t\t\t\t\tret+=i-1;\n\t\t\t\t\t\tif(reverse){\n\t\t\t\t\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\t\t\t\t\tmap[i][j]=conv(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic char conv(int m){\n\t\treturn m==0?'o':'x';\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tchar[][] map = new char[10][10];\n\tboolean flag = true;\n\tint[] dirx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tint[] diry = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tint[] flipx, flipy;\n\t\n\tint put(char color, int y, int x) {\n\t\tint ret = 0;\n\t\tif (map[y][x] != '.') return ret;\n\t\tfor (int i = 0; i < dirx.length; i++) {\n\t\t\tint stoneNum = checkDir(color, x, y, i);\n\t\t\tret += stoneNum;\n\t\t\tbreak;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint checkDir(char color, int x, int y, int dir) {\n\t\tchar c = map[y+diry[dir]][x+dirx[dir]];\n\t\tif (c == 0 || c == '.' || c == color) return 0;\n\t\telse {\n\t\t\tfor (int j = 2; j < dirx.length; j++) {\n\t\t\t\tc = map[y+diry[dir]*j][x+dirx[dir]*j];\n\t\t\t\tif (c == 0 || c == '.') return 0;\n\t\t\t\telse if (c == color) return j - 1;\n\t\t\t\telse continue;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tvoid flip(char color, int x, int y) {\n\t\tfor (int i = 0; i < dirx.length; i++) {\n\t\t\tint stoneNum = checkDir(color, x, y, i);\n\t\t\tfor (int k = stoneNum; k >= 0; k--) {\n\t\t\t\tmap[y+diry[i]*k][x+dirx[i]*k] = color;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tString s = in.next();\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tmap[i][j+1] = s.charAt(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max;\n\t\tint x, y;\n\t\twhile (flag) {\n\t\t\tflag = false;\n\t\t\tmax = 0;\n\t\t\tx = -1; y = -1;\n\t\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\t\tif (max < put('o', i, j)) {\n\t\t\t\t\t\ty = i; x = j;\n\t\t\t\t\t\tmax = put('o', i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max != 0) {\n\t\t\t\tflip('o', x, y);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tx = -1; y = -1;\n\t\t\tfor (int i = 8; i > 0; i--) {\n\t\t\t\tfor (int j = 8; j > 0; j--) {\n\t\t\t\t\tif (max < put('x', i, j)) {\n\t\t\t\t\t\ty = i; x = j;\n\t\t\t\t\t\tmax = put('x', i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max != 0) {\n\t\t\t\tflip('x', x, y);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int[][] map;\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        map = new int[8][8];\n        String a;\n        for (int i=0;i<8;i++) {\n            a = GetSubStringLine()[0];\n            for (int j=0;j<8;j++) {\n                switch (a.charAt(j)) {\n                    case 'o':\n                        map[i][j] = 1;\n                        break;\n                    case 'x':\n                        map[i][j] = -1;\n                        break;\n                    case '.':\n                        map[i][j] = 0;\n                        break;\n                }\n            }\n        }\n\n        int turn = 1;\n        int num;\n        int stopCnt = 0;\n        while (stopCnt < 2) {\n            int[][] numMap = new int[8][8];\n            boolean flg = false;\n            for (int i=0;i<8;i++) {\n                for (int j=0;j<8;j++) {\n                    if (map[i][j] == 0) {\n                        num = GetNum(turn, i, j);\n                        if (num > 0) {\n                            flg = true;\n                        }\n                        numMap[i][j] = num;\n                    }\n                }\n            }\n            if (flg) {\n                // ?????§??°????±???????\n                int max = 0, mY=0,mX=0;\n                if (turn == 1) {\n                    for (int i=0;i<8;i++) {\n                        for (int j=0;j<8;j++) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                } else {\n                    for (int i=7;i>=0;i--) {\n                        for (int j=7;j>=0;j--) {\n                            if (max < numMap[i][j]) {\n                                max = numMap[i][j];\n                                mY = i;\n                                mX = j;\n                            }\n                        }\n                    }\n                }\n                RevNum(turn, mY, mX);\n                map[mY][mX] = turn;\n            } else {\n                stopCnt++;\n            }\n            turn *= -1;\n        }\n        for (int i=0;i<8;i++) {\n            for (int j=0;j<8 ;j++) {\n                switch (map[i][j]) {\n                    case 1:\n                        System.out.print('o');\n                        break;\n                    case -1:\n                        System.out.print('x');\n                        break;\n                    case 0:\n                        System.out.print('.');\n                        break;\n                }\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static public int GetNum(int a, int y, int x) {\n        int sum = 0;\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    sum += GetLineNu(a, i, j, y, x);\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int GetLineNu(int a, int dy, int dx, int y, int x) {\n        int sum = 0;\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return 0;\n            }\n            if(map[y][x] == -a) {\n                sum++;\n            } else if (map[y][x] == a) {\n                return sum;\n            } else {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    static public void RevNum(int a, int y, int x) {\n        for (int i=-1;i<2;i++) {\n            for (int j=-1;j<2;j++) {\n                if (i!=0||j!=0) {\n                    RevLineNu(a, i, j, y, x);\n                }\n            }\n        }\n    }\n\n    static void RevLineNu(int a, int dy, int dx, int y, int x) {\n        y+=dy;\n        x+=dx;\n        for (int cnt=0;cnt<8;cnt++, y+=dy,x+=dx) {\n            if (y < 0 || x < 0 || y > 7 || x > 7) {\n                return;\n            }\n            if(map[y][x] == -a) {\n                map[y][x] = a;\n            } else if (map[y][x] == a) {\n                return;\n            } else {\n                return;\n            }\n        }\n        return;\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static boolean debug = true;\n\tstatic final int n = 8;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = debug ? new Scanner(System.in) : new Scanner(new File(\"L\"));\n\t\tchar[][] s = new char[n][];\n\t\tfor(int i=0; i<n; i++){\n\t\t\ts[i] = in.next().toCharArray();\n\t\t}\n\t\tdfs(s, 'o', false);\n\t\toutput(s);\n\t}\n\t\n\tstatic void output(char[][] s){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tSystem.out.println(String.valueOf(s[i]));\n\t\t}\n\t}\n\t\n//\tstatic int[][] dbg = new int[n][n];\n//\tstatic String dump(char[][] s){\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tfor(int i=0; i<n; i++){\n//\t\t\tfor(int j=0; j<n; j++){\n//\t\t\t\tif(dbg[i][j] != 0) sb.append(dbg[i][j]);\n//\t\t\t\telse sb.append(s[i][j]);\n//\t\t\t}\n//\t\t\tsb.append('\\n');\n//\t\t}\n//\t\treturn sb.toString();\n//\t}\n//\tstatic void clear(){\n//\t\tfor(int i=0; i<n; i++){\n//\t\t\tfor(int j=0; j<n; j++){\n//\t\t\t\tdbg[i][j] = 0;\n//\t\t\t}\n//\t\t}\n//\t}\n\t\n\tstatic final int[] dx = {-1, 0, 1, -1, 1, -1, 0, 1};\n\tstatic final int[] dy = {-1, -1, -1, 0, 0, 1, 1, 1};\n\tstatic void dfs(char[][] s, char c, boolean pass){\n//\t\tclear();\n\t\t\n\t\tPos p = null;\n\t\tif(c=='o'){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(s[i][j] != '.') continue;\n\t\t\t\t\tPos tmp = check(s, c, i, j);\n//\t\t\t\t\tdbg[i][j] = tmp.del;\n\t\t\t\t\tif(tmp.del > 0 && (p == null || p.del < tmp.del)){\n\t\t\t\t\t\tp = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=n-1; i>=0; i--){\n\t\t\t\tfor(int j=n-1; j>=0; j--){\n\t\t\t\t\tif(s[i][j] != '.') continue;\n\t\t\t\t\tPos tmp = check(s, c, i, j);\n//\t\t\t\t\tdbg[i][j] = tmp.del;\n\t\t\t\t\tif(tmp.del > 0 && (p == null || p.del < tmp.del)){\n\t\t\t\t\t\tp = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(dump(s));\n\t\tif(p == null){\n\t\t\tif(!pass) dfs(s, c=='o'?'x':'o', true);\n\t\t\treturn;\n\t\t}\n//\t\tSystem.out.println(p);\n\t\ts[p.y][p.x] = c;\n\t\tfor(int i=0; i<8; i++){\n\t\t\tif((p.dir&1<<i)==0) continue;\n\t\t\tint x = p.x + dx[i];\n\t\t\tint y = p.y + dy[i];\n\t\t\twhile(s[y][x] != c){\n\t\t\t\ts[y][x] = c;\n\t\t\t\ty += dy[i];\n\t\t\t\tx += dx[i];\n\t\t\t}\n\t\t}\n\t\tdfs(s, c=='o'?'x':'o', false);\n\t}\n\t\n\tstatic Pos check(char[][] s, char c, int i, int j){\n\t\tchar enm = c=='o'?'x':'o';\n\t\tint del = 0;\n\t\tint dir = 0;\n\t\tfor(int k=0; k<8; k++){\n\t\t\tint nx = j+dx[k];\n\t\t\tint ny = i+dy[k];\n\t\t\tif(out(nx, ny) || s[ny][nx] != enm) continue;\n\t\t\twhile(!out(nx, ny) && s[ny][nx] == enm){\n\t\t\t\tnx += dx[k];\n\t\t\t\tny += dy[k];\n\t\t\t}\n\t\t\tif(out(nx, ny) || s[ny][nx] != c) continue;\n\t\t\tdel += Math.max(Math.abs(i-ny), Math.abs(j-nx))-1;\n\t\t\tdir |= 1<<k;\n\t\t}\n\t\treturn new Pos(j, i, dir, del);\n\t}\n\t\n\tstatic boolean out(int x, int y){\n\t\treturn x<0 || x>=n || y<0 || y>=n;\n\t}\n}\n\nclass Pos{\n\tint x, y, dir;\n\tint del;\n\tPos(int x, int y, int dir, int del){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.dir = dir;\n\t\tthis.del = del;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[][]field;\n\tstatic char[]a={'o','x'};\n\tstatic int[]v1={-1,0,1,-1,1,-1,0,1};\n\tstatic int[]v2={-1,-1,-1,0,0,1,1,1};\n\tstatic int  turn;\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tfield=new char[8][];\n\t\tturn=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfield[i]=sc.next().toCharArray();\n\t\t}\n\t\tint pass=0;\n\t\tfor(;;){\n\t\t\t\n\t\t\tint x=0,y=0,max=0;\n\t\t\tif(turn==0){\n\t\t\t\tmax=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmax=1;\n\t\t\t}\n\t\t\tboolean isPass=true;;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tint[] put =putCount(i,j,a[turn]);\n\n\t\t\t\t\tif(put==null)continue;\n\t\t\t\t\tif(turn==0){\n\t\t\t\t\t\tif(max<put[0]){\n\t\t\t\t\t\t\tmax=put[0];\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t\tisPass=false;\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(max<=put[0]){\n\t\t\t\t\t\t\tmax=put[0];\n\t\t\t\t\t\t\tx=i;\n\t\t\t\t\t\t\ty=j;\n\t\t\t\t\t\t\tisPass=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isPass){\n\t\t\t\tput(x,y,a[turn]);\n\t\t\t\tpass=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpass++;\n\t\t\t\tif(pass==2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tturn=1-turn;\n\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(field[i][j]!='.')cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==64)break;\n//\t\t\tSystem.out.println(pass);\n//\t\t\tSystem.out.println(isPass);\n//\t\t\toutput();\n\t\t}\n\t\t\n\t\toutput();\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\t\t\n\t}\n\tstatic void put(int x,int y,char c){\n\t\tfield[x][y]=(char)c;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(xx<0||yy<0||xx>=8||yy>=8)continue;\n\t\t\tif(field[xx][yy]==a[1-turn]){\n\t\t\t\tint u=uraCount(xx,yy,c,i);\n\t\t\t\tif(u!=-1){\n\t\t\t\t\tura(xx,yy,c,i,u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic void ura(int x,int y,int c,int dir,int count){\n\t\tfor(int i=0;i<count;i++){\n\t\t\tfield[x][y]=(char)c;\n\t\t\tx+=v1[dir];\n\t\t\ty+=v2[dir];\n\t\t}\n\t}\n\tstatic int[] putCount(int x,int y,char c){\n\t\t\n\t\t// 個数、方向\n\t\tint[] re={0,0};\n\t\tif(field[x][y]!='.')return null;\n\t\tfor(int i=0;i<v1.length;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(xx<0||yy<0||xx>=8||yy>=8)continue;\n\t\t\tif(field[xx][yy]==a[1-turn]){\n\t\t\t\tint u=uraCount(xx,yy,c,i);\n\t\t\t\tif(u!=-1){\n//\t\t\t\t\tSystem.out.println(u);\n\t\t\t\t\tre[0]+=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn re;\n\t}\n\tstatic int uraCount(int x,int y,int c,int dir){\n\t\tint re=1;\n\t\tfor(;;){\n\t\t\tx+=v1[dir];\n\t\t\ty+=v2[dir];\n\t\t\tif(x<0||y<0||x>=8||y>=8)break;\n\t\t\tif(field[x][y]==c){\n\t\t\t\treturn re;\n\t\t\t}\n\t\t\telse if(field[x][y]==a[1-turn]){\n\t\t\t\tre++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] dy = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\t\tint[] dx = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\t\tchar[][] map = new char[8][8];\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tmap[i] = scanner.next().toCharArray();\n\t\tchar my, en;\n\t\tint u = 0;\n\t\tint flag = 0;\n\t\twhile (true) {\n\t\t\tif (u == 0) {\n\t\t\t\tmy = 'o';\n\t\t\t\ten = 'x';\n\t\t\t} else {\n\t\t\t\tmy = 'x';\n\t\t\t\ten = 'o';\n\t\t\t}\n\t\t\tint cnt = 0, ey = 0, ex = 0, dir = 0;\n\t\t\tfor (int y = 0; y < 8; y++)\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tint hy = u == 0 ? y : 7 - y;\n\t\t\t\t\tint hx = u == 0 ? x : 7 - x;\n\t\t\t\t\tif (map[hy][hx] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint cc = 0, ndir = 0;\n\t\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint ny = hy + dy[i] * (c + 1);\n\t\t\t\t\t\t\tint nx = hx + dx[i] * (c + 1);\n\t\t\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (map[ny][nx] == en) {\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else if (map[ny][nx] == my && c != 0) {\n\t\t\t\t\t\t\t\tcc += c;\n\t\t\t\t\t\t\t\tndir |= (1 << i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cnt >= cc)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcnt = cc;\n\t\t\t\t\tey = hy;\n\t\t\t\t\tex = hx;\n\t\t\t\t\tdir = ndir;\n\t\t\t\t}\n\t\t\tu = 1 - u;\n\t\t\tif (cnt == 0) {\n\t\t\t\tflag++;\n\t\t\t\tif (flag == 2)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tflag = 0;\n\t\t\t\tmap[ey][ex] = my;\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tif (((dir >> i) & 1) == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint k = 1;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint ny = ey + dy[i] * k;\n\t\t\t\t\t\tint nx = ex + dx[i] * k;\n\t\t\t\t\t\tif (map[ny][nx] == my)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tmap[ny][nx] = my;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor (char[] ans : map)\n\t\t\tSystem.out.println(ans);\n\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < 8 && 0 <= nx && nx < 8;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint[][] grid = new int[8][8];// oなら1、xなら-1を入れておく\n\t\tint[] dir = { -1, 0, 1 };\n\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tString line = scanner.next();\n\t\t\tfor (int j = 0; j < grid[i].length; j++) {\n\t\t\t\tchar piece = line.charAt(j);\n\t\t\t\tif (piece == 'o') {\n\t\t\t\t\tgrid[i][j] = 1;\n\t\t\t\t} else if (piece == 'x') {\n\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint turn = 0;\n\t\tint pass = 0;\n\t\twhile (pass < 2) {\n\t\t\tint max = 0;\n\t\t\tint x = -1;\n\t\t\tint y = -1;\n\t\t\tint me = 1;\n\t\t\tif (turn % 2 == 1) {\n\t\t\t\tme = -1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\t\tfor (int j = 0; j < grid[i].length; j++) {\n\t\t\t\t\tint gain = 0;\n\t\t\t\t\tint pi = i;\n\t\t\t\t\tint pj = j;\n\t\t\t\t\tif (turn % 2 == 1) {\n\t\t\t\t\t\tpi = 7 - i;\n\t\t\t\t\t\tpj = 7 - j;\n\t\t\t\t\t}\n\t\t\t\t\tif (grid[pi][pj] != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int d1 = 0; d1 < dir.length; d1++) {\n\t\t\t\t\t\tfor (int d2 = 0; d2 < dir.length; d2++) {\n\t\t\t\t\t\t\tif (dir[d1] == 0 && dir[d2] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint distance = 1;\n\t\t\t\t\t\t\twhile (pi + dir[d1] * distance >= 0\n\t\t\t\t\t\t\t\t\t&& pi + dir[d1] * distance < 8\n\t\t\t\t\t\t\t\t\t&& pj + dir[d2] * distance >= 0\n\t\t\t\t\t\t\t\t\t&& pj + dir[d2] * distance < 8) {\n\t\t\t\t\t\t\t\tif (grid[pi + dir[d1] * distance][pj + dir[d2]\n\t\t\t\t\t\t\t\t\t\t* distance] == -1 * me) {\n\t\t\t\t\t\t\t\t\tdistance++;\n\t\t\t\t\t\t\t\t} else if (grid[pi + dir[d1] * distance][pj\n\t\t\t\t\t\t\t\t\t\t+ dir[d2] * distance] == me) {\n\t\t\t\t\t\t\t\t\tgain += distance - 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < gain) {\n\t\t\t\t\t\tmax = gain;\n\t\t\t\t\t\tx = pi;\n\t\t\t\t\t\ty = pj;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (x != -1) {\n\t\t\t\tpass = 0;\n\t\t\t\tgrid[x][y] = me;\n\t\t\t\tfor (int d1 = 0; d1 < dir.length; d1++) {\n\t\t\t\t\tfor (int d2 = 0; d2 < dir.length; d2++) {\n\t\t\t\t\t\tif (dir[d1] == 0 && dir[d2] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint distance = 1;\n\t\t\t\t\t\twhile (x + dir[d1] * distance >= 0\n\t\t\t\t\t\t\t\t&& x + dir[d1] * distance < 8\n\t\t\t\t\t\t\t\t&& y + dir[d2] * distance >= 0\n\t\t\t\t\t\t\t\t&& y + dir[d2] * distance < 8) {\n\t\t\t\t\t\t\tif (grid[x + dir[d1] * distance][y + dir[d2]\n\t\t\t\t\t\t\t\t\t* distance] == -1 * me) {\n\t\t\t\t\t\t\t\tdistance++;\n\t\t\t\t\t\t\t} else if (grid[x + dir[d1] * distance][y + dir[d2]\n\t\t\t\t\t\t\t\t\t* distance] == me) {\n\t\t\t\t\t\t\t\tfor (int dist = 1; dist < distance; dist++) {\n\t\t\t\t\t\t\t\t\tgrid[x + dir[d1] * dist][y + dir[d2] * dist] = me;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpass++;\n\t\t\t}\n\t\t\tturn++;\n\t\t}\n\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tfor (int j = 0; j < grid[i].length; j++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tSystem.out.print(\"o\");\n\t\t\t\t} else if (grid[i][j] == -1) {\n\t\t\t\t\tSystem.out.print(\"x\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Dessert_Witch\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Field field = new Field();\n            for (int i = 0; i < Field.SIZE; i++)\n            {\n                char[] fieldChars = Console.ReadLine().ToCharArray();\n                for (int j = 0; j < Field.SIZE; j++)\n                {\n                    if (fieldChars[j] == '.') field.SetCookie(j, i, Cookie.None);\n                    if (fieldChars[j] == 'o') field.SetCookie(j, i, Cookie.Choco);\n                    if (fieldChars[j] == 'x') field.SetCookie(j, i, Cookie.Cheese);\n                }\n            }\n\n            Game game = new Game(field);\n            game.Play();\n            game.Disp();\n        }\n    }\n}\n\n    public class Game\n    {\n        private Field field;\n        private int[] rotateX = new int[] { 0, 1, 1, 1, 0, -1, -1, -1};\n        private int[] rotateY = new int[] { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n        public Game(Field field)\n        {\n            this.field = field;\n        }\n\n\n        public void Play()\n        {\n            Player mami = new Mami();\n            Player charlotte = new Charlotte();\n            while (true){\n                bool mamiPlayable = Play(mami);\n                bool charlottePlayable = Play(charlotte);\n                if (!mamiPlayable && !charlottePlayable) break;\n            }\n        }\n\n        public void Disp()\n        {\n            Console.Write(field.Disp());\n            Console.WriteLine();\n        }\n\n\n        private bool Play(Player player)\n        {\n            // クッキーを置く位置を決定\n            Point point = player.Decide(field);\n\n            // 位置が決定できなかったので終了\n            if (point == null) return false;\n\n            field.SetCookie(point.X, point.Y, player.GetMyCookie());\n\n            for (int way = 0; way < rotateX.Length; way++)\n            {\n                int count = 1;\n                bool isBetween = false;\n                for (int i = 1; i < Field.SIZE; i++)\n                {\n                    Cookie cookie = field.GetCookie(point.X + (rotateX[way] * i), point.Y + (rotateY[way] * i));\n                    if (cookie == Cookie.None) break;\n                    if (cookie == player.GetMyCookie())\n                    {\n                        isBetween = true;\n                        break;\n                    }\n                    else count++;\n                }\n                if (!isBetween) continue;\n               \n                for (int i = 1; i < count; i++)\n                {\n                    field.SetCookie(point.X + (rotateX[way] * i), point.Y + (rotateY[way] * i), player.GetMyCookie());\n                }                \n            }\n            return true;\n        }\n    }\n\n    public enum Cookie\n    {\n        None,\n        Choco,\n        Cheese\n    }\n\n    public class Field\n    {\n        public const int SIZE = 8;\n\n        private Cookie[,] field;\n\n        public Field()\n        {\n            field = new Cookie[SIZE, SIZE];\n            for (int i = 0; i < SIZE; i++)\n            {\n                for (int j = 0; j < SIZE; j++)\n                {\n                    field[i, j] = Cookie.None;\n                }\n            }\n        }\n\n        public void SetCookie(int x, int y, Cookie cookie)\n        {\n            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;\n            field[x, y] = cookie;\n        }\n\n        public Cookie GetCookie(int x, int y)\n        {\n            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return Cookie.None;\n            return field[x, y];\n        }\n\n        public String Disp()\n        {\n            string str = \"\";\n            for (int y = 0; y < SIZE; y++)\n            {\n                for (int x = 0; x < SIZE; x++)\n                {\n                    if (field[x, y] == Cookie.None) str += \".\";\n                    if (field[x, y] == Cookie.Cheese) str += \"x\";\n                    if (field[x, y] == Cookie.Choco) str += \"o\";\n                }\n                str += \"\\n\";\n            }\n            return str;\n        }\n        \n    }\n\n    public class Point\n    {\n\n        public int X { get; private set; }\n\n        public int Y { get; private set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    public abstract class Player\n    {\n\n        private int[] rotateX = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        private int[] rotateY = new int[] { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n        public abstract Cookie GetMyCookie();\n\n        public Point Decide(Field field)\n        {\n            // 盤面の評価\n\n            int[,] evalField = new int[Field.SIZE, Field.SIZE];\n\n            for (int i = 0; i < Field.SIZE; i++)\n            {\n                for (int j = 0; j < Field.SIZE; j++)\n                {\n                    evalField[i, j] = GetEval(field, i, j);\n                }\n            }\n            return GetDecidePoint(evalField);\n        }\n\n        private int GetEval(Field field, int x, int y)\n        {\n            // クッキーがすでにある場合、クッキーを置けないので評価値は0\n            if (field.GetCookie(x, y) != Cookie.None) return 0;\n\n            int eval = 0;\n            for (int i = 0; i < rotateX.Length; i++)\n            {\n                int count = 0;\n                for (int j = 1; j < Field.SIZE; j++)\n                {\n                    Cookie cookie = field.GetCookie(x + (rotateX[i] * j), y + (rotateY[i] * j));\n                    if (cookie == Cookie.None) break;\n                    if (cookie == GetMyCookie())\n                    {\n                        eval += count;\n                        break;\n                    }\n                    if (cookie != GetMyCookie()) count++;\n                }\n            }\n            return eval;\n        }\n\n        private Point GetDecidePoint(int[,] evalField)\n        {\n            Point maxPoint = null;\n            int maxEval = 0;\n \n            for (int y = 0; y < Field.SIZE; y++)\n            {\n                for (int x = 0; x < Field.SIZE; x++)\n                {\n                    if (evalField[x, y] == 0) continue;\n                    if (maxEval < evalField[x, y])\n                    {\n                        maxEval = evalField[x, y];\n                        maxPoint = new Point(x, y);\n                    }\n                    if (maxEval == evalField[x, y])\n                    {\n                        maxPoint = OnDecide(maxPoint, new Point(x, y));\n                    }\n                }\n            }\n            return maxPoint;\n        }\n\n        protected abstract Point OnDecide(Point a, Point b);\n    }\n\n    public class Mami : Player\n    {\n        public override Cookie GetMyCookie()\n        {\n            return Cookie.Choco;\n        }\n\n        protected override Point OnDecide(Point a, Point b)\n        {\n            /*\n             * 同じ評価の場合、マミさんは上の場所、それでもダメなら左の場所\n             */\n            if (a.Y < b.Y) return a;\n            else if (a.Y > b.Y) return b;\n            else\n            {\n                if (a.X < b.X) return a;\n                else return b;\n            }\n        }\n    }\n\n    public class Charlotte : Player\n    {\n        public override Cookie GetMyCookie()\n        {\n            return Cookie.Cheese;\n        }\n\n        protected override Point OnDecide(Point a, Point b)\n        {\n            /*\n             * 同じ評価の場合、シャルロッテは下の場所、それでもダメなら右の場所\n             */\n            if (a.Y > b.Y) return a;\n            else if (a.Y < b.Y) return b;\n            else\n            {\n                if (a.X > b.X) return a;\n                else return b;\n            }\n        }\n    }"
  },
  {
    "language": "C#",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };\nchar c[8][9];\nint place(int x, int y, char t, bool m) {\n\tint ret = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint px = x + dx[i], py = y + dy[i];\n\t\tbool flag = false;\n\t\twhile (0 <= px && px < 8 && 0 <= py && py < 8) {\n\t\t\tif (c[py][px] == '.') break;\n\t\t\tif (c[py][px] == t) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tpx += dx[i];\n\t\t\tpy += dy[i];\n\t\t}\n\t\tif (flag) {\n\t\t\tret += max(abs(x - px) - 1, abs(y - py) - 1);\n\t\t\tif (m) {\n\t\t\t\tint qx = x, qy = y;\n\t\t\t\twhile (qx != px || qy != py) {\n\t\t\t\t\tc[qy][qx] = t;\n\t\t\t\t\tqx += dx[i];\n\t\t\t\t\tqy += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tfor (int i = 0; i < 8; i++) scanf(\"%s\", &c[i]);\n\tint t = 0, v = 0;\n\twhile (true) {\n\t\tint x = -1, y = -1, r = 0;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\tint p = place(j, i, t % 2 == 0 ? 'o' : 'x', false);\n\t\t\t\t\tif (t % 2 == 1) {\n\t\t\t\t\t\tif (p >= r && p >= 1) {\n\t\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (p > r && p >= 1) {\n\t\t\t\t\t\t\tx = j; y = i; r = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (v == 0) {\n\t\t\t\tv = 1; t++; continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tplace(x, y, t++ % 2 == 0 ? 'o' : 'x', true); v = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < 8; i++) printf(\"%s\\n\", c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C#",
    "code": "//#define READ_FILE72\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nusing CHY72;\n\n\n\nnamespace CHY72{\n    \n    //class は参照型。Arrayも。structにしないのは、Stackに積んだときとかのため。\n    public class PointXY{\n        public int X , Y;\n        public int SQLength() { return X * X + Y * Y; }\n        public bool Flag = false;\n        public int ID = -1;\n        public PointXY(int _X,int _Y,int _ID = 0) {\n            X = _X; Y = _Y; ID = _ID;\n        }\n        public PointXY(PointXY P1, int _X = 0, int _Y = 0,int _ID = -1) {\n            X = P1.X + _X; Y = P1.Y + _Y; ID = _ID;\n        }\n        public static bool operator ==(PointXY P1, PointXY P2) {\n            return (P1.X== P2.X && P1.Y == P2.Y);\n        }\n        public static bool operator !=(PointXY P1, PointXY P2) {return !(P1 ==P2);}\n        public override int GetHashCode() {return X.GetHashCode() ^ Y.GetHashCode();}\n        public override bool Equals(object obj) {\n            if (obj == null || this.GetType() != obj.GetType()) {return false;}\n            return (this == (PointXY)obj);\n        }\n        public string CurrentInformation() {\n            return \"x:\" + X + \"  y:\" + Y + \"  ID:\" + ID;\n        } \n\n    }\n\n    public class Lib72 {\n        public static T[][] CopyJagArray2<T>(T[][] _Base){\n            T[][] NewArray = new T[_Base.Length][];\n            for (int i = 0; i < _Base.Length; i++) {\n                NewArray[i] = new T[_Base[i].Length ];\n                for (int j = 0; j < _Base[i].Length; j++) {\n                    NewArray[i][j] = _Base[i][j];\n                }\n            }\n            return NewArray;\n        }\n\n        public static bool isInRect(int _X, int _Y, int _W, int _H) { return (_X >= 0 && _Y >= 0 && _X < _W && _Y < _H); }\n        public static int NumFromChar(char CNUM) { return CNUM - 48; }\n        public static char LoopChar52(char _C, int n) {\n            //Char(C#) uses Uni-Code\n            //33 !  \"#$%&'(  41 )\n            //42 * +,-.  47/\n            //48 0  .... 57 9\n            //58 :;<=>? 64 @\n            //65 A .... 90 Z\n            //91 [\\]^_ 96`\n            //97 a .... 122 z\n            int i_C = (int)_C;\n            if (i_C > 64 && i_C < 91) i_C -= 65;//0~25 AZ\n            else if (i_C > 96 && i_C < 123) i_C -= 71;//26~51 az\n            else return '0';\n            int RESULT = Modulo ((i_C + n ) , 52);\n            if(RESULT < 26) return (char)(RESULT+65);\n            else return (char)(RESULT + 71);\n        }\n        public static int Modulo(int A, int B)  {\n            // -6 % 5 == -1\n            // -6 % 5 == 4\n            int Result = A % B;\n            if (Result >= 0) { return Result; }\n            else return Result + B;\n        }\n        public static int intFromHourMinSec(int _h,int _m,int _s) {\n            return _s + 60 * _m + 3600 * _h;\n        }\n\n        public static int[] KETAArray(int Num) {return KETAArray(Num.ToString()); }\n        public static int[] KETAArray(string Num) {\n            char[] cKETA = Num.ToCharArray();\n            int[] iKETA = new int[cKETA.Length];\n            for (int i = 0; i < iKETA.Length; i++) {\n                iKETA[i] = NumFromChar(cKETA[i]);\n            }\n            return iKETA;\n        }\n        public static int KETA(int Num) { return Num.ToString().ToCharArray().Length; }\n        public static int FromKETAArray(int[] _ketaarray) {\n            int result = 0;\n            int[] R_ketaarray = _ketaarray.Reverse().ToArray(); \n            for (int i = 0,j=1; i < R_ketaarray.Length; i++,j *=10) {\n                result += j * R_ketaarray[i];\n            }\n            return result;\n        }\n        public static bool isPrime(int p) {\n            if (p != 2 && p % 2 == 0) return false;\n            if (p == 1) return false;\n            int SQp = (int)(Math.Sqrt(p));\n            for (int i = 3; i <= SQp; i++) {\n                if (p % i == 0) return false;\n            }\n            return true;\n        } \n    }\n}    \n\npublic class Program {\n    static bool ReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int  ReadLine_1() {\n        return  int.Parse(Console.ReadLine());\n    }\n    static bool ReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true,int FinNum =0) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] ReadLine_Array(char Spliter = ' ') {\n        return Console.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n\n#if READ_FILE72\n    static bool FileReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int FileReadLine_1() {\n        return int.Parse(cReader.ReadLine());\n    }\n    static bool FileReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true, int FinNum = 0) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] FileReadLine_Array(char Spliter = ' ') {\n        return cReader.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n    \n    static System.IO.StreamReader cReader ;\n#endif\n\n    const int DefaultMax = 72727272;\n\n\n    static void Main(string[] args) {\n        #if READ_FILE72  \n            cReader = new System.IO.StreamReader(System.IO.Directory.GetCurrentDirectory() + \"\\\\Read.txt\", System.Text.Encoding.Unicode);\n        #endif\n\n        Main72();\n\n        #if READ_FILE72\n            cReader.Close();\n        #endif\n    }\n\n    // Me o ┌ :: !Me x　┘\n    static int Reverse_1(int x, int y, int Nx, int Ny, ref char[][] _Map, bool isMe) {\n        bool CanReverse = false;\n        int ReversedNum = 0;\n        for (int i = 1; i < 8; i++) {\n            PointXY NextXY = new PointXY(x + Nx * i, y + Ny * i);\n            if (Lib72.isInRect(NextXY.X, NextXY.Y, 8, 8)) {\n                if (!CanReverse) {\n                    if (_Map[NextXY.X][NextXY.Y] == '.') break;\n                    else if (i == 1 && isMe && _Map[NextXY.X][NextXY.Y] == 'o') break;\n                    else if (i == 1 && !isMe && _Map[NextXY.X][NextXY.Y] == 'x') break;\n                    else if (isMe && _Map[NextXY.X][NextXY.Y] == 'o') { CanReverse = true; i = 0; }\n                    else if (!isMe && _Map[NextXY.X][NextXY.Y] == 'x') { CanReverse = true; i = 0; }\n                }\n                else {\n                    if (isMe && _Map[NextXY.X][NextXY.Y] == 'o') { break; }\n                    else if (!isMe && _Map[NextXY.X][NextXY.Y] == 'x') { break; }\n                    else if (isMe) { _Map[NextXY.X][NextXY.Y] = 'o'; ReversedNum++; }\n                    else if (!isMe) { _Map[NextXY.X][NextXY.Y] = 'x'; ReversedNum++; }\n                }\n            }\n            else break;\n        }\n        return ReversedNum;\n    }\n\n    static int Reverse(int x, int y,ref char[][] _Map, bool isMe) {\n        int RESULT = 0;\n        RESULT += Reverse_1(x,y,0,1,ref _Map ,isMe);\n        RESULT += Reverse_1(x, y, 0, -1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, 1, 0, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, -1, 0, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, 1, 1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, 1, -1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, -1, 1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, -1, -1, ref _Map, isMe);\n\n        return RESULT;\n    }\n\n    static int HowManyReverceable(int x,int y,char[][] _Map,bool isMe) {\n        if (_Map[x][y] == '.') {\n            return Reverse(x, y, ref _Map, isMe);\n        }else return 0;\n    }\n\n    static void Main72() {\n        char[][] Map = new char[8][]; \n        for(int i = 0; i < 8 ; i ++){\n            Map[i] = Console.ReadLine().ToCharArray(); \n        }\n        for (int i = 0; i < 8 * 8; i++) {\n            \n            int MaxReverse = 0;\n            PointXY RevPos = new PointXY(-1,-1);\n            if (i % 2 == 0) {//Me\n                for (int x = 7; x >= 0; x--) {\n                    for (int y = 7; y >= 0; y--) {\n                        int HowMany = HowManyReverceable(x, y,Lib72.CopyJagArray2(Map) , true);\n                        if (HowMany!=0 && HowMany >= MaxReverse  ) {\n                            RevPos = new PointXY(x,y);\n                            MaxReverse = HowMany;\n                        }\n                    }\n                }\n            }else {//!Me\n                for (int x = 0; x < 8; x++) {\n                    for (int y = 0;y < 8; y++) {\n                        int HowMany = HowManyReverceable(x, y, Lib72.CopyJagArray2(Map), false);\n                        if (HowMany != 0 && HowMany >= MaxReverse) {\n                            RevPos = new PointXY(x, y);\n                            MaxReverse = HowMany;\n                        }\n                    }\n                }\n            }\n            if (RevPos != new PointXY(-1, -1)) {\n                Reverse(RevPos.X, RevPos.Y, ref Map, (i % 2 == 0));\n                Map[RevPos.X][RevPos.Y] = ((i % 2 == 0) ? 'o' : 'x');\n            }\n            //for (int G = 0; G < 8; G++) { Console.WriteLine(Map[G]); }\n            //Console.WriteLine(RevPos.CurrentInformation ());\n            //Console.ReadLine();\n        }\n\n        for (int G = 0; G < 8; G++) { Console.WriteLine(Map[G]); }\n        //Console.ReadLine();\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Dessert_Witch\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Field field = new Field();\n            for (int i = 0; i < Field.SIZE; i++)\n            {\n                char[] fieldChars = Console.ReadLine().ToCharArray();\n                for (int j = 0; j < Field.SIZE; j++)\n                {\n                    if (fieldChars[j] == '.') field.SetCookie(j, i, Cookie.None);\n                    if (fieldChars[j] == 'o') field.SetCookie(j, i, Cookie.Choco);\n                    if (fieldChars[j] == 'x') field.SetCookie(j, i, Cookie.Cheese);\n                }\n            }\n\n            Game game = new Game(field);\n            game.Play();\n            game.Disp();\n        }\n    }\n}\n\n    public class Game\n    {\n        private Field field;\n        private int[] rotateX = new int[] { 0, 1, 1, 1, 0, -1, -1, -1};\n        private int[] rotateY = new int[] { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n        public Game(Field field)\n        {\n            this.field = field;\n        }\n\n\n        public void Play()\n        {\n            Player mami = new Mami();\n            Player charlotte = new Charlotte();\n            while (true){\n                bool mamiPlayable = Play(mami);\n                bool charlottePlayable = Play(charlotte);\n                if (!mamiPlayable && !charlottePlayable) break;\n            }\n        }\n\n        public void Disp()\n        {\n            Console.Write(field.Disp());\n        }\n\n\n        private bool Play(Player player)\n        {\n            // クッキーを置く位置を決定\n            Point point = player.Decide(field);\n\n            // 位置が決定できなかったので終了\n            if (point == null) return false;\n\n            field.SetCookie(point.X, point.Y, player.GetMyCookie());\n\n            for (int way = 0; way < rotateX.Length; way++)\n            {\n                int count = 1;\n                bool isBetween = false;\n                for (int i = 1; i < Field.SIZE; i++)\n                {\n                    Cookie cookie = field.GetCookie(point.X + (rotateX[way] * i), point.Y + (rotateY[way] * i));\n                    if (cookie == Cookie.None) break;\n                    if (cookie == player.GetMyCookie())\n                    {\n                        isBetween = true;\n                        break;\n                    }\n                    else count++;\n                }\n                if (!isBetween) continue;\n               \n                for (int i = 1; i < count; i++)\n                {\n                    field.SetCookie(point.X + (rotateX[way] * i), point.Y + (rotateY[way] * i), player.GetMyCookie());\n                }                \n            }\n            return true;\n        }\n    }\n\n    public enum Cookie\n    {\n        None,\n        Choco,\n        Cheese\n    }\n\n    public class Field\n    {\n        public const int SIZE = 8;\n\n        private Cookie[,] field;\n\n        public Field()\n        {\n            field = new Cookie[SIZE, SIZE];\n            for (int i = 0; i < SIZE; i++)\n            {\n                for (int j = 0; j < SIZE; j++)\n                {\n                    field[i, j] = Cookie.None;\n                }\n            }\n        }\n\n        public void SetCookie(int x, int y, Cookie cookie)\n        {\n            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;\n            field[x, y] = cookie;\n        }\n\n        public Cookie GetCookie(int x, int y)\n        {\n            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return Cookie.None;\n            return field[x, y];\n        }\n\n        public String Disp()\n        {\n            string str = \"\";\n            for (int y = 0; y < SIZE; y++)\n            {\n                for (int x = 0; x < SIZE; x++)\n                {\n                    if (field[x, y] == Cookie.None) str += \".\";\n                    if (field[x, y] == Cookie.Cheese) str += \"x\";\n                    if (field[x, y] == Cookie.Choco) str += \"o\";\n                }\n                str += \"\\n\";\n            }\n            return str;\n        }\n        \n    }\n\n    public class Point\n    {\n\n        public int X { get; private set; }\n\n        public int Y { get; private set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    public abstract class Player\n    {\n\n        private int[] rotateX = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        private int[] rotateY = new int[] { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n        public abstract Cookie GetMyCookie();\n\n        public Point Decide(Field field)\n        {\n            // 盤面の評価\n\n            int[,] evalField = new int[Field.SIZE, Field.SIZE];\n\n            for (int i = 0; i < Field.SIZE; i++)\n            {\n                for (int j = 0; j < Field.SIZE; j++)\n                {\n                    evalField[i, j] = GetEval(field, i, j);\n                }\n            }\n            return GetDecidePoint(evalField);\n        }\n\n        private int GetEval(Field field, int x, int y)\n        {\n            // クッキーがすでにある場合、クッキーを置けないので評価値は0\n            if (field.GetCookie(x, y) != Cookie.None) return 0;\n\n            int eval = 0;\n            for (int i = 0; i < rotateX.Length; i++)\n            {\n                int count = 0;\n                for (int j = 1; j < Field.SIZE; j++)\n                {\n                    Cookie cookie = field.GetCookie(x + (rotateX[i] * j), y + (rotateY[i] * j));\n                    if (cookie == Cookie.None) break;\n                    if (cookie == GetMyCookie())\n                    {\n                        eval += count;\n                        break;\n                    }\n                    if (cookie != GetMyCookie()) count++;\n                }\n            }\n            return eval;\n        }\n\n        private Point GetDecidePoint(int[,] evalField)\n        {\n            Point maxPoint = null;\n            int maxEval = 0;\n \n            for (int y = 0; y < Field.SIZE; y++)\n            {\n                for (int x = 0; x < Field.SIZE; x++)\n                {\n                    if (evalField[x, y] == 0) continue;\n                    if (maxEval < evalField[x, y])\n                    {\n                        maxEval = evalField[x, y];\n                        maxPoint = new Point(x, y);\n                    }\n                    if (maxEval == evalField[x, y])\n                    {\n                        maxPoint = OnDecide(maxPoint, new Point(x, y));\n                    }\n                }\n            }\n            return maxPoint;\n        }\n\n        protected abstract Point OnDecide(Point a, Point b);\n    }\n\n    public class Mami : Player\n    {\n        public override Cookie GetMyCookie()\n        {\n            return Cookie.Choco;\n        }\n\n        protected override Point OnDecide(Point a, Point b)\n        {\n            /*\n             * 同じ評価の場合、マミさんは上の場所、それでもダメなら左の場所\n             */\n            if (a.Y < b.Y) return a;\n            else if (a.Y > b.Y) return b;\n            else\n            {\n                if (a.X < b.X) return a;\n                else return b;\n            }\n        }\n    }\n\n    public class Charlotte : Player\n    {\n        public override Cookie GetMyCookie()\n        {\n            return Cookie.Cheese;\n        }\n\n        protected override Point OnDecide(Point a, Point b)\n        {\n            /*\n             * 同じ評価の場合、シャルロッテは下の場所、それでもダメなら右の場所\n             */\n            if (a.Y > b.Y) return a;\n            else if (a.Y < b.Y) return b;\n            else\n            {\n                if (a.X > b.X) return a;\n                else return b;\n            }\n        }\n    }"
  },
  {
    "language": "C#",
    "code": "//#define READ_FILE72\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nusing CHY72;\n\n\n\nnamespace CHY72{\n    \n    //class は参照型。Arrayも。structにしないのは、Stackに積んだときとかのため。\n    public class PointXY{\n        public int X , Y;\n        public int SQLength() { return X * X + Y * Y; }\n        public bool Flag = false;\n        public int ID = -1;\n        public PointXY(int _X,int _Y,int _ID = 0) {\n            X = _X; Y = _Y; ID = _ID;\n        }\n        public PointXY(PointXY P1, int _X = 0, int _Y = 0,int _ID = -1) {\n            X = P1.X + _X; Y = P1.Y + _Y; ID = _ID;\n        }\n        public static bool operator ==(PointXY P1, PointXY P2) {\n            return (P1.X== P2.X && P1.Y == P2.Y);\n        }\n        public static bool operator !=(PointXY P1, PointXY P2) {return !(P1 ==P2);}\n        public override int GetHashCode() {return X.GetHashCode() ^ Y.GetHashCode();}\n        public override bool Equals(object obj) {\n            if (obj == null || this.GetType() != obj.GetType()) {return false;}\n            return (this == (PointXY)obj);\n        }\n        public string CurrentInformation() {\n            return \"x:\" + X + \"  y:\" + Y + \"  ID:\" + ID;\n        } \n\n    }\n\n    public class Lib72 {\n        public static T[][] CopyJagArray2<T>(T[][] _Base){\n            T[][] NewArray = new T[_Base.Length][];\n            for (int i = 0; i < _Base.Length; i++) {\n                NewArray[i] = new T[_Base[i].Length ];\n                for (int j = 0; j < _Base[i].Length; j++) {\n                    NewArray[i][j] = _Base[i][j];\n                }\n            }\n            return NewArray;\n        }\n\n        public static bool isInRect(int _X, int _Y, int _W, int _H) { return (_X >= 0 && _Y >= 0 && _X < _W && _Y < _H); }\n        public static int NumFromChar(char CNUM) { return CNUM - 48; }\n        public static char LoopChar52(char _C, int n) {\n            //Char(C#) uses Uni-Code\n            //33 !  \"#$%&'(  41 )\n            //42 * +,-.  47/\n            //48 0  .... 57 9\n            //58 :;<=>? 64 @\n            //65 A .... 90 Z\n            //91 [\\]^_ 96`\n            //97 a .... 122 z\n            int i_C = (int)_C;\n            if (i_C > 64 && i_C < 91) i_C -= 65;//0~25 AZ\n            else if (i_C > 96 && i_C < 123) i_C -= 71;//26~51 az\n            else return '0';\n            int RESULT = Modulo ((i_C + n ) , 52);\n            if(RESULT < 26) return (char)(RESULT+65);\n            else return (char)(RESULT + 71);\n        }\n        public static int Modulo(int A, int B)  {\n            // -6 % 5 == -1\n            // -6 % 5 == 4\n            int Result = A % B;\n            if (Result >= 0) { return Result; }\n            else return Result + B;\n        }\n        public static int intFromHourMinSec(int _h,int _m,int _s) {\n            return _s + 60 * _m + 3600 * _h;\n        }\n\n        public static int[] KETAArray(int Num) {return KETAArray(Num.ToString()); }\n        public static int[] KETAArray(string Num) {\n            char[] cKETA = Num.ToCharArray();\n            int[] iKETA = new int[cKETA.Length];\n            for (int i = 0; i < iKETA.Length; i++) {\n                iKETA[i] = NumFromChar(cKETA[i]);\n            }\n            return iKETA;\n        }\n        public static int KETA(int Num) { return Num.ToString().ToCharArray().Length; }\n        public static int FromKETAArray(int[] _ketaarray) {\n            int result = 0;\n            int[] R_ketaarray = _ketaarray.Reverse().ToArray(); \n            for (int i = 0,j=1; i < R_ketaarray.Length; i++,j *=10) {\n                result += j * R_ketaarray[i];\n            }\n            return result;\n        }\n        public static bool isPrime(int p) {\n            if (p != 2 && p % 2 == 0) return false;\n            if (p == 1) return false;\n            int SQp = (int)(Math.Sqrt(p));\n            for (int i = 3; i <= SQp; i++) {\n                if (p % i == 0) return false;\n            }\n            return true;\n        } \n    }\n}    \n\npublic class Program {\n    static bool ReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int  ReadLine_1() {\n        return  int.Parse(Console.ReadLine());\n    }\n    static bool ReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true,int FinNum =0) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] ReadLine_Array(char Spliter = ' ') {\n        return Console.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n\n#if READ_FILE72\n    static bool FileReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int FileReadLine_1() {\n        return int.Parse(cReader.ReadLine());\n    }\n    static bool FileReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true, int FinNum = 0) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] FileReadLine_Array(char Spliter = ' ') {\n        return cReader.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n    \n    static System.IO.StreamReader cReader ;\n#endif\n\n    const int DefaultMax = 72727272;\n\n\n    static void Main(string[] args) {\n        #if READ_FILE72  \n            cReader = new System.IO.StreamReader(System.IO.Directory.GetCurrentDirectory() + \"\\\\Read.txt\", System.Text.Encoding.Unicode);\n        #endif\n\n        Main72();\n\n        #if READ_FILE72\n            cReader.Close();\n        #endif\n    }\n\n    // Me o ┌ :: !Me x　┘\n    static int Reverse_1(int x, int y, int Nx, int Ny, ref char[][] _Map, bool isMe) {\n        bool CanReverse = false;\n        int ReversedNum = 0;\n        for (int i = 1; i < 8; i++) {\n            PointXY NextXY = new PointXY(x + Nx * i, y + Ny * i);\n            if (Lib72.isInRect(NextXY.X, NextXY.Y, 8, 8)) {\n                if (!CanReverse) {\n                    if (_Map[NextXY.X][NextXY.Y] == '.') break;\n                    else if (i == 1 && isMe && _Map[NextXY.X][NextXY.Y] == 'o') break;\n                    else if (i == 1 && !isMe && _Map[NextXY.X][NextXY.Y] == 'x') break;\n                    else if (isMe && _Map[NextXY.X][NextXY.Y] == 'o') { CanReverse = true; i = 0; }\n                    else if (!isMe && _Map[NextXY.X][NextXY.Y] == 'x') { CanReverse = true; i = 0; }\n                }\n                else {\n                    if (isMe && _Map[NextXY.X][NextXY.Y] == 'o') { break; }\n                    else if (!isMe && _Map[NextXY.X][NextXY.Y] == 'x') { break; }\n                    else if (isMe) { _Map[NextXY.X][NextXY.Y] = 'o'; ReversedNum++; }\n                    else if (!isMe) { _Map[NextXY.X][NextXY.Y] = 'x'; ReversedNum++; }\n                }\n            }\n            else break;\n        }\n        return ReversedNum;\n    }\n\n    static int Reverse(int x, int y,ref char[][] _Map, bool isMe) {\n        int RESULT = 0;\n        RESULT += Reverse_1(x,y,0,1,ref _Map ,isMe);\n        RESULT += Reverse_1(x, y, 0, -1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, 1, 0, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, -1, 0, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, 1, 1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, 1, -1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, -1, 1, ref _Map, isMe);\n        RESULT += Reverse_1(x, y, -1, -1, ref _Map, isMe);\n\n        return RESULT;\n    }\n\n    static int HowManyReverceable(int x,int y,char[][] _Map,bool isMe) {\n        if (_Map[x][y] == '.') {\n            return Reverse(x, y, ref _Map, isMe);\n        }else return 0;\n    }\n\n    static void Main72() {\n        char[][] Map = new char[8][]; \n        for(int i = 0; i < 8 ; i ++){\n            Map[i] = Console.ReadLine().ToCharArray(); \n        }\n        for (int i = 0; i < 8 * 8; i++) {\n            \n            int MaxReverse = 0;\n            PointXY RevPos = new PointXY(-1,-1);\n            if (i % 2 == 0) {//Me\n                for (int y = 7; y >= 0; y--) {\n                    for (int x = 7; x >= 0; x--) {\n                        int HowMany = HowManyReverceable(x, y,Lib72.CopyJagArray2(Map) , true);\n                        if (HowMany!=0 && HowMany >= MaxReverse  ) {\n                            RevPos = new PointXY(x,y);\n                        }\n                    }\n                }\n            }else {//!Me\n                for (int y = 0; y < 8; y++) {\n                    for (int x = 0; x < 8; x++) {\n                        int HowMany = HowManyReverceable(x, y, Lib72.CopyJagArray2(Map), false);\n                        if (HowMany != 0 && HowMany >= MaxReverse) {\n                            RevPos = new PointXY(x, y);\n                        }\n                    }\n                }\n            }\n            if (RevPos != new PointXY(-1, -1)) {\n                Reverse(RevPos.X, RevPos.Y, ref Map, (i % 2 == 0));\n                Map[RevPos.X][RevPos.Y] = ((i % 2 == 0) ? 'o' : 'x');\n            }\n        }\n        for (int G = 0; G < 8; G++) { Console.WriteLine(Map[G]); }\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Dessert_Witch\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Field field = new Field();\n            for (int i = 0; i < Field.SIZE; i++)\n            {\n                char[] fieldChars = Console.ReadLine().ToCharArray();\n                for (int j = 0; j < Field.SIZE; j++)\n                {\n                    if (fieldChars[j] == '.') field.SetCookie(j, i, Cookie.None);\n                    if (fieldChars[j] == 'o') field.SetCookie(j, i, Cookie.Choco);\n                    if (fieldChars[j] == 'x') field.SetCookie(j, i, Cookie.Cheese);\n                }\n            }\n\n            Game game = new Game(field);\n            game.Play();\n            game.Disp();\n        }\n    }\n}\n\n    public class Game\n    {\n        private Field field;\n        private int[] rotateX = new int[] { 0, 1, 1, 1, 0, -1, -1, -1};\n        private int[] rotateY = new int[] { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n        public Game(Field field)\n        {\n            this.field = field;\n        }\n\n\n        public void Play()\n        {\n            Player mami = new Mami();\n            Player charlotte = new Charlotte();\n            while (true){\n                bool mamiPlayable = Play(mami);\n                bool charlottePlayable = Play(charlotte);\n                if (!mamiPlayable && !charlottePlayable) break;\n            }\n        }\n\n        public void Disp()\n        {\n            Console.Write(field.Disp());\n        }\n\n\n        private bool Play(Player player)\n        {\n            // クッキーを置く位置を決定\n            Point point = player.Decide(field);\n\n            // 位置が決定できなかったので終了\n            if (point == null) return false;\n\n            field.SetCookie(point.X, point.Y, player.GetMyCookie());\n\n            for (int way = 0; way < rotateX.Length; way++)\n            {\n                int count = 1;\n                bool isBetween = false;\n                for (int i = 1; i < Field.SIZE; i++)\n                {\n                    Cookie cookie = field.GetCookie(point.X + (rotateX[way] * i), point.Y + (rotateY[way] * i));\n                    if (cookie == Cookie.None) break;\n                    if (cookie == player.GetMyCookie())\n                    {\n                        isBetween = true;\n                        break;\n                    }\n                    else count++;\n                }\n                if (!isBetween) continue;\n               \n                for (int i = 1; i < count; i++)\n                {\n                    field.SetCookie(point.X + (rotateX[way] * i), point.Y + (rotateY[way] * i), player.GetMyCookie());\n                }                \n            }\n            return true;\n        }\n    }\n\n    public enum Cookie\n    {\n        None,\n        Choco,\n        Cheese\n    }\n\n    public class Field\n    {\n        public const int SIZE = 8;\n\n        private Cookie[,] field;\n\n        public Field()\n        {\n            field = new Cookie[SIZE, SIZE];\n            for (int i = 0; i < SIZE; i++)\n            {\n                for (int j = 0; j < SIZE; j++)\n                {\n                    field[i, j] = Cookie.None;\n                }\n            }\n        }\n\n        public void SetCookie(int x, int y, Cookie cookie)\n        {\n            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;\n            field[x, y] = cookie;\n        }\n\n        public Cookie GetCookie(int x, int y)\n        {\n            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return Cookie.None;\n            return field[x, y];\n        }\n\n        public String Disp()\n        {\n            string str = \"\";\n            for (int y = 0; y < SIZE; y++)\n            {\n                for (int x = 0; x < SIZE; x++)\n                {\n                    if (field[x, y] == Cookie.None) str += \".\";\n                    if (field[x, y] == Cookie.Cheese) str += \"x\";\n                    if (field[x, y] == Cookie.Choco) str += \"o\";\n                }\n                str += \"\\n\";\n            }\n            return str;\n        }\n        \n    }\n\n    public class Point\n    {\n\n        public int X { get; private set; }\n\n        public int Y { get; private set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    public abstract class Player\n    {\n\n        private int[] rotateX = new int[] { 0, 1, 1, 1, 0, -1, -1, -1 };\n        private int[] rotateY = new int[] { -1, -1, 0, 1, 1, 1, 0, -1 };\n\n        public abstract Cookie GetMyCookie();\n\n        public Point Decide(Field field)\n        {\n            // 盤面の評価\n\n            int[,] evalField = new int[Field.SIZE, Field.SIZE];\n\n            for (int i = 0; i < Field.SIZE; i++)\n            {\n                for (int j = 0; j < Field.SIZE; j++)\n                {\n                    evalField[i, j] = GetEval(field, i, j);\n                }\n            }\n            return GetDecidePoint(evalField);\n        }\n\n        private int GetEval(Field field, int x, int y)\n        {\n            // クッキーがすでにある場合、クッキーを置けないので評価値は0\n            if (field.GetCookie(x, y) != Cookie.None) return 0;\n\n            int eval = 0;\n            for (int i = 0; i < rotateX.Length; i++)\n            {\n                int count = 0;\n                for (int j = 1; j < Field.SIZE; j++)\n                {\n                    Cookie cookie = field.GetCookie(x + (rotateX[i] * j), y + (rotateY[i] * j));\n                    if (cookie == Cookie.None) break;\n                    if (cookie == GetMyCookie())\n                    {\n                        eval += count;\n                        break;\n                    }\n                    if (cookie != GetMyCookie()) count++;\n                }\n            }\n            return eval;\n        }\n\n        private Point GetDecidePoint(int[,] evalField)\n        {\n            Point maxPoint = null;\n            int maxEval = 0;\n \n            for (int y = 0; y < Field.SIZE; y++)\n            {\n                for (int x = 0; x < Field.SIZE; x++)\n                {\n                    if (evalField[x, y] == 0) continue;\n                    if (maxEval < evalField[x, y])\n                    {\n                        maxEval = evalField[x, y];\n                        maxPoint = new Point(x, y);\n                    }\n                    if (maxEval == evalField[x, y])\n                    {\n                        maxPoint = OnDecide(maxPoint, new Point(x, y));\n                    }\n                }\n            }\n            return maxPoint;\n        }\n\n        protected abstract Point OnDecide(Point a, Point b);\n    }\n\n    public class Mami : Player\n    {\n        public override Cookie GetMyCookie()\n        {\n            return Cookie.Choco;\n        }\n\n        protected override Point OnDecide(Point a, Point b)\n        {\n            /*\n             * 同じ評価の場合、マミさんは上の場所、それでもダメなら左の場所\n             */\n            if (a.Y < b.Y) return a;\n            else if (a.Y > b.Y) return b;\n            else\n            {\n                if (a.X < b.X) return a;\n                else return b;\n            }\n        }\n    }\n\n    public class Charlotte : Player\n    {\n        public override Cookie GetMyCookie()\n        {\n            return Cookie.Cheese;\n        }\n\n        protected override Point OnDecide(Point a, Point b)\n        {\n            /*\n             * 同じ評価の場合、シャルロッテは下の場所、それでもダメなら右の場所\n             */\n            if (a.Y > b.Y) return a;\n            else if (a.Y < b.Y) return b;\n            else\n            {\n                if (a.X > b.X) return a;\n                else return b;\n            }\n        }\n    }"
  },
  {
    "language": "JavaScript",
    "code": "function A(){\nvar max=0;\nvar ary=[];\nfor(var i=1;i<=8;i++){\nfor(var j=1;j<=8;j++){\nif(yx[i][j]!=\".\")continue;\nvar cnt=seach(i,j,\"x\",\"o\");\nif(cnt>max){ary=[i,j];max=cnt;}\n}\n}\nreturn ary;\n}\n\nfunction B(){\nvar max=0;\nvar ary=[];\nfor(var i=8;i>=1;i--){\nfor(var j=8;j>=1;j--){\nvar cnt=seach(i,j,\"o\",\"x\");\nif(yx[i][j]!=\".\")continue;\nif(cnt>max){ary=[i,j];max=cnt;}\n}\n}\nreturn ary;\n}\n//------------------------------------------------------\nfunction seach(y,x,a,b){\nvar dy=[-1,-1,-1,0,0,1,1,1];\nvar dx=[-1,0,1,-1,1,-1,0,1];\nvar sum=0;\nfor(var i=0;i<8;i++){\nvar DY=dy[i];\nvar DX=dx[i];\nvar cnt=0;\nvar k=1;\n\nwhile(true){\n   if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n   else if(yx[y+DY*k][x+DX*k]==a)cnt++;\n   else if(yx[y+DY*k][x+DX*k]==b){sum+=cnt;break;}\n   k++;\n}\n}\nreturn sum;\n}\n//----------------------------------------------------------\nfunction change(y,x,a,b){\nyx[y][x]=b;\nvar dy=[-1,-1,-1,0,0,1,1,1];\nvar dx=[-1,0,1,-1,1,-1,0,1];\nvar cnt=0;\nfor(var i=0;i<8;i++){\nvar DY=dy[i];\nvar DX=dx[i];\nvar cnt=0;\nvar k=1;\nvar flag=false;\nwhile(true){\n   if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n   else if(yx[y+DY*k][x+DX*k]==a)flag=true;\n   else if(yx[y+DY*k][x+DX*k]==b){\n      if(flag){\n         while(k--)yx[y+DY*k][x+DX*k]=b;\n      }\n      break;\n   }\n   k++;\n}\n}\n\n\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\n\nvar arr=input.trim().split(\"\\n\");\nvar yx=[];\nyx.push(\"ffffffffff\".split(\"\"));\narr.forEach(function(v){\nv=\"f\"+v+\"f\";\nyx.push(v.split(\"\"));\n});\nyx.push(\"ffffffffff\".split(\"\"));\nvar pass=0;\n\n\nwhile(true){\n\nvar ansA=A();\nif(ansA.length==0)pass++;\nelse {pass=0;change(ansA[0],ansA[1],\"x\",\"o\");}\nif(pass==2)break;\n\n\n\nvar ansB=B();\nif(ansB.length==0)pass++;\nelse {pass=0;change(ansB[0],ansB[1],\"o\",\"x\");}\n\nif(pass==2)break;\n\n\n\n}\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/\\,|f/g,\"\"));"
  },
  {
    "language": "JavaScript",
    "code": "function A(){\n   var max=0;\n   var ary=[];\n   for(var i=1;i<=8;i++){\n      for(var j=1;j<=8;j++){\n         if(yx[i][j]!=\".\")continue;\n         var cnt=seach(i,j,\"x\",\"o\");\n         if(cnt>max){ary=[i,j];max=cnt;}\n      }\n   }\n   return ary;\n}\nfunction B(){\n   var max=0;\n   var ary=[];\n   for(var i=8;i>=1;i--){\n      for(var j=8;j>=1;j--){\n         var cnt=seach(i,j,\"o\",\"x\");\n         if(yx[i][j]!=\".\")continue;\n         if(cnt>max){ary=[i,j];max=cnt;}\n      }\n   }\n   return ary;\n}\nfunction seach(y,x,a,b){\n   var dy=[-1,-1,-1,0,0,1,1,1];\n   var dx=[-1,0,1,-1,1,-1,0,1];\n   var sum=0;\n   for(var i=0;i<8;i++){\n      var DY=dy[i];\n      var DX=dx[i];\n      var cnt=0;\n      var k=1; \n      while(true){\n         if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n         else if(yx[y+DY*k][x+DX*k]==a)cnt++;\n         else if(yx[y+DY*k][x+DX*k]==b){sum+=cnt;break;}\n         k++;\n      }\n   }\n   return sum;\n}\nfunction change(y,x,a,b){\n   yx[y][x]=b;\n   var dy=[-1,-1,-1,0,0,1,1,1];\n   var dx=[-1,0,1,-1,1,-1,0,1];\n   var cnt=0;\n   for(var i=0;i<8;i++){\n      var DY=dy[i];\n      var DX=dx[i];\n      var cnt=0;\n      var k=1;\n      var flag=false;\n      while(true){\n         if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n         else if(yx[y+DY*k][x+DX*k]==a)flag=true;\n         else if(yx[y+DY*k][x+DX*k]==b){\n            if(flag){\n               while(k--)yx[y+DY*k][x+DX*k]=b;\n            }\n            break;\n         }\n         k++;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar yx=[];\nyx.push(\"ffffffffff\".split(\"\"));\narr.forEach(function(v){\n   v=\"f\"+v+\"f\";\n   yx.push(v.split(\"\"));\n});\nyx.push(\"ffffffffff\".split(\"\"));\nvar pass=0;\nwhile(true){\n   var ansA=A();\n   if(ansA.length==0)pass++;\n   else {pass=0;change(ansA[0],ansA[1],\"x\",\"o\");}\n   var ansB=B();\n   if(ansB.length==0)pass++;\n   else {pass=0;change(ansB[0],ansB[1],\"o\",\"x\");}\n   if(pass>=2)break;\n}\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/\\,|f/g,\"\"));"
  },
  {
    "language": "JavaScript",
    "code": "var dx = [1,1,1,0,0,-1,-1,-1];\nvar dy = [1,0,-1,1,-1,1,0,-1];\n\nfunction judge(s,turn,ii,jj){\n    var sum = 0;\n    for(var i = 0;i < 8;i++){\n        var su = 0;\n        var x = jj + dx[i],y = ii + dy[i];\n        while(x > 0 && x < 9 && y > 0 && y < 9){\n            if(s[y][x] == turn){sum += su;break;}\n            else if(s[y][x] == turn * (-1))su++;\n            else\n                break;\n            x += dx[i];y += dy[i];\n        }\n    }\n    return sum;\n}\n\nfunction put(s,turn,ii,jj){\n    for(var i = 0;i < 8;i++){\n        var su = 0;\n        var x = jj + dx[i],y = ii + dy[i];\n        var flag = false;\n        while(x > 0 && x < 9 && y > 0 && y < 9){\n            if(s[y][x] == turn){flag = true;break;}\n            else if(s[y][x] == turn * (-1))su++;\n            else\n                break;\n            x += dx[i];y += dy[i];\n        }\n        if(flag){\n            var x = jj + dx[i],y = ii + dy[i];\n            for(var j = 0;j < su;j++){\n                s[y][x] = turn;\n                x += dx[i];y += dy[i];\n            }\n        }\n    }\n    s[ii][jj] = turn;\n}\n\n\n\nfunction Main(input){\n    input = input.split(\"\\n\");\n    var s = [];\n    for(var i = 1;i <= 8;i++){\n        s[i] = [];\n    }\n\n    var fin = 0;\n\n    for(var i = 1;i <= 8;i++){\n        for(var j = 1;j <= 8;j++){\n            if(input[i - 1][j - 1] == 'o'){\n                fin++;\n                s[i][j] = 1;\n            }\n            else if (input[i - 1][j - 1] == 'x'){\n                fin++;\n                s[i][j] = -1;\n            }\n            else\n                s[i][j] = 0;\n        }\n    }\n\n    var turn = 1;var aaa = false;\n\n    while(fin < 64){\n        var maxi = 0,imax = -1,jmax = -1;\n        if(turn == 1){\n            for(var i = 1;i <= 8;i++){\n                for(var j = 1;j <= 8;j++){\n                    if(s[i][j] == 0){\n                        var a = judge(s,turn,i,j);\n                        if(a > maxi){\n                            maxi = a;imax = i;jmax = j;\n                        }\n                    }\n                }\n            }\n        }else{\n            for(var i = 1;i <= 8;i++){\n                for(var j = 1;j <= 8;j++){\n                    if(s[i][j] == 0){\n                        var a = judge(s,turn,i,j);\n                        if(a >= maxi){\n                            maxi = a;imax = i;jmax = j;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(maxi > 0){\n            aaa = false;\n            fin++;\n            put(s,turn,imax,jmax);\n        }else{\n            if(aaa)\n                break;\n            aaa = true;\n        }\n        turn *= (-1);\n    }\n\n    for(var i = 1;i <= 8;i++){\n        var ans = \"\";\n        for(var j = 1;j <= 8;j++){\n            if(s[i][j] == 1)\n                ans += 'o';\n            else if(s[i][j] == (-1))\n                ans += 'x';\n            else\n                ans += '.';\n        }\n        console.log(ans);\n    }\n}\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "function A(){\n   var max=0;\n   var ary=[];\n   for(var i=1;i<=8;i++){\n      for(var j=1;j<=8;j++){\n         if(yx[i][j]!=\".\")continue;\n         var cnt=seach(i,j,\"x\",\"o\");\n         if(cnt>max){ary=[i,j];max=cnt;}\n      }\n   }\n   return ary;\n}\nfunction B(){\n   var max=0;\n   var ary=[];\n   for(var i=8;i>=1;i--){\n      for(var j=8;j>=1;j--){\n         if(yx[i][j]!=\".\")continue;\n         var cnt=seach(i,j,\"o\",\"x\");\n         if(cnt>max){ary=[i,j];max=cnt;}\n      }\n   }\n   return ary;\n}\nfunction seach(y,x,a,b){\n   var dy=[-1,-1,-1,0,0,1,1,1];\n   var dx=[-1,0,1,-1,1,-1,0,1];\n   var sum=0;\n   for(var i=0;i<8;i++){\n      var DY=dy[i];\n      var DX=dx[i];\n      var cnt=0;\n      var k=1; \n      while(true){\n         if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n         else if(yx[y+DY*k][x+DX*k]==a)cnt++;\n         else if(yx[y+DY*k][x+DX*k]==b){sum+=cnt;break;}\n         k++;\n      }\n   }\n   return sum;\n}\nfunction change(y,x,a,b){\n   yx[y][x]=b;\n   var dy=[-1,-1,-1,0,0,1,1,1];\n   var dx=[-1,0,1,-1,1,-1,0,1];\n   var cnt=0;\n   for(var i=0;i<8;i++){\n      var DY=dy[i];\n      var DX=dx[i];\n      var cnt=0;\n      var k=1;\n      var flag=false;\n      while(true){\n         if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n         else if(yx[y+DY*k][x+DX*k]==a)flag=true;\n         else if(yx[y+DY*k][x+DX*k]==b){\n            if(flag){\n               while(k--)yx[y+DY*k][x+DX*k]=b;\n            }\n            break;\n         }\n         k++;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar yx=[];\nyx.push(\"ffffffffff\".split(\"\"));\narr.forEach(function(v){\n   v=\"f\"+v+\"f\";\n   yx.push(v.split(\"\"));\n});\nyx.push(\"ffffffffff\".split(\"\"));\nvar pass=0;\nwhile(true){\n   var ansA=A();\n   if(ansA.length==0)pass++;\n   else {pass=0;change(ansA[0],ansA[1],\"x\",\"o\");}\n   var ansB=B();\n   if(ansB.length==0)pass++;\n   else {pass=0;change(ansB[0],ansB[1],\"o\",\"x\");}\n   if(pass>=2)break;\n}\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/\\,|f/g,\"\"));"
  },
  {
    "language": "JavaScript",
    "code": "function A(){\n   var max=0;\n   var ary=[];\n   for(var i=1;i<=8;i++){\n      for(var j=1;j<=8;j++){\n         if(yx[i][j]!=\".\")continue;\n         var cnt=seach(i,j,\"x\",\"o\");\n         if(cnt>max){ary=[i,j];max=cnt;}\n      }\n   }\n   return ary;\n}\nfunction B(){\n   var max=0;\n   var ary=[];\n   for(var i=8;i>=1;i--){\n      for(var j=8;j>=1;j--){\n         if(yx[i][j]!=\".\")continue;\n         var cnt=seach(i,j,\"o\",\"x\");\n         if(cnt>max){ary=[i,j];max=cnt;}\n      }\n   }\n   return ary;\n}\nfunction seach(y,x,a,b){\n   var dy=[-1,-1,-1,0,0,1,1,1];\n   var dx=[-1,0,1,-1,1,-1,0,1];\n   var sum=0;\n   for(var i=0;i<8;i++){\n      var DY=dy[i];\n      var DX=dx[i];\n      var cnt=0;\n      var k=1; \n      while(true){\n         if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n         else if(yx[y+DY*k][x+DX*k]==a)cnt++;\n         else if(yx[y+DY*k][x+DX*k]==b){sum+=cnt;break;}\n         k++;\n      }\n   }\n   return sum;\n}\nfunction change(y,x,a,b){\n   yx[y][x]=b;\n   var dy=[-1,-1,-1,0,0,1,1,1];\n   var dx=[-1,0,1,-1,1,-1,0,1];\n   var cnt=0;\n   for(var i=0;i<8;i++){\n      var DY=dy[i];\n      var DX=dx[i];\n      var cnt=0;\n      var k=1;\n      var flag=false;\n      while(true){\n         if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n         else if(yx[y+DY*k][x+DX*k]==a)flag=true;\n         else if(yx[y+DY*k][x+DX*k]==b){\n            if(flag){\n               while(k--)yx[y+DY*k][x+DX*k]=b;\n            }\n            break;\n         }\n         k++;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar yx=[];\nyx.push(\"ffffffffff\".split(\"\"));\narr.forEach(function(v){\n   v=\"f\"+v+\"f\";\n   yx.push(v.split(\"\"));\n});\nyx.push(\"ffffffffff\".split(\"\"));\nvar pass=0;\nwhile(true){\n   var ansA=A();\n   if(ansA.length==0)pass++;\n   else {pass=0;change(ansA[0],ansA[1],\"x\",\"o\");}\n   var ansB=B();\n   if(ansB.length==0)pass++;\n   else {pass=0;change(ansB[0],ansB[1],\"o\",\"x\");}\n   if(pass>=2)break;\n}\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/\\,|f/g,\"\"));"
  },
  {
    "language": "JavaScript",
    "code": "function A(){\nvar max=0;\nvar ary=[];\nfor(var i=1;i<=8;i++){\nfor(var j=1;j<=8;j++){\nif(yx[i][j]!=\".\")continue;\nvar cnt=seach(i,j,\"x\",\"o\");\nif(cnt>max){ary=[i,j];max=cnt;}\n}\n}\nreturn ary;\n}\n\nfunction B(){\nvar max=0;\nvar ary=[];\nfor(var i=8;i>=1;i--){\nfor(var j=8;j>=1;j--){\nvar cnt=seach(i,j,\"o\",\"x\");\nif(yx[i][j]!=\".\")continue;\nif(cnt>max){ary=[i,j];max=cnt;}\n}\n}\nreturn ary;\n}\n//------------------------------------------------------\nfunction seach(y,x,a,b){\nvar dy=[-1,-1,-1,0,0,1,1,1];\nvar dx=[-1,0,1,-1,1,-1,0,1];\nvar sum=0;\nfor(var i=0;i<8;i++){\nvar DY=dy[i];\nvar DX=dx[i];\nvar cnt=0;\nvar k=1;\n\nwhile(true){\n   if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n   else if(yx[y+DY*k][x+DX*k]==a)cnt++;\n   else if(yx[y+DY*k][x+DX*k]==b){sum+=cnt;break;}\n   k++;\n}\n}\nreturn sum;\n}\n//----------------------------------------------------------\nfunction change(y,x,a,b){\nyx[y][x]=b;\nvar dy=[-1,-1,-1,0,0,1,1,1];\nvar dx=[-1,0,1,-1,1,-1,0,1];\nvar cnt=0;\nfor(var i=0;i<8;i++){\nvar DY=dy[i];\nvar DX=dx[i];\nvar cnt=0;\nvar k=1;\nvar flag=false;\nwhile(true){\n   if(yx[y+DY*k][x+DX*k]==\"f\" || yx[y+DY*k][x+DX*k]==\".\")break;\n   else if(yx[y+DY*k][x+DX*k]==a)flag=true;\n   else if(yx[y+DY*k][x+DX*k]==b){\n      if(flag){\n         while(k--)yx[y+DY*k][x+DX*k]=b;\n      }\n      break;\n   }\n   k++;\n}\n}\n\n\n}\n// var input = require('fs').readFileSync('/dev/stdin', 'utf8');\ninput = '........\\n........\\n........\\n...ox...\\n...xo...\\n........\\n........\\n........';\n\nvar arr=input.trim().split(\"\\n\");\nvar yx=[];\nyx.push(\"ffffffffff\".split(\"\"));\narr.forEach(function(v){\nv=\"f\"+v+\"f\";\nyx.push(v.split(\"\"));\n});\nyx.push(\"ffffffffff\".split(\"\"));\nvar pass=0;\n\n\nwhile(true){\n\nvar ansA=A();\nif(ansA.length==0)pass++;\nelse {pass=0;change(ansA[0],ansA[1],\"x\",\"o\");}\nif(pass==2)break;\n\n\n\nvar ansB=B();\nif(ansB.length==0)pass++;\nelse {pass=0;change(ansB[0],ansB[1],\"o\",\"x\");}\n\nif(pass==2)break;\n\n\n\n}\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/\\,|f/g,\"\"));"
  },
  {
    "language": "Ruby",
    "code": "BLANK = 0\nO = 1\nX = -1\nH = 8\nW = 8\n\ndef put!(field, y, x, color)\n  field[y][x] = color\n  dy = [-1, -1, -1, 0, 1, 1, 1, 0]\n  dx = [-1, 0, 1, 1, 1, 0, -1, -1]\n  8.times do |i|\n    ny = y + dy[i]\n    nx = x + dx[i]\n    count = 0\n    while field[ny][nx] == -color do\n      count += 1\n      ny += dy[i]\n      nx += dx[i]\n    end\n    next if field[ny][nx] != color || count == 0\n    ny = y + dy[i]\n    nx = x + dx[i]\n    while field[ny][nx] == -color do\n      field[ny][nx] = color\n      ny += dy[i]\n      nx += dx[i]\n    end\n  end\n  1\nend\n\ndef put?(field, y, x, color)\n  return 0 if field[y][x] != BLANK\n  sum = 0\n  dy = [-1, -1, -1, 0, 1, 1, 1, 0]\n  dx = [-1, 0, 1, 1, 1, 0, -1, -1]\n  8.times do |i|\n    ny = y + dy[i]\n    nx = x + dx[i]\n    count = 0\n    while field[ny][nx] == -color do\n      count += 1\n      ny += dy[i]\n      nx += dx[i]\n    end\n    next if field[ny][nx] != color || count == 0\n    sum += count\n  end\n  sum\nend\n\ndef mami(field)\n  max = y = x = 0\n  for i in 1..H do\n    for j in 1..W do\n      count = put?(field, i, j, O)\n      next if max >= count\n      max = count\n      y = i\n      x = j\n    end\n  end\n  max > 0 ? put!(field, y, x, O) : 0\nend\n\ndef witch(field)\n  max = y = x = 0\n  H.downto(1) do |i|\n    W.downto(1) do |j|\n      count = put?(field, i, j, X)\n      next if max >= count\n      max = count\n      y = i\n      x = j\n    end\n  end\n  max > 0 ? put!(field, y, x, X) : 0\nend\n\nfield = Array.new(H+2) {Array.new(W+2, BLANK)}\nfor i in 1..H do\n  field[i][1, W] = gets.chomp.chars.map{|c| c == \"o\" ? O : (c == \"x\" ? X : BLANK)}\nend\n\nturn = O\npass = 0\nwhile true do\n  case turn\n    when O\n      mami(field) > 0 ? pass = 0 : pass += 1\n    when X\n      witch(field) > 0 ? pass = 0 : pass += 1\n  end\n  break if pass == 2\n  turn *= -1\nend\n\nfor i in 1..H do\n  field[i][1,W].map{|c| putc c == 0 ? \".\" : (c == 1 ? \"o\" : \"x\")}\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "$;=''\nboard = $<.map(&:chomp).map(&:split).map{|a| [?.] + a + [?.]}\nboard.unshift [?.] * 10\nboard << [?.] * 10\n\ndef to_be_turned(board, i, j, di, dj, c)\n\tcount = 0\n\tloop do \n\t\ti += di\n\t\tj += dj\n\t\treturn count if board[i][j] == c\n\t\treturn 0 if board[i][j] == ?.\n\t\tcount += 1\n\tend\nend\n\ndef play(board, i, j, c)\n\t[-1, 0, 1].repeated_permutation(2).map { |di, dj|\n\t\tnext if di == 0 && dj == 0\n\t\tturn(board, i, j, di, dj, c)\n\t}\nend\n\ndef turn(board, i, j, di, dj, c)\n\tboard[i][j] = c\n\tloop do \n\t\ti += di\n\t\tj += dj\n\t\treturn if board[i][j] == ?.\n\t\tif board[i][j] == c\n\t\t\tloop do\n\t\t\t\ti -= di\n\t\t\t\tj -= dj\n\t\t\t\treturn if board[i][j] == c\n\t\t\t\tboard[i][j] = c\n\t\t\tend\n\t\tend\n\tend\nend\n\nc = ?o\nskip = false\nloop do\n\tmax = 0\n\tmax_by = nil\n\tord = (1..8).to_a\n\tord.reverse! if c == ?x\n\tord.each do |i|\n\t\tord.each do |j|\n\t\t\tnext unless board[i][j] == ?.\n\t\t\tx = [-1, 0, 1].repeated_permutation(2).map { |di, dj|\n\t\t\t\tnext 0 if di == 0 && dj == 0\n\t\t\t\tto_be_turned(board, i, j, di, dj, c)\n\t\t\t}.inject(:+)\n\t\t\tif x > max\n\t\t\t\tmax = x\n\t\t\t\tmax_by = [i, j]\n\t\t\tend\n\t\tend\n\tend\n\n\tif max_by\n\t\tplay(board, *max_by, c)\n\telsif skip\n\t\tbreak\n\telse\n\t\tskip = true\n\tend\n\tc = (c == ?o ? ?x : ?o)\nend\n\nboard.shift\nboard.pop\nboard.each do |a|\n\ta.pop\n\ta.shift\nend\nputs board.map(&:join)"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Reversi\n  attr_accessor :width, :height, :turn, :board\n  BLACK = 1\n  WHITE = 2\n  DX = [-1,-1,-1, 0, 0, 1, 1, 1]\n  DY = [-1, 0, 1,-1, 1,-1, 0, 1]\n  \n  def initialize(width = 8, height = 8)\n    @width = width\n    @height = height\n    @board = Array.new(@height).map!{Array.new(@width, 0)}\n    @turn = BLACK\n    @colornum = 2\n  end\n\n  def check(color=@turn)\n    point = Struct.new(:x, :y);\n    ar = []\n    for i in 0..@height-1\n      for j in 0..@width-1\n        ar.push point.new(j, i) if put_stone(color, j, i, false) >= 1\n      end\n    end\n    return ar\n  end\n  \n  # 0 => もう置けない\n  def next_color()\n      turn = @turn\n      @colornum.times{\n        turn = (turn%2)+1\n        return turn if check(turn).size > 0\n      }\n      return 0\n  end\n  \n  # -1 => 置けない  0 => ゲーム終了  それ以外 => 次の手番\n  def put(x, y)\n    return 0 if @turn == 0\n    if put_stone(@turn, x, y) then\n      @turn = next_color\n      return @turn\n    end\n    return -1\n  end\n  \n  def put_stone(color, x, y, put = true) # putがfalseの時は置けるか調べるだけ\n    point = Struct.new(:x, :y);\n\n    return 0 if @board[y][x] != 0 # 置く場所をチェック\n    queue = [point.new(x,y)]    # 石が変わる座標をqueueで持つ\n    \n    # 8方向を調べる\n    8.times{|i|\n      cnt = 0 # 返す石の数\n      for j in 1..[@width,@height].max\n        nx = x + DX[i] * j\n        ny = y + DY[i] * j\n        break if nx < 0 || nx >= @width || ny < 0 || ny >= @height # 配列外チェック\n        break if @board[ny][nx] == 0                  # 石が無いなら次へ\n        break if @board[ny][nx] == color && cnt == 0  # ひっくり返せないなら次へ\n        if @board[ny][nx] == color then # ひっくり返せるなら、ひっくり返す\n          for k in 1..cnt\n            queue.push point.new(x+DX[i]*k, y+DY[i]*k)\n          end\n          break\n        end\n        cnt += 1\n      end\n    }\n    \n    revnum = queue.size-1 # 返す石の数\n    \n\n    if put then\n      until queue.empty?  # 石を返す処理\n        p = queue.shift\n        @board[p.y][p.x] = color\n      end\n    end\n    \n    return revnum\n  end\nend\n\n\nrev = Reversi.new\n\ninput = []\n8.times{\n  input.push gets.chomp.gsub('o', '1 ').gsub('x', '2 ').gsub('.', '0 ').split(nil).map(&:to_i)\n}\n\nrev.board = input\n\nrev.turn = rev.next_color if rev.check.size <= 0\n\nwhile rev.turn >= 1\n  best = 0\n  x = 0\n  y = 0\n  8.times{|i|\n    8.times{|j|\n      cnt = rev.put_stone(rev.turn, j, i, false)\n      if (rev.turn == 2 && best <= cnt) || (rev.turn == 1 && best < cnt) then\n        y = i\n        x = j\n        best = cnt\n      end\n    }\n  }\n  rev.put(x, y)\nend\n\nrev.board.each{|e|\n  puts e.join.to_s.gsub('1', 'o').gsub('2', 'x').gsub('0', '.')\n}"
  },
  {
    "language": "Ruby",
    "code": "$;=''\nboard = $<.map(&:chomp).map(&:split).map{|a| [?.] + a + [?.]}\nboard.unshift [?.] * 10\nboard << [?.] * 10\n\ndef to_be_turned(board, i, j, di, dj, c)\n\tcount = 0\n\tloop do \n\t\ti += di\n\t\tj += dj\n\t\treturn count if board[i][j] == c\n\t\treturn 0 if board[i][j] == ?.\n\t\tcount += 1\n\tend\nend\n\ndef play(board, i, j, c)\n\t[-1, 0, 1].repeated_permutation(2).map { |di, dj|\n\t\tnext if di == 0 && dj == 0\n\t\tturn(board, i, j, di, dj, c)\n\t}\nend\n\ndef turn(board, i, j, di, dj, c)\n\tboard[i][j] = c\n\tloop do \n\t\ti += di\n\t\tj += dj\n\t\treturn if board[i][j] == ?.\n\t\tif board[i][j] == c\n\t\t\tloop do\n\t\t\t\ti -= di\n\t\t\t\tj -= dj\n\t\t\t\treturn if board[i][j] == c\n\t\t\t\tboard[i][j] = c\n\t\t\tend\n\t\tend\n\tend\nend\n\nc = ?o\nskip = false\nloop do\n\tmax = 0\n\tmax_by = nil\n\tord = (1..8).to_a\n\tord.reverse! if c == ?x\n\tord.each do |i|\n\t\tord.each do |j|\n\t\t\tnext unless board[i][j] == ?.\n\t\t\tx = [-1, 0, 1].repeated_permutation(2).map { |di, dj|\n\t\t\t\tnext 0 if di == 0 && dj == 0\n\t\t\t\tto_be_turned(board, i, j, di, dj, c)\n\t\t\t}.inject(:+)\n\t\t\tif x > max\n\t\t\t\tmax = x\n\t\t\t\tmax_by = [i, j]\n\t\t\tend\n\t\tend\n\tend\n\n\tif max_by\n\t\tplay(board, *max_by, c)\n\t\tskip = false\n\telsif skip\n\t\tbreak\n\telse\n\t\tskip = true\n\tend\n\tc = (c == ?o ? ?x : ?o)\nend\n\nboard.shift\nboard.pop\nboard.each do |a|\n\ta.pop\n\ta.shift\nend\nputs board.map(&:join)"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    char[][] F;\n    foreach (i; 0 .. 8) {\n        F ~= cast(char[])readln.chomp;\n    }\n\n    const dy = [-1, -1, 0, 1, 1, 1, 0, -1],\n          dx = [0, 1, 1, 1, 0, -1, -1, -1];\n\n    bool chocolate() {\n        long cy = -1, cx = -1;\n        int Ans = 0;\n        foreach (i; 0 .. 8) {\n            foreach (j; 0 .. 8) {\n                if (F[i][j] != '.') continue;\n                int A = 0;\n                foreach (k; 0 .. 8) {\n                    int C = 0;\n                    auto y = i, x = j;\n                    while (true) {\n                        y += dy[k]; x += dx[k];\n                        if (y < 0 || y >= 8) break;\n                        if (x < 0 || x >= 8) break;\n                        if (F[y][x] == '.') break;\n                        if (F[y][x] == 'o') {\n                            A += C;\n                            break;\n                        }\n                        assert(F[y][x] == 'x');\n                        C++;\n                    }\n                }\n                if (A > Ans) {\n                    cy = i; cx = j;\n                    Ans = A;\n                }\n            }\n        }\n        if (Ans == 0) return false;\n        F[cy][cx] = 'o';\n        foreach (k; 0 .. 8) {\n            auto y = cy, x = cx;\n            while (true) {\n                y += dy[k]; x += dx[k];\n                if (y < 0 || y >= 8) break;\n                if (x < 0 || x >= 8) break;\n                if (F[y][x] == '.') break;\n                if (F[y][x] == 'o') {\n                    auto y1 = cy, x1 = cx;\n                    while (y1 != y || x1 != x) {\n                        y1 += dy[k]; x1 += dx[k];\n                        F[y1][x1] = 'o';\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    bool cheese() {\n        long cy = -1, cx = -1;\n        int Ans = 0;\n        foreach (i; 0 .. 8) {\n            foreach (j; 0 .. 8) {\n                if (F[i][j] != '.') continue;\n                int A = 0;\n                foreach (k; 0 .. 8) {\n                    int C = 0;\n                    auto y = i, x = j;\n                    while (true) {\n                        y += dy[k]; x += dx[k];\n                        if (y < 0 || y >= 8) break;\n                        if (x < 0 || x >= 8) break;\n                        if (F[y][x] == '.') break;\n                        if (F[y][x] == 'x') {\n                            A += C;\n                            break;\n                        }\n                        assert(F[y][x] == 'o');\n                        C++;\n                    }\n                }\n                if (A >= Ans) {\n                    cy = i; cx = j;\n                    Ans = A;\n                }\n            }\n        }\n        if (Ans == 0) return false;\n        F[cy][cx] = 'x';\n        foreach (k; 0 .. 8) {\n            auto y = cy, x = cx;\n            while (true) {\n                y += dy[k]; x += dx[k];\n                if (y < 0 || y >= 8) break;\n                if (x < 0 || x >= 8) break;\n                if (F[y][x] == '.') break;\n                if (F[y][x] == 'x') {\n                    auto y1 = cy, x1 = cx;\n                    while (y1 != y || x1 != x) {\n                        y1 += dy[k]; x1 += dx[k];\n                        F[y1][x1] = 'x';\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    for (int i = 0; ; i++) {\n        bool a = chocolate;\n        //foreach (L; F) { writeln(L); } writeln;\n        bool b = cheese;\n        //foreach (L; F) { writeln(L); } writeln;\n        if (!a && !b) break;\n    }\n    foreach (L; F) {\n        writeln(L);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "dxy = zip([1,1,0,-1,-1,-1,0,1],[0,1,1,1,0,-1,-1,-1])\nA = [list(raw_input()) for i in xrange(8)]\nfor i in xrange(64):\n    hand = [\"o\",\"x\"][i%2]\n    d = [1,-1][i%2]\n    mx,nd = 0,[]\n    for y in range(8)[::d]:\n        for x in range(8)[::d]:\n            if A[y][x] == \".\":\n                tmp,td = 0,[]\n                for dx,dy in dxy:\n                    nx,ny = x+dx,y+dy\n                    while 0 <= min(nx,ny) and max(nx,ny) < 8:\n                        if   A[ny][nx] == hand:\n                            get = max(abs(nx-x),abs(ny-y))-1\n                            if get > 0:\n                                tmp += get\n                                td.append([dx,dy])\n                            break\n                        elif A[ny][nx] == \".\":\n                            break\n                        nx += dx; ny += dy\n                if tmp > mx:\n                    mx,nd = tmp,td\n                    px,py = x,y\n    if mx == 0: continue\n    A[py][px] = hand\n    for dx,dy in nd:\n        nx,ny = px+dx,py+dy\n        while 0 <= min(nx,ny) and max(nx,ny) < 8:\n            if A[ny][nx] == hand: break\n            A[ny][nx] = hand\n            nx += dx; ny += dy\nfor a in A:\n    print \"\".join(a)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime,time\n\n\nMAP = [list('z' + input() + 'z') for _ in range(8)]\nMAP = [list('z'*10)] + MAP + [list('z'*10)]\n\ndef check(x0,y0,turn):\n    if MAP[y0][x0] != '.':\n        return 0, []\n\n    if turn:\n        me,you = 'o','x'\n    else:\n        me,you = 'x','o'\n\n    ans = 0\n    dx = [-1, 0, 1,-1, 1,-1, 0, 1]\n    dy = [-1,-1,-1, 0, 0, 1, 1, 1]\n    rev = []\n    for i in range(8):\n        x,y = x0,y0\n        cnt = 0\n        tmprev = []\n        while True:\n            x += dx[i]\n            y += dy[i]\n            if MAP[y][x] == you:\n                tmprev.append([x,y])\n                cnt += 1\n                continue\n            elif MAP[y][x] == me:\n                break\n            else:\n                cnt = 0\n                tmprev = []\n                break\n        ans += cnt\n        rev = tmprev + rev\n    return ans,rev\n\nbtmp = -1\nturn = True\nwhile True:\n    maxtmp = 0\n    maxrev = []\n    my = []\n    ra = list(range(1,9))\n    if not turn:\n        ra = list(reversed(ra))\n\n    #print(turn,ra)\n    for y in ra:\n        for x in ra:\n            #print(turn,x,y)\n            tmp,rev = check(x,y,turn)\n            if maxtmp < tmp:\n                maxtmp = tmp\n                maxrev = rev[:]\n                my = [x,y]\n\n    if my:\n        if turn:\n            MAP[my[1]][my[0]] = 'o'\n        else:\n            MAP[my[1]][my[0]] = 'x'\n\n    for x,y in maxrev:\n        if MAP[y][x] == 'o':\n            MAP[y][x] = 'x'\n        else:\n            MAP[y][x] = 'o'\n\n    #print(maxtmp,my,rev)\n\n    #for m in MAP:\n    #    print(''.join(m))\n\n    if btmp == 0 and maxtmp == 0:\n        break\n\n    btmp = maxtmp\n    turn = not turn\n\nfor y in range(1,9):\n    print(''.join(MAP[y][1:9]))\n\n"
  },
  {
    "language": "Python",
    "code": "def search(c,a,b):\n    r={'o':'x','x':'o'}\n    ans=0\n    direct=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n    for d in range(8):\n        y,x=a,b\n        i,j=direct[d]\n        while s[y+i][x+j]==r[c]:\n            y+=i\n            x+=j\n        if s[y+i][x+j]==c:\n            ans+=max(abs(y-a),abs(x-b))\n\n    return ans\n\ndef mami():\n    m=0\n    a=b=-1\n    for i in range(1,9):\n        for j in range(1,9):\n            if s[i][j]=='.':\n                t=search('o',i,j)\n                if t>m:\n                    m=t\n                    a,b=i,j\n    return(a,b)\n\ndef char():\n    m=1\n    a=b=-1\n    for i in range(1,9):\n        for j in range(1,9):\n            if s[i][j]=='.':\n                t=search('x',i,j)\n                if t>=m:\n                    m=t\n                    a,b=i,j\n    return(a,b)\n\ndef rev(c,a,b):\n    #s[a][b]=c\n    r={'o':'x','x':'o'}\n    direct=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n    for d in range(8):\n        y,x=a,b\n        i,j=direct[d]\n        while s[y+i][x+j]==r[c]:\n            y+=i\n            x+=j\n        if s[y+i][x+j]==c:\n            #i,j=direct[d]\n            y,x=a+i,b+j\n            while s[y][x]==r[c]:\n                s[y][x]=c\n                y+=i\n                x+=j\n    s[a][b]=c\n\ns=[['.']*10]\nfor _ in range(8):\n    s.append(['.']+list(input())+['.'])\ns=tuple(s+[['.']*10])\n\nwhile 1:\n    a,b=mami()\n    if a>0:\n        rev('o',a,b)\n    c,d=char()\n    if c>0:\n        rev('x',c,d)\n    if all(i==-1for i in(a,b,c,d)):\n        break\nfor t in s:\n    print(*t[1:9],sep='')\n"
  },
  {
    "language": "Python",
    "code": "def search(c,a,b):\n    r={'o':'x','x':'o'}\n    ans=0\n    direct=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n    for d in range(8):\n        y,x=a,b\n        i,j=direct[d]\n        while s[y+i][x+j]==r[c]:\n            y+=i\n            x+=j\n        if s[y+i][x+j]==c:\n            ans+=max(abs(y-a),abs(x-b))\n\n    return ans\n\ndef mami():\n    m=0\n    a=b=-1\n    for i in range(1,9):\n        for j in range(1,9):\n            if s[i][j]=='.':\n                t=search('o',i,j)\n                if t>m:\n                    m=t\n                    a,b=i,j\n    return(a,b)\n\ndef char():\n    m=1\n    a=b=-1\n    for i in range(1,9):\n        for j in range(1,9):\n            if s[i][j]=='.':\n                t=search('x',i,j)\n                if t>=m:\n                    m=t\n                    a,b=i,j\n    return(a,b)\n\ndef rev(c,a,b):\n    #s[a][b]=c\n    r={'o':'x','x':'o'}\n    direct=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n    for d in range(8):\n        y,x=a,b\n        i,j=direct[d]\n        while s[y+i][x+j]==r[c]:\n            y+=i\n            x+=j\n        if s[y+i][x+j]==c:\n            #i,j=direct[d]\n            y,x=a+i,b+j\n            while s[y][x]==r[c]:\n                s[y][x]=c\n                y+=i\n                x+=j\n    s[a][b]=c\n\ns=[['.']*10]\nfor _ in range(8):\n    s.append(['.']+list(input())+['.'])\ns=tuple(s+[['.']*10])\n\nwhile 1:\n    a,b=mami()\n    if a>0:\n        rev('o',a,b)\n    c,d=char()\n    if c>0:\n        rev('x',c,d)\n    if all(i==-1for i in(a,b,c,d)):\n        break\nfor t in s[1:-1]:\n    print(*t[1:9],sep='')\n"
  },
  {
    "language": "Python",
    "code": "dxy = zip([1,1,0,-1,-1,-1,0,1],[0,1,1,1,0,-1,-1,-1])\n\nA = [list(raw_input()) for i in xrange(8)]\nfor i in xrange(64):\n    hand = [\"o\",\"x\"][i%2]\n    d = 1-2*(i%2)\n    px = py = -1\n    mx = 0\n    for y in range(8)[::d]:\n        for x in range(8)[::d]:\n            if A[y][x] == \".\":\n                for dx,dy in dxy:\n                    nx,ny = x+dx,y+dy\n                    while 0 <= min(nx,ny) and max(nx,ny) < 8:\n                        if   A[ny][nx] == hand:\n                            if max(abs(nx-x),abs(ny-y))-1 > mx:\n                                mx = max(abs(nx-x),abs(ny-y))-1\n                                px,py,dxx,dyy = x,y,dx,dy\n                            else:\n                                break\n                        elif A[ny][nx] == \".\":\n                            break\n                        nx += dx; ny += dy\n    if px == py == -1: continue\n    while 0 <= min(px,py) and max(px,py) < 8:\n        if A[py][px] == hand: break\n        A[py][px] = hand\n        px += dxx; py += dyy\nfor a in A:\n    print \"\".join(a)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    dd = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n    while True:\n        b = [[c for c in S()] for _ in range(8)]\n        def g(ps,i,j,di,dj):\n            if not (0 <= i < 8) or not (0 <= j < 8):\n                return\n            if b[i][j] == '.':\n                return\n            if b[i][j] == ps:\n                return 0\n            tr = g(ps,i+di,j+dj,di,dj)\n            if tr is None:\n                return\n            return tr + 1\n\n        def ff(ps,i,j,di,dj):\n            if not (0 <= i < 8) or not (0 <= j < 8):\n                return\n            if b[i][j] == '.':\n                return\n            if b[i][j] == ps:\n                return 0\n            tr = ff(ps,i+di,j+dj,di,dj)\n            if tr is None:\n                return\n            b[i][j] = ps\n            return tr + 1\n\n        def f(pf, pp):\n            ps = 'o'\n            es = 'x'\n            if not pf:\n                ps = 'x'\n                es = 'o'\n            mc = 0\n            mij = (0,0)\n            for i in range(8):\n                for j in range(8):\n                    if b[i][j] != '.':\n                        continue\n                    c = 0\n                    for di,dj in dd:\n                        tc = g(ps,i+di,j+dj,di,dj)\n                        if not tc is None:\n                            c += tc\n                    if mc < c or (mc == c and not pf):\n                        mc = c\n                        mij = (i,j)\n\n            if mc > 0:\n                i,j = mij\n                b[i][j] = ps\n                for di,dj in dd:\n                    ff(ps,i+di,j+dj,di,dj)\n                f(not pf, False)\n            elif pp:\n                return\n            else:\n                f(not pf, True)\n\n        f(True, False)\n\n        for i in range(8):\n            rr.append(''.join(b[i]))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "mp = [list(\"X\" * 10)] + [list(\"X\" + input() + \"X\") for _ in range(8)] + [list(\"X\" * 10)]\nvec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\n#mami...o, witch...x\n\ndef search(target, another, x, y, dx, dy):\n  nx, ny = x + dx, y + dy\n  cnt = 0\n  while mp[ny][nx] == another:\n    nx += dx\n    ny += dy\n    cnt += 1\n\n  if mp[ny][nx] == target:\n    return cnt\n  else:\n    return 0\n\ndef score(target, another, x, y):\n  ret = 0\n  for dx, dy in vec:\n    ret += search(target, another, x, y, dx, dy)\n  return ret\n\ndef locate(target, another, x, y):\n  mp[y][x] = target\n  for dx, dy in vec:\n    if search(target, another, x, y, dx, dy):\n      nx, ny = x + dx, y + dy\n      while mp[ny][nx] == another:\n        mp[ny][nx] = target\n        nx += dx\n        ny += dy\n\ndef temp(target, another, flag):\n  max_score = 0\n  max_x, max_y = 100, 100\n  loop = range(1, 9) if flag else range(8, 0, -1)\n  for y in loop:\n    for x in loop:\n      if mp[y][x] != \".\":continue\n      new_score = score(target, another, x, y)\n      if new_score > max_score:\n        max_score = new_score\n        max_x, max_y = x, y\n  \n  if max_score != 0:\n    locate(target, another, max_x, max_y)\n    return True\n  return False\n\ndef mami():\n  return temp(\"o\", \"x\", True)\n\ndef witch():\n  return temp(\"x\", \"o\", False)\n\ndef play():\n  while True:\n    flag = False\n    flag = mami() or flag\n    flag = witch() or flag\n    if not flag:break\nplay()\n[print(\"\".join(lst[1:-1])) for lst in mp[1:-1]]\n"
  },
  {
    "language": "Python",
    "code": "def search(c,a,b):\n    r={'o':'x','x':'o'}\n    ans=0\n    direct=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n    for d in range(8):\n        y,x=a,b\n        i,j=direct[d]\n        while s[y+i][x+j]==r[c]:\n            y+=i\n            x+=j\n        if s[y+i][x+j]==c:\n            ans+=max(abs(y-a),abs(x-b))\n\n    return ans\n\ndef mami():\n    m=0\n    a=b=-1\n    for i in range(1,9):\n        for j in range(1,9):\n            if s[i][j]=='.':\n                t=search('o',i,j)\n                if t>m:\n                    m=t\n                    a,b=i,j\n    return(a,b)\n\ndef char():\n    m=1\n    a=b=-1\n    for i in range(1,9):\n        for j in range(1,9):\n            if s[i][j]=='.':\n                t=search('x',i,j)\n                if t>=m:\n                    m=t\n                    a,b=i,j\n    return(a,b)\n\ndef rev(c,a,b):\n    #s[a][b]=c\n    r={'o':'x','x':'o'}\n    direct=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))\n    for d in range(8):\n        y,x=a,b\n        i,j=direct[d]\n        while s[y+i][x+j]==r[c]:\n            y+=i\n            x+=j\n        if s[y+i][x+j]==c:\n            #i,j=direct[d]\n            y,x=a+i,b+j\n            while s[y][x]==r[c]:\n                s[y][x]=c\n                y+=i\n                x+=j\n    s[a][b]=c\n\ns=[['.']*10]\nfor _ in range(8):\n    s.append(['.']+list(input())+['.'])\ns=tuple(s+[['.']*10])\n\nwhile 1:\n    a,b=mami()\n    if a>0:\n        rev('o',a,b)\n    c,d=char()\n    if c>0:\n        rev('x',c,d)\n    if all(i==-1for i in(a,b,c,d)):\n        break\nfor t in s[:-1]:\n    print(*t[1:9],sep='')\n"
  },
  {
    "language": "Python",
    "code": "from __future__ import print_function\nimport copy\nimport sys\n\nclass Board(object):\n    size = 8\n    dy = [0, -1, -1, -1, 0, 1, 1, 1]\n    dx = [1, 1, 0, -1, -1, -1, 0, 1]\n\n    def __init__(self):\n        self.board = [[0] * Board.size for _ in xrange(Board.size)]\n\n    def __deepcopy__(self, memo):\n        ret = Board()\n        ret.board = copy.deepcopy(self.board, memo)\n        return ret\n\n    def _check_range(self, y, x):\n        assert 0 <= y < Board.size and 0 <= x < Board.size\n\n    def _check_color(self, color):\n        assert color == 'o' or color == 'x'\n\n    def _putone(self, color, y, x):\n        self._check_color(color)\n        self._check_range(y, x)\n\n        if color == 'o':\n            self.board[y][x] = 1\n        if color == 'x':\n            self.board[y][x] = -1\n\n    def _getone(self, y, x):\n        self._check_range(y, x)\n        \n        if self.board[y][x] == 1:\n            return 'o'\n        if self.board[y][x] == -1:\n            return 'x'\n        return '.'\n\n    def view(self):\n        return '\\n'.join(''.join(self._getone(y, x) for x in xrange(Board.size)) for y in xrange(Board.size))\n\n    def put(self, color, y, x):\n        self._check_color(color)\n        self._check_range(y, x)\n        self._putone(color, y, x)\n\n\n        def find(y, x, d):\n            # print(\"y = \", y, \", x = \", x, \", d = \", d)\n            if y < 0 or y >= Board.size or x < 0 or x >= Board.size:\n                return False\n            if self._getone(y, x) == '.':\n                return False\n            if self._getone(y, x) == color:\n                return True\n            if find(y + Board.dy[d], x + Board.dx[d], d):\n                self._putone(color, y, x)\n                return True\n            return False\n\n        for d in xrange(Board.size):\n            # print('d = ', d)\n            find(y + Board.dy[d], x + Board.dx[d], d)\n            # print(self.view())\n\ndef main():\n    board = Board()\n    for i in xrange(8):\n        l = raw_input()\n        for j in xrange(8):\n            if l[j] != '.':\n                board._putone(l[j], i, j)\n    color = 'o'\n    passprev = False\n    while True:\n        cy = -1\n        cx = -1\n        get = 1\n        o = sum(1 for c in board.view() if c == 'o')\n        x = sum(1 for c in board.view() if c == 'x')\n        if color == 'o':\n            for i in xrange(8):\n                for j in xrange(8):\n                    if board._getone(i, j) == '.':\n                        board2 = copy.deepcopy(board)\n                        board2.put(color, i, j)\n                        o2 = sum(1 for c in board2.view() if c == 'o')\n                        if o2 - o > get:\n                            get = o2 - o\n                            cy = i\n                            cx = j\n        else:\n            for _i in xrange(8):\n                for _j in xrange(8):\n                    i = 7 - _i\n                    j = 7 - _j\n                    if board._getone(i, j) == '.':\n                        board2 = copy.deepcopy(board)\n                        board2.put(color, i, j)\n                        x2 = sum(1 for c in board2.view() if c == 'x')\n                        if x2 - x > get:\n                            get = x2 - x\n                            cy = i\n                            cx = j\n\n        if cy == -1 and cx == -1:\n            if passprev:\n                break\n            passprev = True\n        else:\n            passprev = False\n            board.put(color, cy, cx)\n\n        if color == 'o':\n            color = 'x'\n        else:\n            color = 'o'\n\n    print(board.view())\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap};\nuse std::fmt::{Display, Formatter, Error};\nuse std::ops::Range;\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nstruct ValueWithKey<K, V> {\n    key: K, value: V,\n}\nimpl <K, V> Ord for ValueWithKey<K, V> where K: Ord {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.key.cmp(&other.key)\n    }\n}\nimpl <K, V> PartialOrd for ValueWithKey<K, V> where K: PartialOrd {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K, V> PartialEq for ValueWithKey<K, V> where K: PartialEq {\n    fn eq(&self, other: &Self) -> bool {\n        self.key == other.key\n    }\n}\nimpl <K, V> Eq for ValueWithKey<K, V> where K: Eq {}\n#[derive(Copy, Clone)]\nstruct Coordinate {\n    x: usize, y: usize\n}\nimpl Coordinate {\n    fn create(x: i32, y: i32) -> Coordinate {\n        Coordinate{x: x as usize, y: y as usize}\n    }\n}\nimpl Display for Coordinate {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"(x: {}, y: {})\", self.x, self.y)\n    }\n}\nfn find_tomoe(state: &Vec<Vec<char>>) -> Option<Coordinate> {\n    let mut max = 0;\n    let mut max_coordinate = Coordinate::create(0, 0);\n    for y in 0 .. 8 {\n        for x in 0 .. 8 {\n            let mut count = 0;\n            match state[y][x] {\n                '.' => {\n                    for dx in -1_i32 .. 2 {\n                        for dy in -1_i32 .. 2 {\n                            if dx != 0 || dy != 0 {\n                                let mut temp = 0;\n                                let mut cx = x as i32 + dx;\n                                let mut cy = y as i32 + dy;\n                                while cx >= 0 && cx < 8 && cy >= 0 && cy < 8{\n                                    match state[cy as usize][cx as usize] {\n                                        'x' => {\n                                            temp += 1;\n                                            cx += dx;\n                                            cy += dy;\n                                        }\n                                        'o' => {\n                                            count += temp;\n                                            break\n                                        }\n                                        '.' => break,\n                                        _ => unreachable!()\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n            if max < count {\n                max = count;\n                max_coordinate = Coordinate{x: x, y: y};\n            }\n        }\n    }\n    if max == 0 {\n        None\n    }else {\n        Some(max_coordinate)\n    }\n}\nfn find_okashi(state: &Vec<Vec<char>>) -> Option<Coordinate> {\n    let mut max = 0;\n    let mut max_coordinate = Coordinate::create(0, 0);\n    for y in 0 .. 8 {\n        for x in 0 .. 8 {\n            let mut count = 0;\n            match state[7 - y][7 - x] {\n                '.' => {\n                    for dx in -1_i32..2 {\n                        for dy in -1_i32..2 {\n                            if dx != 0 || dy != 0 {\n                                let mut temp = 0;\n                                let mut cx = 7 - x as i32 + dx;\n                                let mut cy = 7 - y as i32 + dy;\n                                while cx >= 0 && cx < 8 && cy >= 0 && cy < 8 {\n                                    match state[cy as usize][cx as usize] {\n                                        'o' => {\n                                            temp += 1;\n                                            cx += dx;\n                                            cy += dy;\n                                        }\n                                        'x' => {\n                                            count += temp;\n                                            break\n                                        }\n                                        '.' => break,\n                                        _ => unreachable!()\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                _ => {}\n            }\n            if max < count {\n                max = count;\n                max_coordinate = Coordinate{x: 7 - x, y: 7 - y};\n            }\n        }\n    }\n    if max == 0 {\n        None\n    }else {\n        Some(max_coordinate)\n    }\n}\nfn put_tomoe(state: &mut Vec<Vec<char>>, coordinate: Coordinate) {\n    state[coordinate.y][coordinate.x] = 'o';\n    for dy in -1_i32 .. 2 {\n        for dx in -1_i32 .. 2 {\n            if dy != 0 || dx != 0 {\n                let mut cx = coordinate.x as i32 + dx;\n                let mut cy = coordinate.y as i32 + dy;\n                while cx >= 0 && cx < 8 && cy >= 0 && cy < 8 {\n                    match state[cy as usize][cx as usize] {\n                        'o' => {\n                            let mut x = (coordinate.x as i32 + dx) as usize;\n                            let mut y = (coordinate.y as i32 + dy) as usize;\n                            while state[y][x] == 'x' {\n                                state[y][x] = 'o';\n                                x = (x as i32 + dx) as usize;\n                                y = (y as i32 + dy) as usize;\n                            }\n                            break\n                        }\n                        'x' => {\n                            cx += dx;\n                            cy += dy;\n                        }\n                        '.' => break,\n                        _ => unreachable!()\n                    }\n                }\n            }\n        }\n    }\n}\nfn put_okashi(state: &mut Vec<Vec<char>>, coordinate: Coordinate) {\n    state[coordinate.y][coordinate.x] = 'x';\n    for dy in -1_i32 .. 2 {\n        for dx in -1_i32 .. 2 {\n            if dy != 0 || dx != 0 {\n                let mut cx = coordinate.x as i32 + dx;\n                let mut cy = coordinate.y as i32 + dy;\n                while cx >= 0 && cx < 8 && cy >= 0 && cy < 8 {\n                    match state[cy as usize][cx as usize] {\n                        'x' => {\n                            let mut x = (coordinate.x as i32 + dx) as usize;\n                            let mut y = (coordinate.y as i32 + dy) as usize;\n                            while state[y][x] == 'o' {\n                                state[y][x] = 'x';\n                                x = (x as i32 + dx) as usize;\n                                y = (y as i32 + dy) as usize;\n                            }\n                            break\n                        }\n                        'o' => {\n                            cx += dx;\n                            cy += dy;\n                        }\n                        '.' => break,\n                        _ => unreachable!()\n                    }\n                }\n            }\n        }\n    }\n}\nfn tomoe_turn(state: &mut Vec<Vec<char>>) {\n    if let Some(c) = find_tomoe(state) {\n        put_tomoe(state, c)\n    }\n}\nfn okashi_turn(state: &mut Vec<Vec<char>>) {\n    if let Some(c) = find_okashi(state) {\n        put_okashi(state, c)\n    }\n}\nfn main(){\n    let mut state = Vec::<Vec<char>>::with_capacity(8);\n    for _ in 0 .. 8 {\n        state.push(read_line!().chars().collect());\n    }\n    for i in 0 .. 64 {\n        tomoe_turn(&mut state);\n        okashi_turn(&mut state);\n    }\n    for y in 0 .. 8{\n        for x in 0 .. 8 {\n            print!(\"{}\", state[y][x]);\n        }\n        println!();\n    }\n}\n\n\n"
  }
]