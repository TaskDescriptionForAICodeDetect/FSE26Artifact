[
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+9;\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nint n,m,a[20],b[20],aa[20],bb[20],c1,c2;\n\nint go[3000111],rev[5],cur,all,cnt;\n\nvoid con(int x,int y)\n{\n\tif(go[x]&&go[y]&&go[x]!=go[y])\n\t{\n\t\tcur=0;\n\t\treturn;\n\t}\n\telse if(!go[x]&&!go[y])\n\t{\n\t\tcur=3ll*cur%mod*power(all,mod-2)%mod;\n\t\tgo[x]=go[y]=++cnt;\n\t\tall--;\n\t}\n\telse\n\t{\n\t\tcur=2ll*cur%mod*power(all,mod-2)%mod;\n\t\tgo[x]=go[y]=go[x]+go[y];\n\t\tall--;\n\t}\n}\nint main()\n{\n\tget2(n,m);\n\tfor(int i=1,x,y,z;i<=m;i++)\n\t{\n\t\tget3(x,y,z);\n\t\tif(z==0)\n\t\t{\n\t\t\taa[c2]=x;\n\t\t\tbb[c2++]=y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[c1]=x;\n\t\t\tb[c1++]=y;\n\t\t}\n\t}\n\tint fac=1,ans=0;for(int i=n+1;i<=n*3;i++)fac=1ll*fac*i%mod;\n\tfac=1ll*fac*power(power(6,mod-2),n)%mod;\n//\tprintf(\"fac= %d\\n\",fac);\n\tfor(int mask=0;mask<(1<<c1);mask++)\n\t{\n\t\tcnt=0;\n\t\tall=n*3;\n\t\tcur=fac;\n\t\tint tot=0;\n\t\tfor(int j=0;j<c2;j++)con(aa[j],bb[j]);\n\t\tfor(int j=0;j<c1;j++)if((mask>>j)&1)\n\t\t{\n\t\t\tcon(a[j],b[j]);\n\t\t\ttot++;\n\t\t}\n\t\t\n\t\tcnt=0;\n\t\tfor(int j=0;j<c2;j++)go[aa[j]]=go[bb[j]]=0;\n\t\tfor(int j=0;j<c1;j++)if((mask>>j)&1)go[a[j]]=go[b[j]]=0;\n//\t\tprintf(\"m= %d cur= %d\\n\",mask,cur);\n\t\tif(tot&1)ans+=mod-cur;\n\t\telse ans+=cur;\n\t\twhile(ans>=mod)ans-=mod;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000009\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,a[20],b[20],c[20],fa[50],dep[50],cnt[40];\nll ans=0,p[3000005],P[3000005];\nvector<int> A,B;\nint find(int x){\n\tif (fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif (x==y) return ;\n\tif (dep[x]<dep[y]){\n\t\tfa[x]=y;\n\t\treturn ;\n\t}\n\tfa[y]=x;\n\tif (dep[x]==dep[y])\n\t\tdep[x]++;\n}\nll solve(){\n\tmemset(cnt,0,sizeof(cnt));\n\tfor (int i=1;i<=2*m;i++)\n\t\tfa[i]=i;\n\tfor (int i=1;i<=m;i++)\n\t\tif (!c[i]) unite(a[i],b[i]);\n\tfor (int i=1;i<=2*m;i++)\n\t\tcnt[find(i)]++;\n\tint c3=0,c2=0;\n\tfor (int i=1;i<=2*m;i++){\n\t\tif (cnt[i]>3) return 0;\n\t\tif (cnt[i]==3) c3++;\n\t\tif (cnt[i]==2) c2++;\n\t}\n\tint c1=3*n-3*c3-2*c2;\n\tif (c1<c2) return 0;\n\treturn (p[c1]*P[c1-c2])%mod;\n}\nvoid dfs(int now,int cnt){\n\tif (now>m){\n\t\tif (cnt&1)\n\t\t\tans=(ans-solve()+mod)%mod;\n\t\telse\n\t\t\tans=(solve()+ans)%mod;\n\t\treturn ;\n\t}\n\tdfs(now+1,cnt);\n\tif (c[now]){\n\t\tc[now]=0;\n\t\tdfs(now+1,cnt+1);\n\t\tc[now]=1;\n\t}\n}\nll pow(ll x,int y){\n\tll res=1;\n\twhile (y){\n\t\tif (y&1) res=(res*x)%mod;\n\t\tx=(x*x)%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tp[0]=1;\n\tn=read(),m=read();\n\tfor (int i=1;i<=3*n;i++)\n\t\tp[i]=(p[i-1]*(ll) i)%mod;\n\tfor (int i=max(0,3*n-100);i<=3*n;i++)\n\t\tP[i]=pow(p[i],mod-2);\n\tfor (int i=1;i<=m;i++)\n\t\ta[i]=read(),b[i]=read(),c[i]=read();\n\tfor (int i=1;i<=m;i++)\n\t\tA.push_back(a[i]),A.push_back(b[i]);\n\tA.erase(unique(A.begin(),A.end()),A.end());\n\tfor (int i=1;i<=m;i++){\n\t\ta[i]=lower_bound(A.begin(),A.end(),a[i])-A.begin()+1;\n\t\tb[i]=lower_bound(A.begin(),A.end(),b[i])-A.begin()+1;\n\t}\n\tdfs(1,0);\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==2){\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}\n\t\t//ans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\nll MOD = 1e9+9;\ntemplate<typename T> \nconstexpr T modpow(T a,T n,T mod=MOD){//(a^n)%MOD\n    T ret=1;\n    while(n>0){\n        if((n&1)!=0){//n%2==1\n            ret=ret*a%mod;\n        }\n        a=a*a%mod;\n        n=n/2;\n    }\n    return ret;\n}\nstd::vector<long long> fac;\nstd::vector<long long> ifac;\n\ntemplate <typename T>\nT modcomb(T a, T b){\n    if(a == 0 && b == 0)return 1;\n    if(a < b || a < 0)return 0;\n    long long tmp = ifac[a-b]* ifac[b] % MOD;\n    return tmp * fac[a] % MOD;\n}\n\n\nvoid combinit(int maxn){\n    fac.resize(maxn+1);\n    ifac.resize(maxn+1);\n    fac[0] = 1;\n    ifac[0] = 1;\n    for(long long i = 0; i<maxn; i++){\n        fac[i+1] = fac[i]*(i+1) % MOD;\n        ifac[i+1] = ifac[i]*modpow(i+1, MOD-2) % MOD;\n    }\n}\n\nstruct UnionFind {\n  vector< int > data;\n \n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n \n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n \n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n \n  int size(int k) {\n    return (-data[find(k)]);\n  }\n\n};\n\nint main(){\n    ll n , m;\n    cin>>n>>m;\n    combinit( 3*n );\n    //cout<<\"OK\"<<endl;\n    vector<mp> good,bad;\n    set<int> use;\n    for(int i=0;i<m;i++){\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\tuse.insert( a );\n\tuse.insert( b );\n\tif( c == 0 ){\n\t    good.push_back( mp( a , b ) );\n\t}else{\n\t    bad.push_back( mp( a , b ) );\n\t}\n    }\n    //cout<<good.size()<<bad.size()<<endl;\n    map<ll,int> change;\n    int j=0;\n    for(auto i:use){\n\tchange[i] = j++;\n    }\n    //cout<<\"OK\"<<endl;\n    UnionFind uni( j+1 );\n    for(int i=0;i<good.size();i++){\n\tuni.unite( change[ good[i].first] , change[ good[i].second ] );\n    }\n    //ll nkai = 1;\n    //for(int i=2;i<=n;i++) {\n\t//nkai *= i;\n\t//nkai %= MOD;\n    //}\n    //nkai = modpow( nkai , MOD-2 );\n    //for(auto i:use)cout<<i<<' '<<change[i]<<' '<<uni.size( change[i] )<<endl;\n    vector<ll> dp( (1<<bad.size() ) , 1 );\n    for(int i=0;i< ( 1<< bad.size() );i++){\n\tUnionFind tmp = uni;\n\tfor(int j=0;j<bad.size();j++){\n\t    if( (i>>j)&1 ){\n\t\t//cout<<\"LOCK\"<<bad[j].first<<' '<<bad[j].second;\n\t\ttmp.unite( change[bad[j].first] , change[bad[j].second] );\n\t    }\n\t}\n\tll rest = 3*n;\n\t//cout<<rest<<endl;\n\tint cnt2 = 0;\n\tbool flag = false;\n\t//cout<<\"SIZE\"<<use.size()<<endl;\n\tfor(auto j:use){\n\t    if( tmp.find( change[j] ) == change[j] ){\n\t\tint sz = tmp.size( change[j] );\n\t\t//cout<<\"UNION\"<<j<<' '<<change[j]<<' '<<sz<<endl;\n\t\tif( sz == 2 ){\n\t\t    //cout<<\"LL\"<<endl;\n\t\t    rest-=2;\n\t\t    cnt2++;\n\t\t}\n\t\tif( sz == 3 ){\n\t\t    rest-=3;\n\t\t    //cout<<\"OK\"<<endl;\n\t\t}\n\t\tif( sz > 3 ){\n\t\t    dp[i] = 0;\n\t\t    flag = true;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif( flag ) continue;\n\tdp[i] = 1;\n\tfor(int j=0;j<cnt2;j++){\n\t    dp[i]*= rest;\n\t    dp[i]%= MOD;\n\t    rest--;\n\t}\n\tif( rest%3 != 0 ){\n\t    cout<<\"Maybe\"<<endl;\n\t    return 0;\n\t}\n\tll nn = rest/3;\n\tll nkai = ifac[nn];\n\tdp[i]*=nkai;\n\tdp[i]%=MOD;\n\t/*while(rest > 0 ){\n\t    //dp[i]*=modcomb( rest , 3ll );\n\t    dp[i] *=  (rest*(rest-1)*(rest-2)/6)%MOD;\n\t    dp[i]%=MOD;\n\t   // cout<<\"REST\"<<rest<<' '<<dp[i]<<endl;\n\t    rest-=3;\n\t}*/\n\tdp[i]*=fac[rest];\n\tdp[i]%=MOD;\n\tll six = modpow( 6LL ,  nn );\n\tsix = modpow( six , MOD-2 );\n\tdp[i]*=six;\n\tdp[i]%=MOD;\n\t//cout<<i<<' '<<dp[i]<<endl;\n    }\n    ll res = 0;\n    for(int i=0;i<(1<<bad.size() );i++){\n\tint cnt = 0;\n\tfor(int j=0;j<bad.size();j++)if( (i>>j)&1 )cnt++;\n\tif( cnt%2 == 0 ){\n\t    res += dp[i];\n\t    res %= MOD;\n\t}else{\n\t    res +=( MOD-dp[i] );\n\t    res %= MOD;\n\t}\n    }\n    //if( bad.size()%2 == 1 )cout<<(MOD-res)%MOD<<endl;\n     cout<<res<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, int>memo;\nMod getrest(const int rest) {\n\tif (memo.find(rest)!=memo.end()) {\n\t\treturn memo[rest];\n\t}\n\telse {\n\t\tif (rest == 0) {\n\t\t\treturn memo[rest] = 1;\n\t\t}\n\t\telse if (rest < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tMod ans = Mod(rest - 1)*Mod((rest - 2))*getrest(rest - 3)/Mod(2);\n\t\t\treturn memo[rest] = ans;\n\t\t}\n\t}\n}\nMod getans(map<int,int>mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second>=2){\n\t\t}\n\t\telse {\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp,int rest) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n >= 2) {\n\t\t\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}\n\t\t\t//ans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-n);\n\t\t\tif (rest < 0)return 0;\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\ninline char nc(){\n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2)  return EOF; }\n  return *p1++;\n}\n\ninline void read(int &x){\n  char c=nc(),b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\nconst int N=3000005;\n\nstruct modi{  \n  int x,y,r;  \n}Stk[N]; int pnt;  \nint fat[N],rnk[N],size[N];  \n  \ninline int Fat(int u){  \n  return u==fat[u]?u:Fat(fat[u]);  \n}\n\nint cot[N];\nint flag=0;\n\ninline int Merge(int x,int y){  \n  x=Fat(x); y=Fat(y); if (x==y) return 0;  \n  if (rnk[x]>rnk[y]) swap(x,y);  \n  Stk[++pnt].x=x; Stk[pnt].y=y; Stk[pnt].r=0;  \n  if (rnk[x]==rnk[y]) rnk[y]++,Stk[pnt].r=1;  \n  fat[x]=y; cot[size[y]]--; cot[size[x]]--; size[y]+=size[x]; cot[size[y]]++;\n  if (size[y]>3) flag=1;\n  return 1;  \n}\n\ninline void Back(int t){  \n  for (;pnt>t;pnt--){\n    int x=Stk[pnt].x,y=Stk[pnt].y;\n    fat[Stk[pnt].x]=Stk[pnt].x;  \n    if (Stk[pnt].r) rnk[Stk[pnt].y]--;\n    cot[size[y]]--; size[y]-=size[x]; \n    cot[size[y]]++; cot[size[x]]++; \n  }  \n}\n\nconst ll P=1e9+9;\n\nll fac[N],inv[N],iinv[N];\n\nint tot;\nint us[20],vs[20],ws[20];\nint n,m;\n\ninline ll Pow(ll a,int b){\n  ll ret=1;\n  for (;b;b>>=1,a=a*a%P)\n    if (b&1)\n      ret=ret*a%P;\n  return ret;\n}\n\ninline void Pre(int n){  \n  fac[0]=1; for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%P;\n  inv[0]=1; for (int i=1;i<=n/3;i++) (inv[i]=inv[i-1]*6)%=P;\n  for (int i=1;i<=n/3;i++) inv[i]=Pow(inv[i],P-2);\n  iinv[1]=1; for (int i=2;i<=n;i++) iinv[i]=(P-P/i)*iinv[P%i]%P;  \n  iinv[0]=1; for (int i=1;i<=n;i++) iinv[i]=iinv[i]*iinv[i-1]%P;  \n}\n\ninline ll Calc(int a,int b,int c){\n  if (b>a) return 0;\n  return fac[a]*inv[(a-b)/3]%P*iinv[(a-b)/3]%P;\n}\n\nint main(){\n  read(n); read(m); n*=3;\n  Pre(n);\n  tot=0;\n  for (int i=1;i<=n;i++) fat[i]=i,size[i]=1;\n  flag=0; cot[1]=n;\n  for (int i=1;i<=m;i++){\n    ++tot;\n    read(us[tot]),read(vs[tot]),read(ws[tot]);\n    if (ws[tot]==0)\n      Merge(us[tot],vs[tot]),tot--;      \n  }\n  if (flag){\n    printf(\"0\\n\");\n    return 0;\n  }\n  ll Ans=Calc(cot[1],cot[2],cot[3]);\n  int tmp=pnt;\n  for (int i=1;i<(1<<tot);i++){\n    flag=0; int c=0;\n    for (int j=1;j<=tot;j++)\n      if (i>>(j-1)&1)\n\tMerge(us[j],vs[j]),c++;   \n    if (!flag){\n      if (c&1)\n\t(Ans+=P-Calc(cot[1],cot[2],cot[3]))%=P;\n      else\n\t(Ans+=Calc(cot[1],cot[2],cot[3]))%=P;\n    }\n    Back(tmp);\n  }\n  printf(\"%lld\\n\",Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n\n    if(n<cnt)return 0;\n    \n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tcin >> N >> M;\n\n\tfor (int i = 1; i <= 1e6 + 1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcountll(i)%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define vi vector<int>\n#define pr pair<int,int>\n#define Rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define For(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define debug(x) {cout<<(#x)<<\" \"<<x<<endl;}\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=40,INF=9999999;\nconst ll P=1e9+9;\n\ntemplate<typename T>\ninline void read(T& x,char s=getchar()) {\n\tx=0;\n\twhile(s>'9'||s<'0') s=getchar();\n\twhile(s<='9'&&s>='0') x=x*10+s-'0',s=getchar();\n}\n\ninline ll _pow(ll a,ll b,ll r=1) {\n\twhile(b) {\n\t\tif(b&1) (r*=a)%=P;\n\t\t(a*=a)%=P;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nvector<pr> a,b;\nmap<int,int> ma;\nint cnt;\nint c[N];\nint fa[N];\nll js[3000005];\n\ninline int find(int x) {\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\n\ninline void unionn(int x,int y) {\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx!=fy) fa[fy]=fx;\n}\n\nint main() {\n\tint n,m,x,y,t;\n\tll ans=0;\n\tcin>>n>>m;\n\tjs[0]=1;\n\tfor(int i=1;i<=3*n;i++) {\n\t\tjs[i]=js[i-1]*i%P;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>x>>y>>t;\n\t\tif(ma.count(x)) x=ma[x];\n\t\telse ma[x]=++cnt,x=cnt;\n\t\tif(ma.count(y)) y=ma[y];\n\t\telse ma[y]=++cnt,y=cnt;\n\t\t\n\t\tif(t==0) {\n\t\t\ta.pb(mp(x,y));\n\t\t}\n\t\telse {\n\t\t\tb.pb(mp(x,y));\n\t\t}\n\t}\n\tfor(int j=0;j<(1<<b.size());j++) {\n\t\tint num=0;\n\t\tfor(int i=1;i<=cnt;i++) fa[i]=i;\n\t\tfor(int i=0;i<a.size();i++) {\n\t\t\tunionn(a[i].x,a[i].y);\n\t\t}\n\t\tfor(int i=0;i<b.size();i++) {\n\t\t\tif(j&(1<<i)) {\n\t\t\t\tnum++;\n\t\t\t\tunionn(b[i].x,b[i].y);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"num: \"<<j<<\" \"<<num<<endl;\n\t\tnum=num&1?-1:1;\n\t\t\n//\t\tcout<<num<<\": \";\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(int i=1;i<=cnt;i++) {\n\t\t\tc[fa[i]]++;\n\t\t}\n\t\tint _n=n;\n\t\tint qindian=0;\n\t\tll tot=1;\n\t\tfor(int i=1;i<=cnt;i++) {\n//\t\t\tcout<<c[i]<<\" \";\n\t\t\tif(c[i]>3) {\n\t\t\t\ttot=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[i]==0) continue;\n\t\t\tif(c[i]==3) _n--;\n\t\t\tif(c[i]==2) qindian++;\n\t\t}\n//\t\tcout<<endl;\n\t\t\n\t\tif(tot==0) continue;\n\t\t\n//\t\tll test=_pow(6,P-2)*6%P;\n//\t\tcout<<\"-==>\"<<test<<endl;\n\t\t\n\t\ttot=js[_n*3-qindian*2]*_pow(js[_n*3-qindian*3],P-2)%P;\n//\t\tcout<<\"-->\"<<_n*3-qindian*2<<\" \"<<_n*3-qindian*3<<endl;\n//\t\tcout<<\"-->\"<<js[_n*3-qindian*2]<<\" \"<<js[_n*3-qindian*3]<<endl;\n//\t\tcout<<\"-->\"<<tot<<endl;\n\t\t_n-=qindian;\n\t\ttot=(tot*js[_n*3]*_pow(_pow(6,_n),P-2)%P);\n\t\tans=(ans+P+num*tot)%P;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n10003 2\n1 2 0\n3 4 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n//#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define MOD 1000000009\n#define NUM 18\n#define SIZE 3000000\n\nstruct Info{\n\tInfo(){\n\t\tfrom = 0;\n\t\tto = 0;\n\t}\n\tInfo(int arg_from,int arg_to){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t}\n\tint from,to;\n};\n\nll N,M;\nint connect_num;\nint POW[NUM+1];\nint good_table[NUM],bad_table[NUM];\nll fact[SIZE+1],dp[SIZE/3+1];\nInfo info[NUM];\nbool visited[SIZE];\nvector<int> G[SIZE];\n\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n\tll d = a;\n\tif(b != 0){\n\t\td = extgcd(b,a%b,y,x);\n\t\ty -= (a/b)*x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te = 0;\n\tif(n == 0)return 1;\n\n\tint res = mod_fact(n/p,p,e);\n\te += n/p;\n\n\tif(n/p%2 != 0)return res*(p-fact[n%p])%p;\n\treturn res*fact[n%p]%p;\n}\n\nll nCm(ll n,ll m,ll p){\n   if(n < m) return 0;\n   ll e1,e2,e3;\n    ll a1 = mod_fact(n,p,e1),a2 = mod_fact(m,p,e2),a3 = mod_fact(n-m,p,e3);\n    if(e1 > e2+e3)return 0;\n    return a1 * mod_inverse(a2*a3%p,p)%p;\n}\n\nvoid recursive(int node_id){\n\n\tvisited[node_id] = true;\n\tconnect_num++;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(visited[G[node_id][i]])continue;\n\t\trecursive(G[node_id][i]);\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i <= NUM; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%lld %lld\",&N,&M);\n\n\tfact[0] = 1;\n\tfor(ll i = 1; i <= 3*N; i++){\n\t\tfact[i] = i*fact[i-1];\n\t\tfact[i] %= MOD;\n\t}\n\n\tdp[0] = 1;\n\tfor(ll i = 1; i <= N; i++){\n\t\tdp[i] = nCm(i*3,3,MOD)*dp[i-1];\n\t\tdp[i] %= MOD;\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tdp[i] *= mod_inverse(fact[i],MOD);\n\t\tdp[i] %= MOD;\n\t}\n\n\tint num_good = 0,num_bad = 0;\n\tint relation;\n\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d %d %d\",&info[i].from,&info[i].to,&relation);\n\t\tinfo[i].from--;\n\t\tinfo[i].to--;\n\n\t\tif(relation == 0){\n\n\t\t\tgood_table[num_good++] = i;\n\n\t\t}else{\n\n\t\t\tbad_table[num_bad++] = i;\n\t\t}\n\t}\n\n\tll ans = 0;\n\tint tmp_bad_count,tmp_index;\n\tll num[4],tmp;\n\tbool FLG;\n\tqueue<int> Q,DEL_Q;\n\n\tfor(int i = 0; i < 3*N; i++)visited[i] = false;\n\n\tfor(int state = 0; state < POW[num_bad]; state++){\n\n\t\ttmp_bad_count = 0;\n\t\twhile(!Q.empty())Q.pop();\n\n\t\tfor(int loop = 0; loop < num_good; loop++){\n\n\t\t\ttmp_index = good_table[loop];\n\t\t\tG[info[tmp_index].from].push_back(info[tmp_index].to);\n\t\t\tG[info[tmp_index].to].push_back(info[tmp_index].from);\n\n\t\t\tQ.push(info[tmp_index].from);\n\t\t\tQ.push(info[tmp_index].to);\n\n\t\t\tDEL_Q.push(info[tmp_index].from);\n\t\t\tDEL_Q.push(info[tmp_index].to);\n\t\t}\n\n\t\tfor(int loop = 0; loop < num_bad; loop++){\n\t\t\tif(state & (1 << loop)){\n\n\t\t\t\ttmp_index = bad_table[loop];\n\t\t\t\tG[info[tmp_index].from].push_back(info[tmp_index].to);\n\t\t\t\tG[info[tmp_index].to].push_back(info[tmp_index].from);\n\n\t\t\t\tQ.push(info[tmp_index].from);\n\t\t\t\tQ.push(info[tmp_index].to);\n\n\t\t\t\tDEL_Q.push(info[tmp_index].from);\n\t\t\t\tDEL_Q.push(info[tmp_index].to);\n\n\t\t\t\ttmp_bad_count++;\n\t\t\t}\n\t\t}\n\n\t\tFLG = true;\n\t\tfor(int i = 1; i <= 3; i++)num[i] = 0;\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp_index = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(visited[tmp_index])continue;\n\n\t\t\tconnect_num = 0;\n\t\t\trecursive(tmp_index);\n\n\t\t\tif(connect_num >= 4){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnum[connect_num]++;\n\t\t}\n\n\t\tnum[1] = 3*N-2*num[2]-3*num[3];\n\n\t\tif(num[1] < num[2]){\n\t\t\tFLG = false;\n\t\t}\n\n\t\tif(FLG){\n\n\t\t\ttmp = 1;\n\t\t\tfor(int i = 0; i < num[2]; i++){\n\t\t\t\ttmp *= (num[1]-i);\n\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t\ttmp *= dp[(num[1]-num[2])/3];\n\t\t\ttmp %= MOD;\n\n\t\t\tif(tmp_bad_count%2 == 1){\n\n\t\t\t\tans -= tmp;\n\t\t\t\tif(ans < 0)ans += MOD;\n\n\t\t\t}else{\n\n\t\t\t\tans += tmp;\n\t\t\t\tans %= MOD;\n\n\t\t\t}\n\t\t}\n\n\t\twhile(!DEL_Q.empty()){\n\n\t\t\ttmp_index = DEL_Q.front();\n\t\t\tDEL_Q.pop();\n\n\t\t\tG[tmp_index].clear();\n\t\t\tvisited[tmp_index] = false;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    assert(0<=n&&n<=3*N);\n    //assert(n-cnt>=0);\n    //assert((n-cnt)%3==0);\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n  //  assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t/*\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}*/\n\t\tMod a = n==2?rest:1;\n\t\tMod b = a;\n\t\twhile (a != b) {\n\t\t\tcout << 22 << endl;\n\t\t}\n\t\tans *= a;\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\ninline char nc(){\n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2)  return EOF; }\n  return *p1++;\n}\n\ninline void read(int &x){\n  char c=nc(),b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\nconst int N=3000005;\n\nstruct modi{  \n  int x,y,r;  \n}Stk[N]; int pnt;  \nint fat[N],rnk[N],size[N];  \n  \ninline int Fat(int u){  \n  return u==fat[u]?u:Fat(fat[u]);  \n}\n\nint cot[N];\nint flag=0;\n\ninline int Merge(int x,int y){  \n  x=Fat(x); y=Fat(y); if (x==y) return 0;  \n  if (rnk[x]>rnk[y]) swap(x,y);  \n  Stk[++pnt].x=x; Stk[pnt].y=y; Stk[pnt].r=0;  \n  if (rnk[x]==rnk[y]) rnk[y]++,Stk[pnt].r=1;  \n  fat[x]=y; cot[size[y]]--; cot[size[x]]--; size[y]+=size[x]; cot[size[y]]++;\n  if (size[y]>3) flag=1;\n  return 1;  \n}\n\ninline void Back(int t){  \n  for (;pnt>t;pnt--){\n    int x=Stk[pnt].x,y=Stk[pnt].y;\n    fat[Stk[pnt].x]=Stk[pnt].x;  \n    if (Stk[pnt].r) rnk[Stk[pnt].y]--;\n    cot[size[y]]--; size[y]-=size[x]; \n    cot[size[y]]++; cot[size[x]]++; \n  }  \n}\n\nconst ll P=1e9+9;\n\nll fac[N],inv[N];\n\nint tot;\nint us[20],vs[20],ws[20];\nint n,m;\n\ninline ll Pow(ll a,int b){\n  ll ret=1;\n  for (;b;b>>=1,a=a*a%P)\n    if (b&1)\n      ret=ret*a%P;\n  return ret;\n}\n\ninline void Pre(int n){  \n  fac[0]=1; for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%P;\n  inv[0]=1; for (int i=1;i<=n/3;i++) (inv[i]=inv[i-1]*6)%=P;\n  for (int i=1;i<=n/3;i++) inv[i]=Pow(inv[i],P-2);\n}\n\ninline ll Calc(int a,int b,int c){\n  if (b>a) return 0;\n  return fac[a]*inv[(a-b)/3]%P;\n}\n\nint main(){\n  read(n); read(m); n*=3;\n  Pre(n);\n  tot=0;\n  for (int i=1;i<=n;i++) fat[i]=i,size[i]=1;\n  flag=0; cot[1]=n;\n  for (int i=1;i<=m;i++){\n    ++tot;\n    read(us[tot]),read(vs[tot]),read(ws[tot]);\n    if (ws[tot]==0)\n      Merge(us[tot],vs[tot]),tot--;      \n  }\n  if (flag){\n    printf(\"0\\n\");\n    return 0;\n  }\n  ll Ans=Calc(cot[1],cot[2],cot[3]);\n  int tmp=pnt;\n  for (int i=1;i<(1<<tot);i++){\n    flag=0; int c=0;\n    for (int j=1;j<=tot;j++)\n      if (i>>(j-1)&1)\n\tMerge(us[j],vs[j]),c++;   \n    if (!flag){\n      if (c&1)\n\t(Ans+=P-Calc(cot[1],cot[2],cot[3]))%=P;\n      else\n\t(Ans+=Calc(cot[1],cot[2],cot[3]))%=P;\n    }\n    Back(tmp);\n  }\n  printf(\"%lld\\n\",Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tif (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=3000000+10,mod=1e9+9;\nstruct ufsstr\n{\n    int fa,rk,siz;\n} ufs[maxn];\nLL ans=0,inv6,fac[maxn],inv[maxn];\nint tot=0,top=0,cnt[maxn],n,m,id[maxn],a[maxn],b[maxn],c[maxn];\nstruct\n{\n    int u,v;\n    ufsstr su,sv;\n}backup[maxn];\nLL power(LL x,int p)\n{\n    if(p==1) return x;\n    if(p==0) return 1;\n    LL t=power(x,p>>1);\n    t=t*t%mod;\n    if(p&1) t=t*x%mod;\n    return t;\n}\nint getf(int x)\n{\n    while(ufs[x].fa!=x)x=ufs[x].fa;\n    return x;\n}\nvoid mg(int u,int v)\n{\n    u=getf(u);v=getf(v);\n    if(ufs[u].rk>ufs[v].rk) swap(u,v);\n    backup[++top].u=u;\n    backup[top].v=v;\n    backup[top].su=ufs[u];\n    backup[top].sv=ufs[v];\n    cnt[ufs[u].siz]--;cnt[ufs[v].siz]--;\n    ufs[v].siz+=ufs[u].siz;\n    cnt[ufs[v].siz]++;\n    ufs[u].fa=v;\n    if(ufs[u].rk==ufs[v].rk) ufs[v].rk++;\n}\nvoid goback()\n{\n    cnt[ufs[backup[top].v].siz]--;\n    ufs[backup[top].u]=backup[top].su;\n    ufs[backup[top].v]=backup[top].sv;\n    cnt[backup[top].su.siz]++;cnt[backup[top].sv.siz]++;\n}\nLL calc()\n{\n    if(cnt[1]+cnt[2]*2+cnt[3]*3<n||cnt[1]<cnt[2]) return 0;\n    return fac[cnt[1]]*power(inv6,(cnt[1]-cnt[2])/3)%mod*inv[(cnt[1]-cnt[2])/3]%mod;\n}\nvoid dfs(int step,int cnt)\n{\n    if(step>tot)\n    {\n        if(cnt%2==1)ans-=calc();else ans+=calc();\n        return;\n    }\n    mg(a[id[step]],b[id[step]]);\n    dfs(step+1,cnt+1);\n    goback();\n    dfs(step+1,cnt);\n}\nint main()\n{\n    inv6=power(6,mod-2);\n    cin>>n>>m;n*=3;\n    fac[0]=1;\n    for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n    inv[n]=power(fac[n],mod-2);\n    for(int i=n-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    for(int i=1;i<=m;i++) cin>>a[i]>>b[i]>>c[i];\n    for(int i=1;i<=n;i++) ufs[i].fa=i,ufs[i].siz=1,ufs[i].rk=1;\n    cnt[1]=n;\n    for(int i=1;i<=m;i++) if(c[i]==0) mg(a[i],b[i]);else id[++tot]=i;\n    dfs(1,0);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, Mod>memo;\nMod getrest(const int rest) {\n\tif (memo.find(rest)!=memo.end()) {\n\t\treturn memo[rest];\n\t}\n\telse {\n\t\tif (rest == 0) {\n\t\t\treturn memo[rest] = 1;\n\t\t}\n\t\telse if (rest < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tMod ans = Mod(rest - 1)*Mod((rest - 2))*getrest(rest - 3)/Mod(2);\n\t\t\treturn memo[rest] = ans;\n\t\t}\n\t}\n}\nvector<\nMod getans(map<int,int>mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==1){\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= dp[rest / 3];\n\treturn ans;\n}\nint main() {\n\tcin >> N >> M;\n\tdp[0] = 1;\n\tfor (int i = 1; i <= N+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tvector<rel>hates;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tcin >> N >> M;\n\n\tfor (int i = 1; i <= N+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t/*\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}*/\n\t\tans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mod 1000000009\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,a[20],b[20],c[20],fa[50],dep[50],cnt[50];\nll ans=0,p[3000005],P[3000005],X[1000005],Y[1000005];\nvector<int> A,B;\nint find(int x){\n\tif (fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif (x==y) return ;\n\tif (dep[x]<dep[y]){\n\t\tfa[x]=y;\n\t\treturn ;\n\t}\n\tfa[y]=x;\n\tif (dep[x]==dep[y])\n\t\tdep[x]++;\n}\nll solve(){\n\tmemset(cnt,0,sizeof(cnt));\n\tfor (int i=1;i<=45;i++)\n\t\tfa[i]=i;\n\tfor (int i=1;i<=m;i++)\n\t\tif (!c[i]) unite(a[i],b[i]);\n\tfor (int i=1;i<=45;i++)\n\t\tcnt[find(i)]++;\n\tint c3=0,c2=0;\n\tfor (int i=1;i<=45;i++){\n\t\tif (cnt[i]>3) return 0;\n\t\tif (cnt[i]==3) c3++;\n\t\tif (cnt[i]==2) c2++;\n\t}\n\tint c1=3*n-3*c3-2*c2;\n\tif (c1<c2) return 0;\n\tll res=(p[c1]*P[c1-c2])%mod;\n\tres=(res*p[c1-c2])%mod;\n\tres=(res*X[(c1-c2)/3])%mod;\n\tres=(res*Y[(c1-c2)/3])%mod;\n\treturn res;\n}\nvoid dfs(int now,int cnt){\n\tif (now>m){\n\t\tif (cnt&1)\n\t\t\tans=(ans-solve()+mod)%mod;\n\t\telse\n\t\t\tans=(solve()+ans)%mod;\n\t\treturn ;\n\t}\n\tdfs(now+1,cnt);\n\tif (c[now]){\n\t\tc[now]=0;\n\t\tdfs(now+1,cnt+1);\n\t\tc[now]=1;\n\t}\n}\nll pow(ll x,int y){\n\tll res=1;\n\twhile (y){\n\t\tif (y&1) res=(res*x)%mod;\n\t\tx=(x*x)%mod;\n\t\ty>>=1;\n\t}\n\treturn res%mod;\n}\nint main(){\n\tp[0]=1;\n\tn=read(),m=read();\n\tfor (int i=1;i<=3*n;i++)\n\t\tp[i]=(p[i-1]*(ll) i)%mod;\n\tfor (int i=max(0,3*n-100);i<=3*n;i++)\n\t\tP[i]=pow(p[i],mod-2);\n\tfor (int i=max(0,n-100);i<=n;i++)\n\t\tX[i]=pow(p[i],mod-2);\n\tfor (int i=max(0,n-100);i<=n;i++)\n\t\tY[i]=pow(pow((ll) 6,i),mod-2);\n\tfor (int i=1;i<=m;i++)\n\t\ta[i]=read(),b[i]=read(),c[i]=read();\n\tfor (int i=1;i<=m;i++)\n\t\tA.push_back(a[i]),A.push_back(b[i]);\n\tsort(A.begin(),A.end());\n\tA.erase(unique(A.begin(),A.end()),A.end());\n\tfor (int i=1;i<=m;i++){\n\t\ta[i]=lower_bound(A.begin(),A.end(),a[i])-A.begin()+1;\n\t\tb[i]=lower_bound(A.begin(),A.end(),b[i])-A.begin()+1;\n\t}\n\tdfs(1,0);\n\tprintf (\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\ninline char nc(){\n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2)  return EOF; }\n  return *p1++;\n}\n\ninline void read(int &x){\n  char c=nc(),b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\nconst int N=3000005;\n\nstruct modi{  \n  int x,y,r;  \n}Stk[N]; int pnt;  \nint fat[N],rnk[N],size[N];  \n  \ninline int Fat(int u){  \n  return u==fat[u]?u:Fat(fat[u]);  \n}\n\nint cot[N];\nint flag=0;\n\ninline int Merge(int x,int y){  \n  x=Fat(x); y=Fat(y); if (x==y) return 0;  \n  if (rnk[x]>rnk[y]) swap(x,y);  \n  Stk[++pnt].x=x; Stk[pnt].y=y; Stk[pnt].r=0;  \n  if (rnk[x]==rnk[y]) rnk[y]++,Stk[pnt].r=1;  \n  fat[x]=y; cot[size[y]]--; cot[size[x]]--; size[y]+=size[x]; cot[size[y]]++;\n  if (size[y]>3) flag=1;\n  return 1;  \n}\n\ninline void Back(int t){  \n  for (;pnt>t;pnt--){\n    int x=Stk[pnt].x,y=Stk[pnt].y;\n    fat[Stk[pnt].x]=Stk[pnt].x;  \n    if (Stk[pnt].r) rnk[Stk[pnt].y]--;\n    cot[size[y]]--; size[y]-=size[x]; \n    cot[size[y]]++; cot[size[x]]++; \n  }  \n}\n\nconst ll P=1e9+9;\n\nll fac[N],inv[N],iinv[N];\n\nint tot;\nint us[20],vs[20],ws[20];\nint n,m;\n\ninline ll Pow(ll a,int b){\n  ll ret=1;\n  for (;b;b>>=1,a=a*a%P)\n    if (b&1)\n      ret=ret*a%P;\n  return ret;\n}\n\ninline void Pre(int n){  \n  fac[0]=1; for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%P;\n  inv[0]=1; for (int i=1;i<=n/3;i++) (inv[i]=inv[i-1]*6)%=P;\n  for (int i=1;i<=n/3;i++) inv[i]=Pow(inv[i],P-2);\n  iinv[1]=1; for (int i=2;i<=n;i++) iinv[i]=(P-P/i)*iinv[P%i]%P;  \n  iinv[0]=1; for (int i=1;i<=n;i++) iinv[i]=iinv[i]*iinv[i-1]%P;  \n}\n\ninline ll Calc(int a,int b,int c){\n  if (b>a) return 0;\n  return fac[a]*inv[(a-b)/3]%P*iinv[(a-b)/3]%P;\n}\n\nint main(){\n  read(n); read(m); n*=3;\n  Pre(n);\n  tot=0;\n  for (int i=1;i<=n;i++) fat[i]=i,size[i]=1;\n  flag=0; cot[1]=n;\n  for (int i=1;i<=m;i++){\n    ++tot;\n    read(us[tot]),read(vs[tot]),read(ws[tot]);\n    if (ws[tot]==0)\n      Merge(us[tot],vs[tot]),tot--;      \n  }\n  if (flag){\n    printf(\"0\\n\");\n    return 0;\n  }\n  ll Ans=Calc(cot[1],cot[2],cot[3]);\n  int tmp=pnt;\n  for (int i=1;i<(1<<tot);i++){\n    flag=0; int c=0;\n    for (int j=1;j<=tot;j++)\n      if (i>>(j-1)&1)\n\tMerge(us[j],vs[j]),c++;   \n    if (!flag){\n      if (c&1)\n\t(Ans+=P-Calc(cot[1],cot[2],cot[3]))%=P;\n      else\n\t(Ans+=Calc(cot[1],cot[2],cot[3]))%=P;\n    }\n    Back(tmp);\n  }\n  printf(\"%lld\\n\",Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define vi vector<int>\n#define pr pair<int,int>\n#define Rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define For(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define debug(x) {cout<<(#x)<<\" \"<<x<<endl;}\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=40,INF=9999999;\nconst ll P=1e9+7;\n\ntemplate<typename T>\ninline void read(T& x,char s=getchar()) {\n\tx=0;\n\twhile(s>'9'||s<'0') s=getchar();\n\twhile(s<='9'&&s>='0') x=x*10+s-'0',s=getchar();\n}\n\ninline ll _pow(ll a,ll b,ll r=1) {\n\twhile(b) {\n\t\tif(b&1) (r*=a)%=P;\n\t\t(a*=a)%=P;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nvector<pr> a,b;\nmap<int,int> ma;\nint cnt;\nint c[N];\nint fa[N];\nll js[N];\n\ninline int find(int x) {\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\n\ninline void unionn(int x,int y) {\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx!=fy) fa[fy]=fx;\n}\n\nint main() {\n\tint n,m,x,y,t;\n\tint ans=0;\n\tcin>>n>>m;\n\tjs[0]=1;\n\tfor(int i=1;i<=3*n;i++) {\n\t\tjs[i]=js[i-1]*i%P;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>x>>y>>t;\n\t\tif(ma.count(x)) x=ma[x];\n\t\telse ma[x]=++cnt;\n\t\tif(ma.count(y)) y=ma[y];\n\t\telse ma[y]=++cnt;\n\t\t\n\t\tif(t==0) {\n\t\t\ta.pb(mp(x,y));\n\t\t}\n\t\telse {\n\t\t\tb.pb(mp(x,y));\n\t\t}\n\t}\n\tfor(int j=0;j<(1<<b.size());j++) {\n\t\tint num=0;\n\t\tfor(int i=1;i<=cnt;i++) fa[i]=i;\n\t\tfor(int i=0;i<a.size();i++) {\n\t\t\tunionn(a[i].x,a[i].y);\n\t\t}\n\t\tfor(int i=0;i<b.size();i++) {\n\t\t\tif(j&(1<<i)) {\n\t\t\t\tnum++;\n\t\t\t\tunionn(b[i].x,b[i].y);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"num: \"<<j<<\" \"<<num<<endl;\n\t\tnum=num&1?-1:1;\n\t\t\n//\t\tcout<<num<<\": \";\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(int i=1;i<=cnt;i++) {\n\t\t\tc[fa[i]]++;\n\t\t}\n\t\tint _n=n;\n\t\tint qindian=0;\n\t\tll tot=1;\n\t\tfor(int i=1;i<=cnt;i++) {\n//\t\t\tcout<<c[i]<<\" \";\n\t\t\tif(c[i]>3) {\n\t\t\t\ttot=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[i]==0) continue;\n\t\t\tif(c[i]==3) _n--;\n\t\t\tif(c[i]==2) qindian++;\n\t\t}\n//\t\tcout<<endl;\n\t\t\n\t\tif(tot==0) continue;\n\t\t\n\t\tll test=_pow(6,P-2)*6%P;\n//\t\tcout<<\"-==>\"<<test<<endl;\n\t\t\n\t\ttot=js[_n*3-qindian*2]*_pow(js[_n*3-qindian*3],P-2)%P;\n//\t\tcout<<\"-->\"<<_n*3-qindian*2<<\" \"<<_n*3-qindian*3<<endl;\n//\t\tcout<<\"-->\"<<js[_n*3-qindian*2]<<\" \"<<js[_n*3-qindian*3]<<endl;\n//\t\tcout<<\"-->\"<<tot<<endl;\n\t\t_n-=qindian;\n\t\ttot=(tot*js[_n*3]*_pow(_pow(6,_n),P-2)%P);\n\t\tans=(ans+P+num*tot)%P;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tif (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, int> dict(const vector<T> &v){\n  map<T, int> res;\n  for(int i=0;i<(int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m),b(m),c(m);\n  for(int i=0;i<m;i++) cin>>a[i]>>b[i]>>c[i];\n  UnionFind uf(3*n);\n  for(int i=0;i<m;i++){\n    a[i]--;b[i]--;\n    if(c[i]==0) uf.unite(a[i],b[i]); \n  }\n  \n  int one=0,two=0;\n  for(int i=0;i<3*n;i++){\n    if(uf.find(i)!=i) continue;\n    if(uf.r[i]>3){\n      cout<<0<<endl;\n      return 0;\n    }\n    if(uf.r[i]==1) one++;\n    if(uf.r[i]==2) two++;\n  }\n  \n  using P = pair<int, int>;\n  vector<P> ps;\n  for(int i=0;i<m;i++){\n    if(c[i]==0) continue;\n    if(uf.same(a[i],b[i])){\n      cout<<0<<endl;\n      return 0;\n    }\n    int x=uf.find(a[i]),y=uf.find(b[i]);\n    if(x>y) swap(x,y);\n    if(uf.r[x]+uf.r[y]<=3)\n      ps.emplace_back(x,y);\n  }\n  ps=compress(ps);\n  int w=ps.size();\n  \n  using M = Mint<int, int(1e9+7)>;\n  M ans;\n  vector<M> po(n<<1,1);\n  M r6=M(6).inv();\n  for(int i=1;i<(int)po.size();i++) po[i]=po[i-1]*r6;\n  M::init(n<<2);\n\n  vector<int> vs;\n  for(auto p:ps){\n    vs.emplace_back(p.first);\n    vs.emplace_back(p.second);    \n  }\n  vs=compress(vs);\n  auto rev=dict(vs);\n  \n  for(int b=0;b<(1<<w);b++){\n    int os=one,ts=two;\n    UnionFind sz(vs.size());\n    for(int i=0;i<(int)vs.size();i++){\n      sz.r[i]=uf.r[vs[i]];\n      if(sz.r[i]==1) os--;\n      if(sz.r[i]==2) ts--;\n    }\n    for(int i=0;i<w;i++)\n      if((b>>i)&1) sz.unite(rev[ps[i].first],rev[ps[i].second]);\n    \n    int flg=0;\n    for(int i=0;i<(int)vs.size();i++){\n      if(sz.find(i)!=i) continue;\n      flg|=sz.r[i]>3;      \n      if(sz.r[i]==1) os++;\n      if(sz.r[i]==2) ts++;\n    }\n    //cout<<flg<<\":\"<<os<<\" \"<<ts<<endl;\n    if(flg||ts>os) continue;\n    M res=M::P(os,ts);    \n    res*=M::fact[os-ts]*po[(os-ts)/3];\n    ans+=__builtin_parity(b)?-res:res;\n  }\n\n  cout<<ans.v<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\nusing ll = long long int;\nconst ll MOD = 1000000009;\n\n// Union-Find  (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int size_;\n    vector<int> uf;\npublic:\n    //  UnionFind uni(n) \n    UnionFind(int _n) : n(_n), size_(_n), uf(_n, -1) {}\n    // find ()\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x  y \n    bool same(int x, int y) {return find(x) == find(y);}\n    // x \n    int size(int x) {return -uf[find(x)];}\n    // \n    int size()      {return size_;}\n    // x  y \n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        size_--;\n        if(-uf[x] < -uf[y]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n        return true;\n    }\n};\n\nll mod_pow(ll n, ll k) {\n    ll res = 1;\n    for(; k>0; k>>=1) {\n        if(k & 1) (res *= n) %= MOD;\n        (n *= n) %= MOD;\n    }\n    return res;\n}\n\nconst int MAXN = 4000010;\nll fact[MAXN+5], finv[MAXN+5];\n\nvoid init() {\n    fact[0] = 1;\n    for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1] * i % MOD;\n\n    finv[MAXN] = mod_pow(fact[MAXN], MOD-2);\n    for(int i=MAXN-1; i>=0; i--) finv[i] = finv[i+1] * (i+1) % MOD;\n}\n\nll nPr(int n, int r) {\n    if(n < r or r < 0) return 0;\n    return fact[n] * finv[n-r] % MOD;\n}\n\nll make_group(ll n) {\n    ll g = n / 3;\n    ll inv = mod_pow(mod_pow(6, g), MOD-2);\n    return fact[n] * inv % MOD * finv[g] % MOD;\n}\n\nint main() {\n    init();\n    ll N, M; cin >> N >> M;\n    vector< pair<int, int> > good, bad;\n\n    map<int, int> cmp;\n    for(int i=0; i<M; i++) {\n        int a, b, c; cin >> a >> b >> c; a--; b--;\n        (c == 0 ? good : bad).emplace_back(a, b);\n        cmp[a]++; cmp[b]++;\n    }\n\n    int K = 0;\n    for(auto &e : cmp) e.second = K++;\n\n    for(auto &e : good) e.first = cmp[e.first], e.second = cmp[e.second];\n    for(auto &e : bad ) e.first = cmp[e.first], e.second = cmp[e.second];\n    \n    UnionFind uf(K);\n    for(auto e : good) {\n        int a, b; tie(a, b) = e;\n        uf.unite(a, b);\n    }\n\n    ll ans = 0;\n    vector<bool> used(K);\n    for(int bit=0; bit<(1<<(int)bad.size()); bit++) {\n        fill(used.begin(), used.end(), false);\n        UnionFind uf_c = uf;\n        for(size_t i=0; i<bad.size(); i++) {\n            if(!(bit >> i & 1)) continue;\n            int a, b; tie(a, b) = bad[i];\n            uf_c.unite(a, b);\n        }\n\n        int cnt[5] = {};\n        cnt[1] = 3*N - K;\n        for(int i=0; i<K; i++) {\n            if(used[ uf_c.find(i) ]) continue;\n            used[ uf_c.find(i) ] = true;\n            int sz = uf_c.size(i);\n            cnt[min(4, sz)]++;\n        }\n\n        if(cnt[4] > 0 or cnt[1] < cnt[2]) continue;\n\n        ll add = 1;\n        \n        // 1 2  (cnt[1] P cnt[2])\n        (add *= nPr(cnt[1], cnt[2])) %= MOD;\n        cnt[1] -= cnt[2];\n\n        // 1  3 \n        (add *= make_group(cnt[1])) %= MOD;\n\n        // fprintf(stderr, \"add = %lld\\n\", add);\n        \n        // \n        if(__builtin_parity(bit)) ans = (ans - add + MOD) % MOD;\n        else ans = (ans + add) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[11111111];\nint inv[11111111];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[11111111];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<11111111;i++)fact[i]=fact[i-1]*i%mod;\n    inv[11111111-1]=mpow(fact[11111111-1],mod-2);\n    for(int i=11111111-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<11111111;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcount(i)%2==1)ans+=calc(AA);\n        else ans-=calc(AA);\n    }\n\n    cout<<calc(A)-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\t/*if (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}*/\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t\tif (rest < 0)return 0;\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 1e6+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define vi vector<int>\n#define pr pair<int,int>\n#define Rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define For(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define debug(x) {cout<<(#x)<<\" \"<<x<<endl;}\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=40,INF=9999999;\nconst ll P=1e9+9;\n\ntemplate<typename T>\ninline void read(T& x,char s=getchar()) {\n\tx=0;\n\twhile(s>'9'||s<'0') s=getchar();\n\twhile(s<='9'&&s>='0') x=x*10+s-'0',s=getchar();\n}\n\ninline ll _pow(ll a,ll b,ll r=1) {\n\twhile(b) {\n\t\tif(b&1) (r*=a)%=P;\n\t\t(a*=a)%=P;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nvector<pr> a,b;\nmap<int,int> ma;\nint cnt;\nint c[N];\nint fa[N];\nll js[3000005];\nll fq[3000005];\n\ninline int find(int x) {\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\n\ninline void unionn(int x,int y) {\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx!=fy) fa[fy]=fx;\n}\n\nint main() {\n\tint n,m,x,y,t;\n\tll ans=0;\n\tcin>>n>>m;\n\tjs[0]=fq[0]=1;\n\tfor(int i=1;i<=3*n;i++) {\n\t\tjs[i]=js[i-1]*i%P;\n\t\tif(i%3==0) {\n\t\t\tfq[i]=fq[i-3]*i*2%P; \n\t\t\t//if(i<=10) cout<<fq[i]<<\" \";\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>x>>y>>t;\n\t\tif(ma.count(x)) x=ma[x];\n\t\telse ma[x]=++cnt,x=cnt;\n\t\tif(ma.count(y)) y=ma[y];\n\t\telse ma[y]=++cnt,y=cnt;\n\t\t\n\t\tif(t==0) {\n\t\t\ta.pb(mp(x,y));\n\t\t}\n\t\telse {\n\t\t\tb.pb(mp(x,y));\n\t\t}\n\t}\n\tfor(int j=0;j<(1<<b.size());j++) {\n\t\tll num=0;\n\t\tfor(int i=1;i<=cnt;i++) fa[i]=i;\n\t\tfor(int i=0;i<a.size();i++) {\n\t\t\tunionn(a[i].x,a[i].y);\n\t\t}\n\t\tfor(int i=0;i<b.size();i++) {\n\t\t\tif(j&(1<<i)) {\n\t\t\t\tnum++;\n\t\t\t\tunionn(b[i].x,b[i].y);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"num: \"<<j<<\" \"<<num<<endl;\n\t\tnum=num&1?-1:1;\n\t\t\n//\t\tcout<<num<<\": \";\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(int i=1;i<=cnt;i++) {\n\t\t\tc[fa[i]]++;\n\t\t}\n\t\tint _n=n;\n\t\tint qindian=0;\n\t\tll tot=1;\n\t\tfor(int i=1;i<=cnt;i++) {\n//\t\t\tcout<<c[i]<<\" \";\n\t\t\tif(c[i]>3) {\n\t\t\t\ttot=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[i]==3) _n--;\n\t\t\tif(c[i]==2) qindian++;\n\t\t}\n//\t\tcout<<endl;\n\t\t\n\t\tif(tot==0) continue;\n\t\t\n//\t\tll test=_pow(6,P-2)*6%P;\n//\t\tcout<<\"-==>\"<<test<<endl;\n\t\t\n\t\ttot=js[_n*3-qindian*2]*_pow(js[_n*3-qindian*3],P-2)%P;\n//\t\tcout<<\"-->\"<<_n*3-qindian*2<<\" \"<<_n*3-qindian*3<<endl;\n//\t\tcout<<\"-->\"<<js[_n*3-qindian*2]<<\" \"<<js[_n*3-qindian*3]<<endl;\n//\t\tcout<<\"-->\"<<tot<<endl;\n\t\t_n-=qindian;\n//\t\tcout<<\"__n: \"<<_n<<endl;\n\t\ttot=tot*js[_n*3]%P*_pow(fq[_n*3],P-2)%P;\n//\t\tcout<<\"-->\"<<tot<<endl;\n\t\tans=(ans+P+num*tot)%P;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n2 2\n1 2 0\n3 4 1\n\n10003 2\n1 2 0\n3 4 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    if(A.size()==0)return table[3*N];\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcountll(i)%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t/*if (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}*/\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\t\n\t\tans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcountll(i)%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n    }\n\n    cout<<((calc(A)-ans+mod)%mod+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n   // assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\treturn dp[rest/3];\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tcin >> N >> M;\n\tdp[0] = 1;\n\tfor (int i = 1; i <= N+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tvector<rel>hates;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 3000005\n#define ll long long\n#define mod 1000000009\nint n, m, k, ans;\nint A[20], B[20], C[20];\nint bel[N], sum[N], siz[N];\nint fac[N], inv[N];\nint Getbel(int x)\n{\n\tif (!bel[x])\n\t\treturn x;\n\treturn bel[x] = Getbel(bel[x]);\n}\nint ksm(int a, int k)\n{\n\tif (!k)\n\t\treturn 1;\n\tint p = ksm(a, k / 2);\n\tif (k & 1)\n\t\treturn (ll)p * p % mod * a % mod;\n\treturn (ll)p * p % mod;\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N - 5; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[N - 5] = ksm(fac[N - 5], mod - 2);\n\tfor (int i = N - 5; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &A[i], &B[i], &C[i]);\n\t\tk += C[i];\n\t}\n\tfor (int i = 0; i < (1 << k); i++)\n\t{\n\t\tsum[1] = n * 3;\n\t\tsum[2] = sum[3] = 0;\n\t\tint w = 0;\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tbel[A[j]] = bel[B[j]] = 0;\n\t\t\tsiz[A[j]] = siz[B[j]] = 1;\n\t\t}\n\t\tint flg = 0, bit = 0;\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif (C[j] == 1 && i & (1 << w))\n\t\t\t\tbit++;\n\t\t\tif (C[j] == 0 || (i & (1 << w)))\n\t\t\t{\n\t\t\t\tint x = Getbel(A[j]), y = Getbel(B[j]);\n\t\t\t\tif (x != y)\n\t\t\t\t{\n\t\t\t\t\tbel[x] = y;\n\t\t\t\t\tsum[siz[y]]--;\n\t\t\t\t\tsum[siz[x]]--;\n\t\t\t\t\tsiz[y] += siz[x];\n\t\t\t\t\tif (siz[y] > 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tflg = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum[siz[y]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw += C[j];\n\t\t}\n\t\tif (!flg)\n\t\t{\n\t\t\tint x = sum[1], y = sum[2];\n\t\t\tif (x >= y)\n\t\t\t{\n\t\t\t\tint now = fac[x];\n\t\t\t\tnow = (ll)now * ksm(inv[3], (x - y) / 3) % mod * inv[(x - y) / 3] % mod;\n\t\t\t\tif (bit & 1)\n\t\t\t\t\tans = (ans - now) % mod;\n\t\t\t\telse\n\t\t\t\t\tans = (ans + now) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans < 0)ans += mod;\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tif (rest < 3 - m.second)return 0;\n\t\t\tif (m.second == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}\n\t\t\t//ans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t\tif (rest < 0)return 0;\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<algorithm>\n#include<bitset>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<deque>\n#include<fstream>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<queue>\n#include<set>\n#include<string>\n#include<stack>\n#include<utility>\n#include<vector>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\ntypedef long long ll;\nconst ll mod=1e9+9;\nint kissme(int x,ll k)\n{\n\tint ans=1;\n\twhile(k>0)\n\t{\n\t\tif(k&1)ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nconst int combsz=3000011;\nint fac[combsz],revf[combsz];\nint C(int x,int y){return 1ll*fac[x]*revf[y]%mod*revf[x-y]%mod;}\nvoid combinit_simple()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<combsz;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\trevf[combsz-1]=kissme(fac[combsz-1],mod-2);\n\tfor(int i=combsz-2;i>=0;i--)revf[i]=1ll*revf[i+1]*(i+1)%mod;\n}\nint n,m,idtot;\nmap<int,int> mp;\nint getid(int x)\n{\n\tint &v=mp[x];\n\tif(v==0)v=++idtot;\n\treturn v;\n}\n\nint ex[22],ey[22],type[22];\nint f[66],cnt[66],sz[66];\nint gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}\nvoid un(int x,int y)\n{\n\tx=gf(x);\n\ty=gf(y);\n\tf[x]=y;\n\tsz[y]+=sz[x];\n\tsz[x]=0;\n}\nll check(int msk)\n{\n//\tcout<<\"check:\"<<msk<<endl;\n\tfor(int i=0;i<66;i++)f[i]=i,sz[i]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(type[i]==1||(msk>>i)&1)\n\t\t{\n\t\t\tun(ex[i],ey[i]);\n\t\t}\n\t}\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<min(3*n,66);i++)\n\t{\n\t\tif(sz[i]>3)return 0;\n\t\telse cnt[sz[i]]++;\n\t}\n\tcnt[1]+=max(0,3*n-66);\n//\tcout<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\tif(cnt[2]>cnt[1]||(cnt[1]-cnt[2])%3!=0)return 0;\n\telse \n\t{\n//\t\tcout<<1ll*fac[cnt[1]]*kissme(fac[cnt[1]-cnt[2]],mod-2)%mod<<\" \"<<fac[cnt[1]-cnt[2]]<<\" \"<<kissme(kissme(6,(cnt[1]-cnt[2])/3),mod-2)<<\" \"<<fac[cnt[1]-cnt[2]]*kissme(kissme(6,(cnt[1]-cnt[2])/3),mod-2)%mod<<endl;\n\t\treturn 1ll*fac[cnt[1]]*kissme(fac[cnt[1]-cnt[2]],mod-2)%mod*fac[cnt[1]-cnt[2]]%mod*kissme(kissme(6,(cnt[1]-cnt[2])/3),mod-2)%mod;\n\t}\n}\nint main()\n{\n\tcombinit_simple();\n\tscanf(\"%d%d\",&n,&m);\n\tint tmsk=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y,c;\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tex[i]=getid(x);\n\t\tey[i]=getid(y);\n\t\ttype[i]=c;\n\t\tif(c==0)tmsk|=1<<i;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<(1<<m);i++)\n\t{\n\t\tif((i&tmsk)==i)\n\t\t{\n\t\t\tint coef=1;\n\t\t\tfor(int j=0;j<m;j++)if((i>>j)&1)coef*=-1;\n\t\t\tll tmp=check(i);\n//\t\t\tcout<<\"coef=\"<<coef<<\" tmp=\"<<tmp<<endl;\n\t\t\tans=(ans+mod+coef*tmp)%mod;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[6666666];\nint inv[6666666];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[6666666];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<6666666;i++)fact[i]=fact[i-1]*i%mod;\n    inv[6666666-1]=mpow(fact[6666666-1],mod-2);\n    for(int i=6666666-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<6666666;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcount(i)%2==1)ans+=calc(AA);\n        else ans-=calc(AA);\n    }\n\n    cout<<calc(A)-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n        assert(0<=ans&&ans<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\t\n\t\t//ans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcount(i)%2==1)ans+=calc(AA);\n        else ans-=calc(AA);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\n\n#define MAX_N 1000001\n\ntypedef long long int64;\n\nconst int64 mod = 1e9 + 9;\n\ninline int64 extgcd(int64 a, int64 b, int64 &x, int64 &y) {\n  int64 d = a;\n  if(b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  else x = 1, y = 0;\n  return d;\n}\n\ninline int64 modPow(int64 x, int64 n) {\n  if(n == 0) return 1;\n  int64 ret = modPow(x, n/2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return ret;\n}\n\ninline int64 modInv(int64 a) {\n  return modPow(a, mod - 2);\n}\n\ninline int64 modFact(int n) {\n  int64 ret = 1;\n  while(n > 1) (ret *= n--) %= mod;\n  return ret;\n}\n\ninline int64 modComb(int64 n, int64 r) {\n  static int64 fact[MAX_N], invfact[MAX_N];\n  if(fact[0] == 0) {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < MAX_N; i++) {\n      fact[i] = fact[i-1] * i % mod;\n      invfact[i] = modInv(fact[i]);\n    }\n  }\n  if(r < 0 || n < r) return 0;\n  return fact[n] * invfact[r] % mod * invfact[n-r] % mod;\n}\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y]; data[y] = x;\n    return;\n  }\n};\n\nint calc(int& n, vector<Tapris>& vec) {\n  UnionFind uf(n);\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 0) uf.unite(a, b);\n  }\n  int x = 0, y = 0;\n  set<int> st;\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 1) continue;\n    int p;\n    if((p = uf.find(a)) == a || (p = uf.find(b)) == b) {\n      st.insert(a);\n      st.insert(b);\n      int sz = uf.size(p);\n      if(sz >= 4) return 0;\n      else if(sz == 2) ++y;\n    }\n  }\n  //cout<<n<<endl;\n  x = n - st.size();\n  //cout << x << \" \" << y << endl;\n  if(y > x) return 0;\n  int z = (x-y)/3;\n  //cout<<z<<endl;\n  //cout<<modFact(x)<<\" \"<<modPow(6, z)<<\" \"<<modInv(modPow(6, z))<<\" \"<<modFact(z)<<\" \"<<modInv(modFact(z))<<endl;\n  return modFact(x)*modInv(modPow(3*2*1, z))%mod*modInv(modFact(z))%mod;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  cin >> n >> m;\n  n *= 3;\n  vector<Tapris> vec;\n  vector<int> badidx;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c; --a, --b;\n    vec.emplace_back(a, b, c);\n    if(c == 1) badidx.push_back(i);\n  }\n  //cout<<calc(n, vec)<<endl;\n  int bad = badidx.size();\n  int ans = 0;\n  rep(bit, 1<<bad) {\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 0;\n    if(__builtin_popcount(bit)%2) (ans -= calc(n, vec)) %= mod;\n    else (ans += calc(n, vec)) %= mod;\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 1;\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, Mod>memo;\nMod getrest(const int rest) {\n\tif (memo.find(rest)!=memo.end()) {\n\t\treturn memo[rest];\n\t}\n\telse {\n\t\tif (rest == 0) {\n\t\t\treturn memo[rest] = 1;\n\t\t}\n\t\telse if (rest < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tMod ans = Mod(rest - 1)*Mod((rest - 2))*getrest(rest - 3)/Mod(2);\n\t\t\treturn memo[rest] = ans;\n\t\t}\n\t}\n}\nMod getans(map<int,int>mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==1){\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\n\n#define MAX_N 1000001\n\ntypedef long long int64;\n\nconst int64 mod = 1e9 + 9;\n\ninline int64 extgcd(int64 a, int64 b, int64 &x, int64 &y) {\n  int64 d = a;\n  if(b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  else x = 1, y = 0;\n  return d;\n}\n\ninline int64 modPow(int64 x, int64 n) {\n  if(n == 0) return 1;\n  int64 ret = modPow(x, n/2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return ret;\n}\n\ninline int64 modInv(int64 a) {\n  return modPow(a, mod - 2);\n}\n\ninline int64 modFact(int n) {\n  int64 ret = 1;\n  while(n > 1) (ret *= n--) %= mod;\n  return ret;\n}\n\ninline int64 modComb(int64 n, int64 r) {\n  static int64 fact[MAX_N], invfact[MAX_N];\n  if(fact[0] == 0) {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < MAX_N; i++) {\n      fact[i] = fact[i-1] * i % mod;\n      invfact[i] = modInv(fact[i]);\n    }\n  }\n  if(r < 0 || n < r) return 0;\n  return fact[n] * invfact[r] % mod * invfact[n-r] % mod;\n}\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y]; data[y] = x;\n    return;\n  }\n};\n\nint calc(int& n, vector<Tapris>& vec) {\n  UnionFind uf(n);\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 0) uf.unite(a, b);\n  }\n  int x = 0, y = 0;\n  set<int> st;\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 1) continue;\n    int p;\n    if((p = uf.find(a)) == a || (p = uf.find(b)) == b) {\n      st.insert(a);\n      st.insert(b);\n      int sz = uf.size(p);\n      if(sz >= 4) return 0;\n      else if(sz == 2) ++y;\n    }\n  }\n  //cout<<n<<endl;\n  x = n - st.size();\n  //cout << x << \" \" << y << endl;\n  if(y > x) return 0;\n  int z = (x-y)/3;\n  //cout<<z<<endl;\n  //cout<<modFact(x)<<\" \"<<modPow(6, z)<<\" \"<<modInv(modPow(6, z))<<\" \"<<modFact(z)<<\" \"<<modInv(modFact(z))<<endl;\n  return modFact(x)*modInv(modPow(3*2*1, z))%mod*modInv(modFact(z))%mod;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  cin >> n >> m;\n  n *= 3;\n  vector<Tapris> vec;\n  vector<int> badidx;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c; --a, --b;\n    vec.emplace_back(a, b, c);\n    if(c == 1) badidx.push_back(i);\n  }\n  //cout<<calc(n, vec)<<endl;\n  int bad = badidx.size();\n  int ans = 0;\n  rep(bit, 1<<bad) {\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 0;\n    if(__builtin_popcount(bit)%2) (ans -= calc(n, vec)) %= mod;\n    else (ans += calc(n, vec)) %= mod;\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 1;\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n        assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\treturn dp[rest/3];\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tcin >> N >> M;\n\tdp[0] = 1;\n\tfor (int i = 1; i <= N+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tvector<rel>hates;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t/*if (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}*/\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\tif (rest >= 3 - n) {\n\n\t\t\tans *= comb(rest, 3 - n);\n\t\t}\n\t\telse {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\ninline char nc(){\n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2)  return EOF; }\n  return *p1++;\n}\n\ninline void read(int &x){\n  char c=nc(),b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\nconst int N=3000005;\n\nstruct modi{  \n  int x,y,r;  \n}Stk[N]; int pnt;  \nint fat[N],rnk[N],size[N];  \n  \ninline int Fat(int u){  \n  return u==fat[u]?u:Fat(fat[u]);  \n}\n\nint cot[N];\nint flag=0;\n\ninline int Merge(int x,int y){  \n  x=Fat(x); y=Fat(y); if (x==y) return 0;  \n  if (rnk[x]>rnk[y]) swap(x,y);  \n  Stk[++pnt].x=x; Stk[pnt].y=y; Stk[pnt].r=0;  \n  if (rnk[x]==rnk[y]) rnk[y]++,Stk[pnt].r=1;  \n  fat[x]=y; cot[size[y]]--; cot[size[x]]--; size[y]+=size[x]; cot[size[y]]++;\n  if (size[y]>3) flag=1;\n  return 1;  \n}\n\ninline void Back(int t){  \n  for (;pnt>t;pnt--){\n    int x=Stk[pnt].x,y=Stk[pnt].y;\n    fat[Stk[pnt].x]=Stk[pnt].x;  \n    if (Stk[pnt].r) rnk[Stk[pnt].y]--;\n    cot[size[y]]--; size[y]-=size[x]; \n    cot[size[y]]++; cot[size[x]]++; \n  }  \n}\n\nconst ll P=1e9+9;\n\nll fac[N],inv[N],iinv[N];\n\nint tot;\nint us[20],vs[20],ws[20];\nint n,m;\n\ninline ll Pow(ll a,int b){\n  ll ret=1;\n  for (;b;b>>=1,a=a*a%P)\n    if (b&1)\n      ret=ret*a%P;\n  return ret;\n}\n\ninline void Pre(int n){  \n  fac[0]=1; for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%P;\n  inv[0]=1; for (int i=1;i<=n/3;i++) (inv[i]=inv[i-1]*6)%=P;\n  for (int i=1;i<=n/3;i++) inv[i]=Pow(inv[i],P-2);\n  iinv[1]=1; for (int i=2;i<=n;i++) iinv[i]=(P-P/i)*iinv[P%i]%P;  \n  iinv[0]=1; for (int i=1;i<=n;i++) iinv[i]=iinv[i]*iinv[i-1]%P;  \n}\n\ninline ll Calc(int a,int b,int c){\n  if (b>a) return 0;\n  return fac[a]*inv[(a-b)/3]%P*iinv[(a-b)/3]%P;\n}\n\nint main(){\n  read(n); read(m); n*=3;\n  Pre(n);\n  tot=0;\n  for (int i=1;i<=n;i++) fat[i]=i,size[i]=1;\n  flag=0; cot[1]=n;\n  for (int i=1;i<=m;i++){\n    ++tot;\n    read(us[tot]),read(vs[tot]),read(ws[tot]);\n    if (ws[tot]==0)\n      Merge(us[tot],vs[tot]),tot--;      \n  }\n  if (flag){\n    printf(\"0\\n\");\n    return 0;\n  }\n  ll Ans=Calc(cot[1],cot[2],cot[3]);\n  int tmp=pnt;\n  for (int i=1;i<(1<<tot);i++){\n    flag=0; int c=0;\n    for (int j=1;j<=tot;j++)\n      if (i>>(j-1)&1)\n\tMerge(us[j],vs[j]),c++;   \n    if (!flag){\n      if (c&1)\n\t(Ans+=P-Calc(cot[1],cot[2],cot[3]))%=P;\n      else\n\t(Ans+=Calc(cot[1],cot[2],cot[3]))%=P;\n    }\n    Back(tmp);\n  }\n  printf(\"%lld\\n\",Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000009\n\nstruct UnionFind{\n  vector<int> v,sav;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){\n    for(int i = 0;i < (int)sav.size();i++)v[sav[i]]=-1;\n    sav.clear();\n  }\n  int find(int x) { return v[x] < 0 ? x : find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    sav.push_back(x); sav.push_back(y);\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll N,M;\nvector<P> rel[2];\nll fac[3000010],finv[3000010];\nll calc[3000010];\n\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r)return 0;\n  return (fac[n]*finv[r]%mod)*finv[n-r]%mod;\n}\n\nint main(){\n  fac[0]=1;\n  rep(i,3000000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,3000001)finv[i]=mod_pow(fac[i],mod-2);\n  calc[0]=1;\n  for(ll i=3;i<=3000000;i+=3){\n    calc[i]=calc[i-3]*comb(i,3)%mod;\n    (calc[i]*=mod_pow(i/3,mod-2))%=mod;\n  }\n\n  cin>>N>>M;\n  N*=3;\n  rep(i,M){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    rel[c].push_back(P(a,b));\n  }\n  ll res=0;\n  M=rel[1].size();\n  UnionFind uf(N);\n  rep(S,1<<M){\n    uf.init();\n    set<ll> vs;\n    rep(i,rel[0].size()){\n      uf.unite(rel[0][i].fi,rel[0][i].se);\n      vs.insert(rel[0][i].fi); vs.insert(rel[0][i].se);\n    }\n    rep(i,M){\n      if((S>>i)&1){\n        uf.unite(rel[1][i].fi,rel[1][i].se);\n        vs.insert(rel[1][i].fi); vs.insert(rel[1][i].se);\n      }\n    }\n    ll crt=1;\n    ll rest=N,cnt=0;\n    map<ll,bool> used;\n    for(ll v : vs){\n      if(!used[uf.find(v)]){\n        used[uf.find(v)]=true;\n        ll sz=uf.size(v);\n        if(sz>3)crt=0;\n        else{\n          rest-=sz;\n          cnt+=3-sz;\n        }\n      }\n    }\n    (crt*=(comb(rest,cnt)*fac[cnt])%mod)%=mod;\n    rest-=cnt;\n\n    if(bcnt(S)%2==0) (res+=calc[rest]*crt%mod)%=mod;\n    else (res+=(mod-(calc[rest]*crt%mod))%mod)%=mod;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t/*\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}*/\n\t\tMod a = n==2?rest:1;\n\t\tMod b = comb(rest, 3 - n);\n\t\twhile (a != b) {\n\t\t\tcout << 22 << endl;\n\t\t}\n\t\tans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+9;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=3000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nvi a,b;\nvi c,d;\n\nint main(){\n\tInit();\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\tif(w==0){\n\t\t\ta.push_back(u);\n\t\t\tb.push_back(v);\n\t\t}\n\t\telse{\n\t\t\tc.push_back(u);\n\t\t\td.push_back(v);\n\t\t}\n\t}\n\tint sa=a.size(),sc=c.size();\n\tll res=0;\n\tfor(int i=0;i<1<<sc;i++){\n\t\tvi s=a,t=b,e;\n\t\tint tmp=0;\n\t\tfor(int j=0;j<sc;j++) if(i&1<<j){\n\t\t\ts.push_back(c[j]);\n\t\t\tt.push_back(d[j]);\n\t\t\ttmp++;\n\t\t}\n\t\tm=s.size();\n\t\tfor(int j=0;j<m;j++){\n\t\t\te.push_back(s[j]);\n\t\t\te.push_back(t[j]);\n\t\t}\n\t\tsort(e.begin(),e.end());\n\t\te.erase(unique(e.begin(),e.end()),e.end());\n\t\tmap<int,int> mp;\n\t\tint N=e.size();\n\t\tfor(int j=0;j<N;j++) mp[e[j]]=j;\n\t\tvvi g(N);\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint u=mp[s[j]],v=mp[t[j]];\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tvi used(N);\n\t\tint x=3*n-N,y=0,z=0;\n\t\tbool B=0;\n\t\tfor(int i=0;i<N;i++) if(!used[i]){\n\t\t\tint t=0;\n\t\t\tqueue<int> q;\n\t\t\tq.push(i);\n\t\t\tused[i]++;\n\t\t\tint cnt=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint v=q.front();q.pop();\n\t\t\t\tcnt++;\n\t\t\t\tfor(auto u:g[v]) if(!used[u]){\n\t\t\t\t\tused[u]++;\n\t\t\t\t\tq.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt>3) B=1;\n\t\t\tif(cnt==2) y++;\n\t\t\tif(cnt==3) z++;\n\t\t}\n\t\tif(B||y>x) continue;\n\t\tll ei=nCk(x,y)*F[y]%mod*Div(F[x-y],Pow(6,(x-y)/3)*F[(x-y)/3]%mod)%mod;\n\t\tif(tmp%2==1) (ei*=mod-1)%=mod;\n\t\t(res+=ei)%=mod;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000009\n\nint n,m;\nll modpow(ll x,ll n)\n{\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[3000005],R[3000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<3000005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<3000005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int a,int b){ return F[a]*R[b]%mod*R[a-b]%mod; }\nvector<P>eq,neq;\nint par[3000005],ran[3000005];\nvoid init(){ for(int i=0;i<3000005;i++) par[i] = i,ran[i] = 0; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint main(){\n\tcin >> n >> m; make();\n\tfor(int i=0;i<m;i++){\n\t\tint p,q,a;\n\t\tcin >> p >> q >> a;\n\t\tif(a == 0) eq.pb(mp(p,q));\n\t\telse neq.pb(mp(p,q));\n\t}\n\tint x = neq.size();\n\tll ret = 0;\n\tinit();\n\tfor(int i=0;i<(1<<x);i++){\n\t\tvector<P>E = eq;\n\t\tvector<int>vi;\n\t\tfor(int j=0;j<x;j++){\n\t\t\tif(((i>>j)&1)) E.pb(neq[j]);\n\t\t}\n\t\tset<int>se;\n\t\tmap<int,int>ma;\n\t\tfor(int j=0;j<E.size();j++){\n\t\t\tint s = E[j].fi,t = E[j].sc;\n\t\t\tunite(s,t);\n\t\t\tse.insert(s); se.insert(t);\n\t\t}\n\t\tint zan = 3*n-se.size();\n\t\tfor(set<int>::iterator it = se.begin();it != se.end();++it){\n\t\t\tma[find(*it)]++;\n\t\t}\n\t\tfor(set<int>::iterator it = se.begin();it != se.end();++it){\n\t\t\tpar[*it] = *it; ran[*it] = 0;\n\t\t}\n\t\tll val = 1;\n\t\tfor(map<int,int>::iterator it = ma.begin();it !=ma.end();++it){\n\t\t\tif( it->sc > 3) val = 0; assert(it->sc>=2);\n\t\t\tval = val * C(zan,3-it->sc) % mod;\n\t\t\tzan -= (3-it->sc);\n\t\t}\n\t\tassert(zan%3 == 0); int k = zan/3;\n\t\tval = val*F[3*k]%mod;\n\t\tval = val*modpow(modpow(6,mod-2),k)%mod*R[k]%mod;\n\t\tif(__builtin_popcount(i)%2 == 0) ret = (ret+val)%mod;\n\t\telse ret = (ret+mod-val)%mod;\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int Mod, bool IsPrime = false>\nclass mod_int {\n    using ll = long long;\n\npublic:\n    constexpr mod_int() : n(0) {}\n    constexpr mod_int(int n_) : n(n_) {\n        if(n >= Mod)     n %= Mod;\n        else if(n < 0) n = (n % Mod + Mod) % Mod;\n    }\n    constexpr mod_int(ll n_) : n(n_) { n = (n + Mod) % Mod; }\n\n    constexpr operator int() const { return n; }\n    constexpr operator ll() const  { return n; }\n\n    constexpr bool operator==(mod_int const& other) const { return n == other.n; }\n    constexpr mod_int& operator+=(mod_int const& other) {\n        if((n += other.n) >= Mod) n -= Mod;\n        return *this;\n    }\n    constexpr mod_int& operator-=(mod_int const& other) {\n        if((n += Mod - other.n) >= Mod) n -= Mod;\n        return *this;\n    }\n    constexpr mod_int& operator*=(mod_int const& other) {\n        n = (unsigned long long)n * other.n % Mod;\n        return *this;\n    }\n    constexpr typename std::enable_if<IsPrime, mod_int>::type& operator/=(mod_int const& other) {\n        return *this *= other.inverse();\n    }\n    constexpr mod_int operator+(mod_int other) const { return mod_int(*this) += other; }\n    constexpr mod_int operator-(mod_int other) const { return mod_int(*this) -= other; }\n    constexpr mod_int operator*(mod_int other) const { return mod_int(*this) *= other; }\n    constexpr mod_int operator/(mod_int other) const { return mod_int(*this) /= other; }\n\n    constexpr typename std::enable_if<IsPrime, mod_int>::type inverse() const {\n        ll a = n, b = Mod, u = 1, v = 0;\n        while(b) {\n            ll t = a / b;\n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        return mod_int(u);\n    }\n\nprivate:\n    ll n;\n};\n\ntemplate <int Mod, bool IsPrime>\nstd::ostream& operator<<(std::ostream& os, mod_int<Mod, IsPrime> const& n) {\n    os << (int)n;\n    return os;\n}\n\nconstexpr int default_mod = 1000000009;\n\ntemplate <int Mod = default_mod>\nmod_int<Mod, true> fact(int n, bool inv = false) {\n    static std::vector<mod_int<Mod, true>> v1 = {1}, v2 = {1};\n    if(n >= static_cast<int>(v1.size())) {\n        const int from = v1.size(), to = n + 1024;\n        v1.reserve(to); v2.reserve(to);\n        for(int i = from; i < to; ++i) {\n            v1.push_back(v1.back() * mod_int<Mod, true>(i));\n            v2.push_back(v2.back() / mod_int<Mod, true>(i));\n        }\n    }\n    return inv ? v2[n] : v1[n];\n}\n\ntemplate <int Mod = default_mod>\nmod_int<Mod, true> comb(int n, int r) { // nCr\n    if(r < 0 || r > n) return 0;\n    return fact<Mod>(n) * fact<Mod>(r, true) * fact<Mod>(n - r, true);\n}\n\nusing mint = mod_int<default_mod, true>; // default\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1) {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(par[x] < par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n    }\n\n    int size(int x) {\n        return -par[root(x)];\n    }\n\nprivate:\n    vector<int> par;\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    n *= 3; // to number of people\n    map<int, int> idx;\n    vector<int> a(m), b(m), c(m), ban;\n    for(int i = 0; i < m; ++i) {\n        cin >> a[i] >> b[i] >> c[i];\n        if(c[i] == 1) {\n            ban.push_back(i);\n        }\n    }\n    const int sz = [&] (){ // compress\n        vector<int> xs;\n        for(int i = 0; i < m; ++i) {\n            xs.push_back(a[i]);\n            xs.push_back(b[i]);\n        }\n        sort(begin(xs), end(xs));\n        xs.erase(unique(begin(xs), end(xs)), xs.end());\n        for(int i = 0; i < m; ++i) {\n            a[i] = lower_bound(begin(xs), end(xs), a[i]) - begin(xs);\n            b[i] = lower_bound(begin(xs), end(xs), b[i]) - begin(xs);\n        }\n        return xs.size();\n    }();\n\n    mint ans = 0;\n    vector<mint> inv6_fact(n, mint(1));\n    {\n        const mint inv6 = mint(6).inverse();\n        for(int i = 1; i < n; ++i) {\n            inv6_fact[i] = inv6_fact[i - 1] * inv6;\n        }\n    }\n    for(int S = 0; S < (1 << ban.size()); ++S) { // same team\n        union_find uf(sz);\n        for(int i = 0; i < m; ++i) {\n            if(c[i] == 1) continue;\n            uf.unite(a[i], b[i]);\n        }\n        for(int i = 0; i < (int)ban.size(); ++i) {\n            if(S & (1 << i)) {\n                uf.unite(a[ban[i]], b[ban[i]]);\n            }\n        }\n        int cnt_two = 0, cnt_three = 0;\n        {\n            bool check = true;\n            vector<bool> f(sz);\n            for(int i = 0; i < sz; ++i) {\n                if(f[uf.root(i)]) continue;\n                f[uf.root(i)] = true;\n                check &= uf.size(i) <= 3;\n                cnt_three += uf.size(i) == 3;\n                cnt_two += uf.size(i) == 2;\n            }\n            check &= (n - cnt_three * 3 - cnt_two * 2) >= cnt_two;\n            if(!check) continue; // not count\n        }\n        int tn = n - cnt_three * 3 - cnt_two * 2;\n        mint tans = comb(tn, cnt_two) * fact(cnt_two);\n        tn -= cnt_two;\n        tans *= fact(tn) * inv6_fact[tn / 3] * fact(tn / 3, true);\n        if(__builtin_popcount(S) & 1) {\n            ans -= tans;\n        } else {\n            ans += tans;\n        }\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcount(i)%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nconst ll mod = 1000000009;\nll dp[2000000];\nll N, M;\nvector<ll> A, B, C;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint main() {\n    dp[0] = 1;\n    for(ll i = 1; i <= 1e6; i++) {\n        ll tmp = (3*i-1) * (3*i-2) / 2;\n        tmp %= mod;\n        tmp *= dp[i-1];\n        tmp %= mod;\n        dp[i] = tmp;\n    }\n    cin >> N >> M;\n    A.resize(M), B.resize(M), C.resize(M);\n    vector<ll> cmp;\n    for(int i = 0; i < M; i++) {\n        cin >> A[i] >> B[i] >> C[i];\n        cmp.push_back(A[i]);\n        cmp.push_back(B[i]);\n    }\n    sort(cmp.begin(), cmp.end());\n    cmp.erase(unique(cmp.begin(), cmp.end()), cmp.end());\n    for(int i = 0; i < M; i++) {\n        auto itr = lower_bound(cmp.begin(), cmp.end(), A[i]);\n        A[i] = itr - cmp.begin();\n        itr = lower_bound(cmp.begin(), cmp.end(), B[i]);\n        B[i] = itr - cmp.begin();\n    }\n    ll ans = 0;\n    for(int bits = 0; bits < (1 << M); bits++) {\n        ll tmp = 1;\n        UnionFind uni(50);\n        for(int i = 0; i < M; i++) {\n            int a = (1 & (bits >> i));\n            if(C[i] == 0 and a) {\n                tmp = 0;\n            } else if(C[i] == 1 and a) {\n                uni.merge(A[i], B[i]);\n            } else if(C[i] == 0) {\n                uni.merge(A[i], B[i]);\n            }\n        }\n        ll two = 0;\n        ll three = 0;\n        for(int i = 0; i < 50; i++) {\n            if(uni.root(i) != i) continue;\n            if(uni.size(i) > 3) tmp = 0;\n            else if(uni.size(i) == 2) two++;\n            else if(uni.size(i) == 3) three++;\n        }\n        ll one = 3 * N - 2*two - 3*three;\n        while(two) {\n            tmp *= one;\n            tmp %= mod;\n            two--;\n            one--;\n        }\n        if(one >= 0) tmp *= dp[one / 3];\n        tmp %= mod;\n        //if(tmp) cerr << bits << \" \" << tmp << endl;\n        if(__builtin_popcount(bits) % 2 == 0) ans += tmp;\n        else ans += mod - tmp;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define fi first\n#define se second\n#define inver(a) power(a, mod - 2)\nusing namespace std;\ninline char nc() {\n\treturn getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f;\n}\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1e9 + 9;\nconst int maxn = 1e6 + 5;\nint n, m;\nint an;\nint tim;\nint f[maxn];\nint cnt[maxn * 3];\nint fac[maxn * 3];\nint inv[maxn * 3];\nint vis[maxn * 3];\nvector<pii> r[2];\nll power(ll x, ll y) {\n\tll re = 1;\n\twhile(y) {\n\t\tif(y & 1) re = re * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn re;\n}\ninline ll binom(int x, int y) {\n\treturn (ll)fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nnamespace us {\n\tint fa[maxn * 3];\n\tvoid init(int x) {\n\t\tfa[x] = x;\n\t}\n\tint find(int a) {\n\t\treturn fa[a] == a ? a : fa[a] = find(fa[a]);\n\t}\n\tbool merge(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a == b) return 0;\n\t\tfa[a] = b; return 1;\n\t}\n}\nbool update(int &n, int &a, int x) {\n\tif(vis[x] == tim) return 0; else vis[x] = tim;\n\tx = us :: find(x);\n\tif(++cnt[x] > 3) return 1;\n\tif(cnt[x] == 3) --a, --n;\n\tif(cnt[x] == 2) ++a;\n\treturn 0;\n}\nint cal() {\n\t++tim;\n\tfor(unsigned int i = 0; i < r[0].size(); ++i) {\n\t\tus :: init(r[0][i].fi), cnt[r[0][i].fi] = 0;\n\t\tus :: init(r[0][i].se), cnt[r[0][i].se] = 0;\n\t} \n\tfor(unsigned int i = 0; i < r[0].size(); ++i) {\n\t\tus :: merge(r[0][i].fi, r[0][i].se);\n\t}\n\tint a = 0, N = n;\n\tfor(unsigned int i = 0; i < r[0].size(); ++i){\n\t\tif(update(N, a, r[0][i].fi)) return 0;\n\t\tif(update(N, a, r[0][i].se)) return 0;\n\t} \n\treturn binom(N * 3 - a * 2, a) * fac[a] % mod * f[N - a] % mod * inv[N - a] % mod;\n}\nvoid dfs(int step, int f) {\n\tif(step == m) {\n\t\tan = (an + (ll)cal() * f) % mod;\n\t\treturn;\n\t}\n\tdfs(step + 1, f);\n\tr[0].push_back(r[1][step]);\n\tdfs(step + 1, mod - f);\n\tr[0].pop_back();\n}\nvoid init(int n) {\n\tint N = n * 3;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; ++i) {\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\t}\n\tinv[N] = inver(fac[N]);\n\tfor(int i = N; i >= 1; --i) {\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\t}\n\tf[0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tf[i] = f[i - 1] * binom(i * 3, 3) % mod;\n\t}\n}\nint solve() {\n\tinit(n);\n\tdfs(0, 1);\n\treturn an;\n}\nint main() {\n//\tfreopen(\"in\", \"r\", stdin);\n\tread(n), read(m);\n\tfor(int i = 1; i <= m; ++i) {\n\t\tint a, b, c; read(a), read(b), read(c);\n\t\tr[c].push_back(pii(a, b));\n\t}\n\tm = r[1].size();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, int> dict(const vector<T> &v){\n  map<T, int> res;\n  for(int i=0;i<(int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m),b(m),c(m);\n  for(int i=0;i<m;i++) cin>>a[i]>>b[i]>>c[i];\n  UnionFind uf(3*n);\n  for(int i=0;i<m;i++){\n    a[i]--;b[i]--;\n    if(c[i]==0) uf.unite(a[i],b[i]); \n  }\n  \n  int one=0,two=0;\n  for(int i=0;i<3*n;i++){\n    if(uf.find(i)!=i) continue;\n    if(uf.r[i]>3){\n      cout<<0<<endl;\n      return 0;\n    }\n    if(uf.r[i]==1) one++;\n    if(uf.r[i]==2) two++;\n  }\n  \n  using P = pair<int, int>;\n  vector<P> ps;\n  for(int i=0;i<m;i++){\n    if(c[i]==0) continue;\n    if(uf.same(a[i],b[i])){\n      cout<<0<<endl;\n      return 0;\n    }\n    int x=uf.find(a[i]),y=uf.find(b[i]);\n    if(x>y) swap(x,y);\n    if(uf.r[x]+uf.r[y]<=3)\n      ps.emplace_back(x,y);\n  }\n  ps=compress(ps);\n  int w=ps.size();\n  \n  using M = Mint<int, int(1e9+9)>;\n  M ans;\n  vector<M> po(n<<1,1);\n  M r6=M(6).inv();\n  for(int i=1;i<(int)po.size();i++) po[i]=po[i-1]*r6;\n  M::init(n<<2);\n\n  vector<int> vs;\n  for(auto p:ps){\n    vs.emplace_back(p.first);\n    vs.emplace_back(p.second);    \n  }\n  vs=compress(vs);\n  auto rev=dict(vs);\n  \n  for(int b=0;b<(1<<w);b++){\n    int os=one,ts=two;\n    UnionFind sz(vs.size());\n    for(int i=0;i<(int)vs.size();i++){\n      sz.r[i]=uf.r[vs[i]];\n      if(sz.r[i]==1) os--;\n      if(sz.r[i]==2) ts--;\n    }\n    for(int i=0;i<w;i++)\n      if((b>>i)&1) sz.unite(rev[ps[i].first],rev[ps[i].second]);\n    \n    int flg=0;\n    for(int i=0;i<(int)vs.size();i++){\n      if(sz.find(i)!=i) continue;\n      flg|=sz.r[i]>3;      \n      if(sz.r[i]==1) os++;\n      if(sz.r[i]==2) ts++;\n    }\n    if(flg||ts>os) continue;\n    M res=M::P(os,ts);\n    res*=M::fact[os-ts]*po[(os-ts)/3]*M::finv[(os-ts)/3];\n    ans+=__builtin_parity(b)?-res:res;\n  }\n\n  cout<<ans.v<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tif (a < b) {\n\t\treturn 0;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t/*if (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}*/\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\tif (rest >= 3 - n) {\n\n\t\t\tans *= comb(rest, 3 - n);\n\t\t}\n\t\telse {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n >= 2) {\n\t\t\t/*if (n == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}*/\n\t\t\tif (rest < 3 - n)assert(false);\n\t\t\tans *= comb(rest, 3 - n);\n\t\t\trest -= (3-n);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= dp[rest / 3];\n\treturn ans;\n}\nint main() {\n\tcin >> N >> M;\n\tdp[0] = 1;\n\tfor (int i = 1; i <= N+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tvector<rel>hates;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\n\nint N,M;\nll F[3000005];\nll T3[1000005];\nll T2[1000005];\nconst ll mod = 1000000009LL;\nll extgcd(ll a, ll b, ll &x, ll &y){\n  ll g = a;\n  x = 1;\n  y = 0;\n  if(b != 0){\n    g = extgcd(b, a%b, y, x);\n    y -= (a / b) * x;\n  }\n  return g;\n}\nll modinv(ll a, ll m=mod){\n  ll x,y;\n  if(extgcd(a,m,x,y) == 1) return (x + m) % m;\n  return -1; \n}\n\nstruct uni {\n  int d[40];\n  int n;\n  uni(int n):n(n){\n    fill( d,d+n,-1 );\n  }\n  int find(int a){ return (d[a]<0?a:(d[a]=find(d[a]))); }\n  void merge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap( a, b );\n    d[a] += d[b]; d[b] = a;\n  }\n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n  vector<int> size(){\n    vector<int> vs;\n    for(int i=0;i<n;i++)\n      if( i == find(d[i]) )\n        vs.emplace_back( -d[i] );\n    return vs;\n  }\n};\n\nvector<int> A,B,C;\nint zatsu(){\n  vector<int> xs;\n  for(int i=0;i<M;i++){\n    xs.emplace_back( A[i] );\n    xs.emplace_back( B[i] );\n  }\n  sort( xs.begin(), xs.end() );\n  xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n  for(int i=0;i<M;i++){\n    A[i] = find( xs.begin(), xs.end(), A[i] ) - xs.begin();\n    B[i] = find( xs.begin(), xs.end(), B[i] ) - xs.begin();\n  }\n  return xs.size();\n}\n\nvoid add(ll &a, ll b){\n  a += b;\n  a %= mod;\n}\nll mult( ll a, ll b ){\n  return a * b % mod;\n}\n\nint main(){\n  cin >> N >> M;\n  F[0] = 1LL;\n  for(int i=1;i<=3*N;i++)\n    F[i] = F[i-1] * (ll)i;\n  T2[0] = T3[0] = 1LL;\n  ll mod_tw = modinv( F[2] );\n  ll mod_th = modinv( F[3] );\n  for(int i=1;i<=N;i++){\n    T2[i] = T2[i-1] * mod_tw;\n    T3[i] = T3[i-1] * mod_th;\n  }\n\n  A.resize(M); B.resize(M); C.resize(M);\n  for(int i=0;i<M;i++)\n    cin >> A[i] >> B[i] >> C[i];\n  int n = zatsu();\n\n  ll res = 0LL;\n  for(int st=0;st<(1<<M);st++){\n    uni U(n);\n    for(int i=0;i<M;i++)\n      if( st & (1<<i) )\n        U.merge( A[i], B[i] );\n\n    bool valid = true;\n    for(int i=0;i<N;i++){\n      if( C[i] == 0 && !U.same(A[i],B[i]) ) valid = false;\n      if( C[i] == 1 && U.same(A[i],B[i]) ) valid = false;        \n    }\n    vector<int> sz = U.size();\n    int b[4]={};\n    for( int s : sz ){\n      if( s > 3 ) valid = false;\n      b[s]++;\n    }\n\n    if( valid ){\n      ll num = N - n;\n      ll xros = 1LL;\n      ll b2 = b[2];\n      xros = mult( xros, mult( F[num], modinv(F[num-b2]) ) );\n      num -= b2;\n      ll b1 = b[1];\n      xros = mult( xros, mult( mult( F[num], modinv(F[num-b1*2LL]) ), T2[b1] ) );\n      num -= b1;\n      xros = mult( xros, mult( mult( F[num], T3[num/3LL] ) ) );\n      add( res, xros );\n    }\n        \n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\t\n\t\t//ans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\nchar c;\nbool flag;\n\nint Cs[10];\nint d;\ninline void read(int&a)\n{\n\ta=0;do c=getchar();while(c!='-'&&(c<'0'||c>'9'));\n\tc=c=='-'?flag=true,getchar():c;\n\twhile(c<='9'&&c>='0')d++,a=(a<<3)+(a<<1)+c-'0',c=getchar();\n\ta=flag?flag=false,-a:a;\n}\n#define ll long long\n#define x first\n#define y second\nmap<int,int>Map;\ninline void read(ll&a)\n{\n\ta=0;do c=getchar();while(c!='-'&&(c<'0'||c>'9'));\n\tc=c=='-'?flag=true,getchar():c;\n\twhile(c<='9'&&c>='0')d++,a=(a<<3)+(a<<1)+c-'0',c=getchar();\n\ta=flag?flag=false,-a:a;\n}\npair<int,int>A[10001];\npair<int,int>B[10001];\npair<int,int>C[10001];\nint F[1<<20];\nint N,M;\n#define lowbit(x) ((x)&-(x))\n\nconst\n\tint Mod=(int)1e9+9;\n\nvoid Up(int &a,int b)\n{\n\ta+=b;\n\tif(a>=Mod)a-=Mod;\n\telse if(a<0)a+=Mod;\n}\nint Mul(int a,int b)\n{\n\treturn a*1ll*b%Mod;\n}\nint Add(int a,int b)\n{\n\ta+=b;\n\tif(a>=Mod)a-=Mod;\n\telse if(a<0)a+=Mod;\n\treturn a;\n}\nint C3[4000001];\nint NO[4000001];\nint size[2000001];\nint f[2000001];\nint Cnt[10];\nint Fact[5000001],Inv[5000001];\nint Com(int x,int y)\n{\n\treturn Mul(Mul(Fact[x],1),Inv[x-y]);\n}\n\nint find(int x){return f[x]==x?x:f[x]=find(f[x]);}\nint Calc(int n,int m)\n{\n\tCnt[1]=N-n,Cnt[2]=0,Cnt[3]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tsize[i]=1,f[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=C[i].x,y=C[i].y;\n\t\tif(find(x)^find(y))\n\t\t\tsize[f[y]]+=size[f[x]],f[f[x]]=f[y];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(find(i)==i)\n\t\t\tif(size[i]<=3)\n\t\t\t\tCnt[size[i]]++;\n\t\t\telse return 0;\n\tif(Cnt[1]<Cnt[2])return 0;\n\treturn \n\tMul(Com(Cnt[1],Cnt[2]),Mul(NO[(Cnt[1]-Cnt[2])/3],Inv[(Cnt[1]-Cnt[2])/3]));\n}\nint Pow(int a,int x)\n{\n\tint res=1;\n\tfor(;x;x>>=1,a=a*1ll*a%Mod)\n\t\tif(x&1)res=res*1ll*a%Mod;\n\treturn res;\n}\nint main()\n{\n\tint n1,n2,INV=Pow(6,Mod-2);\n\tn1=n2=0;\n\tread(N),read(M);\n\tN*=3;\n\tFact[0]=1;\n\tfor(int i=1;i<=3000000;i++)\n\t\tC3[i]=Mul(Mul(Mul(3*i,3*i-1),3*i-2),INV),Fact[i]=Mul(Fact[i-1],i);\n\tNO[0]=1;\n\tInv[3000000]=Pow(Fact[3000000],Mod-2);\n\tInv[0]=1;\n\tfor(int i=2999999;i;i--)\n\t\tInv[i]=Mul(Inv[i+1],i+1);\n\t\n\tfor(int i=1;i<=3000000;i++)\n\t\tNO[i]=Mul(NO[i-1],C3[i]);\n\t\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tint X,Y,Z;\n\t\tread(X),read(Y),read(Z);\n\t\tif(!Z)A[++n1]=make_pair(X,Y);\n\t\telse B[++n2]=make_pair(X,Y);\n\t}\n\tfor(int i=1;i<=n1;i++)\n\t\tC[i]=A[i];\n\tfor(int i=1;i<=n2;i++)\n\t\tF[1<<i-1]=i;\n\tint Ans=0;\n\tfor(int i=0;i<(1<<n2);i++)\n\t{\n\t\tint n3=n1,X=i,Y=i,t=0;\n\t\twhile(X)\n\t\t{\n\t\t\t\tC[++n3]=B[F[lowbit(X)]];\n\t\t\t\tX^=lowbit(X);\n\t\t\t\tt++;\t\n\t\t}\n\t\tMap.clear();\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n3;i++)\n\t\t{\n\t\t\tif(!Map[C[i].x])\n\t\t\t\t\tMap[C[i].x]=++cnt;\n\t\t\tif(!Map[C[i].y])\n\t\t\t\t\tMap[C[i].y]=++cnt;\n\t\t\tC[i].x=Map[C[i].x];\n\t\t\tC[i].y=Map[C[i].y];\n\t\t}\n\t\tUp(Ans,Mul(Pow(Mod-1,t),Calc(cnt,n3)));\n\t}\n\tcout<<Ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, Mod>memo;\nvector<Mod>dp(3e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn dp[rest];\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==1){\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 3; i <= 300000; ++i) {\n\t\tdp[i] = dp[i - 3] * Mod(i - 1)*Mod(i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000009;\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tint lim = max(N, 3);\n\tvector<int> fact(3 * lim + 1), inv(3 * lim + 1), factinv(3 * lim + 1), val(N + 1);\n\tfact[0] = 1; inv[1] = 1; factinv[0] = 1;\n\tfor (int i = 1; i <= 3 * lim; ++i) fact[i] = (long long)(fact[i - 1]) * i % mod;\n\tfor (int i = 2; i <= 3 * lim; ++i) inv[i] = (long long)(inv[mod % i]) * (mod - mod / i) % mod;\n\tfor (int i = 1; i <= 3 * lim; ++i) factinv[i] = (long long)(factinv[i - 1]) * inv[i] % mod;\n\tval[0] = 1; int mul = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tmul = (long long)(mul) * factinv[3] % mod;\n\t\tval[i] = (long long)(mul) * fact[3 * i] % mod * factinv[i] % mod;\n\t}\n\tvector<int> A(M), B(M), C(M);\n\tvector<int> cv;\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> A[i] >> B[i] >> C[i];\n\t\tcv.push_back(A[i]);\n\t\tcv.push_back(B[i]);\n\t}\n\tsort(cv.begin(), cv.end());\n\tcv.erase(unique(cv.begin(), cv.end()), cv.end());\n\tint S = cv.size();\n\tvector<int> par(S);\n\tfor (int i = 0; i < S; ++i) par[i] = i;\n\tfunction<int(int)> root = [&](int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = root(par[x]);\n\t};\n\tfor (int i = 0; i < M; ++i) {\n\t\tA[i] = find(cv.begin(), cv.end(), A[i]) - cv.begin();\n\t\tB[i] = find(cv.begin(), cv.end(), B[i]) - cv.begin();\n\t}\n\tvector<int> nA, nB;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (C[i] == 0) {\n\t\t\tpar[root(A[i])] = root(B[i]);\n\t\t}\n\t\telse {\n\t\t\tnA.push_back(A[i]);\n\t\t\tnB.push_back(B[i]);\n\t\t}\n\t}\n\tA = nA; B = nB;\n\tM = A.size();\n\tvector<int> inipar = par;\n\tint ans = 0;\n\tfor (int i = 0; i < 1 << M; ++i) {\n\t\tpar = inipar;\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tpar[root(A[j])] = root(B[j]);\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tvector<int> hist(S);\n\t\tfor (int j = 0; j < S; ++j) {\n\t\t\t++hist[root(j)];\n\t\t}\n\t\tbool ok = true;\n\t\tint c1 = 3 * N - S, c2 = 0, c3 = 0;\n\t\tfor (int j = 0; j < S; ++j) {\n\t\t\tif (hist[j] >= 4) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hist[j] == 3) ++c3;\n\t\t\tif (hist[j] == 2) ++c2;\n\t\t\tif (hist[j] == 1) ++c1;\n\t\t}\n\t\tif (!ok || c1 < c2) continue;\n\t\tint s1 = (c1 - c2) / 3, s2 = c2, s3 = c3;\n\t\tint sub = (long long)(fact[c1]) * factinv[c1 - c2] % mod * val[s1] % mod;\n\t\tif (cnt % 2 == 0) ans = (ans + sub) % mod;\n\t\telse ans = (ans - sub + mod) % mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000009LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll fact[3000005];\nll extgcd(ll a,ll b,ll& x,ll &y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\nint n,m;\nint a[20],b[20],c[20];\nll dp[1000005];\nvector<int> G[3000005];\nbool used[3000005];\nint siz[5];\nint now=0;\n\nvoid dfs(int v){\n\tnow++;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(ll i=1;i<=n*3;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i-1]*mod_comb(i*3,3,MOD)%MOD;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tqueue<int> que,cla;\n\t\tbool flag=true;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i>>j & 1){\n\t\t\t\tG[a[j]].push_back(b[j]);\n\t\t\t\tG[b[j]].push_back(a[j]);\n\t\t\t\tque.push(a[j]);\n\t\t\t\tque.push(b[j]);\n\t\t\t\tcla.push(a[j]);\n\t\t\t\tcla.push(b[j]);\n\t\t\t\tif(c[j]==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(c[j]==0)flag=false;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbool ng=false;\n\t\t\tmemset(siz,0,sizeof(siz));\n\t\t\twhile(que.size()){\n\t\t\t\tint v=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(!used[v]){\n\t\t\t\t\tnow=0;\n\t\t\t\t\tdfs(v);\n\t\t\t\t\tif(now>=4){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsiz[now]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ng)goto bye;\n\t\t\tsiz[1]=3*n-siz[2]*2-siz[3]*3;\n\t\t\tll val=1;\n\t\t\twhile(siz[2]>0){\n\t\t\t\tval=val*siz[1]%MOD;\n\t\t\t\tsiz[1]--;\n\t\t\t\tsiz[2]--;\n\t\t\t}\n\t\t\tval=val*dp[siz[1]/3]%MOD;\n\t\t\tif(cnt%2==0){\n\t\t\t\tans=(ans+val)%MOD;\n\t\t\t}else{\n\t\t\t\tans=(ans-val+MOD)%MOD;\n\t\t\t}\n\t\t}\n\t\tbye:\n\t\twhile(cla.size()){\n\t\t\tint v=cla.front();\n\t\t\tcla.pop();\n\t\t\tused[v]=false;\n\t\t\tG[v].clear();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    assert((n-cnt)%3==0);\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcount(i)%2==1)ans+=calc(AA);\n        else ans-=calc(AA);\n    }\n\n    cout<<calc(A)-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t/*\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}*/\n\t\tMod a = n==2?rest:1;\n\t\tMod b = comb(rest, 3 - n);\n\t\twhile (a != b) {\n\t\t\tcout << 22 << endl;\n\t\t}\n\t\tans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 1000000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\t\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t/*if (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}*/\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\tif (rest >= 3 - n) {\n\n\t\t\tans *= comb(rest, 3 - n);\n\t\t}\n\t\telse {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000009LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll fact[3000005];\nll extgcd(ll a,ll b,ll& x,ll &y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\nint n,m;\nint a[20],b[20],c[20];\nll dp[1000005];\nvector<int> G[3000005];\nbool used[3000005];\nint siz[5];\nint now=0;\n\nvoid dfs(int v){\n\tnow++;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(ll i=1;i<=n*3;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i-1]*mod_comb(i*3,3,MOD)%MOD;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tqueue<int> que,cla;\n\t\tbool flag=true;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i>>j & 1){\n\t\t\t\tG[a[j]].push_back(b[j]);\n\t\t\t\tG[b[j]].push_back(a[j]);\n\t\t\t\tque.push(a[j]);\n\t\t\t\tque.push(b[j]);\n\t\t\t\tcla.push(a[j]);\n\t\t\t\tcla.push(b[j]);\n\t\t\t\tif(c[j]==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(c[j]==0)flag=false;\n\t\t\t}\n\t\t}\n\t\tbool ng=false;\n\t\tif(flag){\n\t\t\tmemset(siz,0,sizeof(siz));\n\t\t\twhile(que.size()){\n\t\t\t\tint v=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(!used[v]){\n\t\t\t\t\tnow=0;\n\t\t\t\t\tdfs(v);\n\t\t\t\t\tif(now>=4){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsiz[now]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ng)goto bye;\n\t\t\tsiz[1]=3*n-siz[2]*2-siz[3]*3;\n\t\t\tll val=1;\n\t\t\twhile(siz[2]>0){\n\t\t\t\tval=val*siz[1]%MOD;\n\t\t\t\tsiz[1]--;\n\t\t\t\tsiz[2]--;\n\t\t\t}\n\t\t\tval=val*dp[siz[1]/3]%MOD;\n\t\t\tif(cnt%2==0){\n\t\t\t\tans=(ans+val)%MOD;\n\t\t\t}else{\n\t\t\t\tans=(ans-val+MOD)%MOD;\n\t\t\t}\n\t\t}\n\t\tbye:\n\t\twhile(cla.size()){\n\t\t\tint v=cla.front();\n\t\t\tcla.pop();\n\t\t\tused[v]=false;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n >= 2) {\n\t\t\t/*if (n == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}*/\n\t\t\tans *= comb(rest, 3 - n);\n\t\t\trest -= (3-n);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n        assert(0<=ans&&ans<mod);\n        assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\t/*if (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}*/\n\t\t\tif (rest < 3 - m.second)return 0;\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t\tif (rest < 0)return 0;\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t/*if (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}*/\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\tif (rest >= 3 - n) {\n\n\t\t\tans *= comb(rest, 3 - n);\n\t\t}\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tif (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, int> dict(const vector<T> &v){\n  map<T, int> res;\n  for(int i=0;i<(int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m),b(m),c(m);\n  for(int i=0;i<m;i++) cin>>a[i]>>b[i]>>c[i];\n  UnionFind uf(3*n);\n  for(int i=0;i<m;i++){\n    a[i]--;b[i]--;\n    if(c[i]==0) uf.unite(a[i],b[i]); \n  }\n  \n  int one=0,two=0;\n  for(int i=0;i<3*n;i++){\n    if(uf.find(i)!=i) continue;\n    if(uf.r[i]>3){\n      cout<<0<<endl;\n      return 0;\n    }\n    if(uf.r[i]==1) one++;\n    if(uf.r[i]==2) two++;\n  }\n  \n  using P = pair<int, int>;\n  vector<P> ps;\n  for(int i=0;i<m;i++){\n    if(c[i]==0) continue;\n    if(uf.same(a[i],b[i])){\n      cout<<0<<endl;\n      return 0;\n    }\n    int x=uf.find(a[i]),y=uf.find(b[i]);\n    if(x>y) swap(x,y);\n    if(uf.r[x]+uf.r[y]<=3)\n      ps.emplace_back(x,y);\n  }\n  ps=compress(ps);\n  int w=ps.size();\n  \n  using M = Mint<int, int(1e9+7)>;\n  M ans;\n  vector<M> po(n<<1,1);\n  M r6=M(6).inv();\n  for(int i=1;i<(int)po.size();i++) po[i]=po[i-1]*r6;\n  M::init(n<<2);\n\n  vector<int> vs;\n  for(auto p:ps){\n    vs.emplace_back(p.first);\n    vs.emplace_back(p.second);    \n  }\n  vs=compress(vs);\n  auto rev=dict(vs);\n  \n  for(int b=0;b<(1<<w);b++){\n    int os=one,ts=two;\n    UnionFind sz(vs.size());\n    for(int i=0;i<(int)vs.size();i++){\n      sz.r[i]=uf.r[vs[i]];\n      if(sz.r[i]==1) os--;\n      if(sz.r[i]==2) ts--;\n    }\n    for(int i=0;i<w;i++)\n      if((b>>i)&1) sz.unite(rev[ps[i].first],rev[ps[i].second]);\n    \n    int flg=0;\n    for(int i=0;i<(int)vs.size();i++){\n      if(sz.find(i)!=i) continue;\n      flg|=sz.r[i]>3;      \n      if(sz.r[i]==1) os++;\n      if(sz.r[i]==2) ts++;\n    }\n    if(flg||ts>os) continue;\n    M res=M::P(os,ts);\n    res*=M::fact[os-ts]*po[(os-ts)/3]*M::finv[(os-ts)/3];\n    ans+=__builtin_parity(b)?-res:res;\n  }\n\n  cout<<ans.v<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\n\n#define MAX_N 3000001\n\ntypedef long long int64;\n\nconst int64 mod = 1e9 + 9;\n\ninline int64 extgcd(int64 a, int64 b, int64 &x, int64 &y) {\n  int64 d = a;\n  if(b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  else x = 1, y = 0;\n  return d;\n}\n\ninline int64 modPow(int64 x, int64 n) {\n  if(n == 0) return 1;\n  int64 ret = modPow(x, n/2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return ret;\n}\n\ninline int64 modInv(int64 a) {\n  return modPow(a, mod - 2);\n}\n\ninline int64 modFact(int n) {\n  int64 ret = 1;\n  while(n > 1) (ret *= n--) %= mod;\n  return ret;\n}\n\nint64 fact[MAX_N], invfact[MAX_N];\nvoid init() {\n  fact[0] = invfact[0] = 1;\n  for(int i = 1; i < MAX_N; i++) {\n    fact[i] = fact[i-1] * i % mod;\n    invfact[i] = modInv(fact[i]);\n  }\n}\n\ninline int64 modComb(int64 n, int64 r) {\n  if(r < 0 || n < r) return 0;\n  return fact[n] * invfact[r] % mod * invfact[n-r] % mod;\n}\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y]; data[y] = x;\n    return;\n  }\n};\n\nint pow6[MAX_N];\nint invpow6[MAX_N];\nint calc(int& n, vector<Tapris>& vec) {\n  UnionFind uf(n);\n  set<int> st;\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 1) continue;\n    uf.unite(a, b);\n    st.insert(a);\n    st.insert(b);\n  }\n  int x = 0, y = 0;\n  for(int a : st) {\n    if(uf.find(a) == a) {\n      int sz = uf.size(a);\n      if(sz >= 4) return 0;\n      else if(sz == 2) ++y;\n    }\n  }\n  //cout<<n<<endl;\n  x = n - st.size();\n  //cout << x << \" \" << y << endl;\n  if(y > x) return 0;\n  int z = (x-y)/3;\n  //cout<<z<<endl;\n  //cout<<modFact(x)<<\" \"<<modPow(6, z)<<\" \"<<modInv(modPow(6, z))<<\" \"<<modFact(z)<<\" \"<<modInv(modFact(z))<<endl;\n  //return modFact(x)*modInv(modPow(3*2*1, z))%mod*modInv(modFact(z))%mod;\n  //cout << x << \" \" << fact[x] << \" \" << invfact[z] << endl;\n  return fact[x]*invpow6[z]%mod*invfact[z]%mod;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  init();\n  pow6[0] = invpow6[0] = 1;\n  reps(i, 1, MAX_N) {\n    pow6[i] = pow6[i-1]*6 % mod;\n    invpow6[i] = modInv(pow6[i]);\n  }\n\n  int n, m;\n  cin >> n >> m;\n  n *= 3;\n  vector<Tapris> vec;\n  vector<int> badidx;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c; --a, --b;\n    vec.emplace_back(a, b, c);\n    if(c == 1) badidx.push_back(i);\n  }\n  //cout<<calc(n, vec)<<endl;\n  int bad = badidx.size();\n  int ans = 0;\n  rep(bit, 1<<bad) {\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 0;\n    if(__builtin_popcount(bit)%2) ans = (ans-calc(n, vec)+mod) % mod;\n    else ans = (ans+calc(n, vec)) % mod;\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 1;\n  }\n  cout << ans%mod << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_map>\nusing namespace std;\nconst int N=1000100,P=1e9+9;\n#define X first\n#define Y second\nint a[18],b[18],c[18],dp[N];\nunordered_map<int,int>f,sz;\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tint n,m,ans=0;\n\tscanf(\"%d%d\",&n,&m);\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++)dp[i]=1ll*(3*i-1)*(3*i-2)/2%P*dp[i-1]%P;\n\tfor(int i=0;i<m;i++)scanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\tfor(int i=0;i<(1<<m);i++)\n\t{\n\t\tint coef=1,res=1,cnt[4]={};\n\t\tbool ff=0;f.clear();sz.clear();\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(i&(1<<j))\n\t\t\t{\n\t\t\t\tif(c[j])coef*=-1;\n\t\t\t\tif(!f.count(a[j]))f[a[j]]=a[j],sz[a[j]]=1;\n\t\t\t\tif(!f.count(b[j]))f[b[j]]=b[j],sz[b[j]]=1;\n\t\t\t\tif(f[a[j]]!=f[b[j]])\n\t\t\t\t{\n\t\t\t\t\tif(sz[f[a[j]]]+sz[f[b[j]]]>3)ff=1;\n\t\t\t\t\telse if(sz[f[a[j]]]<sz[f[b[j]]])f[a[j]]=f[b[j]],sz[f[b[j]]]++;\n\t\t\t\t\telse f[b[j]]=f[a[j]],sz[f[a[j]]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(!c[j]) coef=0;\n\t\t}\n\t\tif(!ff)\n\t\t{\n\t\t\tfor(auto it=f.begin();it!=f.end();++it)if(it->X==it->Y)cnt[sz[it->X]]++;\n\t\t\tcnt[1]=3*n-2*cnt[2]-3*cnt[3];\n\t\t\tfor(int i=0;i<cnt[2];i++){res=1LL*res*cnt[1]%P;cnt[1]--;}\n\t\t\tres=1LL*res*dp[cnt[1]/3]%P;\n\t\t}\n\t\telse res=0;\n\t\tans=(ans+1ll*res*(P+coef))%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\nconstexpr ll MOD = 1000000009;\nconstexpr ll INV6 = MOD - 166666668;\ntemplate <ll mod = MOD>\nclass ModCombination\n{\npublic:\n    ModCombination(const std::size_t n) : fact(n + 1, 1), inv(n + 1, 1), inv_fact(n + 1, 1)\n    {\n        for (ll i = 2; i <= (ll)n; i++) { fact[i] = (fact[i - 1] * i) % mod, inv[i] = ((mod - (mod / i)) * inv[mod % i]) % mod, inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod; }\n    }\n    ll factorial(const std::size_t n) const { return fact[n]; }\n    ll inverse(const std::size_t n) const { return inv[n]; }\n    ll inverseFactorial(const std::size_t n) const { return inv_fact[n]; }\n    ll permutation(const std::size_t n, const std::size_t k) const { return (fact[n] * inv_fact[n - k]) % mod; }\n    ll combination(const std::size_t n, const std::size_t k) const { return (((fact[n] * inv_fact[k]) % mod) * inv_fact[n - k]) % mod; }\n\nprivate:\n    std::vector<ll> fact, inv, inv_fact;\n};\nint main()\n{\n    int N, M;\n    std::cin >> N >> M;\n    std::vector<std::vector<int>> gorig(3 * N);\n    using P = std::pair<int, int>;\n    std::vector<P> bad;\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        std::cin >> a >> b >> c, a--, b--;\n        if (c == 0) {\n            gorig[a].push_back(b), gorig[b].push_back(a);\n        } else {\n            bad.push_back({std::min(a, b), std::max(a, b)});\n        }\n    }\n    bad.shrink_to_fit();\n    std::vector<int> comp(3 * N, -1);\n    for (int i = 0; i < 3 * N; i++) {\n        if (comp[i] != -1) { continue; }\n        std::queue<int> q;\n        q.push(i), comp[i] = i;\n        while (not q.empty()) {\n            const int p = q.front();\n            q.pop();\n            for (const int to : gorig[p]) {\n                if (comp[to] == -1) { comp[to] = i, q.push(to); }\n            }\n        }\n    }\n    comp.shrink_to_fit();\n    gorig.clear(), gorig.shrink_to_fit();\n    std::vector<int> num(3 * N, 0);\n    for (int i = 0; i < 3 * N; i++) {\n        num[comp[i]]++;\n        if (num[comp[i]] > 3) { return std::cout << 0 << std::endl, 0; }\n    }\n    std::unordered_map<int, int> mp;\n    std::vector<int> s;\n    int c = 0;\n    for (int i = 0; i < 3 * N; i++) {\n        if (num[i] > 0 and num[i] <= 3) { mp[i] = c, c++, s.push_back(num[i]); }\n    }\n    num.clear(), num.shrink_to_fit();\n    std::set<int> con;\n    for (const auto& p : bad) {\n        const int i = p.first, j = p.second;\n        const int CI = comp[i], CJ = comp[j];\n        if (mp.find(CI) == mp.end() or mp.find(CJ) == mp.end()) { continue; }\n        const int ci = mp[comp[i]], cj = mp[comp[j]];\n        con.insert(ci), con.insert(cj);\n        if (ci == cj) { return std::cout << 0 << std::endl, 0; }\n    }\n    const int B = bad.size();\n    const int maximum = 1 << B;\n    ll ans = 0;\n    ModCombination<MOD> mod(N * 3);\n    std::vector<ll> invpow(N + 1, 1);\n    invpow.shrink_to_fit();\n    for (int i = 1; i <= N; i++) { invpow[i] = invpow[i - 1] * INV6 % MOD; }\n    int T = 0, O = 0;\n    std::vector<int> node;\n    std::unordered_map<int, int> mp2;\n    for (int i = 0; i < c; i++) {\n        if (con.find(i) != con.end()) {\n            mp2[i] = node.size();\n            node.push_back(i);\n        } else {\n            if (s[i] == 1) { O++; }\n            if (s[i] == 2) { T++; }\n        }\n    }\n    node.shrink_to_fit();\n    con.clear();\n    const int sz = node.size();\n    auto func = [&](const int one, const int two) {\n        if (two > one) { return 0LL; }\n        ll ans = mod.permutation(one, two);\n        const int P = (one - two) / 3;\n        return ((mod.factorial(3 * P) * mod.inverseFactorial(P) % MOD) * invpow[P] % MOD) * ans % MOD;\n    };\n    for (int i = 0; i < maximum; i++) {\n        std::vector<std::vector<int>> g(sz);\n        int bit = 0;\n        for (int j = 0; j < B; j++) {\n            if (i & (1 << j)) {\n                bit++;\n                const auto& p = bad[j];\n                const int i = p.first, j = p.second;\n                const int ci = mp2[mp[comp[i]]], cj = mp2[mp[comp[j]]];\n                g[ci].push_back(cj), g[cj].push_back(ci);\n            }\n        }\n        g.shrink_to_fit();\n        std::vector<bool> used(sz, false);\n        used.shrink_to_fit();\n        bool NG = false;\n        int o = O, t = T;\n        for (int i = 0; i < sz; i++) {\n            if (used[i]) { continue; }\n            int sum = 0;\n            std::queue<int> q;\n            q.push(i), used[i] = true;\n            while (not q.empty()) {\n                const int p = q.front();\n                sum += s[node[p]];\n                if (sum > 3) {\n                    NG = true;\n                    break;\n                }\n                q.pop();\n                for (const int to : g[p]) {\n                    if (not used[to]) { used[to] = true, q.push(to); }\n                }\n            }\n            if (not NG) {\n                if (sum == 1) { o++; }\n                if (sum == 2) { t++; }\n            }\n        }\n        if (not NG) {\n            const ll f = func(o, t);\n            const ll plus = f * (bit % 2 == 0 ? 1 : MOD - 1) % MOD;\n            (ans += plus) %= MOD;\n        }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, Mod>memo;\nvector<Mod>dp(3e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn dp[rest];\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==1){\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 3; i <= 300000; ++i) {\n\t\tdp[i] = dp[i - 3] * Mod(i - 1)*Mod(i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\ninline char nc(){\n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2)  return EOF; }\n  return *p1++;\n}\n\ninline void read(int &x){\n  char c=nc(),b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\nconst int N=1000005;\n\nstruct modi{  \n  int x,y,r;  \n}Stk[N]; int pnt;  \nint fat[N],rnk[N],size[N];  \n  \ninline int Fat(int u){  \n  return u==fat[u]?u:Fat(fat[u]);  \n}\n\nint cot[N];\nint flag=0;\n\ninline int Merge(int x,int y){  \n  x=Fat(x); y=Fat(y); if (x==y) return 0;  \n  if (rnk[x]>rnk[y]) swap(x,y);  \n  Stk[++pnt].x=x; Stk[pnt].y=y; Stk[pnt].r=0;  \n  if (rnk[x]==rnk[y]) rnk[y]++,Stk[pnt].r=1;  \n  fat[x]=y; cot[size[y]]--; cot[size[x]]--; size[y]+=size[x]; cot[size[y]]++;\n  if (size[y]>3) flag=1;\n  return 1;  \n}\n\ninline void Back(int t){  \n  for (;pnt>t;pnt--){\n    int x=Stk[pnt].x,y=Stk[pnt].y;\n    fat[Stk[pnt].x]=Stk[pnt].x;  \n    if (Stk[pnt].r) rnk[Stk[pnt].y]--;\n    cot[size[y]]--; size[y]-=size[x]; \n    cot[size[y]]++; cot[size[x]]++; \n  }  \n}\n\nconst ll P=1e9+9;\n\nll fac[N],inv[N];\n\nint tot;\nint us[20],vs[20],ws[20];\nint n,m;\n\ninline ll Pow(ll a,int b){\n  ll ret=1;\n  for (;b;b>>=1,a=a*a%P)\n    if (b&1)\n      ret=ret*a%P;\n  return ret;\n}\n\ninline void Pre(int n){  \n  fac[0]=1; for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%P;\n  inv[0]=1; for (int i=1;i<=n/3;i++) (inv[i]=inv[i-1]*6)%=P;\n  for (int i=1;i<=n/3;i++) inv[i]=Pow(inv[i],P-2);\n}\n\ninline ll Calc(int a,int b,int c){\n  if (b>a) return 0;\n  return fac[a]*inv[(a-b)/3]%P;\n}\n\nint main(){\n  read(n); read(m); n*=3;\n  Pre(n);\n  tot=0;\n  for (int i=1;i<=n;i++) fat[i]=i,size[i]=1;\n  flag=0; cot[1]=n;\n  for (int i=1;i<=m;i++){\n    ++tot;\n    read(us[tot]),read(vs[tot]),read(ws[tot]);\n    if (ws[tot]==0)\n      Merge(us[tot],vs[tot]),tot--;      \n  }\n  if (flag){\n    printf(\"0\\n\");\n    return 0;\n  }\n  ll Ans=Calc(cot[1],cot[2],cot[3]);\n  int tmp=pnt;\n  for (int i=1;i<(1<<tot);i++){\n    flag=0; int c=0;\n    for (int j=1;j<=tot;j++)\n      if (i>>(j-1)&1)\n\tMerge(us[j],vs[j]),c++;   \n    if (!flag){\n      if (c&1)\n\t(Ans+=P-Calc(cot[1],cot[2],cot[3]))%=P;\n      else\n\t(Ans+=Calc(cot[1],cot[2],cot[3]))%=P;\n    }\n    Back(tmp);\n  }\n  printf(\"%lld\\n\",Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n        assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, Mod>memo;\nvector<Mod>dp(3e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn dp[rest];\n\t}\n}\nMod getans(map<int,int>mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==1){\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 3; i <= 300000; ++i) {\n\t\tdp[i] = dp[i - 3] * Mod(i - 1)*Mod(i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\t/*if (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}*/\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tcout << 2 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tif (m.second == 2) {\n\t\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 1;\n\t\t\t}\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcount(i)%2==1)ans+=calc(AA);\n        else ans-=calc(AA);\n    }\n\n    cout<<calc(A)-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000009\n\nint n,m;\nll modpow(ll x,ll n)\n{\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[3000005],R[3000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<3000005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<3000005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int a,int b){ return F[a]*R[b]%mod*R[a-b]%mod; }\nvector<P>eq,neq;\nint par[3000005],ran[3000005];\nvoid init(){ for(int i=0;i<3000005;i++) par[i] = i,ran[i] = 0; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nint main(){\n\tcin >> n >> m; make();\n\tfor(int i=0;i<m;i++){\n\t\tint p,q,a;\n\t\tcin >> p >> q >> a;\n\t\tif(a == 0) eq.pb(mp(p,q));\n\t\telse neq.pb(mp(p,q));\n\t}\n\tint x = neq.size();\n\tll ret = 0;\n\tinit();\n\tfor(int i=0;i<(1<<x);i++){\n\t\tvector<P>E = eq;\n\t\tvector<int>vi;\n\t\tfor(int j=0;j<x;j++){\n\t\t\tif(((i>>j)&1)) E.pb(neq[j]);\n\t\t}\n\t\tset<int>se;\n\t\tmap<int,int>ma;\n\t\tfor(int j=0;j<E.size();j++){\n\t\t\tint s = E[j].fi,t = E[j].sc;\n\t\t\tunite(s,t);\n\t\t\tse.insert(s); se.insert(t);\n\t\t}\n\t\tint zan = 3*n-se.size();\n\t\tfor(set<int>::iterator it = se.begin();it != se.end();++it){\n\t\t\tma[find(*it)]++;\n\t\t}\n\t\tfor(set<int>::iterator it = se.begin();it != se.end();++it){\n\t\t\tpar[*it] = *it; ran[*it] = 0;\n\t\t}\n\t\tll val = 1;\n\t\tfor(map<int,int>::iterator it = ma.begin();it !=ma.end();++it){\n\t\t\tif( it->sc > 3) val = 0;\n\t\t\tval = val * C(zan,3-it->sc) % mod;\n\t\t\tzan -= (3-it->sc);\n\t\t}\n\t\tint k = zan/3;\n\t\tval = val*F[3*k]%mod;\n\t\tval = val*modpow(modpow(6,mod-2),k)%mod; \n\t\tif(__builtin_popcount(i)%2 == 0) ret = (ret+val)%mod;\n\t\telse ret = (ret+mod-val)%mod;\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax=MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\treturn dp[rest/3];\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tcin >> N >> M;\n\n\tfor (int i = 1; i <= N+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3 * i - 1)*Mod(3 * i - 2) / Mod(2);\n\t}\n\tinit(3*N+10);\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\tassert(a >= b);\n\tassert(a >= 0 && b >= 0);\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 10);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tans *= comb(rest, 3 - n);\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 1e6+1; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n    assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp,int rest) {\n\tif (mp.size()>N)return 0;\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tif (rest < 3 - m.second)return 0;\n\t\t\tif (m.second == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}\n\t\t\t//ans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t\tif (rest < 0)return 0;\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000009LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll fact[3000005];\nll extgcd(ll a,ll b,ll& x,ll &y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\nint n,m;\nint a[20],b[20],c[20];\nll dp[1000005];\nvector<int> G[3000005];\nbool used[3000005];\nint siz[5];\nint now=0;\n\nvoid dfs(int v){\n\tnow++;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(ll i=1;i<=n*3;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i-1]*mod_comb(i*3,3,MOD)%MOD;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i]*mod_inverse(fact[i],MOD)%MOD;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tqueue<int> que,cla;\n\t\tbool flag=true;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i>>j & 1){\n\t\t\t\tG[a[j]].push_back(b[j]);\n\t\t\t\tG[b[j]].push_back(a[j]);\n\t\t\t\tque.push(a[j]);\n\t\t\t\tque.push(b[j]);\n\t\t\t\tcla.push(a[j]);\n\t\t\t\tcla.push(b[j]);\n\t\t\t\tif(c[j]==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(c[j]==0)flag=false;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbool ng=false;\n\t\t\tmemset(siz,0,sizeof(siz));\n\t\t\twhile(que.size()){\n\t\t\t\tint v=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(!used[v]){\n\t\t\t\t\tnow=0;\n\t\t\t\t\tdfs(v);\n\t\t\t\t\tif(now>=4){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsiz[now]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ng)goto bye;\n\t\t\tsiz[1]=3*n-siz[2]*2-siz[3]*3;\n\t\t\tll val=1;\n\t\t\twhile(siz[2]>0){\n\t\t\t\tval=val*siz[1]%MOD;\n\t\t\t\tsiz[1]--;\n\t\t\t\tsiz[2]--;\n\t\t\t}\n\t\t\tval=val*dp[siz[1]/3]%MOD;\n\t\t\tif(cnt%2==0){\n\t\t\t\tans=(ans+val)%MOD;\n\t\t\t}else{\n\t\t\t\tans=(ans-val+MOD)%MOD;\n\t\t\t}\n\t\t}\n\t\tbye:\n\t\twhile(cla.size()){\n\t\t\tint v=cla.front();\n\t\t\tcla.pop();\n\t\t\tused[v]=false;\n\t\t\tG[v].clear();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\nusing ll = long long int;\nconst ll MOD = 1000000009;\n\n// Union-Find  (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int size_;\n    vector<int> uf;\npublic:\n    //  UnionFind uni(n) \n    UnionFind(int _n) : n(_n), size_(_n), uf(_n, -1) {}\n    // find ()\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x  y \n    bool same(int x, int y) {return find(x) == find(y);}\n    // x \n    int size(int x) {return -uf[find(x)];}\n    // \n    int size()      {return size_;}\n    // x  y \n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        size_--;\n        if(-uf[x] < -uf[y]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n        return true;\n    }\n};\n\nll mod_pow(ll n, ll k) {\n    ll res = 1;\n    for(; k>0; k>>=1) {\n        if(k & 1) (res *= n) %= MOD;\n        (n *= n) %= MOD;\n    }\n    return res;\n}\n\nconst int MAXN = 4000010;\nll fact[MAXN+5], finv[MAXN+5];\n\nvoid init() {\n    fact[0] = 1;\n    for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1] * i % MOD;\n\n    finv[MAXN] = mod_pow(fact[MAXN], MOD-2);\n    for(int i=MAXN-1; i>=0; i--) finv[i] = finv[i+1] * (i+1) % MOD;\n}\n\nll nPr(int n, int r) {\n    if(n < r or r < 0) return 0;\n    return fact[n] * finv[n-r] % MOD;\n}\n\nll make_group(ll n) {\n    ll g = n / 3;\n    ll inv = mod_pow(mod_pow(6, g), MOD-2);\n    return fact[n] * inv % MOD * finv[g] % MOD;\n}\n\nint main() {\n    init();\n    ll N, M; cin >> N >> M;\n    vector< pair<int, int> > good, bad;\n\n    map<int, int> cmp;\n    for(int i=0; i<M; i++) {\n        int a, b, c; cin >> a >> b >> c; a--; b--;\n        (c == 0 ? good : bad).emplace_back(a, b);\n        cmp[a]++; cmp[b]++;\n    }\n\n    int K = 0;\n    for(auto &e : cmp) e.second = K++;\n\n    for(auto &e : good) e.first = cmp[e.first], e.second = cmp[e.second];\n    for(auto &e : bad ) e.first = cmp[e.first], e.second = cmp[e.second];\n    \n    UnionFind uf(K);\n    for(auto e : good) {\n        int a, b; tie(a, b) = e;\n        uf.unite(a, b);\n    }\n\n    ll ans = 0;\n    vector<bool> used(K);\n    for(int bit=0; bit<(1<<(int)bad.size()); bit++) {\n        fill(used.begin(), used.end(), false);\n        UnionFind uf_c = uf;\n        for(size_t i=0; i<bad.size(); i++) {\n            if(!(bit >> i & 1)) continue;\n            int a, b; tie(a, b) = bad[i];\n            uf_c.unite(a, b);\n        }\n\n        int cnt[5] = {};\n        cnt[1] = 3*N - K;\n        for(int i=0; i<K; i++) {\n            if(used[ uf_c.find(i) ]) continue;\n            used[ uf_c.find(i) ] = true;\n            int sz = uf_c.size(i);\n            cnt[min(4, sz)]++;\n        }\n\n        if(cnt[4] > 0 or cnt[1] < cnt[2]) continue;\n\n        ll add = 1;\n        \n        // 1 2  (cnt[1] P cnt[2])\n        (add *= nPr(cnt[1], cnt[2])) %= MOD;\n        cnt[1] -= cnt[2];\n\n        // 1  3 \n        (add *= make_group(cnt[1])) %= MOD;\n\n        // fprintf(stderr, \"add = %lld\\n\", add);\n        \n        // \n        if(__builtin_parity(bit)) ans = (ans - add + MOD) % MOD;\n        else ans = (ans + add) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    assert(0<=n&&n<=3*N);\n    assert(n-cnt>=0);\n    //assert((n-cnt)%3==0);\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n  //  assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 3024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\tint rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t/*\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\t\tassert(n == 3);\n\t\t\tans *= 1;\n\t\t}*/\n\t\tMod a = n==2?rest:1;\n\t\tMod b = comb(rest, 3 - n);\n\t\twhile (a != b) {\n\t\t\tcout << 22 << endl;\n\t\t}\n\t\tans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nmap<int, Mod>memo;\nvector<Mod>dp(3e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn dp[rest];\n\t}\n}\nMod getans(const map<int,int>&mp,int rest) {\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\t\n\t\telse if(m.second==1){\n\t\t\tassert(m.second == 1);\n\t\t\trest++;\n\t\t}\n\t}\n\tfor (auto m : mp) {\n\t\tif (m.second >= 2) {\n\t\t\tans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-m.second);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 3; i <= 300000; ++i) {\n\t\tdp[i] = dp[i - 3] * Mod(i - 1)*Mod(i - 2) / Mod(2);\n\t}\n\tinit();\n\tint N, M; cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\tcout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp,3*N-aset.size());\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp,3*N-aset.size());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define vi vector<int>\n#define pr pair<int,int>\n#define Rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define For(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n#define debug(x) {cout<<(#x)<<\" \"<<x<<endl;}\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=40,INF=9999999;\nconst ll P=1e9+9;\n\ntemplate<typename T>\ninline void read(T& x,char s=getchar()) {\n\tx=0;\n\twhile(s>'9'||s<'0') s=getchar();\n\twhile(s<='9'&&s>='0') x=x*10+s-'0',s=getchar();\n}\n\ninline ll _pow(ll a,ll b,ll r=1) {\n\twhile(b) {\n\t\tif(b&1) (r*=a)%=P;\n\t\t(a*=a)%=P;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nvector<pr> a,b;\nmap<int,int> ma;\nint cnt;\nint c[N];\nint fa[N];\nll js[3000005];\nll fq[3000005];\n\ninline int find(int x) {\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\n\ninline void unionn(int x,int y) {\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx!=fy) fa[fy]=fx;\n}\n\nint main() {\n\tint n,m,x,y,t;\n\tll ans=0;\n\tcin>>n>>m;\n\tjs[0]=fq[0]=1;\n\tfor(int i=1;i<=3*n;i++) {\n\t\tjs[i]=js[i-1]*i%P;\n\t\tif(i%3==0) {\n\t\t\tfq[i]=fq[i-3]*i*2%P; \n\t\t\t//if(i<=10) cout<<fq[i]<<\" \";\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=m;i++) {\n\t\tcin>>x>>y>>t;\n\t\tif(ma.count(x)) x=ma[x];\n\t\telse ma[x]=++cnt,x=cnt;\n\t\tif(ma.count(y)) y=ma[y];\n\t\telse ma[y]=++cnt,y=cnt;\n\t\t\n\t\tif(t==0) {\n\t\t\ta.pb(mp(x,y));\n\t\t}\n\t\telse {\n\t\t\tb.pb(mp(x,y));\n\t\t}\n\t}\n\tfor(int j=0;j<(1<<b.size());j++) {\n\t\tll num=0;\n\t\tfor(int i=1;i<=cnt;i++) fa[i]=i;\n\t\tfor(int i=0;i<a.size();i++) {\n\t\t\tunionn(a[i].x,a[i].y);\n\t\t}\n\t\tfor(int i=0;i<b.size();i++) {\n\t\t\tif(j&(1<<i)) {\n\t\t\t\tnum++;\n\t\t\t\tunionn(b[i].x,b[i].y);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"num: \"<<j<<\" \"<<num<<endl;\n\t\tnum=num&1?-1:1;\n\t\t\n//\t\tcout<<num<<\": \";\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(int i=1;i<=cnt;i++) {\n\t\t\tc[find(i)]++;\n\t\t}\n\t\tint _n=n;\n\t\tint qindian=0;\n\t\tll tot=1;\n\t\tfor(int i=1;i<=cnt;i++) {\n//\t\t\tcout<<c[i]<<\" \";\n\t\t\tif(c[i]>3) {\n\t\t\t\ttot=0;\n//\t\t\t\tcout<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[i]==3) _n--;\n\t\t\tif(c[i]==2) qindian++;\n\t\t}\n//\t\tcout<<endl;\n\t\t\n\t\tif(tot==0) continue;\n\t\t\n//\t\tll test=_pow(6,P-2)*6%P;\n//\t\tcout<<\"-==>\"<<test<<endl;\n\t\t\n\t\ttot=js[_n*3-qindian*2]*_pow(js[_n*3-qindian*3],P-2)%P;\n//\t\tcout<<\"-->\"<<_n*3-qindian*2<<\" \"<<_n*3-qindian*3<<endl;\n//\t\tcout<<\"-->\"<<js[_n*3-qindian*2]<<\" \"<<js[_n*3-qindian*3]<<endl;\n//\t\tcout<<\"-->\"<<tot<<endl;\n\t\t_n-=qindian;\n//\t\tcout<<\"__n: \"<<_n<<endl;\n\t\ttot=tot*js[_n*3]%P*_pow(fq[_n*3],P-2)%P;\n//\t\tcout<<\"-->\"<<tot<<endl;\n\t\tans=(ans+P+num*tot)%P;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n2 3\n1 2 0\n3 5 0\n3 4 1\n\n2 2\n1 2 0\n3 4 1\n\n10003 2\n1 2 0\n3 4 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\t\n\n\t}\n\twhile (b < 0 || a < 0) {\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\t/*if (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}*/\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\tif (rest >= 3 - n) {\n\n\t\t\tans *= comb(rest, 3 - n);\n\t\t}\n\t\telse {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\ninline char nc(){\n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2)  return EOF; }\n  return *p1++;\n}\n\ninline void read(int &x){\n  char c=nc(),b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\nconst int N=1000005;\n\nstruct modi{  \n  int x,y,r;  \n}Stk[N]; int pnt;  \nint fat[N],rank[N],size[N];  \n  \ninline int Fat(int u){  \n  return u==fat[u]?u:Fat(fat[u]);  \n}\n\nint cot[N];\nint flag=0;\n\ninline int Merge(int x,int y){  \n  x=Fat(x); y=Fat(y); if (x==y) return 0;  \n  if (rank[x]>rank[y]) swap(x,y);  \n  Stk[++pnt].x=x; Stk[pnt].y=y; Stk[pnt].r=0;  \n  if (rank[x]==rank[y]) rank[y]++,Stk[pnt].r=1;  \n  fat[x]=y; cot[size[y]]--; cot[size[x]]--; size[y]+=size[x]; cot[size[y]]++;\n  if (size[y]>3) flag=1;\n  return 1;  \n}\n\ninline void Back(int t){  \n  for (;pnt>t;pnt--){\n    int x=Stk[pnt].x,y=Stk[pnt].y;\n    fat[Stk[pnt].x]=Stk[pnt].x;  \n    if (Stk[pnt].r) rank[Stk[pnt].y]--;\n    cot[size[y]]--; size[y]-=size[x]; \n    cot[size[y]]++; cot[size[x]]++; \n  }  \n}\n\nconst ll P=1e9+9;\n\nll fac[N],inv[N];\n\nint tot;\nint us[20],vs[20],ws[20];\nint n,m;\n\ninline ll Pow(ll a,int b){\n  ll ret=1;\n  for (;b;b>>=1,a=a*a%P)\n    if (b&1)\n      ret=ret*a%P;\n  return ret;\n}\n\ninline void Pre(int n){  \n  fac[0]=1; for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%P;\n  inv[0]=1; for (int i=1;i<=n/3;i++) (inv[i]=inv[i-1]*6)%=P;\n  for (int i=1;i<=n/3;i++) inv[i]=Pow(inv[i],P-2);\n}\n\ninline ll Calc(int a,int b,int c){\n  if (b>a) return 0;\n  return fac[a]*inv[(a-b)/3]%P;\n}\n\nint main(){\n  read(n); read(m); n*=3;\n  Pre(n);\n  tot=0;\n  for (int i=1;i<=n;i++) fat[i]=i,size[i]=1;\n  flag=0; cot[1]=n;\n  for (int i=1;i<=m;i++){\n    ++tot;\n    read(us[tot]),read(vs[tot]),read(ws[tot]);\n    if (ws[tot]==0)\n      Merge(us[tot],vs[tot]),tot--;      \n  }\n  if (flag){\n    printf(\"0\\n\");\n    return 0;\n  }\n  ll Ans=Calc(cot[1],cot[2],cot[3]);\n  int tmp=pnt;\n  for (int i=1;i<(1<<tot);i++){\n    flag=0; int c=0;\n    for (int j=1;j<=tot;j++)\n      if (i>>(j-1)&1)\n\tMerge(us[j],vs[j]),c++;   \n    if (!flag){\n      if (c&1)\n\t(Ans+=P-Calc(cot[1],cot[2],cot[3]))%=P;\n      else\n\t(Ans+=Calc(cot[1],cot[2],cot[3]))%=P;\n    }\n    Back(tmp);\n  }\n  printf(\"%lld\\n\",Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#define llint long long\n#define mod 1000000009\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint n, m;\nllint a[20], b[20], c[20];\nllint N, M, S;\nvector<llint> comp;\nvector<P> vec;\nUnionFind uf(40), tmp(40);\n\nllint fact[3000005], fact_inv[3000005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 3000005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 3000005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nvoid count(UnionFind &uf, int cnt[])\n{\n\tmap<llint, llint> mp;\n\tfor(int i = 1; i <= N; i++) mp[uf.root(i)]++;\n\tfor(int i = 1; i <= 4; i++) cnt[i] = 0;\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second > 4) it->second = 4;\n\t\tcnt[it->second]++;\n\t}\n\tcnt[1] += 3*n - N;\n}\n\nllint calc(int cnt[])\n{\n\tif(cnt[4] > 0) return 0;\n\tif(cnt[2] > cnt[1]) return 0;\n\t\n\tllint ret = 1;\n\tret *= fact[cnt[1]] * fact_inv[cnt[1]-cnt[2]] % mod, ret %= mod;\n\tcnt[1] -= cnt[2];\n\tret *= fact[cnt[1]], ret %= mod;\n\tret *= modpow(modpow(6, cnt[1]/3), mod-2), ret %= mod;\n\tret *= fact_inv[cnt[1]/3], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i++) cin >> a[i] >> b[i] >> c[i];\n\tfor(int i = 1; i <= m; i++){\n\t\tcomp.push_back(a[i]);\n\t\tcomp.push_back(b[i]);\n\t}\n\tsort(comp.begin(), comp.end());\n\tcomp.erase(unique(comp.begin(), comp.end()), comp.end());\n\tfor(int i = 1; i <= m; i++){\n\t\ta[i] = lower_bound(comp.begin(), comp.end(), a[i]) - comp.begin() + 1;\n\t\tb[i] = lower_bound(comp.begin(), comp.end(), b[i]) - comp.begin() + 1;\n\t}\n\tN = comp.size();\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tif(c[i] == 0) uf.unite(a[i], b[i]);\n\t\telse vec.push_back(make_pair(a[i], b[i]));\n\t}\n\t\n\tint cnt[5];\n\tcount(uf, cnt);\n\tllint ans = calc(cnt);\n\t\n\tM = vec.size(), S = 1<<M;\n\tfor(int i = 1; i < S; i++){\n\t\tfor(int j = 1; j <= N; j++) tmp.parent[j] = uf.parent[j];\n\t\tfor(int j = 0; j < M; j++){\n\t\t\tif(i & (1<<j)) tmp.unite(vec[j].first, vec[j].second);\n\t\t}\n\t\t\n\t\tcount(tmp, cnt);\n\t\tllint sum = calc(cnt);\n\t\t\n\t\tllint pop = 0;\n\t\tfor(int j = 0; j < M; j++) if(i & (1<<j)) pop++;\n\t\tif(pop%2) ans += mod - sum; else ans += sum;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\twhile(a < b) {\n\t\tcout << 1 << endl;\n\n\t}\n\twhile (b < 0 || a < 0) {\n\t\tcout << 1 << endl;\n\n\t}\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n == 2) {\n\t\tans *= rest;\n\t\t}\n\t\telse {\n\t\tans *= 1;\n\t\t}\n\t\t//if (rest < 3 - n) {\n\t\t//\t//cout << 1 << endl;\n\t\t//\treturn 0;\n\t\t//}\n\t\t\n\t\t//ans *= comb(rest, 3 - n);\n\t\t\n\t\trest -= (3-n);\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n >= 2) {\n\t\t\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}\n\t\t\t//if (rest < 3 - n) {\n\t\t\t//\t//cout << 1 << endl;\n\t\t\t//\treturn 0;\n\t\t\t//}\n\t\t\t//ans *= comb(rest, 3 - n);\n\t\t\trest -= (3-n);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\n\n#define MAX_N 1000001\n\ntypedef long long int64;\n\nconst int64 mod = 1e9 + 9;\n\ninline int64 extgcd(int64 a, int64 b, int64 &x, int64 &y) {\n  int64 d = a;\n  if(b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  else x = 1, y = 0;\n  return d;\n}\n\ninline int64 modPow(int64 x, int64 n) {\n  if(n == 0) return 1;\n  int64 ret = modPow(x, n/2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return ret;\n}\n\ninline int64 modInv(int64 a) {\n  return modPow(a, mod - 2);\n}\n\ninline int64 modFact(int n) {\n  int64 ret = 1;\n  while(n > 1) (ret *= n--) %= mod;\n  return ret;\n}\n\ninline int64 modComb(int64 n, int64 r) {\n  static int64 fact[MAX_N], invfact[MAX_N];\n  if(fact[0] == 0) {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < MAX_N; i++) {\n      fact[i] = fact[i-1] * i % mod;\n      invfact[i] = modInv(fact[i]);\n    }\n  }\n  if(r < 0 || n < r) return 0;\n  return fact[n] * invfact[r] % mod * invfact[n-r] % mod;\n}\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y]; data[y] = x;\n    return;\n  }\n};\n\nint calc(int& n, vector<Tapris>& vec) {\n  UnionFind uf(n);\n  set<int> st;\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 1) continue;\n    uf.unite(a, b);\n    st.insert(a);\n    st.insert(b);\n  }\n  int x = 0, y = 0;\n  for(int a : st) {\n    if(uf.find(a) == a) {\n      int sz = uf.size(a);\n      if(sz >= 4) return 0;\n      else if(sz == 2) ++y;\n    }\n  }\n  //cout<<n<<endl;\n  x = n - st.size();\n  //cout << x << \" \" << y << endl;\n  if(y > x) return 0;\n  int z = (x-y)/3;\n  //cout<<z<<endl;\n  //cout<<modFact(x)<<\" \"<<modPow(6, z)<<\" \"<<modInv(modPow(6, z))<<\" \"<<modFact(z)<<\" \"<<modInv(modFact(z))<<endl;\n  return modFact(x)*modInv(modPow(3*2*1, z))%mod*modInv(modFact(z))%mod;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  cin >> n >> m;\n  n *= 3;\n  vector<Tapris> vec;\n  vector<int> badidx;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c; --a, --b;\n    vec.emplace_back(a, b, c);\n    if(c == 1) badidx.push_back(i);\n  }\n  //cout<<calc(n, vec)<<endl;\n  int bad = badidx.size();\n  int ans = 0;\n  rep(bit, 1<<bad) {\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 0;\n    if(__builtin_popcount(bit)%2) ans = (ans-calc(n, vec)+mod) % mod;\n    else ans = (ans+calc(n, vec)) % mod;\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 1;\n  }\n  cout << ans%mod << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\t//cout << 2 << endl;\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n >= 2) {\n\t\t\tif (n == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}\n\t\t\t//ans *= comb(rest, 3 - m.second);\n\t\t\trest -= (3-n);\n\t\t\tif (rest < 0)return 0;\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 1000000009;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct rel {\n\tint a;\n\tint b;\n\tint love;\n};\nbool operator== (const rel&l, const rel&r) {\n\treturn l.a == r.a&&l.b == r.b&&l.love == r.love;\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<Mod>dp(1e6 + 1);\nMod getrest(const int rest) {\n\tif (rest < 0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tif (rest % 3) {\n\t\t\tassert(false);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn dp[rest/3];\n\t\t}\n\t}\n}\nint N, M;\nMod getans(const map<int,int>&mp) {\n\tvector<int>v;\n\n\tMod ans = 1;\n\tfor (auto m : mp) {\n\t\tif (m.second >= 4)return 0;\n\t\telse if(m.second==1){\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(m.second);\n\t\t}\n\t}\n\t int rest = 3 * N - accumulate(v.begin(), v.end(),0);\n\tif (N < v.size())return 0;\n\tfor (auto n : v) {\n\t\tif (n >= 2) {\n\t\t\t/*if (n == 2) {\n\t\t\tans *= rest;\n\t\t\t}\n\t\t\telse {\n\t\t\tans *= 1;\n\t\t\t}*/\n\t\t\tif (rest < 3 - n) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans *= comb(rest, 3 - n);\n\t\t\trest -= (3-n);\n\t\t}\n\t}\n\tans *= getrest(rest);\n\treturn ans;\n}\nint main() {\n\tdp[0] = 1;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tdp[i] = dp[i - 1] * Mod(3*i - 1)*Mod(3*i - 2) / Mod(2);\n\t}\n\tinit();cin >> N >> M;\n\tvector<rel>rels;\n\tvector<rel>hates;\n\tset<int>aset;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tc = !c;\n\t\ta--; b--;\n\t\taset.emplace(a);\n\t\taset.emplace(b);\n\t\trels.push_back(rel{ a,b,c });\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(rels.begin(), rels.end(), rel{ b,a,!c }) != rels.end()) {\n\t\t\t//cout << \"a\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmap<int, int>mp;\n\tint n = 0;\n\tfor (auto s : aset) {\n\t\tmp[s] = n;\n\t\tn++;\n\t}\n\tfor (auto&r : rels) {\n\t\tr.a = mp[r.a];\n\t\tr.b = mp[r.b];\n\t}\n\tUnionFind uf(aset.size());\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (rels[i].love) {\n\t\t\tuf.unionSet(rels[i].a, rels[i].b);\n\t\t}\n\t\telse {\n\t\t\thates.emplace_back(rels[i]);\n\t\t}\n\t}\n\tassert(hates.size() <= 18);\n\tMod ans = 0;\n\tfor (int i = 0; i < (1<<hates.size()); ++i) {\n\t\tUnionFind nowuf(uf);\n\t\tbitset<18>bs(i);\n\t\tfor (int j = 0; j < hates.size(); ++j) {\n\t\t\t\n\t\t\tif (bs[j]) {\n\t\t\t\tnowuf.unionSet(hates[j].a, hates[j].b);\n\t\t\t}\n\t\t}\n\t\tmap<int, int>lovemp;\n\t\tfor (int j = 0; j < aset.size(); ++j) {\n\t\t\tlovemp[nowuf.root(j)]++;\n\t\t}\n\t\tif (bs.count() % 2) {\n\t\t\tans -= getans(lovemp);\n\t\t}\n\t\telse {\n\t\t\tans += getans(lovemp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-xs.size();\n    int ret=fact[n]*inv[n-cnt]%mod;\n    return ret*table[n-cnt]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    for(int i=1;i<(1<<B.size());i++){\n        vpint AA=A;\n        rep(j,B.size())if(i>>j&1)AA.pb(B[j]);\n\n        if(__builtin_popcountll(i)%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\n\n#define MAX_N 3000001\n\ntypedef long long int64;\n\nconst int64 mod = 1e9 + 9;\n\ninline int64 extgcd(int64 a, int64 b, int64 &x, int64 &y) {\n  int64 d = a;\n  if(b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  else x = 1, y = 0;\n  return d;\n}\n\ninline int64 modPow(int64 x, int64 n) {\n  if(n == 0) return 1;\n  int64 ret = modPow(x, n/2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return ret;\n}\n\ninline int64 modInv(int64 a) {\n  return modPow(a, mod - 2);\n}\n\ninline int64 modFact(int n) {\n  int64 ret = 1;\n  while(n > 1) (ret *= n--) %= mod;\n  return ret;\n}\n\nint64 fact[MAX_N], invfact[MAX_N];\nvoid init() {\n  fact[0] = invfact[0] = 1;\n  for(int i = 1; i < MAX_N; i++) {\n    fact[i] = fact[i-1] * i % mod;\n    invfact[i] = modInv(fact[i]);\n  }\n}\n\ninline int64 modComb(int64 n, int64 r) {\n  if(r < 0 || n < r) return 0;\n  return fact[n] * invfact[r] % mod * invfact[n-r] % mod;\n}\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y]; data[y] = x;\n    return;\n  }\n};\n\nint pow6[MAX_N];\nint invpow6[MAX_N];\nint calc(int& n, vector<Tapris>& vec) {\n  //UnionFind uf(n);\n  //set<int> st;\n  vint press;\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 1) continue;\n    //uf.unite(a, b);\n    //st.insert(a);\n    //st.insert(b);\n    press.push_back(a);\n    press.push_back(b);\n  }\n  sort(all(press));\n  press.erase(unique(all(press)), press.end());\n  UnionFind uf(press.size());\n  rep(i, vec.size()) {\n    int a, b, c;\n    tie(a, b, c) = vec[i];\n    if(c == 1) continue;\n    a = lower_bound(all(press), a)-press.begin();\n    b = lower_bound(all(press), b)-press.begin();\n    uf.unite(a, b);\n  }\n  int x = 0, y = 0;\n  //for(int a : st) {\n  rep(i, press.size()) {\n    if(uf.find(i) == i) {\n      int sz = uf.size(i);\n      if(sz >= 4) return 0;\n      else if(sz == 2) ++y;\n    }\n  }\n  x = n - press.size();\n  if(y > x) return 0;\n  int z = (x-y)/3;\n  return fact[x]*invpow6[z]%mod*invfact[z]%mod;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  init();\n  pow6[0] = invpow6[0] = 1;\n  reps(i, 1, MAX_N) {\n    pow6[i] = pow6[i-1]*6 % mod;\n    invpow6[i] = modInv(pow6[i]);\n  }\n\n  int n, m;\n  cin >> n >> m;\n  n *= 3;\n  vector<Tapris> vec;\n  vector<int> badidx;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c; --a, --b;\n    vec.emplace_back(a, b, c);\n    if(c == 1) badidx.push_back(i);\n  }\n  //cout<<calc(n, vec)<<endl;\n  int bad = badidx.size();\n  int ans = 0;\n  rep(bit, 1<<bad) {\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 0;\n    if(__builtin_popcount(bit)%2) ans = (ans-calc(n, vec)+mod) % mod;\n    else ans = (ans+calc(n, vec)) % mod;\n    rep(i, bad) if((bit>>i)&1) get<2>(vec[badidx[i]]) = 1;\n  }\n  cout << ans%mod << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000009;\nint mpow(int n,int m){\n    n%=mod;\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,M;\nint fact[3333333];\nint inv[3333333];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint table[3333333];\n\nint calc(vpint A){\n    vint xs;\n    rep(i,A.size()){\n        xs.pb(A[i].fi);\n        xs.pb(A[i].se);\n    }\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    rep(i,A.size()){\n        A[i].fi=lower_bound(all(xs),A[i].fi)-xs.begin();\n        A[i].se=lower_bound(all(xs),A[i].se)-xs.begin();\n    }\n\n    UnionFindTree uf(xs.size());\n    rep(i,A.size())uf.unite(A[i].fi,A[i].se);\n\n    int cnt=0;\n    rep(i,xs.size()){\n        if(uf.find(i)!=i)continue;\n        if(uf.sz[i]>3)return 0;\n        if(uf.sz[i]==3)continue;\n        cnt++;\n    }\n\n    int n=3*N-(int)xs.size();\n    assert(0<=n&&n<=3*N);\n    assert(n-cnt>=0);\n    assert((n-cnt)%3==0);\n    int ret=fact[n]*inv[n-cnt]%mod;\n    ret=ret*table[n-cnt]%mod;\n  //  assert(0<=ret&&ret<mod);\n    return ret;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<3333333;i++)fact[i]=fact[i-1]*i%mod;\n    inv[3333333-1]=mpow(fact[3333333-1],mod-2);\n    for(int i=3333333-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    table[0]=1;\n    for(int i=3;i<3333333;i+=3){\n        table[i]=table[i-3]*C(i-1,2)%mod;\n    }\n\n\n    cin>>N>>M;\n\n    vpint A,B;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        if(c==0)A.pb({a,b});\n        else B.pb({a,b});\n    }\n\n    int ans=0;\n\n    int k=B.size();\n    for(int i=1;i<(1<<k);i++){\n        vpint AA=A;\n        rep(j,k)if(i>>j&1)AA.pb(B[j]);\n\n        int pc=0;\n        rep(j,k)if(i>>j&1)pc++;\n        if(pc%2==1)ans=(ans+calc(AA))%mod;\n        else ans=(ans-calc(AA)+mod)%mod;\n        \n      //  assert(0<=calc(AA)&&calc(AA)<mod);\n    }\n\n    cout<<(calc(A)-ans+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nfrom collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    MOD = 10**9 + 9\n    N, M = map(int, readline().split())\n\n    K = 3*N\n    fact = [1]*(K+1)\n    rfact = [1]*(K+1)\n    r = 1\n    for i in range(1, K+1):\n        fact[i] = r = r * i % MOD\n    rfact[K] = r = pow(fact[K], MOD-2, MOD)\n    for i in range(K, 0, -1):\n        rfact[i-1] = r = r * i % MOD\n\n    pr6 = [1]*(N+1)\n    base = pow(6, MOD-2, MOD)\n    r = 1\n    for i in range(N):\n        pr6[i+1] = r = base * r % MOD\n\n    mp = {}\n    G = [[] for i in range(M*2)]\n    cur = 0\n    m = 0\n    E = []\n    for i in range(M):\n        a, b, c = map(int, readline().split())\n        if a not in mp:\n            mp[a] = cur\n            cur += 1\n        ma = mp[a]\n        if b not in mp:\n            mp[b] = cur\n            cur += 1\n        mb = mp[b]\n        if c == 0:\n            G[ma].append(mb)\n            G[mb].append(ma)\n        else:\n            E.append((ma, mb))\n            m += 1\n    L = cur\n    cr = 0\n    lb = [-1]*L\n    sz = []\n    zz = []\n    cc = [0, 0, 0]\n    u = [0]*L\n    que = deque()\n    for i in range(L):\n        if u[i]:\n            continue\n        que.append(i)\n        vs = []\n        u[i] = 1\n        while que:\n            v = que.popleft()\n            vs.append(v)\n            for w in G[v]:\n                if u[w]:\n                    continue\n                u[w] = 1\n                que.append(w)\n        s = len(vs)\n        if s > 3:\n            write(\"0\\n\")\n            return\n        for v in vs:\n            lb[v] = cr\n        sz.append(s)\n        zz.append(vs)\n        cc[s-1] += 1\n        cr += 1\n    used = [0]*(1 << m)\n    ans = 0\n    def dfs(state, c, lb, cc):\n        nonlocal ans\n        if used[state]:\n            return\n        used[state] = 1\n        x = cc[0] + (K - L); y = cc[1]\n        if x >= y:\n            k = (x - y) // 3\n            if c & 1 == 0:\n                ans += fact[x] * pr6[k] * rfact[k] % MOD\n            else:\n                ans -= fact[x] * pr6[k] * rfact[k] % MOD\n        cc0 = [0]*3\n        for i in range(m):\n            if state & (1 << i):\n                continue\n            p, q = E[i]\n            pl = lb[p]; ql = lb[q]\n            if pl != ql:\n                s = sz[pl] + sz[ql]\n                if s > 3:\n                    continue\n                cc0[:] = cc\n                cc0[sz[pl]-1] -= 1\n                cc0[sz[ql]-1] -= 1\n                cc0[s-1] += 1\n\n                nl = len(sz)\n                vs = zz[pl] + zz[ql]\n                for v in vs:\n                    lb[v] = nl\n                sz.append(s)\n                zz.append(vs)\n\n                dfs(state | (1 << i), c+1, lb, cc0)\n\n                for v in zz[pl]:\n                    lb[v] = pl\n                for v in zz[ql]:\n                    lb[v] = ql\n            else:\n                dfs(state | (1 << i), c+1, lb, cc)\n    dfs(0, 0, lb, cc)\n    ans %= MOD\n    write(\"%d\\n\" % ans)\nsolve()\n"
  }
]