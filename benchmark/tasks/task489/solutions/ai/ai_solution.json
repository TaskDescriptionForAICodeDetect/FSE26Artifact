[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_STUDENTS 100\n\nint n;\nbool good_relations[MAX_STUDENTS][MAX_STUDENTS];\nbool bad_relations[MAX_STUDENTS][MAX_STUDENTS];\n\nbool is_valid_team(int team[], int team_size) {\n    for (int i = 0; i < team_size; i++) {\n        for (int j = i + 1; j < team_size; j++) {\n            if (bad_relations[team[i]][team[j]]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint count_team_assignments(int students[], int total_students, int current_team[], int team_count) {\n    if (total_students == 0) {\n        return team_count == n ? 1 : 0;\n    }\n\n    int total_assignments = 0;\n    int current_student = students[0];\n    int remaining_students[MAX_STUDENTS];\n    memcpy(remaining_students, students + 1, (total_students - 1) * sizeof(int));\n\n    // Try forming a new team\n    if (team_count < n) {\n        int new_team[3] = {current_student};\n        for (int i = 0; i < total_students - 1; i++) {\n            for (int j = i + 1; j < total_students; j++) {\n                new_team[1] = remaining_students[i];\n                new_team[2] = remaining_students[j];\n\n                if (is_valid_team(new_team, 3)) {\n                    bool used[MAX_STUDENTS] = {false};\n                    used[i] = true;\n                    used[j] = true;\n\n                    int next_remaining_students[MAX_STUDENTS];\n                    int next_remaining_count = 0;\n                    for (int k = 0; k < total_students - 1; k++) {\n                        if (!used[k]) {\n                            next_remaining_students[next_remaining_count++] = remaining_students[k];\n                        }\n                    }\n\n                    int temp_count = team_count + 1;\n                    total_assignments += count_team_assignments(next_remaining_students, next_remaining_count, current_team, temp_count);\n                }\n            }\n        }\n    }\n\n    // Try adding current student to an existing team\n    for (int i = 0; i < team_count; i++) {\n        if (current_team[i] == -1) continue;\n\n        int new_team[3];\n        int team_size = 0;\n        bool can_add = true;\n\n        // Check good relations within team\n        for (int j = 0; j < 3; j++) {\n            if (current_team[i + j] != -1) {\n                new_team[team_size++] = current_team[i + j];\n                for (int k = 0; k < team_size - 1; k++) {\n                    if (!good_relations[new_team[k]][current_student]) {\n                        can_add = false;\n                        break;\n                    }\n                }\n                if (!can_add) break;\n            }\n        }\n\n        if (can_add && team_size < 3) {\n            new_team[team_size++] = current_student;\n            if (is_valid_team(new_team, team_size)) {\n                int new_current_team[MAX_STUDENTS];\n                memcpy(new_current_team, current_team, MAX_STUDENTS * sizeof(int));\n                new_current_team[i + team_size - 1] = current_student;\n\n                total_assignments += count_team_assignments(remaining_students, total_students - 1, new_current_team, team_count);\n            }\n        }\n    }\n\n    return total_assignments;\n}\n\nint main() {\n    int m;\n    scanf(\"%d %d\", &n, &m);\n\n    memset(good_relations, 0, sizeof(good_relations));\n    memset(bad_relations, 0, sizeof(bad_relations));\n\n    for (int i = 0; i < m; i++) {\n        int type, u, v;\n        scanf(\"%d %d %d\", &type, &u, &v);\n        u--; v--;\n\n        if (type == 1) {\n            good_relations[u][v] = good_relations[v][u] = true;\n        } else {\n            bad_relations[u][v] = bad_relations[v][u] = true;\n        }\n    }\n\n    int students[MAX_STUDENTS];\n    for (int i = 0; i < 3 * n; i++) {\n        students[i] = i;\n    }\n\n    int current_team[MAX_STUDENTS];\n    memset(current_team, -1, sizeof(current_team));\n\n    int result = count_team_assignments(students, 3 * n, current_team, 0);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 300\n\nint parent[MAX];\nint rank[MAX];\nint size[MAX];\nint must_separate[MAX][MAX];\nint N, M1, M2;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n        size[v] += size[u];\n    } else {\n        parent[v] = u;\n        size[u] += size[v];\n        if (rank[u] == rank[v]) {\n            rank[u]++;\n        }\n    }\n}\n\nint solve() {\n    for (int i = 0; i < 3*N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n        size[i] = 1;\n    }\n\n    for (int i = 0; i < M1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        union_sets(u, v);\n    }\n\n    memset(must_separate, 0, sizeof(must_separate));\n    for (int i = 0; i < M2; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u = find(u);\n        v = find(v);\n        must_separate[u][v] = 1;\n        must_separate[v][u] = 1;\n    }\n\n    for (int i = 0; i < 3*N; i++) {\n        if (find(i) != i) continue;\n        for (int j = 0; j < 3*N; j++) {\n            if (find(j) != j) continue;\n            if (must_separate[i][j]) {\n                for (int k = 0; k < 3*N; k++) {\n                    if (find(k) != k) continue;\n                    if (must_separate[i][k] && find(j) != find(k)) {\n                        union_sets(j, k);\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < 3*N; i++) {\n        if (find(i) != i) continue;\n        for (int j = 0; j < 3*N; j++) {\n            if (find(j) != j) continue;\n            if (must_separate[i][j] && find(i) == find(j)) {\n                return 0;\n            }\n        }\n    }\n\n    int component_count = 0;\n    int component_size[MAX];\n    for (int i = 0; i < 3*N; i++) {\n        if (find(i) == i) {\n            component_size[component_count++] = size[i];\n        }\n    }\n\n    int dp[MAX][MAX] = {0};\n    dp[0][0] = 1;\n    for (int i = 0; i < component_count; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (dp[i][j] == 0) continue;\n            if (j + 1 <= N) {\n                dp[i+1][j+1] += dp[i][j] * component_size[i];\n            }\n        }\n    }\n\n    int result = dp[component_count][N];\n    for (int i = 1; i <= N; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M1, &M2);\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 18;\nint N;\nvector<int> same[MAXN], diff[MAXN];\nint team[MAXN];\nlong long dp[1 << MAXN];\n\nbool check(int mask) {\n    for (int i = 0; i < 3 * N; ++i) {\n        if (!(mask & (1 << i))) continue;\n        for (int j : same[i]) {\n            if (!(mask & (1 << j))) return false;\n        }\n        for (int j : diff[i]) {\n            if (mask & (1 << j)) return false;\n        }\n    }\n    return true;\n}\n\nlong long solve(int mask) {\n    if (mask == (1 << (3 * N)) - 1) return 1;\n    if (dp[mask] != -1) return dp[mask];\n\n    long long res = 0;\n    int first = -1;\n    for (int i = 0; i < 3 * N; ++i) {\n        if (!(mask & (1 << i))) {\n            first = i;\n            break;\n        }\n    }\n    if (first == -1) return 0;\n\n    for (int i = first + 1; i < 3 * N; ++i) {\n        if (mask & (1 << i)) continue;\n        for (int j = i + 1; j < 3 * N; ++j) {\n            if (mask & (1 << j)) continue;\n            int new_mask = mask | (1 << first) | (1 << i) | (1 << j);\n            if (check(new_mask)) {\n                res += solve(new_mask);\n            }\n        }\n    }\n\n    return dp[mask] = res;\n}\n\nint main() {\n    int M1, M2;\n    cin >> N >> M1 >> M2;\n\n    for (int i = 0; i < M1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        same[a].push_back(b);\n        same[b].push_back(a);\n    }\n\n    for (int i = 0; i < M2; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        diff[a].push_back(b);\n        diff[b].push_back(a);\n    }\n\n    memset(dp, -1, sizeof(dp));\n    cout << solve(0) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TeamAssignments {\n    static int[] parent;\n    static int[] size;\n    static Map<Integer, List<Integer>> adj;\n\n    static int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    static void union(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU != rootV) {\n            if (size[rootU] > size[rootV]) {\n                parent[rootV] = rootU;\n                size[rootU] += size[rootV];\n            } else {\n                parent[rootU] = rootV;\n                size[rootV] += size[rootU];\n            }\n        }\n    }\n\n    static boolean isBipartite(int start, int[] color) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        color[start] = 1;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : adj.getOrDefault(u, new ArrayList<>())) {\n                if (color[v] == 0) {\n                    color[v] = -color[u];\n                    queue.add(v);\n                } else if (color[v] == color[u]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M1 = scanner.nextInt();\n        int M2 = scanner.nextInt();\n\n        parent = new int[3 * N + 1];\n        size = new int[3 * N + 1];\n        for (int i = 1; i <= 3 * N; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n\n        // Process good relationships (must be in same team)\n        for (int i = 0; i < M1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            union(u, v);\n        }\n\n        adj = new HashMap<>();\n        // Process bad relationships (must be in different teams)\n        for (int i = 0; i < M2; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int rootU = find(u);\n            int rootV = find(v);\n            adj.computeIfAbsent(rootU, k -> new ArrayList<>()).add(rootV);\n            adj.computeIfAbsent(rootV, k -> new ArrayList<>()).add(rootU);\n        }\n\n        // Check bipartition (2-coloring) of the graph formed by bad relationships\n        int[] color = new int[3 * N + 1];\n        boolean possible = true;\n        for (int i = 1; i <= 3 * N; i++) {\n            int root = find(i);\n            if (color[root] == 0 && adj.containsKey(root)) {\n                if (!isBipartite(root, color)) {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n\n        if (!possible) {\n            System.out.println(0);\n            return;\n        }\n\n        // Count the number of root nodes and their sizes\n        Map<Integer, Integer> rootSizes = new HashMap<>();\n        for (int i = 1; i <= 3 * N; i++) {\n            int root = find(i);\n            rootSizes.put(root, rootSizes.getOrDefault(root, 0) + 1);\n        }\n\n        // Check if all components are of size divisible by 3\n        for (int s : rootSizes.values()) {\n            if (s % 3 != 0) {\n                System.out.println(0);\n                return;\n            }\n        }\n\n        // Calculate the number of ways to partition into teams of 3\n        // For each component, the number of ways is (3k)! / (3!^k * k!)\n        // Multiply all components and consider the bipartition constraints\n        long[] fact = new long[3 * N + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= 3 * N; i++) {\n            fact[i] = fact[i - 1] * i;\n        }\n\n        long result = 1;\n        Set<Integer> processed = new HashSet<>();\n        for (int i = 1; i <= 3 * N; i++) {\n            int root = find(i);\n            if (!processed.contains(root)) {\n                processed.add(root);\n                int k = rootSizes.get(root) / 3;\n                long ways = fact[3 * k] / (long) Math.pow(6, k) / fact[k];\n                result *= ways;\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:56:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ICPCTeamAssignment {\n    private static final int MOD = 1_000_000_007;\n    private static int n;\n    private static boolean[][] goodRelations;\n    private static boolean[][] badRelations;\n    private static int[] teamAssignment;\n\n    public static int countTeamAssignments() {\n        goodRelations = new boolean[3 * n][3 * n];\n        badRelations = new boolean[3 * n][3 * n];\n        teamAssignment = new int[3 * n];\n        \n        return backtrack(0);\n    }\n\n    private static int backtrack(int student) {\n        if (student == 3 * n) {\n            return isValidAssignment() ? 1 : 0;\n        }\n\n        int totalAssignments = 0;\n        for (int team = 0; team < n; team++) {\n            if (teamSize(team) < 3) {\n                teamAssignment[student] = team;\n                totalAssignments = (totalAssignments + backtrack(student + 1)) % MOD;\n            }\n        }\n\n        return totalAssignments;\n    }\n\n    private static boolean isValidAssignment() {\n        for (int i = 0; i < 3 * n; i++) {\n            for (int j = i + 1; j < 3 * n; j++) {\n                if (goodRelations[i][j] && teamAssignment[i] != teamAssignment[j]) {\n                    return false;\n                }\n                if (badRelations[i][j] && teamAssignment[i] == teamAssignment[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static int teamSize(int team) {\n        int size = 0;\n        for (int i = 0; i < 3 * n; i++) {\n            if (teamAssignment[i] == team) {\n                size++;\n            }\n        }\n        return size;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        int goodRelationCount = scanner.nextInt();\n        int badRelationCount = scanner.nextInt();\n\n        for (int i = 0; i < goodRelationCount; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            goodRelations[u][v] = goodRelations[v][u] = true;\n        }\n\n        for (int i = 0; i < badRelationCount; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            badRelations[u][v] = badRelations[v][u] = true;\n        }\n\n        System.out.println(countTeamAssignments());\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:56:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int teamFormation(int n, vector<pair<int, int>>& goodRelations, vector<pair<int, int>>& badRelations) {\n        int totalStudents = 3 * n;\n        vector<int> parent(totalStudents);\n        vector<int> rank(totalStudents, 0);\n        \n        // Initialize disjoint set\n        for (int i = 0; i < totalStudents; i++) {\n            parent[i] = i;\n        }\n        \n        // Process good relations\n        for (auto& relation : goodRelations) {\n            unionSet(relation.first, relation.second, parent, rank);\n        }\n        \n        // Process bad relations\n        vector<vector<bool>> conflict(totalStudents, vector<bool>(totalStudents, false));\n        for (auto& relation : badRelations) {\n            conflict[relation.first][relation.second] = true;\n            conflict[relation.second][relation.first] = true;\n        }\n        \n        // Count possible team assignments\n        return countTeamAssignments(n, parent, conflict);\n    }\n    \nprivate:\n    int findSet(int x, vector<int>& parent) {\n        if (parent[x] != x) {\n            parent[x] = findSet(parent[x], parent);\n        }\n        return parent[x];\n    }\n    \n    void unionSet(int x, int y, vector<int>& parent, vector<int>& rank) {\n        int rootX = findSet(x, parent);\n        int rootY = findSet(y, parent);\n        \n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                swap(rootX, rootY);\n            }\n            parent[rootY] = rootX;\n            if (rank[rootX] == rank[rootY]) {\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    int countTeamAssignments(int n, vector<int>& parent, vector<vector<bool>>& conflict) {\n        int totalStudents = 3 * n;\n        int assignments = 0;\n        \n        // Try all possible team assignments\n        for (int mask = 0; mask < (1 << totalStudents); mask++) {\n            if (__builtin_popcount(mask) != 3 * n) continue;\n            \n            bool validAssignment = true;\n            \n            // Check team formation constraints\n            for (int i = 0; i < totalStudents; i++) {\n                for (int j = i + 1; j < totalStudents; j++) {\n                    bool inSameTeam = ((mask & (1 << i)) > 0) == ((mask & (1 << j)) > 0);\n                    \n                    // Check good relations\n                    if (findSet(i, parent) == findSet(j, parent) && !inSameTeam) {\n                        validAssignment = false;\n                        break;\n                    }\n                    \n                    // Check bad relations\n                    if (conflict[i][j] && inSameTeam) {\n                        validAssignment = false;\n                        break;\n                    }\n                }\n                if (!validAssignment) break;\n            }\n            \n            if (validAssignment) {\n                assignments++;\n            }\n        }\n        \n        return assignments;\n    }\n};\n\nint main() {\n    int n, g, b;\n    cin >> n >> g >> b;\n    \n    vector<pair<int, int>> goodRelations(g);\n    vector<pair<int, int>> badRelations(b);\n    \n    for (int i = 0; i < g; i++) {\n        cin >> goodRelations[i].first >> goodRelations[i].second;\n    }\n    \n    for (int i = 0; i < b; i++) {\n        cin >> badRelations[i].first >> badRelations[i].second;\n    }\n    \n    Solution solution;\n    cout << solution.teamFormation(n, goodRelations, badRelations) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef count_possible_teams(N, good_relationships, bad_relationships):\n    students = list(range(3 * N))\n    valid_assignments = 0\n\n    for perm in permutations(students, 3 * N):\n        teams = [perm[i:i+3] for i in range(0, 3 * N, 3)]\n        \n        valid = True\n        for a, b in good_relationships:\n            if not any(a in team and b in team for team in teams):\n                valid = False\n                break\n        \n        for a, b in bad_relationships:\n            if any(a in team and b in team for team in teams):\n                valid = False\n                break\n        \n        if valid:\n            valid_assignments += 1\n    \n    return valid_assignments\n\n# Example Usage:\nN = 2\ngood_relationships = [(0, 1), (3, 4)]\nbad_relationships = [(1, 2), (4, 5)]\nprint(count_possible_teams(N, good_relationships, bad_relationships))",
    "timestamp": "2025-08-13 07:57:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ICPC_Teams {\n    public static final int MOD = 1000000007;\n\n    public static int countAssignments(int N, List<int[]> goodPairs, List<int[]> badPairs) {\n        boolean[][] goodGraph = new boolean[3 * N][3 * N];\n        boolean[][] badGraph = new boolean[3 * N][3 * N];\n        int[] team = new int[3 * N];\n        Arrays.fill(team, -1);\n\n        for (int[] pair : goodPairs) {\n            goodGraph[pair[0]][pair[1]] = true;\n            goodGraph[pair[1]][pair[0]] = true;\n        }\n        \n        for (int[] pair : badPairs) {\n            badGraph[pair[0]][pair[1]] = true;\n            badGraph[pair[1]][pair[0]] = true;\n        }\n\n        int totalWays = 1;\n        for (int i = 0; i < 3 * N; i++) {\n            if (team[i] == -1) {\n                List<Integer> group = new ArrayList<>();\n                if (!dfs(i, team, 0, goodGraph, badGraph, group)) {\n                    return 0;\n                }\n                totalWays = (totalWays * countGroupWays(group, goodGraph, badGraph)) % MOD;\n            }\n        }\n        return totalWays;\n    }\n\n    private static boolean dfs(int node, int[] team, int currentTeam, boolean[][] goodGraph, boolean[][] badGraph, List<Integer> group) {\n        if (team[node] != -1) {\n            return team[node] == currentTeam;\n        }\n        team[node] = currentTeam;\n        group.add(node);\n\n        for (int i = 0; i < team.length; i++) {\n            if (goodGraph[node][i] && !dfs(i, team, currentTeam, goodGraph, badGraph, group)) {\n                return false;\n            }\n            if (badGraph[node][i] && !dfs(i, team, 1 - currentTeam, goodGraph, badGraph, group)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int countGroupWays(List<Integer> group, boolean[][] goodGraph, boolean[][] badGraph) {\n        int size = group.size();\n        if (size % 3 != 0) return 0;\n        \n        int ways = 1;\n        for (int i = 0; i < size; i++) {\n            for (int j = i + 1; j < size; j++) {\n                if (badGraph[group.get(i)][group.get(j)]) {\n                    return 0;\n                }\n            }\n        }\n\n        for (int tuple = 1; tuple <= size / 3; tuple++) {\n            ways = (ways * (tuple)) % MOD;\n        }\n        \n        return ways;\n    }\n\n    public static void main(String[] args) {\n        int N = 2;\n        List<int[]> goodPairs = Arrays.asList(new int[]{0, 1}, new int[]{3, 4});\n        List<int[]> badPairs = Arrays.asList(new int[]{0, 3});\n\n        int result = countAssignments(N, goodPairs, badPairs);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 07:58:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STUDENTS 30\n#define MAX_TEAMS 10\n\ntypedef struct {\n    int good[MAX_STUDENTS][MAX_STUDENTS];\n    int bad[MAX_STUDENTS][MAX_STUDENTS];\n} Relationship;\n\nint team_count = 0;\nint students_in_team[MAX_TEAMS][3];\nint assigned[MAX_STUDENTS];\n\nvoid form_teams(int student, int n, Relationship *relation) {\n    if (student == 3 * n) {\n        team_count++;\n        return;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (students_in_team[i][0] < 3) {\n            int add = 1;\n            for (int j = 0; j < students_in_team[i][0]; ++j) {\n                int teammate = students_in_team[i][j];\n                if (relation->good[student][teammate] || relation->bad[student][teammate]) {\n                    add = 0;\n                    break;\n                }\n            }\n            if (add) {\n                students_in_team[i][students_in_team[i][0]++] = student;\n                assigned[student] = 1;\n                form_teams(student + 1, n, relation);\n                students_in_team[i][--students_in_team[i][0]] = 0;\n                assigned[student] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    Relationship relation;\n    memset(&relation, 0, sizeof(Relationship));\n\n    // Input section where n is the number of teams, and you can fill \n    // the `relation.good` and `relation.bad` matrices.\n    \n    team_count = 0;\n    memset(assigned, 0, sizeof(assigned));\n    for (int i = 0; i < MAX_TEAMS; ++i) {\n        memset(students_in_team[i], 0, sizeof(students_in_team[i]));\n    }\n\n    form_teams(0, n, &relation);\n\n    printf(\"%d\\n\", team_count);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:58:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\n\ndef solve_team_assignments(N: int, good_relations: List[Tuple[int, int]], bad_relations: List[Tuple[int, int]]) -> int:\n    def can_form_team(team: List[int]) -> bool:\n        # Check good relations within the team\n        for a, b in good_relations:\n            if a in team and b not in team:\n                return False\n            if b in team and a not in team:\n                return False\n        \n        # Check bad relations within the team\n        for a, b in bad_relations:\n            if a in team and b in team:\n                return False\n        \n        return True\n\n    def backtrack(students: List[int], teams: List[List[int]], current_team: List[int]) -> int:\n        # All students assigned to teams\n        if not students:\n            return 1\n        \n        # Current team is full, move to next team\n        if len(current_team) == 3:\n            return backtrack(students, teams + [current_team], [])\n        \n        # All teams are formed\n        if len(teams) + (1 if current_team else 0) == N:\n            return 0\n        \n        total_ways = 0\n        for i in range(len(students)):\n            # Try adding current student to the team\n            new_team = current_team + [students[i]]\n            \n            # Check if team is valid\n            if can_form_team(new_team):\n                new_students = students[:i] + students[i+1:]\n                total_ways += backtrack(new_students, teams, new_team)\n        \n        return total_ways\n\n    # Total number of students\n    total_students = 3 * N\n    students = list(range(total_students))\n    return backtrack(students, [], [])\n\n# Example usage\n# N = 2\n# good_relations = [(0, 1), (2, 3)]\n# bad_relations = [(0, 2), (1, 3)]\n# print(solve_team_assignments(N, good_relations, bad_relations))",
    "timestamp": "2025-08-13 07:58:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    N = int(sys.stdin.readline())\n    M1 = int(sys.stdin.readline())\n    good = defaultdict(list)\n    for _ in range(M1):\n        a, b = map(int, sys.stdin.readline().split())\n        good[a].append(b)\n        good[b].append(a)\n    \n    M2 = int(sys.stdin.readline())\n    bad = defaultdict(list)\n    for _ in range(M2):\n        a, b = map(int, sys.stdin.readline().split())\n        bad[a].append(b)\n        bad[b].append(a)\n    \n    visited = [False] * (3*N + 1)\n    res = 1\n    \n    for i in range(1, 3*N + 1):\n        if not visited[i]:\n            # BFS to find the connected component in 'good' graph\n            queue = [i]\n            visited[i] = True\n            component = [i]\n            while queue:\n                u = queue.pop(0)\n                for v in good[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append(v)\n                        component.append(v)\n            \n            # Check if any pair in the component has a bad relationship\n            valid = True\n            for u in component:\n                for v in bad[u]:\n                    if v in component:\n                        valid = False\n                        break\n                if not valid:\n                    break\n            \n            if not valid:\n                print(0)\n                return\n            \n            m = len(component)\n            if m % 3 != 0:\n                print(0)\n                return\n            \n            k = m // 3\n            # The number of ways to split into teams is (3k)! / ( (3!)^k * k! )\n            # Compute numerator: (3k)!\n            numerator = 1\n            for x in range(1, m + 1):\n                numerator = (numerator * x) % MOD\n            \n            # Compute denominator: (3!)^k * k! mod MOD\n            denom_pow = 1\n            fact_k = 1\n            for x in range(1, k + 1):\n                fact_k = (fact_k * x) % MOD\n            pow_6 = pow(6, k, MOD)\n            denominator = (fact_k * pow_6) % MOD\n            \n            # Compute inverse of denominator\n            inv_denominator = pow(denominator, MOD - 2, MOD)\n            \n            # Multiply to result\n            ways = (numerator * inv_denominator) % MOD\n            res = (res * ways) % MOD\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 07:58:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int N, R, B;\n    cin >> N >> R >> B;\n\n    vector<vector<int>> goodPairs(R, vector<int>(2));\n    vector<vector<int>> badPairs(B, vector<int>(2));\n\n    for (int i = 0; i < R; i++) {\n        cin >> goodPairs[i][0] >> goodPairs[i][1];\n        goodPairs[i][0]--;\n        goodPairs[i][1]--;\n    }\n\n    for (int i = 0; i < B; i++) {\n        cin >> badPairs[i][0] >> badPairs[i][1];\n        badPairs[i][0]--;\n        badPairs[i][1]--;\n    }\n\n    vector<long long> dp(1 << (3 * N), 0);\n    dp[0] = 1;\n\n    for (int mask = 0; mask < (1 << (3 * N)); mask++) {\n        int count = __builtin_popcount(mask);\n        if (count % 3 != 0) continue;\n\n        unordered_map<int, int> teamCount;\n        vector<int> team(3 * N, -1);\n        int teamIndex = 0;\n\n        for (int i = 0; i < 3 * N; i++) {\n            if ((mask & (1 << i)) && team[i] == -1) {\n                for (int j = i; j < 3 * N; j++) {\n                    if ((mask & (1 << j))) {\n                        team[j] = teamIndex;\n                    }\n                }\n                teamIndex++;\n            }\n        }\n\n        teamCount.reserve(3 * N);\n        for (int t : team) {\n            if (t != -1) {\n                teamCount[t]++;\n            }\n        }\n\n        bool valid = true;\n        for (const auto& p : goodPairs) {\n            if (team[p[0]] != team[p[1]]) {\n                valid = false;\n                break;\n            }\n        }\n\n        for (const auto& p : badPairs) {\n            if (team[p[0]] == team[p[1]]) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) continue;\n\n        int nextMask = mask;\n        for (int i = 0; i < 3 * N; i++) {\n            if (!(nextMask & (1 << i))) {\n                nextMask |= 1 << i;\n                dp[nextMask] = (dp[nextMask] + dp[mask]) % MOD;\n                nextMask &= ~(1 << i);\n            }\n        }\n    }\n\n    cout << dp[(1 << (3 * N)) - 1] << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:42:17"
  }
]