[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_HOUSES 100\n#define INF INT_MAX\n\ntypedef struct {\n    int house;\n    int deadline;\n} Request;\n\nint graph[MAX_HOUSES][MAX_HOUSES];\nint dist[MAX_HOUSES][MAX_HOUSES];\nRequest requests[MAX_HOUSES];\nint used[MAX_HOUSES];\nint n, m, r;\n\nvoid floydWarshall() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = graph[i][j];\n        }\n    }\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint compareRequests(const void *a, const void *b) {\n    Request *reqA = (Request *)a;\n    Request *reqB = (Request *)b;\n    return reqA->deadline - reqB->deadline;\n}\n\nint canAssign(int santa, int req, int time) {\n    int lastHouse = (santa == -1) ? 0 : requests[santa].house;\n    int travelTime = dist[lastHouse][requests[req].house];\n    return (time + travelTime <= requests[req].deadline);\n}\n\nint main() {\n    while (scanf(\"%d %d %d\", &n, &m, &r) == 3) {\n        if (n == 0 && m == 0 && r == 0) break;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                graph[i][j] = (i == j) ? 0 : INF;\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            if (graph[u][v] > w) {\n                graph[u][v] = w;\n                graph[v][u] = w;\n            }\n        }\n\n        floydWarshall();\n\n        for (int i = 0; i < r; i++) {\n            scanf(\"%d %d\", &requests[i].house, &requests[i].deadline);\n        }\n\n        qsort(requests, r, sizeof(Request), compareRequests);\n\n        int santas = 0;\n        for (int i = 0; i < r; i++) {\n            used[i] = 0;\n        }\n\n        for (int i = 0; i < r; i++) {\n            if (used[i]) continue;\n            santas++;\n            int lastReq = i;\n            int time = dist[0][requests[i].house];\n            used[i] = 1;\n\n            for (int j = i + 1; j < r; j++) {\n                if (!used[j] && canAssign(lastReq, j, time)) {\n                    time += dist[requests[lastReq].house][requests[j].house];\n                    lastReq = j;\n                    used[j] = 1;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", santas);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n};\n\nstruct Request {\n    int from, to, time;\n    Request(int f, int t, int tm) : from(f), to(t), time(tm) {}\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nvector<int> dijkstra(const Graph &graph, int start) {\n    int n = graph.size();\n    vector<int> dist(n, INT_MAX);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (current_dist > dist[u]) continue;\n\n        for (const Edge &e : graph[u]) {\n            int v = e.to;\n            int new_dist = current_dist + e.cost;\n            if (new_dist < dist[v]) {\n                dist[v] = new_dist;\n                pq.push({new_dist, v});\n            }\n        }\n    }\n    return dist;\n}\n\nbool can_fulfill(const vector<Request> &requests, const vector<vector<int>> &dist, int santa_count) {\n    vector<int> santa_times(santa_count, 0);\n    vector<pair<int, int>> deadlines;\n\n    for (const Request &req : requests) {\n        int travel_time = dist[req.from][req.to];\n        if (travel_time == INT_MAX) return false;\n        deadlines.emplace_back(req.time - travel_time, travel_time);\n    }\n\n    sort(deadlines.begin(), deadlines.end());\n\n    for (const auto &dl : deadlines) {\n        int deadline = dl.first;\n        int travel_time = dl.second;\n        bool assigned = false;\n        for (int i = 0; i < santa_count; ++i) {\n            if (santa_times[i] <= deadline) {\n                santa_times[i] = deadline + travel_time;\n                assigned = true;\n                break;\n            }\n        }\n        if (!assigned) return false;\n    }\n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M, R;\n    while (cin >> N >> M >> R) {\n        if (N == 0 && M == 0 && R == 0) break;\n\n        Graph graph(N);\n        for (int i = 0; i < M; ++i) {\n            int x, y, d;\n            cin >> x >> y >> d;\n            graph[x].emplace_back(y, d);\n            graph[y].emplace_back(x, d);\n        }\n\n        vector<Request> requests;\n        for (int i = 0; i < R; ++i) {\n            int s, t, tm;\n            cin >> s >> t >> tm;\n            requests.emplace_back(s, t, tm);\n        }\n\n        vector<vector<int>> dist(N);\n        for (int i = 0; i < N; ++i) {\n            dist[i] = dijkstra(graph, i);\n        }\n\n        int left = 1, right = R, answer = R;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (can_fulfill(requests, dist, mid)) {\n                answer = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        cout << answer << '\\n';\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SantaDelivery {\n    static class Edge {\n        int to, weight;\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    static class Request {\n        int from, to, time;\n        Request(int from, int to, int time) {\n            this.from = from;\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            int Q = scanner.nextInt();\n            if (N == 0 && M == 0 && Q == 0) break;\n\n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < M; i++) {\n                int u = scanner.nextInt();\n                int v = scanner.nextInt();\n                int w = scanner.nextInt();\n                graph.get(u).add(new Edge(v, w));\n                graph.get(v).add(new Edge(u, w));\n            }\n\n            Request[] requests = new Request[Q];\n            for (int i = 0; i < Q; i++) {\n                int from = scanner.nextInt();\n                int to = scanner.nextInt();\n                int time = scanner.nextInt();\n                requests[i] = new Request(from, to, time);\n            }\n\n            int[][] dist = new int[N][N];\n            for (int i = 0; i < N; i++) {\n                Arrays.fill(dist[i], Integer.MAX_VALUE);\n                dist[i][i] = 0;\n                PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));\n                pq.add(new Edge(i, 0));\n                while (!pq.isEmpty()) {\n                    Edge current = pq.poll();\n                    if (current.weight > dist[i][current.to]) continue;\n                    for (Edge edge : graph.get(current.to)) {\n                        int newDist = current.weight + edge.weight;\n                        if (newDist < dist[i][edge.to]) {\n                            dist[i][edge.to] = newDist;\n                            pq.add(new Edge(edge.to, newDist));\n                        }\n                    }\n                }\n            }\n\n            Arrays.sort(requests, Comparator.comparingInt(r -> r.time));\n\n            int santas = 0;\n            int[] santaFreeTime = new int[Q];\n            for (Request req : requests) {\n                boolean assigned = false;\n                for (int i = 0; i < santas; i++) {\n                    if (santaFreeTime[i] + dist[req.from][req.to] <= req.time) {\n                        santaFreeTime[i] = req.time;\n                        assigned = true;\n                        break;\n                    }\n                }\n                if (!assigned) {\n                    santaFreeTime[santas] = req.time;\n                    santas++;\n                }\n            }\n            System.out.println(santas);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:20:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ChristmasPresentDelivery {\n    static class Edge {\n        int to, time;\n        Edge(int to, int time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    static class Request {\n        int house, deadline;\n        Request(int house, int deadline) {\n            this.house = house;\n            this.deadline = deadline;\n        }\n    }\n\n    public static int minimumSantas(int houses, List<Edge>[] graph, List<Request> requests) {\n        int[] earliestDelivery = new int[houses + 1];\n        Arrays.fill(earliestDelivery, Integer.MAX_VALUE);\n\n        // Dijkstra's algorithm to find earliest delivery times\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        for (Request req : requests) {\n            pq.offer(new int[]{req.house, 0});\n            earliestDelivery[req.house] = 0;\n        }\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int node = current[0], time = current[1];\n\n            for (Edge edge : graph[node]) {\n                int newTime = time + edge.time;\n                if (newTime < earliestDelivery[edge.to]) {\n                    earliestDelivery[edge.to] = newTime;\n                    pq.offer(new int[]{edge.to, newTime});\n                }\n            }\n        }\n\n        // Check if all requests can be met\n        for (Request req : requests) {\n            if (earliestDelivery[req.house] > req.deadline) {\n                return -1;  // Impossible to deliver\n            }\n        }\n\n        // Count minimum Santas needed\n        Set<Integer> santaLocations = new HashSet<>();\n        for (Request req : requests) {\n            santaLocations.add(req.house);\n        }\n\n        return santaLocations.size();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int houses = scanner.nextInt();\n            int roads = scanner.nextInt();\n            int requests = scanner.nextInt();\n\n            List<Edge>[] graph = new ArrayList[houses + 1];\n            for (int i = 1; i <= houses; i++) {\n                graph[i] = new ArrayList<>();\n            }\n\n            for (int i = 0; i < roads; i++) {\n                int from = scanner.nextInt();\n                int to = scanner.nextInt();\n                int time = scanner.nextInt();\n                graph[from].add(new Edge(to, time));\n                graph[to].add(new Edge(from, time));\n            }\n\n            List<Request> deliveryRequests = new ArrayList<>();\n            for (int i = 0; i < requests; i++) {\n                int house = scanner.nextInt();\n                int deadline = scanner.nextInt();\n                deliveryRequests.add(new Request(house, deadline));\n            }\n\n            int result = minimumSantas(houses, graph, deliveryRequests);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:20:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_HOUSES 500\n#define MAX_ROADS 5000\n\ntypedef struct {\n    int start, end, time;\n} Request;\n\ntypedef struct {\n    int u, v, weight;\n} Road;\n\nint parent[MAX_HOUSES];\nint rank[MAX_HOUSES];\nRoad roads[MAX_ROADS];\nRequest requests[MAX_ROADS];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    \n    if (rootX == rootY) return;\n    \n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint compareRoads(const void* a, const void* b) {\n    Road* roadA = (Road*)a;\n    Road* roadB = (Road*)b;\n    return roadA->weight - roadB->weight;\n}\n\nint compareRequests(const void* a, const void* b) {\n    Request* reqA = (Request*)a;\n    Request* reqB = (Request*)b;\n    return reqA->time - reqB->time;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        int N, M, K;\n        scanf(\"%d %d %d\", &N, &M, &K);\n        \n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            scanf(\"%d %d %d\", &roads[i].u, &roads[i].v, &roads[i].weight);\n        }\n        \n        for (int i = 0; i < K; i++) {\n            scanf(\"%d %d %d\", &requests[i].start, &requests[i].end, &requests[i].time);\n        }\n        \n        qsort(roads, M, sizeof(Road), compareRoads);\n        qsort(requests, K, sizeof(Request), compareRequests);\n        \n        int santas = 0;\n        for (int i = 0; i < K; i++) {\n            int u = requests[i].start - 1;\n            int v = requests[i].end - 1;\n            \n            if (find(u) != find(v)) {\n                santas++;\n                unionSet(u, v);\n            }\n        }\n        \n        printf(\"%d\\n\", santas);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_HOUSES = 500;\nconst int INF = INT_MAX;\n\nstruct Request {\n    int house;\n    int deadline;\n};\n\nstruct Edge {\n    int dest;\n    int time;\n};\n\nclass Solution {\nprivate:\n    int n, m, k;\n    vector<vector<Edge>> graph;\n    vector<Request> requests;\n    \n    vector<int> dijkstra(int start) {\n        vector<int> dist(n + 1, INF);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        \n        dist[start] = 0;\n        pq.push({0, start});\n        \n        while (!pq.empty()) {\n            int currTime = pq.top().first;\n            int currNode = pq.top().second;\n            pq.pop();\n            \n            if (currTime > dist[currNode]) continue;\n            \n            for (const auto& edge : graph[currNode]) {\n                int nextNode = edge.dest;\n                int nextTime = currTime + edge.time;\n                \n                if (nextTime < dist[nextNode]) {\n                    dist[nextNode] = nextTime;\n                    pq.push({nextTime, nextNode});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    bool canDeliver(int santas) {\n        vector<bool> visited(n + 1, false);\n        \n        for (const auto& req : requests) {\n            bool found = false;\n            for (int santa = 1; santa <= santas; ++santa) {\n                vector<int> dist = dijkstra(santa);\n                if (dist[req.house] <= req.deadline) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) return false;\n        }\n        \n        return true;\n    }\n    \npublic:\n    void solve() {\n        cin >> n >> m >> k;\n        \n        graph.resize(n + 1);\n        \n        for (int i = 0; i < m; ++i) {\n            int u, v, t;\n            cin >> u >> v >> t;\n            graph[u].push_back({v, t});\n            graph[v].push_back({u, t});\n        }\n        \n        requests.resize(k);\n        for (int i = 0; i < k; ++i) {\n            cin >> requests[i].house >> requests[i].deadline;\n        }\n        \n        int left = 1, right = n;\n        int result = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (canDeliver(mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        cout << result << endl;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    Solution solution;\n    solution.solve();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\nimport heapq\n\ndef min_santas(datasets):\n    def dijkstra(num_houses, roads, start):\n        dist = {i: float('inf') for i in range(num_houses)}\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            current_dist, current = heapq.heappop(pq)\n            if current_dist > dist[current]:\n                continue\n            for neighbor, time in roads[current]:\n                distance = current_dist + time\n                if distance < dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        return dist\n\n    def can_delivery_completed(delivery_requests, dist):\n        for house, deadline in delivery_requests:\n            if dist[house] > deadline:\n                return False\n        return True\n\n    results = []\n    for houses, roads, requests in datasets:\n        num_houses = len(houses)\n        road_map = defaultdict(list)\n        \n        for road in roads:\n            start, end, time = road\n            road_map[start].append((end, time))\n            road_map[end].append((start, time))\n\n        fulfillable_santas = 0\n\n        for house_start in range(num_houses):\n            dist_from_start = dijkstra(num_houses, road_map, house_start)\n            if can_delivery_completed(requests, dist_from_start):\n                fulfillable_santas += 1\n\n        results.append(fulfillable_santas)\n\n    return results\n\n# Example datasets and invocation:\ndatasets = [\n    (\n        [0, 1, 2, 3],  # houses\n        [(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 0, 1)],  # roads\n        [(1, 5), (2, 6), (3, 10)]  # delivery requests (house, deadline)\n    ),\n    # Add more datasets below as needed\n]\n\nresults = min_santas(datasets)\nprint(results)",
    "timestamp": "2025-08-13 05:54:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ChristmasPresentDelivery {\n\n    static class DeliveryRequest {\n        int house;\n        int time;\n\n        DeliveryRequest(int house, int time) {\n            this.house = house;\n            this.time = time;\n        }\n    }\n\n    static class RoadNetwork {\n        int houses;\n        int[][] roads;\n\n        RoadNetwork(int houses, int[][] roads) {\n            this.houses = houses;\n            this.roads = roads;\n        }\n    }\n\n    static class Dataset {\n        RoadNetwork roadNetwork;\n        List<DeliveryRequest> deliveryRequests;\n\n        Dataset(RoadNetwork roadNetwork, List<DeliveryRequest> deliveryRequests) {\n            this.roadNetwork = roadNetwork;\n            this.deliveryRequests = deliveryRequests;\n        }\n    }\n\n    public static int calculateMinimumSantas(List<Dataset> datasets) {\n        int totalSantas = 0;\n        for (Dataset dataset : datasets) {\n            totalSantas += calculateSantasForDataset(dataset);\n        }\n        return totalSantas;\n    }\n\n    private static int calculateSantasForDataset(Dataset dataset) {\n        int houses = dataset.roadNetwork.houses;\n        int[][] roads = dataset.roadNetwork.roads;\n        List<DeliveryRequest> deliveryRequests = dataset.deliveryRequests;\n\n        int[] earliestDelivery = new int[houses];\n        Arrays.fill(earliestDelivery, Integer.MAX_VALUE);\n        for (DeliveryRequest request : deliveryRequests) {\n            earliestDelivery[request.house] = Math.min(earliestDelivery[request.house], request.time);\n        }\n\n        int santasNeeded = 0;\n        boolean[] santasAvailable = new boolean[houses];\n        Arrays.fill(santasAvailable, true);\n\n        for (DeliveryRequest request : deliveryRequests) {\n            if (santasAvailable[request.house]) {\n                santasAvailable[request.house] = false;\n                santasNeeded++;\n            } else {\n                santasNeeded++;\n            }\n\n            updateSantasAvailability(request.house, earliestDelivery, santasAvailable, roads);\n        }\n\n        return santasNeeded;\n    }\n\n    private static void updateSantasAvailability(int house, int[] earliestDelivery, boolean[] santasAvailable, int[][] roads) {\n        for (int i = 0; i < roads.length; i++) {\n            if (roads[i][0] == house && santasAvailable[roads[i][1]] && earliestDelivery[roads[i][1]] > earliestDelivery[house]) {\n                santasAvailable[roads[i][1]] = false;\n            }\n            if (roads[i][1] == house && santasAvailable[roads[i][0]] && earliestDelivery[roads[i][0]] > earliestDelivery[house]) {\n                santasAvailable[roads[i][0]] = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<Dataset> datasets = new ArrayList<>();\n        \n        int[][] roads1 = {{0, 1}, {1, 2}, {2, 3}};\n        List<DeliveryRequest> requests1 = Arrays.asList(new DeliveryRequest(0, 1), new DeliveryRequest(3, 5));\n        datasets.add(new Dataset(new RoadNetwork(4, roads1), requests1));\n        \n        int totalSantas = calculateMinimumSantas(datasets);\n        System.out.println(\"Minimum Santas required: \" + totalSantas);\n    }\n}",
    "timestamp": "2025-08-13 05:55:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define MAX_HOUSES 100\n#define MAX_REQUESTS 100\n\ntypedef struct {\n    int house;\n    int time_limit;\n} Request;\n\ntypedef struct {\n    int destination;\n    int travel_time;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node *head[MAX_HOUSES];\n    int num_houses;\n} Graph;\n\nvoid initGraph(Graph *graph, int num_houses) {\n    graph->num_houses = num_houses;\n    for (int i = 0; i < num_houses; i++) {\n        graph->head[i] = NULL;\n    }\n}\n\nvoid addEdge(Graph *graph, int u, int v, int travel_time) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->destination = v;\n    newNode->travel_time = travel_time;\n    newNode->next = graph->head[u];\n    graph->head[u] = newNode;\n}\n\nint minDistance(int dist[], bool sptSet[], int n) {\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < n; v++) {\n        if (!sptSet[v] && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\nvoid dijkstra(Graph *graph, int src, int dist[]) {\n    int n = graph->num_houses;\n    bool sptSet[n];\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        sptSet[i] = false;\n    }\n    dist[src] = 0;\n    for (int count = 0; count < n - 1; count++) {\n        int u = minDistance(dist, sptSet, n);\n        sptSet[u] = true;\n        Node *node = graph->head[u];\n        while (node != NULL) {\n            int v = node->destination;\n            int weight = node->travel_time;\n            if (!sptSet[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n            }\n            node = node->next;\n        }\n    }\n}\n\nint calculateMinSantas(Graph *graph, Request requests[], int num_requests) {\n    int dist[MAX_HOUSES];\n    int required_santas = 0;\n    \n    for (int i = 0; i < num_requests; i++) {\n        dijkstra(graph, 0, dist);\n        if (dist[requests[i].house] <= requests[i].time_limit) {\n            required_santas++;\n        }\n    }\n    return required_santas;\n}\n\nint main() {\n    int num_datasets;\n    scanf(\"%d\", &num_datasets);\n    while (num_datasets--) {\n        int num_houses, num_roads, num_requests;\n        scanf(\"%d %d %d\", &num_houses, &num_roads, &num_requests);\n        \n        Graph graph;\n        initGraph(&graph, num_houses);\n        \n        for (int i = 0; i < num_roads; i++) {\n            int u, v, travel_time;\n            scanf(\"%d %d %d\", &u, &v, &travel_time);\n            addEdge(&graph, u - 1, v - 1, travel_time);\n            addEdge(&graph, v - 1, u - 1, travel_time);\n        }\n        \n        Request requests[MAX_REQUESTS];\n        for (int i = 0; i < num_requests; i++) {\n            scanf(\"%d %d\", &requests[i].house, &requests[i].time_limit);\n            requests[i].house -= 1; // zero-based indexing\n        }\n        \n        int min_santas = calculateMinSantas(&graph, requests, num_requests);\n        printf(\"%d\\n\", min_santas);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 05:55:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\nimport heapq\n\ndef solve_santa_delivery(n, roads, requests):\n    # Create adjacency list representation of road network\n    graph = defaultdict(list)\n    for u, v, time in roads:\n        graph[u].append((v, time))\n        graph[v].append((u, time))\n    \n    # Track delivery requests\n    house_requests = defaultdict(list)\n    for house, deadline in requests:\n        house_requests[house].append(deadline)\n    \n    # Track used Santas and their routes\n    santa_count = 0\n    \n    # Process requests for each house\n    for house, deadlines in house_requests.items():\n        # Sort deadlines \n        deadlines.sort()\n        \n        # Check if multiple Santas needed\n        santa_needed = 1\n        last_delivery_time = float('-inf')\n        \n        for deadline in deadlines:\n            # If can't make this delivery with current Santa, add new Santa\n            if last_delivery_time > deadline:\n                santa_needed += 1\n            last_delivery_time = deadline\n        \n        santa_count += santa_needed\n    \n    return santa_count\n\ndef main():\n    # Read number of datasets\n    T = int(input())\n    \n    for _ in range(T):\n        # Read input for each dataset\n        n, m, k = map(int, input().split())\n        \n        # Read road network\n        roads = []\n        for _ in range(m):\n            u, v, time = map(int, input().split())\n            roads.append((u, v, time))\n        \n        # Read delivery requests\n        requests = []\n        for _ in range(k):\n            house, deadline = map(int, input().split())\n            requests.append((house, deadline))\n        \n        # Calculate and print minimum Santas needed\n        result = solve_santa_delivery(n, roads, requests)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:55:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        N = int(input[ptr])\n        M = int(input[ptr+1])\n        ptr +=2\n        if N == 0 and M == 0:\n            break\n        \n        adj = [[] for _ in range(N+1)]\n        for _ in range(M):\n            u = int(input[ptr])\n            v = int(input[ptr+1])\n            t = int(input[ptr+2])\n            ptr +=3\n            adj[u].append((v, t))\n            adj[v].append((u, t))\n        \n        R = int(input[ptr])\n        ptr +=1\n        requests = []\n        for _ in range(R):\n            u = int(input[ptr])\n            v = int(input[ptr+1])\n            deadline = int(input[ptr+2])\n            ptr +=3\n            requests.append((u, v, deadline))\n        \n        # Precompute all pairs shortest paths using Dijkstra's\n        dist = [[float('inf')] * (N+1) for _ in range(N+1)]\n        for u in range(1, N+1):\n            heap = []\n            heapq.heappush(heap, (0, u))\n            dist[u][u] = 0\n            while heap:\n                d, node = heapq.heappop(heap)\n                if d > dist[u][node]:\n                    continue\n                for neighbor, t in adj[node]:\n                    if dist[u][neighbor] > d + t:\n                        dist[u][neighbor] = d + t\n                        heapq.heappush(heap, (dist[u][neighbor], neighbor))\n        \n        # Sort requests by deadline in ascending order\n        requests.sort(key=lambda x: x[2])\n        \n        santas = 0\n        santa_schedule = []\n        for u, v, deadline in requests:\n            time_needed = dist[u][v]\n            if time_needed > deadline:\n                continue  # impossible to fulfill\n            \n            assigned = False\n            for i in range(len(santa_schedule)):\n                last_v, last_time = santa_schedule[i]\n                # Check if current santa can reach u from last_v in time\n                if dist[last_v][u] + time_needed <= deadline - last_time:\n                    santa_schedule[i] = (v, last_time + dist[last_v][u] + time_needed)\n                    assigned = True\n                    break\n            \n            if not assigned:\n                santas +=1\n                santa_schedule.append((v, time_needed))\n        \n        print(santas)\n\nsolve()",
    "timestamp": "2025-08-13 05:56:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, time;\n    Edge(int to, int time) : to(to), time(time) {}\n};\n\nstruct DeliveryRequest {\n    int house, time;\n    DeliveryRequest(int house, int time) : house(house), time(time) {}\n};\n\nbool compareTimes(const DeliveryRequest& a, const DeliveryRequest& b) {\n    return a.time < b.time;\n}\n\nint bfsMinSantas(int start, const vector<vector<Edge>>& adjList, int targetHouse, int targetTime) {\n    vector<int> minTime(adjList.size(), numeric_limits<int>::max());\n    queue<int> q;\n    q.push(start);\n    minTime[start] = 0;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        for (const Edge& edge : adjList[current]) {\n            int next = edge.to;\n            int time = edge.time;\n            if (minTime[current] + time < minTime[next]) {\n                minTime[next] = minTime[current] + time;\n                q.push(next);\n            }\n        }\n    }\n\n    return minTime[targetHouse] <= targetTime ? 1 : numeric_limits<int>::max();\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n\n    for (int datasetIdx = 0; datasetIdx < numDatasets; ++datasetIdx) {\n        int numHouses, numRoads, numRequests;\n        cin >> numHouses >> numRoads >> numRequests;\n\n        vector<vector<Edge>> adjList(numHouses + 1);\n        for (int i = 0; i < numRoads; ++i) {\n            int from, to, time;\n            cin >> from >> to >> time;\n            adjList[from].emplace_back(to, time);\n            adjList[to].emplace_back(from, time); // Assuming roads are bidirectional\n        }\n\n        vector<DeliveryRequest> requests;\n        for (int i = 0; i < numRequests; ++i) {\n            int house, time;\n            cin >> house >> time;\n            requests.emplace_back(house, time);\n        }\n\n        sort(requests.begin(), requests.end(), compareTimes);\n\n        int minSantas = 0;\n        for (const DeliveryRequest& request : requests) {\n            int requiredSantas = bfsMinSantas(0, adjList, request.house, request.time);\n            if (requiredSantas == numeric_limits<int>::max()) {\n                minSantas = numeric_limits<int>::max();\n                break;\n            }\n            minSantas += requiredSantas;\n        }\n\n        cout << (minSantas == numeric_limits<int>::max() ? -1 : minSantas) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:09"
  }
]