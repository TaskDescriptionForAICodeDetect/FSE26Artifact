[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct BipMatch{\n  int n;\n  vector<vector<int> > G;\n  vector<int> match,used;\n  \n  BipMatch(){}\n  BipMatch(int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n        match[v]=u;\n        match[u]=v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int build(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<n;v++){\n      if(match[v]<0){\n        fill(used.begin(),used.end(),0);\n        if(dfs(v)){\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nint n,a[101][101],a1,a2,a3,p[1001],t[1001],m,m2;\n\nint main(){\nwhile(1){\n  r(i,101)r(j,101)a[i][j]=(i==j?0:1e8);\n  cin>>n>>m>>m2;\n  if(n==0)return 0;\n  r(i,m){\n    cin>>a1>>a2>>a3;\n    a[a2][a1]=a[a1][a2]=a3;\n  }\n  r(i,m2)cin>>p[i]>>t[i];\n  r(k,n)r(i,n)r(j,n)a[i][j]=min(a[i][j],a[i][k]+a[k][j]);\n  BipMatch D(m2*2);\n  r(i,m2){\n    r(j,m2)if(i!=j){\n      if(a[p[i]][p[j]]+t[i]<=t[j]){\n        D.add_edge(i,j+m2);\n      }\n    }\n  }\n  cout<<m2-D.build()<<endl;\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint main(){\n\tint N,M,L;\n\tint u[1000],v[1000],d[1000],p[1000],t[1000];\n\tvector<int> numofsanta;\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\n\twhile(N != 0 || M != 0 || L != 0){\n\t\tint dist[N][N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = 100000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> psort;\n\t\tvector<int> tsort; \n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d\",&u[i],&v[i],&d[i]);\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\n\t\t//Warshall-Floyd Algorithm\n\n    \tfor(int i = 0; i < N; i++){\n        \tfor(int j = 0; j < N; j++){\n            \tfor(int k = 0; k < N; k++){\n            \t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            \t}\n            }\n        }\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tvector<int>::iterator pit = psort.begin();\n\t\t\tvector<int>::iterator tit = tsort.begin();\t\t\t\t\n\t\t\tscanf(\"%d %d\",&p[i],&t[i]);\n\t\t\tif(i == 0){\n\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\ttsort.push_back(t[i]);\n\t\t\t}else{\n\t\t\t\tint siz = psort.size();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tif(tsort[j] > t[i]){\n\t\t\t\t\t\tpsort.insert(pit,p[i]);\n\t\t\t\t\t\ttsort.insert(tit,t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\t\t\ttsort.push_back(t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++pit;\n\t\t\t\t\t\t++tit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint nos = 1;\n\t\tvector<int> santanow;\n\t\tvector<int> santatime;\n\t\tfor(int i = 0; i < psort.size(); i++){\n\t\t\tif(i == 0){\n\t\t\t\tsantanow.push_back(psort[i]);\n\t\t\t\tsantatime.push_back(0);\n\t\t\t}else{\n\t\t\t\tint siz = santanow.size();\n\t\t\t\tvector<int>::iterator itn = santanow.begin();\n\t\t\t\tvector<int>::iterator itt = santatime.begin();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tint temp = santatime[j]  + dist[psort[i]][santanow[j]];\n\t\t\t\t\tif(temp <= tsort[i]){\n\t\t\t\t\t\titt = santatime.erase(itt);\n\t\t\t\t\t\tsantatime.insert(itt,tsort[i]);\n\t\t\t\t\t\titn = santanow.erase(itn);\n\t\t\t\t\t\tsantanow.insert(itn,psort[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tsantanow.push_back(psort[i]);\n\t\t\t\t\t\tsantatime.push_back(tsort[i]);\n\t\t\t\t\t\tnos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\titn++;\n\t\t\t\t\t\titt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnumofsanta.push_back(nos);\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t}\n\n\tfor(int i = 0; i < numofsanta.size(); i++){\n\t\tprintf(\"%d\\n\",numofsanta[i]);\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match;\n  vector< bool > used;\n\n  Bipartite_Matching(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v)\n  {\n    used[v] = true;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(w == -1 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    match.assign(graph.size(), -1);\n    for(int i = 0; i < graph.size(); i++) {\n      if(match[i] == -1) {\n        used.assign(graph.size(), false);\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  int cost[100][100];\n  int p[1000], t[1000];\n\n  while(scanf(\"%d %d %d\", &N, &M, &L), L) {\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) cost[i][j] = INF;\n      cost[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      cost[u][v] = cost[v][u] = d;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n\n    Bipartite_Matching flow(L + L);\n    for(int i = 0; i < L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(i == j) continue;\n        if(t[j] - t[i] >= cost[p[i]][p[j]]) {\n          flow.add_edge(i, j + L);\n        }\n      }\n    }\n    printf(\"%d\\n\", L - flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 29;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,x,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \n/*--------------------------*/\nusing vvi = vector<vi>;\nconst int kMax_n = 5001; //????????°????????§???\n\nint n; //????????°\nvvi G(kMax_n);\nvi match(kMax_n); //??????????????°????????¢\nvi used(kMax_n);\n\n// u??¨v????????¶????????°?????????????????????\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n// ?¢?????????????DFS??§??¢???\nbool dfs(int v){\n    used[v] = true;\n    \n    for(auto u : G[v]){\n        int w = match[u];\n\n        if(w < 0 || (!used[w] && dfs(w))){\n            match[v] = u;\n            match[u] = v;\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//????????°??????????????§??????????????°????±???????\nint b_match(void){\n    int res = 0;\n\n    fill(_all(match), -1);\n\n    rep(i, n){\n        if(match[i] < 0){\n            fill(_all(used), false);\n\n            if(dfs(i)) res++;\n        }\n    }\n\n    return res;\n}\n\nvoid init_G(void){\n    for(auto & g : G) g.clear();\n}\n/*--------------------------*/\n\nint main(void){\n    for(int N, m, L; cin >> N >> m >> L, N;){\n        vvi dist(N, vi(N, inf));\n        rep(i, N) dist[i][i] = 0;\n        rep(loop, m){\n            int u, v, d; cin >> u >> v >> d;\n\n            dist[u][v] = dist[v][u] = d;\n        }\n\n        vector<pair<int, int>> tasks(L);\n        for(auto & e : tasks){\n            cin >> e.first >> e.second;\n        }\n\n        rep(k, N){\n            rep(i, N){\n                rep(j, N){\n                    chmin(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        n = 2 * L;\n        init_G();\n        rep(i, L){\n            rep(j, L){\n                if(i == j) continue;\n\n                if(tasks[i].second + dist[tasks[i].first][tasks[j].first] > tasks[j].second){\n                    continue;\n                }\n\n                int a = i, b = L + j;\n                add_edge(a, b);\n            }\n        }\n\n        cout << L - b_match() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint main(){\n\tint N,M,L;\n\tint u[1000],v[1000],d[1000],p[1000],t[1000];\n\tvector<int> numofsanta;\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\n\twhile(N != 0 || M != 0 || L != 0){\n\t\tint dist[N][N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = 100000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> psort;\n\t\tvector<int> tsort; \n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d\",&u[i],&v[i],&d[i]);\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\n\t\t//Warshall-Floyd Algorithm\n\n    \tfor(int i = 0; i < N; i++){\n        \tfor(int j = 0; j < N; j++){\n            \tfor(int k = 0; k < N; k++){\n            \t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            \t}\n            }\n        }\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tvector<int>::iterator pit = psort.begin();\n\t\t\tvector<int>::iterator tit = tsort.begin();\t\t\t\t\n\t\t\tscanf(\"%d %d\",&p[i],&t[i]);\n\t\t\tif(i == 0){\n\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\ttsort.push_back(t[i]);\n\t\t\t}else{\n\t\t\t\tint siz = psort.size();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tif(tsort[j] > t[i]){\n\t\t\t\t\t\tpsort.insert(pit,p[i]);\n\t\t\t\t\t\ttsort.insert(tit,t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\t\t\ttsort.push_back(t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++pit;\n\t\t\t\t\t\t++tit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint nos = 1;\n\t\tvector<int> santanow;\n\t\tvector<int> santatime;\n\t\tfor(int i = 0; i < psort.size(); i++){\n\t\t\tif(i == 0){\n\t\t\t\tsantanow.push_back(psort[i]);\n\t\t\t\tsantatime.push_back(0);\n\t\t\t}else{\n\t\t\t\tint siz = santanow.size();\n\t\t\t\tvector<int>::iterator itn = santanow.begin();\n\t\t\t\tvector<int>::iterator itt = santatime.begin();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tint temp = santatime[j]  + dist[psort[i]][santanow[j]];\n\t\t\t\t\tif(temp <= tsort[i]){\n\t\t\t\t\t\titt = santatime.erase(itt);\n\t\t\t\t\t\tsantatime.insert(itt,tsort[i]);\n\t\t\t\t\t\titn = santanow.erase(itn);\n\t\t\t\t\t\tsantanow.insert(itn,psort[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tsantanow.push_back(psort[i]);\n\t\t\t\t\t\tsantatime.push_back(tsort[i]);\n\t\t\t\t\t\tnos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\titn++;\n\t\t\t\t\t\titt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnumofsanta.push_back(nos);\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t}\n\n\tfor(int i = 0; i < numofsanta.size(); i++){\n\t\tprintf(\"%d\\n\",numofsanta[i]);\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\n\nstruct BipartiteMatching {\n    int n, timestamp;\n    vector<vector<int>> graph;\n    vector<int> alive, used, match;\n    BipartiteMatching(int n) : \\\n        n(n), timestamp(0), graph(n), alive(n, 1), used(n, 0), match(n, -1) { }\n    void add_edge(int u, int v) {\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n    bool dfs(int idx) {\n        used[idx] = timestamp;\n        for (auto &to: graph[idx]) if (alive[to]) {\n            int to_match = match[to];\n            if (to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n                match[idx] = to;\n                match[to] = idx;\n                return true;\n            }\n        }\n        return false;\n    }\n    int bipartite_matching() {\n        int ret = 0;\n        for (int i = 0; i < n; i++) if (alive[i]) {\n            if (match[i] == -1) ++timestamp, ret += dfs(i);\n        }\n        return ret;\n    }\n    friend ostream& operator<<(ostream& os, BipartiteMatching& bm) {\n        for (int i = 0; i < bm.n; i++) if (i < bm.match[i]) {\n            os << i << \" - \" << bm.match[i] << endl;\n        }\n        return os;\n    }\n};\n\nint main() {\n    int N, M, L;\n    while (cin >> N >> M >> L, N) {\n        vector<vector<int>> dist(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) dist[i][i] = 0;\n        for (int i = 0; i < M; i++) {\n            int u, v, d; cin >> u >> v >> d;\n            dist[u][v] = dist[v][u] = d;\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n        vector<int> p(L), t(L);\n        for (int i = 0; i < L; i++) cin >> p[i] >> t[i];\n        BipartiteMatching bm(2 * L);\n        for (int i = 0; i < L; i++) for (int j = 0; j < L; j++) if (i != j) {\n            if (dist[p[i]][p[j]] <= t[j] - t[i]) bm.add_edge(i, j + L);\n        }\n        cout << L - bm.bipartite_matching() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nbool flow[2005][2005], capa[2005][2005];\nbool DAG[1005][1005];\nint L,v[2020];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int u, int v, int w)\n{\n\tflow[v][u]=1;\n\tcapa[u][v]=1;\n\tcapa[v][u]=1;\n\tnode[u].to.push_back(v);\n\tnode[v].to.push_back(u);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=(flow[p][next]?0:1);\n\t\tif(p==SOUR||next==SINK) fw=1;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\t\n\t\tif(min(mf,fw) != 1) printf(\"%d\\n\", min(mf,fw));\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]=1;\n\t\t\tflow[next][p]=0;\n\t\t\t\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]-flow[n][next] <= 0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid Connect(int u, int v, int w, vector<Node>& graph)\n{\n\tgraph[u].to.push_back(v);\n\tgraph[v].to.push_back(u);\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\t\n\tflow[v][u]+=w;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(capa, 0, sizeof(capa));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\tfor(int j=0; j<L; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t{\n\t\t\t\tDAG[i][j]=1;\n\t\t\t\tbeg[j]=1;\n\t\t\t\tend[i]=1;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]) \n\t\t\t{\n\t\t\t\tConnect(node, SOUR, i, INF);\n\t\t\t}\n\t\t\tif(!end[i]) \n\t\t\t{\n\t\t\t\tConnect(node, L+i, SINK, INF);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint add=0;\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]&&!end[i])\n\t\t\t{\n\t\t\t\t++add;\n\t\t\t}\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(DAG[i][j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j,1);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dinic(SOUR,SINK,node)+add);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int maxn = 0x7F7F7F7F;\nint n, m, l;\nstruct Point{\n    int p, t;\n    Point(){}\n    Point(int p, int t){\n        this->p = p;\n        this->t = t;\n    }\n    void assign(int p, int t){\n        this->p = p;\n        this->t = t;\n    }\n}tasks[1001];\nint dis[101][101];\nvector<int> G[2002];\nint match[2002];\nbool used[2002];\n\n\nbool compare(const Point &a, const Point &b){\n    if(a.t<b.t && dis[a.p][b.p]<=b.t-a.t)\n        return true;\n    else\n        return false; \n}\n\n\nvoid floyd(){\n    for(int k=0; k<n; k++){\n        for(int i=0; i<n; i++){\n            if(i!=k){\n                for(int j=0; j<n; j++){\n                    if(k!=j && i!=j){\n                        if(dis[i][k]<maxn && dis[k][j]<maxn){\n                            dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\n\nbool dfs(int u){\n    used[u] = true;\n    int v, w;\n    for(int i=0; i<G[u].size(); i++){\n        v = G[u][i];\n        if(match[v]==-1 || !used[match[v]]&&dfs(match[v])){\n            match[u] = v;\n            match[v] = u;\n            return true;\n        }        \n    }\n    return false;\n}\n\n\nint Hungary(){\n    memset(match, 255, sizeof(match));\n    for(int u=0; u<2*l; u++){\n        if(match[u]==-1){\n            memset(used, 0, sizeof(used));\n            dfs(u);\n        }\n    }\n    int ans = l;\n    /*\n    for(int i=0; i<l; i++)\n        printf(\"%d \", match[i]);\n    printf(\"\\n\");\n    */\n    for(int i=0; i<l; i++)\n        ans -= match[i]!=-1;\n    return ans;\n}\n\n\nint main(){\n    //freopen(\"in.txt\", \"r\", stdin);\n    int u, v, w, p, t;\n    while(scanf(\"%d %d %d\", &n, &m, &l), n!=0){\n        memset(dis, 127, sizeof(dis));\n        for(int i=0; i<n; i++)\n            dis[i][i] = 0;\n        for(int i=0; i<m; i++){\n            scanf(\"%d %d %d\", &u, &v, &w);\n            dis[u][v] = w;\n            dis[v][u] = w;\n        }\n        floyd();\n        /*\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                printf(\"%d \", dis[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        */ \n        for(int i=0; i<l; i++){\n            G[i].clear(); G[i+l].clear();\n            scanf(\"%d %d\", &p, &t);\n            tasks[i].assign(p, t);\n        }\n\n        for(int i=0; i<l; i++)\n        for(int j=0; j<l; j++){\n            if(i!=j){\n                if(compare(tasks[i], tasks[j])){\n                    G[i].push_back(j+l);\n                    G[j+l].push_back(i);\n                }\n                else if(compare(tasks[j], tasks[i])){\n                    G[j].push_back(i+l);\n                    G[i+l].push_back(j);\n                }\n            }\n        }\n        printf(\"%d\\n\", Hungary());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[s]=dag[s][i],pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(cin>>N>>M>>L,N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=(INT_MAX-1)/2;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w; cin>>u>>v>>w;\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)cin>>p[i]>>t[i];\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool bm_augment(const vector<vector<int> >& g, int u, vector<int>& match_to, vector<int>& visited) // {{{\n{\n  if (u < 0) {\n    return true;\n  }\n\n  for (vector<int>::const_iterator it = g[u].begin(); it != g[u].end(); ++it) {\n    if (!visited[*it]) {\n      visited[*it] = true;\n      if (bm_augment(g, match_to[*it], match_to, visited)) {\n        match_to[u] = *it;\n        match_to[*it] = u;\n        return true;\n      }\n    }\n  }\n  return false;\n} // }}}\n\nint bipartite_matching(const vector<vector<int> >& g)  // {{{\n{\n  const int N = g.size();\n  vector<int> match_to(N, -1);\n  int match = 0;\n  vector<int> visited;\n  for (int u = 0; u < N; u++) {\n    visited.assign(N, false);\n    if (bm_augment(g, u, match_to, visited)) {\n      match++;\n    }\n  }\n  return match;\n} // }}}\n\nstruct by_second\n{\n  template <class T, class U>\n  bool operator()(const pair<T,U>& a, const pair<T,U>& b) const\n  {\n    if (a.second == b.second) {\n      return a.first < b.first;\n    } else {\n      return a.second < b.second;\n    }\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    static const int INF = 10000000;\n    vector<vector<int> > dist(N, vector<int>(N, INF));\n    for (int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      dist[u][v] = dist[v][u] = d;\n    }\n    vector<pair<int,int> > pt(L);\n    for (int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &pt[i].first, &pt[i].second);\n    }\n    sort(pt.begin(), pt.end(), by_second());\n\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    vector<vector<int> > g(2*L);\n    for (int i = 0; i < L; i++) {\n      for (int j = i+1; j < L; j++) {\n        const int u = pt[i].first;\n        const int v = pt[j].first;\n        if (dist[u][v] <= pt[j].second - pt[i].second) {\n          g[i].push_back(j+L);\n        }\n      }\n    }\n    const int r = bipartite_matching(g);\n    printf(\"%d\\n\", L-r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef int Weight;\ntypedef int Flow;\n\n#define REP(i,n) for(int i = 0; i < n; i++)\nconst int INF = 1e8;\n\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\ntypedef int Weight;\ntypedef int Flow;\n\nvoid add_edge(Graph &g, int src, int dest, Flow cap) {\n  g[src].push_back((Edge) { src, dest, (int)g[dest].size(), cap, 0 });\n  g[dest].push_back((Edge) { dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (Edge &e : g[v]) {\n    if (!used[e.dest] && e.cap > 0) {\n      Flow d = dfs(g, used, e.dest, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.dest][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t) {\n  Flow flow = 0;\n  for (;;) {\n    vector<bool> used(g.size(), false);\n    Flow f = dfs(g, used, s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nvector<vector<int>> road;\n\n\nbool reachable(int from, int to, int time){\n  return road[from][to] <= time;\n}\nsigned main(){\n  int n,m,l;\n  while(cin >> n >> m >> l, n != 0){\n    road = vector<vector<int>>(n,vector<int>(n,INF));\n    for(int range(i,0,m)){\n      int u, v, d;\n      cin >> u >> v >> d;\n      road[u][v] = road[v][u] = d;\n    }\n\n    vector<tuple<int,int>> req;\n    for(int range(i,0,l)){\n      int p,t;\n      cin >> p >> t;\n      req.emplace_back(t,p);\n    }\n    sort(all(req));\n\n    for(int range(k,0,n)){\n      for(int range(i,0,n)){\n        for(int range(j,0,n)){\n          road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n        }\n      }\n    }\n\n\n    const int s_id = 0;\n    const int t_id = 1;\n    const int g_size = 2 + l + l;\n    Graph g(g_size, Edges());\n    for(int range(i,0,l)){\n      for(int range(j,i+1,l)){\n        int pt, pp, nt, np;\n        tie(pt, pp) = req[i];\n        tie(nt, np) = req[j];\n        if(road[pp][np] <= nt - pt){\n          add_edge(g, 2 + i, 2 + l + j, 1);\n        }\n      }\n    }\n    for(int range(i,0,l)){\n      add_edge(g, s_id, 2 + i, 1);\n      add_edge(g, 2 + l + i, t_id, 1);\n    }\n    int ff = ford_fulkerson(g, s_id, t_id);\n\n    cout << l - ff << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <limits>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n#define   min_int(a,b)  ( ((a)<(b) ) ? (a) : (b) )\nusing namespace std;\nclass Req{\npublic:\n  char house;\n  int time;\n};\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\nint dist[max_n][max_n];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\nint req_graph[max_l][max_l];\nint num_child[max_l];//各リクエストxの子の数\nint parent[max_l]; //被覆パスにおけるリクエストxの親\nint till[max_l];\nbool visited[max_l];\nint halfmax = (numeric_limits<int>::max())/2;\n \n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n   \n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j,h1,h2;\n \n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++) for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] != halfmax) //h1、h2間に経路あり\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n  } \n}\n \nint find(int i, bool root){\n  int child, x, found;\n  //親権の空いている子を探す\n  visited[i] = true;  \n  if(till[i] < num_child[i]){    \n    while((++(till[i])) < num_child[i]){\n      child = req_graph[i][till[i]];\n      if(parent[child] >= 0) continue;\n      parent[child] = i; //childを自分の子とする\n      return child;\n    }\n  }\n  //他の親から親権を譲ってもらえる子を探す  \n  for(int j = 0;j < num_child[i]; j++){\n    child = req_graph[i][j];\n    x = parent[child]; //x: childのパス上の親\n    if(visited[x]) continue;\n    found = find(x,false); //xからchildの親権をもらう交渉\n    if(found < 0) continue;\n    parent[child] = i; //childの親権獲得\n    return child;\n  }\n  return -1;\n}\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  memset(till,-1,l*sizeof(int));\n  memset(parent,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    memset(visited,0,l*sizeof(bool));\n    find(i,true);\n  }\n  for(int i=0;i<l;i++) if(parent[i]<0) num++;\n  return num;\n}\n \n//プレゼント配送に必要なサンタの数を出力する関数\nint santas(){\n  int u,v,d,i,j;\n  //入力読み込み\n  for(i=0;i<n;i++) dist[i][i] = 0;\n  for(i=0;i<n;i++) for(j=i+1;j<n;j++) dist[i][j] = halfmax;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  return res;\n}\n \n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;    \n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Weight = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight): src(src), dst(dst), weight(weight) {}\n};\nusing Vertex = vector<Edge>;\nusing Graph = vector<Vertex>;\n\nbool augment(const Graph& graph, vector<bool>& visited, vector<int>& match, int u) {\n    if (u == -1) return true;\n    for (auto& e : graph[u]) {\n        if (!visited[e.dst]) {\n            visited[e.dst] = true;\n            if (augment(graph, visited, match, match[e.dst])) {\n                match[e.src] = e.dst;\n                match[e.dst] = e.src;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint bipartie_matching(const Graph& graph, int n_left) {\n    vector<int> match(graph.size(), -1);\n    int n_match = 0;\n    REP(u, n_left) {\n        vector<bool> visited(graph.size());\n        if (augment(graph, visited, match, u)) ++n_match;\n    }\n    return n_match;\n}\n\nvector<vector<Weight>> warshall_floyd(Graph graph) {\n    static const Weight inf = numeric_limits<Weight>::max() / 10;\n    vector<vector<Weight>> dist(graph.size(), vector<Weight>(graph.size(), inf));\n    REP(u, graph.size()) dist[u][u] = 0;\n    REP(u, graph.size()) for (auto& e : graph[u]) dist[e.src][e.dst] = e.weight;\n    REP(u, graph.size()) REP(v, graph.size()) REP(w, graph.size())\n        dist[u][v] = min(dist[u][v], dist[u][w] + dist[w][v]);\n    return dist;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, L;\n    while (cin>>N>>M>>L, N|M|L) {\n        Graph graph1(N);\n        REP(i, M) {\n            int u, v, d; cin >> u >> v >> d;\n            graph1[u].emplace_back(u, v, d);\n            graph1[v].emplace_back(v, u, d);\n        }\n        vector<pair<int, int>> schedules(L);\n        REP(i, L) cin >> schedules[i].second >> schedules[i].first;\n        sort(schedules.begin(), schedules.end());\n\n        vector<vector<Weight>> dist = warshall_floyd(graph1);\n\n        Graph graph2(2*L);\n        REP(i, L) {\n            int t1, p1; tie(t1, p1) = schedules[i];\n            FOR(j, i+1, L) {\n                int t2, p2; tie(t2, p2) = schedules[j];\n                if (dist[p1][p2] <= t2-t1) {\n                    graph2[i].emplace_back(i, j+L, 0);\n                }\n            }\n        }\n        cout << L - bipartie_matching(graph2, L) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconst int N = 1005;\nconst int M = N*N;\n\nstruct EG{\n    int next, v;\n} edge[M];\n\nstruct Node{\n    int u, t;\n    Node(int u=0, int t =0):u(u),t(t){}\n} node[N];\n\nint ghead[N], gcnt;\nbool vis[N];\nint match[N], tmp[N];\nint n, m;\n\nint d[N][N];\nvoid addedge(int u, int v){\n    edge[gcnt].v = v;\n    edge[gcnt].next = ghead[u];\n    ghead[u] = gcnt++;\n}\n\nbool dfs(int u){\n    int i, v;\n    for (i = ghead[u]; i != -1; i = edge[i].next){\n        v = edge[i].v;\n        if (!vis[v]){\n            vis[v] = 1;\n            if (match[v]==-1 || dfs(match[v])){\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint L;\nint hungary(){\n    int ans = 0;\n    memset(match, -1, sizeof(match));\n    for (int i = 1; i <= L; i++){\n        memset(vis, 0 ,sizeof(vis));\n        if (dfs(i)) ans++;\n    }\n    return ans;\n}\n\nint main(){\n    int n, m, i, u, t, v, _d, k, j;\n    while(~scanf(\"%d%d%d\",&n,&m,&L)&&(n+m+L)){\n        memset(d, 0x1f, sizeof(d));\n        for(i=0;i<m;++i){\n            scanf(\"%d%d%d\",&u,&v,&_d);\n            ++u, ++v;\n            d[u][v] = d[v][u] = _d;\n        }\n\n        for(i=1;i<=L;++i){\n            scanf(\"%d%d\",&u,&t);\n            ++u;\n            node[i] = Node(u, t);\n        }\n\n        for(k=1;k<=n;++k) for(i=1;i<=n;++i) for(j=1;j<=n;++j) if(i!=j && j!=k && k!=i)\n            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        gcnt = 0;\n        memset(ghead, -1, sizeof(ghead));\n        for(i=1;i<=L;++i) for(j=1;j<=L;++j)\n            if(i!=j && node[i].t + d[node[i].u][node[j].u] <= node[j].t)\n                addedge(i,j);\n        printf(\"%d\\n\", L - hungary());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nstruct BipartiteMatching {\n\tint V;\n\tvector<vector<bool> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\n\tBipartiteMatching(int v) {\n\t\tV = v;\n\t\tG = vector<vector<bool> >(v, vector<bool>(v));\n\t\tmatch = vector<int>(v);\n\t\tused = vector<bool>(v);\n\t}\n\n\tvoid add_edge(int v, int u) {\n\t\tG[v][u] = G[u][v] = true;\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(!G[v][i]) continue;\n\t\t\tint u = i, w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint calc() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tBipartiteMatching bp(N + N);\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tbp.add_edge(u, v + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << max(1, N - bp.calc()) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint N, M, L;\nint S, T;\nint dist[105][105];\nint p[1005], t[1005];\nvector<edge> G[2005];\nbool used[2005];\n\nvoid WarshallFloyd()\n{\n\tfor(int k = 0; k < N; k++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v)\n{\n\tG[u].push_back( edge(v, 1, G[v].size() ) );\n\tG[v].push_back( edge(u, 0, G[u].size()-1 ) );\n}\n\nint dfs(int v, int c)\n{\n\tif(v == T) return c;\n\tused[v] = true;\n\t\n\tint ret;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap == 0) continue;\n\t\tret = dfs(G[v][i].to, min(c, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint u, v, d;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\n\t\tWarshallFloyd();\n\t\t\n\t\tfor(int i = 1; i <= L; i++){\n\t\t\tcin >> p[i]>> t[i];\n\t\t}\n\t\t\n\t\tS = 0, T = 2 * L + 1;\n\t\tfor(int i = S; i <= T; i++) G[i].clear();\n\t\tfor(int i = 1; i <= L; i++){\n\t\t\tadd_edge(S, i);\n\t\t\tadd_edge(L+i, T);\n\t\t\tfor(int j = 1; j <= L; j++){\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(i, L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret, flow = 0;\n\t\twhile(1){\n\t\t\tfor(int i = S; i <= T; i++) used[i] = false;\n\t\t\tret = dfs(S, inf);\n\t\t\tif(ret == 0) break;\n\t\t\tflow += ret;\n\t\t}\n\t\t\n\t\tcout << L - flow << endl;\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool bm_augment(const vector<vector<int> >& g, int u, vector<int>& match_to, vector<int>& visited) // {{{\n{\n  if (u < 0) {\n    return true;\n  }\n\n  for (vector<int>::const_iterator it = g[u].begin(); it != g[u].end(); ++it) {\n    if (!visited[*it]) {\n      visited[*it] = true;\n      if (bm_augment(g, match_to[*it], match_to, visited)) {\n        match_to[u] = *it;\n        match_to[*it] = u;\n        return true;\n      }\n    }\n  }\n  return false;\n} // }}}\n\nint bipartite_matching(const vector<vector<int> >& g)  // {{{\n{\n  const int N = g.size();\n  vector<int> match_to(N, -1);\n  int match = 0;\n  vector<int> visited;\n  for (int u = 0; u < N; u++) {\n    visited.assign(N, false);\n    if (bm_augment(g, u, match_to, visited)) {\n      match++;\n    }\n  }\n  return match;\n} // }}}\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    static const int INF = 10000000;\n    vector<vector<int> > dist(N, vector<int>(N, INF));\n    for (int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      dist[u][v] = dist[v][u] = d;\n    }\n    vector<pair<int,int> > pt(L);\n    for (int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &pt[i].first, &pt[i].second);\n    }\n\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    vector<vector<int> > g(2*L);\n    for (int i = 0; i < L; i++) {\n      for (int j = 0; j < L; j++) {\n        if (i == j) {\n          continue;\n        }\n        const int u = pt[i].first;\n        const int v = pt[j].first;\n        if (dist[u][v] <= pt[j].second - pt[i].second) {\n          g[i].push_back(j+L);\n        }\n      }\n    }\n    const int r = bipartite_matching(g);\n    printf(\"%d\\n\", L-r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\n#define MAX_V 3000\nstruct Edge{\n  int src, dest;\n  int cap, rev;\n};\n\nconst int INF = 1000000000;\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nbool visited[MAX_V];\n\nvoid add_edge(Graph &g, int src, int dest, int cap) {\n  g[src].push_back((Edge){src, dest, cap, (int)g[dest].size()});\n  g[dest].push_back((Edge){dest, src, 0, (int)g[src].size() - 1});\n}\n\nint dfs(Graph &g, int v, int t, int f) {\n  if (v == t) return f;\n  visited[v] = true;\n  REP(i, g[v].size()) {\n    Edge &e = g[v][i];\n    if (!visited[e.dest] && e.cap > 0) {\n      int d = dfs(g, e.dest, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.dest][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph &g, int s, int t) {\n  int flow = 0;\n  for(;;) {\n    memset(visited, 0, sizeof(visited));\n    int f = dfs(g, s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  while(1){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(!n)break;\n    vector<vector<int>> b(n,vector<int>(n,INF));\n    REP(i,m){\n      int u,v,d;\n      cin>>u>>v>>d;\n      b[u][v] = d;\n      b[v][u] = d;\n    }\n    REP(i,n) b[i][i] = 0;\n    REP(k,n)REP(i,n)REP(j,n)\n      b[i][j]=min(b[i][j], b[i][k]+b[k][j]);\n    vector<pair<int,int>> q;\n    REP(i,l){\n      int p,t;\n      cin>>p>>t;\n      q.emplace_back(t,p);\n    }\n    sort(begin(q),end(q));\n    Graph g(l*2+2);\n    REP(i,l)REP(j,i){\n      int ps,ts,pe,te;\n      tie(ts,ps) = q[j];\n      tie(te,pe) = q[i];\n      if(b[ps][pe] <= te - ts) {\n        add_edge(g, j + 1, i + l + 1, 1);\n      }\n    }\n    REP(i,l){\n      add_edge(g, 0, i+1, 1);\n      add_edge(g, l+i+1, 2*l+1, 1);\n    }\n    int f = max_flow(g, 0, 2*l+1);\n    cout << l - f << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string.h>\n#include<sstream>\n#include<algorithm>\n#include<vector>\n//#include<ext/hash_map>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<math.h>\n#include<utility>\n#include<cmath>\n#include<iostream>\n#include<ctype.h>\n#define ll long long\n#define i64 __int64\n#define INF 1000000000\n#define sz(b) (int)b.size()\n#define pb push_back\n#define pf push_front\n#define lson k<<1\n#define rson k<<1|1\n#define MOD 1000000\n#define N 10005\nusing namespace std;\n//using namespace __gnu_cxx;\nint G[105][105],n,m,mat[205],q[1005],t[1005];\nbool used[205];\nvector<int> a[205];\nvector<int> p;\nvoid make()\n{\n    int from,to,d;\n    p.clear();\n    for(int i=0;i<2*n;i++) a[i].clear();\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n        {\n            if(i==j) G[i][j]=0;\n            else G[i][j]=INF;\n\n        }\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&from,&to,&d);\n        G[from][to]=min(G[from][to],d);\n        G[to][from]=min(G[to][from],d);\n    }\n}\nvoid floyd()\n{\n    for(int k=0;k<n;k++)\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                if(G[i][j]>G[i][k]+G[k][j])\n                    G[i][j]=G[i][k]+G[k][j];\n}\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0;i<sz(a[v]);i++)\n    {\n        int u=a[v][i],w=mat[u];\n        if(w<0||!used[w]&&dfs(w))\n        {\n            mat[v]=u;\n            mat[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\nint match()\n{\n    int ret=0;\n    memset(mat,-1,sizeof(mat));\n    for(int i=0;i<sz(p);i++)\n    {\n        if(mat[p[i]]<0)\n        {\n            memset(used,0,sizeof(used));\n            if(dfs(p[i])) ret++;\n        }\n    }\n    return ret;\n}\nint main()\n{\n    int k;\n    while(scanf(\"%d %d %d\",&n,&m,&k)!=EOF)\n    {\n        if(n==0&&m==0&&k==0) break;\n        make();\n        floyd();\n        for(int i=0;i<k;i++) scanf(\"%d%d\",&q[i],&t[i]);\n        for(int i=0;i<k;i++)\n            for(int j=0;j<k;j++)\n            {\n                if(G[q[i]][q[j]]==INF) continue;\n                if(i==j) continue;\n                if(G[q[i]][q[j]]<=t[i]-t[j])\n                {\n                    a[q[j]].pb(q[i]+n);\n                    p.pb(q[i]+n);\n                    p.pb(q[j]);\n                }\n            }\n        int ans=n-match();\n        if(ans==0) ans=1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int MAX_V = 2000 + 10;\n\nint V;\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V];\n\nvoid add_edge(int v,int u){\n    G[v].push_back(u);\n    G[u].push_back(v);\n}\n\nbool dfs(int v){\n    if(v<0) return true;\n\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        int w = match[u];\n\n        if(!used[w]&&dfs(w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret = 0;\n    memset(match,-1,sizeof(match));\n\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            memset(used,-1,sizeof(used));\n            if(dfs(v)) ret++;\n        }\n    }\n    return ret;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    int d[100][100] = {};\n    REP(i, N) REP(j, N) d[i][j] = (i != j ? INF : 0);\n    REP(i, M){\n      int u, v, c;\n      scanf(\"%d %d %d\", &u, &v, &c);\n      d[u][v] = d[v][u] = c;\n    }\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int p[1000], t[1000];\n    REP(i, L){\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n    V = 2 * L;\n    REP(i, V) G[i].clear();\n    REP(i, L) FOR(j, i + 1, L) if(t[i] > t[j]) { swap(t[i], t[j]); swap(p[i], p[j]); }\n    REP(i, L) FOR(j, i + 1, L){\n      if(d[p[i]][p[j]] <= t[j] - t[i]) add_edge(i, L + j);\n    }\n    cout << L - bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nconst int inf = 1<<29;\n\nstruct Edge {\n  int src,dst;\n  int weight;\n  Edge(int src, int dst, int weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint dist[101][101];\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  for(Edges::const_iterator e = g[u].begin(); e != g[u].end(); ++e)\n    if (!visited[e->dst]) {\n      visited[e->dst] = true;\n      if (augment(g, matchTo[e->dst], matchTo, visited)) {\n\tmatchTo[e->src] = e->dst;\n\tmatchTo[e->dst] = e->src;\n\treturn true;\n      }\n    }\n  return false;\n}\n\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  for(int u=0; u<L; ++u) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  for(int u=0; u<L; ++u)\n    if (matchTo[u] >= 0) // make explicit matching\n        matching.push_back( Edge(u, matchTo[u], 1) );\n  return match;\n}\n\nint main() {\n    int N,M,L,u,v,d,p,t;\n    while(scanf(\"%d %d %d\", &N, &M, &L), N|M|L) {\n        REP(i, 100) {\n            REP(j, 100) dist[i][j] = inf;\n            dist[i][i] = 0;\n        }\n\n        REP(i,M) {\n            scanf(\"%d %d %d\", &u, &v, &d);\n            dist[u][v] = dist[v][u] = d;\n        }\n\n        REP(k, N) REP(i, N) REP(j, N)\n            dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\n        vector<pair<int,int> > reqs;\n        Graph g(L*2);\n        REP(i,L) {\n            scanf(\"%d %d\", &p, &t);\n            reqs.push_back(make_pair(p,t));\n        }\n\n        REP(i,L) {\n            REP(j,L) {\n                if(reqs[j].second <= reqs[i].second) continue;\n                if(reqs[j].second - reqs[i].second\n                   >= dist[reqs[i].first][reqs[j].first]) {\n                    g[i].push_back(Edge(i,j+L,1));\n                    // printf(\"add %d to %d\\n\", i, j);\n                }\n            }\n        }\n\n\n        Edges es;\n        printf(\"%d\\n\", L - bipartiteMatching(g,L,es));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint l = sc.nextInt();\n\n\t\tint[][] dist = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.fill(dist, 1 << 30);\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt(), v = sc.nextInt(), d = sc.nextInt();\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\n\t\tint[] p = new int[l];\n\t\tlong[] t = new long[l];\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tp[l] = sc.nextInt();\n\t\t\tt[l] = sc.nextLong();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Edge>[] g = new ArrayList[2 * n + 2];\n\t\tfor (int i = 0; i < 2 * n + 2; i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\tif (dist[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tg[p[i]].add(new Edge(p[i], n + p[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[2 * n - 1].add(new Edge(2 * n - 1, i, 1));\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i + n].add(new Edge(i + n, 2 * n, 1));\n\t\t}\n\n\t\tPreflow_Relabel pr = new Preflow_Relabel(2 * n - 1, 2 * n, g);\n\t\tSystem.out.println((n - pr.calc()));\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\ntypedef vector<vector<edge>> Graph;\nconstexpr int MAX_V = 2002;\n\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(Graph& G,int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(Graph &G,int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(Graph &G,int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(G,e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(Graph &G,int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(G,s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(G,s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tGraph g(2*l+2);\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(g,p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(g,0, i + 1, 1);\n\t\tREP(i, l)add_edge(g,i + l + 1, 2 * l + 1, 1);\n\t\tcout << l - max_flow(g,0, 2 * l + 1) << endl;\n\t\tREP(i, MAX_V) {\n\t\t\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 300;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[1001];\n        fill(used,used+1001,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            ct=node=0;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i=v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int maxTime=-1;\n                int idx=0;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i=v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=0){\n                        int nTime=ct-cost;\n                        if(ct-cost>time)\n                            nTime=time;\n                        if(maxTime<nTime){\n                            maxTime=nTime;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(maxTime==-1)\n                    break;\n                else{\n                    //  êÎAóÔðXV\n                    ct=maxTime;\n                    node=v[idx].second;\n                    used[idx]=true;\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define FORIT(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n    int src;\n    int dest;\n    int capacity;\n    Weight weight;\n    Edge() {;}\n    Edge(int src, int dest, int capacity, Weight weight) : src(src), dest(dest), capacity(capacity), weight(weight) {;}\n    bool operator<(const Edge &rhs) const {\n        return weight > rhs.weight;\n    }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n    REP(y, matrix.size()) {\n        REP(x, matrix[y].size()) {\n            printf(\"%d \", matrix[y][x]);\n        }\n        puts(\"\");\n    }\n}\n\n/*\nWeight augment(const Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n    if (from == t || cur == 0) { return cur; }\n    if (finished[from]) { return 0; }\n    FORIT(it, g[from]) {\n        int to = it->dest;\n        if (level[to] <= level[from]) { continue; }\n        Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n        if (f > 0) {\n            capacity[from][to] -= f;\n            capacity[to][from] += f;\n            return f;\n        }\n    }\n    finished[from] = true;\n    return 0;\n}\n\nWeight MaxFlow(const Graph &g, int s, int t) {\n    const int n = g.size();\n    Matrix capacity(n, Array(n));\n    REP(from, n) {\n        FORIT(it, g[from]) {\n            int to = it->dest;\n            capacity[from][to] += it->weight;\n        }\n    }\n    int ans = 0;\n    while (true) {\n        vector<int> level(n, -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        for (int d = n; !que.empty() && level[que.front()] < d; ) {\n            const int from = que.front();\n            que.pop();\n            if (from == t) { d = level[from]; }\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                if (capacity[from][to] > 0 && level[to] == -1) {\n                    que.push(to);\n                    level[to] = level[from] + 1;\n                }\n            }\n        }\n        vector<bool> finished(n);\n        bool end = true;\n        while (true) {\n            Weight f = augment(g, capacity, level, finished, s, t, 2000000000LL);\n            if (f == 0) { break; }\n            ans += f;\n            end = false;\n        }\n        if (end) { break; }\n    }\n    return ans;\n}\n*/\n\nint parent[2020];\nint nowDist[2020];\nint prevDist[2020];\n\nint MinCostFlow(const Graph &g, int s, int t, int l) {\n    const int n = g.size();\n    Matrix capacity(n, Array(n, 0));\n    Matrix cost(n, Array(n, 0));\n    REP(from, n) {\n        FORIT(it, g[from]) {\n            assert(it->capacity >= 0);\n            capacity[from][it->dest] += it->capacity;\n            cost[from][it->dest] += it->weight;\n        }\n    }\n\n    vector<int> parent(n);\n    vector<int> prev_dist(n, 0);\n    vector<int> now_dist(n);\n\n    // calc potential\n    REP(iter, n) {\n        bool end = true;\n        REP(from, n) {\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                if (capacity[from][to] == 0) { continue; }\n                int ncost = prev_dist[from] + cost[from][to];\n                if (ncost < prev_dist[to]) {\n                    end = false;\n                    prev_dist[to] = ncost;\n                }\n            }\n        }\n        if (end) { break; }\n    }\n\n    int ret = 0;\n    int c = 0;\n    while (true) {\n        ret++;\n        fill(parent.begin(), parent.end(), -1);\n        fill(now_dist.begin(), now_dist.end(), 2000000000LL);\n        priority_queue<Edge> que;\n        que.push(Edge(s, s, 0, 0));\n        now_dist[s] = 0;\n        while (!que.empty()) {\n            Edge node = que.top();\n            que.pop();\n            if (parent[node.dest] != -1) { continue; }\n            parent[node.dest] = node.src;\n            int from = node.dest;\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                int ncost = node.weight + cost[from][to] + (prev_dist[from] - prev_dist[to]);\n                if (capacity[from][to] == 0) { continue; }\n                if (ncost >= now_dist[to]) { continue; }\n                now_dist[to] = ncost;\n                que.push(Edge(from, to, 0, ncost));\n            }\n        }\n        if (parent[t] == -1) { assert(false); }\n        int from = parent[t];\n        int to = t;\n        while (from != to) {\n            c += cost[from][to];\n            capacity[from][to]--;\n            capacity[to][from]++;\n            from = parent[from];\n            to = parent[to];\n        }\n        REP(i, n) {\n            prev_dist[i] += now_dist[i];\n        }\n        if (c == -l) { return ret; }\n    }\n    assert(false);\n    return 0;\n}\n\nvoid addEdge(Graph &g, int from, int to, int cost) {\n    g[from].push_back(Edge(from, to, 1, cost));\n    g[to].push_back(Edge(to, from, 0, -cost));\n}\n\nint n, m, l;\ninline int IN(int x) { return 2 * x; }\ninline int OUT(int x) { return 2 * x + 1; }\ninline int SOURCE() { return 2 * l; }\ninline int DEST() { return 2 * l + 1; }\ninline int SIZE() { return 2 * l + 2; }\n\nll matrix[110][110];\nint point[1010];\nll ontime[1010];\nbool visit[2020];\n\nint main() {\n    FILE *fp = fopen(\"J.txt\", \"r\");\n    while (fscanf(fp, \"%d %d %d\", &n, &m, &l), n|m|l) {\n        MEMSET(matrix, 0x0f);\n        Graph g(2 * l + 2);\n        REP(i, m) {\n            int f, t, c;\n            fscanf(fp, \"%d %d %d\", &f, &t, &c);\n            matrix[f][t] = c;\n            matrix[t][f] = c;\n        }\n        REP(k, n) REP(i, n) REP(j, n) {\n            matrix[j][j] = 0;\n            matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n        }\n        REP(i, l) {\n            int p, t;\n            fscanf(fp, \"%d %d\", &p, &t);\n            point[i] = p;\n            ontime[i] = t;\n        }\n        REP(i, l) {\n            addEdge(g, SOURCE(), IN(i), 0);\n            addEdge(g, OUT(i), DEST(), 0);\n            addEdge(g, IN(i), OUT(i), -1);\n            REP(j, l) {\n              if (i == j) { continue; }\n                if (ontime[j] + matrix[point[j]][point[i]] <= ontime[i]) {\n                    addEdge(g, OUT(j), IN(i), 0);\n                }\n            }\n        }\n        printf(\"%d\\n\", MinCostFlow(g, SOURCE(), DEST(), l));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int,int>;\nusing P3 = pair<P, int>;\nusing ll = long long int;\nconstexpr int INF = 1<<28;\n\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<vector<edge> > G;\nvector<bool> used;\n\nvoid add_edge(int from, int to, int cap){\n    G[from].emplace_back((edge){to, cap, int(G[to].size())});\n    G[to].emplace_back((edge){from, 0, int(G[from].size())-1});\n}\n\n// 増加路の探索\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(auto &e : G[v]){\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    used.resize(G.size());\n    int flow = 0;\n    while(1){\n        fill(used.begin(), used.end(), false);\n        int f = dfs(s, t, INF);\n        if(f==0) break;\n        flow += f;\n    }\n    return flow;\n}\n\nint main() {\n    int N, M, L;\n    int dist[101][101];\n    P query[1001];\n    G.resize(2005);\n    while(cin >> N >> M >> L, N){\n        for(int i=0;i<N;i++) fill(dist[i], dist[i]+N, INF);\n        for(int i=0;i<M;i++){\n            int u, v, d;\n            cin >> u >> v >> d;\n            dist[u][v] = d;\n            dist[v][u] = d;\n        }\n        for(int i=0;i<N;i++){\n            dist[i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        for(int i=0;i<L;i++){\n            int p, t;\n            cin >> p >> t;\n            query[i] = P(t, p);\n        }\n        sort(query, query+L);\n        \n        int S = L*2, T = L*2+1;\n        for(int i=0;i<L*2+2;i++){\n            G[i].clear();\n        }\n        for(int i=0;i<L;i++){\n            add_edge(S, i, 1);\n            add_edge(i+L, T, 1);\n        }\n        for(int i=0;i<L;i++){\n            for(int j=i+1;j<L;j++){\n                int u = query[i].second, v = query[j].second;\n                if(dist[u][v] <= query[j].first-query[i].first){\n                    add_edge(i, j+L, 1);\n                }\n            }\n        }\n        cout << L - max_flow(S, T) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define MAX_V 1001\n#define INF 100000000\n\nvoid add_edge(int,int);\nbool dfs(int);\nint bipartite_matching(int);\nvoid warshall_floyd(int);\n\nusing namespace std;\n\nvector<int>G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V],d[MAX_V][MAX_V];\n\n\n\nint main(void){\n  int n,m,l,p[MAX_V],t[MAX_V];\n\n  while(scanf(\"%d %d %d\",&n,&m,&l),n,m,l){\n    for(int i=0;i<MAX_V*2;i++)G[i].clear();\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  d[i][j]= i==j ?0:INF;\n\n      for(int i=0;i<m;i++){\n\t  int a,b,c; \n\t  scanf(\"%d %d %d\",&a,&b,&c);\n\t  d[a][b]=d[b][a]=c;\n\t}\n      warshall_floyd(n);\n\n      for(int i=0;i<l;i++)\n\tscanf(\"%d %d\",&p[i],&t[i]);\n\n      for(int i=0;i<l;i++){\n\tfor(int j=0;j<l;j++){\n\t  if(i==j)continue;\n\t  else if(t[i]+d[p[i]][p[j]]<=t[j])\n\t    add_edge(i,j+l);\n\t}\n      }\n\n      cout << l-bipartite_matching(2*l) << endl;\n    }\n  return 0;\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i < G[v].size();i++){\n    int u= G[v][i],w=match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\n\nint bipartite_matching(int V){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nvoid warshall_floyd(int V){\n  for(int i = 0; i < V; i++){\n    for(int j = 0; j < V; j++){\n      for(int k = 0; k < V; k++){\n\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nstruct edge{\n  int to,rev,f;\n};\nvector<edge> G[1111];\nint Gh[1005][1005];\n\nbool used[1111];\nbool memo[1111];\n\nvoid init(){\n  memset(Gh,0,sizeof(Gh));\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( (edge){to,G[to].size(),1} );\n  G[to].push_back( (edge){from,G[from].size()-1,0} );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\nbool check(){\n  for(int i=0;i<L;i++) {\n    //cout <<i << \" : \" << used[i] << endl;\n    if( !used[i] ) return false;\n  }\n  return true;\n}\n\nbool dfs(int id){\n  if( memo[id] ) return false;\n  memo[id] = true;\n  for(int i=0;i<(int)G[id].size();i++){\n    edge &e= G[id][i];\n    //  cout << \"edge \" << id << \" -> \" << e.to << \" \" << e.f << endl;\n    if( e.f ) {\n      if( dfs(e.to) ){\n        e.f = 0;\n        G[e.to][e.rev].f = 1;\n        return used[id] = true;\n        break;\n      }\n    }\n  }\n  // cout << \"in dfs\" << id<< \": \" <<used[id] << endl;\n  if( !used[id] ) return used[id] = true;\n  return false;\n}\n\nint solve(){\n  for(int i=1;i<N;i++){\n    memset(memo,0,sizeof(memo));\n    dfs(L);\n    //cout<<i << endl;\n    if( check() ) return i;\n  }\n  return N;\n}\n\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n    for(int i=0;i<L;i++)\n      swap( pt[i].first, pt[i].second );    \n\n    for(int i=0;i<L;i++){\n      for(int j=0;j<L;j++){\n        if( i == j ) continue;\n        ll len = W[pt[i].first][pt[j].first];\n        ll lt = pt[j].second - pt[i].second;\n        if( len <= lt )          \n          add_edge( i, j );\n      }\n    }\n    for(int i=0;i<L;i++)\n      add_edge(L,i);\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n\n    used[L] = true;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint flow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tvector<int> dist((int)G.size(), INF);\n\t\tvector<int> prevV((int)G.size());\n\t\tvector<int> prevE((int)G.size());\n\t\tdist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < dist.size(); ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\treturn INF;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tm[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tm[u][v] = m[v][u] = d;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint s = 2*L+1, t = s+1;\n\t\tG.clear(); G.resize(t+1);\n\n\t\tvector<int> p(L), time(L);\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tcin >> p[i] >> time[i];\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tif (i != j && time[i] + m[p[i]][p[j]] <= time[j]) {\n\t\t\t\t\taddEdge(L+i, j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\taddEdge(s, i, 1, 0);\n\t\t\taddEdge(L+i, t, 1, 0);\n\t\t\taddEdge(i, L+i, 1, -1);\n\t\t}\n\n\t\tvector< vector<Edge> > g = G;\n\t\tint l = 0, r = L;\n\t\twhile (l < r-1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif ( flow(s, t, m) == -L ) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\tG = g;\n\t\t}\n\t\tcout << r << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M,L;\nconst int MAX_N = 100,MAX_L = 1000;\nint dist [MAX_N] [MAX_N];\nint P [MAX_L],T [MAX_L];\nbool edge [MAX_L] [MAX_L];\nint matching [MAX_L];\nbool vis [MAX_L];\nconst int INF = 1e9;\n\nbool dfs(int curr)\n{\n\tvis [curr] = true;\n\tFOR(i,0,L) if(edge [curr] [i]){\n\t\tint nxt = matching [i];\n\t\tif(nxt == -1 || (vis [nxt] == false && dfs(nxt))){\n\t\t\tmatching [i] = curr;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&N,&M,&L),N + M + L){\n\t\tfill(dist [0],dist [MAX_N],INF);\n\t\tmemset(edge,0,sizeof(edge));\n\t\tFOR(i,0,M){\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\t\tchmin(dist [u] [v],c);\n\t\t\tchmin(dist [v] [u],c);\n\t\t}\n\t\tFOR(i,0,L){\n\t\t\tscanf(\"%d%d\",&P [i],&T [i]);\n\t\t}\n\t\tFOR(i,0,N) dist [i] [i] = 0;\n\t\tFOR(k,0,N) FOR(i,0,N) FOR(j,0,N) chmin(dist [i] [j],dist [i] [k] + dist [k] [j]);\n\n\t\tFOR(i,0,L) FOR(j,0,L) if(j != i && T [i] <= T [j] && dist [P [i]] [P [j]] <= T [j] - T [i]){\n\t\t\tedge [i] [j] = true;\n\t\t}\n\n\t\tint ans = L;\n\t\tmemset(matching,-1,sizeof(matching));\n\t\tFOR(i,0,L){\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans -= dfs(i);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstruct EdgeC{\n  int to, cap, cost, rev;\n  EdgeC(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\nusing GraphC = vector<vector<EdgeC>>;\nconst int INF = 1e9;\n\nvoid add_edge(GraphC& G, int from, int to, int cap, int cost){\n  G[from].emplace_back(to, cap, cost, G[to].size());\n  G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n}\nint min_cost_flow(GraphC& G, int s, int t, int f){\n  int V = G.size();\n  vector<int> dist(V);\n  vector<int> prevv(V), preve(V);\n  int res = 0;\n  \n  while(f > 0){\n\tfill(begin(dist), end(dist), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(unsigned int i=0;i<G[v].size();++i){\n\t\t  auto& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tif(dist[t] == INF) return -INF;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  auto& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, L;\n  while(cin>>N>>M>>L,N){\n\tVVI dist(N, VI(N,1e9));\n\tREP(i,N) dist[i][i] = 0;\n\tREP(i,M){\n\t  int u, v, d;\n\t  cin >> u >> v >> d;\n\t  mini(dist[u][v], d);\n\t  mini(dist[v][u], d);\n\t}\n\tREP(k,N) REP(i,N) REP(j,N)\n\t  mini(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tvector<PII> qs(L);\n\tREP(i,L){\n\t  cin >> qs[i].SS >> qs[i].FF;\n\t}\n\tSORT(qs);\n\n\tint S = L+L, T = S+1;\n\tGraphC G(L+L+2);\n\tREP(i1,L) FOR(i2,i1+1,L){\n\t  if(qs[i1].FF + dist[qs[i1].SS][qs[i2].SS] <= qs[i2].FF){\n\t\tadd_edge(G, i1*2+1, i2*2, INF, 0);\n\t  }\n\t}\n\tREP(i,L){\n\t  add_edge(G, S, i*2, INF, 0);\n\t  add_edge(G, i*2+1, T, INF, 0);\n\t  add_edge(G, i*2, i*2+1, 1, -1);\n\t  add_edge(G, i*2, i*2+1, INF, 0);\n\t}\n\n\tint sum = 0;\n\tfor(int f=1;;++f){\n\t  sum += min_cost_flow(G, S, T, 1);\n\t  if(sum == -L){\n\t\tcout << f << endl;\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long  Int;\n\ntemplate <typename Weight, int MAX_N, Weight INF> class MaxFlow{\nprivate:\n\tstruct E{\n\t\tint to, rev;\n\t\tWeight lim;\n\t\tE(int x, Weight y, int z){\n\t\t\tto = x;\n\t\t\tlim = y;\n\t\t\trev = z;\n\t\t}\n\t};\n\n\tvector<E> edge[MAX_N];\n\tint lev[MAX_N];\n\tint iter[MAX_N];\n\n\n\tWeight dfs(int s, int g, Weight f){\n\t\tif(s == g)return f;\n\t\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\t\tE &e = edge[s][i];\n\t\t\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\t\tWeight tmp = dfs(e.to, g, min(f, e.lim));\n\t\t\tif(!tmp)continue;\n\t\t\te.lim -= tmp;\n\t\t\tedge[e.to][e.rev].lim += tmp;\n\t\t\treturn tmp;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid bfs(int x){\n\t\tqueue<int> q;\n\t\tq.push(x);\n\t\tint p = 0;\n\t\t\twhile(!q.empty()){\n\t\t\tfor(int i = q.size();i--;){\n\t\t\t\tint tmp = q.front();q.pop();\n\t\t\t\tif(lev[tmp] != INF)continue;\n\t\t\t\tlev[tmp] = p;\n\t\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == INF)q.push(edge[tmp][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n\npublic:\n\tvoid make_edge(int a, int b, Weight l){\n\t\tedge[a].push_back(E(b, l, edge[b].size()));\n\t\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n\t}\n\n\tWeight max_flow(int s, int g){\n\t\tWeight res = 0;\n\t\tbool fin = false;\n\t\twhile(!fin){\n\t\t\tfill(lev, lev + MAX_N, INF);\n\t\t\tfill(iter, iter + MAX_N, 0);\n\t\t\tbfs(s);\n\t\t\tfin = true;\n\t\t\twhile(true){\n\t\t\t\tWeight p = dfs(s, g, INF);\n\t\t\t\tif(p == 0)break;\n\t\t\t\tfin = false;\n\t\t\t\tres += p;\n\t\t\t}\n\t\t}\t\n\t\treturn res;\n\t}\n};\n\n\n#define INF (1 << 30)\n\nint dist[108][108];\nint p[1080], t[1080];\nint main(){\n\tint n, m, l, u, v, d;\n\twhile(cin >> n >> m >> l, n|m|l){\t\t\n\t\tMaxFlow<int, 2160, INF> mf;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\t\telse dist[i][j] = INF-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tfor(int j = 0;j < n;j++)\n\t\t\t\tfor(int k = 0;k < n;k++)\n\t\t\t\t\tdist[j][k] = min(dist[j][i] + dist[i][k], dist[j][k]);\n\t\tfor(int i = 0;i < l ;i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0;i < l;i++){\n\t\t\tmf.make_edge(l * 2, i, 1);\n\t\t\tmf.make_edge(i + l, l * 2+1, 1);\t\t\t\n\t\t\tfor(int j = 0;j < l;j++){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tmf.make_edge(i, j + l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << l - mf.max_flow(l * 2, l * 2 + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\nconst Weight EPS = 0; // ???????°???°?????????1e-14\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight; // ????°??????¨?????§???cost?????????\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n    Edge(int src, int dst, int cap, Weight cost): // ????°??????¨?????¨\n        src(src), dst(dst), cap(cap), weight(cost){ }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// ?????§?????¨????°??????¨????????????\n// ?????????????????§?????£????????????????????????????????????\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\n\n// ??????????????????\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); } \nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); } \n\n// ??????????????????????????????1??????\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\n// Floyd Warshall\n// O(V^3)\n// ??\\???\n// g: ??£??\\????????¨?¨??????????????????°??????????????????????????¨???????????°????????????????¨±?????????\n// ??????\n// dist: dist[i][j]???i??????j???????????????????????????????????????????????°?????????????????????????????¨??§????????? \n//\n// ??¢???????????????????????????????????¨?????????????????´??§????£??????????\nvoid shortestPathFW(const Matrix &g, Matrix &dist) {\n    ll n = g.size();\n    dist = g;\n    rep(k, n) rep(i, n) rep(j, n)\n        if (dist[i][j] > dist[i][k] + dist[k][j])\n            dist[i][j] = dist[i][k] + dist[k][j];\n}\n// O(V^2)\n// ???????????????m??¨?????????n??????????????¨\nvoid initFW(Matrix& m, ll n){\n    m = Matrix(n, Array(n, INF));\n    rep(i, n) m[i][i] = 0;\n}\n\n// ?????¨??????????????°\n// ??\\??????\n// g : ?????¨??°?????????0 ... L-1 ????????´?????????L ... g.size()-1 ????????´????????????????????????\n// L : ?????¨??°??????????????´??????????????°???\n// ?????????matching : ??????????????°?????¨????????????????????????\n//\n// ??¨??????g????????????????????? ??? ??? ??°?????????\n// O(V (V + E))\nbool augment(const Graph& g, int u,\n        vector<int>& matchTo, vector<bool>& visited) {\n    if (u < 0) return true;\n    FOR(e, g[u]) if (!visited[e->dst]) {\n        visited[e->dst] = true;\n        if (augment(g, matchTo[e->dst], matchTo, visited)) {\n            matchTo[e->src] = e->dst;\n            matchTo[e->dst] = e->src;\n            return true;\n        }\n    }\n    return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n    const int n = g.size();\n    vector<int> matchTo(n, -1);\n    int match = 0;\n    rep(u, L) {\n        vector<bool> visited(n);\n        if (augment(g, u, matchTo, visited)) ++match;\n    }\n    rep(u, L) if (matchTo[u] >= 0) // make explicit matching\n        matching.push_back( Edge(u, matchTo[u], 1) );\n    return match;\n}\n// ?????¨??????????????°?????\\?????°??????????????§??¢??°???????§????\n// bool f(i, j) : ??????i in [0, L)????????????j in [0, R)??¨?????????????????°1, ???????????°0\ntemplate<class Function>\nvoid constructBiparitate(Graph& g, int L, int R, Function f) {\n    g = Graph(L + R);\n    rep(l, L) rep(r, R) if (f(l, r)) addDirected(g, l, L + r);\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m, l;\n    while (cin >> n >> m >> l && n) {\n        Matrix dist;\n        Matrix g_fw;\n        initFW(g_fw, n);\n        rep(i, m) {\n            ll u, v, d; cin >> u >> v >> d;\n            g_fw[u][v] = g_fw[v][u] = d;\n        }\n        shortestPathFW(g_fw, dist);\n\n        vll p(l), t(l);\n        rep(i, l) {\n            cin >> p[i] >> t[i];\n        }\n\n        Graph g(2*l);\n        rep(i_, l) rep(j_, l) if (i_ != j_) {\n            int i = p[i_], j = p[j_];\n            if (dist[i][j] <= t[j] - t[i]) { // i -> j??????????????°\n                addDirected(g, i_, l+j_);\n            }\n        }\n//        vizGraph(g);\n        Edges matching;\n        int ret = bipartiteMatching(g, l, matching);\n        cout << l - ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nWeight INF=1e9;\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=false;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push(make_pair(Weight(0),s));\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push(make_pair(dist[e.to],e.to));\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\nint solve();\nint main(){\n    while(solve()){\n\n    }\n    return true;\n}\nint solve(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(n==0) return false;\n    vector<vector<int>> d(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        int dd;\n        cin>>dd;\n        d[u][v]=dd;\n        d[v][u]=dd;\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n    vector<int> p(l),t(l);\n    for(int i=0;i<l;i++) cin>>p[i]>>t[i];\n    vector<pair<int,int>> tp(l);\n    for(int i=0;i<l;i++) tp[i]={t[i],p[i]};\n    sort(tp.begin(),tp.end());\n    for(int i=0;i<l;i++){\n        t[i]=tp[i].first;\n        p[i]=tp[i].second;\n    }\n\n    Flow org(2*l+4);\n    //[0,l):in\n    int S=2*l;\n    int superS=2*l+1;\n    int T=2*l+2;\n    int superT=2*l+3;\n    \n    for(int i=0;i<l;i++){\n        org.addEdge(S,i,1,0);\n        org.addEdge(i+l,T,INF,0);\n        //org.addEdge(i,i+l,1,-1);\n        org.addEdge(i+l,i,1,1);\n        org.addEdge(superS,i+l,1,0);\n        org.addEdge(i,superT,1,0);\n    }\n\n    vector<vector<int>> town(l,vector<int>(n,0));\n    \n    for(int i=l-1;i>=0;--i){\n        for(int j=i+1;j<l;j++){\n            if(town[i][p[j]] || d[p[i]][p[j]]>t[j]-t[i]) continue;            \n            org.addEdge(i+l,j+l,INF,0);\n            org.addEdge(i+l,j,1,0);\n            for(int k=0;k<n;k++){\n                town[i][k]|=town[j][k];\n            }\n        }\n    }\n    int lb=0;\n    int ub=n;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        Flow flow=org;\n        flow.addEdge(superS,S,mid,0);\n        flow.addEdge(T,superT,mid,0);\n        int cost=flow.minCostFlow(superS,superT,mid+l);\n        cost-=l;\n        if(cost!=-l){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    cout<<ub<<endl;\n\n    return true;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <string.h>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge{ int to, cap, rev;};\nbool used[2002];\n\nint dfs(vector< vector <edge> > &G, int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(G, e.to, t, min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(vector< vector <edge> > &G, int s, int t){\n  int flow = 0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f = dfs(G, s, t, INF);\n    if(!f) return flow;\n    flow += f;\n  }\n}\n\nvoid add_edge(vector< vector <edge> > &G, int from, int to, int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L, N){\n    vector< vector<int> > D(N, vector<int>(N, INF));\n    for(int i = 0; i < M; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      D[u][v] = d;\n      D[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) D[i][i] = 0;\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n    vector< pair<int,int> > V;\n    for(int i = 0; i < L; ++i){\n      int p, t;\n      cin >> p >> t;\n      V.push_back(make_pair(t, p));\n    }\n    sort(V.begin(), V.end());\n    vector< vector<edge> > G(2*L + 2);\n    for(int i = 0; i < L; ++i){\n      for(int j = 0; j < i; ++j){\n        int p_i = V[i].second, t_i = V[i].first, p_j = V[j].second, t_j = V[j].first;\n        if(D[p_j][p_i] <= t_i - t_j) add_edge(G, j, L + i, 1);\n      }\n    }\n    for(int i = 0; i < L; ++i){\n      add_edge(G, 2*L, i, 1);\n      add_edge(G, L + i, 2*L+1, 1);\n    }\n    int ans = L - max_flow(G, 2*L, 2*L+1);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  int cost[100][100];\n  pair< int, int > tp[1000];\n\n  while(scanf(\"%d %d %d\", &N, &M, &L), L) {\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) cost[i][j] = INF;\n      cost[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      cost[u][v] = cost[v][u] = d;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &tp[i].second, &tp[i].first);\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n\n    sort(tp, tp + L);\n    Bipartite_Matching flow(L, L);\n    for(int i = 0; i < L; i++) {\n      for(int j = i + 1; j < L; j++) {\n        if(i == j) continue;\n        if(tp[j].first - tp[i].first >= cost[tp[i].second][tp[j].second]) {\n          flow.add_edge(i, j);\n        }\n      }\n    }\n    printf(\"%d\\n\", L - flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define min(a,b)    (((a) < (b)) ? (a) : (b))\n#define max(a,b)    (((a) > (b)) ? (a) : (b))\n#define abs(x)    ((x) < 0 ? -(x) : (x))\n#define INF 0x3f3f3f3f\n#define delta 0.85\n#define eps 1e-10\n#define PI 3.14159265358979323846\nusing namespace std;\n\n#define MAX_V 2000\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n#define MAX_N 100\n#define MAX_L 1000\nint N, M, L;\nint dp[MAX_N][MAX_N];\nint P[MAX_L], T[MAX_L];\n\nvoid clear_graph(){\n\tfor(int v = 0; v < V; v++) G[v].clear();\n}\n\nvoid floyd_warshall(){\n\tfor(int k = 0; k < N; k++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tfloyd_warshall();\n\tV = 2 * L;\n\tclear_graph();\n\t\n\tfor(int i = 0; i < L; i++){\n\t\tfor(int j = i + 1; j < L; j++){\n\t\t\tif(dp[P[i]][P[j]] <= abs(T[j] - T[i])){\n\t\t\t\tif(T[i] <= T[j]) add_edge(i, L + j);\n\t\t\t\telse add_edge(j, L + i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", L - bipartite_matching());\n}\n\nint main(){\n\twhile(~scanf(\"%d%d%d\", &N, &M, &L) && (N | M | L)){\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tfor(int i = 0; i < N; i++) dp[i][i] = 0;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tdp[u][v] = dp[v][u] = d;\n\t\t}\n\t\tfor(int i = 0; i < L; i++) scanf(\"%d%d\", P + i, T + i);\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nstruct BipartiteMatching {\n    vector<vector<int>> E; int n, m; vector<int> match, dist;\n    void init(int _n,int _m){n=_n,m=_m;E.resize(n+m+2);match.resize(n+m+2);dist.resize(n+m+2);}\n    bool bfs() {\n        queue<int> que;\n        rep(i, 1, n + 1) {\n            if (!match[i]) dist[i] = 0, que.push(i);\n            else dist[i] = inf;\n        }\n        dist[0] = inf;\n        while (!que.empty()) {\n            int u = que.front(); que.pop();\n            if (u) fore(v, E[u]) if (dist[match[v]] == inf) {\n                dist[match[v]] = dist[u] + 1;\n                que.push(match[v]);\n            }\n        }\n        return (dist[0] != inf);\n    }\n    bool dfs(int u) {\n        if (u) {\n            fore(v, E[u]) if (dist[match[v]] == dist[u] + 1) if (dfs(match[v])) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n            dist[u] = inf;\n            return false;\n        }\n        return true;\n    }\n    void add(int a, int b) { b += n; E[a + 1].push_back(b + 1); E[b + 1].push_back(a + 1); }\n    int whois(int x) { return match[x + 1] - 1; }\n    int solve() {\n        rep(i, 0, n + m + 1) match[i] = 0;\n        int res = 0;\n        while (bfs()) rep(i, 1, n + 1) if (!match[i] && dfs(i)) res++;\n        return res;\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M, L;\nint D[101][101];\nint P[1010], T[1010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N >> M >> L) {\n        if (N == 0) return;\n        rep(i, 0, N) rep(j, 0, N) D[i][j] = inf;\n        rep(i, 0, N) D[i][i] = 0;\n        rep(i, 0, M) {\n            int a, b, c; cin >> a >> b >> c;\n            D[a][b] = D[b][a] = c;\n        }\n        rep(k, 0, N) rep(i, 0, N) rep(j, 0, N) chmin(D[i][j], D[i][k] + D[k][j]);\n        rep(i, 0, L) {\n            cin >> P[i] >> T[i];\n        }\n\n        BipartiteMatching bm;\n        bm.init(L, L);\n        rep(i, 0, L) rep(j, 0, L) if (i != j) if (T[i] + D[P[i]][P[j]] <= T[j]) bm.add(i, j);\n\n        int ans = L - bm.solve();\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi g;\n\tpublic:\n\tvi match,used;\n\tbool BM_dfs(int v){\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tint u=g[v][i],w=match[u];\n\t\t\tif(w<0||!used[w]&&BM_dfs(w)){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint BM(){\n\t\tint res=0;\n\t\tmatch=vi(V,-1);\n\t\tfor(int i=0;i<V;i++) if(match[i]<0){\n\t\t\tused=vi(V);\n\t\t\tif(BM_dfs(i)) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tGraph(int v){\n\t\tV=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n};\n\nint n,m,l;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>l;\n\t\tif(!n) break;\n\t\tGraph g(2*l);\n\t\tvvi G(n,vi(n,inf));\n\t\tvp a(l);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint v,u,c;\n\t\t\tcin>>v>>u>>c;\n\t\t\tG[v][u]=G[u][v]=c;\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tint p,t;\n\t\t\tcin>>p>>t;\n\t\t\ta[i]={t,p};\n\t\t}\n\t\tfor(int i=0;i<n;i++) G[i][i]=0;\n\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\tfor(int i=0;i<l;i++) for(int j=0;j<l;j++){\n\t\t\tif(i!=j&&G[a[i].second][a[j].second]<=a[j].first-a[i].first) g.add_edge(i,l+j);\n\t\t}\n\t\tcout<<l-g.BM()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 3;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nclass BipartiteMatching\n{\n    int size;\n    std::vector<std::vector<int>> g;\n    std::vector<int> match;\n    std::vector<bool> used;\n    bool dfs(int v)\n    {\n        used[v] = true;\n        for (const auto &u : g[v])\n        {\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w)))\n            {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\npublic:\n    BipartiteMatching(int v) : size(v), g(v), match(v), used(v) {}\n    void add_edge(int u, int v)\n    {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int maximum_matching(void)\n    {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < size; ++v)\n        {\n            if (match[v] >= 0)\n                continue;\n            fill(begin(used), end(used), 0);\n            if (dfs(v))\n                ++res;\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, l;\n    while (cin >> n >> m >> l, n || m || l)\n    {\n        vector<vector<int>> dist(n, vector<int>(n, INF));\n        for (int i = 0; i < n; i++)\n            dist[i][i] = 0;\n        for (int i = 0; i < m; i++)\n        {\n            int u, v, d;\n            cin >> u >> v >> d;\n            dist[u][v] = dist[v][u] = d;\n        }\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);\n                }\n            }\n        }\n        // place, time;\n        vector<int> p(l), t(l);\n        for (int i = 0; i < l; i++)\n        {\n            cin >> p[i] >> t[i];\n        }\n        BipartiteMatching bm(2 * l);\n        for (int i = 0; i < l; i++)\n        {\n            for (int j = 0; j < l; j++)\n            {\n                if(i==j) continue;\n                // i を処理してから j を処理できるか\n                if (dist[p[i]][p[j]] <= t[j] - t[i])\n                {\n                    bm.add_edge(i, j + l);\n                }\n            }\n        }\n        //for(int i=0;i<n;i++)for(int j=0;j<n;j++) cout << i << \" \"<<j << \" \"<<dist[i][j]<<endl;\n        // cout << bm.maximum_matching() << endl;\n        cout << l - bm.maximum_matching() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int INF = 10000000;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Cost cost;\n    Edge *back;\n    Edge(int from, int to, Flow c, Cost d, Edge *b) : from(from), to(to), capacity(c), flow(0), cost(d), back(b) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid make_edge(vector<vector<Edge<Flow,Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    auto *e = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    auto *back = e->back = new Edge<Flow,Cost>(dst, src, 0, -d, e);\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> h(N), dist(N);\n    vector<Edge<Flow,Cost>*> parent(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        dist[src] = 0;\n        fill(parent.begin(), parent.end(), nullptr);\n        priority_queue<pair<Cost,int>> q;\n        q.push(make_pair(0, src));\n        while(!q.empty()) {\n            const int n = q.top().second;\n            const Cost c = -q.top().first;\n            q.pop();\n            if(dist[n] < c) {\n                continue;\n            }\n            for(auto e : g[n]) {\n                if(e->capacity - e->flow > 0) {\n                    const Cost c2 = c + e->cost + h[n] - h[e->to];\n                    if(c2 < dist[e->to]) {\n                        dist[e->to] = c2;\n                        parent[e->to] = e;\n                        q.push(make_pair(-c2, e->to));\n                    }\n                }\n            }\n        }\n        if(parent[sink] == nullptr) {\n            break;\n        }\n\n        Flow to_push = f;\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            to_push = min(to_push, e->capacity - e->flow);\n        }\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            res.second += to_push * e->cost;\n            e->flow += to_push;\n            e->back->flow -= to_push;\n        }\n        f -= to_push;\n        res.first += to_push;\n        for(int i = 0; i < N; ++i) {\n            h[i] += dist[i];\n        }\n    }\n    return res;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<LL>> dist(N, vector<LL>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] >= d) dist[i][j] = d;\n            }\n        }\n    }\n\n    vector<vector<Edge<int,int>*>> graph(L*2+2);\n    const int SRC = L*2;\n    const int SINK = SRC+1;\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const int in_node = i*2;\n        const int out_node = i*2+1;\n        make_edge(graph, SRC, in_node, 1, 0);\n        make_edge(graph, in_node, out_node, 1, 0);\n        make_edge(graph, out_node, SINK, INF, 0);\n        const int ni = queries[i].second;\n        for(int j = i+1; j < L; ++j) {\n            const int nj = queries[j].second;\n            if(dist[ni][nj] != -1 && queries[j].first - queries[i].first >= dist[ni][nj]) {\n                //cout << queries[i].second << ' ' << queries[j].second << endl;\n                make_edge(graph, out_node, j*2, 1, -1);\n            }\n        }\n    }\n    make_edge(graph, SRC, SINK, INF, 0);\n    const auto res = primal_dual(graph, SRC, SINK, L);\n    cout << L + res.second << endl;\n    for(auto &row : graph) {\n        for(auto e : row) {\n            delete e;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define FORIT(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int index;\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int index, int src, int dest, Weight weight) : index(index), src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nWeight augment(const Graph &g, Array &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] != level[from] + 1) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[it->index]));\n    if (f > 0) {\n      capacity[it->index] -= f;\n      capacity[it->index^1] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\n// index^1 is reverse edge\nWeight MaxFlow(const Graph &g, int e, int s, int t) {\n  int n = g.size();\n  Array capacity(e);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      capacity[it->index] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[it->index] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 2000000000LL);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\n\nvoid addEdge(int &e, Graph &g, int from, int to) {\n    g[from].push_back(Edge(e++, from, to, 1));\n    g[to].push_back(Edge(e++, to, from, 0));\n}\n\nint n, m, l;\ninline int IN(int x) { return 2 * x; }\ninline int OUT(int x) { return 2 * x + 1; }\ninline int SOURCE() { return 2 * l; }\ninline int DEST() { return 2 * l + 1; }\ninline int SIZE() { return 2 * l + 2; }\n\nll matrix[110][110];\nint point[1010];\nll ontime[1010];\nbool visit[2020];\n\nint main() {\n    while (scanf(\"%d %d %d\", &n, &m, &l), n|m|l) {\n      int e = 0;\n        MEMSET(matrix, 0x0f);\n        Graph g(2 * l + 2);\n        REP(i, m) {\n            int f, t, c;\n            scanf(\"%d %d %d\", &f, &t, &c);\n            matrix[f][t] = min(matrix[f][t], (ll)c);\n            matrix[t][f] = min(matrix[t][f], (ll)c);\n        }\n        REP(k, n) REP(i, n) REP(j, n) {\n            matrix[j][j] = 0;\n            matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n        }\n        REP(i, l) {\n            int p, t;\n            scanf(\"%d %d\", &p, &t);\n            point[i] = p;\n            ontime[i] = t;\n        }\n        REP(i, l) {\n            addEdge(e, g, SOURCE(), IN(i));\n            addEdge(e, g, OUT(i), DEST());\n            REP(j, l) {\n              if(i == j) { continue; }\n                if (ontime[j] + matrix[point[j]][point[i]] <= ontime[i]) {\n                    addEdge(e, g, IN(i), OUT(j));\n                }\n            }\n        }\n        printf(\"%d\\n\", l - MaxFlow(g, e, SOURCE(), DEST()));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#define INF 1<<29\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[2005];\nbool used[2005];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge& e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,false,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint n,m,l;\nint dist[101][101];\nint p[1001],t[1001];\n\nvoid solve(){\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint S=l*2,T=S+1;\n\tfor(int i=0;i<=T;i++){\n\t\tG[i].clear();\n\t}\n\tfor(int i=0;i<l;i++){\n\t\tadd_edge(S,i,1);\n\t\tadd_edge(l+i,T,1);\n\t\tfor(int j=0;j<l;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(dist[p[i]][p[j]]<=t[j]-t[i]){\n\t\t\t\tadd_edge(i,l+j,1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",l-max_flow(S,T));\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n+m+l==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tdist[a][b]=c;\n\t\t\tdist[b][a]=c;\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tscanf(\"%d%d\",&p[i],&t[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nint flow[2005][2005], capa[2005][2005],L,v[2020];\nbool DAG[1005][1005];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int u, int v, int w)\n{\n\tflow[v][u]+=w;\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\tnode[u].to.push_back(v);\n\tnode[v].to.push_back(u);\n}\n\nbool dfs(vector<Node>& node, int p)\n{\n\tif(p==SINK) return true;\n\tfor(int i=0; i<node[p].to.size(); i++)\n\t{\n\t\tint next=node[p].to[i];\n\n\t\tif(v[next]>=0) continue;\n\t\tif(flow[p][next]<0) continue;\n\t\tif(flow[p][next]==capa[p][next]) continue;\n\t\t\n\t\t\n\t\tv[next]=p;\n\t\tif(dfs(node,next)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(cin >> N >> M >> L, (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tcin >> u >> v >> c;\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tcin >> s[i] >> t[i];\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(capa, 0, sizeof(capa));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\tfor(int j=0; j<L; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t{\n\t\t\t\tDAG[i][j]=1;\n\t\t\t\tbeg[j]=1;\n\t\t\t\tend[i]=1;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]) \n\t\t\t{\n\t\t\t\tConnect(node, SOUR, i, INF);\n\t\t\t}\n\t\t\tif(!end[i]) \n\t\t\t{\n\t\t\t\tConnect(node, L+i, SINK, INF);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]&&!end[i])\n\t\t\t{\n\t\t\t\tConnect(node, i, L+i, 1);\n\t\t\t}\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(DAG[i][j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j,1);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint total=0;\n\t\twhile(1)\n\t\t{\n\n\t\t\tfor(int i=0; i<=SINK; i++)\n\t\t\t\tv[i]=-1;\n\t\t\t\t\n\t\t\tv[SOUR]=SOUR;\n\t\t\t\n\t\t\tif(dfs(node, SOUR))\n\t\t\t{\n\t\t\t\ttotal++;\n\t\n\t\t\t\tfor(int j=SINK; v[j]!=j; j=v[j])\n\t\t\t\t{\n\t\t\t\t\tflow[v[j]][j]++;\n\t\t\t\t\tflow[j][v[j]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\tcout << total << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nstruct request{int num, time;}re[2009];\nvector<int> g[2009];\nint match[2009];\nbool used[2009];\nint n, m, l;\nint INF=999999999;\nint d[2009][2009];\nvoid add_edge(int u, int v)\n{\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0; i<g[v].size(); i++)\n    {\n        int u=g[v][i], w=match[u];\n        if(w<0 || !used[w] && dfs(w))\n        {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\nint bipartite_matching()\n{\n    int res=0;\n    memset(match, -1, sizeof(match));\n    for(int v=0; v<n; v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used, 0, sizeof(used));\n            if(dfs(v))\n                res++;\n        }\n    }\n    return res;\n}\nvoid Floyd()\n{\n    for(int k=0; k<n; k++)\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                d[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n}\nint main()\n{\n    printf(\"%d\", INF);\n    int f, t, dis;\n    while(~scanf(\"%d%d%d\", &n, &m, &l))\n    {\n        if(!(n+m+l)) break;\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                d[i][j]=INF;\n        for(int i=0; i<n; i++)\n            g[i].clear();\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%d\", &f, &t, &dis);\n            d[f][t]=dis;\n            d[t][f]=dis;\n        }\n        for(int i=0; i<n; i++)\n        {\n            d[i][i]=0;\n        }\n        Floyd();\n        for(int i=0; i<l; i++)\n        {\n            scanf(\"%d%d\", &re[i].num, &re[i].time);\n        }\n        for(int i=0; i<l; i++)\n        {\n            for(int j=0; j<l; j++)\n            {\n                if(i==j) continue;\n                if(d[re[i].num][re[j].num]<=re[j].time-re[i].time)\n                {\n                    add_edge(i, j+n);\n                }\n            }\n        }\n        printf(\"%d\\n\", l-bipartite_matching());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2010\n#define MAX_N 1010\nusing namespace std;\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n  return max_flow(s,t);\n}\n\n\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    \n  memset(can,0,sizeof(can));\n  for(int i=0;i<l;i++)\n    for(int j=0;j<l;j++)\n      if(i!=j&&tl[i]+g[idx[i]][idx[j]]<=tl[j])can[i][j]=1;\n  cout <<l-Biparite_Matching(l,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nclass BipartiteMatching\n{\nprivate:\n  int MAX_V;\n  vector<int>* G;\n  int* match;\n  int* used;\n\n  bool dfs(int v)\n  {\n    used[v] = true;\n    rep(i, G[v].size()){\n      int u = G[v][i], w = match[u];\n      if(w < 0 || !used[w] && dfs(w)){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  BipartiteMatching(int MAX_V) : MAX_V(MAX_V)\n  {\n    G = new vector<int>[MAX_V];\n    match = new int[MAX_V];\n    used = new int[MAX_V];\n  }\n\n  void addEdge(int u, int v)\n  {\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n\n  int matching()\n  {\n    int res = 0;\n    rep(i, MAX_V) match[i] = -1;\n    rep(v, MAX_V){\n      if(match[v] < 0){\n        rep(i, MAX_V) used[i] = 0;\n        if(dfs(v)) res += 1;\n      }\n    }\n    return res;\n  }\n};\n\nint N, M, L;\nint u, v, dd;\nint d[111][111];\nint p[1111];\nint t[1111];\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> M >> L, N){\n    BipartiteMatching bm = BipartiteMatching(2 * N);\n    rep(i, N) rep(j, N) d[i][j] = INF;\n    rep(i, N) d[i][i] = 0;\n    rep(i, M){\n      cin >> u >> v >> dd;\n      d[u][v] = dd;\n      d[v][u] = dd;\n    }\n    rep(k, N) rep(i, N) rep(j, N) minup(d[i][j], d[i][k] + d[k][j]);\n    rep(i, L) cin >> p[i] >> t[i];\n    rep(i, L) rep(j, L) if(i != j && t[p[i]] + d[p[i]][p[j]] <= t[p[j]]) bm.addEdge(p[i], p[j]);\n    cout << N - bm.matching() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Edge(int src, int dst) :\n    src(src), dst(dst) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\nint adj[100][100];\nint p[1000],t[1000];\n\nint main() {\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l) {\n    REP(i,n)REP(j,n)adj[i][j]=INF;\n    REP(i,m) {\n      int u,v,d;\n      cin>>u>>v>>d;\n      adj[u][v] = min(adj[u][v],d);\n      adj[v][u] = adj[u][v];\n    }\n    REP(k,n)REP(i,n)REP(j,n)adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);\n    Graph g(2*l);\n    REP(i,l) {\n      cin>>p[i]>>t[i];\n    }\n    REP(i,l) {\n      REP(j,l) {\n        if (i==j) continue;\n        if (adj[p[i]][p[j]] <= t[j]-t[i]) {\n          g[i].push_back(Edge(i,l+j));\n        }\n      }\n    }\n    Edges e;\n    cout << l - bipartiteMatching(g, l, e) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\nint d[100][100];\nstruct edge{ int to,cap,cost,rev;};\nvector<int> G[2010];\nbool used[2010];\nint match[2010];\nint V;//Vは頂点数\n\nvoid add_edge(int u,int v){\nG[u].push_back(v);\nG[v].push_back(u);\n}\n\nbool ddffss(int v){\nused[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] &&ddffss(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(ddffss(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\nint p[1000],t[1000];\nvoid solve(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tif(n==0 && m==0 && l==0) exit(0);\n\t\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\td[i][j]=inf;\n\t\td[i][i]=0;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy,yyy;\n\t\tcin>>y>>yy>>yyy;\n\t\td[y][yy]=yyy;\n\t\td[yy][y]=yyy;\n\t}\n\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n\tV=2*l;\n\tfor(int i=0;i<V;i++){\n\t\tused[i]=0;\n\t\tmatch[i]=0;\n\t\tG[i].clear();\n\t}\n\t\n\tfor(int i=0;i<l;i++)cin>>p[i]>>t[i];\n\tfor(int i=0;i<l;i++)for(int j=0;j<l;j++)if(i!=j)if(t[i]<t[j]){\n\t\tif(d[p[i]][p[j]]<=t[j]-t[i])add_edge(i,l+j);\n\t}\n\tint ans=l-bi_match();\n\tcout<<ans<<endl;\n}\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\n  \twhile(1)solve();\n  \treturn 0;\n    }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1e9;\n\nvector<vector<int> > shortest_path(vector<vector<int> > &g)\n{\n\tvector<vector<int> > dist;\n\tconst int n = g.size();\n\n\tdist = g;\n\n\tfor(int k = 0; k < n; ++k) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nstruct graph {\n\n\tstruct edge { int to, from, cap, rev; };\n\n\tvector<vector<edge> > g;\n\n\tvoid init(int n)\n\t{\n\t\tg.resize(n);\n\t}\n\n\tvoid add_edge(int from, int to, int cap)\n\t{\n\t\tg[from].push_back((edge){to, from, cap, g[to].size()});\n\t\tg[to].push_back((edge){from, to, 0, g[from].size() - 1});\n\t}\n\n\tint inner_max_flow(int v, int t, int f)\n\t{\n\t\tif(v == t)\n\t\t\treturn f;\n\t\t//printf(\"debug: %d -> %d\\n\", v, t);\n\n\t\tfor(int i = 0; i < g[v].size(); ++i) {\n\n\t\t\tedge &e = g[v][i];\n\t\t\tedge &re = g[e.to][e.rev];\n\n\t\t\tif(e.cap == 0)\n\t\t\t\tcontinue;\n\t\t\tint nf = min(f, e.cap), mem = e.cap;\n\t\t\te.cap = 0;\n\t\t\tint temp = inner_max_flow(e.to, t, nf);\n\t\t\te.cap = mem;\n\t\t\tif(temp == 0)\n\t\t\t\tcontinue;\n\t\t\te.cap -= temp;\n\t\t\tre.cap += temp;\n\n\t\t\t//printf(\"%d %d %d -> %d\\n\", v, t, f, temp);\n\t\t\treturn temp;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint max_flow(int s, int t)\n\t{\n\t\tint f = 0;\n\t\twhile(true) {\n\t\t\tint temp = inner_max_flow(s, t, inf);\n\t\t\tf += temp;\n\t\t\tif(temp == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn f;\n\t}\n};\n\nint main()\n{\n\twhile(true) {\n\n\t\tint n, m, l;\n\t\tvector<pair<int, int> > pt;\n\t\tvector<vector<int> > dist, g;\n\t\tgraph bg;\n\n\t\tscanf(\"%d%d%d\", &n, &m, &l);\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tg.resize(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tg[i].resize(n, inf);\n\t\t\tg[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\tpt.resize(l);\n\t\tfor(int i = 0; i < l; ++i)\n\t\t\tscanf(\"%d%d\", &pt[i].first, &pt[i].second);\n\n\t\tdist = shortest_path(g);\n\n\t\tbg.init(l * 2 + 2);\n\t\tconst int bg_s = l * 2, bg_t = l * 2 + 1;\n\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\tbg.add_edge(bg_s, i * 2, 1);\n\t\t\tbg.add_edge(i * 2 + 1, bg_t, 1);\n\t\t}\n\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\tfor(int j = 0; j < l; ++j) {\n\n\t\t\t\tif(i == j)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint u = pt[i].first;\n\t\t\t\tint v = pt[j].first;\n\t\t\t\tint dt = pt[j].second - pt[i].second;\n\n\t\t\t\tif(dist[u][v] <= dt)\n\t\t\t\t\tbg.add_edge(i * 2, j * 2 + 1, 1);\n\t\t\t}\n\t\t}\n\n\t\tint ans = l - bg.max_flow(bg_s, bg_t);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int maxn = 105;\nconst int maxm = 1005;\nconst int inf = 0x7fffffff;\n\nstruct Query\n{\n\tint v, time;\n\tbool operator < (const Query p) const\n\t{\n\t\treturn time < p.time;\n\t}\n\tvoid input()\n\t{\n\t\tscanf(\"%d %d\", &v, &time);\n\t}\n};\n\nstruct Match\n{\n\tbool vis[maxn];\n\tint net[maxn], match[maxn], size, n;\n\tstruct EDGE\n\t{\n\t\tint v, next;\n\t\tEDGE(){}\n\t\tEDGE(int a, int b): v(a), next(b){}\n\t}E[maxm<<4];\n\tvoid init(int _n)\n\t{\n\t\tn = _n, size = 0;\n\t\tmemset(net, -1, sizeof(net));\n\t}\n\tvoid add_edge(int u, int v)\n\t{\n\t\tE[size] = EDGE(v, net[u]);\n\t\tnet[u] = size++;\n\t}\n\tint dfs(int u)\n\t{\n\t\tint v;\n\t\tfor(int i = net[u]; v = E[i].v, i != -1; i = E[i].next)\n\t\t\tif(!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = true;\n\t\t\t\tif(match[v] == -1 || dfs(match[v]))\n\t\t\t\t{\n\t\t\t\t\tmatch[v] = u;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\treturn 0;\n\t}\n\tint hungary()\n\t{\n\t\tint ans = 0;\n\t\tmemset(match, -1, sizeof(match));\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmemset(vis, false, sizeof(vis));\n\t\t\tans += dfs(i);\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nMatch G;\nQuery query[maxm];\nint map[maxn][maxn], n;\n\nvoid floyd()\n{\n\tfor(int k = 0; k < n; k++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(map[i][k] == inf)\n\t\t\t\tcontinue;\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif(map[k][j] == inf)\n\t\t\t\t\tcontinue;\n\t\t\t\tmap[i][j] = std::min(map[i][j], map[i][k]+map[k][j]);\n\t\t\t}\n\t\t}\n}\n\nint main()\n{\n\tint m, l, a, b, c;\n\t\n\twhile(scanf(\"%d %d %d\", &n, &m, &l) == 3)\n\t{\n\t\tif(!n && !m && !l)\n\t\t\tbreak;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tmap[i][j] = (i==j) ? 0 : inf;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tif(a != b)\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t}\n\t\tfloyd();\n\t\tfor(int i = 0; i < l; i++)\n\t\t\tquery[i].input();\n\t\tstd::sort(query, query+l);\n\t\tG.init(l);\n\t\tfor(int i = 0; i < l; i++)\n\t\t\tfor(int j = i+1; j < l; j++)\n\t\t\t\tif(map[query[i].v][query[j].v] <= query[j].time-query[i].time)\n\t\t\t\t\tG.add_edge(i, j);\n\t\tprintf(\"%d\\n\", l - G.hungary());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> PII;\n\nconst int MAX=2000;\nconst int INF=1<<28;\n\nint V;//number of vertex\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n\treturn;\n}\n\nbool dfs(int v)\n{\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++)\n\t{\n\t\tif(match[v]<0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint dp[100][100];\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n)\n\t{\n\t\tV=2*l;\n\t\trep(i,V)G[i].clear();\n\t\trep(i,n)rep(j,n)dp[i][j]=INF;\n\t\trep(i,n)dp[i][i]=0;\n\t\tint u,v,d;\n\t\trep(i,m)\n\t\t{\n\t\t\tcin>>u>>v>>d;\n\t\t\tdp[u][v]=d;\n\t\t\tdp[v][u]=d;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tPII p[1000];\n\t\trep(i,l)cin>>p[i].second>>p[i].first;\n\t\tsort(p,p+l);\n\t\trep(i,l)\n\t\t{\n\t\t\tint t=p[i].first;\n\t\t\tint to=p[i].second;\n\t\t\t\n\t\t\tfor(int j=i+1;j<l;j++)\n\t\t\t{\n\t\t\t\tif(p[j].first>=t+dp[to][p[j].second])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(i,l+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<l-bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,cost,rev;\n};\n\nconst int INF=1<<29;\nint N,L;\nint NV;\nvector<vector<edge> > G;\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back({to,cap,cost,(int)G[to].size()});\n  G[to].push_back({from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t){\n  int nc=0;\n  for(int c=1;;c++){\n    int dist[2002];\n    fill(begin(dist),end(dist),INF);\n    dist[0]=0;\n    int prevv[2002],preve[2002];\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<NV;v++){\n\tif(dist[v]==INF)continue;\n\tfor(int i=0;i<G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t    dist[e.to]=dist[v]+e.cost;\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    update=true;\n\t  }\n\t}\n      }\n    }\n    nc-=dist[t];\n    if(nc==L)return c;\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap--;\n      G[v][e.rev].cap++;\n    }\n  }\n}\n\nint main(){\n  for(int M;cin>>N>>M>>L,N;){\n    NV=2*L+2;\n    int d[100][100];\n    fill(d[0],d[100],INF);\n    for(int i=0;i<N;i++){\n      d[i][i]=0;\n    }\n    while(M--){\n      int u,v,di;\n      cin>>u>>v>>di;\n      d[u][v]=d[v][u]=min(d[u][v],di);\n    }\n    for(int k=0;k<N;k++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<N;j++){\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    G=vector<vector<edge> >(NV);\n    vector<pair<int,int> > pt;\n    for(int i=0;i<L;i++){\n      int p,t;\n      cin>>p>>t;\n      pt.emplace_back(t,p);\n    }\n    sort(begin(pt),end(pt));\n    for(int i=0;i<pt.size();i++){\n      add_edge(0,2*i+2,1,0);\n      add_edge(2*i+2,2*i+3,1,-1);\n      add_edge(2*i+3,1,1,0);\n      for(int j=0;j<i;j++){\n\tif(pt[j].first+d[pt[j].second][pt[i].second]<=pt[i].first){\n\t  add_edge(2*j+3,2*i+2,1,0);\n\t}\n      }\n    }\n    cout<<min_cost_flow(0,1)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\n#define INF 100000000\n\nusing namespace std;\n\nint V,match[202];\nbool used[202];\nvector<int>G[202];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main(void){\n\n  int n,m,l,u,v,d,graph[101][101],p[1001],t[1001];\n\n  while(cin >> n >> m >> l,n|m|l){  \n\n    for(int i=0;i<2*n;i++)G[i].clear();\n\n    fill(graph[0],graph[101],INF);\n    for(int i=0;i<101;i++)graph[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      graph[u][v]=graph[v][u]=d;\n    }\n    \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[p[i]][p[j]]+t[i]<=t[j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 8;\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        const int from;\n        const int to;\n        const T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge(to, from, cost));\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\nvoid WarshallFloyd(const CostGraph& g, vector<vector<CostGraph::T>>& d)\n{\n    using T = CostGraph::T;\n    assert(d.size() == g.V);\n    for (int i = 0; i < g.V; i++) {\n        assert(d[i].size() == g.V);\n        for (int j = 0; j < g.V; j++) {\n            if (i == j) {\n                d[i][j] = 0;\n            } else {\n                d[i][j] = INF<T>;\n            }\n        }\n        for (const auto& e : g.edge[i]) {\n            d[i][e.to] = min(e.cost, d[i][e.to]);  // For doubled-link\n        }\n    }\n    for (int k = 0; k < g.V; k++) {\n        for (int i = 0; i < g.V; i++) {\n            for (int j = 0; j < g.V; j++) {\n                if (d[i][j] > d[i][k] + d[k][j] and d[i][k] < INF<T> and d[k][j] < INF<T>) {\n                    d[i][j] = d[i][k] + d[k][j];\n                }\n            }\n        }\n    }\n}\n\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, bool is_reverse = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, is_reverse(is_reverse) {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        bool is_reverse;\n    };\n\n    Flow(const int v) : V{v}\n    {\n        edge.resize(v);\n    }\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, 0, true});\n    }\n\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) {\n                checked[i] = false;\n            }\n            const T f = dfs_ff(s, t, INF<T>, checked);\n            if (f == 0) {\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    T Dinic(const int s, const int t)\n    {\n        T flow = 0;\n        while (true) {\n            vector<int> level(V, -1);\n            queue<int> q;\n            q.push(s);\n            level[s] = 0;\n            while (not q.empty()) {\n                const int v = q.front();\n                for (const auto& e : edge[s]) {\n                    if (e.capacity > e.flow and level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        q.push(e.to);\n                    }\n                }\n            }\n            while (true) {\n                const T f = dfs_dinic(s, t, INF<T>, level);\n                if (f == 0) {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    const int V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    T dfs_ff(const int pos, const int t, const T flow, vector<bool>& checked)\n    {\n        if (pos == t) {\n            return flow;\n        }\n        checked[pos] = true;\n        for (auto& e : edge[pos]) {\n            if (not checked[e.to]) {\n                const T res = e.capacity - e.flow;\n                if (res > 0) {\n                    const T d = dfs_ff(e.to, t, min(flow, res), checked);\n                    if (d > 0) {\n                        e.flow += min(d, res);\n                        edge[e.to][e.reverse].flow -= min(d, res);\n                        return d;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_dinic(const int pos, const int t, const T flow, const vector<int>& level)\n    {\n        if (pos == t) {\n            return flow;\n        }\n        for (auto& e : edge[pos]) {\n            const T res = e.capacity - e.flow;\n            if (res > 0 and level[pos] < level[e.to]) {\n                const T d = dfs_dinic(e.to, t, min(flow, res), level);\n                if (d > 0) {\n                    e.flow += min(d, res);\n                    edge[e.to][e.reverse].flow -= min(d, res);\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nint main()\n{\n    while (true) {\n        int N, M, L;\n        cin >> N >> M >> L;\n        if (N == 0 and M == 0 and L == 0) {\n            break;\n        }\n        CostGraph g(N);\n        for (int i = 0; i < M; i++) {\n            int u, v;\n            ll d;\n            cin >> u >> v >> d;\n            g.addEdge(u, v, d);\n            g.addEdge(v, u, d);\n        }\n        vector<vector<ll>> d(N, vector<ll>(N, INF<ll>));\n        WarshallFloyd(g, d);\n        using P = pair<int, ll>;\n        vector<P> req(L);\n        for (int i = 0; i < L; i++) {\n            int p;\n            ll t;\n            cin >> p >> t;\n            req[i] = {p, t};\n        }\n\n        Flow flow(2 * L + 2);\n        const int S = 2 * L;\n        const int T = 2 * L + 1;\n        for (int i = 0; i < L; i++) {\n            flow.addEdge(S, i, 1);\n            flow.addEdge(i + L, T, 1);\n            for (int j = 0; j < L; j++) {\n                if (i == j) {\n                    continue;\n                }\n                const int p1 = req[i].first;\n                const ll t1 = req[i].second;\n                const int p2 = req[j].first;\n                const ll t2 = req[j].second;\n                if (t1 < t2) {\n                    if (d[p1][p2] <= t2 - t1) {\n                        flow.addEdge(i, j + L, 1);\n                    }\n                }\n            }\n        }\n        cout << L - flow.FordFulkerson(S, T) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * Dinic?????????????????§???\n *\n * ?????¨???????????¬????????????\n * template?????°???int V???????????°\n */\nconst int INF = 1<<28;\ntemplate<int V>\nstruct MaxFlow {\n    typedef int T;\n    struct Edge {\n        int to, rev;\n        T cap;\n    };\n    vector<Edge> g[V];\n    int level[V];\n    int iter[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    void add_multi(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    void bfs(int s) {\n        fill_n(level, V, -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (Edge e: g[v]) {\n                if (e.cap <= 0) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap <= 0) continue;\n            if (level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d <= 0) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // s??????t???????????§????????????\n    T exec(int s, int t) {\n        T flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill_n(iter, V, 0);\n            T f;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\ntypedef pair<int, int> P;\nconst int MN = 110;\nconst int ML = 1100;\nMaxFlow<ML*2> mf;\n\nint dist[MN][MN];\nP qu[ML];\nbool solve() {\n    mf.init();\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (!n) return false;\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = 1e8;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j],\n                    dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n\n    for (int i = 0; i < l; i++) {\n        int p, t;\n        cin >> p >> t;\n        qu[i] = P(t, p);\n    }\n    sort(qu, qu+l);\n\n    int vs = 2*ML-1;\n    int vt = 2*ML-2;\n    for (int i = 0; i < l; i++) {\n        for (int j = i+1; j < l; j++) {\n            int ap, at, bp, bt;\n            tie(at, ap) = qu[i];\n            tie(bt, bp) = qu[j];\n            if (dist[ap][bp] <= bt - at) {\n                mf.add(i, j+ML, 1);\n            }\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        mf.add(vs, i, 1);\n        mf.add(i+ML, vt, 1);\n    }\n    cout << l - mf.exec(vs, vt) << endl;\n    return true;\n}\n\nint main() {\n    while (true) {\n        if (!solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 5000\nusing namespace std;\ntypedef pair<int,int> ii;\n\n// flow --- start\nstruct edge\n{\n  int to,cap,rev;\n  edge(int to=inf,int cap=inf,int rev=inf):to(to),cap(cap),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint level[MAX];\nint iter[MAX];\n\nvoid add_edge(int from,int to,int cap)\n{\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n  rep(i,MAX)level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty())\n    {\n      int v = que.front(); que.pop();\n      rep(i,G[v].size())\n\t{\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && level[e.to] < 0)\n\t    {\n\t      level[e.to] = level[v] + 1;\n\t      que.push(e.to);\n\t    }\n\t}\n    }\n} \n\nint dfs(int v,int t,int f)\n{\n  if(v == t)return f;\n  for(int &i = iter[v]; i < G[v].size() ; i++)\n    {\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to])\n\t{\n\t  int d = dfs(e.to,t,min(f,e.cap));\n\t  if(d > 0)\n\t    {\n\t      e.cap -= d;\n\t      G[e.to][e.rev].cap += d;\n\t      return d;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;)\n    {\n      bfs(s);\n      if(level[t] < 0)return flow;\n      rep(i,MAX)iter[i] = 0;\n      int f;\n      while((f = dfs(s,t,inf)) > 0)\n\tflow += f;\n    }\n}\n\n// flow --- end\n\n\nint N,M,L;\nint mincost[MAX][MAX];\nvector<ii> ps;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      rep(i,MAX)G[i].clear();\n      rep(i,N)rep(j,N)mincost[j][i] = inf;\n      rep(i,N)        mincost[i][i] = 0;\n\n      \tint u,v,d;\n\trep(i,M)\n\t  {\n\t    cin >> u >> v >> d;\n\t    mincost[u][v] = mincost[v][u] = d;\n\t  }\n\trep(i,N)rep(j,N)rep(k,N)mincost[j][k] = min(mincost[j][k],mincost[j][i]+mincost[i][k]);\n\n\tps.clear();\n\tps.resize(L);\n\trep(i,L)cin >> ps[i].first >> ps[i].second;\n\tV = L;\n\n\tint st = 2*V+1,ed = 2*V+2;\n\trep(i,V)        add_edge(st,i,inf);\n\trep(i,V)rep(j,V)if(i != j && ps[i].second+mincost[ps[i].first][ps[j].first] <= ps[j].second)add_edge(i,V+j,1);\n\trep(i,V)        add_edge(V+i,ed,1);\n\t/*\n\trep(i,2*N)\n\t  {\n\t    cout << \"start \" << i << endl;\n\t    rep(j,G[i].size())\n\t      {\n\t\tcout << \"(\" << G[i][j].to << \",\" << G[i][j].cap << \") \";\n\t      }\n\t    cout << endl;\n\t  }\n\t*/\n\tcout << V-max_flow(st,ed) << endl;\n\n      }\n\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint prevV[2100], prevE[2100];\nint dist[2100];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\tint V = G.size();\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+2100, INF);\n\t\tdist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tm[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tm[u][v] = m[v][u] = d;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint s = 2*L+1, t = s+1;\n\t\tG.clear(); G.resize(t+1);\n\n\t\tvector<int> p(L), time(L);\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tcin >> p[i] >> time[i];\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tif (i != j && time[i] + m[p[i]][p[j]] <= time[j]) {\n\t\t\t\t\taddEdge(L+i, j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\taddEdge(s, i, 1, 0);\n\t\t\taddEdge(L+i, t, 1, 0);\n\t\t\taddEdge(i, L+i, 1, -1);\n\t\t}\n\n\t\tint r = 0;\n\t\tfor (int l = 1; l <= L; ++l) {\n\t\t\tr += flow(s, t, 1);\n\t\t\tif (r == -L) {\n\t\t\t\tcout << l << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,cost,rev;\n};\n\nconst int INF=1<<29;\nint N,L;\nint NV;\nvector<vector<edge> > G;\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back({to,cap,cost,G[to].size()});\n  G[to].push_back({from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t){\n  int nc=0;\n  for(int c=1;;c++){\n    int dist[202];\n    fill(begin(dist),end(dist),INF);\n    dist[0]=0;\n    int prevv[202],preve[202];\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<NV;v++){\n\tif(dist[v]==INF)continue;\n\tfor(int i=0;i<G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t    dist[e.to]=dist[v]+e.cost;\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    update=true;\n\t  }\n\t}\n      }\n    }\n    nc-=dist[t];\n    if(nc==L)return c;\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap--;\n      G[v][e.rev].cap++;\n    }\n  }\n}\n\nint main(){\n  for(int M;cin>>N>>M>>L,N;){\n    NV=2*L+2;\n    int d[100][100];\n    fill(d[0],d[100],INF);\n    for(int i=0;i<N;i++){\n      d[i][i]=0;\n    }\n    while(M--){\n      int u,v,di;\n      cin>>u>>v>>di;\n      d[u][v]=d[v][u]=min(d[u][v],di);\n    }\n    for(int k=0;k<N;k++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<N;j++){\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    G=vector<vector<edge> >(NV);\n    vector<pair<int,int> > pt;\n    for(int i=0;i<L;i++){\n      int p,t;\n      cin>>p>>t;\n      pt.emplace_back(t,p);\n    }\n    sort(begin(pt),end(pt));\n    for(int i=0;i<pt.size();i++){\n      add_edge(0,2*i+2,1,0);\n      add_edge(2*i+2,2*i+3,1,-1);\n      add_edge(2*i+3,1,1,0);\n      for(int j=0;j<i;j++){\n\tif(pt[j].first+d[pt[j].second][pt[i].second]<=pt[i].first){\n\t  add_edge(2*j+3,2*i+2,1,0);\n\t}\n      }\n    }\n    cout<<min_cost_flow(0,1)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nWeight INF=1e9;\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=false;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push(make_pair(Weight(0),s));\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push(make_pair(dist[e.to],e.to));\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\nint solve();\nint main(){\n    while(solve()){\n\n    }\n    return true;\n}\nint solve(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(n==0) return false;\n    vector<vector<int>> d(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        int dd;\n        cin>>dd;\n        d[u][v]=dd;\n        d[v][u]=dd;\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n    vector<int> p(l),t(l);\n    for(int i=0;i<l;i++) cin>>p[i]>>t[i];\n    vector<pair<int,int>> tp(l);\n    for(int i=0;i<l;i++) tp[i]={t[i],p[i]};\n    sort(tp.begin(),tp.end());\n    for(int i=0;i<l;i++){\n        t[i]=tp[i].first;\n        p[i]=tp[i].second;\n    }\n\n    Flow org(2*l+4);\n    //[0,l):in\n    int S=2*l;\n    int superS=2*l+1;\n    int T=2*l+2;\n    int superT=2*l+3;\n    \n    for(int i=0;i<l;i++){\n        org.addEdge(S,i,1,0);\n        org.addEdge(i+l,T,INF,0);\n        //org.addEdge(i,i+l,1,-1);\n        org.addEdge(i+l,i,1,1);\n        org.addEdge(superS,i+l,1,0);\n        org.addEdge(i,superT,1,0);\n    }\n\n    for(int i=0;i<l;++i){\n        vector<int> town(n,false);\n        vector<int> index;\n        for(int j=i+1;j<l;j++){\n            if(town[p[j]] || d[p[i]][p[j]]>t[j]-t[i]) continue;\n            town[p[j]]=true;            \n            index.push_back(j);\n        }\n        for(int j=0;j<index.size();j++){\n            bool isok=true;\n            for(int k=0;k<j;k++){\n                if(d[p[index[j]]][p[index[k]]]<=t[index[k]]-t[index[j]]) isok=false;\n            }\n            if(isok){\n                org.addEdge(l+i,index[j],1,0);\n                org.addEdge(l+i,index[j]+l,INF,0);\n            }\n        }\n    }\n    int lb=0;\n    int ub=n;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        Flow flow=org;\n        flow.addEdge(superS,S,mid,0);\n        flow.addEdge(T,superT,mid,0);\n        int cost=flow.minCostFlow(superS,superT,mid+l);\n        cost-=l;\n        if(cost!=-l){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    cout<<ub<<endl;\n\n    return true;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define FORIT(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n    int src;\n    int dest;\n    int capacity;\n    Weight weight;\n    Edge() {;}\n    Edge(int src, int dest, int capacity, Weight weight) : src(src), dest(dest), capacity(capacity), weight(weight) {;}\n    bool operator<(const Edge &rhs) const {\n        return weight > rhs.weight;\n    }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n    REP(y, matrix.size()) {\n        REP(x, matrix[y].size()) {\n            printf(\"%d \", matrix[y][x]);\n        }\n        puts(\"\");\n    }\n}\n\n/*\nWeight augment(const Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n    if (from == t || cur == 0) { return cur; }\n    if (finished[from]) { return 0; }\n    FORIT(it, g[from]) {\n        int to = it->dest;\n        if (level[to] <= level[from]) { continue; }\n        Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n        if (f > 0) {\n            capacity[from][to] -= f;\n            capacity[to][from] += f;\n            return f;\n        }\n    }\n    finished[from] = true;\n    return 0;\n}\n\nWeight MaxFlow(const Graph &g, int s, int t) {\n    const int n = g.size();\n    Matrix capacity(n, Array(n));\n    REP(from, n) {\n        FORIT(it, g[from]) {\n            int to = it->dest;\n            capacity[from][to] += it->weight;\n        }\n    }\n    int ans = 0;\n    while (true) {\n        vector<int> level(n, -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        for (int d = n; !que.empty() && level[que.front()] < d; ) {\n            const int from = que.front();\n            que.pop();\n            if (from == t) { d = level[from]; }\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                if (capacity[from][to] > 0 && level[to] == -1) {\n                    que.push(to);\n                    level[to] = level[from] + 1;\n                }\n            }\n        }\n        vector<bool> finished(n);\n        bool end = true;\n        while (true) {\n            Weight f = augment(g, capacity, level, finished, s, t, 2000000000LL);\n            if (f == 0) { break; }\n            ans += f;\n            end = false;\n        }\n        if (end) { break; }\n    }\n    return ans;\n}\n*/\n\nint parent[2020];\nint nowDist[2020];\nint prevDist[2020];\n\nint MinCostFlow(const Graph &g, int s, int t, int l) {\n    const int n = g.size();\n    Matrix capacity(n, Array(n, 0));\n    Matrix cost(n, Array(n, 0));\n    REP(from, n) {\n        FORIT(it, g[from]) {\n            assert(it->capacity >= 0);\n            capacity[from][it->dest] += it->capacity;\n            cost[from][it->dest] += it->weight;\n        }\n    }\n\n    vector<int> parent(n);\n    vector<int> prev_dist(n, 0);\n    vector<int> now_dist(n);\n\n    // calc potential\n    REP(iter, n) {\n        bool end = true;\n        REP(from, n) {\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                if (capacity[from][to] == 0) { continue; }\n                int ncost = prev_dist[from] + cost[from][to];\n                if (ncost < prev_dist[to]) {\n                    end = false;\n                    prev_dist[to] = ncost;\n                }\n            }\n        }\n        if (end) { break; }\n    }\n\n    int ret = 0;\n    int c = 0;\n    while (true) {\n        ret++;\n        fill(parent.begin(), parent.end(), -1);\n        fill(now_dist.begin(), now_dist.end(), 2000000000LL);\n        priority_queue<Edge> que;\n        que.push(Edge(s, s, 0, 0));\n        now_dist[s] = 0;\n        while (!que.empty()) {\n            Edge node = que.top();\n            que.pop();\n            if (parent[node.dest] != -1) { continue; }\n            parent[node.dest] = node.src;\n            int from = node.dest;\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                int ncost = node.weight + cost[from][to] + (prev_dist[from] - prev_dist[to]);\n                if (capacity[from][to] == 0) { continue; }\n                if (ncost >= now_dist[to]) { continue; }\n                now_dist[to] = ncost;\n                que.push(Edge(from, to, 0, ncost));\n            }\n        }\n        if (parent[t] == -1) { assert(false); }\n        int from = parent[t];\n        int to = t;\n        while (from != to) {\n            c += cost[from][to];\n            capacity[from][to]--;\n            capacity[to][from]++;\n            from = parent[from];\n            to = parent[to];\n        }\n        REP(i, n) {\n            prev_dist[i] += now_dist[i];\n        }\n        if (c == -l) { return ret; }\n    }\n    assert(false);\n    return 0;\n}\n\nvoid addEdge(Graph &g, int from, int to, int cost) {\n    g[from].push_back(Edge(from, to, 1, cost));\n    g[to].push_back(Edge(to, from, 0, -cost));\n}\n\nint n, m, l;\ninline int IN(int x) { return 2 * x; }\ninline int OUT(int x) { return 2 * x + 1; }\ninline int SOURCE() { return 2 * l; }\ninline int DEST() { return 2 * l + 1; }\ninline int SIZE() { return 2 * l + 2; }\n\nll matrix[110][110];\nint point[1010];\nll ontime[1010];\nbool visit[2020];\n\nint main() {\n    while (scanf(\"%d %d %d\", &n, &m, &l), n|m|l) {\n        MEMSET(matrix, 0x0f);\n        Graph g(2 * l + 2);\n        REP(i, m) {\n            int f, t, c;\n            scanf(\"%d %d %d\", &f, &t, &c);\n            matrix[f][t] = c;\n            matrix[t][f] = c;\n        }\n        REP(k, n) REP(i, n) REP(j, n) {\n            matrix[j][j] = 0;\n            matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n        }\n        REP(i, l) {\n            int p, t;\n            scanf(\"%d %d\", &p, &t);\n            point[i] = p;\n            ontime[i] = t;\n        }\n        REP(i, l) {\n            addEdge(g, SOURCE(), IN(i), 0);\n            addEdge(g, OUT(i), DEST(), 0);\n            addEdge(g, IN(i), OUT(i), -1);\n            REP(j, l) {\n              if (i == j) { continue; }\n                if (ontime[j] + matrix[point[j]][point[i]] <= ontime[i]) {\n                    addEdge(g, OUT(j), IN(i), 0);\n                }\n            }\n        }\n        printf(\"%d\\n\", MinCostFlow(g, SOURCE(), DEST(), l));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\ntemplate <class T>\nbool chmax(T &a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\nbool chmin(T &a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconstexpr int INF = 1e9;\n\nstruct Dinic {\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    Dinic(int V) : V(V) { G.assign(V, vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge){to, cap, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, (int)(G[from].size() - 1)});\n    }\n\n    void bfs(int s) {\n        level.assign(V, -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            for  (auto &e : G[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = itr[v]; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V, 0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nsigned main() {\n    int N, M, L;\n    while (1) {\n        cin >> N >> M >> L;\n        if (N == 0) break;\n\n        vector<vector<int>> adj(N, vector<int>(N, INF));\n        rep(i, 0, N) {\n            adj[i][i] = 1;\n        }\n        rep(i, 0, M) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            adj[a][b] = adj[b][a] = c;\n        }\n        rep(k, 0, N) {\n            rep(i, 0, N) {\n                rep(j, 0, N) {\n                    chmin(adj[i][j], adj[i][k] + adj[k][j]);\n                }\n            }\n        }\n        vector<vector<int>> req_time(N), node_id(N);\n        rep(i, 0, L) {\n            int p, t;\n            cin >> p >> t;\n            req_time[p].push_back(t);\n        }\n        rep(i, 0, N) sort(req_time[i].begin(), req_time[i].end());\n        int idx = 0;\n        rep(i, 0, N) for (auto t : req_time[i]) {\n            node_id[i].push_back(idx);\n            idx++;\n        }\n\n        int SZ = idx;\n        vector<vector<int>> dag(SZ);\n        rep(i, 0, N) {\n            rep(k, 0, req_time[i].size()) {\n                int T = req_time[i][k];\n                int nd = node_id[i][k];\n                rep(j, 0, N) {\n                    if (adj[i][j] != INF) {\n                        int nxt = T + adj[i][j];\n                        auto itr = lower_bound(req_time[j].begin(), req_time[j].end(), nxt);\n                        if (itr == req_time[j].end()) continue;\n                        int p = itr - req_time[j].begin();\n                        int nx_nd = node_id[j][p];\n                        dag[nd].push_back(nx_nd);\n                    }\n                }\n            }\n        }\n\n        Dinic bimatch(SZ * 2 + 2); // 0: S, 1:S\n        rep(v, 0, SZ) {\n            bimatch.add_edge(0, 2 + v, 1);\n            bimatch.add_edge(2 + SZ + v, 1, 1);\n        }\n        rep(v, 0, SZ) {\n            for (int w : dag[v]) {\n                bimatch.add_edge(2 + v, 2 + SZ + w, 1);\n            }\n        }\n        int min_path_cover = SZ - bimatch.max_flow(0, 1);\n        cout << min_path_cover << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\n\nbool bm_augment(const vector<vector<int>> &graph, int v, vector<int> &match_to, vector<bool> &visited) {\n    if(v == -1) return true;\n    if(visited[v]) return false;\n    visited[v] = true;\n    for(int n : graph[v]) {\n        if(bm_augment(graph, match_to[n], match_to, visited)) {\n            match_to[n] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(const vector<vector<int>> &graph) {\n    const int N = graph.size();\n    vector<int> match_to(N, -1);\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        vector<bool> visited(N, false);\n        if(bm_augment(graph, i, match_to, visited)) ++cnt;\n    }\n    return cnt;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<int>> dist(N, vector<int>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] >= d) dist[i][j] = d;\n            }\n        }\n    }\n\n    vector<vector<int>> graph(L);\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const auto &qi = queries[i];\n        for(int j = i+1; j < L; ++j) {\n            const auto &qj = queries[j];\n            if(dist[qi.second][qj.second] != -1 && qj.first - qi.first >= dist[qi.second][qj.second]) {\n                graph[i].push_back(j);\n            }\n        }\n    }\n    int cnt = bipartite_matching(graph);\n    cout << L-cnt << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nbool G[1000][1000];\nint match[1000];\nbool used[1000];\n\nstruct BipartiteMatching {\n\tint V;\n\n\tBipartiteMatching(int v) {\n\t\tV = v;\n\t}\n\n\tvoid add_edge(int v, int u) {\n\t\tG[v][u] = G[u][v] = true;\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(!G[v][i]) continue;\n\t\t\tint u = i, w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint calc() {\n\t\tint res = 0;\n\t\tfill(match, match + V, -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used, used + V, false);\n\t\t\t\tif(dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tBipartiteMatching bp(2 * L);\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tG[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tbp.add_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - bp.calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(scanf(\"%d%d%d\",&N,&M,&L),N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)scanf(\"%d%d\",&p[i],&t[i]);\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    printf(\"%d\\n\",num);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string.h>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n  for(i=0;i<l;i++) printf(\"%3d\",pathParent[i]);\n  printf(\"\\n\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++) find(i);\n  for(int i=0;i<l;i++) if(pathParent[i]<0) num++;\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,l;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[3005];\nbool used[3005];\nint E[105][105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nint p[1005],t[1005];\nint main(){\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) return 0;\n\t\trep(i,105) rep(j,105){\n\t\t\tE[i][j] = INF;\n\t\t\tif(i==j) E[i][j] = 0;\n\t\t}\n\t\trep(i,3005){\n\t\t\tG[i].clear(); used[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tE[u][v] = E[v][u] = d;\n\t\t}\n\t\tfor(int i=0;i<l;i++) cin >> p[i] >> t[i];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tE[j][k] = min(E[j][k],E[j][i]+E[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(t[i]+E[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(i,j+1005,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++) add_edge(2301,i,1);\n\t\tfor(int i=0;i<l;i++) add_edge(i+1005,2302,1);\n\t\tcout << l-max_flow(2301,2302) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define MAX_V 2016\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nstruct edge{ int to,cap,rev; };\n\nint n,m,l;\nint dis[MAX][MAX],level[MAX_V],iter[MAX_V];\nvpi vp;\nint V;\nvector<edge> G[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  level[s]=0;\n  q.push(s);\n  while(q.size()){\n    int v=q.front();\n    q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap > 0 && level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap > 0 && level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,inf))>0)flow+=f;\n  }\n} \n\nvoid init(){\n  FOR(i,0,MAX){\n    FOR(j,0,MAX){\n      if(i==j)dis[i][j]=0;\n      else dis[i][j]=inf;\n    }\n  }\n  FOR(i,0,MAX_V)G[i].clear();\n  vp.clear();\n}\n\nvoid wf(){\n  FOR(k,0,n)\n    FOR(i,0,n)\n      FOR(j,0,n)\n        dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n}\n\nvoid solve(){\n  int s=2*l;\n  int t=s+1;\n  V=t+1;\n  FOR(i,0,l){\n    add_edge(s,i,1);\n    add_edge(i+l,t,1);\n  }\n  FOR(i,0,l){\n    FOR(j,0,l){\n      if(i==j)continue;\n      if(vp[j].s<vp[i].s)continue;\n      if(dis[vp[i].f][vp[j].f]<=vp[j].s-vp[i].s)add_edge(i,j+l,1);\n    }\n  }\n  cout<<l-max_flow(s,t)<<endl;\n  return;\n}\n\nint main()\n{\n  while(1){\n    cin>>n>>m>>l;\n    if(n+m+l==0)break;\n    init();\n    FOR(i,0,m){\n      int u,v,d;\n      cin>>u>>v>>d;\n      dis[u][v]=d;\n      dis[v][u]=d;\n    }\n    FOR(i,0,l){\n      int p,t;\n      cin>>p>>t;\n      vp.pb(mp(p,t));\n    }\n    wf();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define INF 100000000\n\nusing namespace std;\n\nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0 || !used[w] && dfs(w)){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bitpartite_matching(){\n\tint res=0;\n\tfill(match,match+2001,-1);\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v]<0){\n\t\t\tfill(used,used+2001,false);\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\tint n,m,l,u,v,d,dist[101][101],p[1001],t[1001];\n\t\n\twhile(cin >> n >> m >> l,n|m|l){\n\t\tfor(int i=0;i<2001;i++)G[i].clear();\n\t\t\n\t\tfill(dist[0],dist[101],INF);\n\t\t\n\t\tfor(int i=0;i<101;i++)dist[i][i]=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v]=dist[v][u]=d;\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\t\tfor(int i=0;i<l;i++)cin >> p[i] >> t[i];\n\t\t\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(dist[p[i]][p[j]]+t[i]<=t[j])add_edge(i,j+l);\n\t\t\t}\n\t\t}\n\t\tV=2*l;\n\t\tcout << l-bitpartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge1\n{\npublic:\n    int to, cost;\n    Edge1(){};\n    Edge1(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge1> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge1 e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<Edge1> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nclass Edge2\n{\npublic:\n    int to, cap, rev;\n    Edge2(){};\n    Edge2(int to0, int cap0){to = to0; cap = cap0;}\n    Edge2(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge2> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge2> > edges;\n    static vector<bool> used;\n\n    class Func{\n    public:\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            used[s] = true;\n            for(unsigned i=0; i<edges[s].size(); ++i){\n                Edge2& e = edges[s][i];\n                if(!used[e.to] && e.cap > 0){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    int n = edges0.size();\n    edges.assign(n, vector<Edge2>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge2& e = edges0[i][j];\n            edges[i].push_back(Edge2(e.to, e.cap, edges[e.to].size()));\n            edges[e.to].push_back(Edge2(i, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        used.assign(n, false);\n        int f = Func::dfs(source, sink, INT_MAX);\n        if(f == 0)\n            return ret;\n        ret += f;\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, l;\n        cin >> n >> m >> l;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge1> > edges1(n);\n        for(int i=0; i<m; ++i){\n            int u, v, d;\n            cin >> u >> v >> d;\n            edges1[u].push_back(Edge1(v, d));\n            edges1[v].push_back(Edge1(u, d));\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges1, dist);\n\n        vector<pair<int, int> > del(l);\n        for(int i=0; i<l; ++i)\n            cin >> del[i].second >> del[i].first;\n        sort(del.begin(), del.end());\n\n        vector<vector<Edge2> > edges2(2*l+2);\n        for(int i=0; i<l; ++i){\n            edges2[0].push_back(Edge2(i+2, 1));\n            edges2[i+l+2].push_back(Edge2(1, 1));\n        }\n        for(int i=0; i<l; ++i){\n            for(int j=i+1; j<l; ++j){\n                if(dist[del[i].second][del[j].second] <= del[j].first - del[i].first)\n                    edges2[i+2].push_back(Edge2(j+l+2, 1));\n            }\n        }\n\n        int ret = l - maxFlow(edges2, 0, 1);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\nint d[112][112];\n\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  //out(from,to,cap,1);\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=1e7;\n\n//max_flow\n\nvector<int> used;\n\nint dfs(Graph &g,int v,int t,int f){\n  if(v==t) return f;\n  used[v]=1;\n  int re,i,j,k;\n  for(i=0;i<g[v].size();i++){\n    Edge &e=g[v][i];\n    if(e.cap<=0||used[e.to])continue;\n    int d=dfs(g,e.to,t,min(f,e.cap));\n    if(d>0){\n      e.cap-=d;\n      g[e.to][e.rev].cap+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph &g,int s,int t){\n  int sum=0,f,V=g.size();\n  while(1){\n    used.resize(V);\n    fill(all(used),0);\n    sum+=f=dfs(g,s,t,INF);\n    if(!f)return sum;\n  }\n}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m,l;\n  while(cin>>n>>m>>l,n){\n    fill(d[0],d[112],MOD);\n    rep(i,112) d[i][i]=0;\n  rep(i,m){\n    int x,y,z;\n    cin>>x>>y>>z;\n    MN(d[x][y],z);\n    MN(d[y][x],z);\n  }\n  rep(k,n)rep(i,n)rep(j,n) MN(d[i][j],d[i][k]+d[k][j]);\n  //rep(i,n){rep(j,n)cout<<d[i][j]<<\",\";cout<<endl;}\n  vector<int> ps(l),ts(l);\n  rep(i,l) cin>>ps[i]>>ts[i];\n  Graph g(l+l+2);\n  //rep(i,l)rep(j,l)if(i!=j)out(ts[i]+d[ps[i]][ps[j]],ts[j],1);\n  rep(i,l)rep(j,l)if(i!=j && ts[i]+d[ps[i]][ps[j]]<=ts[j]) add_edge(g,i,l+j,1);\n  rep(i,l){\n    add_edge(g,l+l,i,1);\n    add_edge(g,l+i,l+l+1,1);\n  }\n  int flow=max_flow(g,l+l,l+l+1);\n  //out(l,flow,n,m,1);\n  cout<<l-flow<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1050\n#define INF 1<<28\nvector<int> G[MAX_V];\nint match[MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\ntypedef pair<int,int> P;\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n    int e[n][n];\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) e[i][j]=(i!=j)*INF;\n    for(int i=0;i<m;i++){\n      int u,v,d;\n      cin>>u>>v>>d;\n      e[u][v]=e[v][u]=d;\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n    vector<P> p(l);\n    for(int i=0;i<l;i++) cin>>p[i].first>>p[i].second;\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i==j) continue;\n\tint u=p[i].first,v=p[j].first;\n\tif(p[j].second-p[i].second>=e[u][v]) add_edge(u,l+v);\n      }\n    }\n    V=l*2;\n    cout<<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint search(vector<int>& psort,vector<int>& tsort,int nos,int* santanow,int* santatime,int dist[1000][1000],int pos,int max){\n\tpos++;\n\tif(max == pos){\n\t\treturn nos;\n\t}\n\n\tvector<int> avalable;\n\tfor(int i = 0; i < nos; i++){\n\t\tint temp = santatime[i]  + dist[psort[pos]][santanow[i]];\n\t\tif(temp <= tsort[pos]){\n\t\t\tavalable.push_back(i);\n\t\t}\n\t}\n\n\tif(avalable.empty()){\n\t\tnos++;\n\t\tsantanow[nos-1] = psort[pos];\n\t\tsantatime[nos-1] = tsort[pos];\n\t\tnos = search(psort,tsort,nos,santanow,santatime,dist,pos,max);\n\t}else{\n\t\tvector<int> noss;\n\t\tint min = max;\n\t\tfor(int i = 0; i < avalable.size(); i++){\n\t\t\tsantanow[avalable[i]] = psort[pos];\n\t\t\tsantatime[avalable[i]] = tsort[pos];\n\t\t\tnoss.push_back(search(psort,tsort,nos,santanow,santatime,dist,pos,max));\n\t\t}\n\t\tfor(int i = 0; i < noss.size(); i++){\n\t\t\tif(min > noss[i]){\n\t\t\t\tmin = noss[i];\n\t\t\t}\n\t\t}\n\t\tnos = min;\n\t}\n\n\treturn nos;\n}\n\nint main(){\n\tint N,M,L;\n\tint u[1000],v[1000],d[1000],p[1000],t[1000];\n\tvector<int> numofsanta;\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\n\twhile(N != 0 || M != 0 || L != 0){\n\t\tint dist[1000][1000];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = 100000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> psort;\n\t\tvector<int> tsort; \n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d\",&u[i],&v[i],&d[i]);\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\n\t\t//Warshall-Floyd Algorithm\n\n    \tfor(int i = 0; i < N; i++){\n        \tfor(int j = 0; j < N; j++){\n            \tfor(int k = 0; k < N; k++){\n            \t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            \t}\n            }\n        }\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tvector<int>::iterator p_it = psort.begin();\n\t\t\tvector<int>::iterator t_it = tsort.begin();\t\t\t\t\n\t\t\tscanf(\"%d %d\",&p[i],&t[i]);\n\t\t\tif(i == 0){\n\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\ttsort.push_back(t[i]);\n\t\t\t}else{\n\t\t\t\tint siz = psort.size();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tif(tsort[j] > t[i]){\n\t\t\t\t\t\tpsort.insert(p_it,p[i]);\n\t\t\t\t\t\ttsort.insert(t_it,t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\t\t\ttsort.push_back(t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++p_it;\n\t\t\t\t\t\t++t_it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint nos = 1;\n\t\tint max = psort.size();\n\t\tint santanow[max],santatime[max];\n\t\tsantanow[0] = psort[0];\n\t\tsantatime[0] = tsort[0];\n\n\n\t\tnos = search(psort,tsort,nos,santanow,santatime,dist,0,max);\n\n\t\tnumofsanta.push_back(nos);\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t}\n\n\tfor(int i = 0; i < numofsanta.size(); i++){\n\t\tprintf(\"%d\\n\",numofsanta[i]);\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<algorithm>\n\nusing namespace std;\n\nconst int maxn = 1010;\nconst int inf = 0x3f3f3f3f;\n\nint dis[maxn][maxn];\nint n,m,L;\n\nstruct node\n{\n    int s,t;\n    node(int _s ,int _t):s(_s),t(_t) {}\n    node() {};\n    bool operator <(const node& o)const\n    {\n        return t < o.t;\n    }\n} q[maxn];\n\nint nn;\nbool e[maxn][maxn];\nvoid build()\n{\n    memset(e,0,sizeof(e));\n    nn = L;\n    for (int i=1; i<=nn; i++)\n        for (int j=i+1; j<=nn; j++)\n        {\n            int d1 = q[j].t - q[i].t;\n            int d2 = dis[q[j].s][q[i].s];\n            if (d2 <= d1)\n            {\n                e[i][j] = 1;\n                //printf(\"%d %d\\n\",i,j);\n            }\n        }\n    for (int k=1;k<=nn;k++)\n        for (int i=1;i<k;i++)\n            for (int j=k+1;j<=nn;j++)\n                e[i][j] = (e[i][j] | (e[i][k] & e[k][j]));\n    return ;\n}\n\nint vis[maxn];\nint cx[maxn];\nint cy[maxn];\nint find(int u)\n{\n    for (int v = u; v<=nn; v++)\n    {\n        if (e[u][v] && !vis[v])\n        {\n            vis[v] = 1;\n            if (cy[v]==-1 || find(cy[v]))\n            {\n                cx[u] = v;\n                cy[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint solve()\n{\n    memset(vis,0,sizeof(vis));\n    memset(cx,-1,sizeof(cx));\n    memset(cy,-1,sizeof(cy));\n    int res = 0;\n    for (int i=1; i<=nn; i++)\n    {\n        if (cx[i]==-1)\n        {\n            memset(vis,0,sizeof(vis));\n            if (find(i))\n                res++;\n        }\n    }\n    return res;\n}\nint main()\n{\n    while (scanf(\"%d%d%d\",&n,&m,&L)==3)\n    {\n        if (n==0 &&m==0 && L==0)\n            break;\n        memset(dis,inf,sizeof(dis));\n        for (int i=1; i<=m; i++)\n        {\n            int u,v,d;\n            scanf(\"%d%d%d\",&u,&v,&d);\n            u++;\n            v++;\n            if (d < dis[u][v])\n            {\n                dis[u][v] = d;\n                dis[v][u] = d;\n            }\n        }\n\n        for (int k=1; k<=n; k++)\n            for (int i=1; i<=n; i++)\n                for (int j=1; j<=n; j++)\n                    dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);\n        for (int i=1;i<=n;i++)\n            dis[i][i] = 0;\n\n\n        for (int i=1; i<=L; i++)\n        {\n            int s,t;\n            scanf(\"%d%d\",&s,&t);\n            s++;\n            q[i] = node(s,t);\n        }\n        sort(q+1,q+1+L);\n        build();\n        int res = solve();\n        int ans = L - res;\n\n        printf(\"%d\\n\",ans);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Weight = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight): src(src), dst(dst), weight(weight) {}\n};\nusing Vertex = vector<Edge>;\nusing Graph = vector<Vertex>;\n\nbool augment(const Graph& graph, vector<bool>& visited, vector<int>& match, int u) {\n    if (u == -1) return true;\n    for (auto& e : graph[u]) {\n        if (!visited[e.dst]) {\n            visited[e.dst] = true;\n            if (augment(graph, visited, match, match[e.dst])) {\n                match[e.src] = e.dst;\n                match[e.dst] = e.src;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint bipartie_matching(const Graph& graph, int n_left) {\n    vector<int> match(graph.size(), -1);\n    int n_match = 0;\n    REP(u, n_left) {\n        vector<bool> visited(graph.size());\n        if (augment(graph, visited, match, u)) ++n_match;\n    }\n    return n_match;\n}\n\nvector<vector<Weight>> warshall_floyd(Graph graph) {\n    static const Weight inf = numeric_limits<Weight>::max() / 10;\n    vector<vector<Weight>> dist(graph.size(), vector<Weight>(graph.size(), inf));\n    REP(u, graph.size()) dist[u][u] = 0;\n    REP(u, graph.size()) for (auto& e : graph[u]) dist[e.src][e.dst] = e.weight;\n    REP(w, graph.size()) REP(u, graph.size()) REP(v, graph.size())\n        dist[u][v] = min(dist[u][v], dist[u][w] + dist[w][v]);\n    return dist;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, L;\n    while (cin>>N>>M>>L, N|M|L) {\n        Graph graph1(N);\n        REP(i, M) {\n            int u, v, d; cin >> u >> v >> d;\n            graph1[u].emplace_back(u, v, d);\n            graph1[v].emplace_back(v, u, d);\n        }\n        vector<int> positions(L), times(L);\n        REP(i, L) cin >> positions[i] >> times[i];\n\n        vector<vector<Weight>> dist = warshall_floyd(graph1);\n\n        Graph graph2(2*L);\n        REP(i, L) {\n            int t1 = times[i], p1 = positions[i];\n            REP(j, L) if (i != j) {\n                int t2 = times[j], p2 = positions[j];\n                if (dist[p1][p2] <= t2-t1) {\n                    graph2[i].emplace_back(i, j+L, 0);\n                }\n            }\n        }\n        cout << L - bipartie_matching(graph2, L) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\n#define MAX_V 1000\n\nlong long int d[MAX_V][MAX_V];\n\nvoid warshall_floyd(int n){\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n}\n\nstruct edge{\n\tlong long int to, cap, rev; // \n};\n\nvector<edge> G[MAX_V] = {};\nbool used[MAX_V];\n\n// \nvoid add_edge(long long int from, long long int to, long long int cap){\n\tG[from].push_back((edge){to, cap, (long long int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (long long int)G[from].size() - 1}); // \n\t// G[to].push_back((edge){from, cap, G[from].size() - 1}); // \n}\n\n// \nlong long int dfs(int v, int t, long long int f){\n\tif(v == t){\n\t\treturn f;\n\t}\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tlong long int d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// \nlong long int max_flow(int s, int t){\n\tlong long int flow = 0;\n\twhile(true){\n\t\tfill(used, used + MAX_V, 0);\n\t\tlong long int f = dfs(s, t, INF);\n\t\tif(f == 0){\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n    while(true){\n        int N, M, L;\n        cin >> N >> M >> L;\n        if(N == 0){\n            break;\n        }\n        for(int i = 0; i < N; i++){\n            for(int j = 0; j < N; j++){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        for(int i = 0; i < M; i++){\n            int u, v, d_;\n            cin >> u >> v >> d_;\n            d[u][v] = d[v][u] = d_;\n        }\n        warshall_floyd(N);\n        long long int p[1100], t[1100];\n        for(int i = 0; i < L; i++){\n            cin >> p[i] >> t[i];\n        }\n        for(int i = 0; i < MAX_V; i++){\n            G[i].clear();\n        }\n        for(int i = 1; i <= L; i++){\n            add_edge(0, i, 1);\n            add_edge(i + L, 2 * L + 1, 1);\n        }\n        for(int i = 0; i < L; i++){\n            for(int j = 0; j < L; j++){\n                if(i != j && t[j] - t[i] >= d[p[i]][p[j]]){\n                    add_edge(i + 1, j + 1 + N, 1);\n                }\n            }\n        }\n        cout << L - max_flow(0, 2 * L + 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF=1<<29,MAX=2222;\nint V,match[MAX];\nvector<int> G[MAX];\nbool used[MAX];\nvoid add_edge(int u,int v){G[u].push_back(v);}\n\nbool dfs(int v){\n  used[v]=1;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n,m,l;\n  while(cin >> n >> m >> l&&n) {\n    for(int i=0;i<MAX;i++)G[i].clear();\n    V=l;\n    int d[n][n];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)d[i][j]=INF;\n      d[i][i]=0;\n    }\n    for(int i=0;i<m;i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      d[x][y]=min(d[x][y],z);\n      d[y][x]=min(d[y][x],z);\n    }\n    for(int k=0;k<n;k++) {\n      for(int i=0;i<n;i++) {\n        for(int j=0;j<n;j++) {\n          if(d[i][k]!=INF&&d[k][j]!=INF) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    P a[l];\n    for(int i=0;i<l;i++) cin >> a[i].first >> a[i].second;\n    for(int i=0; i<l; i++) {\n      for(int j=0; j<l; j++) {\n        if(i!=j&&a[j].second-a[i].second>=d[a[i].first][a[j].first]) add_edge(i,j+1000);\n      }\n    }\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n \nusing namespace std;\n \n////////////////////////?????§???????§?//////////////////////////////////////\n#define MAX_V 1000 * 2 + 16\nint V;                 // ??¶?????°\nvector<int> G[MAX_V];    // ???????????\\??¨\nint match[MAX_V];      // ??????????????¶???\nbool used[MAX_V];      // DFS?????¨??°??????????????°\n \n// ??????????¢???????????????\\u???v??????\nvoid add_edge(int u, int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \n// ??????DFS???????¢???????\nbool dfs(int v)\n{\n\tused[v] = true;\n\tfor (vector<int>::iterator it = G[v].begin(); it != G[v].end(); ++it)\n\t{\n\t\tint u = *it, w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n \n\treturn false;\n}\n \n// ?±??§£?????????????????§??????\nint bipartite_matching()\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n \n\treturn res;\n}\n \nvoid clear()\n{\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tG[i].clear();\n\t}\n}\n \n///////////////////////////////?????§?????????/////////////////////////////////////\n#define  MAX_N 100\n#define  MAX_L 1000\n#define  INF 0x3f3f3f3f\n \nint distance_matrix[MAX_N][MAX_N];\t\t// ????????´?????????\nint p[MAX_L], t[MAX_L];\t\t\t\t\t// ?????´???????????¶???\n \nbool update_min(int& v, const int& t)\n{\n\tif (t < v)\n\t{\n\t\tv = t;\n\t\treturn true;\n\t}\n\treturn false;\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n\tint N, M, L;\n\twhile (scanf(\"%d%d%d\", &N, &M, &L) != EOF && N)\n\t{\n\t\tV = L * 2;\n\t\tclear();\n\t\tmemset(distance_matrix, INF, sizeof(distance_matrix));\n \n\t\tfor (int _ = 0; _ < M; ++_)\n\t\t{\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tdistance_matrix[u][v] = distance_matrix[v][u] = d;\n\t\t}\n \n\t\tfor (int i = 0; i < L; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d\", p + i, t + i);\n\t\t}\n \n\t\t// warshall_floyd ????????´?????????\n\t\tfor (int k = 0; k < N; ++k) \n\t\t{\n\t\t\tdistance_matrix[k][k] = 0;\n\t\t\tfor (int i = 0; i < N; ++i) \n\t\t\t{\n\t\t\t\tfor (int j = 0; j < N; ++j) \n\t\t\t\t{\n\t\t\t\t\tupdate_min(distance_matrix[i][j], distance_matrix[i][k] + distance_matrix[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tfor (int i = 0; i < L; ++i) \n\t\t{\n\t\t\tfor (int j = 0; j < L; ++j)  \n\t\t\t{\n\t\t\t\tif (i != j && t[i] + distance_matrix[p[i]][p[j]] <= t[j])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(2 * i, 2 * j + 1);\t// ?????\\??¨i????????????j???????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tprintf(\"%d\\n\", L - bipartite_matching());\n\t}\n\treturn 0;\n}\n///////////////////////////End Sub//////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<set>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define INF (1<<30)\n#define maxn 1005\nint n,m,l;\nint dis[maxn][maxn],mark[maxn],t[maxn],sum=0;\nbool vis[maxn],f[maxn][maxn],vis1[maxn];\nint _max;\nbool dfs(int i)\n{\n    for(int j=0;j<=_max;j++)\n    {\n        if(!vis[j]&&f[i][j])\n        {\n            vis[j]=1;\n            if(mark[j]==-1||dfs(mark[j]))\n            {\n                mark[j]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n\n}\nvoid solve()\n{\n    memset(mark,-1,sizeof(mark));\n    for(int i=0;i<=_max;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if(dfs(i))sum++;\n    }\n}\nvoid build()\n{\n    int i,j;\n    for(i=0;i<=_max;i++)\n    {\n        for(j=0;j<=_max;j++)\n        {\n            if(dis[i][j]!=INF&&i!=j)\n            if(t[i]+dis[i][j]<=t[j])\n            {\n                 f[i][j]=1;\n            }\n        }\n    }\n}\nvoid floyd()\n{\n    int k,i,j;\n    for(k=0;k<n;k++)\n    {\n        for(i=0;i<n;i++)\n            for(j=0;j<n;j++)\n            if(dis[i][k]!=INF&&dis[k][j]!=INF)\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n}\nint main()\n{\n    \n     while(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n     {\n         if(!n&&!m&&!l)break;\n         int i,j;\n         memset(f,0,sizeof(f));\n         sum=0;\n         _max=n;\n         for(i=0;i<=n;i++)\n            for(j=0;j<=n;j++)dis[i][j]=INF;\n         for(i=1;i<=m;i++)\n         {\n             int x,y,w;\n             scanf(\"%d%d%d\",&x,&y,&w);\n             dis[x][y]=dis[y][x]=w;\n         }\n         floyd();\n         memset(t,-1,sizeof(t));\n         for(i=1;i<=l;i++)\n         {\n             int x,y;\n             scanf(\"%d%d\",&x,&y);\n             if(t[x]==-1)t[x]=y;\n             else {t[(x/n)*n+x]=y;_max=max(_max,(x/n)*n+x);}\n\n         }\n         for(i=0;i<=_max;i++)\n            for(j=0;j<=_max;j++)\n            {\n                dis[i][j]=dis[i%(n)][j%(n)];\n\n            }\n         build();\n\n         solve();\n        // printf(\"_max=%d sum=%d\\n\",_max,sum);\n         printf(\"%d\\n\",l-sum);\n\n     }\n     return 0;\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef vector< vector<int> > graph;\n\ngraph g;\nvector<int> match;\nvector<bool> visit;\n\nbool search(int u){\n\tif(u<0) return true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint next = g[u][i];\n\t\tif(visit[next]) continue;\n\t\tvisit[next] = true;\n\t\tif(search(match[next])){\n\t\t\tmatch[u] = next, match[next] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatch(int L, int R){\n\tint res = 0;\n\tmatch.assign(L+R, -1);\n\tfor(int i=0;i<L;i++){\n\t\tvisit.assign(L+R, false);\n\t\tres += search(i);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, M, L;\n\tstatic int dist[100][100];\n\twhile(cin >> N >> M >> L, N){\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\tdist[i][j] = (i==j ? 0 : INF);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\tdist[a][b] = dist[b][a] = min(dist[a][b], c);\n\t\t}\n\t\tfor(int k=0;k<N;k++)\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\tg.assign(2*L, vector<int>());\n\t\tvector< pair<int, int> > vp(L);\n\t\tfor(int i=0;i<L;i++)\n\t\t\tcin >> vp[i].second >> vp[i].first;\n\t\tsort(vp.begin(), vp.end());\n\t\tfor(int i=0;i<L;i++){\n\t\t\tfor(int j=i+1;j<L;j++){\n\t\t\t\tif(vp[i].first + dist[vp[i].second][vp[j].second] <= vp[j].first){\n\t\t\t\t\tg[i].push_back(L+j);\n\t\t\t\t\tg[L+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << L - maximumMatch(L, L) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint const nMax = 1010;\nlong long road[200][200];\nint n,m,L,x,y,cost,judge;\nstruct SANTA{\n    int house;\n    long long time;\n}santa[nMax];\nstruct present{\n    int a;\n    long long time;\n}pre[nMax];\nbool cmp(present a,present b)\n{\n    return a.time < b.time;\n}\nbool cmp2(SANTA a,SANTA b)\n{\n    return a.time > b.time;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L),n||m||L){\n        int ans = 0;\n        memset(road,63,sizeof(road));\n        for(int i = 1;i <= m;i++){\n            scanf(\"%d%d%d\",&x,&y,&cost);\n            if( road[x][y] > cost )\n                road[x][y] = road[y][x] = cost;\n        }\n        for(int k = 0;k < n;k++){\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < n;j++)\n                    if( road[i][j] > road[i][k] + road[k][j] ) road[i][j] = road[i][k] + road[k][j];\n            }\n        }\n        for(int i = 0;i < n;i++) road[i][i] = 0;\n        for(int i = 0;i < L;i++) scanf(\"%d%d\",&pre[i].a,&pre[i].time);\n        sort(pre,pre+m,cmp);\n        //for(int i = 0;i < L;i++)printf(\"%d  %d\\n\",pre[i].a,pre[i].time);\n        int len = L;\n        while( len > 0 ){\n            int k = 0;\n            for(int i = 0;i < len;i++){\n                //for(int k = 1;k <= ans;k++)printf(\"%d %d\\n\",santa[k].house,santa[k].time);\n                if( i == 0 ) {\n                    ans++;\n                    santa[ans].house = pre[i].a;\n                    santa[ans].time = pre[i].time;\n                    continue;\n                }\n                if( road[santa[ans].house][pre[i].a] <= pre[i].time - santa[ans].time ){\n                    santa[ans].house = pre[ans].a;\n                    santa[ans].time = pre[i].time;\n                }\n                else{\n                    pre[k].a = pre[i].a;\n                    pre[k].time = pre[i].time;\n                    k++;\n                }\n            }\n            len = k;\n        }\n        //for(int i = 1;i <= ans;i++)printf(\"%d %d\\n\",santa[i].house,santa[i].time);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<math.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n#define maxn 2050\nint V;                 \nvector<int> G[maxn];  \nint match[maxn];  \nbool used[maxn];\n#define  MAX_N 100\n#define  MAX_L 1000\n#define  INF 0x3f3f3f3f\nint dis[MAX_N][MAX_N];\nint p[MAX_L], t[MAX_L];  \nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \n// 通?DFS?找?广路\nbool dfs(int v){\n\tused[v] = true;\n\tfor (vector<int>::iterator it = G[v].begin(); it != G[v].end(); ++it)\n\t{\n\t\tint u = *it, w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n \n\treturn false;\n}\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n \n\treturn res;\n}\n \nvoid clear(){\n\tfor (int i = 0; i < V; ++i){\n\t\tG[i].clear();\n\t}\n}\t\nint main(){\n\tint N, M, L;\n\tint i,j,k;\n\twhile (~scanf(\"%d%d%d\", &N, &M, &L)){\n\t\tif(N==0&&M==0&&L==0) break;\n\t\tV = L * 2;\n\t\tclear();\n\t\tmemset(dis, INF, sizeof(dis));\n \n\t\tfor (i= 0; i< M; ++i){\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tdis[u][v] = dis[v][u] = d;\n\t\t}\n \n\t\tfor (i = 0; i < L; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d\", p + i, t + i);\n\t\t}\n \n\t\tfor (k = 0; k < N; ++k) {\n\t\t\tdis[k][k] = 0;\n\t\t\tfor (i = 0; i < N; ++i) {\n\t\t\t\tfor (j = 0; j < N; ++j) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tfor (i = 0; i < L; ++i) {\n\t\t\tfor (j = 0; j < L; ++j)  {\n\t\t\t\tif (i != j && t[i] + dis[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(2 * i, 2 * j + 1);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", L - bipartite_matching());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cstring>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nvector<int> vv[2010];\nint match[2010];\nbool used[2010];\n\n\nbool matchdfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0;i < vv[v].size();i++)\n\t{\n\t\tint u = vv[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w))\n\t\t{\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint two_matching_max(int l)\n{\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l)\n\t{\n\t\tif(match[v] < 0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l)\n\t{\t\t\n\t\tREP(i,2010)vv[i].clear();\n\t\tint dist[n+1][n+1] = {};\n\t\tREP(i,n+1)REP(j,n+1)dist[i][j] = 1e9;\n\t\t\n\t\t//cout << \"!\" << endl;\n\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\n\t\t//cout << \"!!\" << endl;\n\t\t\n\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t{\n\t\t\tdist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j]);\n\t\t}\n\t\t\n\t\t//cout << \"!!!\" << endl;\n\t\t\n\t\t//SHOW2d(dist,n,n);\n\t\t\n\t\tvector<pair<int,int> > v(l);\n\t\t\n\t\tREP(i,l)\n\t\t{\n\t\t\tint p,t;\n\t\t\tcin >> p >> t;\n\t\t\tv[i] = MP(p,t);\n\t\t}\n\t\t\n\t\t//cout << \"!!!!\" << endl;\n\t\t\n\t\tREP(i,l)REP(j,l)\n\t\t{\n\t\t\tif(i == j)continue;\n\t\t\tif(v[j].SE - v[i].SE >= dist[i][j])\n\t\t\t{\n\t\t\t\tvv[i].PB(l+j);\n\t\t\t\tvv[l+j].PB(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"!!!!!\" << endl;\n\t\t\n\t\tint ret =  l - two_matching_max(2*l) ;\n\t\tcout << ret << endl;\n\t}\n\t\t\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) y) { return (f)(begin(y), end(y), ## __VA_ARGS__); })(x)\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\n\nstruct edge_t { int to, cap, rev; };\nint maximum_flow_destructive(int s, int t, vector<vector<edge_t> > & g) {\n    int n = g.size();\n    vector<bool> used(n);\n    function<int (int, int)> dfs = [&](int i, int f) {\n        if (i == t) return f;\n        used[i] = true;\n        for (edge_t & e : g[i]) {\n            if (used[e.to] or e.cap <= 0) continue;\n            int nf = dfs(e.to, min(f, e.cap));\n            if (nf > 0) {\n                e.cap -= nf;\n                g[e.to][e.rev].cap += nf;\n                return nf;\n            }\n        }\n        return 0;\n    };\n    int result = 0;\n    while (true) {\n        used.clear(); used.resize(n);\n        int f = dfs(s, numeric_limits<int>::max());\n        if (f == 0) break;\n        result += f;\n    }\n    return result;\n}\n\nvector<pair<int,int> > perfect_bipartite_matching(set<int> const & a, set<int> const & b, vector<vector<int> > const & g /* adjacency list */) { // O(V + FE)\n    assert (a.size() + b.size() <= g.size());\n    int n = g.size();\n    int src = n;\n    int dst = n + 1;\n    vector<vector<edge_t> > h(n + 2);\n    auto add_edge = [&](int from, int to, int cap) {\n        h[from].push_back((edge_t) {   to, cap, int(h[  to].size()    ) });\n        h[  to].push_back((edge_t) { from,   0, int(h[from].size() - 1) });\n    };\n    repeat (i,n) {\n        if (a.count(i)) {\n            add_edge(src, i, 1);\n            for (int j : g[i]) if (b.count(j)) {\n                add_edge(i, j, 1); // collect edges e : a -> b, from g\n            }\n        }\n        if (b.count(i)) {\n            add_edge(i, dst, 1);\n        }\n    }\n    maximum_flow_destructive(src, dst, h);\n    vector<pair<int,int> > ans;\n    for (int from : a) {\n        for (edge_t e : h[from]) if (b.count(e.to) and e.cap == 0) {\n            ans.emplace_back(from, e.to);\n        }\n    }\n    return ans;\n}\n\nconst int inf = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, l; cin >> n >> m >> l;\n        if (n == 0 and m == 0 and l == 0) break;\n        vector<map<int,int> > g(n);\n        repeat (i,m) {\n            int u, v, d; cin >> u >> v >> d;\n            g[u][v] = d;\n            g[v][u] = d;\n        }\n        vector<int> p(l), t(l);\n        repeat (i,l) cin >> p[i] >> t[i];\n        // warshall floyd\n        vector<vector<int> > dist(n, vector<int>(n, inf));\n        repeat (i,n) dist[i][i] = 0;\n        repeat (i,n) for (auto it : g[i]) dist[i][it.first] = it.second;\n        repeat (k,n) repeat (i,n) repeat (j,n) setmin(dist[i][j], dist[i][k] + dist[k][j]);\n        // make a digraph of presents, DAG\n        vector<vector<int> > h(2*l);\n        repeat (i,l) repeat (j,l) if (i != j) if (dist[p[i]][p[j]] <= t[j] - t[i]) h[i].push_back(j + l);\n        // let it flow\n        set<int> a, b;\n        repeat (i,l) a.insert(i);\n        repeat (j,l) b.insert(j + l);\n        auto move = perfect_bipartite_matching(a, b, h);\n        // output\n        cout << l - move.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef vector< vector<int> > graph;\n\ngraph g;\nvector<int> match;\nvector<bool> visit;\n\nbool search(int u){\n\tif(u<0) return true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint next = g[u][i];\n\t\tif(visit[next]) continue;\n\t\tvisit[next] = true;\n\t\tif(search(match[next])){\n\t\t\tmatch[u] = next, match[next] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// L : ¶¤Ìm[hCR : E¤Ìm[h\nint maximumMatch(int L, int R){\n\tint res = 0;\n\tmatch.assign(L+R, -1);\n\tfor(int i=0;i<L;i++){\n\t\tvisit.assign(L+R, false);\n\t\tres += search(i);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, M, L;\n\tstatic int dist[100][100];\n\twhile(cin >> N >> M >> L, N){\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\tdist[i][j] = (i==j ? 0 : INF);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\tdist[a][b] = dist[b][a] = min(dist[a][b], c);\n\t\t}\n\t\tfor(int k=0;k<N;k++)\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n\t\tg.assign(2*L, vector<int>());\n\t\tvector< pair<int, int> > vp(L);\n\t\tfor(int i=0;i<L;i++)\n\t\t\tcin >> vp[i].second >> vp[i].first;\n\t\tsort(vp.begin(), vp.end());\n\t\tfor(int i=0;i<L;i++){\n\t\t\tfor(int j=i+1;j<L;j++){\n\t\t\t\tif(vp[i].first + dist[vp[i].second][vp[j].second] <= vp[j].first){\n\t\t\t\t\tg[i].push_back(L+j);\n\t\t\t\t\tg[L+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << L - maximumMatch(L, L) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nbool flow[2005][2005];\nbool DAG[1005][1005];\nint L,v[2020];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int src, int dst)\n{\n\tflow[dst][src]=1;\n\tnode[src].to.push_back(dst);\n\tnode[dst].to.push_back(src);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=(flow[p][next]?0:1);\n\t\tif(p==SOUR||p==SINK) fw=1;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]=1;\n\t\t\tflow[next][p]=0;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(n!=SOUR&&next!=SINK)\n\t\t\t\t{\n\t\t\t\t\tif(flow[n][next]) continue;\n\t\t\t\t}\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tConnect(node, SOUR, i);\n\t\t\tConnect(node, L+i, SINK);\n\t\t\t\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", L-dinic(SOUR,SINK,node));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * Dinic?????????????????§???\n *\n * ?????¨???????????¬????????????\n * template?????°???int V???????????°\n */\ntemplate<int V>\nstruct MaxFlow {\n    typedef int T;\n    const T INF = 1<<28;\n    struct Edge {\n        int to, rev;\n        T cap;\n    };\n    vector<Edge> g[V];\n    int level[V];\n    int iter[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    void add_multi(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    void bfs(int s) {\n        fill_n(level, V, -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (Edge e: g[v]) {\n                if (e.cap <= 0) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap <= 0) continue;\n            if (level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d <= 0) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // s??????t???????????§????????????\n    T exec(int s, int t) {\n        T flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill_n(iter, V, 0);\n            T f;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\ntypedef pair<int, int> P;\nconst int MN = 110;\nconst int ML = 1100;\nMaxFlow<MN*2> mf;\n\nint dist[MN][MN];\nP qu[ML];\nbool solve() {\n    mf.init();\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (!n) return false;\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = 1e8;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j],\n                    dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n\n    for (int i = 0; i < l; i++) {\n        int p, t;\n        cin >> p >> t;\n        qu[i] = P(t, p);\n    }\n    sort(qu, qu+l);\n\n    int vs = 2*MN-1;\n    int vt = 2*MN-2;\n    for (int i = 0; i < l; i++) {\n        for (int j = i+1; j < l; j++) {\n            int ap, at, bp, bt;\n            tie(at, ap) = qu[i];\n            tie(bt, bp) = qu[j];\n            if (dist[ap][bp] <= bt - at) {\n                mf.add(i, j+MN, 1);\n            }\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        mf.add(vs, i, 1);\n        mf.add(i+MN, vt, 1);\n    }\n    cout << l - mf.exec(vs, vt) << endl;\n    return true;\n}\n\nint main() {\n    while (true) {\n        if (!solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint to;\n\n\tEdge() {}\n\tEdge(int to):to(to) {}\n};\n\nstruct Graph : vector< vector<Edge> > {\n\tint numV;\n\tvector<bool> visited;\n\tvector<int> match;\n\n\tGraph(){}\n\n\tvoid init(int numV_) {\n\t\tnumV = numV_;\n\t\tassign(numV, vector<Edge>());\n\t}\n\n\tvoid init() {\n\t\tassign(numV, vector<Edge>());\n\t}\n\n\tvoid addUndirectedEdge(int from, int to) {\n\t\tat(from).push_back(Edge(to));\n\t\tat(to).push_back(Edge(from));\n\t}\n};\n\nGraph G;\n\nbool augment(Graph& graph, int v) {\n\tgraph.visited[v] = true;\n\tfor (int i = 0; i < (int)graph[v].size(); ++i) {\n\t\tint u = graph[v][i].to, w = graph.match[u];\n\t\tif (w < 0 || (!graph.visited[w] && augment(graph, w))) {\n\t\t\tgraph.match[v] = u;\n\t\t\tgraph.match[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint calcBipartiteMatching(Graph& graph) {\n\tgraph.match.assign(graph.numV, -1);\n\tgraph.visited.resize(graph.numV);\n\tfor (int v = 0; v < graph.numV; ++v) if (graph.match[v] < 0) {\n\t\tfill(graph.visited.begin(), graph.visited.end(), false);\n\t\taugment(graph, v);\n\t}\n\treturn (graph.numV - count(graph.match.begin(), graph.match.end(), -1)) / 2;\n}\n\nconst int MAX_N = 100;\nconst int MAX_Q = 1000;\nconst int INF = (int)(1.05e9); \n\nint N, M, L;\nint mat[MAX_N][MAX_N];\nint ps[MAX_Q], ts[MAX_Q];\n\ntemplate<typename numType>\ninline bool updateMin(numType& old, const numType& test) {\n\tif (old > test) {\n\t\told = test;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool init() {\n\tscanf(\"%d%d%d\", &N, &M, &L);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfill(mat[i], mat[i] + N, INF);\n\t}\n\n\tfor (int _ = 0; _ < M; ++_) {\n\t\tint from, to, cost;\n\t\tscanf(\"%d%d%d\", &from, &to, &cost);\n\t\tupdateMin(mat[from][to], cost);\n\t\tupdateMin(mat[to][from], cost);\n\t}\n\n\tfor (int i = 0; i < L; ++i) {\n\t\tscanf(\"%d%d\", ps + i, ts + i);\n\t}\n\n\treturn N > 0;\n}\n\nint solve() {\n\tG.init(2*L);\n\tfor (int k = 0; k < N; ++k) {\n\t\tmat[k][k] = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tupdateMin(mat[i][j], mat[i][k] + mat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < L; ++i) {\n\t\tfor (int j = 0; j < L; ++j) if (i != j) {\n\t\t\tif (ts[i] + mat[ps[i]][ps[j]] <= ts[j]) {\n\t\t\t\tG.addUndirectedEdge(2*i, 2*j+1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn L - calcBipartiteMatching(G);\n}\n\nint main() {\n\tfor (;init();) {\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n \n#define INF 100000000\n \nusing namespace std;\n \nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  fill(match,match+2001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+2001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main(void){  \n  int n,m,l,u,v,d,dist[101][101],graph[1001][1001],p[1001],t[1001];\n  \n  while(cin >> n >> m >> l,n|m|l){  \n    \n    for(int i=0;i<2001;i++)G[i].clear();\n    \n    fill(dist[0],dist[101],INF);\n    fill(graph[0],graph[1001],0);\n    \n    for(int i=0;i<101;i++)dist[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      dist[u][v]=dist[v][u]=d;\n    }\n    \n    for(int i=0;i<l;i++)\n      cin >> p[i] >> t[i];\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j && dist[p[i]][p[j]]+t[i]<=t[j])\n\t  graph[i][j]=1;\n    \n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[i][j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nbool G[2000][2000];\nint match[2000];\nbool used[2000];\n\nint V;\n\nvoid add_edge(int v, int u) {\n\tG[v][u] = G[u][v] = true;\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor(int i = 0; i < V; i++) {\n\t\tif(!G[v][i]) continue;\n\t\tint u = i, w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint calc() {\n\tint res = 0;\n\tfill(match, match + V, -1);\n\tfor(int v = 0; v < V; v++) {\n\t\tif(match[v] < 0) {\n\t\t\tfill(used, used + V, false);\n\t\t\tif(dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tV = 2 * L;\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tG[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tadd_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nbool G[1000][1000];\nint match[1000];\nbool used[1000];\n\nint V;\n\nvoid add_edge(int v, int u) {\n\tG[v][u] = G[u][v] = true;\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor(int i = 0; i < V; i++) {\n\t\tif(!G[v][i]) continue;\n\t\tint u = i, w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint calc() {\n\tint res = 0;\n\tfill(match, match + V, -1);\n\tfor(int v = 0; v < V; v++) {\n\t\tif(match[v] < 0) {\n\t\t\tfill(used, used + V, false);\n\t\t\tif(dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tV = 2 * L;\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tG[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tadd_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll, ll>\n#define pdd pair<double, double>\n#define f first\n#define s second\n#define MOD 1000000007\n#define mkp make_pair\n#define M_PI 3.14159265358979323846\n#define FOR(i,l,r) for (int i=l;i<=r;i++)\n#define FORD(i,r,l) for (int i=r;i>=l;i--)\n#define INF 1000000000\ntypedef long long ll;\n\n#define MAXN 105\n#define MAXL 1005\nint N,M,L;\nint dis[MAXN][MAXN];\npii mis[MAXL];\n\n#define MAXV 2100\nint V;//# of vertex \nvector<int> G[MAXV];\nint match[MAXV];\nint used[MAXV];\nvoid add_edge(int u, int v)\n{\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\nbool dfs(int u)\n{\n    used[u]=true;\n    for(int i = 0; i < G[u].size(); i++)\n    {\n        int v = G[u][i], w = match[v];\n        if(w<0 || !used[w]&&dfs(w) )\n        {\n            match[u]=v;\n            match[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bip_match()\n{\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0; v<V; v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used,0,sizeof(used));\n            if(dfs(v))res++;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    while(cin>>N>>M>>L&&(N+M+L))\n    {\n        V=L*2;\n        FOR(i,0,V-1)G[i].clear();\n        FOR(i,0,N-1)FOR(j,0,N-1)dis[i][j]=(i==j)?0:INF;\n        int a,b,c;\n        FOR(i,1,M)\n        {\n            cin>>a>>b>>c;\n            dis[a][b]=dis[b][a]=c;\n        }\n        FOR(k,0,N-1)FOR(i,0,N-1)FOR(j,0,N-1)\n            if(dis[i][k]+dis[k][j]<dis[i][j])\n                dis[i][j]=dis[i][k]+dis[k][j];\n        //get missions\n        FOR(i,0,L-1)cin>>mis[i].f>>mis[i].s;\n        //build graph\n        FOR(i,0,L-1)FOR(j,0,L-1)if(i!=j&&(mis[j].s-mis[i].s)>=dis[mis[i].f][mis[j].f])\n            add_edge(i,L+j);\n        cout<<L-bip_match()<<'\\n';\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF = 1e9;\n\nvoid dfs(vector< vector<int> > &G, vector<bool> &visited, int v){\n  visited[v] = true;\n  for(int i = 0; i < G[v].size(); ++i){\n    if(visited[G[v][i]]) continue;\n    dfs(G, visited, G[v][i]);\n    break;\n  }\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L, N){\n    vector< vector<int> > D(N, vector<int>(N, INF));\n    for(int i = 0; i < M; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      D[u][v] = d;\n      D[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) D[i][i] = 0;\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n    vector< pair<int,int> > V;\n    for(int i = 0; i < L; ++i){\n      int p, t;\n      cin >> p >> t;\n      V.emplace_back(t, p);\n    }\n    sort(V.begin(), V.end());\n    vector< vector<int> > G(L);\n    for(int i = 0; i < L; ++i){\n      for(int j = 0; j < i; ++j){\n        int p_i = V[i].second, t_i = V[i].first, p_j = V[j].second, t_j = V[j].first;\n        if(D[p_i][p_j] <= t_i - t_j) G[j].push_back(i);\n      }\n    }\n    vector<bool> visited(L, false);\n    int ans = 0;\n    for(int i = 0; i < L; ++i){\n      if(visited[i]) continue;\n      ++ans;\n      dfs(G, visited, i);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(u,a,b) for(int u=(a);u<(b);u++)\n#define rrep(u,a,b) for(int u=(b)-1;u>=(a);u--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct HopcroftKarp {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match, dist;\n\tvector<bool> used, alive;\n\tHopcroftKarp(int n) : n(n), g(n), match(n), dist(n), used(n), alive(n, true) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\twhile (true) {\n\t\t\tbuildAlternatingLevelGraph();\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint flow = 0;\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tif (match[u] == -1 && augment(u))\n\t\t\t\t\tflow++;\n\t\t\tif (flow == 0)break;\n\t\t\tcnt += flow;\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid buildAlternatingLevelGraph() {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int u = 0; u < n; u++)\n\t\t\tif (match[u] == -1) {\n\t\t\t\tq.emplace(u);\n\t\t\t\tdist[u] = 0;\n\t\t\t}\n\t\twhile (q.size()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w != -1 && dist[w] == -1) {\n\t\t\t\t\tdist[w] = dist[u] + 1;\n\t\t\t\t\tq.emplace(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tbool augment(int u) {\n\t\tused[u] = true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!alive[v])continue;\n\t\t\tint w = match[v];\n\t\t\tif (w == -1 || (!used[w] && dist[w] == dist[u] + 1 && augment(w))) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\tused[v] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\ntemplate<class T, class ...Tail>\nvoid tiedSort(vector<T> &a, vector<Tail>&... tail) {\n\tint n = a.size();\n\tusing S = tuple<T, Tail...>;\n\tvector<S> s(n);\n\tfor (int i = 0; i < n; i++)\n\t\ts[i] = make_tuple(a[i], tail[i]...);\n\tsort(s.begin(), s.end());\n\tfor (int i = 0; i < n; i++)\n\t\ttie(a[i], tail[i]...) = s[i];\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tstatic int g[110][110];\n\t\tmemset(g, 0x3f, sizeof(g));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\ttiedSort(t, p);\n\t\tHopcroftKarp hk(L + L);\n\t\tint source = hk.n - 2, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, i + 1, L) {\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\thk.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - hk.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> PII;\n\nconst int MAX=200;\nconst int INF=1<<28;\n\nint V;//number of vertex\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n\treturn;\n}\n\nbool dfs(int v)\n{\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++)\n\t{\n\t\tif(match[v]<0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint dp[100][100];\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n)\n\t{\n\t\tV=2*l;\n\t\trep(i,V)G[i].clear();\n\t\trep(i,n)rep(j,n)dp[i][j]=INF;\n\t\tint u,v,d;\n\t\trep(i,m)\n\t\t{\n\t\t\tcin>>u>>v>>d;\n\t\t\tdp[u][v]=d;\n\t\t\tdp[v][u]=d;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tPII p[1000];\n\t\trep(i,l)cin>>p[i].second>>p[i].first;\n\t\tsort(p,p+l);\n\t\trep(i,l)\n\t\t{\n\t\t\tint time=p[i].first;\n\t\t\tint to=p[i].second;\n\t\t\t\n\t\t\tfor(int j=i+1;j<l;j++)\n\t\t\t{\n\t\t\t\tif(p[j].first>=time+dp[to][p[j].second])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(i,l+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<l-bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e15;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// Dinic's algorithm.\n\ntypedef ll FLOW;       // Type of flow. int here.\nconst ll MAX_V = 2005;  // Maximum number of nodes in a graph.\n\nstruct Edge {\n  ll rev, from, to;\n  FLOW cap, icap; // icap: initial cap\n\n  Edge(ll r, ll f, ll t, FLOW c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n\n  friend ostream& operator << (ostream& s, const Edge& E) {\n    if (E.cap > 0) {\n      return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n    } else {\n      return s;\n    }\n  }\n};\n\nclass Graph {\npublic:\n  Graph(ll n = 0) : V(n) {\n    rep(i, MAX_V) { list[i].clear(); }\n  }\n\n  void init(ll n = 0) {\n    V = n;\n    rep(i, MAX_V) { list[i].clear(); }\n  }\n\n  void resize(ll n = 0) { V = n; }\n\n  void reset() {\n    rep(i, V) {\n      rep(j, list[i].size()) {\n        list[i][j].cap = list[i][j].icap;\n      }\n    }\n  }\n\n  inline vector<Edge>& operator [] (ll i) {\n    return list[i];\n  }\n\n  Edge &redge(Edge e) {\n    if (e.from != e.to) {\n      return list[e.to][e.rev];\n    } else {\n      return list[e.to][e.rev + 1];\n    }\n  }\n\n  void addedge(ll from, ll to, FLOW cap) {\n    list[from].push_back(Edge((ll)list[to].size(), from, to, cap));\n    list[to].push_back(Edge((ll)list[from].size() - 1, to, from, 0));\n  }\n\nprivate:\n  ll V;\n  vector<Edge> list[MAX_V];\n};\n\nstatic ll level[MAX_V];\nstatic ll iter[MAX_V];\n\nvoid dibfs(Graph &G, ll s) {\n  rep(i, MAX_V) { level[i] = -1; }\n  level[s] = 0;\n  queue<ll> que;\n  que.push(s);\n  while (!que.empty()) {\n    ll v = que.front();\n    que.pop();\n    rep(i, G[v].size()) {\n      Edge &e = G[v][i];\n      if (level[e.to] < 0 && e.cap > 0) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nFLOW didfs(Graph &G, ll v, ll t, FLOW f) {\n  if (v == t) { return f; }\n\n  for (ll &i = iter[v]; i < G[v].size(); ++i) {\n    Edge &e = G[v][i], &re = G.redge(e);\n    if (level[v] < level[e.to] && e.cap > 0) {\n      FLOW d = didfs(G, e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        re.cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n// Main function for calculatig maximum flow\nFLOW Dinic(Graph &G, int s, int t) {\n  FLOW res = 0;\n  while (true) {\n    dibfs(G, s);\n    if (level[t] < 0) { return res; }\n    memset(iter, 0, sizeof(iter));\n    FLOW flow;\n    while ((flow = didfs(G, s, t, INF)) > 0) {\n      res += flow;\n    }\n  }\n}\n\n// int main(int argc, char** argv) {\n//   int V, E;\n//   cin >> V >> E;\n//   Graph g(V);\n//   rep(i, E) {\n//     ll u, v, c;\n//     cin >> u >> v >> c;\n//     g.addedge(u, v, c);\n//   }\n//\n//   ll r = Dinic(g, 0, V - 1);\n//   cout << r << endl;\n// }\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  while (true) {\n    ll n,m,l;\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) { break; }\n\n    // initializatio\n    memset(level, 0, sizeof(level));\n    memset(iter, 0, sizeof(iter));\n\n    vector<vector<ll>> d1(n, vector<ll>(n,INF));\n    rep(i,n) { d1[i][i] = 0; }\n    while (m--) {\n      ll u,v,d;\n      cin >> u >> v >> d;\n      d1[u][v] = d;\n      d1[v][u] = d;\n    }\n    // Warshall-Floyd\n    rep(k,n) {\n      rep(u,n)rep(v,n) {\n        chmin(d1[u][v], d1[u][k] + d1[k][v]);\n      }\n    }\n    // printtree(d1);\n\n    vector<ll> p(l);\n    vector<ll> t(l);\n    rep(i,l) {\n      cin >> p[i] >> t[i];\n    }\n\n    Graph g(2*l+2); // DAG\n    rep(i,l)rep(j,l) {\n      if (i==j) { continue; }\n      if (t[i]+d1[p[i]][p[j]] <= t[j]) { // i->j is ok.\n        g.addedge(i,l+j,1);\n        // cout << \"(i,j):\" << i  << \",\" << j << endl;\n        // cout << \"(i,j+l):\" << i  << \",\" << j+l << endl;\n      }\n    }\n\n    // Add source and target\n    ll src = 2*l, tgt = 2*l+1;\n    rep(i,l) {\n      g.addedge(src,i,1);\n      g.addedge(l+i,tgt,1);\n    }\n\n    // cout << \"src: \" << src << endl;\n    // cout << \"tgt: \" << tgt << endl;\n    // rep(i,2*l+2) {\n    //   for (auto& e : g[i]) {\n    //     cout << e;\n    //   }\n    //   cout << endl;\n    // }\n\n    ll r = Dinic(g,src,tgt); // maximum matching\n\n    // cout << \"r: \" << r << endl;\n    cout << l-r << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef Int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, L+j, 0 ) );\n                    g[L+j].push_back( Edge( L+j, i, 0 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        bipartiteMatching( g, L, edges );\n        set <int> V;\n        int answer = L;\n        for ( int i = 0; i < (int)edges.size(); i++ ) {\n            if ( V.find( edges[i].dst ) == V.end() ) {\n                answer--;\n                V.insert( edges[i].dst );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n&&m&&l) {\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(i + 1, j + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n\nvector<int> gra[1005];\nint dis[105][105];\nint lin[1005][2];\nint n,m,l;\nint p[1005];\nbool vis[1005];\nbool find(int x)\n{\n    for(int i=0;i<gra[x].size();i++)\n        if(vis[gra[x][i]]==0)\n        {\n            vis[gra[x][i]]=1;\n            if(p[gra[x][i]]==0 || find(p[gra[x][i]]))\n            {\n                p[gra[x][i]]=x;\n                return 1;\n            }\n        }\n    return 0;\n}\nint max_match()\n{\n    memset(p,0,sizeof(p));\n    int ans=0;\n    for(int i=1;i<=l;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        ans+=find(i);\n    }\n    return ans;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&l))\n    {\n        if(n==0 && m==0 && l==0) break;\n        int x,y,w;\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                if(i==j) dis[i][j]=0;\n                else dis[i][j]=0x3fffffff;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&w);\n            dis[y][x]=dis[x][y]=min(dis[x][y],w);\n        }\n        for(int k=0;k<n;k++)\n            for(int i=0;i<n;i++)\n                for(int j=0;j<n;j++)\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n        for(int i=0;i<l;i++)\n            scanf(\"%d%d\",&lin[i][0],&lin[i][1]);\n        for(int i=0;i<=l;i++) gra[i].clear();\n        for(int i=0;i<l;i++)\n            for(int j=0;j<l;j++)\n                if(i!=j)\n                {\n                    if(dis[lin[i][0]][lin[j][0]]<=lin[i][1]-lin[j][1])\n                        gra[j+1].push_back(i+1);\n                }\n        printf(\"%d\\n\",l-max_match());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\nint n,m,l;\nbool t[2222][2222];\nbool use[2222];\nint from[2222],b[2222];\nint a[2222][2222];\nint p[2222],q[2222];\nint tot;\nbool match(int x)\n{\n    for (int i = 0; i < l; i++)\n        if (t[x][i + l] && !use[i + l])\n    {\n        use[i + l] = 1;\n        if (from[i + l] == -1 || match(from[i + l]))\n        {\n            from[i + l] = x;\n            return 1;\n        }\n    }\n    return 0;\n}\nint hungary()\n{\n    tot = 0;\n    memset(from,-1,sizeof(from));\n    for (int i = 0; i < l; i++)\n    {\n        memset(use,0,sizeof(use));\n        if (match(i)) tot++;\n    }\n    return tot;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&l);\n    while (!(n == 0 && m == 0 && l == 0))\n    {\n        int x,y,z;\n        memset(a,63,sizeof(a));\n        for (int i = 1; i <= m; i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&z);\n            a[x][y] = a[y][x] = z;\n        }\n        for (int k = 0; k < n; k++)\n            for (int i = 0; i < n; i++)\n              for (int j = 0; j < n; j++)\n                if (a[i][k] < 1000000000 && a[k][j] < 1000000000 && a[i][j] > a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j];\n        memset(b,0,sizeof(b));\n        for (int i = 0; i < l; i++)\n        {\n            scanf(\"%d%d\",&x,&y);\n            p[i] = x;\n            q[i] = y;\n        }\n        memset(t,0,sizeof(t));\n        for (int i = 0; i < l; i++)\n        {\n            for (int j = 0; j < l; j++)\n                if (i != j && q[j] >= q[i] && a[p[i]][p[j]] <= q[j] - q[i]) t[i][j + l] = 1;\n        }\n        int ans = l - hungary();\n        printf(\"%d\\n\",ans);\n        scanf(\"%d%d%d\",&n,&m,&l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{ int to,cap,rev; };\nclass Max_Flow{\npublic:\n\tvector<vector<edge>>G;\n\tvector<bool>used;int size__;\n\tvoid init(int _size){ G.resize(_size); used.resize(_size); size__=_size; }\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\t\tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n\t}\n\tint dfs(int v,int t,int f){\n\t\tif(v==t)return f;\n\t\tused[v]=true;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(!used[e.to] && e.cap>0){\n\t\t\t\tint d=dfs(e.to,t,min(t,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t){\n\t\tint ret=0;\n\t\twhile(true){\n\t\t\tfor(int j=0;j<size__;j++)used[j]=false;\n\t\t\tint f=dfs(s,t,1000000007);\n\t\t\tif(f==0)return ret;\n\t\t\tret+=f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint N,M,L,a,b,c,d[100][100],e1[1000],e2[1000];\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>L;if(N+M+L==0)break;\n\t\tfor(int i=0;i<N;i++){for(int j=0;j<N;j++)d[i][j]=1e9;d[i][i]=0;}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;d[b][a]=c;\n\t\t}\n\t\tfor(int k=0;k<N;k++){for(int i=0;i<N;i++){for(int j=0;j<N;j++){d[i][j]=min(d[i][j],d[i][k]+d[k][j]);}}}\n\t\tfor(int i=0;i<L;i++){\n\t\t\tcin>>e1[i]>>e2[i];\n\t\t}\n\t\tMax_Flow X;\n\t\tX.init(2*L+2);\n\t\tfor(int i=0;i<L;i++){\n\t\t\tfor(int j=0;j<L;j++){\n\t\t\t\tif(i==j || d[e1[i]][e1[j]]>e2[j]-e2[i])continue;\n\t\t\t\tX.add_edge(i,j+L,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<L;i++){X.add_edge(2*L,i,1);}\n\t\tfor(int i=0;i<L;i++){X.add_edge(i+L,2*L+1,1);}\n\t\tcout<<L-X.max_flow(2*L,2*L+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int NUM=110;\nconst int MAX=2010;\nconst int INF=0x7ffffff;\nint dis[NUM][NUM],p[MAX],t[MAX];\nint access[MAX][MAX],vis[MAX],match[MAX];\nvoid init(int n);\nbool dfs(int now,int m);\nint main()\n{\n    int n,m,l,u,v,x;\n    while(~scanf(\"%d%d%d\",&n,&m,&l)&&n+m+l)\n    {\n        init(n);\n        for (int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%d\",&u,&v,&x);\n            dis[u][v]=dis[v][u]=x;\n        }\n        for (int k=0; k<n; k++)\n            for (int i=0; i<n; i++)\n                for (int j=0; j<n; j++)\n                    if (dis[i][j]>dis[i][k]+dis[k][j])\n                        dis[i][j]=dis[i][k]+dis[k][j];\n        for (int i=0; i<l; i++)\n            scanf(\"%d%d\",&p[i],&t[i]);\n        for (int i=0; i<l; i++)\n            for (int j=0; j<l; j++)\n                if (i!=j&&t[i]+dis[p[i]][p[j]]<=t[j])\n                    access[2*i][2*j+1]=access[2*j+1][2*i]=1;\n        int num=0;\n        for (int i=0; i<2*l; i++)\n        {\n            if (match[i]<0)\n            {\n                memset(vis,0,sizeof vis);\n                if (dfs(i,2*l))\n                    num++;\n            }\n        }\n        printf(\"%d\\n\",l-num);\n    }\n    return 0;\n}\nvoid init(int n)\n{\n    memset(access,0,sizeof access);\n    memset(vis,0,sizeof vis);\n    memset(match,-1,sizeof match);\n    for (int i=0; i<n; i++)\n        for (int j=0; j<n; j++)\n            if (i!=j)\n                dis[i][j]=INF;\n}\nbool dfs(int now,int m)\n{\n    vis[now]=1;\n    for (int i=0; i<m; i++)\n    {\n        if (access[now][i])\n        {\n            if (match[i]==-1||!vis[match[i]]&&dfs(match[i],m))\n            {\n                match[i]=now;\n                match[now]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 300;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[1001];\n        fill(used,used+1001,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            ct=node=0;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i = v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int minTime=-1;\n                int idx=0;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i = v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=0){\n                        int nTime=ct-cost;;\n                        if(ct-cost>time)\n                            nTime=time;\n                        if(minTime<nTime){\n                            minTime=nTime;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(minTime==-1){\n                    break;\n                }\n                else{\n                    //  êÎAóÔðXV\n                    //ct=v[idx].first;\n                    ct=minTime;\n                    node=v[idx].second;\n                    used[idx]=true;\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,s,t) for(int i = s; i < t ; i++)\nusing VI = vector<int>;\n\nstruct Bipartite_Matching {\n\tvector<vector<int>> graph;\n\tvector<int> match, alive, used;\n\tint timestamp;\n\n\tBipartite_Matching(int n) {\n\t\ttimestamp = 0;\n\t\tgraph.resize(n);\n\t\talive.assign(n, 1);\n\t\tused.assign(n, 0);\n\t\tmatch.assign(n, -1);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = timestamp;\n\t\tfor (int i = 0; i < (int)graph[v].size(); i++) {\n\t\t\tint u = graph[v][i], w = match[u];\n\t\t\tif (alive[u] == 0) continue;\n\t\t\tif (w == -1 || (used[w] != timestamp && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t}\n\t\treturn (false);\n\t}\n\n\tint bipartite_matching() {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < (int)graph.size(); i++) {\n\t\t\tif (alive[i] == 0) continue;\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i);\n\t\t\t}\n\t\t}\n\t\treturn (ret);\n\t}\n};\n\n// N 600\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tusing LL = long long;\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tvector<vector<LL>>dist(N, vector<LL>(N, 1e18));\n\t\tFOR(i, 0, N) {\n\t\t\tdist[i][i] = 0;\n\t\t}\n\n\t\tFOR(i, 0, M) {\n\t\t\tLL a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tdist[a][b] = dist[b][a] = min(dist[a][b], c);\n\t\t}\n\t\tFOR(k, 0, N)FOR(i, 0, N)FOR(j, 0, N) {\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t\t// グラフはできたのでcheckをする\n\t\tBipartite_Matching F(2 * N);\n\t\tvector<LL>p(L), t(L); // L^2\n\t\tFOR(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\n\t\tFOR(i, 0, L) {\n\t\t\tFOR(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n#define IN(x) (x)\n#define OUT(x) (x+N)\n\t\t\t\tif (t[i]<=t[j] && t[i] + dist[p[i]][p[j]] <= t[j]) {\n\t\t\t\t\tF.add_edge(IN(p[i]),OUT(p[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - F.bipartite_matching() << endl;\n\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) y) { return (f)(begin(y), end(y), ## __VA_ARGS__); })(x)\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\n\nconst int inf = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, l; cin >> n >> m >> l;\n        if (n == 0 and m == 0 and l == 0) break;\n        vector<map<int,int> > g(n);\n        repeat (i,m) {\n            int u, v, d; cin >> u >> v >> d;\n            g[u][v] = d;\n            g[v][u] = d;\n        }\n        vector<int> p(l), t(l);\n        repeat (i,l) cin >> p[i] >> t[i];\n        // warshall floyd\n        vector<vector<int> > dist(n, vector<int>(n, inf));\n        repeat (i,n) dist[i][i] = 0;\n        repeat (i,n) for (auto it : g[i]) dist[i][it.first] = it.second;\n        repeat (k,n) repeat (i,n) repeat (j,n) setmin(dist[i][j], dist[i][k] + dist[k][j]);\n        // make a digraph of presents\n        vector<set<int> > h(l);\n        repeat (i,l) repeat (j,l) if (dist[p[i]][p[j]] <= t[j] - t[i]) h[i].insert(j);\n        vector<set<int> > rev(l);\n        repeat (i,l) for (int j : h[i]) rev[j].insert(i);\n        // run on the DAG\n        vector<int> que(l);\n        whole(iota, que, 0);\n        whole(sort, que, [&](int i, int j) { return t[i] < t[j]; });\n        vector<bool> has_santa(l);\n        int ans = 0;\n        for (int i : que) {\n            for (int j : rev[i]) if (has_santa[j]) {\n                has_santa[j] = false;\n                has_santa[i] = true;\n                break;\n            }\n            if (not has_santa[i]) {\n                has_santa[i] = true;\n                ans += 1;\n            }\n        }\n        // output\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstring>\n#include<functional>\n#include<fstream>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define f first\n#define s second\n\nint dist[100][100];\nint qt[1000];\nint qp[1000];\n\nclass Matching{\n  typedef vector<vector<int> > G;\n\n  vector<bool> visited;\n\n  const G &g; //g[i][j] = k <==> i is connected to k\n  int n; //number of node\n  int m; //number of left node\n\n  bool augment(int left) {\n    if (left < 0)\n      return true;\n    if (visited[left])\n      return false;\n    visited[left] = true;\n    REP(i, g[left].size()) {\n      int right = g[left][i];\n      if (augment(matching[right])) {\n        matching[right] = left;\n        return true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  vector<int> matching;\n\n  explicit Matching(const G &graph, int mm)\n    : g(graph), m(mm){\n    n = graph.size();\n  }\n\n  int solve() {\n    int matches = 0;\n    matching = vector<int>(n,-1);\n    visited = vector<bool>(n);\n    REP(left, n) {\n      visited.assign(n, false);\n      if (augment(left))\n        matches++;\n    }\n    return matches;\n  }\n};\n\n\ntypedef vector<vector<int> > G;\n\nG g;\n\nint main(){\n  int n,m,l;\n#define MAX 100000\n  while(cin>>n>>m>>l, n+m+l){\n    g = G(l+l);\n\n    REP(i,n) REP(j,n) dist[i][j] = (i==j ? 0 : MAX);\n\n    REP(i,m){\n      int a,b,d;\n      cin>>a>>b>>d;\n      dist[a][b] = dist[b][a] = d;\n    }\n    REP(i,l) cin>>qp[i]>>qt[i];\n\n    REP(k,n) REP(i,n) REP(j,n)\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    REP(i,l) REP(j,l) if(i!=j){\n      int pos1 = qp[i];\n      int pos2 = qp[j];\n      int t1 = qt[i];\n      int t2 = qt[j];\n\n      if(dist[pos1][pos2] != MAX && t1 + dist[pos1][pos2] <= t2)\n        g[i].push_back(j+l);\n    }\n\n    int ret = Matching(g, g.size()/2).solve();\n    printf(\"%d\\n\",l-ret);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\n\nconst int MAX_N = 102;\nconst int MAX_L = 1005;\nconst int MAX_V = MAX_N << 1;\n\n\nstruct Request\n{\n\tint p;\n\tint t;\n\tbool operator < (const Request & y)const\n\t{\n\t\treturn t < y.t;\n\t}\n}r[MAX_L];\n\nint G[MAX_V][MAX_V];\nint deg[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v);\nbool dfs(const int & v);\nint bipartite_matching(const int V);\n\nint MAT[MAX_N][MAX_N];\nint _min(const int & a, int b);\nvoid warshall_floyd(int n);\n\n\nint main()\n{\n\tint N, M, L, u, v, d;\n\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &L);\n\t\tif (!N)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tmemset(deg, 0, sizeof(deg));\n\t\tmemset(MAT, 8, sizeof(MAT));\n\n\t\twhile (M--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tMAT[u][v] = d;\n\t\t\tMAT[v][u] = d;\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tMAT[i][i] = 0;\n\t\t}\n\t\twarshall_floyd(N);\n\t\t\n\t\tfor (int i = 0; i < L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &r[i].p, &r[i].t);\n\t\t}\n\t\tsort(r, r + L);\n\n\t\tfor (int i = 1; i < L; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (r[i].t - r[j].t >= MAT[r[i].p][r[j].p])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(j, i + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", L - bipartite_matching(L << 1));\n\t}\n\t\n\treturn 0;\n}\n\nvoid add_edge(int u, int v)\n{\n\tG[u][deg[u]++] = v;\n\tG[v][deg[v]++] = u;\n}\n\nbool dfs(const int & v)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < deg[v]; i++)\n\t{\n\t\tconst int & u = G[v][i];\n\t\tconst int & w = match[u];\n\n\t\tif (w == -1 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(const int V)\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++)\n\t{\n\t\tif (match[v] == -1)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tres += dfs(v);\n\t\t}\n\t}\n\treturn res;\n}\n\nint _min(const int & a, int b)\n{\n\treturn a < b ? a : b;\n}\n\nvoid warshall_floyd(int n)\n{\n\tfor (int k = 0; k < n; k++)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tMAT[i][j] = _min(MAT[i][j], MAT[i][k] + MAT[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> struct edge\n{\n  int to;\n  T cap;\n  int reverse;\n  edge(int to, T cap, int reverse) : to(to), cap(cap), reverse(reverse) {}\n};\n\ntemplate <typename T> class Dinic\n{\nprivate:\n  static const T INF = (T)1000000000;\n  vector<edge<T> >* G;\n  int N;\n  int* level;\n  int* iter;\n\n  void bfs(int s);\n  T dfs(int v, int t, T f);\n\npublic:\n  Dinic(int N) : N(N) { this->init(); }\n  ~Dinic();\n  void init();\n  void addEdge(int from, int to, T cap);\n  T MaximumFlow(int s, int t);\n};\n\ntemplate<typename T> Dinic<T>::~Dinic()\n{\n  delete[] G;\n  delete[] level;\n  delete[] iter;\n}\n\ntemplate<typename T> void Dinic<T>::init()\n{\n  G = new vector<edge<T> >[N];\n  level = new int[N];\n  iter = new int[N];\n  rep(i, N) G[i].clear();\n}\n\ntemplate<typename T> void Dinic<T>::addEdge(int from, int to, T cap)\n{\n  G[from].pb(edge<T>(to, cap, G[to].size()));\n  G[to].pb(edge<T>(from, (T)0, G[from].size()-1));\n}\n\ntemplate<typename T> void Dinic<T>::bfs(int s)\n{\n  rep(i, N) level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();  que.pop();\n    vrep(w, G[v]){\n      edge<T>& e = *w;\n      if(e.cap > (T)0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\ntemplate<typename T> T Dinic<T>::dfs(int v, int t, T f)\n{\n  if(v == t) return f;\n  for(int& i = iter[v]; i<G[v].size(); i++){\n    edge<T>& e = G[v][i];\n    if(e.cap > (T)0 && level[v] < level[e.to]){\n      T d = dfs(e.to, t, min(f, e.cap));\n      if(d > (T)0){\n        e.cap -= d;\n        G[e.to][e.reverse].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\ntemplate<typename T> T Dinic<T>::MaximumFlow(int s, int t)\n{\n  T flow = (T)0;\n  while(true){\n    bfs(s);\n    if(level[t] < (T)0) return flow;\n    rep(i, N) iter[i] = 0;\n    T f;\n    while((f = dfs(s, t, Dinic::INF)) > (T)0){\n      flow += f;\n    }\n  }\n}\n\n\nint N, M, L;\nint u, v, dd;\nint d[111][111];\nint p[1111];\nint t[1111];\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> M >> L, N){\n    Dinic<int> dinic = Dinic<int>(2 * L + 2);\n    rep(i, N) rep(j, N) d[i][j] = INF;\n    rep(i, N) d[i][i] = 0;\n    rep(i, M){\n      cin >> u >> v >> dd;\n      d[u][v] = dd;\n      d[v][u] = dd;\n    }\n    rep(k, N) rep(i, N) rep(j, N) minup(d[i][j], d[i][k] + d[k][j]);\n    rep(i, L) cin >> p[i] >> t[i];\n    rep(i, L) rep(j, L) if(i != j && t[i] + d[p[i]][p[j]] <= t[j]) dinic.addEdge(i, j + L, 1);\n    int s = 2 * L;\n    int t = s + 1;\n    rep(i, L) dinic.addEdge(s, i, 1);\n    rep(j, L) dinic.addEdge(j + L, t, 1);\n    cout << L - dinic.MaximumFlow(s, t) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define house second\n#define time first\nconst int INF = 0xfffffff;\n\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nstruct edge {\n\tint to, cap, rev;\n\tedge(int t, int c, int r):to(t), cap(c), rev(r){}\n};\n\nvector<vector<edge> > G;\nvector<int> level;\nvector<int> iter;\n\nvoid init(int n) {\n\tG.clear();\n\tG.resize(n);\n\tlevel.clear();\n\tlevel.resize(n);\n\titer.clear();\n\titer.resize(n);\n}\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(int s) {\n\tfill(level.begin(), level.end(), -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\n\t\tfor(int i = 0; i < G[v].size(); ++i) {\n\t\t\tconst edge& e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t)\n\t\treturn f;\n\n\tfor(int& i = iter[v]; i < G[v].size(); ++i) {\n\t\tedge& e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\n\tfor(;;) {\n\t\tbfs(s);\n\t\tif(level[t] < 0)\n\t\t\treturn flow;\n\n\t\tfill(iter.begin(), iter.end(), 0);\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0)\n\t\t\tflow += f;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, l; cin >> n >> m >> l, n | m | l;) {\n\t\tvector<vector<int> > mat(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tmat[i][i] = 0;\n\t\t\t\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tmat[u][v] = mat[v][u] = d;\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tfor(int k = 0; k < n; ++k)\n\t\t\t\t\tchmin(mat[j][k], mat[j][i] + mat[i][k]);\n\n\t\tvector<pair<int, int> > p(l);\n\t\tfor(int i = 0; i < l; ++i)\n\t\t\tcin >> p[i].house >> p[i].time;\n\n\t\tsort(p.begin(), p.end());\n\n\t\tinit(l * 2 + 2);\n\t\tconst int s = l * 2, t = l * 2 + 1;\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\tadd_edge(s, i, 1);\n\t\t\tadd_edge(i + l, t, 1);\n\n\t\t\tfor(int j = i + 1; j < l; ++j) {\n\t\t\t\tif(p[i].time + mat[p[i].house][p[j].house] <= p[j].time)\n\t\t\t\t\tadd_edge(i, j + l, 1);\n\t\t\t}\n\t\t}\n\n\t\tcout << l - max_flow(s, t) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing std::min;\n\nconst int N = 100 + 10;\nconst int M = 2000 + 10;\n\nstd::vector<int> neighbors[M];\n\nusing std::pair;\nusing std::make_pair;\ntypedef pair<int, int> Pair;\n\nstd::vector<Pair> task;\nint map[N][N], dist[N][N];\nint n, m, task_count;\n\nint links[M];\nbool visit[M];\n\nbool find(int u) {\n\tif (visit[u]) {\n\t\treturn false;\n\t}\n\tvisit[u] = true;\n\tfor (int i = 0; i < neighbors[u].size(); ++ i) {\n\t\tint v = neighbors[u][i];\n\t\tif (links[v] == 0 || find(links[v])) {\n\t\t\tlinks[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid initialise() {\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tneighbors[i].clear();\n\t}\n\ttask.clear();\n\tmemset(map, 60, sizeof(map));\n\tmemset(dist, 60, sizeof(dist));\n\tmemset(links, 0, sizeof(links));\n}\n\nint main() {\n\twhile (scanf(\"%d%d%d\", &n, &m, &task_count) != EOF) {\n\t\tif (n + m + task_count == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tinitialise();\n\t\tfor (int i = 0; i < m; ++ i) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\t\tu ++, v ++;\n\t\t\tmap[u][v] = map[v][u] = dist[u][v] = dist[v][u] = min(map[u][v], w);\n\t\t}\n\t\tfor (int i = 1; i <= task_count; ++ i) {\n\t\t\tint node, time;\n\t\t\tscanf(\"%d%d\", &node, &time);\n\t\t\tnode ++;\n\t\t\ttask.push_back(make_pair(time, node));\n\t\t}\n\t\tstd::sort(task.begin(), task.end());\n\t\ttask.resize(unique(task.begin(), task.end()) - task.begin());\n\t\t\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\tdist[i][i] = 0;\n\t\t}\n\t\tfor (int k = 1; k <= n; ++ k) {\n\t\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\t\tif (i != k) {\n\t\t\t\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\t\t\t\tif (i != j && j != k) {\n\t\t\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s = task.size();\n\t\tfor (int i = 0; i < s; ++ i) {\n\t\t\tint u = task[i].second;\n\t\t\tfor (int j = i + 1; j < s; ++ j) {\n\t\t\t\tint v = task[j].second;\n\t\t\t\tif (task[j].first - task[i].first >= dist[u][v]) {\n\t\t\t\t\tneighbors[i + 1].push_back(j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tfor (int i = 1; i <= s; ++ i) {\n\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\ttotal += find(i);\n\t\t}\n\t\tprintf(\"%d\\n\", s - total);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define\tMAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[s]=dag[s][i],pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(cin>>N>>M>>L,N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w; cin>>u>>v>>w;\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)cin>>p[i]>>t[i];\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * Dinic?????????????????§???\n *\n * ?????¨???????????¬????????????\n * template?????°???int V???????????°\n */\nconst int INF = 1<<28;\ntemplate<int V>\nstruct MaxFlow {\n    typedef int T;\n    struct Edge {\n        int to, rev;\n        T cap;\n    };\n    vector<Edge> g[V];\n    int level[V];\n    int iter[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    void add_multi(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    void bfs(int s) {\n        fill_n(level, V, -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (Edge e: g[v]) {\n                if (e.cap <= 0) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap <= 0) continue;\n            if (level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d <= 0) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // s??????t???????????§????????????\n    T exec(int s, int t) {\n        T flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill_n(iter, V, 0);\n            T f;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\ntypedef pair<int, int> P;\nconst int MN = 110;\nconst int ML = 1100;\nMaxFlow<ML*2> mf;\n\nint dist[MN][MN];\nP qu[ML];\nbool solve() {\n    mf.init();\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (!n) return false;\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = 1e8;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j],\n                    dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n\n    for (int i = 0; i < l; i++) {\n        int p, t;\n        cin >> p >> t;\n        qu[i] = P(t, p);\n    }\n    sort(qu, qu+l);\n\n    int vs = 2*ML-1;\n    int vt = 2*ML-2;\n    for (int i = 0; i < l; i++) {\n        for (int j = i+1; j < l; j++) {\n            int ap, at, bp, bt;\n            tie(at, ap) = qu[i];\n            tie(bt, bp) = qu[j];\n            if (dist[ap][bp] <= bt - at) {\n                mf.add(i, j+MN, 1);\n            }\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        mf.add(vs, i, 1);\n        mf.add(i+MN, vt, 1);\n    }\n    cout << l - mf.exec(vs, vt) << endl;\n    return true;\n}\n\nint main() {\n    while (true) {\n        if (!solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nWeight INF=1e9;\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=false;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push(make_pair(Weight(0),s));\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push(make_pair(dist[e.to],e.to));\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\nint solve();\nint main(){\n    while(solve()){\n\n    }\n    return true;\n}\nint solve(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(n==0) return false;\n    vector<vector<int>> d(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        int dd;\n        cin>>dd;\n        d[u][v]=dd;\n        d[v][u]=dd;\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n    vector<int> p(l),t(l);\n    for(int i=0;i<l;i++) cin>>p[i]>>t[i];\n    vector<pair<int,int>> tp(l);\n    for(int i=0;i<l;i++) tp[i]={t[i],p[i]};\n    sort(tp.begin(),tp.end());\n    for(int i=0;i<l;i++){\n        t[i]=tp[i].first;\n        p[i]=tp[i].second;\n    }\n\n    Flow org(2*l+4);\n    //[0,l):in\n    int S=2*l;\n    int superS=2*l+1;\n    int T=2*l+2;\n    int superT=2*l+3;\n    \n    for(int i=0;i<l;i++){\n        org.addEdge(S,i,1,0);\n        org.addEdge(i+l,T,INF,0);\n        //org.addEdge(i,i+l,1,-1);\n        org.addEdge(i+l,i,1,1);\n        org.addEdge(superS,i+l,1,0);\n        org.addEdge(i,superT,1,0);\n    }\n\n    vector<vector<int>> town(l,vector<int>(n,0));\n    \n    for(int i=l-1;i>=0;--i){\n        for(int j=i+1;j<l;j++){\n            if(town[i][p[j]] || d[p[i]][p[j]]>t[j]-t[i]) continue;  \n            town[i][p[j]]=true;          \n            org.addEdge(i+l,j+l,INF,0);\n            org.addEdge(i+l,j,1,0);\n            for(int k=0;k<n;k++){\n                town[i][k]|=town[j][k];\n            }\n        }\n    }\n    int lb=0;\n    int ub=n;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        Flow flow=org;\n        flow.addEdge(superS,S,mid,0);\n        flow.addEdge(T,superT,mid,0);\n        int cost=flow.minCostFlow(superS,superT,mid+l);\n        cost-=l;\n        if(cost!=-l){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    cout<<ub<<endl;\n\n    return true;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 2525; // TODO:initialize\nconst int INF = 1010101010; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,G[to].size()});\n    G[to].pb({from,0,-cost,G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        pq.push(pi(0,s));\n        while(!pq.empty()){\n            pi p = pq.top();\n            pq.pop();\n            int v = p.se;\n            if(p.fi>dist[v]) continue;\n            rep(i,G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    pq.push(pi(dist[e.to],e.to));\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst int M=10;\nint d[100][100];\n\nint main()\n{\n    int n,m,R;\n    while(scanf(\" %d %d %d\", &n, &m, &R),n)\n    {\n        fill(d[0],d[100],INF);\n        rep(i,n) d[i][i]=0;\n        rep(i,m)\n        {\n            int u,v,c;\n            scanf(\" %d %d %d\", &u, &v, &c);\n            d[u][v] = d[v][u] = c;\n        }\n\n        rep(k,n)rep(i,n)rep(j,n) d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n        vector<pi> req(R);\n        rep(i,R)\n        {\n            int p,t;\n            scanf(\" %d %d\", &p, &t);\n            req[i] = pi(t,p);\n        }\n        sort(all(req));\n\n        int l=0,r=n;\n        while(r-l>1)\n        {\n            int mid = (l+r)/2;\n            V = 2*R + mid + 2;\n            int S = 2*R+mid, T = S+1;\n\n            rep(i,MAX_V) G[i].clear();\n\n            rep(i,mid)\n            {\n                add_edge(S,2*R+i,1,0);\n                rep(j,R) add_edge(2*R+i,2*j,1,0);\n                add_edge(2*R+i,T,1,0);\n            }\n            rep(i,R)\n            {\n                add_edge(2*i,2*i+1,1,-M);\n                add_edge(2*i+1,T,1,0);\n            }\n            rep(i,R)for(int j=i+1; j<R; ++j)\n            {\n                int ti = req[i].fi, tj = req[j].fi;\n                int u = req[i].se, v = req[j].se;\n                if(d[u][v]<=tj-ti) add_edge(2*i+1,2*j,1,0);\n            }\n\n            if(min_cost_flow(S,T,mid)==-R*M) r=mid;\n            else l=mid;\n        }\n        printf(\"%d\\n\", r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n \n#define INF 100000000\n \nusing namespace std;\n \nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n \nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res=0;\n  fill(match,match+2001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+2001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n \nint main(void){\n \n  int n,m,l,u,v,d,dist[101][101],graph[1001][1001],p[1001],t[1001];\n \n  while(cin >> n >> m >> l,n|m|l){  \n \n    for(int i=0;i<2001;i++)G[i].clear();\n \n    fill(dist[0],dist[101],INF);\n    fill(graph[0],graph[1001],0);\n\n    for(int i=0;i<101;i++)dist[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      dist[u][v]=dist[v][u]=d;\n    }\n     \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j && dist[p[i]][p[j]]+t[i]<=t[j])\n\t  graph[i][j]=1;\n\n    \n    for(int k=0;k<l;k++)\n      for(int i=0;i<l;i++)\n\tfor(int j=0;j<l;j++)\n\t  graph[i][j]|=graph[i][k]&graph[k][j];\n\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[i][j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Edge {\n\tint to, cap, rev;\n};\nvector< vector<Edge> > G;\nint dist[110][110];\n\nvoid add_edge(int from, int to, int cap) {\n//\tcout << from << \" \" << to << \" \" << cap << endl;\n\tG[from].pb({to, cap, (int)G[to].size()});\n\tG[to].pb({from, 0, (int)G[from].size()-1});\n}\nint cost[3000];\nvoid bfs(int s) {\n\tfill(cost, cost+3000, inf);\n\tqueue<int> Q; Q.push(s); cost[s] = 0;\n\twhile ( !Q.empty() ) {\n\t\tint v = Q.front(); Q.pop();\n\t\tEACH(e, G[v]) {\n\t\t\tif (e.cap > 0 && cost[v]+1 < cost[e.to]) {\n\t\t\t\tcost[e.to] = cost[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nbool used[3000];\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tif (used[s]) return 0;\n\tused[s] = true;\n\tEACH(e, G[s]) {\n\t\tif (e.cap > 0 && cost[e.to] == cost[s]+1) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (cost[t] == inf) break;\n\t\twhile (1) {\n\t\t\tfill(used, used+3000, false);\n\t\t\tint f = dfs(s, t, inf);\n\t\t\tif (f == 0) break;\n\t\t\tres += f;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n/*\n\tG.resize(4);\n\tadd_edge(0, 1, 5);\n\tadd_edge(0, 2, 4);\n\tadd_edge(1, 2, 3);\n\tadd_edge(1, 3, 10);\n\tadd_edge(2, 3, 5);\n\tcout << max_flow(0, 3) << endl;\n\treturn 0;\n*/\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tfill(dist[0], dist[110], inf);\n\t\tREP(i, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tdist[u][v] = min(dist[u][v], d);\n\t\t\tdist[v][u] = min(dist[v][u], d);\n\t\t}\n\t\tREP(i, N) dist[i][i] = 0;\n\t\tREP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvector<P> task(L);\n\t\tREP(i, L) {\n\t\t\tint p, t; cin >> p >> t;\n\t\t\ttask[i] = P(p, t);\n\t\t}\n\t\tint s = L*2, t = s+1;\n\t\tG = vector< vector<Edge> >(t+1);\n\t\tREP(i, L) REP(j, L) {\n\t\t\tif (i == j) continue;\n\t\t\tif (task[i].second+dist[task[i].first][task[j].first] > task[j].second) continue;\n\t\t\tadd_edge(i, L+j, 1);\n\t\t}\n\t\tREP(i, L) add_edge(s, i, 1);\n\t\tREP(i, L) add_edge(L+i, t, 1);\n\t\tcout << L - max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\ntypedef pair<int, int> P;\n\nint prevV[2100], prevE[2100];\nint dist[2100];\nint h[2100];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\tint V = G.size();\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+2100, INF);\n\t\tdist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.top(); Q.pop();\n\t\t\tint i = p.second;\n\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\tEdge& e = G[i][j];\n\t\t\t\tif (e.cap > 0 && dist[i]+e.cost+h[i]-h[e.to] < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[i]+e.cost+h[i]-h[e.to];\n\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\tprevE[e.to] = j;\n\n\t\t\t\t\tQ.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < V; ++i) h[i] += dist[i];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tm[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tm[u][v] = m[v][u] = d;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint s = 2*L+1, t = s+1;\n\t\tG.clear(); G.resize(t+1);\n\n\t\tvector<int> p(L), time(L);\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tcin >> p[i] >> time[i];\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tif (i != j && time[i] + m[p[i]][p[j]] <= time[j]) {\n\t\t\t\t\taddEdge(L+i, j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\taddEdge(s, i, 1, 0);\n\t\t\taddEdge(L+i, t, 1, 0);\n\t\t\taddEdge(i, L+i, 1, -1);\n\t\t}\n\n\t\tint r = 0;\n\t\tfill(&h[0], &h[0]+2100, 0);\n\t\tfor (int f = 1; f <= L; ++f) {\n\t\t\tr += flow(s, t, 1);\n\t\t\tif (r == -L) {\n\t\t\t\tcout << f << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nint n;\nvector<vector<int>> g;\nvector<int> match;\nvector<bool> used;\nvoid init(int n_) {\n\tn = n_;\n\tg.assign(n, vector<int>());\n\tmatch.assign(n, -1);\n\tused.assign(n, false);\n}\nvoid addEdge(int u, int v) {\n\tg[u].emplace_back(v);\n\tg[v].emplace_back(u);\n}\nbool augment(int v) {\n\tused[v] = true;\n\tfor (int u : g[v]) {\n\t\tint w = match[u];\n\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatching() {\n\tint cnt = 0;\n\tfill(match.begin(), match.end(), -1);\n\tfor (int v = 0; v < n; v++) {\n\t\tif (match[v] == -1) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (augment(v))cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tinit(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\taddEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,s,t) for(int i = s; i < t ; i++)\nusing VI = vector<int>;\n\nstruct Bipartite_Matching {\n\tvector<vector<int>> graph;\n\tvector<int> match, alive, used;\n\tint timestamp;\n\n\tBipartite_Matching(int n) {\n\t\ttimestamp = 0;\n\t\tgraph.resize(n);\n\t\talive.assign(n, 1);\n\t\tused.assign(n, 0);\n\t\tmatch.assign(n, -1);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = timestamp;\n\t\tfor (int i = 0; i < (int)graph[v].size(); i++) {\n\t\t\tint u = graph[v][i], w = match[u];\n\t\t\tif (alive[u] == 0) continue;\n\t\t\tif (w == -1 || (used[w] != timestamp && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t}\n\t\treturn (false);\n\t}\n\n\tint bipartite_matching() {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < (int)graph.size(); i++) {\n\t\t\tif (alive[i] == 0) continue;\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i);\n\t\t\t}\n\t\t}\n\t\treturn (ret);\n\t}\n};\n\n// N 600\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tusing LL = long long;\n\tint N, M, L;\n\twhile (cin >> N >> M >> L, N) {\n\t\tvector<vector<LL>>dist(N, vector<LL>(N, 1e18));\n\t\tFOR(i, 0, N) {\n\t\t\tdist[i][i] = 0;\n\t\t}\n\n\t\tFOR(i, 0, M) {\n\t\t\tLL a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tdist[a][b] = dist[b][a] = min(dist[a][b], c);\n\t\t}\n\t\tFOR(k, 0, N)FOR(i, 0, N)FOR(j, 0, N) {\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t\t// グラフはできたのでcheckをする\n\t\tBipartite_Matching F(2 * N);\n\t\tvector<LL>p(L), t(L); // L^2\n\t\tFOR(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\n\t\tFOR(i, 0, L) {\n\t\t\tFOR(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n#define IN(x) (x)\n#define OUT(x) (x+N)\n\t\t\t\tif (t[i] + dist[p[i]][p[j]] <= t[j]) {\n\t\t\t\t\tF.add_edge(IN(p[i]),OUT(p[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - F.bipartite_matching() << endl;\n\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//bigraph\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<limits>\n#include<utility>\n\n//#define c11\n#ifdef c11\n#include<unordered_set>\n#include<unordered_map>\n#endif\n\nusing namespace std;\ntypedef long long ll;\n#define ull unsigned long long\n#define PI acos(-1.0)\n#define eps 1e-12\n#define initz(x) memset(x,0,sizeof(x))\n#define initn1(x) memset(x,-1,sizeof(x))\n#define initm(x) memset(x,0x3f,sizeof(x))\n#define forn(i, n) for(int i = 0; i < (int) n; ++i)\n#define for1(i, n) for(int i = 1; i <= (int) n; ++i)\n#define fore(i, l, r) for(int i = (int) l; i <= (int) r; ++i)\n#define rforn(i, n) for(int i = (int) n - 1; i>= 0; --i)\n#define fi first\n#define se second\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\nconst int MAX_N = 120;\nconst int MAX_M = 1010;\n\ntypedef pair<ll, ll> P;\n\n\nvector<int> e[1010];\nbool checked[1010];\nint match[1010];\nint n1;\n\nint n, m;\nint d[110][110];\n\nint p[1010], t[1010];\n\nbool dfs(int u) {\n    for(vector<int>::iterator it = e[u].begin(); it != e[u].end(); ++it) {\n        int v = *it;\n        if (!checked[v]) {\n            checked[v] = 1;\n            int w = match[v];\n            if (w < 0 || dfs(w)) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint hungarin() {\n    initn1(match);\n    int ans = 0;\n    forn(i, n1) {\n        initz(checked);\n        if (dfs(i)) ans++;\n    }\n    return ans;\n}\nvoid floyd(int n) {\n    forn(k, n) {\n        forn(i, n) {\n            forn(j, n) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\n\n\nint main() {\n#ifndef ONLINE_JUDGE\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n//---------------------------------------------\n// YOUR CODE\n    while (scanf(\"%d%d%d\", &n, &m, &n1) != EOF && n) {\n        memset(d, 0x3f, sizeof(d));\n        for (int i = 0; i < n; ++i) d[i][i] = 0;\n        for (int i = 0; i < m; ++i) {\n            int u, v, c;\n            scanf(\"%d%d%d\", &u, &v, &c);\n            d[u][v] = d[v][u] = c;\n        }\n        floyd(n);\n        for (int i = 0; i < n1; ++i) {\n            scanf(\"%d%d\", &p[i], &t[i]);\n            e[i].clear();\n        }\n        for (int i = 0; i < n1; ++i) {\n            for (int j = 0; j < n1; ++j) {\n                if (i == j) continue;\n                if (t[i] + d[p[i]][p[j]] <= t[j]) {\n                    e[i].push_back(j);\n                }\n            }\n        }\n        printf(\"%d\\n\", n1 - hungarin());\n    }\n//---------------------------------------------\n#ifndef ONLINE_JUDGE\n    fclose(stdin);\n    fclose(stdout);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int INF = 1<<29;\nbool bipartite_matching_dfs(\n\tint v, const vector< vector<int> > &conn,\n\tvector<bool> &used, vector<int> &match)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < conn[v].size(); ++i){\n\t\tint u = conn[v][i], w = match[u];\n\t\tif(w < 0 || (!used[w] && bipartite_matching_dfs(w, conn, used, match))){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//O(E√V)\nint bipartite_matching(const vector< vector<int> > &conn){\n\tint res = 0;\n\tvector<int> match(conn.size(), -1);\n\tvector<bool> used(conn.size(), false);\n\tfor(int v = 0; v < conn.size(); ++v){\n\t\tif(match[v] < 0){\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif(bipartite_matching_dfs(v, conn, used, match)){ ++res; }\n\t\t}\n\t}\n\treturn res;\n}\n\nint n, m, l;\n\nint g[101][101];\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l, n){\n\t\tREP(i, n)REP(j, n) g[i][j] = i==j ? 0 : INF;\n\t\tREP(i, m){\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tvector<pii> q(l);\n\t\tREP(i, l) cin >> q[i].first >> q[i].second;\n\t\tvector<vi> gg(l*2);\n\t\tREP(i, l)REP(j, l)if(i!=j){\n\t\t\tconst int u = q[j].first;\n\t\t\tconst int v = q[i].first;\n\t\t\tconst int t = q[i].second - q[j].second;\n\t\t\tif(g[u][v] <= t){\n\t\t\t\tgg[j].emplace_back(l+i);\n\t\t\t\tgg[l+i].emplace_back(j);\n\t\t\t}\n\t\t}\n\t\tcout << l - bipartite_matching(gg) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cstring>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++(i))\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++(i))\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nvector<int> vv[2010];\nint match[2010];\nbool used[2010];\n\n\nbool matchdfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0;i < vv[v].size();i++)\n\t{\n\t\tint u = vv[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w))\n\t\t{\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint two_matching_max(int l)\n{\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l)\n\t{\n\t\tif(match[v] < 0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint cou = 0;\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l)\n\t{\n\t\tif(cou == 2)break;cou++;\n\n\t\tREP(i,2010)vv[i].clear();\n\t\tint dist[n+1][n+1] = {};\n\t\tREP(i,n+1)REP(j,n+1)\n\t\t{\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse dist[i][j] = 5e8;\n\t\t}\n\t\t\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\t\t\n\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t{\n\t\t\tdist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j]);\n\t\t}\n\t\t\n\t\tcout << n << ' ' << m << ' ' << l << endl;\n\t\tSHOW2d(dist,n,n);\n\t\t\n\t\tvector<pair<int,int> > v(l);\n\t\t\n\t\tREP(i,l)\n\t\t{\n\t\t\tint p,t;\n\t\t\tcin >> p >> t;\n\t\t\tv[i] = MP(t,p);\n\t\t}\n\t\t\t\t\n\t\tif(m == 0)\n\t\t{\n\t\t\tcout << n << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\t\n\t\tREP(i,l)rep(j,i,l)\n\t\t{\n\t\t\tif(i == j)continue;\n\t\t\tif(v[j].FI - v[i].FI >= dist[v[j].SE][v[i].SE])\n\t\t\t{\n\t\t\t\tvv[i].PB(l+j);\n\t\t\t\tvv[l+j].PB(i);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tint ret =  l - two_matching_max(2*l) ;\n\t\tcout << ret << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nvoid warshall_floyd(vector<vector<T>> &g) {\n    const auto INF = numeric_limits<T>::max();\n    int n = g.size();\n    for(int k = 0; k < n; k++) {\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(g[i][k] == INF || g[k][j] == INF) continue;\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            }\n        }\n    }\n}\nstruct HopcroftKarp {\n    vector<vector<int>> g;\n    vector<int> d, mch;\n    vector<bool> used, vv;\n    HopcroftKarp(int n, int m) : g(n), mch(m, -1), used(n) {}\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n    }\n    void bfs() {\n        d.assign(g.size(), -1);\n        queue<int> que;\n        for (int i = 0; i < g.size(); i++) {\n            if (!used[i]) {\n                que.emplace(i);\n                d[i] = 0;\n            }\n        }\n        while (!que.empty()) {\n            int a = que.front();\n            que.pop();\n            for (auto &b : g[a]) {\n                int c = mch[b];\n                if (c >= 0 && d[c] == -1) {\n                    d[c] = d[a] + 1;\n                    que.emplace(c);\n                }\n            }\n        }\n    }\n    bool dfs(int a) {\n        vv[a] = true;\n        for (auto &b : g[a]) {\n            int c = mch[b];\n            if (c < 0 || (!vv[c] && d[c] == d[a] + 1 && dfs(c))) {\n                mch[b] = a;\n                used[a] = true;\n                return (true);\n            }\n        }\n        return (false);\n    }\n    int bipartite_matching() {\n        int ret = 0;\n        while (true) {\n            bfs();\n            vv.assign(g.size(), false);\n            int flow = 0;\n            for (int i = 0; i < g.size(); i++) {\n                if (!used[i] && dfs(i)) ++flow;\n            }\n            if (flow == 0) return ret;\n            ret += flow;\n        }\n    }\n};\nbool solve() {\n  int n, m, l; cin >> n >> m >> l;\n  if(n == 0) return false;\n  vvi g(n, vi(n, INF));\n  for(int i=0;i<n;++i) {\n    g[i][i] = 0;\n  }\n  for(int i=0;i<m;++i) {\n    int u, v, d; cin >> u >> v >> d;\n    g[u][v] = d;\n    g[v][u] = d;\n  }\n  warshall_floyd(g);\n  vector<P> v(l);\n  for(int i=0;i<l;++i) {\n    cin >> v[i].second >> v[i].first;\n  }\n  sort(v.begin(), v.end());\n  HopcroftKarp match(l, l);\n  for(int i=0;i<l;++i) {\n    for(int j=i+1;j<l;++j) {\n      if(g[v[i].second][v[j].second] <= v[j].first - v[i].first) {\n        match.add_edge(i, j);\n      }\n    }\n  }\n  cout << l - match.bipartite_matching() << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    if(!solve()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n&&m&&l) {\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nvector<int> G[2111];\n\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( to );\n  G[to].push_back( from );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\n\nbool used[2111];\nint match[2111];\nint V;\n\nint dfs(int v){\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u = G[v][i], w = match[u];\n    if( w < 0 || (!used[w] && dfs(w)) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset( match, -1, sizeof(match) );\n  for(int v=0;v<V;v++){\n    if( match[v] < 0 ) {\n      memset( used, 0, sizeof ( used ) );\n      if( dfs( v ) ) res++;\n    }\n  }\n  return res;\n}\n\nint solve(){\n  return L - bipartite_matching();\n}\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n\n    for(int i=0;i<L;i++){\n      for(int j=i+1;j<L;j++){\n        ll len = W[pt[i].second][pt[j].second];\n        ll lt = pt[j].first - pt[i].first;\n        if( len <= lt )          \n          add_edge( i, L+j );\n      }\n    }\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n    V = 2 * L;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<utility>\n#define pb push_back\n#define sz(x) (int)x.size()\n#define scf scanf\n#define ptf printf\n#define forp(i,j,k) for(int i=j;i<k;i++)\n#define form(i,j,k) for(int i=j;i>k;i--)\nusing namespace std;\ntypedef long long LL;\nconst int N=1010,oo=1e8+10;\nint mp[N][N],dis[N][N],lk[N],p[N],t[N],u[N],l;\n\nint find(int x)\n{\n    forp(i,0,l)\n        if(mp[x][i]&&!u[i])\n        {\n            u[i]=1;\n            if(lk[i]==-1||find(lk[i]))\n            {\n                lk[i]=x;return 1;\n            }\n        }\n    return 0;\n}\n\nint main()\n{\n    int n,m;\n    scf(\"%d%d%d\",&n,&m,&l);\n    while(n||m||l)\n    {\n        forp(i,0,n)forp(j,0,n)dis[i][j]=oo;\n        int x,y,z;\n        forp(i,0,m)\n        {\n            scf(\"%d%d%d\",&x,&y,&z);\n            dis[y][x]=dis[x][y]=z;\n        }\n        forp(k,0,n)\n            forp(i,0,n)\n                forp(j,0,n)\n                    if(i!=j&&j!=k&&i!=k)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n        forp(i,0,l)scf(\"%d%d\",p+i,t+i);\n        memset(mp,0,sizeof(mp));\n        forp(i,0,l)forp(j,0,l)if(i!=j&&t[i]+dis[p[i]][p[j]]<=t[j])mp[i][j]=1;\n        memset(lk,-1,sizeof(lk));\n        int ans=0;\n        forp(i,0,l)\n        {\n            memset(u,0,sizeof(u));\n            if(find(i))ans++;\n        }\n        ptf(\"%d\\n\",l-ans);\n        scf(\"%d%d%d\",&n,&m,&l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint N, M, L;\nint G[101][101];\n\nstruct BM\n{\n  vector< vector<int> > graph;\n  vector<int> matched;\n  vector<bool> used;\n  BM(int V):graph(V), matched(V, -1), used(V, false){}\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  bool dfs(int u)\n  {\n    used[u] = true;\n    for(auto& v : graph[u]) {\n      int w = matched[v];\n      if(w < 0 || !used[w] && dfs(w)) {\n\tmatched[u] = v;\n\tmatched[v] = u;\n\treturn true;\n      }\n    }\n    return false;\n  }\n  int match()\n  {\n    int res = 0;\n    for(int u = 0; u < graph.size(); u++) {\n      if(matched[u] < 0) {\n\tused.clear(); used.resize(graph.size(), false);\n\tif(dfs(u)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> L, N) {\n    rep(i, 101) rep(j, 101) G[i][j] = (i == j ? 0 : inf);\n    rep(i, M) {\n      int u, v, d;\n      cin >> u >> v >> d;\n      G[u][v] = G[v][u] = d;\n    }\n    rep(i, N) rep(j, N) rep(k, N) {\n      G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n    }\n    vector<int> p(L), t(L);\n    rep(i, L) cin >> p[i] >> t[i];\n    BM bm(2*L);\n    rep(i, L) rep(j, L) if(i != j) {\n      if(t[i] + G[p[i]][p[j]] <= t[j]) bm.add_edge(i, j + L);\n    }\n    cout << L - bm.match() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAXN 3001  //X驛ィ蛻?噪譛?、ァ鬘カ轤ケ謨ー\n#define MAXM 3001 //Y驛ィ蛻?噪譛?、ァ鬘カ轤ケ謨ー\n#define _clr(x,y) memset(x,y,sizeof(x))\n\nstruct Node\n{\n\tint to;\n\tint next;\n}edge[MAXN*MAXM]; //驍サ謗・陦ィ菫晏ュ倩セケ菫。諱ッ\n\nint n,m;\nint tot;\n\nint head[MAXN];\nint matchx[MAXN],matchy[MAXM];\nint disx[MAXN],disy[MAXM];\n\ninline void add_edge(int a,int b)   //豺サ蜉?黒蜷題セケ\n{\n\tedge[tot].to=b;\n\tedge[tot].next=head[a];\n\thead[a]=tot++;\n}\n\nbool BFS()  //隶。邂苓鰍轤ケ荳咲嶌莠、逧?アよャ。蝗セ\n{\n\tint i;\n\tint h=0,t=0;\n\tint q[MAXN];\n\tbool flag=false;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(matchx[i]==-1)\n\t\t{\n\t\t\tq[t++]=i;\n\t\t}\n\t}\n\t_clr(disx,0);\n\t_clr(disy,0);\n\twhile(h<t)\n\t{\n\t\tint x=q[h++];\n\t\tfor(i=head[x];i!=-1;i=edge[i].next)\n\t\t{\n\t\t\tint y=edge[i].to;\n\t\t\tif(!disy[y])\n\t\t\t{\n\t\t\t\tdisy[y]=disx[x]+1;\n\t\t\t\tif(matchy[y]==-1)\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdisx[matchy[y]]=disy[y]+1;\n\t\t\t\t\tq[t++]=matchy[y];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\n\nbool find(int x)  // dfs豐ソ螻よャ。蝗セ蟇サ謇セ蠅槫ケソ霍ッ\n{\n\tfor(int i=head[x];i!=-1;i=edge[i].next)\n\t{\n\t\tint y=edge[i].to;\n\t\tif(disy[y]==disx[x]+1)\n\t\t{\n\t\t\tdisy[y]=0;\n\t\t\tif(matchy[y]==-1 || find(matchy[y]))\n\t\t\t{\n\t\t\t\tmatchx[x]=y;\n\t\t\t\tmatchy[y]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint Hopcroft_Karp()\n{\n\tint cnt=0;\n\t_clr(matchx,-1);\n\t_clr(matchy,-1);\n\twhile(BFS())\n\t{\n\t\tfor(int x=1;x<=n;x++) // 螟夊キッ蠅槫ケソ\n\t\t{\n\t\t\tif(matchx[x]==-1 && find(x))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint g[210][210];\nint a[210],b[210];\n\nvoid Floyed(int len)\n{\n    int i,j,k;\n    for(k=0;k<len;k++)\n        for(i=0;i<len;i++)\n            for(j=0;j<len;j++)\n                {\n                   /* if(i==j)\n                        continue;*/\n                    g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n                }\n}\n\nint main()\n{\n    int mm,nn,k,i,j;\n    while(scanf(\"%d %d %d\",&mm,&nn,&k),mm||nn||k)\n    {\n        memset(head,-1,sizeof(head));\n        tot=0;\n        for(i=0;i<110;i++)\n            for(j=0;j<110;j++)\n                g[i][j]=i!=j?10000001:0;\n        for(i=0;i<nn;i++)\n        {\n            int u,v,w;\n            scanf(\"%d %d %d\",&u,&v,&w);\n            g[u][v]=g[v][u]=min(g[u][v],w);\n        }\n        Floyed(mm);\n        for(i=1;i<=k;i++)\n        {\n            scanf(\"%d %d\",&a[i],&b[i]);\n        }\n        n=110,m=10000;\n        for(i=1;i<=k;i++)\n            for(j=1;j<=k;j++)\n                if(i!=j &&g[a[i]][a[j]]<=b[j]-b[i])\n                    add_edge(i,j);\n        printf(\"%d\\n\",k-Hopcroft_Karp());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, j+L, 1 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        int answer = L - bipartiteMatching( g, L, edges );\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\n\ntypedef int Cost;Cost CINF=1<<28;\nnamespace EGraph{\n\tstruct Edge{\n\t\tint from,to;Cost cost;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost) {};\n\t\tbool operator<(Edge r) const{\n\t\t\treturn cost<r.cost;\n\t\t}\n\t\tbool operator>(Edge r) const{\n\t\t\treturn cost>r.cost;\n\t\t}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nnamespace MGraph{\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\nusing namespace EGraph;\n\nnamespace MaximamFlows{\n    typedef int Flow;\n    const int INF = 1 << 28;\n    struct Edge{\n        int to;Flow cap;int rev;\n        Edge(int to,Flow cap,int rev) : to(to),cap(cap),rev(rev) {};\n    };\n    typedef vector<vector<Edge> > Graph;\n\n    //dinic O(V^2*E)\n    class MaximamFlow{\n    private:\n           //iter　次に調べる時の開始位置 距離\n        vector<int> iter,dist;\n         //sからのbfs距離の計算\n        void bfs_dist(int s){\n            fill(ALL(dist),-1);dist[s]=0;\n            queue<int> que;que.push(s);\n            while(!que.empty()){\n                int v=que.front();que.pop();\n                EACH(e,G[v]){\n                    if(e->cap>0 && dist[e->to] == -1){\n                        dist[e->to]=dist[v]+1;\n                        que.push(e->to);\n                    }\n                }\n            }\n        }\n            //増加パス\n        Flow dfs_best_path(int v,int t,Flow f){\n            if(v==t)return f;\n            for(int &i =iter[v];i<(int)G[v].size();i++){\n                Edge& e=G[v][i];\n                if(e.cap>0 && dist[v]<dist[e.to]){\n                    Flow d=dfs_best_path(e.to,t,min(f,e.cap));\n                    if(d>0){\n                        e.cap-=d;G[e.to][e.rev].cap+=d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n    public:\n        int V;Graph G;\n        MaximamFlow(int V):V(V){\n            G=Graph(V);\n            dist=vector<int>(V);iter=vector<int>(V);\n        }\n\n        void add_edge(int from,int to,int cap){\n            int fromrev=G[to].size(),torev=G[from].size();\n            G[from].push_back(Edge(to,cap,fromrev));G[to].push_back(Edge(from,0,torev));\n        }\n        int max_flow(int s,int t){\n            Flow flow=0;\n            while(true){\n                bfs_dist(s);\n                if(dist[t]<0)return flow;\n                fill(ALL(iter),0);\n                Flow f;\n                while((f=dfs_best_path(s,t,INF))>0)flow+=f;\n            }return -1;\n        }\n    };\n}\nusing namespace MaximamFlows;\n\nclass Main{\npublic:\n\tint N,M,L;\n\tMat g;\n\tvector<int> ps,ts;\n\tbool input(){\n\t\tnextInt(N);nextInt(M);nextInt(L);if(N==0)return false;\n\t\tg=Mat(N,vector<Cost>(N,CINF));\n\t\tREP(i,N)g[i][i]=0;\n\t\tREP(i,M){\n\t\t\tint u,v,d;nextInt(u);nextInt(v);nextInt(d);\n\t\t\tg[u][v]=g[v][u]=d;\n\t\t}\n\t\tps=vector<int>(L);ts=vector<int>(L);\n\t\tREP(i,L){\n\t\t\tnextInt(ps[i]);nextInt(ts[i]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run(){\n\t\twhile(input()){\n\t\t\twarshall_floyd(g);\n\t\t\tMaximamFlow mf(2*L+2);\n\t\t\tREP(i,L)REP(j,L)if(g[ps[i]][ps[j]]<=ts[j]-ts[i] &&i!=j){\n\t\t\t\tmf.add_edge(i, L+j,1);\n\t\t\t}\n\t\t\tREP(i,L)mf.add_edge(2*L,i,1);\n\t\t\tREP(j,L)mf.add_edge(L+j,2*L+1,1);\n\n\t\t\tcout <<L-mf.max_flow(2*L, 2*L+1)<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n/*\ntypedef int weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n*/\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main()\n{\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n)\n\t{\n\t\tvector<vi> dist(n, vi(n));\n\t\tREP(i, n)REP(j, n) dist[i][j] = (i == j ? 0 : INF);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tGraph g(2*l + 2);\n\t\tREP(i, l)\n\t\t{\n\t\t\tadd_edge(g, 2 * l, i, 1);\n\t\t\tadd_edge(g, l + i, 2 * l + 1, 1);\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) cin >> p[i] >> t[i];\n\t\tREP(i, l)REP(j, l)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (dist[p[i]][p[j]] <= t[j] - t[i]) add_edge(g, i, j+l, 1);\n\t\t}\n\t\tcout << l - ford_fulkerson(g, 2 * l, 2 * l + 1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\n// Dinic を信じろ\n\ntemplate <typename CapTp=int, typename CostTp=int>\nstruct Edge {\n    int to, rev;\n    CapTp cap; CostTp cost;\n    bool is_rev;\n    Edge(int t, bool f, int r, CapTp ca, CostTp co=0)\n        : to(t), rev(r), cap(ca), cost(co), is_rev(f) {}\n};\n\ntemplate<typename CapTp=int>\nstruct Dinic {\n    using Graph = vector< vector< Edge<CapTp> > >;\n    Graph G;\n    vector<int> level, iter;\n    const CapTp IA;\n    vector< pair<int, int> > r_edges;\n    Dinic(int N, CapTp IA_=1<<29) : IA(IA_) {\n        G.resize(N);\n        level.resize(N);\n        iter.resize(N);\n    }\n    void add_edge(int from, int to, CapTp cap) {\n        G[from].emplace_back(to, false, G[to].size(), cap);\n        G[to].emplace_back(from, true, G[from].size() - 1, 0);\n        r_edges.emplace_back(to, G[to].size() - 1);\n    }\n    CapTp get_flowed_cap(size_t k) {\n        if(r_edges.size() <= k) return -1;\n        int v, i; tie(v, i) = r_edges[k];\n        return G[v][i].cap;\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que; que.push(s);\n        level[s] = 0;\n        while(!que.empty()) {\n            int temp = que.front(); que.pop();\n            for(size_t i=0; i<G[temp].size(); i++) {\n                auto &e = G[temp][i];\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[temp] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    CapTp dfs(int v, int t, CapTp f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(int)G[v].size(); i++) {\n            auto &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                CapTp d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    CapTp max_flow(int s, int t) {\n        CapTp flow = 0.0, f;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            while( (f = dfs(s, t, IA)) > 0 ) flow += f;\n        }\n    }\n};\n\n// 最小流量制約付きフロー\n// u から v に最小 lb, 最大 ub 流す\ntemplate<typename flow_type>\nstruct Dinic_lr {\n    Dinic<flow_type> fl;\n    int S, T;\n    flow_type sum_lb;\n\n    Dinic_lr() {}\n    Dinic_lr(int N) : fl(N+2, 0), S(N), T(N+1), sum_lb(0) {}\n\n    void add_edge(int u, int v, flow_type lb, flow_type ub) {\n        assert(0 <= lb && lb <= ub);\n        if(u == v || ub == 0) return;\n        fl.add_edge(u, v, ub - lb);\n        fl.add_edge(S, v, lb);\n        fl.add_edge(u, T, lb);\n        sum_lb += lb;\n    }\n\n    flow_type max_flow(int s, int t) {\n        flow_type a = fl.max_flow(S, T);\n        flow_type b = fl.max_flow(s, T);\n        flow_type c = fl.max_flow(S, t);\n        flow_type d = fl.max_flow(s, t);\n        return (a + c == sum_lb && a + b == sum_lb) ? b + d : -1;\n    }\n};\n\n\nint solve_testcase() {\n    int N, M, L; cin >> N >> M >> L;\n    if(N == 0 and M == 0 and L == 0) return 1;\n    \n    const int INF = 1 << 29;\n    vector< vector<int> > D(N, vector<int>(N, INF));\n    for(int i=0; i<N; i++) D[i][i] = 0;\n\n    for(int i=0; i<M; i++) {\n        int u, v, d; cin >> u >> v >> d;\n        D[u][v] = D[v][u] = d;\n    }\n\n    for(int k=0; k<N; k++) {\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n            }\n        }\n    }\n\n    vector< pair<int, int> > order;\n    for(int i=0; i<L; i++) {\n        int p, t; cin >> p >> t;\n        order.emplace_back(t, p);\n    }\n    sort(order.begin(), order.end());\n\n    Dinic<int> fl(L*2 + 2);\n    int source = L*2, sink = source + 1;\n    for(int i=0; i<L; i++) {\n        fl.add_edge(source, i, 1);\n        fl.add_edge(L+i, sink, 1);\n    }\n    for(int i=0; i<L; i++) {\n        for(int j=i+1; j<L; j++) {\n            int t1 = order[i].first, t2 = order[j].first;\n            int p1 = order[i].second, p2 = order[j].second;\n            int d = D[p1][p2];\n            if(t1 + d <= t2) {\n                // fprintf(stderr, \"i = %d, j = %d\\n\", i, j);\n                fl.add_edge(i, L+j, 1);\n            }\n        }\n    }\n    cout << L - fl.max_flow(source, sink) << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int t, int c, int r):to(t),cap(c),rev(r){}\n\tedge(){}\n};\n\nint dfs(int v, int g, int flow, vector<vector<edge> >& adj, vector<bool>& used){\n\tif(used[v]) return -1;\n\tused[v] = true;\n\tif(v == g) return flow;\n\t\n\tfor(int i=0; i<(int)adj[v].size(); i++){\n\t\tedge& next = adj[v][i];\n\t\tif(next.cap > 0){\n\t\t\tint ret = dfs(next.to, g, min(flow, next.cap), adj, used);\n\t\t\tif(ret > 0){\n\t\t\t\tnext.cap -= ret;\n\t\t\t\tadj[next.to][next.rev].cap += ret;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint maxflow(int s, int g, vector<vector<edge> > &graph){\n\tint res = 0;\n\twhile(1){\n\t\tvector<bool> used((graph.size()+1)*2, false);\n\t\tint ret = dfs(s, g, inf, graph, used);\n\t\tif(ret==-1) break;\n\t\tres += ret;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > adj(n, vector<int>(n, inf));\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tadj[u][v] = adj[v][u] = d;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> p(l), t(l);\n\t\tfor(int i=0; i<l; i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\t\n\t\tvector<vector<edge> > bg((l+1)*2);\n\t\tfor(int i=0; i<l; i++){\n\t\t\tfor(int j=0; j<l; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(t[i] +adj[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tbg[i].push_back(edge(l+j, 1, bg[l+j].size()));\n\t\t\t\t\tbg[l+j].push_back(edge(i, 0, bg[i].size()-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<l; i++){\n\t\t\tbg[2*l].push_back(edge(i, 1, bg[i].size()));\n\t\t\tbg[i].push_back(edge(2*l, 0, bg[2*l].size()-1));\n\t\t\tbg[l+i].push_back(edge(2*l+1, 1, bg[2*l+1].size()));\n\t\t\tbg[2*l+1].push_back(edge(l+1, 0, bg[l+1].size()-1));\n\t\t}\n\t\tcout << l -maxflow(2*l, 2*l+1, bg) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\n#include <cstring>\n\n#define MAX_V 1001\n#define INF 100000000\n\nvoid add_edge(int,int);\nbool dfs(int);\nint bipartite_matching(int);\nvoid warshall_floyd(int);\n\nusing namespace std;\n\nvector<int>G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V],d[MAX_V][MAX_V];\n\n\n\nint main(void){\n  int n,m,l,p[MAX_V],t[MAX_V];\n\n  while(scanf(\"%d %d %d\",&n,&m,&l),n,m,l){\n    for(int i=0;i<MAX_V*2;i++)G[i].clear();\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  d[i][j]= i==j ?0:INF;\n\n      for(int i=0;i<m;i++){\n\t  int a,b,c; \n\t  scanf(\"%d %d %d\",&a,&b,&c);\n\t  d[a][b]=d[b][a]=c;\n\t}\n      warshall_floyd(n);\n\n      for(int i=0;i<l;i++)\n\tscanf(\"%d %d\",&p[i],&t[i]);\n\n      for(int i=0;i<l;i++){\n\tfor(int j=0;j<l;j++){\n\t  if(i==j)continue;\n\t  else if(t[i]+d[p[i]][p[j]]<=t[j])\n\t    add_edge(i,j+l);\n\t}\n      }\n\n      cout << l-bipartite_matching(2*l) << endl;\n    }\n  return 0;\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i < G[v].size();i++){\n    int u= G[v][i],w=match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\n\nint bipartite_matching(int V){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nvoid warshall_floyd(int V){\n  for(int i = 0; i < V; i++){\n    for(int j = 0; j < V; j++){\n      for(int k = 0; k < V; k++){\n\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * Dinic?????????????????§???\n *\n * ?????¨???????????¬????????????\n * template?????°???int V???????????°\n */\nconst int INF = 1<<28;\ntemplate<int V>\nstruct MaxFlow {\n    typedef int T;\n    struct Edge {\n        int to, rev;\n        T cap;\n    };\n    vector<Edge> g[V];\n    int level[V];\n    int iter[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    void add_multi(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    void bfs(int s) {\n        fill_n(level, V, -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (Edge e: g[v]) {\n                if (e.cap <= 0) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap <= 0) continue;\n            if (level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d <= 0) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // s??????t???????????§????????????\n    T exec(int s, int t) {\n        T flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill_n(iter, V, 0);\n            T f;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\ntypedef pair<int, int> P;\nconst int MN = 110;\nconst int ML = 1100;\nMaxFlow<MN*2> mf;\n\nint dist[MN][MN];\nP qu[ML];\nbool solve() {\n    mf.init();\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (!n) return false;\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = 1e8;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j],\n                    dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n\n    for (int i = 0; i < l; i++) {\n        int p, t;\n        cin >> p >> t;\n        qu[i] = P(t, p);\n    }\n    sort(qu, qu+l);\n\n    int vs = 2*MN-1;\n    int vt = 2*MN-2;\n    for (int i = 0; i < l; i++) {\n        for (int j = i+1; j < l; j++) {\n            int ap, at, bp, bt;\n            tie(at, ap) = qu[i];\n            tie(bt, bp) = qu[j];\n            if (dist[ap][bp] <= bt - at) {\n                mf.add(i, j+MN, 1);\n            }\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        mf.add(vs, i, 1);\n        mf.add(i+MN, vt, 1);\n    }\n    cout << l - mf.exec(vs, vt) << endl;\n    return true;\n}\n\nint main() {\n    while (true) {\n        if (!solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(scanf(\"%d%d%d\",&N,&M,&L),N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n      d[u][v]=d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)scanf(\"%d%d\",&p[i],&t[i]);\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    printf(\"%d\\n\",num);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge\n{\n  ll to, cap, rev;\n};\n\nconst int MAX_N = 100;\n// const int MAX_M = 1000;\nconst int MAX_L = 1000;\nconst int MAX_V = MAX_L + MAX_L + 2;\nconst int INF = 1 << 29;\n\nvector< edge > G[MAX_V];\nbool used[MAX_V];\n\nvoid init_G()\n{\n  for (int v = 0; v < MAX_V; v++)\n    G[v].clear();\n}\n\nvoid add_edge(int from, int to, ll cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nll dfs(int v, int t, ll f)\n{\n  if (v == t)\n    return f;\n\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); i++)\n  {\n    edge &e = G[v][i];\n\n    if (!used[e.to] && e.cap > 0)\n    {\n      ll d = dfs(e.to, t, min(e.cap, f));\n\n      if (d > 0)\n      {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nll max_flow(const int s, const int t)\n{\n  ll flow = 0;\n\n  for (;;)\n  {\n    memset(used, false, sizeof used);\n    ll f = dfs(s, t, INF);\n\n    if (f == 0)\n      return flow;\n    else\n      flow += f;\n  }\n}\n\nint dist[MAX_N][MAX_N];\n\nvoid init_dist()\n{\n  for (int n1 = 0; n1 < MAX_N; n1++)\n    for (int n2 = 0; n2 < MAX_N; n2++)\n      dist[n1][n2] = n1 == n2 ? 0 : INF;\n}\n\nvoid warshall_floyd(int N)\n{\n  for (int k = 0; k < N; k++)\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < N; j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n}\n\nint N, M, L;\nint ps[MAX_L], ts[MAX_L];\n\nvoid solve()\n{\n  init_G();\n\n  warshall_floyd(N);\n\n  const int s = L + L, t = s + 1;\n\n  for (int i = 0; i < L; i++)\n    add_edge(s, i, 1);\n\n  for (int i = 0; i < L; i++)\n    add_edge(i + L, t, 1);\n\n  for (int i = 0; i < L; i++)\n    for (int j = 0; j < L; j++)\n      if (i != j && dist[ps[i]][ps[j]] + ts[i] <= ts[j])\n        add_edge(i, j + L, 1);\n\n  printf(\"%lld\\n\", L - max_flow(s, t));\n}\n\nint main()\n{\n  while (true)\n  {\n    scanf(\"%d%d%d\", &N, &M, &L);\n    if (N == 0 && M == 0 && L == 0)\n      break;\n\n    init_dist();\n\n    for (int m = 0; m < M; m++)\n    {\n      int u, v, d;\n      scanf(\"%d%d%d\", &u, &v, &d);\n      dist[u][v] = d;\n      dist[v][u] = d;\n    }\n\n    for (int l = 0; l < L; l++)\n      scanf(\"%d%d\", ps + l, ts + l);\n\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace flow {\n\nclass bipartite_matching {\nprivate:\n\n  int V;\n  vector<vector<int>> G;\n  vector<int> match;\n  vector<bool> used;\n\n  bool dfs(int v) {\n    used[v] = 1;\n    for(auto& u: G[v]) {\n      int w = match[u];\n      if(w < 0 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n\npublic:\n\n  bipartite_matching(int V): V(V) {\n    G.resize(V), match.resize(V), used.resize(V);\n  }\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  int maximum_matching() {\n    int ret = 0;\n    match.clear(), match.resize(V, -1);\n    rep(v, V) {\n      if(match[v] < 0) {\n        used.clear(), used.resize(V, 0);\n        if(dfs(v)) { ret ++; }\n      }\n    }\n    return ret;\n  }\n};\n\n}\n\nint main() {\n\n  int N, M, L;\n  while(cin >> N >> M >> L && (N|M|L)) {\n    int D[N][N]; rep(i, N) rep(j, N) D[i][j] = inf; rep(i, N) D[i][i] = 0;\n    rep(i, M) {\n      int u, v, d; cin >> u >> v >> d;\n      minimize(D[u][v], d);\n      minimize(D[v][u], d);\n    }\n\n    int P[L], T[L];\n    rep(i, L) {\n      cin >> P[i] >> T[i];\n    }\n\n    rep(k, N) rep(i, N) rep(j, N) {\n      minimize(D[i][j], D[i][k] + D[k][j]);\n    }\n\n    flow::bipartite_matching bp(2 * L);\n\n    rep(i, L) rep(j, L) {\n      if(i == j) continue;\n      if(D[P[i]][P[j]] <= T[j] - T[i]) {\n        bp.add_edge(i, L + j);\n      }\n    }\n\n    cout << L - bp.maximum_matching() << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=2006, E=5000006, INF=0x3fffffff;\n\nstruct ARC\n{\n    int u, next;\n    void init(int a, int b)\n    {\n        u=a, next=b;\n    }\n} arc[E];\nint head[N], tot;\n\nvoid add_edge(int s, int t)\n{\n    arc[tot].init(t, head[s]);\n    head[s]=tot++;\n}\n\nint n, m, nn, mm, L;\nbool vs[N];\nint G[106][106], id[N], T[N], mth_L[N], mth_R[N];\n\nbool Find(int u)\n{\n    if(vs[u]) return false;\n    vs[u]=true;\n    for(int e=head[u]; e!=-1; e=arc[e].next)\n    {\n        int v=arc[e].u;\n        if(mth_R[v]==-1 || Find(mth_R[v]))\n        {\n            mth_L[u]=v, mth_R[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint MaxMatch()\n{\n    int ans=0;\n    memset(mth_L, -1, sizeof mth_L);\n    memset(mth_R, -1, sizeof mth_R);\n    for(bool flag=false; 1; flag=false)\n    {\n        memset(vs, 0, sizeof vs);\n        for(int i=0; i<n; i++)\n            if(mth_L[i]==-1 && Find(i)) ans++, flag=true;\n        if(!flag) return ans;\n    }\n}\n\nvoid Floyd() {\n\tfor(int k=0; k<nn; k++)\n\t\tfor(int i=0; i<nn; i++)\n\t\t\tfor(int j=0; j<nn; j++) {\n\t\t\t\tif(G[i][k]==INF || G[k][j]==INF) continue;\n\t\t\t\tG[i][j]=min(G[i][j], G[i][k]+G[k][j]);\n\t\t\t}\n}\n\nint main() {\n\twhile(scanf(\"%d%d%d\", &nn, &mm, &L), nn!=0 || mm!=0 || L!=0) {\n\t\tfor(int i=0; i<nn; i++)\n\t\t\tfor(int j=0; j<nn; j++) G[i][j]=INF;\n\t\tfor(int i=0, a, b, c; i<mm; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tG[a][b]=G[b][a]=min(G[a][b], c);\n\t\t}\n\t\tFloyd();\n\t\tfor(int i=0; i<L; i++) scanf(\"%d%d\", &id[i], &T[i]);\n\t\tn=L;\n\t\tmemset(head, -1, sizeof head);\n\t\ttot=0;\n\t\tfor(int i=0; i<L; i++)\n\t\t\tfor(int j=0; j<L; j++) {\n\t\t\t\tint u=id[i], v=id[j];\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(G[u][v]==INF) continue;\n\t\t\t\tif(T[i]+G[u][v]>T[j]) continue;\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\tprintf(\"%d\\n\", L-MaxMatch());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#define INF 1<<28\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[2005];\nbool used[2005];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge& e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,false,sizeof(used));\n\t\tint f=dfs(s,t,1);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint n,m,l;\nint dist[101][101];\nint p[1001],t[1001];\n\nvoid solve(){\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint S=l*2,T=S+1;\n\tfor(int i=0;i<=T;i++){\n\t\tG[i].clear();\n\t}\n\tfor(int i=0;i<l;i++){\n\t\tadd_edge(S,i,1);\n\t\tadd_edge(l+i,T,1);\n\t\tfor(int j=0;j<l;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(dist[p[i]][p[j]]<=t[j]-t[i]){\n\t\t\t\tadd_edge(i,l+j,1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",l-max_flow(S,T));\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n+m+l==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=INF;\n\t\t\t}\n\t\t\tdist[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tdist[a][b]=c;\n\t\t\tdist[b][a]=c;\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tscanf(\"%d%d\",&p[i],&t[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nint flow[2005][2005], capa[2005][2005],L,v[2020];\nbool DAG[1005][1005];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int u, int v, int w)\n{\n\tflow[v][u]+=w;\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\tnode[u].to.push_back(v);\n\tnode[v].to.push_back(u);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=capa[p][next]-flow[p][next];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]+=f;\n\t\t\tflow[next][p]-=f;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]-flow[n][next] <= 0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid Connect(int u, int v, int w, vector<Node>& graph)\n{\n\tgraph[u].to.push_back(v);\n\tgraph[v].to.push_back(u);\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\t\n\tflow[v][u]+=w;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(capa, 0, sizeof(capa));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\tfor(int j=0; j<L; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t{\n\t\t\t\tDAG[i][j]=1;\n\t\t\t\tbeg[j]=1;\n\t\t\t\tend[i]=1;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]) \n\t\t\t{\n\t\t\t\tConnect(node, SOUR, i, INF);\n\t\t\t}\n\t\t\tif(!end[i]) \n\t\t\t{\n\t\t\t\tConnect(node, L+i, SINK, INF);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]&&!end[i])\n\t\t\t{\n\t\t\t\tConnect(node, i, L+i, 1);\n\t\t\t}\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(DAG[i][j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j,1);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dinic(SOUR,SINK,node));\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nbool flow[2005][2005];\nbool DAG[1005][1005];\nint L,v[2020];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int u, int v)\n{\n\tflow[v][u]=1;\n\tnode[u].to.push_back(v);\n\tnode[v].to.push_back(u);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=(flow[p][next]?0:1);\n\t\tif(p==SOUR||p==SINK) fw=1;\n\t\t\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]=1;\n\t\t\tflow[next][p]=0;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(flow[n][next]) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tConnect(node, SOUR, i);\n\t\t\tConnect(node, L+i, SINK);\n\t\t\t\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", L-dinic(SOUR,SINK,node));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\nint v[100][100];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tREP(i, n)REP(j, n)v[i][j] = INF;\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min_int(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n  for(i=0;i<l;i++) printf(\"%3d\",pathParent[i]);\n  printf(\"\\n\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++) find(i);\n  for(int i=0;i<l;i++) if(pathParent[i]<0) num++;\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(scanf(\"%d%d%d\",&N,&M,&L),N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)scanf(\"%d%d\",&p[i],&t[i]);\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MAX_V 1000\n#define INF 1000000000\nusing namespace std;\n\nint N, M, L, V;\n\nstruct vertex{\n\tint v, time;\n\tbool operator < (const vertex& other){\n\t\treturn time < other.time;\n\t}\n}data[MAX_V];\nint d[100][100];\n\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tfill(d[i], d[i]+N, INF);\n\t\td[i][i] = 0;\n\t}\n\tfor(int i = 0; i < V; i++) G[i].clear();\n}\nvoid floyd_warshall(){\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>N>>M>>L){\n\t\tif(!(N&&M&&L)) break;\n\t\tV = L;\n\t\tinit();\n\t\twhile(M--){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][b] = c; \n\t\t\td[b][a] = c;\n\t\t}\n\t\tfloyd_warshall();\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tscanf(\"%d%d\", &data[i].v, &data[i].time);\n\t\t}\n\t\tsort(data, data+V);\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = i+1; j < V; j++){\n\t\t\t\tint u = data[i].v, v = data[j].v;\n\t\t\t\tif(data[i].time+d[u][v] <= data[j].time){\n\t\t\t\t\tadd_edge(i, j);\n\t\t\t\t//\tprintf(\"u = %d, v = %d\\n\",u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", V - bipartite_matching());\n\t\t\t\t\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge\n{\n    int to,cap,rev;\n};\n\nconst int MAX_N = 1002;\n\nint d[102][102];\nvector<edge> G[2*MAX_N];\nint level[2*MAX_N];\nint iter[2*MAX_N];\nint n,m,L;\n\nvoid warshall_floyd()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,n){\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> L;\n        if(n == 0 && m == 0 && L == 0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = INF;\n            }\n        }\n        rep(i,n){\n            d[i][i] = 0;\n        }\n        rep(i,m){\n            int x,y,z;\n            cin >> x >> y >> z;\n            d[x][y] = z;\n            d[y][x] = z;\n        }\n        vector<int> p(L),t(L);\n        rep(i,L){\n            cin >> p[i] >> t[i];\n        }\n        warshall_floyd();\n        rep(i,2*L+2){\n            G[i].clear();\n        }\n        rep(i,L){\n            rep(j,L){\n                if(i != j){\n                    if(t[i] + d[p[i]][p[j]] <= t[j]){\n                        add_edge(i+1,L+j+1,INF);\n                    }\n                }\n            }\n        }\n        rep(i,L){\n            add_edge(0,i+1,1);\n            add_edge(L+i+1,2*L+1,1);\n        }\n        cout << L - max_flow(0,2*L+1) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m,l;\nint d[100][100];\nint t[1000],pl[1000];\nvector<vi> e;\n\nint p[2000]; bool v[2000];\nbool rec(int s)\n{\n\tif(s<0)return 1;\n\tfr(i,e[s])if(!v[*i])\n\t{\n\t\tv[*i]=1;\n\t\tif(rec(p[*i]))return p[s]=*i,p[*i]=s,1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&n,&m,&l),n)\n\t{\n\t\trep(i,n)rep(j,n)d[i][j]=i==j?0:inf;\n\t\trep(i,m)\n\t\t{\n\t\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\t\td[a][b]=d[b][a]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\n\t\trep(i,l)scanf(\"%d%d\",pl+i,t+i);\n\t\te.clear(); e.resize(2*l);\n\t\trep(i,l)rep(j,l)if(i!=j&&d[pl[i]][pl[j]]<=t[j]-t[i])\n\t\te[i].pb(j+l),e[j+l].pb(i);\n\t\t\n\t\tint ans=l;\n\t\trep(i,2*l)p[i]=-1;\n\t\trep(i,l)\n\t\t{\n\t\t\trep(j,2*l)v[j]=0;\n\t\t\tif(rec(i))ans--;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint biMatch(const vector<vector<int>>& adj, int ln) { // adj: [0,ln)->inL [ln,n)->inR\n    int n = adj.size();\n    vector<int> matchTo(n, -1);\n    vector<bool> used(n, false);\n    function<bool(int)> dfs = [&](int v) {\n        for(int nv : adj[v]) if(!used[nv]) {\n            used[nv] = true;\n            if(matchTo[nv] < 0 || dfs(matchTo[nv])) {\n                matchTo[v] = nv;\n                matchTo[nv] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int ans = 0;\n    for(int v : in(ln)) if(matchTo[v] < 0) {\n        used.assign(n, false);\n        if(dfs(v)) ++ans;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    const int INF(1e9);\n    int n, m, q;\n    while(cin >> n >> m >> q && n) {\n        vector<vector<int>> dist(n, vector<int>(n, INF));\n        for(int i : in(n)) dist[i][i] = 0;\n        for(int _ : in(m)) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            dist[u][v] = dist[v][u] = d;\n        }\n        for(int k : in(n))\n            for(int i : in(n))\n                for(int j : in(n))\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        vector<pair<int, int>> query(q);\n        for(auto& p : query) cin >> p.first >> p.second;\n        vector<vector<int>> adj(q * 2);\n        for(const auto& p1 : query) {\n            int u, v;\n            tie(u, ignore) = p1;\n            for(const auto& p2 : query) {\n                tie(v, ignore) = p2;\n                int t = p2.second - p1.second;\n                if(t <= 0 || dist[u][v] > t) continue;\n                v += q;\n                adj[u].emplace_back(v);\n                adj[v].emplace_back(u);\n            }\n        }\n        cout << q - biMatch(adj, q) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nstruct edge{\n  int to,rev,f;\n};\nvector<edge> G[1111];\nint Gh[1005][1005];\n\nbool used[1111];\nbool memo[1111];\n\nvoid init(){\n  memset(Gh,0,sizeof(Gh));\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( (edge){to,G[to].size(),1} );\n  G[to].push_back( (edge){from,G[from].size()-1,0} );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\nbool check(){\n  for(int i=0;i<L;i++) {\n    //cout <<i << \" : \" << used[i] << endl;\n    if( !used[i] ) return false;\n  }\n  return true;\n}\n\nbool dfs(int id){\n  if( memo[id] ) return false;\n  memo[id] = true;\n  for(int i=0;i<(int)G[id].size();i++){\n    edge &e= G[id][i];\n    //  cout << \"edge \" << id << \" -> \" << e.to << \" \" << e.f << endl;\n    if( e.f ) {\n      if( dfs(e.to) ){\n        e.f = 0;\n        G[e.to][e.rev].f = 1;\n        break;\n      }\n    }\n  }\n  // cout << \"in dfs\" << id<< \": \" <<used[id] << endl;\n  if( !used[id] ) return used[id] = true;\n  return false;\n}\n\nint solve(){\n  for(int i=1;i<N;i++){\n    memset(memo,0,sizeof(memo));\n    dfs(L);\n    //cout<<i << endl;\n    if( check() ) return i;\n  }\n  return N;\n}\n\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n    for(int i=0;i<L;i++)\n      swap( pt[i].first, pt[i].second );    \n\n    for(int i=0;i<L;i++){\n      for(int j=0;j<L;j++){\n        if( i == j ) continue;\n        ll len = W[pt[i].first][pt[j].first];\n        ll lt = pt[j].second - pt[i].second;\n        if( len <= lt )          \n          add_edge( i, j );\n      }\n    }\n    for(int i=0;i<L;i++)\n      add_edge(L,i);\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n\n    used[L] = true;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF 999999999\n\ntypedef pair<int,int> P;\n\nint n, m, l;\nint t[102][102];\nP p[2002];\n\nint V;\nvector<int> G[2002];\nint match[2002];\nbool used[2002];\n\nvoid floyd(){\n  for(int k = 0; k < n; k++){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        if(i == j) continue;\n        t[i][j] = min(t[i][j], t[i][k] + t[k][j]);\n      }\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    t[i][i] = 0;\n  }\n}\n\nvoid mkGraph(){\n  sort(p, p + l);\n  V = l * 2;\n\n  for(int i = 0; i < V; i++){\n    G[i].clear();\n  }\n\n  for(int i = 0; i < l; i++){\n    for(int j = i + 1; j < l; j++){\n      if(p[i].first + t[p[i].second][p[j].second] <= p[j].first){\n        G[i].push_back(l + j);\n        G[l + j].push_back(i);\n      }\n    }\n  }\n}\n\nbool dfs(int v){\n  used[v] = true;\n\n  for(int i = 0; i < G[v].size(); i++){\n    int u = G[v][i];\n    int w = match[u];\n\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m >> l, n || m || l){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        t[i][j] = INF;\n      }\n    }\n\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      t[a][b] = t[b][a] = c;\n    }\n\n    for(int i = 0; i < l; i++){\n      cin >> p[i].second >> p[i].first;\n    }\n\n    floyd();\n    mkGraph();\n    cout << l - bipartite_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> PII;\n\nconst int MAX=2000;\nconst int INF=1<<28;\n\nint V;//number of vertex\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n\treturn;\n}\n\nbool dfs(int v)\n{\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++)\n\t{\n\t\tif(match[v]<0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint dp[100][100];\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l,n)\n\t{\n\t\tV=2*l;\n\t\trep(i,V)G[i].clear();\n\t\trep(i,n)rep(j,n)dp[i][j]=INF;\n\t\tint u,v,d;\n\t\trep(i,m)\n\t\t{\n\t\t\tcin>>u>>v>>d;\n\t\t\tdp[u][v]=d;\n\t\t\tdp[v][u]=d;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tPII p[1000];\n\t\trep(i,l)cin>>p[i].second>>p[i].first;\n\t\tsort(p,p+l);\n\t\trep(i,l)\n\t\t{\n\t\t\tint time=p[i].first;\n\t\t\tint to=p[i].second;\n\t\t\t\n\t\t\tfor(int j=i+1;j<l;j++)\n\t\t\t{\n\t\t\t\tif(p[j].first>=time+dp[to][p[j].second])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(i,l+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<l-bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 5000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<vector<char> >,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint n, m, l;\nint dist[100][100];\nint p[1000], t[1000];\n\nvoid solve(){\n    rep(i,MAX_V) G[i].clear();\n    rep(i,n) rep(j,n) dist[i][j] = INF;\n    rep(i,n) dist[i][i] = 0;\n    rep(i,m){\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    rep(i,n) rep(j,n) rep(k,n) dist[j][k] = min(dist[j][k],dist[j][i]+dist[i][k]);\n    rep(i,l){\n        cin >> p[i] >> t[i];\n    }\n    rep(i,l){\n        rep(j,l){\n            if(i == j) continue;\n            if(dist[p[i]][p[j]] <= t[j]-t[i]){\n                add_edge(i,j+l,1);\n            }\n        }\n    }\n    rep(i,l) add_edge(2*l,i,1);\n    rep(i,l) add_edge(i+l,2*l+1,1);\n    cout << l-max_flow(2*l,2*l+1) << endl;\n}\n\nint main(){\n    while(cin >> n >> m >> l){\n        if(n == 0 && m == 0 && l == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <map>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\nll inf = 1e15;\n\nclass network_flow{\nprivate:\n\tint N;\n\tstruct edge{int to; ll cap; int rev;};\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\tvoid bfs(int s){\n\t\tfor(int i=0;i<=N;i++) level[i] = -1;\n\t\tqueue<int> Q;\n\t\tlevel[s] = 0;\n\t\tQ.push(s);\n\t\twhile(!Q.empty()){\n\t\t\tint v = Q.front(); Q.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll dfs(int v,int t,ll f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(level[v]<level[e.to] && e.cap>0){\n\t\t\t\tll d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tnetwork_flow(int n){\n\t\tN = n;\n\t\tG = vector<vector<edge>>(N+1);\n\t\tlevel = iter = vector<int>(N+1);\n\t}\n\tvoid add_edge(int from, int to,ll cap){\n\t\tG[from].push_back((edge){to,cap,(int) G[to].size()});\n\t\tG[to].push_back((edge){from,0,(int) G[from].size()-1});\n\t}\n\tll max_flow(int s,int t){\n\t\tll flow = 0;\n\t\tfor(;;){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\tfor(int i=0;i<=N;i++) iter[i] = 0;\n\t\t\tll f;\n\t\t\twhile((f=dfs(s,t,inf))>0) flow += f;\n\t\t}\n\t}\n};\n\nll solve(int N,int M,int L,vector<vector<ll>>& G,vector<ll> &P,vector<ll> &T){\n    network_flow flow(2*L+2);\n    for(int i=0;i<L;i++){\n        flow.add_edge(0,i+1,1);\n        flow.add_edge(i+L+1,2*L+1,1);\n        for(int j=0;j<L;j++){\n            if(i==j) continue;\n            if(T[i]+G[P[i]][P[j]]<=T[j]){\n                flow.add_edge(i+1,j+L+1,1);\n            }\n        }\n    }\n    return L-flow.max_flow(0,2*L+1);\n}\n\nint main(){\n    int N,M,L;\n    while(cin >> N >> M >> L && N){\n        vector<vector<ll>> G(N,vector<ll>(N,inf));\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a][b] = c;\n            G[b][a] = c;\n        }\n        for(int k=0;k<N;k++) for(int i=0;i<N;i++) for(int j=0;j<N;j++){\n            G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n        }\n        for(int i=0;i<N;i++) G[i][i] = 0;\n        vector<ll> P(L),T(L);\n        for(int i=0;i<L;i++) cin >> P[i] >> T[i];\n        cout << solve(N,M,L,G,P,T) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nint n,m,L;\nstruct nod\n{\n    int id;\n    int t;\n}nd[105];\n\nint dist[105][105];\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef double DB;\n\nconst int N = 50005;\nconst int E = 1000005;\nconst int inf = 1000000000;\nstruct Edge\n{\n    int en,cap,flow,next;\n} edge[E];\n\nint head[N] , now[N];\nint src,dest,node,nedge;\nint pre[N] , dis[N] , gap[N];\n\nvoid add_edge(int st,int en,int cap)\n{\n    edge[nedge].en=en;\n    edge[nedge].cap=cap;\n    edge[nedge].flow=0;\n    edge[nedge].next=head[st];\n    head[st]=nedge++;\n\n    edge[nedge].en=st;\n    edge[nedge].cap=0;\n    edge[nedge].flow=0;\n    edge[nedge].next=head[en];\n    head[en]=nedge++;\n}\n\nvoid augment(int flow)\n{\n    for(int i=src;i!=dest;i=edge[now[i]].en)\n    {\n        edge[now[i]].flow+=flow;\n        edge[now[i]^1].flow-=flow;\n    }\n}\n\nint sap()\n{\n    memset(dis,0,sizeof(dis));\n    memset(gap,0,sizeof(gap));\n    memset(pre,-1,sizeof(pre));\n    for(int i=0;i<node;i++)\n        now[i]=head[i];\n    gap[0]=node;\n    int point=src,flow=0,min_flow=inf;\n    while(dis[src]<node)\n    {\n        bool fg=false;\n        for(int i=now[point];~i;i=edge[i].next)\n            if(edge[i].cap-edge[i].flow>0 && dis[point]==dis[edge[i].en]+1)\n            {\n                min_flow=min(min_flow,edge[i].cap-edge[i].flow);\n                now[point]=i;\n                pre[edge[i].en]=point;\n                point=edge[i].en;\n                if(point==dest)\n                {\n                    flow+=min_flow;\n                    augment(min_flow);\n                    point=src;\n                    min_flow=inf;\n                }\n                fg=true;\n                break;\n            }\n        if(fg) continue;\n        if(--gap[dis[point]]==0) break;\n        int Min=node;\n        for(int i=head[point];~i;i=edge[i].next)\n            if(edge[i].cap-edge[i].flow>0 && Min>dis[edge[i].en])\n            {\n                Min=dis[edge[i].en];\n                now[point]=i;\n            }\n        gap[dis[point]=Min+1]++;\n        if(point!=src) point=pre[point];\n    }\n    return flow;\n}\n\nvoid init(int _node,int _src,int _dest)\n{\n    nedge=0;\n    node=_node;\n    src=_src;\n    dest=_dest;\n    for(int i=0;i<node;i++)head[i]=-1;\n}\n\nbool cmp(nod a,nod b)\n{\n    return a.t<b.t;\n}\n\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d%d%d\",&n,&m,&L);\n        if(n==0&&m==0&&L==0)break;\n        for(int i=0;i<n;++i)for(int j=0;j<n;++j)dist[i][j]=1000000;\n        for(int i=0;i<n;++i)dist[i][i]=0;\n        for(int i=0;i<m;++i)\n        {\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            dist[u][v]=w;\n            dist[v][u]=w;\n        }\n        for(int k=0;k<n;++k)\n        {\n            for(int i=0;i<n;++i)\n            {\n                for(int j=0;j<n;++j)\n                {\n                    dist[i][j]=min(dist[i][k]+dist[k][j],dist[i][j]);\n                }\n            }\n        }\n        for(int i=0;i<L;++i)\n        {\n            scanf(\"%d%d\",&nd[i].id,&nd[i].t);\n        }\n        init(3000,2998,2999);\n        sort(nd,nd+L,cmp);\n\n        for(int i=0;i<L;++i)\n        {\n            add_edge(src,i,1);\n            add_edge(i+L,dest,1);\n            for(int j=0;j<i;++j)\n            {\n                if(nd[j].t+dist[ nd[j].id ][ nd[i].id ] <= nd[i].t )\n                {\n                    add_edge(i,j+L,1);\n                }\n            }\n        }\n        int res = sap();\n        printf(\"%d\\n\",L-res);\n\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n#define INF 1000000000\n#define pb push_back\nstruct bipartite_matching{\n\tconst static int MAX_V=2100;\n\tint V;\n\tvector<int> G[MAX_V];\n\tint match[MAX_V];\n\tbool used[MAX_V];\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tbool dfs(int v)\n\t{\n\t\tused[v]=true;\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0||!used[w]&&dfs(w))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint matching()\n\t{\n\t\tint res=0;\n\t\tmemset(match,-1,sizeof(match));\n\t\tfor(int v=0;v<V;v++)\n\t\t{\n\t\t\tif(match[v]<0)\n\t\t\t{\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tif(dfs(v))res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nint d[105][105];\nint p[1050],t[1050];\nint N,M,L;\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\tif(N==0&&M==0&&L==0)break;\n\t\tbipartite_matching bm;\n\t\tbm.V = 2*L;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t{\n\t\t\t\td[i][j]=INF;\n\t\t\t\tif(i==j)d[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint u,v,dist;\n\t\t\tscanf(\"%d %d %d\",&u,&v,&dist);\n\t\t\td[u][v]=dist;\n\t\t\td[v][u]=dist;\n\t\t}\n\t\tfor(int k=0;k<N;k++)\n\t\t{\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\tfor(int i=0;i<L;i++)scanf(\"%d %d\",&p[i],&t[i]);\n\t\tfor(int i=0;i<L;i++)\n\t\t{\n\t\t\tfor(int j=0;j<L;j++)\n\t\t\t{\n\t\t\t\tif(t[i]<t[j]&&d[p[i]][p[j]]<=t[j]-t[i])bm.add_edge(i,j+L);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",L - bm.matching());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MAX_V 2000\n#define INF 1000000000\nusing namespace std;\n\nint N, M, L, V;\n\nstruct vertex{\n\tint v, time;\n\tbool operator < (const vertex& other){\n\t\treturn time < other.time;\n\t}\n}data[MAX_V];\nint d[100][100];\n\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid init(){\n\tmemset(d, -1, sizeof(d));\n\tfor(int i = 0; i < V; i++) G[i].clear();\n}\nvoid floyd_warshall(){\n\tfor(int k = 0; k < N; k++){\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\td[i][i] = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(d[i][j] < 0) d[i][j] = INF;\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint count = 0;\n\twhile(cin>>N>>M>>L){\n\t\tif(!N && !M && !L) break;\n\t\tV = L;\n\t\tinit();\n\t\twhile(M--){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][b] = c; \n\t\t\td[b][a] = c;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tscanf(\"%d%d\", &data[i].v, &data[i].time);\n\t\t}\n\t\tfloyd_warshall();\n\t\t/* \n\t\t   ????????¨?????¨??????0~V-1\n\t\t   ????????¨?°?????????¨??????V ~ 2V-1\n\t\t*/\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tint u = data[i].v, v = data[j].v;\n\t\t\t\tif(i != j && data[i].time+d[u][v] <= data[j].time){\n\t\t\t\t\tadd_edge(i, j+V);\n\t\t\t\t//\tprintf(\"u = %d, v = %d\\n\",u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", V - bipartite_matching());\t\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\n\nbool bm_augment(const vector<vector<int>> &graph, int v, vector<int> &match_to, vector<bool> &visited) {\n    if(v == -1) return true;\n    if(visited[v]) return false;\n    visited[v] = true;\n    for(int n : graph[v]) {\n        if(bm_augment(graph, match_to[n], match_to, visited)) {\n            match_to[n] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(const vector<vector<int>> &graph) {\n    const int N = graph.size();\n    vector<int> match_to(N, -1);\n    int cnt = 0;\n    for(int i = 0; i < N; ++i) {\n        vector<bool> visited(N, false);\n        if(bm_augment(graph, i, match_to, visited)) ++cnt;\n    }\n    return cnt;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<int>> dist(N, vector<int>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) {\n        dist[i][i] = 0;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] > d) dist[i][j] = d;\n            }\n        }\n    }\n\n    vector<vector<int>> graph(L);\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const auto &qi = queries[i];\n        for(int j = i+1; j < L; ++j) {\n            const auto &qj = queries[j];\n            if(dist[qi.second][qj.second] != -1 && qj.first - qi.first >= dist[qi.second][qj.second]) {\n                graph[i].push_back(j);\n            }\n        }\n    }\n    int cnt = bipartite_matching(graph);\n    cout << L-cnt << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\nstruct edge{\n    int flow,to,rev;\n};\ntypedef vector<edge> E;\ntypedef vector<E> FlowGraph;\n\nvoid addedge(FlowGraph &g,int from,int to,int f){\n    int a=g[from].size();\n    int b=g[to].size();\n    g[from].push_back(edge{f,to,b});\n    g[to].push_back(edge{0,from,a});\n}\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\nconst LL INF=1e15;\n\nV bfs(FlowGraph &g,int s){\n    int n=g.size();\n    queue<int> que;\n    V dist(n,-1);\n    que.push(s);\n    for(;que.size();que.pop()){\n        auto v=que.front();\n        for(auto &e:g[v]){\n            if(e.flow>0&&dist[e.to]==-1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    return dist;\n}\nint maxflow(FlowGraph &g,int s,int t){\n    int res=0,n=g.size();\n    while(true){\n        auto dist=bfs(g,s);\n        if(dist[t]<0)break;\n        vector<unsigned> iter(n,0);\n        std::function<int(int,int)> dfs=[&](int v,int f){\n            if(v==s)return f;\n            for(auto &i=iter[v];i<g[v].size();i++){\n                edge &e=g[v][i];\n                edge &re=g[e.to][e.rev];\n                if(re.flow>0&&dist[v]>dist[e.to]){\n                    int d=dfs(e.to,min(f,re.flow));\n                    if(d>0){e.flow+=d;re.flow-=d;return d;}\n                }\n            }\n            return 0;\n        };\n        int f;\n        while((f=dfs(t,114514))>0)res+=f;\n    }\n    return res;\n}\n\nint main(){\n    for(int N,M,L;cin>>N>>M>>L,N+M+L;){\n        VV g(N,V(N,INF));\n        for(int i=0;i<M;i++){\n            int u,v,d;\n            cin>>u>>v>>d;\n            g[u][v]=g[v][u]=d;\n        }\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        using P=tuple<int,int>;\n        vector<P> pt(L);\n        for(int i=0;i<L;i++){\n            int p,t;\n            cin>>p>>t;\n            pt[i]=P(t ,p);\n        }\n        sort(pt.begin(),pt.end());\n        FlowGraph fg(2*L+2);\n        int id=0;\n        int S=id++;\n        int T=id++;\n        vector<int> bg(L),ed(L);\n        for(int i=0;i<L;i++){\n            bg[i]=id++;ed[i]=id++;\n            addedge(fg,S,ed[i],1);\n            addedge(fg,bg[i],T,1);\n            int pv,tv,pu,tu;\n            tie(tv,pv)=pt[i];\n            for(int j=0;j<i;j++){\n                tie(tu,pu)=pt[j];\n                if(g[pv][pu]<=abs(tv-tu))\n                    addedge(fg,ed[j],bg[i],1);                   \n            }\n        }\n        cout<<L-maxflow(fg,S,T)<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nint D[nsize][nsize];\nint P[lsize];\nint T[lsize];\nint E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, L+j, 0 ) );\n                    g[L+j].push_back( Edge( L+j, i, 0 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        cout << L - bipartiteMatching( g, L, edges ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nstruct edge{\n  int to,rev,f;\n};\nvector<edge> G[1111];\nint Gh[1005][1005];\n\nbool used[1111];\nbool memo[1111];\n\nvoid init(){\n  memset(Gh,0,sizeof(Gh));\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( (edge){to,G[to].size(),1} );\n  G[to].push_back( (edge){from,G[from].size()-1,0} );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\nbool check(){\n  for(int i=0;i<L;i++) {\n    //cout <<i << \" : \" << used[i] << endl;\n    if( !used[i] ) return false;\n  }\n  return true;\n}\n\nbool dfs(int id){\n  if( memo[id] ) return false;\n  memo[id] = true;\n  bool ret = false;\n  for(int i=0;i<(int)G[id].size();i++){\n    edge &e= G[id][i];\n    //  cout << \"edge \" << id << \" -> \" << e.to << \" \" << e.f << endl;\n    if( e.f ) {\n      ret = dfs( e.to );\n      if( ret ){\n        e.f = 0;\n        G[e.to][e.rev].f = 1;\n        break;\n      }\n    }\n  }\n  // cout << \"in dfs\" << id<< \": \" <<used[id] << endl;\n  if( !used[id] || ret ) return used[id] = true;\n  return false;\n}\n\nint solve(){\n  for(int i=1;i<N;i++){\n    memset(memo,0,sizeof(memo));\n    dfs(L);\n    //cout<<i << endl;\n    if( check() ) return i;\n  }\n  return N;\n}\n\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n    for(int i=0;i<L;i++)\n      swap( pt[i].first, pt[i].second );    \n\n    for(int i=0;i<L;i++){\n      for(int j=0;j<L;j++){\n        if( i == j ) continue;\n        ll len = W[pt[i].first][pt[j].first];\n        ll lt = pt[j].second - pt[i].second;\n        if( len <= lt )          \n          add_edge( i, j );\n      }\n    }\n    for(int i=0;i<L;i++)\n      add_edge(L,i);\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n\n    used[L] = true;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=105;\nconst int L=2005;\n\nint n,m,l,u,v,d,p,t;\nint dp[N][N];\nint match[L];\nbool vis[L];\n\nvoid floyd() {\n    for (int k=0;k<n;k++) {\n        dp[k][k]=0;\n        for (int i=0;i<n;i++) {\n            for (int j=0;j<n;j++) {\n                if (i!=j) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n            }\n        }\n    }\n}\n\nvector<int> g[L];\n\nint dfs(int u) {\n    vis[u]=1;\n    for (int i=0;i<g[u].size();i++) {\n        int to=g[u][i];\n        if (match[to]==-1||(!vis[match[to]]&&dfs(match[to]))) {\n            match[u]=to;\n            match[to]=u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d%d\",&n,&m,&l);\n        if (n==0&&m==0&&l==0) break;\n        memset(dp,INF,sizeof(dp));\n        for (int i=0;i<m;i++) {\n            scanf(\"%d%d%d\",&u,&v,&d);\n            dp[u][v]=dp[v][u]=d;\n        }\n        vector<PII> reqs;\n        for (int i=0;i<l;i++) {\n            scanf(\"%d%d\",&p,&t);\n            reqs.pb(mp(p,t));\n        }\n        floyd();\n        for (int i=0;i<2*l;i++) g[i].clear();\n        for (int i=0;i<l;i++) {\n            for (int j=0;j<l;j++) {\n                int a=reqs[i].first;\n                int b=reqs[j].first;\n                if (i!=j&&reqs[i].second+dp[a][b]<=reqs[j].second) {\n                    g[i].pb(j+l);\n                    g[j+l].pb(i);\n                }\n            }\n        }\n\n        memset(match,-1,sizeof(match));\n        int mx_match=0;\n        for (int i=0;i<2*l;i++) {\n            if (match[i]==-1) {\n                memset(vis,0,sizeof(vis));\n                mx_match+=dfs(i);\n            }\n        }\n        printf(\"%d\\n\",l-mx_match);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, j+L, 1 ) );\n                    g[j+L].push_back( Edge( j+L, i, 1 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        bipartiteMatching( g, L, edges );\n        int answer = L - edges.size();\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#define INF 99999999\nusing namespace std;\n\ntypedef struct {\n    int num;\n    int time;\n}node;\nint n,l;\nint dis[105][105],w[1005][1005];\nint linker[1005],vis[1005];\nnode no[1005];\n\nvoid floyd() {\n    for(int k = 0;k < n;k++)\n        for(int i = 0;i < n;i++)\n            for(int j = 0;j < n;j++)\n                if(dis[i][k] < INF &&\n                   dis[k][j] < INF &&\n                   dis[i][j] > dis[i][k] + dis[k][j])\n                   dis[i][j] = dis[i][k] + dis[k][j];\n}\n\nbool dfs(int u) {\n    for(int v = 1;v <= l;v++)\n        if(w[u][v] && !vis[v]) {\n            vis[v] = 1;\n            if(linker[v] == -1 || dfs(linker[v])) {\n                linker[v] = u;\n                return true;\n            }\n        }\n    return false;\n}\n\nint hungary() {\n    int res = 0;\n    memset(linker,-1,sizeof(linker));\n    for(int u = 1;u <= l;u++) {\n        memset(vis,0,sizeof(vis));\n        if(dfs(u)) res++;\n    }\n    return res;\n}\n\nint main() {\n    int m;\n    //freopen(\"test.in\",\"r\",stdin);\n    while(~scanf(\"%d%d%d\",&n,&m,&l) && (n + m + l)) {\n        memset(w,0,sizeof(w));\n        for(int i = 0;i < n;i++)\n            for(int j = 0;j < n;j++) {\n                dis[i][j] = INF;\n                if(i == j) dis[i][j] = 0;\n            }\n\n\n        while(m--) {\n            int a,b,val;\n            scanf(\"%d%d%d\",&a,&b,&val);\n            dis[a][b] = val;\n            dis[b][a] = val;\n        }\n\n        floyd();\n\n        for(int i = 1;i <= l;i++)\n            scanf(\"%d%d\",&no[i].num,&no[i].time);\n\n        for(int i = 1;i <= l;i++)\n            for(int j = 1;j <= l;j++) {\n            if(i == j) continue;\n            int f = no[i].num,t = no[j].num;\n            int ft = no[i].time,tt = no[j].time;\n            if(ft + dis[f][t] <= tt) w[i][j] = 1;\n        }\n\n        printf(\"%d\\n\",l - hungary());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef int Weight;\ntypedef int Flow;\n\n#define REP(i,n) for(int i = 0; i < n; i++)\nconst int INF = 1e8;\n\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\ntypedef int Weight;\ntypedef int Flow;\n\nvoid add_edge(Graph &g, int src, int dest, Flow cap) {\n  g[src].push_back((Edge) { src, dest, (int)g[dest].size(), cap, 0 });\n  g[dest].push_back((Edge) { dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (Edge &e : g[v]) {\n    if (!used[e.dest] && e.cap > 0) {\n      Flow d = dfs(g, used, e.dest, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.dest][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t) {\n  Flow flow = 0;\n  for (;;) {\n    vector<bool> used(g.size(), false);\n    Flow f = dfs(g, used, s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nvector<vector<int>> road;\n\n\nbool reachable(int from, int to, int time){\n  return road[from][to] <= time;\n}\nsigned main(){\n  int n,m,l;\n  while(cin >> n >> m >> l, n != 0){\n    road = vector<vector<int>>(n,vector<int>(n,INF));\n    for(int range(i,0,m)){\n      int u, v, d;\n      cin >> u >> v >> d;\n      road[u][v] = road[v][u] = d;\n    }\n\n    vector<tuple<int,int>> req;\n    for(int range(i,0,l)){\n      int p,t;\n      cin >> p >> t;\n      req.emplace_back(t,p);\n    }\n    sort(all(req));\n\n    for(int range(k,0,n)){\n      for(int range(i,0,n)){\n        for(int range(j,0,n)){\n          road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n        }\n      }\n    }\n\n\n    const int s_id = 0;\n    const int t_id = 1;\n    const int g_size = 2 + l + l;\n    Graph g(g_size, Edges());\n    for(int range(i,0,l)){\n      for(int range(j,i+1,l)){\n        int pt, pp, nt, np;\n        tie(pt, pp) = req[i];\n        tie(nt, np) = req[j];\n        if(road[pp][np] <= nt - pt){\n          add_edge(g, 2 + i, 2 + l + j, 1);\n        }\n      }\n    }\n    for(int range(i,0,l)){\n      add_edge(g, s_id, 2 + i, 1);\n      add_edge(g, 2 + l + i, t_id, 1);\n    }\n    int ff = ford_fulkerson(g, s_id, t_id);\n\n    cout << l - ff << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(u,a,b) for(int u=(a);u<(b);u++)\n#define rrep(u,a,b) for(int u=(b)-1;u>=(a);u--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct HopcroftKarp {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match, dist;\n\tvector<bool> used, alive;\n\tHopcroftKarp(int n) : n(n), g(n), match(n), dist(n), used(n), alive(n, true) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\twhile (true) {\n\t\t\tbuildAlternatingLevelGraph();\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint flow = 0;\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tif (match[u] == -1 && augment(u))\n\t\t\t\t\tflow++;\n\t\t\tif (flow == 0)break;\n\t\t\tcnt += flow;\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid buildAlternatingLevelGraph() {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int u = 0; u < n; u++)\n\t\t\tif (match[u] == -1) {\n\t\t\t\tq.emplace(u);\n\t\t\t\tdist[u] = 0;\n\t\t\t}\n\t\twhile (q.size()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (auto &v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w != -1 && dist[w] == -1) {\n\t\t\t\t\tdist[w] = dist[v] + 1;\n\t\t\t\t\tq.emplace(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tbool augment(int u) {\n\t\tused[u] = true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!alive[v])continue;\n\t\t\tint w = match[v];\n\t\t\tif (w == -1 || (!used[w] && dist[w] == dist[u] + 1 && augment(w))) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\tused[v] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tHopcroftKarp hk(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\thk.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - hk.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100;\nconst int L = 1000;\nconst int INF = 1e+8 + 10;\nconst int MAX_V = L * 2 + 2;\n\nstruct data{\n  int p, t;\n  data(int p=0, int t=0):p(p),t(t){}\n  bool operator < (const data &d) const {\n    return t < d.t;\n  }\n};\n\nstruct edge{\n  int to, cap, rev;\n  edge(int t=0, int c=0, int r=0):to(t),cap(c),rev(r){}\n};\n  \nvoid add_edge(const int &from, const int &to, const int &cap, vector<edge> G[MAX_V]){\n  G[from].push_back(edge(to, cap, G[to].size()));\n  G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n \nint dfs_f(const int &v, const int &t, const int &f, vector<edge> G[MAX_V], bool used[MAX_V]){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs_f(e.to, t, min(f, e.cap), G, used);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s, int t, vector<edge> G[MAX_V]){\n  int flow = 0;\n  while(1){\n    bool used[MAX_V];\n    fill(used, used+MAX_V, false);\n    int f = dfs_f(s, t, INF, G, used);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\n\n\nint n, m, l, G[N][N];\nvector<data> v;\n\nint solve(){\n  vector<edge> fG[MAX_V];\n\n  for(int i=0;i<n;i++) G[i][i] = 0;\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n      }\n    }\n  }\n\n  sort(v.begin(), v.end());\n  for(int i=0;i<l;i++){\n    add_edge(l*2, i, 1, fG);\n    add_edge(l+i, l*2+1, 1, fG);\n    //add_edge(i, l+i, 1, fG);\n    for(int j=i+1;j<l;j++){\n      if(G[v[i].p][v[j].p] < INF && v[i].t + G[v[i].p][v[j].p] <= v[j].t) {\n        add_edge(j, l+i, 1, fG);\n      }\n    }\n  }\n\n  // ?????§???????????? = V - ????°?????????????\n  return l - max_flow(l*2, l*2+1, fG);\n}\n\nint main(){\n  int x, y, d;\n  while(cin >> n >> m >> l && (n|m|l)){\n    fill(G[0], G[n], INF);\n    v.clear();\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d;\n      G[x][y] = min(G[x][y], d);\n      G[y][x] = min(G[y][x], d);\n    }\n    for(int i=0;i<l;i++){\n      cin >> x >> y;\n      v.push_back(data(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MAX_V 2000\n#define INF 1000000000\nusing namespace std;\n\nint N, M, L, V;\n\nstruct vertex{\n\tint v, time;\n\tbool operator < (const vertex& other){\n\t\treturn time < other.time;\n\t}\n}data[MAX_V];\nint d[100][100];\n\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tfill(d[i], d[i]+N, INF);\n\t\td[i][i] = 0;\n\t}\n\tfor(int i = 0; i < V; i++) G[i].clear();\n}\nvoid floyd_warshall(){\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint count = 0;\n\twhile(cin>>N>>M>>L){\n\t\tif(!N && !M && !L) break;\n\t\tV = L;\n\t\tinit();\n\t\twhile(M--){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][b] = c; \n\t\t\td[b][a] = c;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tscanf(\"%d%d\", &data[i].v, &data[i].time);\n\t\t}\n\t\tfloyd_warshall();\n\t\t/* \n\t\t   ????????¨?????¨??????0~V-1\n\t\t   ????????¨?°?????????¨??????V ~ 2V-1\n\t\t*/\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tint u = data[i].v, v = data[j].v;\n\t\t\t\tif(i != j && data[i].time+d[u][v] <= data[j].time){\n\t\t\t\t\tadd_edge(i, j+V);\n\t\t\t\t//\tprintf(\"u = %d, v = %d\\n\",u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", V - bipartite_matching());\t\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> struct edge\n{\n  int to;\n  T cap;\n  int reverse;\n  edge(int to, T cap, int reverse) : to(to), cap(cap), reverse(reverse) {}\n};\n\ntemplate <typename T> class Dinic\n{\nprivate:\n  static const T INF = (T)1000000000;\n  vector<edge<T> >* G;\n  int N;\n  int* level;\n  int* iter;\n\n  void bfs(int s);\n  T dfs(int v, int t, T f);\n\npublic:\n  Dinic(int N) : N(N) { this->init(); }\n  void init();\n  void addEdge(int from, int to, T cap);\n  T MaximumFlow(int s, int t);\n};\n\ntemplate<typename T> void Dinic<T>::init()\n{\n  G = new vector<edge<T> >[N];\n  level = new int[N];\n  iter = new int[N];\n  rep(i, N) G[i].clear();\n}\n\ntemplate<typename T> void Dinic<T>::addEdge(int from, int to, T cap)\n{\n  G[from].pb(edge<T>(to, cap, G[to].size()));\n  G[to].pb(edge<T>(from, (T)0, G[from].size()-1));\n}\n\ntemplate<typename T> void Dinic<T>::bfs(int s)\n{\n  rep(i, N) level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();  que.pop();\n    vrep(w, G[v]){\n      edge<T>& e = *w;\n      if(e.cap > (T)0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\ntemplate<typename T> T Dinic<T>::dfs(int v, int t, T f)\n{\n  if(v == t) return f;\n  for(int& i = iter[v]; i<G[v].size(); i++){\n    edge<T>& e = G[v][i];\n    if(e.cap > (T)0 && level[v] < level[e.to]){\n      T d = dfs(e.to, t, min(f, e.cap));\n      if(d > (T)0){\n        e.cap -= d;\n        G[e.to][e.reverse].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\ntemplate<typename T> T Dinic<T>::MaximumFlow(int s, int t)\n{\n  T flow = (T)0;\n  while(true){\n    bfs(s);\n    if(level[t] < (T)0) return flow;\n    rep(i, N) iter[i] = 0;\n    T f;\n    while((f = dfs(s, t, Dinic::INF)) > (T)0){\n      flow += f;\n    }\n  }\n}\n\n\nint N, M, L;\nint u, v, dd;\nint d[111][111];\nint p[1111];\nint t[1111];\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> M >> L, N){\n    Dinic<int> dinic = Dinic<int>(2 * L + 2);\n    rep(i, N) rep(j, N) d[i][j] = INF;\n    rep(i, N) d[i][i] = 0;\n    rep(i, M){\n      cin >> u >> v >> dd;\n      d[u][v] = dd;\n      d[v][u] = dd;\n    }\n    rep(k, N) rep(i, N) rep(j, N) minup(d[i][j], d[i][k] + d[k][j]);\n    rep(i, L) cin >> p[i] >> t[i];\n    rep(i, L) rep(j, L) if(i != j && t[i] + d[p[i]][p[j]] <= t[j]) dinic.addEdge(i, j + L, 1);\n    int s = 2 * L;\n    int t = s + 1;\n    rep(i, L) dinic.addEdge(s, i, 1);\n    rep(j, L) dinic.addEdge(j + L, t, 1);\n    cout << L - dinic.MaximumFlow(s, t) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct bipartite_matching\n{\n\tconst static int MAX_V=2100;\n\tint V;\n\tvector<int> G[MAX_V];\n\tint match[MAX_V];\n\tbool used[MAX_V];\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tbool dfs(int v)\n\t{\n\t\tused[v]=true;\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0||!used[w]&&dfs(w))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint matching()\n\t{\n\t\tint res=0;\n\t\tmemset(match,-1,sizeof(match));\n\t\tfor(int v=0;v<V;v++)\n\t\t{\n\t\t\tif(match[v]<0)\n\t\t\t{\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tif(dfs(v))res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nint d[105][105];\nint p[1050],t[1050];\nint N,M,L;\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> N >> M >> L;\n\t\tif(N==0&&M==0&&L==0)break;\n\t\tbipartite_matching bm;\n\t\tbm.V = 2*L;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t{\n\t\t\t\td[i][j]=INF;\n\t\t\t\tif(i==j)d[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint u,v,dist;\n\t\t\tcin >> u >> v >> dist;\n\t\t\td[u][v]=dist;\n\t\t\td[v][u]=dist;\n\t\t}\n\t\tfor(int k=0;k<N;k++)\n\t\t{\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\tfor(int i=0;i<L;i++)cin >> p[i] >> t[i];\n\t\tfor(int i=0;i<L;i++)\n\t\t{\n\t\t\tfor(int j=0;j<L;j++)\n\t\t\t{\n\t\t\t\tif(t[i]<t[j]&&d[p[i]][p[j]]<=t[j]-t[i])bm.add_edge(i,j+L);\n\t\t\t}\n\t\t}\n\t\tcout << L - bm.matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inc(i, l, r) for (int i = l; i <= r; i++)\n#define dec(i, l, r) for (int i = l; i >= r; i--)\n#define pii pair<int, int>\n#define fi first\n#define se second\n#define pb push_back\n\nconst int maxn = 205;\nconst int maxm = 2005;\nconst int inf = 0x3f3f3f3f;\n\nint n, m, l;\nint d[maxn][maxn];\n\nvector<int> g[maxm];\nint match[maxm];\nint vis[maxm];\n\nvoid add_edge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\n\nbool dfs(int v) {\n    vis[v] = 1;\n    for (int i = 0; i < g[v].size(); i++) {\n        int u = g[v][i], w = match[u];\n        if (w < 0 || !vis[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bm() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int i = 1; i <= l; i++) {\n        if (match[i] < 0) {\n            memset(vis, 0, sizeof(vis));\n            if (dfs(i)) res++;\n        }\n    }\n    return res;\n}\n\nvoid floyd() {\n    inc(k, 1, n) inc(i, 1, n) inc(j, 1, n) d[i][j] =\n        min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main() {\n    int u, v, x;\n    while (scanf(\"%d %d %d\", &n, &m, &l) != EOF && n) {\n        inc(i, 1, n) inc(j, 1, n) d[i][j] = inf;\n        inc(i, 1, n) d[i][i] = 0;\n        while (m--) {\n            scanf(\"%d %d %d\", &u, &v, &x);\n            u++, v++;\n            d[u][v] = d[v][u] = x;\n        }\n        floyd();\n        inc(i, 1, 2 * l) g[i].clear();\n        vector<pii> qq(l + 1);\n        inc(i, 1, l) {\n            scanf(\"%d %d\", &qq[i].fi, &qq[i].se);\n            qq[i].fi++;\n        }\n        inc(i, 1, l) inc(j, 1, l) {\n            if (i != j && qq[i].se + d[qq[i].fi][qq[j].fi] <= qq[j].se) {\n                add_edge(i, j + l);\n               // printf(\"add_edge %d %d\\n\", i, j + l);\n            }\n        }\n        printf(\"%d\\n\", l - bm());\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nstruct edge{\n  int to,rev,f;\n};\nvector<edge> G[2111];\n\nbool memo[2111];\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( (edge){to,G[to].size(),1} );\n  G[to].push_back( (edge){from,G[from].size()-1,0} );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\n\nbool dfs(int id,int t){\n  memo[id] = true;\n  if( t == id ) return true;\n  for(int i=0;i<(int)G[id].size();i++){\n    edge &e= G[id][i];\n    if( !memo[e.to] && e.f ) {\n      if( dfs(e.to,t) ){\n        e.f = 0;\n        G[e.to][e.rev].f = 1;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint solve(){\n  for(int i=0;i<L;i++){\n    memset(memo,0,sizeof(memo));\n    if( !dfs(2*L,2*L+1) ) return L-i;\n  }\n  return 0;\n}\n\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n\n    for(int i=0;i<L;i++){\n      for(int j=i+1;j<L;j++){\n        ll len = W[pt[i].second][pt[j].second];\n        ll lt = pt[j].first - pt[i].first;\n        if( len <= lt )          \n          add_edge( i, L+j );\n      }\n    }\n    for(int i=0;i<L;i++){\n      add_edge(2*L,i);\n      add_edge(i+L,2*L+1);\n    }\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n    \n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=110;\nconst int MAXE=2100000;\nconst int INF=(1<<29);\n\nint n,m,query;\n\nstruct Edge\n{\n\tint next,to;\n};\nEdge edge[MAXE];\nint head[MAXN];\nint countedge;\nvoid addedge(const int& start,const int& end)\n{\n\tedge[countedge].to=end;\n\tedge[countedge].next=head[start];\n\thead[start]=countedge;\n\tcountedge++;\n}\n\nint dis[MAXN][MAXN];\n\nstruct Q\n{\n\tint time,to;\n};\nQ q[1100];\n\nint match[1100];\nbool use[1100];\nbool find(int u)\n{\n\tint temp;\n\tfor(temp=head[u];temp!=-1;temp=edge[temp].next)\n\t{\n\t\tif(!use[edge[temp].to])\n\t\t{\n\t\t\tuse[edge[temp].to]=true;\n\t\t\tif(!match[edge[temp].to]||find(match[edge[temp].to]))\n\t\t\t{\n\t\t\t\tmatch[edge[temp].to]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint hungry()\n{\n\tint ret=0;\n\tmemset(match,0,sizeof(match));\n\tint i;\n\tfor(i=1;i<=query;i++)\n\t{\n\t\tmemset(use,0,sizeof(use));\n\t\tif(find(i))ret++;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&n,&m,&query))\n\t{\n\t\tif(0==n&&0==m&&0==query)break;\n\t\t\n\t\tint i,j,k;\n\t\tint start,end,weight;\n\t\t\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tfor(j=0;j<n;j++)dis[i][j]=INF;\n\t\t\tdis[i][i]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&start,&end,&weight);\n\t\t\tdis[start][end]=weight;\n\t\t\tdis[end][start]=weight;\n\t\t}\n\t\tfor(k=0;k<n;k++)\n\t\t{\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(i==k)continue;\n\t\t\t\tfor(j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j==k||j==i)continue;\n\t\t\t\t\tdis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=query;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&q[i].to,&q[i].time);\n\t\t}\n\t\t\n\t\tcountedge=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tfor(i=1;i<=query;i++)\n\t\t{\n\t\t\tfor(j=1;j<=query;j++)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(q[i].time+dis[q[i].to][q[j].to]<=q[j].time)addedge(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",query-hungry());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e9;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nint N, M, L;\nvector<i_i> Queries;\nvector<vector<ll>> dist;\nvector<vector<ll>> paths;\nbool visited[1005];\n\nstruct max_flow {\n    int INF = 1e9;\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nvoid dfs(int from, int to) {\n    if(visited[to]) return;\n    visited[to] = true;\n    for(auto tmp : paths[to]) {\n        dfs(from, tmp);\n    }\n}\n\nvoid solve() {\n    dist = vector<vector<ll>>(N, vector<ll>(N, INF));\n    for(int i = 0; i < N; i++) dist[i][i] = 0;\n    paths = vector<vector<ll>>(L);\n    for(int i = 0; i < M; i++) {\n        ll u, v, d;\n        cin >> u >> v >> d;\n        chmin(dist[u][v], d);\n        chmin(dist[v][u], d);\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < N; k++) {\n                chmin(dist[j][k], dist[j][i] + dist[i][k]);\n            }\n        }\n    }\n    Queries.resize(L);\n    for(int i = 0; i < L; i++) {\n        cin >> Queries[i].second >> Queries[i].first;\n    }\n    sort(Queries.begin(), Queries.end());\n    for(int from = L - 1; from >= 0; from--) {\n        for(int i = 0; i < L; i++) {\n            visited[i] = false;\n        }\n        for(int to = from + 1; to < L; to++) {\n            if(visited[to]) continue;\n            if(Queries[to].first - Queries[from].first >= dist[Queries[to].second][Queries[from].second]) {\n                paths[from].push_back(to);\n                //dfs(from, to);\n            }\n        }\n    }\n    /*\n    for(int i = 0; i < L; i++) {\n        cerr << \"----\" << i << \"---\" << Queries[i].second << \"---\" << Queries[i].first << endl;\n        for(auto to : paths[i]) {\n            cerr << to << \" \";\n        }\n        cerr << endl;\n    }\n    */\n    max_flow graph(2 * L + 2);\n    int s = 2 * L;\n    int t = 2 * L + 1;\n    for(int i = 0; i < L; i++) {\n        graph.add_edge(s, i, 1);\n        graph.add_edge(L + i, t, 1);\n        for(auto to : paths[i]) {\n            graph.add_edge(i, to + L, 1);\n        }\n    }\n    cout << L - graph.run(s, t) << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> L) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nint D[nsize][nsize];\nint P[lsize];\nint T[lsize];\nint E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, L+j, 0 ) );\n                    g[L+j].push_back( Edge( L+j, i, 0 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        bipartiteMatching( g, L, edges );\n        set <pair<int, int> > V;\n        int answer = L;\n        for ( int i = 0; i < (int)edges.size(); i++ ) {\n            if ( V.find( make_pair( P[edges[i].src], P[edges[i].dst] ) ) == V.end() ) {\n                answer--;\n                V.insert( make_pair( P[edges[i].src], P[edges[i].dst] ) );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#define nl n<<1\n#define nr (n<<1)|1\n#define first fi\n#define second se\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int>P;\nconst int INF=0x3f3f3f3f;\nconst ll INFF=0x3f3f3f3f3f3f3f3f;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' | ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9') {x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid Out(int aa)\n{\n    if(aa>9)\n        Out(aa/10);\n    putchar(aa%10+'0');\n}\nint n,m,l;\nint mapp[105][105];\nint str[2005][2005];\nint use[2005],girl[2005];\nvoid floyd()\n{\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            for(int k=1;k<=n;k++)\n                mapp[j][k]=min(mapp[j][k],mapp[j][i]+mapp[i][k]);\n}\nbool dfs(int x)\n{\n    for(int i=1;i<=l;i++)\n    {\n        if(str[x][i]&&!use[i])\n        {\n            use[i]=true;\n            if(!girl[i]|dfs(girl[i]))\n            {\n                girl[i]=x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint solve()\n{\n    int ans=0;\n    memset(girl,0,sizeof(girl));\n    for(int i=1;i<=l;i++)\n    {\n        memset(use,false,sizeof(use));\n        if(dfs(i))\n            ans++;\n    }\n    return ans;\n}\nint p[1010],t[1010];\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n    {\n        if(n+m+l==0)break;\n        memset(mapp,INF,sizeof(mapp));\n        memset(str,0,sizeof(str));\n        for(int i=1;i<=m;i++)\n        {\n            int a=read(),b=read(),c=read();\n            mapp[a+1][b+1]=mapp[b+1][a+1]=c;\n            mapp[i][i]=0;\n        }\n        floyd();\n        for(int i=1;i<=l;i++)p[i]=read()+1,t[i]=read();\n        for(int i=1;i<=l;i++)\n        {\n            for(int j=1;j<=l;j++)\n            {\n                if(i==j)continue;\n                if(mapp[p[i]][p[j]]<=t[j]-t[i])\n                {\n                    str[i][j]=1;\n                }\n            }\n        }\n        printf(\"%d\\n\",l-solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\nstruct edge{\n    int flow,to,rev;\n};\ntypedef vector<edge> E;\ntypedef vector<E> FlowGraph;\n\nvoid addedge(FlowGraph &g,int from,int to,int f){\n    int a=g[from].size();\n    int b=g[to].size();\n    g[from].push_back(edge{f,to,b});\n    g[to].push_back(edge{0,from,a});\n}\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\nconst LL INF=1e15;\n\nV bfs(FlowGraph &g,int s){\n    int n=g.size();\n    queue<int> que;\n    V dist(n,-1);\n    dist[s]=0;\n    que.push(s);\n    for(;que.size();que.pop()){\n        auto v=que.front();\n        for(auto &e:g[v]){\n            if(e.flow>0&&dist[e.to]==-1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    return dist;\n}\nint maxflow(FlowGraph &g,int s,int t){\n    int res=0,n=g.size();\n    while(true){\n        auto dist=bfs(g,s);\n        if(dist[t]<0)break;\n        vector<unsigned> iter(n,0);\n        std::function<int(int,int)> dfs=[&](int v,int f){\n            if(v==s)return f;\n            for(auto &i=iter[v];i<g[v].size();i++){\n                edge &e=g[v][i];\n                edge &re=g[e.to][e.rev];\n                if(re.flow>0&&dist[v]>dist[e.to]){\n                    int d=dfs(e.to,min(f,re.flow));\n                    if(d>0){e.flow+=d;re.flow-=d;return d;}\n                }\n            }\n            return 0;\n        };\n        int f;\n        while((f=dfs(t,114514))>0)res+=f;\n    }\n    return res;\n}\n\nint main(){\n    for(int N,M,L;cin>>N>>M>>L,N+M+L;){\n        VV g(N,V(N,INF));\n        for(int i=0;i<M;i++){\n            int u,v,d;\n            cin>>u>>v>>d;\n            g[u][v]=g[v][u]=d;\n        }\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        using P=tuple<int,int>;\n        vector<P> pt(L);\n        for(int i=0;i<L;i++){\n            int p,t;\n            cin>>p>>t;\n            pt[i]=P(t ,p);\n        }\n        sort(pt.begin(),pt.end());\n        FlowGraph fg(2*L+2);\n        int id=0;\n        int S=id++;\n        int T=id++;\n        vector<int> bg(L),ed(L);\n        for(int i=0;i<L;i++){\n            bg[i]=id++;ed[i]=id++;\n            addedge(fg,S,ed[i],1);\n            addedge(fg,bg[i],T,1);\n            int pv,tv,pu,tu;\n            tie(tv,pv)=pt[i];\n            for(int j=0;j<i;j++){\n                tie(tu,pu)=pt[j];\n                if(g[pv][pu]<=abs(tv-tu))\n                    addedge(fg,ed[j],bg[i],1);                   \n            }\n        }\n        cout<<L-maxflow(fg,S,T)<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int t, int c, int r):to(t),cap(c),rev(r){}\n\tedge(){}\n};\n\nint dfs(int v, int g, int flow, vector<vector<edge> >& adj, vector<bool>& used){\n\tif(used[v]) return -1;\n\tused[v] = true;\n\tif(v == g) return flow;\n\t\n\tfor(int i=0; i<(int)adj[v].size(); i++){\n\t\tedge& next = adj[v][i];\n\t\tif(next.cap > 0){\n\t\t\tint ret = dfs(next.to, g, min(flow, next.cap), adj, used);\n\t\t\tif(ret > 0){\n\t\t\t\tnext.cap -= ret;\n\t\t\t\tadj[next.to][next.rev].cap += ret;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint maxflow(int s, int g, vector<vector<edge> > &graph){\n\tint res = 0;\n\twhile(1){\n\t\tvector<bool> used((graph.size()+1)*2, false);\n\t\tint ret = dfs(s, g, inf, graph, used);\n\t\tif(ret==-1) break;\n\t\tres += ret;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,l;\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > adj(n, vector<int>(n, inf));\n\t\tfor(int i=0; i<n; i++) adj[i][i] = 0;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tadj[u][v] = adj[v][u] = d;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> p(l), t(l);\n\t\tfor(int i=0; i<l; i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\t\n\t\tvector<vector<edge> > bg((l+1)*2);\n\t\tfor(int i=0; i<l; i++){\n\t\t\tfor(int j=0; j<l; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(t[i] +adj[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tbg[i].push_back(edge(l+j, 1, bg[l+j].size()));\n\t\t\t\t\tbg[l+j].push_back(edge(i, 0, bg[i].size()-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<l; i++){\n\t\t\tbg[2*l].push_back(edge(i, 1, bg[i].size()));\n\t\t\tbg[i].push_back(edge(2*l, 0, bg[2*l].size()-1));\n\t\t\tbg[l+i].push_back(edge(2*l+1, 1, bg[2*l+1].size()));\n\t\t\tbg[2*l+1].push_back(edge(l+1, 0, bg[l+1].size()-1));\n\t\t}\n\t\tcout << l -maxflow(2*l, 2*l+1, bg) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nclass BipMatch {\nprivate:\n  int v;\n  vector<vector<int> > g;\n  vector<int> match;\n  vector<bool> used;\n\n  bool dfs(int v) {\n    used[v] = true;\n    rep (i, g[v].size()) {\n      int u = g[v][i], w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n\tmatch[v] = u;\n\tmatch[u] = v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  BipMatch() : v(0) {}\n\n  int next() {\n    g.push_back(vector<int>());\n    match.push_back(0);\n    used.push_back(0);\n    return v++;\n  }\n\n  void add_edge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  int run() {\n    int res = 0;\n    fill(match.begin(), match.end(), -1);\n    rep (i, v) if (match[i] < 0) {\n      fill(used.begin(), used.end(), 0);\n      if (dfs(i)) res++;\n    }\n    return res;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    int dis[n][n];\n    rep (i, n) rep (j, n) dis[i][j] = 1e9;\n    rep (i, n) dis[i][i] = 0;\n    rep (i, m) {\n      int u, v, d;\n      cin >> u >> v >> d;\n      dis[u][v] = min(dis[u][v], d);\n      dis[v][u] = min(dis[v][u], d);\n    }\n    int p[l], t[l];\n    rep (i, l) cin >> p[i] >> t[i];\n    rep (k, n) rep (i, n) rep (j, n) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n    BipMatch bm;\n    int left[l], right[l];\n    rep (i, l) left[i] = bm.next();\n    rep (i, l) right[i] = bm.next();\n    rep (i, l) rep (j, l) if (t[i] < t[j] && dis[p[i]][p[j]] <= t[j] - t[i]) bm.add_edge(left[i], right[j]);\n    cout << l - bm.run() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 300;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[MAX_V];\n        fill(used,used+MAX_V,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            ct=node=0;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i = v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int minTime=-1;\n                int idx=0;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i = v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=time){\n                        if(minTime<time){\n                            minTime=ct-cost;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(minTime==-1)\n                    break;\n                //  êÎAóÔðXV\n                ct=v[idx].first;\n                node=v[idx].second;\n                used[idx]=true;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge\n{\n    int to,cap,rev;\n};\n\nconst int MAX_N = 1002;\n\nint d[102][102];\nvector<edge> G[2*MAX_N];\nint level[2*MAX_N];\nint iter[2*MAX_N];\nint n,m,L;\n\nvoid warshall_floyd()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,n){\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> L;\n        if(n == 0 && m == 0 && L == 0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = INF;\n            }\n        }\n        rep(i,m){\n            int x,y,z;\n            cin >> x >> y >> z;\n            d[x][y] = z;\n            d[y][x] = z;\n        }\n        vector<int> p(L),t(L);\n        rep(i,L){\n            cin >> p[i] >> t[i];\n        }\n        warshall_floyd();\n        rep(i,2*L+2){\n            G[i].clear();\n        }\n        rep(i,L){\n            rep(j,L){\n                if(t[i] + d[p[i]][p[j]] <= t[j]){\n                    add_edge(i,L+j+1,INF);\n                }\n            }\n        }\n        rep(i,L){\n            add_edge(0,i,1);\n            add_edge(L+i+1,2*L+1,1);\n        }\n        cout << L - max_flow(0,2*L+1) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\nvector<vector<int>> e;\nint used[1000 * 2], match[1000 * 2];\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (auto u : e[v]) {\n\t\tint w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int N) {\n\tint ret = 0;\n\tmemset(match, -1, sizeof(match));\n\tFOR(v, N) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint cost[100][100];\n\nint main() {\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tmemset(cost, 0x3F, sizeof(cost));\n\t\tFOR(i, n) cost[i][i] = 0;\n\t\tFOR(i, m) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tcost[u][v] = cost[v][u] = d;\n\t\t}\n\t\tFOR(k, n) FOR(i, n) FOR(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\n\t\tvector<Pii> vp(l);\n\t\tFOR(i, l) {\n\t\t\tcin >> vp[i].first >> vp[i].second;\n\t\t}\n\t\te = vector<vector<int>>(2 * l);\n\t\tFOR(i, l) FOR(j, l) {\n\t\t\tif (i == j) continue;\n\t\t\tint from = vp[i].first, to = vp[j].first;\n\t\t\tif (vp[i].second + cost[from][to] <= vp[j].second) {\n\t\t\t\te[i].push_back(l + j);\n\t\t\t}\n\t\t}\n\n\t\tcout << l - bipartite_matching(2 * l) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n#include<cstring>\nstruct edge { int to, cap, rev; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint d[100][100];\n\nvoid solve() {\n\tint n, m, l; \n\twhile (cin >> n >> m >> l, n) {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i == j)d[i][j] = 0;\n\t\t\t\telse d[i][j] = mod;\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tint u, v, x; cin >> u >> v >> x;\n\t\t\td[u][v] = d[v][u] = x;\n\t\t}\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> p(l), t(l);\n\t\trep(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\trep(i, 2 * l + 2)G[i].clear();\n\t\tint ans = l;\n\t\tint s = 2 * l; int g = s + 1;\n\t\trep(i, l) {\n\t\t\trep(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tint dif = t[j] - t[i];\n\t\t\t\tif (dif >= 0) {\n\t\t\t\t\tif (dif >= d[p[i]][p[j]]) {\n\t\t\t\t\t\tadd_edge(i, j + l, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, l) {\n\t\t\tadd_edge(s, i, 1);\n\t\t\tadd_edge(i + l, g, 1);\n\t\t}\n\t\tans -= max_flow(s, g);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 200;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            if(from>=200||to>=200){\n                int x=0;\n             //   3/x;\n            }\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[200];\n        fill(used,used+200,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            ct=node=0;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i = v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int minTime=-1;\n                int idx=0;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i = v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=time){\n                        if(minTime<time){\n                            minTime=ct-cost;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(minTime==-1)\n                    break;\n                //  êÎAóÔðXV\n                ct=v[idx].first;\n                node=v[idx].second;\n                used[idx]=true;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int INF = 10000000;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Cost cost;\n    Edge *back;\n    Edge() {}\n    Edge(int from, int to, Flow c, Cost d, Edge *b) : from(from), to(to), capacity(c), flow(0), cost(d), back(b) {}\n};\nEdge<int,int> _buf[(1000*1000 + 1000 + 100) * 2];\nint _bp;\n\ntemplate<class Flow, class Cost>\nvoid make_edge(vector<vector<Edge<Flow,Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    _buf[_bp] = Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    auto *e = &_buf[_bp];\n    _buf[_bp+1] = Edge<Flow,Cost>(dst, src, 0, -d, e);\n    auto *back = e->back = &_buf[_bp+1];\n    _bp += 2;\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> h(N), dist(N);\n    vector<Edge<Flow,Cost>*> parent(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        dist[src] = 0;\n        fill(parent.begin(), parent.end(), nullptr);\n        priority_queue<pair<Cost,int>> q;\n        q.push(make_pair(0, src));\n        while(!q.empty()) {\n            const int n = q.top().second;\n            const Cost c = -q.top().first;\n            q.pop();\n            if(dist[n] < c) {\n                continue;\n            }\n            for(auto e : g[n]) {\n                if(e->capacity - e->flow > 0) {\n                    const Cost c2 = c + e->cost + h[n] - h[e->to];\n                    if(c2 < dist[e->to]) {\n                        dist[e->to] = c2;\n                        parent[e->to] = e;\n                        q.push(make_pair(-c2, e->to));\n                    }\n                }\n            }\n        }\n        if(parent[sink] == nullptr) {\n            break;\n        }\n\n        Flow to_push = f;\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            to_push = min(to_push, e->capacity - e->flow);\n            if(to_push == 1) break;\n        }\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            res.second += to_push * e->cost;\n            e->flow += to_push;\n            e->back->flow -= to_push;\n        }\n        f -= to_push;\n        res.first += to_push;\n        for(int i = 0; i < N; ++i) {\n            h[i] += dist[i];\n        }\n    }\n    return res;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<int>> dist(N, vector<int>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) {\n        dist[i][i] = 0;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] >= d) dist[i][j] = d;\n            }\n        }\n    }\n\n    _bp = 0;\n    vector<vector<Edge<int,int>*>> graph(L*2+2);\n    const int SRC = L*2;\n    const int SINK = SRC+1;\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const int in_node = i*2;\n        const int out_node = i*2+1;\n        make_edge(graph, SRC, in_node, 1, 0);\n        make_edge(graph, in_node, out_node, 1, 0);\n        make_edge(graph, out_node, SINK, INF, 0);\n        const int ni = queries[i].second;\n        for(int j = i+1; j < L; ++j) {\n            const int nj = queries[j].second;\n            if(dist[ni][nj] != -1 && queries[j].first - queries[i].first >= dist[ni][nj]) {\n                //cout << queries[i].second << ' ' << queries[j].second << endl;\n                make_edge(graph, out_node, j*2, 1, -1);\n            }\n        }\n    }\n    make_edge(graph, SRC, SINK, INF, 0);\n    const auto res = primal_dual(graph, SRC, SINK, L);\n    cout << L + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nclass BipartiteMatching\n{\nprivate:\n  int MAX_V;\n  vector<int>* G;\n  int* match;\n  int* used;\n\n  bool dfs(int v)\n  {\n    used[v] = true;\n    rep(i, G[v].size()){\n      int u = G[v][i], w = match[u];\n      if(w < 0 || !used[w] && dfs(w)){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  BipartiteMatching(int MAX_V) : MAX_V(MAX_V)\n  {\n    G = new vector<int>[MAX_V];\n    match = new int[MAX_V];\n    used = new int[MAX_V];\n  }\n\n  ~BipartiteMatching()\n  {\n    delete[] G;\n    delete[] match;\n    delete[] used;\n  }\n  \n  void addEdge(int u, int v)\n  {\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n\n  int matching()\n  {\n    int res = 0;\n    rep(i, MAX_V) match[i] = -1;\n    rep(v, MAX_V){\n      if(match[v] < 0){\n        rep(i, MAX_V) used[i] = 0;\n        if(dfs(v)) res += 1;\n      }\n    }\n    return res;\n  }\n};\n\nint N, M, L;\nint u, v, dd;\nint d[111][111];\nint p[1111];\nint t[1111];\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> M >> L, N){\n    BipartiteMatching bm = BipartiteMatching(2 * L);\n    rep(i, N) rep(j, N) d[i][j] = INF;\n    rep(i, N) d[i][i] = 0;\n    rep(i, M){\n      cin >> u >> v >> dd;\n      d[u][v] = dd;\n      d[v][u] = dd;\n    }\n    rep(k, N) rep(i, N) rep(j, N) minup(d[i][j], d[i][k] + d[k][j]);\n    rep(i, L) cin >> p[i] >> t[i];\n    rep(i, L) rep(j, L) if(i != j && t[i] + d[p[i]][p[j]] <= t[j]) bm.addEdge(i, j + L);\n    cout << L - bm.matching() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <stack>\n#include <cctype>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <bitset>\n#include <deque>\n#include <iomanip>\nusing namespace std;\n#define pr(x) cout << \"x = \" << x << endl;\n#define bug cout << \"bugbug\" << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MOD = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int maxn = 2e3 + 4;\nconst int maxm = 1e2 + 4;\nstruct Edge{\n    int to, cab, rev;\n    Edge(int _to, int _cap, int _rev):to(_to), cab(_cap), rev(_rev){\n\n    }\n};\nvector<Edge> G[maxn];\nint level[maxn], iter[maxn], n, m, u, v, cab;\ninline void add(int u, int v, int cap){\n//\tcout << u << ' ' << v << endl;\n    G[u].push_back(Edge(v, cap, G[v].size()));\n    G[v].push_back(Edge(u, 0, G[u].size() - 1));\n    return;\n} \nvoid bfs(int s, int t){\n    level[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(q.size()){\n        int u = q.front(); q.pop();\n        for (int i = 0; i < G[u].size(); ++i){\n            int to = G[u][i].to;\n            if (level[to] == -1 && G[u][i].cab > 0){\n                level[to] = level[u] + 1;\n                q.push(to);\n            }\n        }\n    }\n    return;\n}\nint dfs(int u, int t, int f){\n    if (u == t) return f;\n    for (int& i = iter[u]; i < G[u].size(); ++i){\n        int to = G[u][i].to;\n        if (level[to] > level[u] && G[u][i].cab > 0){\n            int d = dfs(to, t, min(f, G[u][i].cab));\n            if (d > 0){\n                G[u][i].cab -= d;\n                G[to][G[u][i].rev].cab += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s, int t){\n    int ret = 0, tmp;\n    while(true){\n        memset(level, -1, sizeof level);\n        bfs(s, t);\n        if (level[t] == -1) return ret;\n        memset(iter, 0, sizeof iter);\n        while((tmp = dfs(s, t, inf)) != 0) ret += tmp;\n    }\n}\nint l, pos[maxn], t[maxn];\nint dis[maxm][maxm], d;\n//u, v, d;\nint main(){\n//必????才能交 \n//    ios::sync_with_stdio(false);\n\tint ik, i, j, k, kase;\n\twhile(scanf(\"%d%d%d\", &n, &m, &l) && n){\n\t\tmemset(dis, 0x3f, sizeof dis);\n\t\tfor (i = 1; i <= m; ++i){\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tdis[u][v] = dis[v][u] = d;\n\t\t}\n\t\tfor (k = 0; k < n; ++k)\n\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\tfor (j = 0; j < n; ++j) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\tfor (i = 1; i <= l; ++i) scanf(\"%d%d\", pos+i, t+i);\n\t\tfor (i = 0; i < maxn; ++i) G[i].clear();\n\t\tfor (i = 1; i <= l; ++i)\n\t\t\tfor (j = 1; j <= l; ++j){\n\t\t\t\tif (i == j) continue;\n\t\t\t\tif (t[i] < t[j]) continue;\n\t\t\t\tif (t[i] - t[j] >= dis[pos[i]][pos[j]]) add(j, i + l, 1);\n\t\t\t}\n\t\tfor (i = 1; i <= l; ++i){\n\t\t\tadd(0, i, 1);\n\t\t\tadd(i+l, 2*l+1, 1); \n\t\t}\n\t\tprintf(\"%d\\n\", l - max_flow(0, 2*l+1));\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 2525; // TODO:initialize\nconst int INF = 1010101010; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        pq.push(pi(0,s));\n        while(!pq.empty()){\n            pi p = pq.top();\n            pq.pop();\n            int v = p.se;\n            if(p.fi>dist[v]) continue;\n            rep(i,G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    pq.push(pi(dist[e.to],e.to));\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst int M=10;\nint d[100][100];\n\nint main()\n{\n    int n,m,R;\n    while(scanf(\" %d %d %d\", &n, &m, &R),n)\n    {\n        fill(d[0],d[100],INF);\n        rep(i,n) d[i][i]=0;\n        rep(i,m)\n        {\n            int u,v,c;\n            scanf(\" %d %d %d\", &u, &v, &c);\n            d[u][v] = d[v][u] = c;\n        }\n\n        rep(k,n)rep(i,n)rep(j,n) d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n        vector<pi> req(R);\n        rep(i,R)\n        {\n            int p,t;\n            scanf(\" %d %d\", &p, &t);\n            req[i] = pi(t,p);\n        }\n        sort(all(req));\n\n        int l=0,r=n;\n        while(r-l>1)\n        {\n            int mid = (l+r)/2;\n            V = 2*R + mid + 2;\n            int S = 2*R+mid, T = S+1;\n\n            rep(i,MAX_V) G[i].clear();\n\n            rep(i,mid)\n            {\n                add_edge(S,2*R+i,1,0);\n                rep(j,R) add_edge(2*R+i,2*j,1,0);\n                add_edge(2*R+i,T,1,0);\n            }\n            rep(i,R)\n            {\n                add_edge(2*i,2*i+1,1,-M);\n                add_edge(2*i+1,T,1,0);\n            }\n            rep(i,R)for(int j=i+1; j<R; ++j)\n            {\n                int ti = req[i].fi, tj = req[j].fi;\n                int u = req[i].se, v = req[j].se;\n                if(d[u][v]<=tj-ti) add_edge(2*i+1,2*j,1,0);\n            }\n\n            if(min_cost_flow(S,T,mid)==-R*M) r=mid;\n            else l=mid;\n        }\n        printf(\"%d\\n\", r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int MAX_V = 2000;\nint V; // 頂点数!!!\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    int u = G[v][i];\n    int w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof match);\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof used);\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    int d[100][100] = {};\n    REP(i, N) REP(j, N) d[i][j] = (i != j ? INF : 0);\n    REP(i, M){\n      int u, v, c;\n      scanf(\"%d %d %d\", &u, &v, &c);\n      d[u][v] = d[v][u] = c;\n    }\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int p[1000], t[1000];\n    REP(i, L){\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n    V = 2 * L;\n    REP(i, V) G[i].clear();\n    REP(i, L) FOR(j, i + 1, L) if(t[i] > t[j]) { swap(t[i], t[j]); swap(p[i], p[j]); }\n    REP(i, L) FOR(j, i + 1, L){\n      if(t[i] + d[p[i]][p[j]] <= t[j]) add_edge(i, L + j);\n    }\n    cout << L - bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nvector<int> G[2111];\n\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( to );\n  G[to].push_back( from );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\n\nbool used[2111];\nint match[2111];\nint V;\n\nint dfs(int v){\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u = G[v][i], w = match[u];\n    if( w < 0 || (!used[w] && dfs(w)) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset( match, -1, sizeof(match) );\n  for(int v=0;v<V;v++){\n    if( match[v] < 0 ) {\n      memset( used, 0, sizeof ( used ) );\n      if( dfs( v ) ) res++;\n    }\n  }\n  return res;\n}\n\nint solve(){\n  return L - bipartite_matching();\n}\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n\n    for(int i=0;i<L;i++){\n      for(int j=0;j<L;j++){\n        if( i == j )continue;\n        ll len = W[pt[i].second][pt[j].second];\n        ll lt = pt[j].first - pt[i].first;\n        if( len <= lt )          \n          add_edge( i, L+j );\n      }\n    }\n    V = 2 * L;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\nstruct edge{\n    int flow,to,rev;\n};\ntypedef vector<edge> E;\ntypedef vector<E> FlowGraph;\n\nvoid addedge(FlowGraph &g,int from,int to,int f){\n    int a=g[from].size();\n    int b=g[to].size();\n    g[from].push_back(edge{f,to,b});\n    g[to].push_back(edge{0,from,a});\n}\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\nconst LL INF=1e15;\n\nV bfs(FlowGraph &g,int s){\n    int n=g.size();\n    queue<int> que;\n    V dist(n,-1);\n    dist[s]=0;\n    que.push(s);\n    for(;que.size();que.pop()){\n        auto v=que.front();\n        for(auto &e:g[v]){\n            if(e.flow>0&&dist[e.to]==-1){\n                dist[e.to]=dist[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n    return dist;\n}\nint maxflow(FlowGraph &g,int s,int t){\n    int res=0,n=g.size();\n    while(true){\n        auto dist=bfs(g,s);\n        if(dist[t]<0)break;\n        vector<unsigned> iter(n,0);\n        std::function<int(int,int)> dfs=[&](int v,int f){\n            if(v==s)return f;\n            for(auto &i=iter[v];i<g[v].size();i++){\n                edge &e=g[v][i];\n                edge &re=g[e.to][e.rev];\n                if(re.flow>0&&dist[v]>dist[e.to]){\n                    int d=dfs(e.to,min(f,re.flow));\n                    if(d>0){e.flow+=d;re.flow-=d;return d;}\n                }\n            }\n            return 0;\n        };\n        int f;\n        while((f=dfs(t,114514))>0)res+=f;\n    }\n    return res;\n}\n\nint main(){\n    for(int N,M,L;cin>>N>>M>>L,N+M+L;){\n        VV g(N,V(N,INF));\n        for(int i=0;i<M;i++){\n            int u,v,d;\n            cin>>u>>v>>d;\n            g[u][v]=g[v][u]=d;\n        }\n        for(int i=0;i<N;i++)g[i][i]=0;\n        for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n                for(int j=0;j<N;j++)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        using P=tuple<int,int>;\n        vector<P> pt(L);\n        for(int i=0;i<L;i++){\n            int p,t;\n            cin>>p>>t;\n            pt[i]=P(t ,p);\n        }\n        sort(pt.begin(),pt.end());\n        FlowGraph fg(2*L+2);\n        int id=0;\n        int S=id++;\n        int T=id++;\n        vector<int> bg(L),ed(L);\n        for(int i=0;i<L;i++){\n            bg[i]=id++;ed[i]=id++;\n            addedge(fg,S,ed[i],1);\n            addedge(fg,bg[i],T,1);\n            int pv,tv,pu,tu;\n            tie(tv,pv)=pt[i];\n            for(int j=0;j<i;j++){\n                tie(tu,pu)=pt[j];\n                if(g[pv][pu]<=abs(tv-tu))\n                    addedge(fg,ed[j],bg[i],1);                   \n            }\n        }\n        cout<<L-maxflow(fg,S,T)<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint flow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tvector<int> dist((int)G.size(), INF);\n\t\tvector<int> prevV((int)G.size());\n\t\tvector<int> prevE((int)G.size());\n\t\tdist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < dist.size(); ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\treturn INF;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tm[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tm[u][v] = m[v][u] = d;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint s = 2*L+1, t = s+1;\n\t\tG.clear(); G.resize(t+1);\n\n\t\tvector<int> p(L), time(L);\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tcin >> p[i] >> time[i];\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tif (i != j && time[i] + m[p[i]][p[j]] <= time[j]) {\n\t\t\t\t\taddEdge(L+i, j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\taddEdge(s, i, 1, 0);\n\t\t\taddEdge(L+i, t, 1, 0);\n\t\t\taddEdge(i, L+i, 1, -1);\n\t\t}\n\n\t\tint r = 0;\n\t\tvector< vector<Edge> > g = G;\n\t\tfor (int l = 1; l <= L; ++l) {\n\t\t\tr += flow(s, t, 1);\n\t\t\tif (r == -L) {\n\t\t\t\tcout << l << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2010\n#define MAX_N 1010\nusing namespace std;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<l+l+2;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j&&tl[i]+g[idx[i]][idx[j]]<=tl[j])add_edge(i,l+j);\n    \n    V=l+l;\n    cout <<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint main(){\n\tint N,M,L;\n\tint u[1000],v[1000],d[1000],p[1000],t[1000];\n\tvector<int> numofsanta;\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\n\twhile(N != 0 || M != 0 || L != 0){\n\t\tint dist[N][N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = 100000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> psort;\n\t\tvector<int> tsort; \n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d\",&u[i],&v[i],&d[i]);\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\n\t\t//Warshall-Floyd Algorithm\n\n    \tfor(int i = 0; i < N; i++){\n        \tfor(int j = 0; j < N; j++){\n            \tfor(int k = 0; k < N; k++){\n            \t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            \t}\n            }\n        }\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tvector<int>::iterator pit = psort.begin();\n\t\t\tvector<int>::iterator tit = tsort.begin();\t\t\t\t\n\t\t\tscanf(\"%d %d\",&p[i],&t[i]);\n\t\t\tif(i == 0){\n\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\ttsort.push_back(t[i]);\n\t\t\t}else{\n\t\t\t\tint siz = psort.size();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tif(tsort[j] > t[i]){\n\t\t\t\t\t\tpsort.insert(pit,p[i]);\n\t\t\t\t\t\ttsort.insert(tit,t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\t\t\ttsort.push_back(t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++pit;\n\t\t\t\t\t\t++tit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint nos = 1;\n\t\tvector<int> santanow;\n\t\tvector<int> santatime;\n\t\tfor(int i = 0; i < psort.size(); i++){\n\t\t\tif(i == 0){\n\t\t\t\tsantanow.push_back(psort[i]);\n\t\t\t\tsantatime.push_back(0);\n\t\t\t}else{\n\t\t\t\tint siz = santanow.size();\n\t\t\t\tint a = -1;\n\t\t\t\tint min = 1000000000;\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tint temp = santatime[j]  + dist[psort[i]][santanow[j]];\n\t\t\t\t\tif(temp <= tsort[i] && temp <= min){\n\t\t\t\t\t\ta = j;\n\t\t\t\t\t\tmin = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<int>::iterator itn = santanow.begin();\n\t\t\t\tvector<int>::iterator itt = santatime.begin();\n\t\t\t\tif(a != -1){\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\titn++;\n\t\t\t\t\t\titt++;\n\t\t\t\t\t}\n\t\t\t\t\titt = santatime.erase(itt);\n\t\t\t\t\tsantatime.insert(itt,tsort[i]);\n\t\t\t\t\titn = santanow.erase(itn);\n\t\t\t\t\tsantanow.insert(itn,psort[i]);\n\t\t\t\t}else{\n\t\t\t\t\tsantanow.push_back(psort[i]);\n\t\t\t\t\tsantatime.push_back(tsort[i]);\n\t\t\t\t\tnos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnumofsanta.push_back(nos);\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t}\n\n\tfor(int i = 0; i < numofsanta.size(); i++){\n\t\tprintf(\"%d\\n\",numofsanta[i]);\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2010\n#define MAX_N 1010\nusing namespace std;\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n  return max_flow(s,t);\n}\n\n\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<l+l+2;i++)G[i].clear();\n    \n\n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    \n  memset(can,0,sizeof(can));\n  for(int i=0;i<l;i++)\n    for(int j=0;j<l;j++)\n      if(i!=j&&tl[idx[i]]+g[idx[i]][idx[j]]<=tl[idx[j]])can[i][j]=1;\n  cout <<l-Biparite_Matching(l,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n\tpa[s]=dag[s][i],pa[dag[s][i]]=s;\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  \n  while(cin>>N>>M>>L,N){\n    int d[N][N];\n    memset(d,INT_MAX,sizeof(d));\n    rep(i,N)d[i][i]=0;\n\n    rep(i,M){\n      int u,v,w; cin>>u>>v>>w;\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L], t[L];\n    rep(i,L)cin>>p[i]>>t[i];\n  \n    // calc shortest path\n    rep(i,N)rep(j,N)rep(k,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?d[i][k]+d[k][j]:d[i][j];\n    // calc DAG\n    vector<int> dag[N];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[p[i]].push_back(p[j]),dag[p[j]].push_back(p[i]);}\n    // enumerate santas\n    int num=L;\n    int pa[L];memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[N];memset(v,0,sizeof(v));\n      if(dfs(p[i],v,pa,dag))num--;\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\n#define MAX_L 2005\nint N,M,L;\nint a[MAX_N][MAX_N];\nint t[MAX_L],u[MAX_L];\n\nvector<int> G[MAX_L];\nbool used[MAX_L];\nint match[MAX_L];\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w==-1||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching(){\n  memset(match,-1,sizeof(match));\n  int res=0;\n  for(int i=0;i<L;i++){\n    if(match[i]==-1){\n      memset(used,false,sizeof(used));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)\n    for(int j=0;j<MAX_N;j++)\n      a[i][j]=(i==j?0:1e9);\n  for(int i=0;i<MAX_L;i++)G[i].clear();\n}\n\nint main(){\n  while(1){\n    cin>>N>>M>>L;\n    if(N==0&&M==0&&L==0)break;\n    init();\n    for(int i=0;i<M;i++){\n      int from,to,cost;\n      cin>>from>>to>>cost;\n      a[from][to]=min(a[from][to],cost);\n      a[to][from]=min(a[to][from],cost);\n    }\n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          a[i][j]=min(a[i][j],a[i][k]+a[k][j]);\n\n    \n    for(int i=0;i<L;i++){\n      cin>>t[i]>>u[i];\n      for(int j=0;j<i;j++){\n        int from=i,to=j;\n        if(u[from]>u[to])swap(from,to);\n        if(u[from]+a[t[from]][t[to]]<=u[to]){\n          G[from].push_back(to+L);\n          G[to+L].push_back(from);\n        }\n      }\n    }\n    cout<<L-matching()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\n\ntypedef int Cost;Cost CINF=1<<28;\nnamespace EGraph{\n\tstruct Edge{\n\t\tint from,to;Cost cost;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost) {};\n\t\tbool operator<(Edge r) const{\n\t\t\treturn cost<r.cost;\n\t\t}\n\t\tbool operator>(Edge r) const{\n\t\t\treturn cost>r.cost;\n\t\t}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nnamespace MGraph{\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\nusing namespace EGraph;\n\nnamespace MaximamFlows{\n    typedef int Flow;\n    const int INF = 1 << 28;\n    struct Edge{\n        int to;Flow cap;int rev;\n        Edge(int to,Flow cap,int rev) : to(to),cap(cap),rev(rev) {};\n    };\n    typedef vector<vector<Edge> > Graph;\n\n    //dinic O(V^2*E)\n    class MaximamFlow{\n    private:\n            //iter　次に調べる時の開始位置 距離\n        vector<int> iter,dist;\n            //sからのbfs距離の計算\n        void bfs_dist(int s){\n            fill(ALL(dist),-1);dist[s]=0;\n            queue<int> que;que.push(s);\n            while(!que.empty()){\n                int v=que.front();que.pop();\n                EACH(e,G[v]){\n                    if(e->cap>0 && dist[e->to] == -1){\n                        dist[e->to]=dist[v]+1;\n                        que.push(e->to);\n                    }\n                }\n            }\n        }\n            //増加パス\n        Flow dfs_best_path(int v,int t,Flow f){\n            if(v==t)return f;\n            for(int &i =iter[v];i<(int)G[v].size();i++){\n                Edge& e=G[v][i];\n                if(e.cap>0 && dist[v]<dist[e.to]){\n                    Flow d=dfs_best_path(e.to,t,min(f,e.cap));\n                    if(d>0){\n                        e.cap-=d;G[e.to][e.rev].cap+=d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n    public:\n        int V;Graph G;\n        MaximamFlow(int V):V(V){\n            G=Graph(V);\n            dist=vector<int>(V);iter=vector<int>(V);\n        }\n\n        void add_edge(int from,int to,int cap){\n            int fromrev=G[to].size(),torev=G[from].size();\n            G[from].push_back(Edge(to,cap,fromrev));G[to].push_back(Edge(from,0,torev));\n        }\n        int max_flow(int s,int t){\n            Flow flow=0;\n            while(true){\n                bfs_dist(s);\n                if(dist[t]<0)return flow;\n                fill(ALL(iter),0);\n                Flow f;\n                while((f=dfs_best_path(s,t,INF))>0)flow+=f;\n            }return -1;\n        }\n    };\n}\nusing namespace MaximamFlows;\n\n\n//dagの最小パス被覆＝最大反鎖\nclass Main{\npublic:\n\tint N,M,L;\n\tMat g;\n\tvector<int> ps,ts;\n\tbool input(){\n\t\tnextInt(N);nextInt(M);nextInt(L);if(N==0)return false;\n\t\tg=Mat(N,vector<Cost>(N,CINF));\n\t\tREP(i,N)g[i][i]=0;\n\t\tREP(i,M){\n\t\t\tint u,v,d;nextInt(u);nextInt(v);nextInt(d);\n\t\t\tg[u][v]=g[v][u]=d;\n\t\t}\n\t\tps=vector<int>(L);ts=vector<int>(L);\n\t\tREP(i,L){\n\t\t\tnextInt(ps[i]);nextInt(ts[i]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run(){\n\t\twhile(input()){\n\t\t\twarshall_floyd(g);\n\t\t\tMaximamFlow mf(2*L+2);\n\t\t\tREP(i,L)REP(j,L)if(g[ps[i]][ps[j]]<=ts[j]-ts[i] &&i!=j){\n\t\t\t\tmf.add_edge(i, L+j,1);\n\t\t\t}\n\t\t\tREP(i,L)mf.add_edge(2*L,i,1);\n\t\t\tREP(j,L)mf.add_edge(L+j,2*L+1,1);\n\n\t\t\tcout <<L-mf.max_flow(2*L, 2*L+1)<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 3050\n#define INF 1<<28\nvector<int> G[MAX_V];\nint match[MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\ntypedef pair<int,int> P;\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n    int e[n][n];\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) e[i][j]=(i!=j)*INF;\n    for(int i=0;i<m;i++){\n      int u,v,d;\n      cin>>u>>v>>d;\n      e[u][v]=e[v][u]=d;\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n    vector<P> p(l);\n    for(int i=0;i<l;i++) cin>>p[i].first>>p[i].second;\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i==j) continue;\n\tint u=p[i].first,v=p[j].first;\n\tif(p[j].second-p[i].second>=e[u][v]) add_edge(i,l+j);\n      }\n    }\n    V=l*2;\n    cout<<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nWeight INF=1e9;\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=false;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push(make_pair(Weight(0),s));\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push(make_pair(dist[e.to],e.to));\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\nint solve();\nint main(){\n    while(solve()){\n\n    }\n    return true;\n}\nint solve(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    if(n==0) return false;\n    vector<vector<int>> d(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        int dd;\n        cin>>dd;\n        d[u][v]=dd;\n        d[v][u]=dd;\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n    vector<int> p(l),t(l);\n    for(int i=0;i<l;i++) cin>>p[i]>>t[i];\n    vector<pair<int,int>> tp(l);\n    for(int i=0;i<l;i++) tp[i]={t[i],p[i]};\n    sort(tp.begin(),tp.end());\n    for(int i=0;i<l;i++){\n        t[i]=tp[i].first;\n        p[i]=tp[i].second;\n    }\n\n    Flow org(2*l+4);\n    //[0,l):in\n    int S=2*l;\n    int superS=2*l+1;\n    int T=2*l+2;\n    int superT=2*l+3;\n    \n    for(int i=0;i<l;i++){\n        org.addEdge(S,i,1,0);\n        org.addEdge(i+l,T,INF,0);\n        //org.addEdge(i,i+l,1,-1);\n        org.addEdge(i+l,i,1,1);\n        org.addEdge(superS,i+l,1,0);\n        org.addEdge(i,superT,1,0);\n    }\n\n    for(int i=0;i<l;++i){\n        vector<int> town(n,false);\n        vector<int> index;\n        for(int j=i+1;j<l;j++){\n            if(town[p[j]] || d[p[i]][p[j]]>t[j]-t[i]) continue;\n            town[p[j]]=true;            \n            index.push_back(j);\n        }\n        for(int j=0;j<index.size();j++){\n            bool isok=true;\n            for(int k=0;k<j;k++){\n                if(d[p[index[j]]][p[index[k]]]<=t[index[k]]-t[index[j]]) isok=false;\n            }\n            if(isok){\n                org.addEdge(l+i,index[j],1,0);\n                org.addEdge(l+i,index[j]+l,INF,0);\n            }\n        }\n    }\n    \n    \n    \n    org.addEdge(superS,S,l,0);\n    org.addEdge(T,superT,l,0);\n    org.addEdge(S,T,n,0);\n    int cost=org.minCostFlow(superS,superT,l+l);\n    cost-=l*1000;\n    cout<<cost<<endl;\n\n    return true;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,l;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[1005];\nbool used[1005];\nint E[105][105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nint p[1005],t[1005];\nint main(){\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) return 0;\n\t\trep(i,105) rep(j,105){\n\t\t\tE[i][j] = INF;\n\t\t\tif(i==j) E[i][j] = 0;\n\t\t}\n\t\trep(i,1005){\n\t\t\tG[i].clear(); used[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tE[u][v] = E[v][u] = d;\n\t\t}\n\t\tfor(int i=0;i<l;i++) cin >> p[i] >> t[i];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tE[j][k] = min(E[j][k],E[j][i]+E[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(t[i]+E[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(p[i],p[j]+105,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) add_edge(301,i,1);\n\t\tfor(int i=0;i<n;i++) add_edge(i+105,302,1);\n\t\tcout << l-max_flow(301,302) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nlong long int d[1000][1000];\n\nvoid warshall_floyd(int n){\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n}\n\nstruct edge{\n\tlong long int to, cap, rev; // \n};\n\n#define MAX_V 2100\n\nvector<edge> G[MAX_V] = {};\nbool used[MAX_V];\n\n// \nvoid add_edge(long long int from, long long int to, long long int cap){\n\tG[from].push_back((edge){to, cap, (long long int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (long long int)G[from].size() - 1}); // \n\t// G[to].push_back((edge){from, cap, G[from].size() - 1}); // \n}\n\n// \nlong long int dfs(int v, int t, long long int f){\n\tif(v == t){\n\t\treturn f;\n\t}\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tlong long int d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// \nlong long int max_flow(int s, int t){\n\tlong long int flow = 0;\n\twhile(true){\n\t\tfill(used, used + MAX_V, 0);\n\t\tlong long int f = dfs(s, t, INF);\n\t\tif(f == 0){\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n    while(true){\n        int N, M, L;\n        cin >> N >> M >> L;\n        if(N == 0){\n            break;\n        }\n        for(int i = 0; i < N; i++){\n            for(int j = 0; j < N; j++){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        for(int i = 0; i < M; i++){\n            int u, v, d_;\n            cin >> u >> v >> d_;\n            d[u][v] = d[v][u] = d_;\n        }\n        warshall_floyd(N);\n        long long int p[1100], t[1100];\n        for(int i = 0; i < L; i++){\n            cin >> p[i] >> t[i];\n        }\n        for(int i = 0; i < MAX_V; i++){\n            G[i].clear();\n        }\n        for(int i = 1; i <= L; i++){\n            add_edge(0, i, 1);\n            add_edge(i + L, 2 * L + 1, 1);\n        }\n        for(int i = 0; i < L; i++){\n            for(int j = 0; j < L; j++){\n                if(i != j && t[j] - t[i] >= d[p[i]][p[j]]){\n                    add_edge(i + 1, j + 1 + L, 1);\n                }\n            }\n        }\n        cout << L - max_flow(0, 2 * L + 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=1006, E=5000006, INF=0x3fffffff;\n\nstruct ARC\n{\n    int u, next;\n    void init(int a, int b)\n    {\n        u=a, next=b;\n    }\n} arc[E];\nint head[N], tot;\n\nvoid add_edge(int s, int t)\n{\n    arc[tot].init(t, head[s]);\n    head[s]=tot++;\n}\n\nint n, m, nn, mm, L;\nbool vs[N];\nint G[106][106], id[N], T[N], mth_L[N], mth_R[N];\n\nbool Find(int u)\n{\n    if(vs[u]) return false;\n    vs[u]=true;\n    for(int e=head[u]; e!=-1; e=arc[e].next)\n    {\n        int v=arc[e].u;\n        if(mth_R[v]==-1 || Find(mth_R[v]))\n        {\n            mth_L[u]=v, mth_R[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint MaxMatch()\n{\n    int ans=0;\n    memset(mth_L, -1, sizeof mth_L);\n    memset(mth_R, -1, sizeof mth_R);\n    for(bool flag=false; 1; flag=false)\n    {\n        memset(vs, 0, sizeof vs);\n        for(int i=0; i<n; i++)\n            if(mth_L[i]==-1 && Find(i)) ans++, flag=true;\n        if(!flag) return ans;\n    }\n}\n\nvoid Floyd() {\n\tfor(int k=0; k<nn; k++)\n\t\tfor(int i=0; i<nn; i++)\n\t\t\tfor(int j=0; j<nn; j++) {\n\t\t\t\tif(G[i][k]==INF || G[k][j]==INF) continue;\n\t\t\t\tG[i][j]=min(G[i][j], G[i][k]+G[k][j]);\n\t\t\t}\n}\n\nint main() {\n\twhile(scanf(\"%d%d%d\", &nn, &mm, &L), nn!=0 || mm!=0 || L!=0) {\n\t\tfor(int i=0; i<nn; i++)\n\t\t\tfor(int j=0; j<nn; j++) G[i][j]=INF;\n\t\tfor(int i=0, a, b, c; i<mm; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tG[a][b]=G[b][a]=min(G[a][b], c);\n\t\t}\n\t\tFloyd();\n\t\tfor(int i=0; i<L; i++) scanf(\"%d%d\", &id[i], &T[i]);\n\t\tn=L;\n\t\tmemset(head, -1, sizeof head);\n\t\ttot=0;\n\t\tfor(int i=0; i<L; i++)\n\t\t\tfor(int j=0; j<L; j++) {\n\t\t\t\tint u=id[i], v=id[j];\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(G[u][v]==INF) continue;\n\t\t\t\tif(T[i]+G[u][v]>T[j]) continue;\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\tprintf(\"%d\\n\", L-MaxMatch());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <limits>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n#define   min_int(a,b)  ( ((a)<(b) ) ? (a) : (b) )\nusing namespace std;\nclass Req{\npublic:\n  char house;\n  int time;\n};\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\nint dist[max_n][max_n];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\nint req_graph[max_l][max_l];\nint num_child[max_l];//各リクエストxの子の数\nint parent[max_l]; //被覆パスにおけるリクエストxの親\nint till[max_l];\nbool visited[max_l];\nint halfmax = (numeric_limits<int>::max())/2;\n \n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n   \n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j,h1,h2;\n \n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++) for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] != halfmax) //h1、h2間に経路あり\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n  } \n}\n \nint find(int i, bool root){\n  int child, x, found;\n  //親権の空いている子を探す\n  visited[i] = true;  \n  if(till[i] < num_child[i]){    \n    while((++(till[i])) < num_child[i]){\n      child = req_graph[i][till[i]];\n      if(parent[child] >= 0) continue;\n      parent[child] = i; //childを自分の子とする\n      return child;\n    }\n  }\n  //他の親から親権を譲ってもらえる子を探す  \n  for(int j = 0;j < num_child[i]; j++){\n    child = req_graph[i][j];\n    x = parent[child]; //x: childのパス上の親\n    if(visited[x]) continue;\n    found = find(x,false); //xからchildの親権をもらう交渉\n    if(found < 0) continue;\n    parent[child] = i; //childの親権獲得\n    return child;\n  }\n  return -1;\n}\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  memset(till,-1,l*sizeof(int));\n  memset(parent,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    memset(visited,0,l*sizeof(bool));\n    find(i,true);\n  }\n  for(int i=0;i<l;i++) if(parent[i]<0) num++;\n  return num;\n}\n \n//プレゼント配送に必要なサンタの数を出力する関数\nint santas(){\n  int u,v,d,i,j;\n  //入力読み込み\n  for(i=0;i<n;i++) dist[i][i] = 0;\n  for(i=0;i<n;i++) for(j=i+1;j<n;j++) dist[i][j] = halfmax;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  return res;\n}\n \n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;    \n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<string.h>\n#include<algorithm>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n \nusing namespace std;\ntypedef long long ll;\n \n/**\n * F-F ??????????????¨?????????????????¨\n */\ntemplate<int V>\nstruct MaxFlow {\n    struct Edge {\n        int to, rev, cap;\n    };\n    vector<Edge> g[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    /// ??????????????¨?????????, ??????1??????2????????????????????????????????????\n    void add_multi(int from, int to, int cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    int erase(int from, int to) {\n        for (int i = 0; i < (int)g[from].size(); i++) {\n            auto e = g[from][i];\n            if (e.to == to) {\n                int c = g[to][e.rev].cap - e.cap;\n                g[to].erase(g[to].begin()+e.rev);\n                g[from].erase(g[from].begin()+i);\n                return c;\n            }\n        }\n        assert(false);\n    }\n\n    bool used[V];\n    bool dfs(int s, int t) {\n        if (s == t) return true;\n        used[s] = true;\n        for (auto &e : g[s]) {\n            if (used[e.to]) continue;\n            if (!e.cap) continue;\n            if (dfs(e.to, t)) {\n                e.cap -= 1;\n                g[e.to][e.rev].cap += 1;\n                return true;\n            }\n        }\n        return false;\n    }\n    int exec(int s, int t, int F) {\n        int f = 0;\n        while (f < F) {\n            fill_n(used, V, false);\n            if (!dfs(s, t)) break;\n            f++;\n        }\n        return f;\n    }\n    void print() {\n        for (int i = 0; i < V; i++) {\n            for (auto &e: g[i]) {\n                printf(\"(%d %d %d)\\n\", i, e.to, e.cap);\n            }\n        }\n    }\n};\n\n \ntypedef pair<int, int> P;\nconst int MN = 110;\nconst int ML = 1100;\nMaxFlow<ML*2> mf;\n \nint dist[MN][MN];\nP qu[ML];\nbool solve() {\n    mf.init();\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (!n) return false;\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = 1e8;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j],\n                    dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n \n \n    for (int i = 0; i < l; i++) {\n        int p, t;\n        cin >> p >> t;\n        qu[i] = P(t, p);\n    }\n    sort(qu, qu+l);\n \n    int vs = 2*ML-1;\n    int vt = 2*ML-2;\n    for (int i = 0; i < l; i++) {\n        for (int j = i+1; j < l; j++) {\n            int ap, at, bp, bt;\n            tie(at, ap) = qu[i];\n            tie(bt, bp) = qu[j];\n            if (dist[ap][bp] <= bt - at) {\n                mf.add(i, j+ML, 1);\n            }\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        mf.add(vs, i, 1);\n        mf.add(i+ML, vt, 1);\n    }\n    cout << l - mf.exec(vs, vt, 100000) << endl;\n    return true;\n}\n \nint main() {\n    while (true) {\n        if (!solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\nconst int MAX_V=2000;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v]=true;\n\trep(i,G[v].size()){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint nibu(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\trep(v,V){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\nint N,M,L,INF=1e9;\nll d[100][100];\nint p[1000],t[1000];\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>L;\n\t\tif(N==0) break;\n\t\trep(i,N) rep(j,N) if(i!=j) d[i][j]=INF;\n\t\trep(i,M){\n\t\t\tint u,v,di;\n\t\t\tcin>>u>>v>>di;\n\t\t\td[u][v]=di;\n\t\t\td[v][u]=di;\n\t\t}\n\t\trep(i,N) rep(j,N) rep(k,N) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\trep(i,L) cin>>p[i]>>t[i];\n\t\tV=2*L;\n\t\trep(i,V) G[i].clear();\n\t\trep(i,L) rep(j,L) if(i!=j){\n\t\t\tif(t[i]+d[p[i]][p[j]]<=t[j]){\n\t\t\t\tadd_edge(i,j+L);\n\t\t\t}\n\t\t}\n\t\tcout<<L-nibu()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, M, L;\nconst int MAX_V = 2100;\nint V;\nVI biG[MAX_V];\nVI origG[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\n\nvoid add_edge(int u, int v){\n  biG[u].push_back(v);\n  biG[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0;i<biG[v].size();++i){\n\tint u = biG[v][i], w = match[u];\n\tif(w < 0 || !used[w] && dfs(w)){\n\t  match[v] = u;\n\t  match[u] = v;\n\t  return true;\n\t}\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v=0;v<V;++v){\n\tif(match[v] < 0){\n\t  memset(used, false, sizeof(used));\n\t  if(dfs(v))\n\t\t++res;\n\t}\n  }\n  return res;\n}\n\nint findMinPathcover(int n){\n  REP(i,MAX_V) biG[i].clear();\n  V = 2*n;\n  REP(i,n) REP(j,SZ(origG[i])){\n\tadd_edge(i, n+origG[i][j]);\n  }\n  int res = bipartite_matching();\n  return n - res;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>L,N){\n\tREP(i,MAX_V) origG[i].clear();\n\tvector<vector<LL>> dist(N, vector<LL>(N, 1e+15));\n\tREP(i,N) dist[i][i] = 0;\n\tREP(i,M){\n\t  int u, v, d;\n\t  cin >> u >> v >> d;\n\t  dist[u][v] = dist[v][u] = d;\n\t}\n\n\tREP(k,N) REP(i,N) REP(j,N)\n\t  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tvector<LL> p(L), t(L);\n\tREP(i,L) cin >> p[i] >> t[i];\n\tREP(i,L) REP(j,L)\n\t  if(i != j && t[i] + dist[p[i]][p[j]] <= t[j])\n\t\torigG[i].PB(j);\n\tcout << findMinPathcover(L) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\nint v[100][100];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(i, n)REP(j, n)v[i][j] = INF;\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n#define   min_int(a,b)  ( ((a)<(b) ) ? (a) : (b) )\nusing namespace std;\nclass Req{\npublic:\n  char house;\n  int time;\n};\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\nint dist[max_n][max_n];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\nint req_graph[max_l][max_l];\nint num_child[max_l];//各リクエストxの子の数\nint parent[max_l]; //被覆パスにおけるリクエストxの親\nint till[max_l];\nbool visited[max_l];\n \n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n   \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j,h1,h2;\n \n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++) for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n  } \n}\n \nint find(int i, bool root){\n  int child, x, found;\n  //親権の空いている子を探す\n  visited[i] = true;  \n  if(till[i] < num_child[i]){    \n    while((++(till[i])) < num_child[i]){\n      child = req_graph[i][till[i]];\n      if(parent[child] >= 0) continue;\n      parent[child] = i; //childを自分の子とする\n      return child;\n    }\n  }\n  //他の親から親権を譲ってもらえる子を探す  \n  for(int j = 0;j < num_child[i]; j++){\n    child = req_graph[i][j];\n    x = parent[child]; //x: childのパス上の親\n    if(visited[x]) continue;\n    found = find(x,false); //xからchildの親権をもらう交渉\n    if(found < 0) continue;\n    parent[child] = i; //childの親権獲得\n    return child;\n  }\n  return -1;\n}\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  memset(till,-1,l*sizeof(int));\n  memset(parent,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    memset(visited,0,l*sizeof(bool));\n    find(i,true);\n  }\n  for(int i=0;i<l;i++) if(parent[i]<0) num++;\n  return num;\n}\n \n//プレゼント配送に必要なサンタの数を出力する関数\nint santas(){\n  int u,v,d,i;\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  return res;\n}\n \n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;    \n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  int cost[100][100];\n  int p[1000], t[1000];\n\n  while(scanf(\"%d %d %d\", &N, &M, &L), L) {\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) cost[i][j] = INF;\n      cost[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      cost[u][v] = cost[v][u] = d;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n\n    Bipartite_Matching flow(L, L);\n    for(int i = 0; i < L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(i == j) continue;\n        if(t[j] - t[i] >= cost[p[i]][p[j]]) {\n          flow.add_edge(i, j);\n        }\n      }\n    }\n    printf(\"%d\\n\", L - flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(scanf(\"%d%d%d\",&N,&M,&L),N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n      d[u][v]=d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)scanf(\"%d%d\",&p[i],&t[i]);\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    printf(\"%d\\n\",num);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\ntemplate <typename Weight, int MAX_N, Weight INF> class MaxFlow{\nprivate:\n\tstruct E{\n\t\tint to, rev;\n\t\tWeight lim;\n\t\tE(int x, Weight y, int z){\n\t\t\tto = x;\n\t\t\tlim = y;\n\t\t\trev = z;\n\t\t}\n\t};\n\n\tvector<E> edge[MAX_N];\n\tint lev[MAX_N];\n\tint iter[MAX_N];\n\n\n\tWeight dfs(int s, int g, Weight f){\n\t\tif(s == g)return f;\n\t\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\t\tE &e = edge[s][i];\n\t\t\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\t\tWeight tmp = dfs(e.to, g, min(f, e.lim));\n\t\t\tif(tmp<1e-9)continue;\n\t\t\te.lim -= tmp;\n\t\t\tedge[e.to][e.rev].lim += tmp;\n\t\t\treturn tmp;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid bfs(int x){\n\t\tqueue<int> q;\n\t\tq.push(x);\n\t\tint p = 0;\n\t\t\twhile(!q.empty()){\n\t\t\tfor(int i = q.size();i--;){\n\t\t\t\tint tmp = q.front();q.pop();\n\t\t\t\tif(lev[tmp] != INF)continue;\n\t\t\t\tlev[tmp] = p;\n\t\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == INF)q.push(edge[tmp][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n\npublic:\n\tvoid make_edge(int a, int b, Weight l){\n\t\tedge[a].push_back(E(b, l, edge[b].size()));\n\t\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n\t}\n\n\tWeight max_flow(int s, int g){\n\t\tWeight res = 0;\n\t\tbool fin = false;\n\t\twhile(!fin){\n\t\t\tfill(lev, lev + MAX_N, INF);\n\t\t\tfill(iter, iter + MAX_N, 0);\n\t\t\tbfs(s);\n\t\t\tfin = true;\n\t\t\twhile(true){\n\t\t\t\tWeight p = dfs(s, g, INF);\n\t\t\t\tif(p < 1e-9)break;\n\t\t\t\tfin = false;\n\t\t\t\tres += p;\n\t\t\t}\n\t\t}\t\n\t\treturn res;\n\t}\n};\n\n\n#define INF (1 << 30)\n\nint dist[108][108];\nint p[1080], t[1080];\nint main(){\n\tint n, m, l, u, v, d;\n\twhile(cin >> n >> m >> l, n|m|l){\t\t\n\t\tMaxFlow<int, 2160, INF> mf;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\t\telse dist[i][j] = INF-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tfor(int j = 0;j < n;j++)\n\t\t\t\tfor(int k = 0;k < n;k++)\n\t\t\t\t\tdist[j][k] = min(dist[j][i] + dist[i][k], dist[j][k]);\n\t\tfor(int i = 0;i < l ;i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0;i < l;i++){\n\t\t\tmf.make_edge(l * 2, i, 1);\n\t\t\tmf.make_edge(i + l, l * 2+1, 1);\t\t\t\n\t\t\tfor(int j = 0;j < l;j++){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tmf.make_edge(i, j + l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << l - mf.max_flow(l * 2, l * 2 + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#include <string>\n#define INF 0x3fffffff\n#define eps 1e-8\nusing namespace std;\nint n,m,l;\nint head[5005],cnt;\nint dis[105][105];\nint p[5005],t[5005];\nint linked[5005];\nbool used[5005];\n\nstruct ed\n{\n    int next,to;\n}edge[10005];\n\nvoid addedge(int u,int v)\n{\n    cnt++;\n    edge[cnt].next=head[u];\n    head[u]=cnt;\n    edge[cnt].to=v;\n}\n\nbool dfs(int n)\n{\n    int e,v;\n    for(e=head[n];e;e=edge[e].next)\n    {\n        v=edge[e].to;\n        if(!used[v])\n        {\n            used[v]=1;\n            if(linked[v]==-1||dfs(linked[v]))\n            {\n                linked[v]=n;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint solve()\n{\n    memset(linked,-1,sizeof(linked));\n    int i,res=0;\n    for(i=0;i<l;++i)\n    {\n        memset(used,0,sizeof(used));\n        if(dfs(i))\n            res++;\n    }\n    return res;\n}\n\nvoid Floyd()\n{\n    int i,j,k;\n    for(k=0;k<n;++k)\n        for(i=0;i<n;++i)\n            for(j=0;j<n;++j)\n            {\n                if(k==i||k==j||i==j)\n                    continue;\n                if(dis[i][j]>dis[i][k]+dis[k][j])\n                    dis[i][j]=dis[i][k]+dis[k][j];\n            }\n}\n\nint main()\n{\n    int u,v,i,j;\n    while(scanf(\"%d%d%d\",&n,&m,&l)&&n)\n    {\n        for(u=0;u<n;++u)\n            for(v=0;v<n;++v)\n            dis[u][v]=dis[v][u]=INF;\n        while(m--)\n        {\n            scanf(\"%d%d%d\",&u,&v,&i);\n            dis[u][v]=dis[v][u]=i;\n        }\n        for(i=0;i<n;++i)\n            dis[i][i]=0;\n        Floyd();\n        for(i=0;i<l;++i)\n            scanf(\"%d%d\",p+i,t+i);\n        memset(head,0,sizeof(head));\n        cnt=0;\n        for(i=0;i<l;++i)\n            for(j=0;j<l;++j)\n            if(i!=j&&t[i]>=t[j]+dis[p[j]][p[i]])\n            {\n                addedge(j,i+l);\n                addedge(i+l,j);\n            }\n        printf(\"%d\\n\",l-solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 5000\nusing namespace std;\ntypedef pair<int,int> ii;\n\n// flow --- start\nstruct edge\n{\n  int to,cap,rev;\n  edge(int to=inf,int cap=inf,int rev=inf):to(to),cap(cap),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint level[MAX];\nint iter[MAX];\n\nvoid add_edge(int from,int to,int cap)\n{\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n  rep(i,MAX)level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty())\n    {\n      int v = que.front(); que.pop();\n      rep(i,G[v].size())\n\t{\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && level[e.to] < 0)\n\t    {\n\t      level[e.to] = level[v] + 1;\n\t      que.push(e.to);\n\t    }\n\t}\n    }\n} \n\nint dfs(int v,int t,int f)\n{\n  if(v == t)return f;\n  for(int &i = iter[v]; i < G[v].size() ; i++)\n    {\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to])\n\t{\n\t  int d = dfs(e.to,t,min(f,e.cap));\n\t  if(d > 0)\n\t    {\n\t      e.cap -= d;\n\t      G[e.to][e.rev].cap += d;\n\t      return d;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;)\n    {\n      bfs(s);\n      if(level[t] < 0)return flow;\n      rep(i,MAX)iter[i] = 0;\n      int f;\n      while((f = dfs(s,t,inf)) > 0)\n\tflow += f;\n    }\n}\n\n// flow --- end\n\n\nint N,M,L;\nint mincost[MAX][MAX];\nvector<ii> ps;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      rep(i,MAX)G[i].clear();\n      rep(i,N)rep(j,N)mincost[j][i] = inf;\n      rep(i,N)        mincost[i][i] = 0;\n\n      \tint u,v,d;\n\trep(i,M)\n\t  {\n\t    cin >> u >> v >> d;\n\t    mincost[u][v] = mincost[v][u] = d;\n\t  }\n\trep(i,N)rep(j,N)rep(k,N)mincost[j][k] = min(mincost[j][k],mincost[j][i]+mincost[i][k]);\n\n\tps.clear();\n\tps.resize(L);\n\trep(i,L)cin >> ps[i].first >> ps[i].second;\n\tV = L;\n\n\tint st = 2*V,ed = 2*V+1;\n\trep(i,V)        add_edge(st,i,1);\n\trep(i,V)rep(j,V)if(i != j && ps[i].second+mincost[ps[i].first][ps[j].first] <= ps[j].second)add_edge(i,V+j,1);\n\trep(i,V)        add_edge(V+i,ed,1);\n\n\tcout << V-max_flow(st,ed) << endl;\n\n      }\n\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int MAX_V = 2000 + 10;\n\nint V;\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V];\n\nvoid add_edge(int v,int u){\n    G[v].push_back(u);\n    G[u].push_back(v);\n}\n\nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        int w = match[u];\n\n        if(w < 0 || (!used[w]&&dfs(w))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret = 0;\n    memset(match,-1,sizeof(match));\n\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)) ret++;\n        }\n    }\n    return ret;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    int d[100][100] = {};\n    REP(i, N) REP(j, N) d[i][j] = (i != j ? INF : 0);\n    REP(i, M){\n      int u, v, c;\n      scanf(\"%d %d %d\", &u, &v, &c);\n      d[u][v] = d[v][u] = c;\n    }\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int p[1000], t[1000];\n    REP(i, L){\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n    V = 2 * L;\n    REP(i, V) G[i].clear();\n    REP(i, L) FOR(j, i + 1, L) if(t[i] > t[j]) { swap(t[i], t[j]); swap(p[i], p[j]); }\n    REP(i, L) FOR(j, i + 1, L){\n      if(t[i] + d[p[i]][p[j]] <= t[j]) add_edge(i, L + j);\n    }\n    cout << L - bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string.h>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\nint min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n  for(i=0;i<l;i++) printf(\"%3d\",pathParent[i]);\n  printf(\"\\n\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++) find(i);\n  for(int i=0;i<l;i++) if(pathParent[i]<0) num++;\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BipartiteMatching {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\tvector<int> used;\n\tBipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\trep(i, 0, n)match[i] = -1;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (augment(v))cnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\tbool augment(int v) {\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tBipartiteMatching bm(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tbm.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - bm.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<set>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define INF (1<<30)\n#define maxn 1005\nint n,m,l;\nint dis[maxn][maxn],mark[maxn],t[maxn],sum=0,fa[maxn];\nbool vis[maxn],f[maxn][maxn],vis1[maxn];\nvoid judge(int i)\n{\n    queue<int> q;\n    q.push(i);\n    while(!q.empty())\n    {\n\n        int u=q.front();q.pop();\n        vis1[u]=1;\n\n        //printf(\"i=%d,u=%d\\n\",i,u);\n        if(i!=u)\n        f[i][u]=1;\n        for(int k=0;k<l;k++)\n        {\n            if(f[u][k]&&!vis1[k])\n                q.push(k);\n        }\n    }\n}\n\nbool dfs(int i)\n{\n    for(int j=0;j<l;j++)\n    {\n        if(!vis[j]&&f[i][j])\n        {\n            vis[j]=1;\n            if(mark[j]==-1||dfs(mark[j]))\n            {\n                mark[j]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n\n}\nvoid solve()\n{\n    memset(mark,-1,sizeof(mark));\n    for(int i=0;i<l;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if(dfs(i))sum++;\n    }\n}\nvoid build()\n{\n    int i,j;\n    for(i=0;i<l;i++)\n    {\n        for(j=0;j<l;j++)\n        {\n            if(dis[i][j]!=INF&&i!=j)\n            if(t[i]+dis[i][j]<=t[j])\n            {\n                 f[i][j]=1;\n            }\n        }\n    }\n}\nvoid floyd()\n{\n    int k,i,j;\n    for(k=0;k<n;k++)\n    {\n        for(i=0;i<n;i++)\n            for(j=0;j<n;j++)\n            if(dis[i][k]!=INF&&dis[k][j]!=INF)\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n}\nvoid floyd1()\n{\n    int k,i,j;\n        for(i=0;i<l;i++)\n        {\n            memset(vis1,0,sizeof(vis1));\n            judge(i);\n\n        }\n\n\n}\nint main()\n{\n    \n     while(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n     {\n         if(!n&&!m&&!l)break;\n         int i,j;\n         memset(f,0,sizeof(f));\n         sum=0;\n         for(i=0;i<l;i++)fa[i]=i;\n         for(i=0;i<=l;i++)\n            for(j=0;j<=l;j++)dis[i][j]=INF;\n         for(i=1;i<=m;i++)\n         {\n             int x,y,w;\n             scanf(\"%d%d%d\",&x,&y,&w);\n             dis[x][y]=dis[y][x]=w;\n         }\n         floyd();\n         for(i=0;i<l;i++)\n            for(j=0;j<l;j++)\n            {\n                dis[i][j]=dis[i%(n)][j%(n)];\n\n            }\n         memset(t,-1,sizeof(t));\n         for(i=1;i<=l;i++)\n         {\n             int x,y;\n             scanf(\"%d%d\",&x,&y);\n             if(t[x]==-1)t[x]=y;\n             else t[(x/n)*n+x]=y;\n\n         }\n         build();\n         floyd1();\n         solve();\n         //printf(\"sum=%d\\n\",sum);\n         printf(\"%d\\n\",l-sum);\n\n     }\n     return 0;\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef Int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, L+j, 0 ) );\n                    g[L+j].push_back( Edge( L+j, i, 0 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        bipartiteMatching( g, L, edges );\n        set <pair<int, int> > V;\n        int answer = L;\n        for ( int i = 0; i < (int)edges.size(); i++ ) {\n            if ( V.find( make_pair( P[edges[i].src], P[edges[i].dst] ) ) == V.end() ) {\n                answer--;\n                V.insert( make_pair( P[edges[i].src], P[edges[i].dst] ) );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2000\n#define MAX_N 1001\nusing namespace std;\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n  return max_flow(s,t);\n}\n\n\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    \n\n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    \n  memset(can,0,sizeof(can));\n  for(int i=0;i<l;i++)\n    for(int j=0;j<l;j++)\n      if(i!=j&&tl[idx[i]]+g[idx[i]][idx[j]]<=tl[idx[j]])can[i][j]=1;\n  cout <<l-Biparite_Matching(l,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cfloat>\n#include<climits>\n#include<cmath>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = (int)(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = (int)(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define REVERSE(x) reverse((x).begin(), (x).end())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << '\\n'\n#define endl '\\n'\n\nconstexpr int IINF = (1 << 30) - 1;\nconstexpr long long LLINF = 1LL << 61;\nconstexpr double EPS = 1e-10;\n\nconstexpr int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconstexpr int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T& a, T b){\n    if(b < a){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m, l;\n    while(cin >> n >> m >> l, n){\n        vector< vector<lint> > cost(n, vector<lint>(n, LLINF));\n        rep(i, n){\n            cost[i][i] = 0;\n        }\n\n        rep(i, m){\n            int u, v;\n            lint d;\n            cin >> u >> v >> d;\n            chmin(cost[u][v], d);\n            chmin(cost[v][u], d);\n        }\n\n        rep(k, n){\n            rep(i, n){\n                rep(j, n){\n                    chmin(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n\n        vector<int> p(l);\n        vector<lint> t(l);\n        rep(i, l){\n            cin >> p[i] >> t[i];\n        }\n\n        BipartiteMatching g(l << 1);\n\n        rep(i, l){\n            rep(j, i){\n                if(abs(t[i] - t[j]) >= cost[p[i]][p[j]]){\n                    if(t[i] < t[j]){\n                        g.add_edge(i, j + l);\n                    }else{\n                        g.add_edge(j, i + l);\n                    }\n                }\n            }\n        }\n\n        cout << l - g.bipartite_matching() << endl;\n    }\n\n    cout << flush;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<set>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define INF (1<<30)\n#define maxn 1005\nint n,m,l;\nstruct node\n{\n    int p,t;\n};\nint dis[maxn][maxn],mark[maxn],t[maxn],sum=0;\nbool vis[maxn],f[maxn][maxn];\nnode s[maxn];\n\nbool cmp(node a,node b)\n{\n    if(a.p<b.p)return true;\n    if(a.p==b.p&&a.t<b.t)return true;\n    return false;\n}\nbool dfs(int i)\n{\n    for(int j=0;j<l;j++)\n    {\n        if(!vis[j]&&f[i][j])\n        {\n            vis[j]=1;\n            if(mark[j]==-1||dfs(mark[j]))\n            {\n                mark[j]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n\n}\nvoid solve()\n{\n    memset(mark,-1,sizeof(mark));\n    for(int i=0;i<l;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if(dfs(i))sum++;\n    }\n}\nvoid build()\n{\n    int i,j;\n    for(i=0;i<l;i++)\n    {\n        for(j=0;j<l;j++)\n        {\n            if(dis[i][j]!=INF&&i!=j)\n            if(t[i]+dis[i][j]<=t[j])\n            {\n                 f[i][j]=1;\n            }\n        }\n    }\n}\nvoid floyd()\n{\n    int k,i,j;\n    for(k=0;k<n;k++)\n    {\n        for(i=0;i<n;i++)\n            for(j=0;j<n;j++)\n            if(dis[i][k]!=INF&&dis[k][j]!=INF)\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n}\nvoid update(int si,int k,int x)\n{\n    for(int i=0;i<si;i++)\n        dis[i][k]=dis[k][i]=dis[x][i];\n}\nint main()\n{\n     \n     while(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n     {\n         if(!n&&!m&&!l)break;\n         int i,j;\n         memset(f,0,sizeof(f));\n         sum=0;\n         for(i=0;i<=l;i++)\n            for(j=0;j<=l;j++)dis[i][j]= i == j ? 0 : INF;\n         for(i=1;i<=m;i++)\n         {\n             int x,y,w;\n             scanf(\"%d%d%d\",&x,&y,&w);\n             dis[x][y]=dis[y][x]=w;\n         }\n         floyd();\n         int k=0;\n         memset(t,-1,sizeof(t));\n         for(i=1;i<=l;i++)\n         {\n             int x,y;\n             scanf(\"%d%d\",&s[i].p,&s[i].t);\n         }\n         sort(s+1,s+l+1,cmp);\n         i=1;\n         while(i<=l)\n         {\n            int x=s[i].p,y=s[i].t;\n            if(t[x]==-1)t[x]=y;\n            else  {t[n+k]=y;update(n+k,n+k,x);k++;}\n            //printf(\"x=%d y=%d k=%d\\n\",x,y,k);\n            while(s[i].p==s[i+1].p&&s[i].t==s[i+1].t&&i<l)\n                i++;\n            i++;\n         }\n         l=n+k;\n\n         build();\n         solve();\n         //printf(\"l=%d sum=%d\\n\",l,sum);\n         printf(\"%d\\n\",l-sum);\n\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nbool flow[2005][2005];\nbool DAG[1005][1005];\nint L,v[2020];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int src, int dst)\n{\n\tflow[dst][src]=1;\n\tnode[src].to.push_back(dst);\n\tnode[dst].to.push_back(src);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=(flow[p][next]?0:1);\n\t\t\n\t\t//if(p==SOUR) fw=1;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]=1;\n\t\t\tflow[next][p]=0;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(flow[n][next]) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\t\td[i][j]=INF;\n\t\t\t\td[i][i]=d[j][j]=0;\n\t\t}\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tConnect(node, SOUR, i);\n\t\t\tConnect(node, L+i, SINK);\n\t\t\t\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", L-dinic(SOUR,SINK,node));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cstring>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nvector<int> vv[2010];\nint match[2010];\nbool used[2010];\n\n\nbool matchdfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0;i < vv[v].size();i++)\n\t{\n\t\tint u = vv[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w))\n\t\t{\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint two_matching_max(int l)\n{\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l)\n\t{\n\t\tif(match[v] < 0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l)\n\t{\n\t\tREP(i,2010)vv[i].clear();\n\t\t\n\t\tint dist[n][n] = {};\n\t\tREP(i,n)REP(j,n)dist[i][j] = 1e9;\n\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\n\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t{\n\t\t\tdist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j]);\n\t\t}\n\t\t\n\t\t//SHOW2d(dist,n,n);\n\t\t\n\t\tvector<pair<int,int> > v(l);\n\t\t\n\t\tREP(i,l)\n\t\t{\n\t\t\tint p,t;\n\t\t\tcin >> p >> t;\n\t\t\tv[i] = MP(p,t);\n\t\t}\n\t\t\n\t\t\n\t\tREP(i,l)REP(j,l)\n\t\t{\n\t\t\tif(i == j)continue;\n\t\t\tif(v[j].SE - v[i].SE >= dist[i][j])\n\t\t\t{\n\t\t\t\tvv[i].PB(l+j);\n\t\t\t\tvv[l+j].PB(i);\n\t\t\t}\n\t\t}\n\t\tint ret =  l - two_matching_max(2*l) ;\n\t\tcout << ret << endl;\n\t}\n\t\t\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint const nMax = 1010;\nlong long road[2200][2200];\nint n,m,L,x,y,cost,judge,g[2200][2200],tot;\nint use[2200],from[2200];\nstruct SANTA{\n    int house;\n    long long time;\n}santa[nMax];\nstruct present{\n    int a;\n    long long time;\n}pre[nMax];\nbool match(int x)\n{\n    for(int i = L;i < 2 * L;i++){\n        if( g[x][i] && !use[i] ){\n            use[i] = 1;\n            if(from[i]==-1||match(from[i])){\n                from[i] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint hungary(){\n    tot = 0;\n    memset(from,-1,sizeof(from));\n    for(int i = 0;i < n;i++){\n        memset(use,0,sizeof(use));\n        if(match(i))\n            ++tot;\n    }\n    return tot;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L),n||m||L){\n        int ans = 0;\n        memset(road,63,sizeof(road));\n        for(int i = 1;i <= m;i++){\n            scanf(\"%d%d%d\",&x,&y,&cost);\n            if( road[x][y] > cost )\n                road[x][y] = road[y][x] = cost;\n        }\n        for(int k = 0;k < n;k++){\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < n;j++)\n                    if( road[i][j] > road[i][k] + road[k][j] ) road[i][j] = road[i][k] + road[k][j];\n            }\n        }\n        for(int i = 0;i < n;i++) road[i][i] = 0;\n        for(int i = 0;i < L;i++) scanf(\"%d%d\",&pre[i].a,&pre[i].time);\n        memset(g,0,sizeof(g));\n        for(int i = 0;i < L;i++){\n            for(int j = 0;j < L;j++)\n                if( i != j && road[pre[j].a][pre[i].a] <= pre[j].time - pre[i].time && pre[j].time - pre[i].time >= 0 ) g[i][j + L] = 1;\n        }\n        ans = L - hungary();\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\n#define INF 100000000\n\nusing namespace std;\n\nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  fill(match,match+2001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+2001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\nint main(void){\n \n  int n,m,l,u,v,d,dist[101][101],graph[1001][1001],p[1001],t[1001];\n \n  while(cin >> n >> m >> l,n|m|l){  \n \n    for(int i=0;i<2001;i++)G[i].clear();\n \n    fill(dist[0],dist[101],INF);\n    fill(graph[0],graph[1001],0);\n\n    for(int i=0;i<101;i++)dist[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      dist[u][v]=dist[v][u]=d;\n    }\n     \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j && dist[p[i]][p[j]]+t[i]<=t[j])\n\t  graph[i][j]=1;\n\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[i][j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n \nusing namespace std;\n \n////////////////////////最大流开始//////////////////////////////////////\n#define MAX_V 1000 * 2 + 16\nint V;                 // 顶点数\nvector<int> G[MAX_V];    // 图的邻接表\nint match[MAX_V];      // 所匹配的顶点\nbool used[MAX_V];      // DFS中用到的访问标记\n \n// 向图中增加一条连接u和v的边\nvoid add_edge(int u, int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \n// 通过DFS寻找增广路\nbool dfs(int v)\n{\n\tused[v] = true;\n\tfor (vector<int>::iterator it = G[v].begin(); it != G[v].end(); ++it)\n\t{\n\t\tint u = *it, w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n \n\treturn false;\n}\n \n// 求解二分图的最大匹配\nint bipartite_matching()\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n \n\treturn res;\n}\n \nvoid clear()\n{\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tG[i].clear();\n\t}\n}\n \n///////////////////////////////最大流结束/////////////////////////////////////\n#define  MAX_N 100\n#define  MAX_L 1000\n#define  INF 0x3f3f3f3f\n \nint distance_matrix[MAX_N][MAX_N];\t\t// 两点间最短路\nint p[MAX_L], t[MAX_L];\t\t\t\t\t// 房间编号，时刻\n \nbool update_min(int& v, const int& t)\n{\n\tif (t < v)\n\t{\n\t\tv = t;\n\t\treturn true;\n\t}\n\treturn false;\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n\tint N, M, L;\n\twhile (scanf(\"%d%d%d\", &N, &M, &L) != EOF && N)\n\t{\n\t\tV = L * 2;\n\t\tclear();\n\t\tmemset(distance_matrix, INF, sizeof(distance_matrix));\n \n\t\tfor (int _ = 0; _ < M; ++_)\n\t\t{\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tdistance_matrix[u][v] = distance_matrix[v][u] = d;\n\t\t}\n \n\t\tfor (int i = 0; i < L; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d\", p + i, t + i);\n\t\t}\n \n\t\t// warshall_floyd 两点间最短路\n\t\tfor (int k = 0; k < N; ++k) \n\t\t{\n\t\t\tdistance_matrix[k][k] = 0;\n\t\t\tfor (int i = 0; i < N; ++i) \n\t\t\t{\n\t\t\t\tfor (int j = 0; j < N; ++j) \n\t\t\t\t{\n\t\t\t\t\tupdate_min(distance_matrix[i][j], distance_matrix[i][k] + distance_matrix[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tfor (int i = 0; i < L; ++i) \n\t\t{\n\t\t\tfor (int j = 0; j < L; ++j)  \n\t\t\t{\n\t\t\t\tif (i != j && t[i] + distance_matrix[p[i]][p[j]] <= t[j])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(2 * i, 2 * j + 1);\t// 可以在i之后处理j，连一条边\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tprintf(\"%d\\n\", L - bipartite_matching());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nstruct BipartiteMatching {\n\tint V;\n\tvector<vector<bool> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\n\tBipartiteMatching(int v) {\n\t\tV = v;\n\t\tG = vector<vector<bool> >(v, vector<bool>(v));\n\t\tmatch = vector<int>(v);\n\t\tused = vector<bool>(v);\n\t}\n\n\tvoid add_edge(int v, int u) {\n\t\tG[v][u] = G[u][v] = true;\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(!G[v][i]) continue;\n\t\t\tint u = i, w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint calc() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef long long ll;\nconst ll INF = 1LL << 250;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tBipartiteMatching bp(N + N);\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tbp.add_edge(u, v + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << max(1, N - bp.calc()) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst int MAX_V_flow = 2010;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , 0 , G[from].size()-1 ) );\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\tint ret = 0,d = 1;\n\t\twhile(d > 0){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\td = dfs(s,t,INF);\n\t\t\tret += d;\n\t\t}\n\t\treturn ret;\n\t}\n}flow;\n\nint n,m,l;\nint u[1002],v[1002],d[1002];\nint p[1002],t[1002];\nint dist[102][102];\n\nvoid init(){\n\tflow.init();\n\trep(i,102)rep(j,102)dist[i][j] = INF;\n\trep(i,102)dist[i][i] = 0;\n}\n\nint main(){\n\twhile(1){\n\t\tinit();\n\t\t\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n == 0)break;\n\t\trep(i,m)scanf(\"%d%d%d\",&u[i],&v[i],&d[i]);\n\t\trep(i,l)scanf(\"%d%d\",&p[i],&t[i]);\n\t\t\n\t\trep(i,m){\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)dist[i][j] = min ( dist[i][j] , dist[i][k] + dist[k][j] );\n\t\t\n\t\trep(i,n){\n\t\t\tflow.add_edge( 2*n+1 , 2*i , 1 );\n\t\t\tflow.add_edge( 2*i+1 , 2*n , 1 );\n\t\t\trep(j,n){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(dist[p[i]][p[j]] <= t[j]-t[i]){\n\t\t\t\t\tflow.add_edge( 2*i , 2*j+1 , 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << n - flow.flow( 2*n+1 , 2*n ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  int cost[100][100];\n  int p[1000], t[1000];\n\n  while(scanf(\"%d %d %d\", &N, &M, &L), L) {\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) cost[i][j] = INF;\n      cost[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      cost[u][v] = cost[v][u] = d;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n\n    Bipartite_Matching flow(L, L);\n    for(int i = 0; i < L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(i == j) continue;\n        if(t[j] - t[i] >= cost[p[i]][p[j]]) {\n          flow.add_edge(i, j);\n        }\n      }\n    }\n    printf(\"%d\\n\", L - flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi g;\n\tpublic:\n\tvi match,used;\n\tbool BM_dfs(int v){\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tint u=g[v][i],w=match[u];\n\t\t\tif(w<0||!used[u]&&BM_dfs(u)){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint BM(){\n\t\tint res=0;\n\t\tmatch=vi(V,-1);\n\t\tfor(auto i=0;i<V;i++) if(match[i]<0){\n\t\t\tused=vi(V);\n\t\t\tif(BM_dfs(i)) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tGraph(int v){\n\t\tV=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n};\n\nint n,m,l;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>l;\n\t\tif(!n) break;\n\t\tGraph g(2*l);\n\t\tUnion_Find_Tree uft(n);\n\t\tvvi G(n,vi(n,inf));\n\t\tvp a(l);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint v,u,c;\n\t\t\tcin>>v>>u>>c;\n\t\t\tG[v][u]=c;\n\t\t\tG[u][v]=c;\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tint p,t;\n\t\t\tcin>>p>>t;\n\t\t\ta[i]={t,p};\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tfor(int i=0;i<n;i++) G[i][i]=0;\n\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\tfor(int i=1;i<l-1;i++) for(int j=0;j<l;j++) if(i+j<l){\n\t\t\tint v=a[j].second,u=a[i+j].second;\n\t\t\tif(G[v][u]<=a[i+j].first-a[j].first&&!uft.Same(v,u)){\n\t\t\t\tuft.Unite(j,j+i);\n\t\t\t\tg.add_edge(j,j+i+u);\n\t\t\t}\n\t\t}\n\t\tcout<<n-g.BM()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_V 2000\n#define INF 1e9\n\nint V,match[MAX_V];\nvector<int> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int u = G[v][i],w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v = 0 ; v < V ; v++){\n    if(match[v] < 0){\n      memset(used,false,sizeof(used));\n      if(dfs(v)){ res++; }\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n\nint main(){\n  int N,M,L,a,b,c;\n  while(cin >> N >> M >> L, N){\n    int d[MAX_N][MAX_N];\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < N ; j++){\n        d[i][j] = (i != j ? INF : 0);  \n      }\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b >> c;\n      d[a][b] = d[b][a] = c;\n    }\n\n    int p[L],t[L];\n    for(int i = 0 ; i < L ; i++){\n      cin >> p[i] >> t[i];\n    }\n    for(int i = 0 ; i < L ; i++){\n      for(int j = L-1 ; j > 0 ; j--){\n        if(t[j] < t[j-1]){\n          swap(t[j],t[j-1]);\n          swap(p[j],p[j-1]);\n        }\n      }\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    init(); V = L;\n    for(int i = 0 ; i < L ; i++){\n      for(int j = i+1 ; j < L ; j++){\n        if(d[p[i]][p[j]] <= t[j]-t[i]){\n          add_edge(i,j+L);\n        }\n      }\n    }\n    cout << L-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nint flow[2005][2005], capa[2005][2005],L,v[2020];\nbool DAG[1005][1005];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int u, int v, int w)\n{\n\tflow[v][u]+=w;\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\tnode[u].to.push_back(v);\n\tnode[v].to.push_back(u);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=capa[p][next]-flow[p][next];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]+=f;\n\t\t\tflow[next][p]-=f;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]-flow[n][next] <= 0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid Connect(int u, int v, int w, vector<Node>& graph)\n{\n\tgraph[u].to.push_back(v);\n\tgraph[v].to.push_back(u);\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\t\n\tflow[v][u]+=w;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(cin >> N >> M >> L, (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tcin >> u >> v >> c;\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tcin >> s[i] >> t[i];\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(capa, 0, sizeof(capa));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\tfor(int j=0; j<L; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t{\n\t\t\t\tDAG[i][j]=1;\n\t\t\t\tbeg[j]=1;\n\t\t\t\tend[i]=1;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]) \n\t\t\t{\n\t\t\t\tConnect(node, SOUR, i, INF);\n\t\t\t}\n\t\t\tif(!end[i]) \n\t\t\t{\n\t\t\t\tConnect(node, L+i, SINK, INF);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]&&!end[i])\n\t\t\t{\n\t\t\t\tConnect(node, i, L+i, 1);\n\t\t\t}\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(DAG[i][j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j,1);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dinic(SOUR,SINK,node) << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cstring>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++(i))\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++(i))\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nvector<int> vv[2010];\nint match[2010];\nbool used[2010];\n\n\nbool matchdfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0;i < vv[v].size();i++)\n\t{\n\t\tint u = vv[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w))\n\t\t{\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint two_matching_max(int l)\n{\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l)\n\t{\n\t\tif(match[v] < 0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint cou = 0;\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l)\n\t{\n\n\t\tREP(i,2010)vv[i].clear();\n\t\tint dist[n+1][n+1] = {};\n\t\tREP(i,n+1)REP(j,n+1)\n\t\t{\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse dist[i][j] = 5e8;\n\t\t}\n\t\t\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\t\t\n\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t{\n\t\t\tdist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j]);\n\t\t}\n\t\t\t\t\n\t\tvector<pair<int,int> > v(l);\n\t\t\n\t\tREP(i,l)\n\t\t{\n\t\t\tint p,t;\n\t\t\tcin >> p >> t;\n\t\t\tv[i] = MP(t,p);\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tREP(i,l)rep(j,i,l)\n\t\t{\n\t\t\t\n\t\t\tif(i == j)continue;\n\t\t\tif(v[j].FI - v[i].FI >= dist[v[j].SE][v[i].SE])\n\t\t\t{\n\t\t\t\tvv[i].PB(l+j);\n\t\t\t\tvv[l+j].PB(i);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tint ret =  l - two_matching_max(2*l) ;\n\t\tcout << ret << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge1\n{\npublic:\n    int to, cost;\n    Edge1(){};\n    Edge1(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge1> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge1 e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<Edge1> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nclass Edge2\n{\npublic:\n    int to, cap, rev;\n    Edge2(){};\n    Edge2(int to0, int cap0){to = to0; cap = cap0;}\n    Edge2(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge2> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge2> > edges;\n    static vector<unsigned> index;\n    static vector<int> level;\n    static int n;\n\n    class Func{\n    public:\n        static void bfs(int s){\n            level.assign(n, -1);\n            queue<int> q;\n            level[s] = 0;\n            q.push(s);\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for(unsigned i=0; i<edges[v].size(); ++i){\n                    Edge2& e = edges[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        q.push(e.to);\n                    }\n                }\n            }\n        }\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            for(unsigned& i=index[s]; i<edges[s].size(); ++i){\n                Edge2& e = edges[s][i];\n                if(e.cap > 0 && level[s] < level[e.to]){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    n = edges0.size();\n    edges.assign(n, vector<Edge2>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge2& e = edges0[i][j];\n            edges[i].push_back(Edge2(e.to, e.cap, edges[e.to].size()));\n            edges[e.to].push_back(Edge2(i, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        Func::bfs(source);\n        if(level[sink] < 0)\n            return ret;\n        index.assign(n, 0);\n        int f;\n        while((f = Func::dfs(source, sink, INT_MAX)) > 0)\n            ret += f;\n    }\n\n    return 0;\n}\n\n/***************************************************************************************************/\n// ツ陳クツ点ツづー1ツ嘉アツつクツづつカツバツーツつキツづゥツパツスツづ個催渉ャツ本ツ青板づーツ仰づ淞づゥ\n// dag : DAG\n/***************************************************************************************************/\nint coverNode(vector<vector<int> > dag)\n{\n    int n = dag.size();\n    vector<vector<Edge2> > edges(2*n+2);\n    for(int i=0; i<n; ++i){\n        edges[0].push_back(Edge2(i+2, 1));\n        edges[i+n+2].push_back(Edge2(1, 1));\n    }\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<dag[i].size(); ++j){\n            edges[i+2].push_back(Edge2(dag[i][j]+n+2, 1));\n        }\n    }\n    return n - maxFlow(edges, 0, 1);\n}\n\nint main()\n{\n    for(;;){\n        int n, m, l;\n        cin >> n >> m >> l;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge1> > edges1(n);\n        for(int i=0; i<m; ++i){\n            int u, v, d;\n            cin >> u >> v >> d;\n            edges1[u].push_back(Edge1(v, d));\n            edges1[v].push_back(Edge1(u, d));\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges1, dist);\n\n        vector<pair<int, int> > del(l);\n        for(int i=0; i<l; ++i)\n            cin >> del[i].second >> del[i].first;\n        sort(del.begin(), del.end());\n\n        vector<vector<int> > edges2(l);\n        for(int i=0; i<l; ++i){\n            for(int j=i+1; j<l; ++j){\n                if(dist[del[i].second][del[j].second] <= del[j].first - del[i].first)\n                    edges2[i].push_back(j);\n            }\n        }\n\n        cout << coverNode(edges2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\ntypedef vector<vector<edge>> Graph;\nconstexpr int MAX_V = 2002;\n\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(Graph& G,int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(Graph &G,int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(Graph &G,int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(G,e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(Graph &G,int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(G,s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(G,s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tGraph g(2*l+2);\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(i, n)v[i][i] = 0;\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(g,i + 1, j + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(g,0, i + 1, 1);\n\t\tREP(i, l)add_edge(g,i + l + 1, 2 * l + 1, 1);\n\t\tcout << l - max_flow(g,0, 2 * l + 1) << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nstruct BipartiteMatching {\n\tint V;\n\tvector<vector<bool> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\n\tBipartiteMatching(int v) {\n\t\tV = v;\n\t\tG = vector<vector<bool> >(v, vector<bool>(v));\n\t\tmatch = vector<int>(v);\n\t\tused = vector<bool>(v);\n\t}\n\n\tvoid add_edge(int v, int u) {\n\t\tG[v][u] = G[u][v] = true;\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(!G[v][i]) continue;\n\t\t\tint u = i, w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint calc() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nconst int INF = 1 << 25;\nint wf[100][100];\nint p[1000];\nint t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tBipartiteMatching bp(N + N);\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tbp.add_edge(u, v + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << max(1, N - bp.calc()) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) y) { return (f)(begin(y), end(y), ## __VA_ARGS__); })(x)\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\ntemplate <typename T, typename X> auto vectors(T a, X x) { return vector<T>(x, a); }\ntemplate <typename T, typename X, typename Y, typename... Zs> auto vectors(T a, X x, Y y, Zs... zs) { auto cont = vectors(a, y, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <class T> ostream & operator , (ostream & out, T a) { return out << a; }\n\nconst int inf = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, l; cin >> n >> m >> l;\n        if (n == 0 and m == 0 and l == 0) break;\n        vector<map<int,int> > g(n);\n        repeat (i,m) {\n            int u, v, d; cin >> u >> v >> d;\n            g[u][v] = d;\n            g[v][u] = d;\n        }\n        vector<int> p(l), t(l);\n        repeat (i,l) cin >> p[i] >> t[i];\n        // warshall floyd\n        vector<vector<int> > dist = vectors(inf, n, n);\n        repeat (i,n) dist[i][i] = 0;\n        repeat (i,n) for (auto it : g[i]) dist[i][it.first] = it.second;\n        repeat (k,n) repeat (i,n) repeat (j,n) setmin(dist[i][j], dist[i][k] + dist[k][j]);\n        // make a digraph of presents\n        vector<set<int> > h(l);\n        repeat (i,l) repeat (j,l) if (dist[p[i]][p[j]] <= t[j] - t[i]) h[i].insert(j);\n        vector<set<int> > rev(l);\n        repeat (i,l) for (int j : h[i]) rev[j].insert(i);\n        // run on the DAG\n        vector<int> que(l);\n        whole(iota, que, 0);\n        whole(sort, que, [&](int i, int j) { return t[i] < t[j]; });\n        vector<bool> has_santa(l);\n        int ans = 0;\n        for (int i : que) {\n            for (int j : rev[i]) if (has_santa[j]) {\n                has_santa[j] = false;\n                has_santa[i] = true;\n                break;\n            }\n            if (not has_santa[i]) {\n                has_santa[i] = true;\n                ans += 1;\n            }\n        }\n        // output\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define size(x) ((int)(x).size()) \n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int maxn = 1001;\nconst int inf = 5e8;\nint n, m;\nint d[111][111];\nint p[maxn], w[maxn];\nint vis[maxn];\nstd::vector<int> G[maxn];\n\nvoid init(int x){\n\tfor(int i = 0; i < x; i++){\n\t\tG[i].clear();\n\t}\n}\n\nint dfs(int x){\n\tfor(int i = 0; i < size(G[x]); i++){\n\t\tint u = G[x][i];\n\t\tif(!vis[u]){\n\t\t\tvis[u] = 1;\n\t\t\tif(p[u] < 0 || dfs(p[u])){\n\t\t\t\tp[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint match(int x){\n\tint num = 0;\n\tmemset(p, -1, sizeof(p));\n\tfor(int i = 0; i < x; i++){\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tif(dfs(i)){\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint L;\n\twhile(cin >> n >> m >> L && n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j) d[i][j] = 0;\n\t\t\t\telse d[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tinit(L);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\td[x][y] = z;\n\t\t\td[y][x] = z;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tcin >> p[i] >> w[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(d[p[i]][p[j]] + w[i] <= w[j] && i != j){\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << L - match(L) << endl;\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100;\nconst int L = 1000;\nconst int INF = 1e+8 + 10;\nconst int MAX_V = L * 2 + 2;\n\nstruct data{\n  int p, t;\n  data(int p=0, int t=0):p(p),t(t){}\n  bool operator < (const data &d) const {\n    return t < d.t;\n  }\n};\n\nstruct edge{\n  int to, cap, rev;\n  edge(int t=0, int c=0, int r=0):to(t),cap(c),rev(r){}\n};\n  \nvoid add_edge(int from, int to, int cap, vector<edge> G[MAX_V]){\n  G[from].push_back(edge(to, cap, G[to].size()));\n  G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n \nint dfs_f(int v, int t, int f, vector<edge> G[MAX_V], bool used[MAX_V]){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs_f(e.to, t, min(f, e.cap), G, used);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s, int t, vector<edge> G[MAX_V]){\n  int flow = 0;\n  while(1){\n    bool used[MAX_V];\n    fill(used, used+MAX_V, false);\n    int f = dfs_f(s, t, INF, G, used);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\n\n\nint n, m, l, G[N][N];\nvector<data> v;\n\nint solve(){\n  vector<edge> fG[MAX_V];\n\n  for(int i=0;i<n;i++) G[i][i] = 0;\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n      }\n    }\n  }\n\n  sort(v.begin(), v.end());\n  for(int i=0;i<l;i++){\n    add_edge(l*2, i, 1, fG);\n    add_edge(l+i, l*2+1, 1, fG);\n    //add_edge(i, l+i, 1, fG);\n    for(int j=i+1;j<l;j++){\n      if(G[v[i].p][v[j].p] < INF && v[i].t + G[v[i].p][v[j].p] <= v[j].t) {\n        add_edge(j, l+i, 1, fG);\n      }\n    }\n  }\n\n  // ?????§???????????? = V - ????°?????????????\n  return l - max_flow(l*2, l*2+1, fG);\n}\n\nint main(){\n  int x, y, d;\n  while(cin >> n >> m >> l && (n|m|l)){\n    fill(G[0], G[n], INF);\n    v.clear();\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d;\n      G[x][y] = min(G[x][y], d);\n      G[y][x] = min(G[y][x], d);\n    }\n    for(int i=0;i<l;i++){\n      cin >> x >> y;\n      v.push_back(data(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Edge(int src, int dst) :\n    src(src), dst(dst) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\nint adj[100][100];\nint p[1000],t[1000];\n\nint main() {\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l) {\n    REP(i,n)REP(j,n)adj[i][j]=INF;\n    REP(i,m) {\n      int u,v,d;\n      cin>>u>>v>>d;\n      adj[u][v] = min(adj[u][v],d);\n      adj[v][u] = adj[u][v];\n    }\n    REP(k,n)REP(i,n)REP(j,n) {\n      adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);\n    }\n    Graph g(2*l);\n    REP(i,l) {\n      cin>>p[i]>>t[i];\n    }\n    REP(i,l) {\n      REP(j,l) {\n        if (i==j) continue;\n        if (adj[p[i]][p[j]] <= t[j]-t[i]) {\n          g[i].push_back(Edge(i,l+j));\n        }\n      }\n    }\n    Edges e;\n    cout << l - bipartiteMatching(g, l, e) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64=int_fast64_t;\nusing pii=pair<int,int>;\ntemplate <class T> constexpr T inf=numeric_limits<T>::max() / (T)2;\ntemplate <class T> using minheap=priority_queue<T,vector<T>,greater<T>>;\n#define fir first\n#define sec second\n#define mkp make_pair\n#define mkt make_tuple\n#define emb emplace_back\n#define all(v) begin(v),end(v)\ni64 binry(i64 ok,i64 ng,const function<bool(i64)> &f) {\n    while(abs(ok-ng)>1) {\n        i64 mid=(ok+ng)/2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\n\ntemplate <class cost_t = int_fast64_t, class cap_t = int_fast64_t>\nstruct Flow {\n    struct edge { int from, to; cost_t cost; cap_t cap; size_t rev; };\n    size_t V,E;\n    vector<vector<size_t>> adj;\n    vector<edge> edges;\n    bool neg_edge_exist;\n\n    Flow(size_t _V) : V(_V), E(), edges(), neg_edge_exist()\n    {\n        adj.resize(V);\n    }\n\n    void add_edge(int from, int to, cost_t cost, cap_t cap) {\n        size_t pos = edges.size();\n        size_t rpos = pos + 1;\n        edges.emplace_back((edge){ from, to, cost, cap, rpos });\n        adj[from].emplace_back(pos);\n        edges.emplace_back((edge){ to, from, -cost, 0, pos });\n        adj[to].emplace_back(rpos); \n        ++E; if(cost < 0) neg_edge_exist = true;\n    }\n\n    vector<cost_t> Dijkstra(int s) {\n        vector<cost_t> dist(V,inf<cost_t>);\n        priority_queue<pair<cost_t,int>,vector<pair<cost_t,int>>,greater<pair<cost_t,int>>> que;\n        que.emplace(dist[s] = 0, s);\n        while(!que.empty()) {\n            auto p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(size_t i : adj[v]) {\n                edge &e = edges[i];\n                if(e.cap > 0 && dist[v] + e.cost < dist[e.to]) que.emplace(dist[e.to] = dist[v] + e.cost, e.to);\n            } \n        }\n        return dist;\n    }\n\n    struct Fold_Fulkerson_exe {\n        vector<edge> &edges;\n        vector<vector<size_t>> &adj;  \n        vector<bool> used;\n\n        Fold_Fulkerson_exe(Flow &_F) : edges(_F.edges), adj(_F.adj)\n        {\n            used.resize(_F.V);\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            used[v] = true;\n            for(size_t i : adj[v]) {\n                edge &e = edges[i];\n                if(!used[e.to] && e.cap > 0) {\n                    cap_t d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        edges[e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0,f;\n            while(true) {\n                fill(begin(used),end(used),false);\n                if((f = dfs(s,t,numeric_limits<cap_t>::max())) > 0) flow += f;\n                else break;\n            }\n            return flow;\n        }\n    };\n\n    cap_t Fold_Fulkerson(int s, int t) { return Fold_Fulkerson_exe(*this).max_flow(s,t); }\n    \n    struct Dinic_exe {\n        vector<edge> &edges;\n        vector<vector<size_t>> &adj;\n        vector<int> level,itr;\n\n        Dinic_exe(Flow &_F) : edges(_F.edges), adj(_F.adj)\n        {\n            level.resize(_F.V), itr.resize(_F.V);\n        }\n\n        void bfs(int s) {\n            fill(begin(level),end(level),-1);\n            queue<int> que;\n            level[s] = 0;\n            que.emplace(s);\n            while(!que.empty()) {\n                int v = que.front(); que.pop();\n                for(size_t i : adj[v]) {\n                    edge &e = edges[i];\n                    if(e.cap > 0 && level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        que.emplace(e.to);\n                    }\n                } \n            }\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            for(int &i = itr[v]; i < (int)adj[v].size(); ++i) {\n                edge &e = edges[adj[v][i]];\n                if(e.cap > 0 && level[v] < level[e.to]) {\n                    cap_t d = dfs(e.to, t, min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        edges[e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0,f;\n            while(true) {\n                bfs(s);\n                if(level[t] < 0) return flow;\n                fill(begin(itr), end(itr), 0);\n                while((f = dfs(s,t,numeric_limits<cap_t>::max())) > 0) flow += f;\n            }\n        }\n    };\n\n    cap_t Dinic(int s, int t) { return Dinic_exe(*this).max_flow(s,t); }\n\n    struct Primal_Dual_exe {\n        Flow &F;\n        vector<cost_t> dist,h;\n        vector<int> prev_v;\n        vector<edge*> prev_e;\n\n        Primal_Dual_exe(Flow &_F) : F(_F) {\n            dist.resize(F.V), h.resize(F.V), prev_v.resize(F.V), prev_e.resize(F.V);\n        }\n\n        bool Dijkstra(int s, int t) {\n            priority_queue<pair<cost_t,int>,vector<pair<cost_t,int>>,greater<pair<cost_t,int>>> que;\n            fill(begin(dist),end(dist),inf<cost_t>);\n            que.emplace(dist[s] = 0, s);\n            while(!que.empty()) {\n                cost_t cs; int v;\n                tie(cs,v) = que.top();\n                que.pop();\n                if(cs > dist[v]) continue;\n                for(edge &e : F.adj[v]) {\n                    if(e.cap > 0 && dist[v] + h[v] + e.cost < dist[e.to] + h[e.to]) {\n                        que.emplace(dist[e.to] = dist[v] + h[v] - h[e.to] + e.cost, e.to);\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = &e;\n                    }\n                }\n            } \n            if(dist[t] >= inf<cost_t>) return false;\n            for(int v = 0; v < F.V; ++v) h[v] += dist[v];\n            return true;\n        }\n\n        cost_t min_cost_flow(int s, int t, cap_t f) {\n            cost_t res = 0;\n            fill(begin(h),end(h),0);\n            while(f > 0) {\n                if(!Dijkstra(s,t)) return inf<cost_t>;\n                cap_t d = f;\n                for(int v = t; v != s; v = prev_v[v]) d = min(d, prev_e[v]->cap);\n                f -= d;\n                res += d * h[t];\n                for(int v = t; v != s; v = prev_v[v]) {\n                    prev_e[v]->cap -= d;\n                    prev_e[v]->rev->cap += d;\n                }\n            }\n            return res;\n        }\n    };\n\n    cost_t Primal_Dual(int s, int t, cap_t f) {\n        cost_t corr = 0;\n        if(neg_edge_exist) {\n            neg_edge_exist = false;\n            int _s = V++;\n            int _t = V++;\n            add_edge(_s,s,0,f);\n            add_edge(t,_t,0,f);\n            s = _s, t = _t;\n            for(int v = 0; v < V; ++v) {\n                for(edge &e : adj[v]) {\n                    if(e.cost < 0) {\n                        f += e.cap;\n                        add_edge(s,e.to,0,e.cap);\n                        add_edge(v,t,0,e.cap);\n                        corr += e.cap * e.cost;\n                        e.rev->cap += e.cap;\n                        e.cap = 0;\n                    }\n                }\n            }\n        }\n        return Primal_Dual_exe(*this).min_cost_flow(s,t,f) + corr;\n    } \n};\n\nint n,m,l;\nint dist[128][128];\npii tasks[1024];\n\nvoid solve() {\n    Flow<int,int> flow(l*2+2);\n    int s=l*2;\n    int t=s+1;\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(i!=j) dist[i][j]=1e8;\n        }\n    }\n    for(int i=0; i<m; ++i) {\n        int u,v,d; cin>>u>>v>>d;\n        dist[u][v]=dist[v][u]=d;\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                dist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n            }\n        }\n    }\n\n    for(int i=0; i<l; ++i) {\n        cin>>tasks[i].sec>>tasks[i].fir;\n        flow.add_edge(s,i,0,1);\n        flow.add_edge(i+l,t,0,1);\n    }\n\n    for(int i=0; i<l; ++i) {\n        for(int j=0; j<l; ++j) {\n            if(i!=j) {\n                if(tasks[i].fir-tasks[j].fir>=dist[tasks[i].sec][tasks[j].sec]) {\n                    flow.add_edge(j,i+l,0,1);\n                }\n            }\n        }\n    }\n\n    cout<<l-flow.Dinic(s,t)<<\"\\n\";\n}\n\nsigned main() {\n    // freopen(\"stdin.txt\",\"rt\",stdin);\n    // freopen(\"stdout.txt\",\"wt\",stdout);\n\n    while(cin>>n>>m>>l,n) {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LINF (1LL << 60)\n#define INF (1 << 30)\n#define MAX_N 1080\ntypedef long long  Int;\nstruct E{\n\tint to, rev;\n\tInt lim;\n\tE(int x, Int y, int z){\n\t\tto = x;\n\t\tlim = y;\n\t\trev = z;\n\t}\n};\n\nvector<E> edge[MAX_N];\nint lev[MAX_N];\nint iter[MAX_N];\n\nvoid make_edge(int a, int b, Int l){\n\tedge[a].push_back(E(b, l, edge[b].size()));\n\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n}\n\nInt dfs(int s, int g, Int f){\n\tif(s == g)return f;\n\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\tE &e = edge[s][i];\n\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\tInt tmp = dfs(e.to, g, min(f, e.lim));\n\t\tif(!tmp)continue;\n\t\te.lim -= tmp;\n\t\tedge[e.to][e.rev].lim += tmp;\n\t\treturn tmp;\n\t}\n\treturn 0;\n}\n\nvoid bfs(int x){\n\tqueue<int> q;\n\tq.push(x);\n\tint p = 0;\n\twhile(!q.empty()){\n\t\tfor(int i = q.size();i--;){\n\t\t\tint tmp = q.front();q.pop();\n\t\t\tif(lev[tmp] != INF)continue;\n\t\t\tlev[tmp] = p;\n\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == INF)q.push(edge[tmp][j].to);\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n}\n\nInt max_flow(int s, int g){\n\tInt res = 0;\n\tbool fin = false;\n\twhile(!fin){\n\t\tfill(lev, lev + MAX_N, INF);\n\t\tfill(iter, iter + MAX_N, 0);\n\t\tbfs(s);\n\t\tfin = true;\n\t\twhile(true){\n\t\t\tint p = dfs(s, g, INF);\n\t\t\tif(p == 0)break;\n\t\t\tfin = false;\n\t\t\tres += p;\n\t\t}\n\t}\t\n\treturn res;\n}\n\nint dist[108][108];\nint p[108], t[108];\nint main(){\n\tint n, m, l, u, v, d;\n\twhile(cin >> n >> m >> l, n|m|l){\n\t\tfor(int i = 0;i < 1080;i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\t\telse dist[i][j] = INF - 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tfor(int j = 0;j < n;j++)\n\t\t\t\tfor(int k = 0;k < n;k++)\n\t\t\t\t\tdist[j][k] = min(dist[j][i] + dist[i][k], dist[j][k]);\n\t\tfor(int i = 0;i < l ;i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0;i < l;i++){\n\t\t\tmake_edge(l * 2, i, 1);\n\t\t\tmake_edge(i + l, l * 2+1, 1);\t\t\t\n\t\t\tfor(int j = 0;j < l;j++){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tmake_edge(i, j + l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << l - max_flow(l * 2, l * 2 + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LINF (1LL << 60)\n#define INF (1 << 30)\n#define MAX_N 2160\ntypedef long long  Int;\nstruct E{\n\tint to, rev;\n\tInt lim;\n\tE(int x, Int y, int z){\n\t\tto = x;\n\t\tlim = y;\n\t\trev = z;\n\t}\n};\n\nvector<E> edge[MAX_N];\nint lev[MAX_N];\nint iter[MAX_N];\n\nvoid make_edge(int a, int b, Int l){\n\tedge[a].push_back(E(b, l, edge[b].size()));\n\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n}\n\nInt dfs(int s, int g, Int f){\n\tif(s == g)return f;\n\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\tE &e = edge[s][i];\n\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\tInt tmp = dfs(e.to, g, min(f, e.lim));\n\t\tif(!tmp)continue;\n\t\te.lim -= tmp;\n\t\tedge[e.to][e.rev].lim += tmp;\n\t\treturn tmp;\n\t}\n\treturn 0;\n}\n\nvoid bfs(int x){\n\tqueue<int> q;\n\tq.push(x);\n\tint p = 0;\n\twhile(!q.empty()){\n\t\tfor(int i = q.size();i--;){\n\t\t\tint tmp = q.front();q.pop();\n\t\t\tif(lev[tmp] != INF)continue;\n\t\t\tlev[tmp] = p;\n\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == INF)q.push(edge[tmp][j].to);\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n}\n\nInt max_flow(int s, int g){\n\tInt res = 0;\n\tbool fin = false;\n\twhile(!fin){\n\t\tfill(lev, lev + MAX_N, INF);\n\t\tfill(iter, iter + MAX_N, 0);\n\t\tbfs(s);\n\t\tfin = true;\n\t\twhile(true){\n\t\t\tint p = dfs(s, g, INF);\n\t\t\tif(p == 0)break;\n\t\t\tfin = false;\n\t\t\tres += p;\n\t\t}\n\t}\t\n\treturn res;\n}\n\nint dist[108][108];\nint p[108], t[108];\nint main(){\n\tint n, m, l, u, v, d;\n\twhile(cin >> n >> m >> l, n|m|l){\n\t\tfor(int i = 0;i < 2160;i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\t\telse dist[i][j] = INF - 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tfor(int j = 0;j < n;j++)\n\t\t\t\tfor(int k = 0;k < n;k++)\n\t\t\t\t\tdist[j][k] = min(dist[j][i] + dist[i][k], dist[j][k]);\n\t\tfor(int i = 0;i < l ;i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0;i < l;i++){\n\t\t\tmake_edge(l * 2, i, 1);\n\t\t\tmake_edge(i + l, l * 2+1, 1);\t\t\t\n\t\t\tfor(int j = 0;j < l;j++){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tmake_edge(i, j + l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << l - max_flow(l * 2, l * 2 + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint N, M, L;\nint S, T;\nint dist[105][105];\nint p[1005], t[1005];\nvector<edge> G[2005];\nbool used[2005];\n\nvoid WarshallFloyd()\n{\n\tfor(int k = 0; k < N; k++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v)\n{\n\tG[u].push_back( edge(v, 1, G[v].size() ) );\n\tG[v].push_back( edge(u, 0, G[u].size()-1 ) );\n}\n\nint dfs(int v, int c)\n{\n\tif(v == T) return c;\n\tused[v] = true;\n\t\n\tint ret;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap == 0) continue;\n\t\tret = dfs(G[v][i].to, min(c, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> L;\n\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdist[i][j] = inf;\n\t\t\t\tif(i == j) dist[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint u, v, d;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\n\t\tWarshallFloyd();\n\t\t\n\t\t\n\t\tfor(int i = 1; i <= L; i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\t\n\t\tS = 0, T = 2 * L + 1;\n\t\tfor(int i = S; i <= T; i++) G[i].clear();\n\t\tfor(int i = 1; i <= L; i++){\n\t\t\tadd_edge(S, i);\n\t\t\tadd_edge(L+i, T);\n\t\t\tfor(int j = 1; j <= L; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(i, L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret, flow = 0;\n\t\twhile(1){\n\t\t\tfor(int i = S; i <= T; i++) used[i] = false;\n\t\t\tret = dfs(S, inf);\n\t\t\tif(ret == 0) break;\n\t\t\tflow += ret;\n\t\t}\n\t\t\n\t\tcout << L - flow << endl;\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 1001;\ntypedef pair<int,int> pii;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\npii works[1001];\nvector<int> G[MAX_V*2];\nint match[MAX_V*2];\nbool used[MAX_V*2];\n\nconst int INF=1000000000;\n\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(int V){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            for(int k = 0; k < V; k++){\n            \td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nint n,m,l;\n\n\n// uÆvðÔÓðOtÉÇÁ\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n// ÁpXðdfsÅT·\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// ñOtÌÅå}b`Oðßé\nint bipartite_matching(int V){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\twhile(cin>>n>>m>>l&&(n|m|l)){\n\t\tfor(int i=0;i<MAX_V*2;i++)G[i].clear();\n\t\tfor(int i=0;i<MAX_V;i++){\n\t\t\tfor(int j=0;j<MAX_V;j++){\n\t\t\t\tif(i==j)d[i][j]=0;\n\t\t\t\telse d[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,c;\n\t\t\tcin>>u>>v>>c;\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\twarshall_floyd(n);\n\t\tfor(int i=0;i<l;i++)cin>>works[i].first>>works[i].second;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\telse if(works[i].second+d[works[i].first][works[j].first]<=works[j].second)\n\t\t\t\t\tadd_edge(i,j+l);\n\t\t\t}\n\t\t}\n\t\t// OtGÉÂ¢ÄAñ}b`Oðs¤\n\t\tint res=bipartite_matching(2*l);\n\t\tcout<<l-res<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 1000;\nconst int MAX_L = 1000;\nconst int MAX_GN = MAX_L * 2 + 2;\nconst int INF = 1 << 29;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\nint n, m, l;\nint dists[MAX_N][MAX_N];\npii reqs[MAX_L];\nvi nbrs[MAX_L];\nbool used[MAX_L];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0) break;\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) dists[i][j] = INF;\n      dists[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n      int u, v, d;\n      cin >> u >> v >> d;\n      dists[u][v] = dists[v][u] = d;\n    }\n\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n\tfor (int j = 0; j < n; j++)\n\t  dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j]);\n\n    for (int i = 0; i < l; i++)\n      cin >> reqs[i].second >> reqs[i].first;\n    sort(reqs, reqs + l);\n    \n    for (int i = 0; i < l; i++) nbrs[i].clear();\n    \n    for (int i = 0; i < l; i++) {\n      pii& ri = reqs[i];\n      for (int j = i + 1; j < l; j++) {\n\tpii& rj = reqs[j];\n\tif (dists[ri.second][rj.second] + ri.first <= rj.first)\n\t  nbrs[i].push_back(j);\n      }\n    }\n    \n    memset(used, false, sizeof(used));\n    int nu = 0;\n    \n    for (int i = 0; i < l; i++)\n      if (! used[i]) {\n\tused[i] = true;\n\tnu++;\n\t\n\tfor (int u = i; u >= 0;) {\n\t  int k = -1;\n\t  vi& nbru = nbrs[u];\n\t  for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\t    int& v = *vit;\n\t    if (! used[v]) {\n\t      used[v] = true;\n\t      k = v;\n\t      break;\n\t    }\n\t  }\n\t  u = k;\n\t}\n      }\n\n    cout << nu << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nstruct BipartiteMatching {\n\tint V;\n\tvector<vector<bool> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\n\tBipartiteMatching(int v) {\n\t\tV = v;\n\t\tG = vector<vector<bool> >(v, vector<bool>(v));\n\t\tmatch = vector<int>(v);\n\t\tused = vector<bool>(v);\n\t}\n\n\tvoid add_edge(int v, int u) {\n\t\tG[v][u] = G[u][v] = true;\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(!G[v][i]) continue;\n\t\t\tint u = i, w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint calc() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tBipartiteMatching bp(2 * L);\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tbp.add_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - bp.calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> g[2010];\nbool used[2010];\n\nvoid addEdge(int from,int to,int cap){\n\tedge e;\n\te.to=to;e.cap=cap;e.rev=g[to].size();\n\tg[from].push_back(e);\n\te.to=from;e.cap=0;e.rev=g[from].size()-1;\n\tg[to].push_back(e);\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=1;\n\trep(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tfill(used,used+2010,0);\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint N,M,L,d[110][110],u,v,D;\npi r[1010];\n\nint main(){\n\twhile(cin>>N>>M>>L&&N){\n\t\tint S=L*2,G=S+1;\n\t\trep(i,G+1)g[i].clear();\n\t\trep(i,N)rep(j,N)d[i][j]=(i!=j)*INF;\n\t\trep(i,M)cin>>u>>v>>D,d[u][v]=d[v][u]=D;\n\t\trep(k,N)rep(i,N)rep(j,N)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\trep(i,L)cin>>r[i].fir>>r[i].sec,addEdge(S,i,1),addEdge(L+i,G,1);\n\t\trep(i,L)rep(j,L)if(i!=j&&r[j].sec-r[i].sec>=d[r[i].fir][r[j].fir])addEdge(i,L+j,1);\n\t\tcout<<L-maxFlow(S,G)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\n#define ll long long\n#define FOR( i, a, b ) for(int i = a; i <= b; ++i )\nconst int ma=(1e+9)+1;\nconst int fa=(1e+4)+12;\nint n,m,l,x,y,d,p,tot;\nint a[fa],head[fa];\nint ru[fa],chu[fa];\nint lu[fa/10][fa/10];\nstruct wgh\n{\n    int x,y,d;\n} bian[fa];\nstruct node\n{\n    int d,y,next;\n} e[fa*10];\nstruct wgh1\n{\n    int x,p;\n} aa[fa];\nvoid adde(int x,int y,int d)\n{\n    tot++;\n    ru[y]++;\n    chu[x]++;\n    e[tot].y=y;\n    e[tot].d=d;\n    e[tot].next=head[x];\n    head[x]=tot;\n}\nint dist[fa/10][fa/10];\nstruct wgh2\n{\n    int x,t;\n}ans[fa];int sum;\nbool cmp(wgh1 a,wgh1 b)\n{\n    return a.p<b.p;\n}\nint dp[fa/10][fa/10];\nint main()\n{\n    //freopen(\"out.txt\",\"w\",stdout);\n    //freopen(\"in.txt\",\"r\",stdin);\n    int i,j,k;\n    while(~scanf(\"%d%d%d\",&n,&m,&l))\n    {\n        if(n==0&&m==0&&l==0)break;\n        memset(chu,0,sizeof(chu));\n        memset(head,0,sizeof(head));\n        memset(ru,0,sizeof(ru));\n        memset(lu,0,sizeof(lu));\n        for(i=1;i<=l;i++)\n        {\n            for(j=1;j<=i;j++)\n            dp[i][j]=ma;\n        }\n        for(i=0; i<=n; i++)\n        {\n            a[i]=ma;\n        }\n        tot=0;\n        for(i=0; i<n; i++)\n        {\n            for(j=0; j<n; j++)\n            {\n                if(i!=j)dist[i][j]=ma;\n                else dist[i][j]=0;\n            }\n        }\n        for(i=1; i<=m; i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&d);\n            bian[i].x=x;\n            bian[i].y=y;\n            bian[i].d=d;\n            dist[x][y]=min(dist[x][y],d);\n            dist[y][x]=min(dist[y][x],d);\n            //adde(x,y,d);\n            //adde(y,x,d);\n        }\n        for (k = 0; k < n; k++)\n            for (i = 0; i < n; i++)\n                for (j = 0; j < n; j++)\n                    if (dist[i][k] + dist[k][j] < dist[i][j])\n                        dist[i][j] = dist[i][k] + dist[k][j];\n\n        for(i=1; i<=l; i++)\n        {\n            scanf(\"%d%d\",&aa[i].x,&aa[i].p);\n            a[aa[i].x]=min(a[aa[i].x],aa[i].p);\n        }\n        sort(aa+1,aa+1+l,cmp);\n        for(int ii=1; ii<=l; ii++)\n        {\n            lu[ii][ii]=1;\n            for(int jj=ii+1;jj<=l;jj++)\n            {\n                if(dist[aa[ii].x][aa[jj].x]<=aa[jj].p-aa[ii].p)\n                {\n                    lu[jj][ii]=1;\n                }\n            }\n        }\n        sum=1;\n        ans[sum].t=aa[1].p;\n        ans[sum].x=aa[1].x;\n        for(int ii=2;ii<=l;ii++)\n        {\n            bool bo=false;\n            int o=0,tt=-ma;\n            for(int k=1;k<=sum;k++)\n            {\n                if(ans[k].t+dist[ans[k].x][aa[ii].x]<=aa[ii].p)\n                {\n                    bo=true;\n                    if(ans[k].t>tt)\n                    {\n                        tt=ans[k].t;\n                        o=k;\n                    }\n                }\n            }\n            if(bo==false)\n            {\n                sum++;\n                ans[sum].t=aa[ii].p;\n                ans[sum].x=aa[ii].x;\n            }\n            else\n            {\n                ans[o].t=aa[ii].p;\n                ans[o].x=aa[ii].x;\n            }\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 400\n#define MAX_N 400\nusing namespace std;\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n  return max_flow(s,t);\n}\n\n\n\nint main(){\n  int n,m,l;\n  while(1){\n    vector<vector<int> >g(MAX_N,vector<int>(MAX_N,INF));\n    for(int i=0;i<MAX_N;i++) G[i].clear(),g[i][i]=0;\n  cin>>n>>m>>l;\n  if(!n&&!m&&!l)break;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    g[a][b]=g[b][a]=c;\n  }\n  vector<int>tl(MAX_N,INF);\n  for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[a]=b;\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n  \n  memset(can,0,sizeof(can));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      if(tl[j]==INF||\n\t (tl[i]==INF&&g[i][j]<=tl[j])||\n\t(tl[i]+g[i][j]<=tl[j])) can[i][j]=1;     \n    }\n  cout <<n-Biparite_Matching(n,n)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector> \n#include<utility>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define ft first\n#define sd second\n#define MAX 1000*2+16 \nvector<int> arr[MAX];\nint x[MAX],vis[MAX];\nint dist[105][105];\nint N,M,L;\nvoid floyd()\n{\n\tint k,i,j;\n\tfor(i=0;i<N;i++)\n\t\tdist[i][i]=0;\n\tfor(k=0;k<N;k++)\n\t\tfor(i=0;i<N;i++)\n\t\t\tfor(j=0;j<N;j++)\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\t\t\t\t\n}\n\nint dfs(int v)\n{\n\tvis[v]=1;\n\tfor(int i=0;i<arr[v].size();i++)\n\t{\n\t\tint m=arr[v][i];\n\t\tint w=x[m];\n\t\tif(w<0||(!vis[w]&&dfs(w)))\n\t\t{\n\t\t\tx[v]=m;\n\t\t\tx[m]=v;\n\t\t\treturn 1;\n\t\t}\t\n\t}\n\treturn 0;\n}\nint V;\nint solve()\n{\n\tint ans=0;\n\tmemset(x,-1,sizeof(x));\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tif(x[i]<0)\n\t\t{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(i);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid add(int u,int v)\n{\n\tarr[u].push_back(v);\n\tarr[v].push_back(u);\n}\nint p[1050],t[1050]; \nint main()\n{\n\twhile(scanf(\"%d%d%d\",&N,&M,&L)!=EOF&&N)\n\t{\n\t\tV=L*2;\n\t\tmemset(dist,INF,sizeof(dist));\n\t\tint i,m1,m2,m3;\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&m1,&m2,&m3);\n\t\t\tdist[m1][m2]=dist[m2][m1]=m3;\n\t\t}\n\t\tfloyd();\n\t\tfor(i=0;i<L;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&m1,&m2);\n\t\t\tp[i]=m1;\n\t\t\tt[i]=m2;\n\t\t}\n\t\tfor(i=0;i<L;i++)\n\t\t{\n\t\t\tfor(int j=0;j<L;j++)\n\t\t\t{\n\t\t\t\tif(i!=j&&dist[p[i]][p[j]]+t[i]<=t[j])\n\t\t\t\t{\n\t\t\t\t\tadd(i,L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",L-solve());\n\t\tfor(i=0;i<V;i++)arr[i].clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 2525; // TODO:initialize\nconst int INF = 1010101010; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        pq.push(pi(0,s));\n        while(!pq.empty()){\n            pi p = pq.top();\n            pq.pop();\n            int v = p.se;\n            if(p.fi>dist[v]) continue;\n            rep(i,G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    pq.push(pi(dist[e.to],e.to));\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst int M=10;\nint d[100][100];\n\nint main()\n{\n    int n,m,R;\n    while(scanf(\" %d %d %d\", &n, &m, &R),n)\n    {\n        fill(d[0],d[100],INF);\n        rep(i,n) d[i][i]=0;\n        rep(i,m)\n        {\n            int u,v,c;\n            scanf(\" %d %d %d\", &u, &v, &c);\n            d[u][v] = d[v][u] = c;\n        }\n\n        rep(k,n)rep(i,n)rep(j,n) d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n        vector<pi> req(R);\n        rep(i,R)\n        {\n            int p,t;\n            scanf(\" %d %d\", &p, &t);\n            req[i] = pi(t,p);\n        }\n        sort(all(req));\n\n        rep(i,MAX_V) G[i].clear();\n        V = MAX_V;\n        int S = MAX_V-2, T = S+1;\n        rep(i,n)\n        {\n            add_edge(S,2*R+i,1,0);\n            add_edge(2*R+i,T,1,0);\n        }\n        rep(i,R)\n        {\n            add_edge(2*i,2*i+1,1,-M);\n            add_edge(2*i+1,T,1,0);\n        }\n        rep(i,R)for(int j=i+1; j<R; ++j)\n        {\n            int ti = req[i].fi, tj = req[j].fi;\n            int u = req[i].se, v = req[j].se;\n            if(d[u][v]<=tj-ti) add_edge(2*i+1,2*j,1,0);\n        }\n\n        int ans = 0;\n        int sum = 0;\n        while(1)\n        {\n            rep(i,R) add_edge(2*R+ans,2*i,1,0);\n            ++ans;\n            sum += min_cost_flow(S,T,1);\n            if(sum == -R*M) break;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nclass BipartiteMatching\n{\nprivate:\n  int MAX_V;\n  vector<int>* G;\n  int* match;\n  int* used;\n\n  bool dfs(int v)\n  {\n    used[v] = true;\n    rep(i, G[v].size()){\n      int u = G[v][i], w = match[u];\n      if(w < 0 || !used[w] && dfs(w)){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  BipartiteMatching(int MAX_V) : MAX_V(MAX_V)\n  {\n    G = new vector<int>[MAX_V];\n    match = new int[MAX_V];\n    used = new int[MAX_V];\n  }\n\n  void addEdge(int u, int v)\n  {\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n\n  int matching()\n  {\n    int res = 0;\n    rep(i, MAX_V) match[i] = -1;\n    rep(v, MAX_V){\n      if(match[v] < 0){\n        rep(i, MAX_V) used[i] = 0;\n        if(dfs(v)) res += 1;\n      }\n    }\n    return res;\n  }\n};\n\nint N, M, L;\nint u, v, dd;\nint d[111][111];\nint p[1111];\nint t[1111];\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> M >> L, N){\n    BipartiteMatching bm = BipartiteMatching(2 * L);\n    rep(i, N) rep(j, N) d[i][j] = INF;\n    rep(i, N) d[i][i] = 0;\n    rep(i, M){\n      cin >> u >> v >> dd;\n      d[u][v] = dd;\n      d[v][u] = dd;\n    }\n    rep(k, N) rep(i, N) rep(j, N) minup(d[i][j], d[i][k] + d[k][j]);\n    rep(i, L) cin >> p[i] >> t[i];\n    rep(i, L) rep(j, L) if(i != j && t[i] + d[p[i]][p[j]] <= t[j]) bm.addEdge(i, j + L);\n    cout << L - bm.matching() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\nconst ll INF = 1LL<<50;\nconst int MAXN = 105;\n\nint N, M1, M2;\nll u, v, d, p, t;\nll dist[MAXN][MAXN];\n\nconst int MAX_L = 1050;\nconst int MAX_R = 1050;\n\nstruct Graph {\n    int L;\n    vector<int> list[MAX_L];\n    \n    void init(int n = 0) {L = n; for (int i = 0; i < MAX_L; ++i) list[i].clear();}\n    inline vector<int>& operator [] (int i) {return list[i];}\n    friend ostream& operator << (ostream& s, const Graph& G) {for (int i = 0; i < G.L; ++i) {s << i << \" : \" << G.list[i];}return s;}\n    \n    void addedge(int from, int to) {\n        list[from].push_back(to);\n    }\n} G;\n\nint L = 0;\nbool seen[MAX_L];\nbool matched[MAX_L];\nint level[MAX_L];\nint matching[MAX_R];\n\nvoid hobfs(Graph &G) {\n    queue<int> que;\n    for (int left = 0; left < L; ++left) {\n        level[left] = -1;\n        if (!matched[left]) {\n            que.push(left);\n            level[left] = 0;\n        }\n    }\n    level[L] = L;\n    while (!que.empty()) {\n        int left = que.front();\n        que.pop();\n        for (int i = 0; i < G[left].size(); ++i) {\n            int right = G[left][i];\n            int next = matching[right];\n            if (level[next] == -1) {\n                level[next] = level[left] + 1;\n                que.push(next);\n            }\n        }\n    }\n}\n\nbool hodfs(Graph &G, int left) {\n    if (left == L) return true;\n    if (seen[left]) return false;\n    seen[left] = true;\n    for (int i = 0; i < G[left].size(); ++i) {\n        int right = G[left][i];\n        int next = matching[right];\n        if (level[next] > level[left] && hodfs(G, next)) {\n            matching[right] = left;\n            return true;\n        }\n    }\n    return false;\n}\n\nint Hopcroft_Karp(Graph &G) {\n    L = G.L;\n    for (int i = 0; i < MAX_R; ++i) matching[i] = L;\n    memset(matched, 0, sizeof(matched));\n    \n    int res = 0;\n    while (true) {\n        hobfs(G);\n        memset(seen, 0, sizeof(seen));\n        bool finished = true;\n        for (int left = 0; left < L; ++left) {\n            if (!matched[left] && hodfs(G, left)) {\n                matched[left] = true;\n                ++res;\n                finished = false;\n            }\n        }\n        if (finished) break;\n    }\n    return res;\n}\n\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    while (scanf(\"%d %d %d\", &N, &M1, &M2) != -1) {\n        if (N == 0) break;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) dist[i][j] = INF;\n            dist[i][i] = 0;\n        }\n        \n        for (int i = 0; i < M1; ++i) {\n            scanf(\"%d %d %d\", &u, &v, &d);\n            dist[u][v] = dist[v][u] = d;\n        }\n        for (int k = 0; k < N; ++k) \n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n        \n        G.init(M2);\n        vector<pair<int,ll> > req(M2);\n        for (int i = 0; i < M2; ++i) {\n            scanf(\"%d %d\", &p, &t);\n            req[i] = MP(p,t);\n        }\n        for (int i = 0; i < M2; ++i) {\n            for (int j = i+1; j < M2; ++j) {\n                //cout << i << \", \" << j << \" : \" << req[i].FI << \", \" << req[j].FI <<\" ; \" << dist[req[i].FI][req[j].FI] << endl;\n                if (req[j].SE - req[i].SE >= dist[req[i].FI][req[j].FI]) {\n                    G.addedge(i,j);\n                }\n                else if (req[i].SE - req[j].SE >= dist[req[i].FI][req[j].FI]) {\n                    G.addedge(j,i);\n                }\n            }\n        }\n        \n//        COUT(req);\n//        cout << G;\n        \n        int res = Hopcroft_Karp(G);\n        \n        cout << M2-res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(u,a,b) for(int u=(a);u<(b);u++)\n#define rrep(u,a,b) for(int u=(b)-1;u>=(a);u--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct HopcroftKarp {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match, dist;\n\tvector<bool> used, alive;\n\tHopcroftKarp(int n) : n(n), g(n), match(n), dist(n), used(n), alive(n, true) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\twhile (true) {\n\t\t\tbuildAlternatingLevelGraph();\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint flow = 0;\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tif (match[u] == -1 && augment(u))\n\t\t\t\t\tflow++;\n\t\t\tif (flow == 0)break;\n\t\t\tcnt += flow;\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid buildAlternatingLevelGraph() {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int u = 0; u < n; u++)\n\t\t\tif (match[u] == -1) {\n\t\t\t\tq.emplace(u);\n\t\t\t\tdist[u] = 0;\n\t\t\t}\n\t\twhile (q.size()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w != -1 && dist[w] == -1) {\n\t\t\t\t\tdist[w] = dist[u] + 1;\n\t\t\t\t\tq.emplace(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tbool augment(int u) {\n\t\tused[u] = true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!alive[v])continue;\n\t\t\tint w = match[v];\n\t\t\tif (w == -1 || (!used[w] && dist[w] == dist[u] + 1 && augment(w))) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\tused[v] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tHopcroftKarp hk(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\thk.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - hk.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 200;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[200];\n        fill(used,used+200,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            ct=node=0;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i = v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int minTime=-1;\n                int idx=0;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i = v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=time){\n                        if(minTime<time){\n                            minTime=ct-cost;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(minTime==-1)\n                    break;\n                //  êÎAóÔðXV\n                ct=v[idx].first;\n                node=v[idx].second;\n                used[idx]=true;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint prevV[1500], prevE[1500];\nint dist[1500];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\tint V = G.size();\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+1500, INF);\n\t\tdist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\treturn INF;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tm[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tm[u][v] = m[v][u] = d;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint s = 2*L+1, t = s+1;\n\t\tG.clear(); G.resize(t+1);\n\n\t\tvector<int> p(L), time(L);\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tcin >> p[i] >> time[i];\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tif (i != j && time[i] + m[p[i]][p[j]] <= time[j]) {\n\t\t\t\t\taddEdge(L+i, j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\taddEdge(s, i, 1, 0);\n\t\t\taddEdge(L+i, t, 1, 0);\n\t\t\taddEdge(i, L+i, 1, -1);\n\t\t}\n\n\t\tint r = 0;\n\t\tfor (int l = 1; l <= L; ++l) {\n\t\t\tr += flow(s, t, 1);\n\t\t\tif (r == -L) {\n\t\t\t\tcout << l << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, M, L;\nconst int MAX_V = 300;\nint V;\nVI biG[MAX_V];\nVI origG[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\n\nvoid add_edge(int u, int v){\n  biG[u].push_back(v);\n  biG[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0;i<biG[v].size();++i){\n\tint u = biG[v][i], w = match[u];\n\tif(w < 0 || !used[w] && dfs(w)){\n\t  match[v] = u;\n\t  match[u] = v;\n\t  return true;\n\t}\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v=0;v<V;++v){\n\tif(match[v] < 0){\n\t  memset(used, false, sizeof(used));\n\t  if(dfs(v))\n\t\t++res;\n\t}\n  }\n  return res;\n}\n\nint findMinPathcover(int n){\n  REP(i,MAX_V) biG[i].clear();\n  V = 2*n;\n  REP(i,n) REP(j,SZ(origG[i])){\n\tadd_edge(i, n+origG[i][j]);\n  }\n  int res = bipartite_matching();\n  return n - res;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>L,N){\n\tREP(i,MAX_V) origG[i].clear();\n\tvector<vector<LL>> dist(N, vector<LL>(N, 1e+15));\n\tREP(i,N) dist[i][i] = 0;\n\tREP(i,M){\n\t  int u, v, d;\n\t  cin >> u >> v >> d;\n\t  dist[u][v] = dist[v][u] = d;\n\t}\n\n\tREP(k,N) REP(i,N) REP(j,N)\n\t  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tvector<LL> p(L), t(L);\n\tREP(i,L) cin >> p[i] >> t[i];\n\tREP(i,L) REP(j,L)\n\t  if(i != j && t[i] + dist[p[i]][p[j]] <= t[j])\n\t\torigG[i].PB(j);\n\tcout << findMinPathcover(L) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAXN 3010  //X驛ィ蛻?噪譛?、ァ鬘カ轤ケ謨ー\n#define MAXM 3010  //Y驛ィ蛻?噪譛?、ァ鬘カ轤ケ謨ー\n#define _clr(x,y) memset(x,y,sizeof(x))\n\nstruct Node\n{\n\tint to;\n\tint next;\n}edge[MAXN*MAXM]; //驍サ謗・陦ィ菫晏ュ倩セケ菫。諱ッ\n\nint n,m;\nint tot;\n\nint head[MAXN];\nint matchx[MAXN],matchy[MAXM];\nint disx[MAXN],disy[MAXM];\n\ninline void add_edge(int a,int b)   //豺サ蜉?黒蜷題セケ\n{\n\tedge[tot].to=b;\n\tedge[tot].next=head[a];\n\thead[a]=tot++;\n}\n\nbool BFS()  //隶。邂苓鰍轤ケ荳咲嶌莠、逧?アよャ。蝗セ\n{\n\tint i;\n\tint h=0,t=0;\n\tint q[MAXN];\n\tbool flag=false;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(matchx[i]==-1)\n\t\t{\n\t\t\tq[t++]=i;\n\t\t}\n\t}\n\t_clr(disx,0);\n\t_clr(disy,0);\n\twhile(h<t)\n\t{\n\t\tint x=q[h++];\n\t\tfor(i=head[x];i!=-1;i=edge[i].next)\n\t\t{\n\t\t\tint y=edge[i].to;\n\t\t\tif(!disy[y])\n\t\t\t{\n\t\t\t\tdisy[y]=disx[x]+1;\n\t\t\t\tif(matchy[y]==-1)\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdisx[matchy[y]]=disy[y]+1;\n\t\t\t\t\tq[t++]=matchy[y];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\n\nbool find(int x)  // dfs豐ソ螻よャ。蝗セ蟇サ謇セ蠅槫ケソ霍ッ\n{\n\tfor(int i=head[x];i!=-1;i=edge[i].next)\n\t{\n\t\tint y=edge[i].to;\n\t\tif(disy[y]==disx[x]+1)\n\t\t{\n\t\t\tdisy[y]=0;\n\t\t\tif(matchy[y]==-1 || find(matchy[y]))\n\t\t\t{\n\t\t\t\tmatchx[x]=y;\n\t\t\t\tmatchy[y]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint Hopcroft_Karp()\n{\n\tint cnt=0;\n\t_clr(matchx,-1);\n\t_clr(matchy,-1);\n\twhile(BFS())\n\t{\n\t\tfor(int x=1;x<=n;x++) // 螟夊キッ蠅槫ケソ\n\t\t{\n\t\t\tif(matchx[x]==-1 && find(x))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint g[210][210];\nint a[210],b[210];\n\nvoid Floyed(int len)\n{\n    int i,j,k;\n    for(k=1;k<=len;k++)\n        for(i=1;i<=len;i++)\n            for(j=1;j<=len;j++)\n                {\n                    if(i==j)\n                        continue;\n                    g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n                }\n}\n\nint main()\n{\n    int mm,nn,k,i,j;\n    while(scanf(\"%d %d %d\",&mm,&nn,&k),mm||nn||k)\n    {\n        memset(head,-1,sizeof(head));\n        tot=0;\n        for(i=0;i<110;i++)\n            for(j=0;j<110;j++)\n                g[i][j]=i!=j?100000001:0;\n        for(i=0;i<nn;i++)\n        {\n            int u,v,w;\n            scanf(\"%d %d %d\",&u,&v,&w);\n            u++,v++;\n            g[u][v]=g[v][u]=min(g[u][v],w);\n        }\n        Floyed(mm);\n        for(i=0;i<k;i++)\n        {\n            scanf(\"%d %d\",&a[i],&b[i]);\n            a[i]++;\n        }\n        n=1000,m=100010;\n        for(i=0;i<k;i++)\n            for(j=0;j<k;j++)\n                if(i!=j &&g[a[i]][a[j]]<=b[j]-b[i])\n                    add_edge(i+1,j+1);\n        printf(\"%d\\n\",k-Hopcroft_Karp());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define FORIT(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n    int src;\n    int dest;\n    int capacity;\n    Weight weight;\n    Edge() {;}\n    Edge(int src, int dest, int capacity, Weight weight) : src(src), dest(dest), capacity(capacity), weight(weight) {;}\n    bool operator<(const Edge &rhs) const {\n        return weight > rhs.weight;\n    }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n    REP(y, matrix.size()) {\n        REP(x, matrix[y].size()) {\n            printf(\"%d \", matrix[y][x]);\n        }\n        puts(\"\");\n    }\n}\n\n/*\nWeight augment(const Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n    if (from == t || cur == 0) { return cur; }\n    if (finished[from]) { return 0; }\n    FORIT(it, g[from]) {\n        int to = it->dest;\n        if (level[to] <= level[from]) { continue; }\n        Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n        if (f > 0) {\n            capacity[from][to] -= f;\n            capacity[to][from] += f;\n            return f;\n        }\n    }\n    finished[from] = true;\n    return 0;\n}\n\nWeight MaxFlow(const Graph &g, int s, int t) {\n    const int n = g.size();\n    Matrix capacity(n, Array(n));\n    REP(from, n) {\n        FORIT(it, g[from]) {\n            int to = it->dest;\n            capacity[from][to] += it->weight;\n        }\n    }\n    int ans = 0;\n    while (true) {\n        vector<int> level(n, -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        for (int d = n; !que.empty() && level[que.front()] < d; ) {\n            const int from = que.front();\n            que.pop();\n            if (from == t) { d = level[from]; }\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                if (capacity[from][to] > 0 && level[to] == -1) {\n                    que.push(to);\n                    level[to] = level[from] + 1;\n                }\n            }\n        }\n        vector<bool> finished(n);\n        bool end = true;\n        while (true) {\n            Weight f = augment(g, capacity, level, finished, s, t, 2000000000LL);\n            if (f == 0) { break; }\n            ans += f;\n            end = false;\n        }\n        if (end) { break; }\n    }\n    return ans;\n}\n*/\n\nint parent[2020];\nint nowDist[2020];\nint prevDist[2020];\n\nint MinCostFlow(const Graph &g, int s, int t, int l) {\n    const int n = g.size();\n    Matrix capacity(n, Array(n, 0));\n    Matrix cost(n, Array(n, 0));\n    REP(from, n) {\n        FORIT(it, g[from]) {\n            assert(it->capacity >= 0);\n            capacity[from][it->dest] += it->capacity;\n            cost[from][it->dest] += it->weight;\n        }\n    }\n\n    vector<int> parent(n);\n    vector<int> prev_dist(n, 0);\n    vector<int> now_dist(n);\n\n    // calc potential\n    REP(iter, n) {\n        bool end = true;\n        REP(from, n) {\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                if (capacity[from][to] == 0) { continue; }\n                int ncost = prev_dist[from] + cost[from][to];\n                if (ncost < prev_dist[to]) {\n                    end = false;\n                    prev_dist[to] = ncost;\n                }\n            }\n        }\n        if (end) { break; }\n    }\n\n    int ret = 0;\n    int c = 0;\n    while (true) {\n        ret++;\n        fill(parent.begin(), parent.end(), -1);\n        fill(now_dist.begin(), now_dist.end(), 2000000000LL);\n        priority_queue<Edge> que;\n        que.push(Edge(s, s, 0, 0));\n        now_dist[s] = 0;\n        while (!que.empty()) {\n            Edge node = que.top();\n            que.pop();\n            if (parent[node.dest] != -1) { continue; }\n            parent[node.dest] = node.src;\n            int from = node.dest;\n            FORIT(it, g[from]) {\n                int to = it->dest;\n                int ncost = node.weight + cost[from][to] + (prev_dist[from] - prev_dist[to]);\n                if (capacity[from][to] == 0) { continue; }\n                if (ncost >= now_dist[to]) { continue; }\n                now_dist[to] = ncost;\n                que.push(Edge(from, to, 0, ncost));\n            }\n        }\n        if (parent[t] == -1) { assert(false); }\n        int from = parent[t];\n        int to = t;\n        while (from != to) {\n            c += cost[from][to];\n            capacity[from][to]--;\n            capacity[to][from]++;\n            from = parent[from];\n            to = parent[to];\n        }\n        REP(i, n) {\n            prev_dist[i] += now_dist[i];\n        }\n        if (c == -l) { return ret; }\n    }\n    assert(false);\n    return 0;\n}\n\nvoid addEdge(Graph &g, int from, int to, int cost) {\n    g[from].push_back(Edge(from, to, 1, cost));\n    g[to].push_back(Edge(to, from, 0, -cost));\n}\n\nint n, m, l;\ninline int IN(int x) { return 2 * x; }\ninline int OUT(int x) { return 2 * x + 1; }\ninline int SOURCE() { return 2 * l; }\ninline int DEST() { return 2 * l + 1; }\ninline int SIZE() { return 2 * l + 2; }\n\nll matrix[110][110];\nint point[1010];\nll ontime[1010];\nbool visit[2020];\n\nint main() {\n    while (scanf(\"%d %d %d\", &n, &m, &l), n|m|l) {\n        MEMSET(matrix, 0x0f);\n        Graph g(2 * l + 2);\n        REP(i, m) {\n            int f, t, c;\n            scanf(\"%d %d %d\", &f, &t, &c);\n            matrix[f][t] = c;\n            matrix[t][f] = c;\n        }\n        REP(k, n) REP(i, n) REP(j, n) {\n            matrix[j][j] = 0;\n            matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n        }\n        REP(i, l) {\n            int p, t;\n            scanf(\"%d %d\", &p, &t);\n            point[i] = p;\n            ontime[i] = t;\n        }\n        REP(i, l) {\n            addEdge(g, SOURCE(), IN(i), 0);\n            addEdge(g, OUT(i), DEST(), 0);\n            addEdge(g, IN(i), OUT(i), -1);\n            REP(j, l) {\n              if (i == j) { continue; }\n                if (ontime[j] + matrix[point[j]][point[i]] <= ontime[i]) {\n                    addEdge(g, OUT(j), IN(i), 0);\n                }\n            }\n        }\n        printf(\"%d\\n\", MinCostFlow(g, SOURCE(), DEST(), l));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <utility>\n#include <map>\n#include <stack>\n#include <set>\n#include <vector>\n#include <queue>\n#include <deque>\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define Pair pair<int,int>\n#define LOWBIT(x) x & (-x)\nusing namespace std;\n\nconst int MOD=1e9+7;\nconst int INF=1e9;\nconst int magic=348;\n\nint t,tot,head[10048],nxt[2000048],to[2000048],f[2000048];\ninline void addedge(int s,int t,int cap)\n{\n\tto[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap;\n\tto[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;\n}\n\nint n,e,qq;\nint ga[148][148];\nPair query[1048];\n\nvoid floyd()\n{\n\tint i,j,k;\n\tfor (k=1;k<=n;k++)\n\t\tfor (i=1;i<=n;i++)\n\t\t\tfor (j=1;j<=n;j++)\n\t\t\t\tif (i!=j && i!=k && j!=k && ga[i][j]>ga[i][k]+ga[k][j])\n\t\t\t\t\tga[i][j]=ga[i][k]+ga[k][j];\n}\n\nint depth[10048];queue<int> q;\nbool bfs()\n{\n\tint i,x,y;\n\tfor (i=0;i<=t;i++) depth[i]=-1;\n\tdepth[0]=0;q.push(0);\n\twhile (!q.empty())\n\t{\n\t\tx=q.front();q.pop();\n\t\tfor (i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\ty=to[i];\n\t\t\tif (f[i] && depth[y]==-1)\n\t\t\t{\n\t\t\t\tdepth[y]=depth[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\tif (depth[t]==-1) return false; else return true;\n}\n\nint dfs(int x,int maxf)\n{\n\tif (x==t) return maxf;\n\tint i,minf,now,y,ans=0;\n\tfor (i=head[x];i;i=nxt[i])\n\t{\n\t\ty=to[i];\n\t\tif (f[i] && depth[y]==depth[x]+1)\n\t\t{\n\t\t\tminf=min(f[i],maxf-ans);\n\t\t\tnow=dfs(y,minf);\n\t\t\tf[i]-=now;\n\t\t\tf[i^1]+=now;\n\t\t\tans+=now;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main ()\n{\n\tint i,j,x,y,len;\n\twhile (scanf(\"%d%d%d\",&n,&e,&qq)!=EOF && n && e && qq)\n\t{\n\t\tfor (i=1;i<=n;i++)\n\t\t\tfor (j=1;j<=n;j++)\n\t\t\t\tga[i][j]=INF;\n\t\tfor (i=1;i<=n;i++) ga[i][i]=0;\n\t\tfor (i=1;i<=e;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&len);\n\t\t\tx++;y++;\n\t\t\tga[x][y]=len;ga[y][x]=len;\n\t\t}\n\t\tfloyd();\n\t\tfor (i=1;i<=qq;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&query[i].y,&query[i].x);\n\t\t\tquery[i].y++;\n\t\t}\n\t\tsort(query+1,query+qq+1);\n\t\tt=qq*2+1;\n\t\ttot=1;for (i=0;i<=t;i++) head[i]=0;\n\t\tfor (i=1;i<=qq;i++) addedge(0,i,1);\n\t\tfor (i=1;i<=qq;i++) addedge(qq+i,t,1);\n\t\t//cout<<query[2].x-query[1].x<<endl;\n\t\tfor (i=1;i<=qq;i++)\n\t\t\tfor (j=1;j<=qq;j++)\n\t\t\t\tif (i!=j && ga[query[i].y][query[j].y]<=query[j].x-query[i].x)\n\t\t\t\t{\n\t\t\t\t\t//cout<<i<<' '<<j<<endl;\n\t\t\t\t\taddedge(i,qq+j,1);\n\t\t\t\t}\n\t\tint ans=0;\n\t\twhile (bfs()) ans+=dfs(0,2e9);\n\t\tprintf(\"%d\\n\",qq-ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nconst int INF = 1e9;\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for(int v = 0; v < n; ++v){\n            if (match[v] < 0) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u: g[v]) {\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint N,M,L;\nint mat[110][110];\npair<int,int> node[1010];\n\nint main(){\n    while(cin >> N >> M >> L && N){\n        rep(i,N)rep(j,N) mat[i][j] = (i == j ? 0 : INF);\n        rep(i,M){\n            int u,v,d;\n            cin >> u >> v >> d;\n            mat[u][v] = mat[v][u] = d;\n        }\n        rep(k,N)rep(i,N)rep(j,N) mat[i][j] = min(mat[i][j], mat[i][k]+mat[k][j]);\n        rep(i,L) cin >> node[i].second >> node[i].first;\n        sort(node, node+L);\n\n        bipartite_matching bm(L*2);\n\n        rep(i,L)rep(j,i){\n            int dt = node[i].first - node[j].first;\n            int dist = mat[node[i].second][node[j].second];\n            if(dt >= dist){\n                bm.add_edge(j, i+L);\n            }\n        }\n\n        int f = bm.maximum_matching();\n        cout << L-f << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,cost,rev;\n};\n\nconst int INF=1<<29;\nint N,L;\nint NV;\nvector<vector<edge> > G;\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back({to,cap,cost,(int)G[to].size()});\n  G[to].push_back({from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t){\n  int nc=0;\n  for(int c=1;;c++){\n    int dist[202];\n    fill(begin(dist),end(dist),INF);\n    dist[0]=0;\n    int prevv[202],preve[202];\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<NV;v++){\n\tif(dist[v]==INF)continue;\n\tfor(int i=0;i<G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t    dist[e.to]=dist[v]+e.cost;\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    update=true;\n\t  }\n\t}\n      }\n    }\n    nc-=dist[t];\n    if(nc==L)return c;\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap--;\n      G[v][e.rev].cap++;\n    }\n  }\n}\n\nint main(){\n  for(int M;cin>>N>>M>>L,N;){\n    NV=2*L+2;\n    int d[100][100];\n    fill(d[0],d[100],INF);\n    for(int i=0;i<N;i++){\n      d[i][i]=0;\n    }\n    while(M--){\n      int u,v,di;\n      cin>>u>>v>>di;\n      d[u][v]=d[v][u]=min(d[u][v],di);\n    }\n    for(int k=0;k<N;k++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<N;j++){\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    G=vector<vector<edge> >(NV);\n    vector<pair<int,int> > pt;\n    for(int i=0;i<L;i++){\n      int p,t;\n      cin>>p>>t;\n      pt.emplace_back(t,p);\n    }\n    sort(begin(pt),end(pt));\n    for(int i=0;i<pt.size();i++){\n      add_edge(0,2*i+2,1,0);\n      add_edge(2*i+2,2*i+3,1,-1);\n      add_edge(2*i+3,1,1,0);\n      for(int j=0;j<i;j++){\n\tif(pt[j].first+d[pt[j].second][pt[i].second]<=pt[i].first){\n\t  add_edge(2*j+3,2*i+2,1,0);\n\t}\n      }\n    }\n    cout<<min_cost_flow(0,1)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\n#define MAX_V 2010\n\nstruct edge{ int to,cap,rev; };\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid init(int V){\n  rep(i,V)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front(); que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n\nint N,M,L;\nll d[101][101];\nll p[1001],t[1001];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin>>N>>M>>L;\n    if(N==0)break;\n    rep(i,N)rep(j,N)d[i][j]=(i==j?0:1e16);\n    rep(i,M){\n      ll a,b,c;\n      cin>>a>>b>>c;\n      d[a][b]=d[b][a]=c;\n    }\n    rep(k,N)rep(i,N)rep(j,N)minch(d[i][j],d[i][k]+d[k][j]);\n    int source=2*L,sink=2*L+1;\n    rep(i,L){\n      cin>>p[i]>>t[i];\n    }\n    init(2*L+2);\n    rep(i,L)rep(j,L){\n      if(i==j)continue;\n      if(t[i]+d[p[i]][p[j]]<=t[j])add_edge(i,j+L,1);\n    }\n    rep(i,L){\n      add_edge(source,i,1);\n      add_edge(i+L,sink,1);\n    }\n    cout<<L-max_flow(source,sink)<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n#define MAX_V 2200\nint n;\nvector<int> g[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvoid init(int n_) {\n\tn = n_;\n\trep(i, 0, n_)g[i].clear();\n}\nvoid addEdge(int u, int v) {\n\tg[u].emplace_back(v);\n\tg[v].emplace_back(u);\n}\nbool augment(int v) {\n\tused[v] = true;\n\tfor (int u : g[v]) {\n\t\tint w = match[u];\n\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatching() {\n\tint cnt = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < n; v++) {\n\t\tif (match[v] == -1) {\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tif (augment(v))cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tinit(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\taddEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 5000\nusing namespace std;\ntypedef pair<int,int> ii;\n\n// flow --- start\nstruct edge\n{\n  int to,cap,rev;\n  edge(int to=inf,int cap=inf,int rev=inf):to(to),cap(cap),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint level[MAX];\nint iter[MAX];\n\nvoid add_edge(int from,int to,int cap)\n{\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n  rep(i,MAX)level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty())\n    {\n      int v = que.front(); que.pop();\n      rep(i,G[v].size())\n\t{\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && level[e.to] < 0)\n\t    {\n\t      level[e.to] = level[v] + 1;\n\t      que.push(e.to);\n\t    }\n\t}\n    }\n} \n\nint dfs(int v,int t,int f)\n{\n  if(v == t)return f;\n  for(int &i = iter[v]; i < G[v].size() ; i++)\n    {\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to])\n\t{\n\t  int d = dfs(e.to,t,min(f,e.cap));\n\t  if(d > 0)\n\t    {\n\t      e.cap -= d;\n\t      G[e.to][e.rev].cap += d;\n\t      return d;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;)\n    {\n      bfs(s);\n      if(level[t] < 0)return flow;\n      rep(i,MAX)iter[i] = 0;\n      int f;\n      while((f = dfs(s,t,inf)) > 0)\n\tflow += f;\n    }\n}\n\n// flow --- end\n\n\nint N,M,L;\nint mincost[MAX][MAX];\nvector<ii> ps;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      rep(i,MAX)G[i].clear();\n      rep(i,MAX)rep(j,MAX)mincost[j][i] = inf;\n      rep(i,MAX)          mincost[i][i] = 0;\n\n      {\n\tint u,v,d;\n\trep(i,M)\n\t  {\n\t    cin >> u >> v >> d;\n\t    mincost[u][v] = mincost[v][u] = d;\n\t  }\n\trep(i,MAX)rep(j,MAX)rep(k,MAX)mincost[j][k] = min(mincost[j][k],mincost[j][i]+mincost[i][k]);\n\n\tps.clear();\n\tps.resize(L);\n\trep(i,L)cin >> ps[i].first >> ps[i].second;\n\tV = L;\t  \n\n\tint st = MAX-2,ed = MAX-1;\n\trep(i,V)        add_edge(st,i,inf);\n\trep(i,V)rep(j,V)if(i != j && ps[i].second+mincost[i][j] <= ps[j].second)add_edge(i,V+j,1);\n\trep(i,V)        add_edge(V+i,ed,1);\n\t/*\n\trep(i,2*N)\n\t  {\n\t    cout << \"start \" << i << endl;\n\t    rep(j,G[i].size())\n\t      {\n\t\tcout << \"(\" << G[i][j].to << \",\" << G[i][j].cap << \") \";\n\t      }\n\t    cout << endl;\n\t  }\n\t*/\n\tcout << N-max_flow(st,ed) << endl;\n\n      }\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n#define min_int(a,b)  ( ((a)<(b) ) ? (a) : (b) )\nusing namespace std;\nclass Req{\npublic:\n  char house;\n  int time;\n};\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\nint dist[max_n][max_n];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\nint req_graph[max_l][max_l];\nint num_child[max_l];//各リクエストxの子の数\nint parent[max_l]; //被覆パスにおけるリクエストxの親\nint till[max_l];\nbool visited[max_l];\n \n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n   \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j,h1,h2;\n \n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++) for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n  } \n}\n \nint find(int i, bool root){\n  int child, x, found;\n  //親権の空いている子を探す\n  visited[i] = true;  \n  if(till[i] < num_child[i]){    \n    while((++(till[i])) < num_child[i]){\n      child = req_graph[i][num_child[i]-till[i]-1];\n      if(parent[child] >= 0) continue;\n      parent[child] = i; //childを自分の子とする\n      return child;\n    }\n  }\n  //他の親から親権を譲ってもらえる子を探す  \n  for(int j = num_child[i]-1;j >=0; j--){\n    child = req_graph[i][j];\n    x = parent[child]; //x: childのパス上の親\n    if(visited[x]) continue;\n    found = find(x,false); //xからchildの親権をもらう交渉\n    if(found < 0) continue;\n    parent[child] = i; //childの親権獲得\n    return child;\n  }\n  return -1;\n}\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  memset(till,-1,l*sizeof(int));\n  memset(parent,-1,l*sizeof(int));\n  for(int i=l-1;i>=0;i--){\n    memset(visited,0,l*sizeof(bool));\n    find(i,true);\n  }\n  for(int i=0;i<l;i++) if(parent[i]<0) num++;\n  return num;\n}\n \n//プレゼント配送に必要なサンタの数を出力する関数\nint santas(){\n  int u,v,d,i;\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  return res;\n}\n \n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;    \n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<math.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n#define maxn 2050\nint V;                 \nvector<int> G[maxn];  \nint match[maxn];  \nbool used[maxn];\n#define  MAX_N 100\n#define  MAX_L 1000\n#define  INF 0x3f3f3f3f\nint dis[MAX_N][MAX_N];\nint p[MAX_L], t[MAX_L];  \nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \n// 通?DFS?找?广路\nbool dfs(int v){\n\tused[v] = true;\n\tfor (vector<int>::iterator it = G[v].begin(); it != G[v].end(); ++it)\n\t{\n\t\tint u = *it, w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n \n\treturn false;\n}\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n \n\treturn res;\n}\n \nvoid clear(){\n\tfor (int i = 0; i < V; ++i){\n\t\tG[i].clear();\n\t}\n}\t\nint main(){\n\tint N, M, L;\n\tint i,j,k;\n\twhile (~scanf(\"%d%d%d\", &N, &M, &L)){\n\t\t\n\t\tV = L * 2;\n\t\tclear();\n\t\tmemset(dis, INF, sizeof(dis));\n \n\t\tfor (i= 0; i< M; ++i){\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tdis[u][v] = dis[v][u] = d;\n\t\t}\n \n\t\tfor (i = 0; i < L; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d\", p + i, t + i);\n\t\t}\n \n\t\tfor (k = 0; k < N; ++k) {\n\t\t\tdis[k][k] = 0;\n\t\t\tfor (i = 0; i < N; ++i) {\n\t\t\t\tfor (j = 0; j < N; ++j) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tfor (i = 0; i < L; ++i) {\n\t\t\tfor (j = 0; j < L; ++j)  {\n\t\t\t\tif (i != j && t[i] + dis[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(2 * i, 2 * j + 1);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", L - bipartite_matching());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nstruct edge\n{\n  int to, cap, rev;\n};\n\nconst int MAX_N = 100;\n// const int MAX_M = 1000;\nconst int MAX_L = 1000;\nconst int MAX_V = MAX_L + MAX_L + 2;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid init_G()\n{\n  for (int v = 0; v < MAX_V; v++)\n    G[v].clear();\n}\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if (v == t)\n    return f;\n\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); i++)\n  {\n    edge &e = G[v][i];\n\n    if (!used[e.to] && e.cap > 0)\n    {\n      int d = dfs(e.to, t, min(f, e.cap));\n\n      if (d > 0)\n      {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(const int s, const int t)\n{\n  int flow = 0;\n\n  for (;;)\n  {\n    memset(used, false, sizeof used);\n    int f = dfs(s, t, INF);\n\n    if (f == 0)\n      return flow;\n    else\n      flow += f;\n  }\n}\n\nint N; // number of houses\nint M; // number of roads\nint L; // number of requests\n\nint as[MAX_L], ts[MAX_L]; // delivery addresses and times.\nint dist[MAX_N][MAX_N];   // dist[u][v] is minimum distances from u to v.\n\n// init_dist() initialize dist[][].\nvoid init_dist()\n{\n  for (int i = 0; i < MAX_N; i++)\n    for (int j = 0; j < MAX_N; j++)\n      dist[i][j] = i == j ? 0 :INF;\n}\n\n// wrshall_floyd() calc minimum distances between all each towns.\nvoid warshall_floyd()\n{\n  for (int k = 0; k < N; k++)\n    for (int u = 0; u < N; u++)\n      for (int v = 0; v < N; v++)\n        dist[u][v] = min(dist[u][v], dist[u][k] + dist[k][v]);\n}\n\n// solve() solves question.\nvoid solve()\n{\n  warshall_floyd();\n\n  init_G();\n\n  const int s = L + L, t = s + 1;\n  // connect s and towns.\n  for (int u = 0; u < L; u++)\n    add_edge(s, u, 1);\n\n  // connect towns and t.\n  for (int u = 0; u < L; u++)\n    add_edge(u + L, t, 1);\n\n  // connect from u(=as[i]) to v(=as[j]) if dist[u][v] <= ts[j] - ts[i]\n  for (int i = 0; i < L; i++)\n    for (int j = 0; j < L; j++)\n      if (i != j && dist[as[i]][as[j]] <= ts[j] - ts[i])\n        add_edge(i, j + L, 1);\n\n  printf(\"%d\\n\", L - max_flow(s, t));\n}\n\n// main() handles input.\nint main()\n{\n  while (true)\n  {\n    init_dist();\n\n    scanf(\"%d%d%d\", &N, &M, &L);\n    if (N == 0 && M == 0 & L == 0)\n      break;\n\n    // load roads.\n    for (int m = 0; m < M; m++)\n    {\n      int u, v, d;\n      scanf(\"%d%d%d\", &u, &v, &d);\n      dist[u][v] = d;\n      dist[v][u] = d;\n    }\n\n    // load presents.\n    for (int l = 0; l < L; l++)\n    {\n      scanf(\"%d%d\", as + l, ts + l);\n    }\n\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\n#define INF 100000000\n\nusing namespace std;\n\nint V,match[202];\nbool used[202];\nvector<int>G[202];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  fill(match,match+202,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+202,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main(void){\n\n  int n,m,l,u,v,d,graph[101][101],p[1001],t[1001];\n\n  while(cin >> n >> m >> l,n|m|l){  \n\n    for(int i=0;i<2*n;i++)G[i].clear();\n\n    fill(graph[0],graph[100],INF);\n    for(int i=0;i<101;i++)graph[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      graph[u][v]=graph[v][u]=d;\n    }\n    \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[p[i]][p[j]]+t[i]<=t[j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nbool G[2000][2000];\nint match[2000];\nbool used[2000];\n\nint V;\n\nvoid add_edge(int v, int u) {\n\tG[v][u] = G[u][v] = true;\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor(int i = 0; i < V; i++) {\n\t\tif(!G[v][i]) continue;\n\t\tint u = i, w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint calc() {\n\tint res = 0;\n\tfill(match, match + V, -1);\n\tfor(int v = 0; v < V; v++) {\n\t\tif(match[v] < 0) {\n\t\t\tfill(used, used + V, false);\n\t\t\tif(dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tV = 2 * L;\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tfor(int j = 0; j < V; j++) {\n\t\t\t\tG[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tadd_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(u,a,b) for(int u=(a);u<(b);u++)\n#define rrep(u,a,b) for(int u=(b)-1;u>=(a);u--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct HopcroftKarp {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match, dist;\n\tvector<bool> used, alive;\n\tHopcroftKarp(int n) : n(n), g(n), match(n), dist(n), used(n), alive(n, true) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\twhile (true) {\n\t\t\tbuildAlternatingLevelGraph();\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint flow = 0;\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tif (match[u] == -1 && augment(u))\n\t\t\t\t\tflow++;\n\t\t\tif (flow == 0)break;\n\t\t\tcnt += flow;\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid buildAlternatingLevelGraph() {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int u = 0; u < n; u++)\n\t\t\tif (match[u] == -1) {\n\t\t\t\tq.emplace(u);\n\t\t\t\tdist[u] = 0;\n\t\t\t}\n\t\twhile (q.size()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w != -1 && dist[w] == -1) {\n\t\t\t\t\tdist[w] = dist[u] + 1;\n\t\t\t\t\tq.emplace(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tbool augment(int u) {\n\t\tused[u] = true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!alive[v])continue;\n\t\t\tint w = match[v];\n\t\t\tif (w == -1 || (!used[w] && dist[w] == dist[u] + 1 && augment(w))) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\tused[v] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\ntemplate<class T, class ...Tail>\nvoid tiedSort(vector<T> &a, vector<Tail>&... tail) {\n\tint n = a.size();\n\tusing S = tuple<T, Tail...>;\n\tvector<S> s(n);\n\tfor (int i = 0; i < n; i++)\n\t\ts[i] = make_tuple(a[i], tail[i]...);\n\tsort(s.begin(), s.end());\n\tfor (int i = 0; i < n; i++)\n\t\ttie(a[i], tail[i]...) = s[i];\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\ttiedSort(t, p);\n\t\tHopcroftKarp hk(L + L);\n\t\tint source = hk.n - 2, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, i + 1, L) {\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\thk.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - hk.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int MAX_V = 2000 + 10;\n\nint V;\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V];\n\nvoid add_edge(int v,int u){\n    G[v].push_back(u);\n    G[u].push_back(v);\n}\n\nbool dfs(int v){\n    if(v<0) return true;\n\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        int w = match[u];\n\n        if(!used[w]&&dfs(w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret = 0;\n    memset(match,-1,sizeof(match));\n\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            memset(used,-1,sizeof(used));\n            if(dfs(v)) ret++;\n        }\n    }\n    return ret;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    int d[100][100] = {};\n    REP(i, N) REP(j, N) d[i][j] = (i != j ? INF : 0);\n    REP(i, M){\n      int u, v, c;\n      scanf(\"%d %d %d\", &u, &v, &c);\n      d[u][v] = d[v][u] = c;\n    }\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int p[1000], t[1000];\n    REP(i, L){\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n    V = 2 * L;\n    REP(i, V) G[i].clear();\n    REP(i, L) FOR(j, i + 1, L) if(t[i] > t[j]) { swap(t[i], t[j]); swap(p[i], p[j]); }\n    REP(i, L) FOR(j, i + 1, L){\n      if(t[i] + d[p[i]][p[j]] <= t[j]) add_edge(i, L + j);\n    }\n    cout << L - bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge1\n{\npublic:\n    int to, cost;\n    Edge1(){};\n    Edge1(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge1> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge1 e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<Edge1> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nclass Edge2\n{\npublic:\n    int to, cap, rev;\n    Edge2(){};\n    Edge2(int to0, int cap0){to = to0; cap = cap0;}\n    Edge2(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge2> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge2> > edges;\n    static vector<unsigned> index;\n    static vector<int> level;\n    static int n;\n\n    class Func{\n    public:\n        static void bfs(int s){\n            level.assign(n, -1);\n            queue<int> q;\n            level[s] = 0;\n            q.push(s);\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for(unsigned i=0; i<edges[v].size(); ++i){\n                    Edge2& e = edges[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        q.push(e.to);\n                    }\n                }\n            }\n        }\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            for(unsigned& i=index[s]; i<edges[s].size(); ++i){\n                Edge2& e = edges[s][i];\n                if(e.cap > 0 && level[s] < level[e.to]){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    n = edges0.size();\n    edges.assign(n, vector<Edge2>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge2& e = edges0[i][j];\n            edges[i].push_back(Edge2(e.to, e.cap, edges[e.to].size()));\n            edges[e.to].push_back(Edge2(i, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        Func::bfs(source);\n        if(level[sink] < 0)\n            return ret;\n        index.assign(n, 0);\n        int f;\n        while((f = Func::dfs(source, sink, INT_MAX)) > 0)\n            ret += f;\n    }\n\n    return 0;\n}\n\nint main()\n{\n    for(;;){\n        int n, m, l;\n        cin >> n >> m >> l;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge1> > edges1(n);\n        for(int i=0; i<m; ++i){\n            int u, v, d;\n            cin >> u >> v >> d;\n            edges1[u].push_back(Edge1(v, d));\n            edges1[v].push_back(Edge1(u, d));\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges1, dist);\n\n        vector<pair<int, int> > del(l);\n        for(int i=0; i<l; ++i)\n            cin >> del[i].second >> del[i].first;\n        sort(del.begin(), del.end());\n\n        vector<vector<Edge2> > edges2(2*l+2);\n        for(int i=0; i<l; ++i){\n            edges2[0].push_back(Edge2(i+2, 1));\n            edges2[i+l+2].push_back(Edge2(1, 1));\n        }\n        for(int i=0; i<l; ++i){\n            for(int j=i+1; j<l; ++j){\n                if(dist[del[i].second][del[j].second] <= del[j].first - del[i].first)\n                    edges2[i+2].push_back(Edge2(j+l+2, 1));\n            }\n        }\n\n        int ret = l - maxFlow(edges2, 0, 1);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\nint v[100][100];\nint p[1000], t[1000];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tREP(i, n)REP(j, n)v[i][j] = INF;\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int INF = 10000000;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Cost cost;\n    Edge *back;\n    Edge(int from, int to, Flow c, Cost d, Edge *b) : from(from), to(to), capacity(c), flow(0), cost(d), back(b) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid make_edge(vector<vector<Edge<Flow,Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    auto *e = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    auto *back = e->back = new Edge<Flow,Cost>(dst, src, 0, -d, e);\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> h(N), dist(N);\n    vector<Edge<Flow,Cost>*> parent(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        dist[src] = 0;\n        fill(parent.begin(), parent.end(), nullptr);\n        priority_queue<pair<Cost,int>> q;\n        q.push(make_pair(0, src));\n        while(!q.empty()) {\n            const int n = q.top().second;\n            const Cost c = -q.top().first;\n            q.pop();\n            if(dist[n] < c) {\n                continue;\n            }\n            for(auto e : g[n]) {\n                if(e->capacity - e->flow > 0) {\n                    const Cost c2 = c + e->cost + h[n] - h[e->to];\n                    if(c2 < dist[e->to]) {\n                        dist[e->to] = c2;\n                        parent[e->to] = e;\n                        q.push(make_pair(-c2, e->to));\n                    }\n                }\n            }\n        }\n        if(parent[sink] == nullptr) {\n            break;\n        }\n\n        Flow to_push = f;\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            to_push = min(to_push, e->capacity - e->flow);\n        }\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            res.second += to_push * e->cost;\n            e->flow += to_push;\n            e->back->flow -= to_push;\n        }\n        f -= to_push;\n        res.first += to_push;\n        for(int i = 0; i < N; ++i) {\n            h[i] += dist[i];\n        }\n    }\n    return res;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<LL>> dist(N, vector<LL>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] >= d) dist[i][j] = d;\n            }\n        }\n    }\n\n    vector<vector<Edge<int,int>*>> graph(L*2+2);\n    const int SRC = L*2;\n    const int SINK = SRC+1;\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const int in_node = i*2;\n        const int out_node = i*2+1;\n        make_edge(graph, SRC, in_node, 1, 0);\n        make_edge(graph, in_node, out_node, 1, 0);\n        make_edge(graph, out_node, SINK, INF, 0);\n        const int ni = queries[i].second;\n        for(int j = i+1; j < L; ++j) {\n            const int nj = queries[j].second;\n            if(dist[ni][nj] != -1 && queries[j].first - queries[i].first >= dist[ni][nj]) {\n                //cout << queries[i].second << ' ' << queries[j].second << endl;\n                make_edge(graph, out_node, j*2, 1, -1);\n            }\n        }\n    }\n    make_edge(graph, SRC, SINK, INF, 0);\n    const auto res = primal_dual(graph, SRC, SINK, L);\n    cout << L + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n&&m&&l) {\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << l - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint biMatch(const vector<vector<int>>& adj, int ln) { // adj: [0,ln)->inL [ln,n)->inR\n    int n = adj.size();\n    vector<int> matchTo(n, -1);\n    vector<bool> used(n, false);\n    function<bool(int)> dfs = [&](int v) {\n        for(int nv : adj[v]) if(!used[nv]) {\n            used[nv] = true;\n            if(matchTo[nv] < 0 || dfs(matchTo[nv])) {\n                matchTo[v] = nv;\n                matchTo[nv] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int ans = 0;\n    for(int v : in(ln)) if(matchTo[v] < 0) {\n        used.assign(n, false);\n        if(dfs(v)) ++ans;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    const int INF(1e9);\n    int n, m, q;\n    while(cin >> n >> m >> q && n) {\n        vector<vector<int>> dist(n, vector<int>(n, INF));\n        for(int i : in(n)) dist[i][i] = 0;\n        for(int _ : in(m)) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            dist[u][v] = dist[v][u] = d;\n        }\n        for(int k : in(n))\n            for(int i : in(n))\n                for(int j : in(n))\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        vector<pair<int, int>> query(q);\n        for(auto& p : query) cin >> p.second >> p.first;\n        sort(query.begin(), query.end());\n        vector<vector<int>> adj(q * 2);\n        for(int i : in(q)) {\n            for(int j : in(i + 1, q)) {\n                int u, v, t1, t2;\n                tie(t1, u) = query[i];\n                tie(t2, v) = query[j];\n                if(t2 - t1 >= dist[u][v]) {\n                    adj[i].emplace_back(j + q);\n                    adj[j + q].emplace_back(i);\n                }\n            }\n        }\n        cout << q - biMatch(adj, q) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(scanf(\"%d%d%d\",&N,&M,&L),N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)scanf(\"%d%d\",&p[i],&t[i]);\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    printf(\"%d\\n\",num);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#define INF 1<<29\nusing namespace std;\n\nint n,m,l;\nint dist[101][101];\nint p[1001],t[1001];\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[2005];\nbool used[2005];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge& e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,false,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nvoid solve(){\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint S=l*2,T=S+1;\n\tfor(int i=0;i<=T;i++){\n\t\tG[i].clear();\n\t}\n\tfor(int i=0;i<l;i++){\n\t\tadd_edge(S,i,1);\n\t\tadd_edge(l+i,T,1);\n\t\tfor(int j=0;j<l;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(dist[p[i]][p[j]]<=t[j]-t[i]){\n\t\t\t\tadd_edge(i,l+j,1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",l-max_flow(S,T));\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n+m+l==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tdist[a][b]=c;\n\t\t\tdist[b][a]=c;\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tscanf(\"%d%d\",&p[i],&t[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nint n,m,L;\nstruct nod\n{\n    int id;\n    int t;\n}nd[1005];\n\nint dist[105][105];\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef double DB;\n\nconst int N = 50005;\nconst int E = 1000005;\nconst int inf = 1000000000;\nstruct Edge\n{\n    int en,cap,flow,next;\n} edge[E];\n\nint head[N] , now[N];\nint src,dest,node,nedge;\nint pre[N] , dis[N] , gap[N];\n\nvoid add_edge(int st,int en,int cap)\n{\n    edge[nedge].en=en;\n    edge[nedge].cap=cap;\n    edge[nedge].flow=0;\n    edge[nedge].next=head[st];\n    head[st]=nedge++;\n\n    edge[nedge].en=st;\n    edge[nedge].cap=0;\n    edge[nedge].flow=0;\n    edge[nedge].next=head[en];\n    head[en]=nedge++;\n}\n\nvoid augment(int flow)\n{\n    for(int i=src;i!=dest;i=edge[now[i]].en)\n    {\n        edge[now[i]].flow+=flow;\n        edge[now[i]^1].flow-=flow;\n    }\n}\n\nint sap()\n{\n    memset(dis,0,sizeof(dis));\n    memset(gap,0,sizeof(gap));\n    memset(pre,-1,sizeof(pre));\n    for(int i=0;i<node;i++)\n        now[i]=head[i];\n    gap[0]=node;\n    int point=src,flow=0,min_flow=inf;\n    while(dis[src]<node)\n    {\n        bool fg=false;\n        for(int i=now[point];~i;i=edge[i].next)\n            if(edge[i].cap-edge[i].flow>0 && dis[point]==dis[edge[i].en]+1)\n            {\n                min_flow=min(min_flow,edge[i].cap-edge[i].flow);\n                now[point]=i;\n                pre[edge[i].en]=point;\n                point=edge[i].en;\n                if(point==dest)\n                {\n                    flow+=min_flow;\n                    augment(min_flow);\n                    point=src;\n                    min_flow=inf;\n                }\n                fg=true;\n                break;\n            }\n        if(fg) continue;\n        if(--gap[dis[point]]==0) break;\n        int Min=node;\n        for(int i=head[point];~i;i=edge[i].next)\n            if(edge[i].cap-edge[i].flow>0 && Min>dis[edge[i].en])\n            {\n                Min=dis[edge[i].en];\n                now[point]=i;\n            }\n        gap[dis[point]=Min+1]++;\n        if(point!=src) point=pre[point];\n    }\n    return flow;\n}\n\nvoid init(int _node,int _src,int _dest)\n{\n    nedge=0;\n    node=_node;\n    src=_src;\n    dest=_dest;\n    for(int i=0;i<node;i++)head[i]=-1;\n}\n\nbool cmp(nod a,nod b)\n{\n    return a.t<b.t;\n}\n\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d%d%d\",&n,&m,&L);\n        if(n==0&&m==0&&L==0)break;\n        for(int i=0;i<n;++i)for(int j=0;j<n;++j)dist[i][j]=1000000008;\n        for(int i=0;i<n;++i)dist[i][i]=0;\n        for(int i=0;i<m;++i)\n        {\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            dist[u][v]=min(w,dist[u][v]);\n            dist[v][u]=min(w,dist[v][u]);\n        }\n        for(int k=0;k<n;++k)\n        {\n            for(int i=0;i<n;++i)\n            {\n                for(int j=0;j<n;++j)\n                {\n                    dist[i][j]=min(dist[i][k]+dist[k][j],dist[i][j]);\n                }\n            }\n        }\n        for(int i=0;i<L;++i)\n        {\n            scanf(\"%d%d\",&nd[i].id,&nd[i].t);\n        }\n        init(2*L+2,2*L,2*L+1);\n        for(int i=0;i<L;++i)\n        {\n            add_edge(src,i,1);\n            add_edge(i+L,dest,1);\n        }\n        for(int i=0;i<L;++i)\n        {\n            for(int j=0;j<L;++j)\n            {\n                if(i!=j&&(LL)nd[j].t+dist[ nd[j].id ][ nd[i].id ] <= nd[i].t )\n                {\n                    add_edge(j,i+L,1);\n                }\n            }\n        }\n        int res = sap();\n        printf(\"%d\\n\",L-res);\n\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <cstdarg>\n#include <sys/time.h>\n#include <fstream>\n//#include \"cout.h\"\n\nusing namespace std;\n\n#define SZ(x) ((int)x.size())\n#define MSET(x,a) memset(x, a, (int)sizeof(x))\n#define PB push_back\n#define VI vector < int >\n#define PII pair < int, int >\n#define LL long long\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(), (v).end()\n#define FIT(it,v) for (typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define OUT(A) cout << #A << \" = \"<< (A) << endl\n#define OUT2(A, B) cout << \"(\" << #A << \", \" << #B << \") = (\" << (A) << \", \"<< (B) << \")\" << endl\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } \ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } \n\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n\n\n\n\n    const int MAX_V = 2010;\n    \n    int V; // 左の頂点数。忘れずに設定すること。\n    // ちなみに、Vは左右合わせた全部の頂点数でも問題ない。（左が終わった後に右からのをチェックしても、マッチ数は絶対増えない）\n    \n    \n    VI G[MAX_V]; // ちゃんとGもケースごとに全部clear。\n    int match[MAX_V];\n    bool used[MAX_V];\n    \n    void add_edge(int u, int v){\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n    \n    bool dfs(int v){\n        used[v] = true;\n        REP(i, SZ(G[v])){\n            int u = G[v][i], w = match[u];\n            if(w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    int bipartite_matching(){\n        int res = 0;\n        MSET(match, -1);\n        REP(v, V){\n            if(match[v] < 0){\n                MSET(used, 0);\n                if(dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n    \n    \n    \nint INF = (1<<29);\n\nint n, m, l;\nint g[110][110];\nint p[1010], t[1010];\n\nvoid init() {\n}\n\nvoid input() {\n\tREP(i, 110) REP(j, 110) g[i][j] = INF;\n\tREP(i, n) g[i][i] = 0;\n\tREP(i, m){\n\t\tint u, v, d;\n\t\tcin >> u >> v >> d;\n\t\tg[u][v] = d, g[v][u] = d;\n\t}\n\tREP(k, n) REP(i, n) REP(j, n) chmin(g[i][j], g[i][k]+g[k][j]);\n\tREP(i, l) cin >> p[i] >> t[i];\n}\n\nvoid solve() {\n\tV = l*2;\n\tREP(i, V) G[i].clear();\n\tREP(i, l) REP(j, l) if(i != j){\n\t\tif(t[i] + g[p[i]][p[j]] <= t[j]) add_edge(i, j+l);\n\t\tif(t[j] + g[p[j]][p[i]] <= t[i]) add_edge(j, i+l);\n\t}\n\tcout << l - bipartite_matching() << endl;\n}\n\nint main() {\n\tinit();\n\twhile(cin >> n >> m >> l){\n\t\tif(n == 0) break;\n\t\tinput();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\nint n, m, l;\nconst int INF = 1000000000;\n\n// **gは無向二部グラフ**\nbool findABipartiteMatching(VVI& g, int v, VI& used, VI& match) {\n  used[v] = true;\n  rep (ui, g[v].size()) {\n    int u = g[v][ui];\n    int w = match[u];\n    if (w == -1 || !used[w] && findABipartiteMatching(g, w, used, match)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> n >> m >>   l, n) {\n    VVI graph(n, VI(n,INF));\n    rep(i,n) graph[i][i] = 0;\n    rep (i,m) {\n      int u, v, d;\n      cin >> u >> v >> d;\n      graph[u][v] = graph[v][u] = d;\n    }\n\n    vector<PII> reqs(l); // fist: t, sec: p\n    rep (i,l) {\n      cin >> reqs[i].second >> reqs[i].first;\n    }\n    sort(reqs.begin(), reqs.end());\n    \n    // warshal-floyd\n    rep(ti,n) rep(u,n) rep(v,n) graph[u][v] = min(graph[u][v], graph[u][ti] + graph[ti][v]);\n\n    VVI reqGraph(l);  // adj graph\n    rep(j,l) rep(i,j) {\n      int u = reqs[i].second;\n      int v = reqs[j].second;\n      int t = reqs[j].first - reqs[i].first;\n      if (graph[u][v] <= t) {   // if (クエリiからクエリjを処理できる)\n        reqGraph[i].push_back(j);\n      }\n    }\n\n    VVI bipGraph(l*2);  // adj graph, 0...l: src, l...2l: sink\n    rep(i,l) rep(j,reqGraph[i].size()) {\n      int to = reqGraph[i][j];\n      bipGraph[i].push_back(l+to);\n      bipGraph[l+to].push_back(i);\n    }\n\n    VI used(2*l);\n    VI match(2*l, -1);\n    int flow = 0;\n    rep(i,2*l) {\n      if (match[i] == -1) {\n        used = VI(2*l);\n        if ( findABipartiteMatching(bipGraph, i, used, match) ) flow++;\n      }\n    }\n    // rep(i,2*l) cout << \"match \" << i%l <<\" \"<< match[i]%l << endl;\n\n    cout << l - flow << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MAX_V 1000\n#define INF 1000000000\nusing namespace std;\n\nint N, M, L, V;\n\nstruct vertex{\n\tint v, time;\n\tbool operator < (const vertex& other){\n\t\treturn time < other.time;\n\t}\n}data[MAX_V];\nint d[100][100];\n\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tfill(d[i], d[i]+N, INF);\n\t\td[i][i] = 0;\n\t}\n\tfor(int i = 0; i < V; i++) G[i].clear();\n}\nvoid floyd_warshall(){\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>N>>M>>L){\n\t\tif(!N && !M && !L) break;\n\t\tV = L;\n\t\tinit();\n\t\twhile(M--){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][b] = c; \n\t\t\td[b][a] = c;\n\t\t}\n\t\tfloyd_warshall();\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tscanf(\"%d%d\", &data[i].v, &data[i].time);\n\t\t}\n\t\tsort(data, data+V);\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = i+1; j < V; j++){\n\t\t\t\tint u = data[i].v, v = data[j].v;\n\t\t\t\tif(data[i].time+d[u][v] <= data[j].time){\n\t\t\t\t\tadd_edge(i, j);\n\t\t\t\t//\tprintf(\"u = %d, v = %d\\n\",u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", V - bipartite_matching());\n\t\t\t\t\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nbool flow[2005][2005];\nbool DAG[1005][1005];\nint L,v[2020];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int src, int dst)\n{\n\tflow[dst][src]=1;\n\tnode[src].to.push_back(dst);\n\tnode[dst].to.push_back(src);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=(flow[p][next]?0:1);\n\t\t\n\t\tif(p==SOUR) fw=1;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]=1;\n\t\t\tflow[next][p]=0;\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(n!=SOUR&&flow[n][next]) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tConnect(node, SOUR, i);\n\t\t\tConnect(node, L+i, SINK);\n\t\t\t\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", L-dinic(SOUR,SINK,node));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nclass bipartite_graph{\n\tvector<vector<int> > Graph;\n\tvector<int> used, match;\n\tint V;\npublic:\n\tbipartite_graph(int size) :V(size){\n\t\tGraph.resize(V);\n\t\tused.resize(V, 0);\n\t\tmatch.resize(V, -1);\n\t}\n\tvoid add_edge(int from, int to){\n\t\tGraph[from].push_back(to);\n\t\tGraph[to].push_back(from);\n\t}\n\tint dfs(int v){\n\t\tused[v] = 1;\n\t\tfor (int i = 0; i < Graph[v].size(); i++){\n\t\t\tint x = Graph[v][i], w = match[x];\n\t\t\tif (w < 0 || !used[w] && dfs(w)){\n\t\t\t\tmatch[x] = v;\n\t\t\t\tmatch[v] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint matching(){\n\t\tfill(match.begin(), match.end(), -1);\n\t\tint res = 0;\n\t\tfor (int v = 0; v < V; v++){\n\t\t\tif (match[v] >= 0) continue;\n\t\t\tfill(used.begin(), used.end(), 0);\n\t\t\tif (dfs(v)) res++;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nconst int N = 110;\nint dist[N][N];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n){\n\t\trep(i, n) rep(j, n) dist[i][j] = i == j ? 0 : 1e9;\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tdist[a][b] = dist[b][a] = c;\n\t\t}\n\t\trep(i, n) rep(j, n) rep(k, n) dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n\t\tvector<pair<int, int>> v(l);\n\t\trep(i, l){\n\t\t\tint pos, t;\n\t\t\tcin >> pos >> t;\n\t\t\tv[i] = MP(t, pos);\n\t\t}\n\t\tsort(ALL(v));\n\t\n\t\tbipartite_graph G(l*2);\n\t\trep(i, l) FOR(j, i + 1, l){\n\t\t\tint a = v[i].second, b = v[j].second;\n\t\t\tif (v[i].first + dist[a][b] <= v[j].first) G.add_edge(i, j + l);\n\t\t}\n\n\t\tcout << l - G.matching() << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, bool Scaling = false> struct dinic {\n  struct edge {\n    int to;\n    T cap;\n  };\n  const T inf = numeric_limits<T>::max(), eps = 1e-10;\n  int n, s, t;\n  vector<edge> es;\n  vector<vector<int>> g;\n  T scale;\n  vector<int> h, ptr;\n  dinic(int _n, int _s, int _t) : n(_n), s(_s), t(_t), g(n), h(n), ptr(n) {}\n  void add(int from, int to, T cap, T rev_cap = 0) {\n    g[from].push_back(es.size()), es.push_back({to, cap});\n    g[to].push_back(es.size()), es.push_back({from, rev_cap});\n  }\n  bool bfs() {\n    static vector<int> que(n);\n    fill(begin(h), end(h), -1);\n    h[t] = 0, que[0] = t;\n    for (int bg = 0, ed = 1; bg < ed; ) {\n      int v = que[bg++];\n      for (int id : g[v])\n        if (es[id ^ 1].cap > scale and h[es[id].to] == -1) {\n          h[es[id].to] = h[v] + 1, que[ed++] = es[id].to;\n          if (es[id].to == s) return true;\n        }\n    }\n    return false;\n  }\n  T dfs(int v, T f) {\n    if (v == t) return f;\n    for (int& i = ptr[v]; i >= 0; --i) {\n      int id = g[v][i];\n      if (es[id].cap > scale and h[v] > h[es[id].to]) {\n        T df = dfs(es[id].to, min(f, es[id].cap));\n        if (df > eps)\n          return es[id].cap -= df, es[id ^ 1].cap += df, df;\n      }\n    }\n    return 0;\n  }\n  T max_flow() {\n    T flow = 0, max_cap = 0;\n    for (auto&& e : es) max_cap = max(max_cap, e.cap);\n    for (scale = Scaling ? max_cap / 2 : eps; ; scale /= 2) {\n      while (bfs()) {\n        for (int v = 0; v < n; ++v) ptr[v] = (int)g[v].size() - 1;\n        for (T df; (df = dfs(s, inf)) > eps; ) flow += df;\n      }\n      if (scale <= eps) break;\n    }\n    return flow;\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, l;\n  while (cin >> n >> m >> l, n) {\n    DEBUG(n, m, l);\n    vector<vector<int>> d(n, vector<int>(n, 0x3f3f3f3f));\n    while (m--) {\n      int u, v, w;\n      cin >> u >> v >> w;\n      d[u][v] = d[v][u] = w;\n    }\n    for (int i = 0; i < n; ++i) {\n      d[i][i] = 0;\n    }\n    for (int k = 0; k < n; ++k) {\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n      }\n    }\n    struct query {\n      int p, t;\n      bool operator<(query b) const {\n        return t < b.t;\n      }\n    };\n    vector<query> qs(l);\n    for (int i = 0; i < l; ++i) {\n      cin >> qs[i].p >> qs[i].t;\n    }\n    sort(begin(qs), end(qs));\n    dinic<int> g(2 * l + 2, 2 * l, 2 * l + 1);\n    for (int i = 0; i < l; ++i) {\n      g.add(g.s, i, 1);\n      g.add(l + i, g.t, 1);\n      for (int j = i + 1; j < l; ++j) {\n        if (d[qs[i].p][qs[j].p] <= qs[j].t - qs[i].t) {\n          g.add(i, l + j, 1);\n        }\n      }\n    }\n    cout << l - g.max_flow() << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nstruct edge\n{\n  int to, cap, rev;\n};\n\nconst int MAX_N = 100;\n// const int MAX_M = 1000;\nconst int MAX_L = 1000;\nconst int MAX_V = MAX_N + MAX_N + 2;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid init_G()\n{\n  for (int v = 0; v < MAX_V; v++)\n    G[v].clear();\n}\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if (v == t)\n    return f;\n\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); i++)\n  {\n    edge &e = G[v][i];\n\n    if (!used[e.to] && e.cap > 0)\n    {\n      int d = dfs(e.to, t, min(f, e.cap));\n\n      if (d > 0)\n      {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(const int s, const int t)\n{\n  int flow = 0;\n\n  for (;;)\n  {\n    memset(used, false, sizeof used);\n    int f = dfs(s, t, INF);\n\n    if (f == 0)\n      return flow;\n    else\n      flow += f;\n  }\n}\n\nint N; // number of houses\nint M; // number of roads\nint L; // number of requests\n\nint as[MAX_L], ts[MAX_L]; // delivery addresses and times.\nint dist[MAX_N][MAX_N];   // dist[u][v] is minimum distances from u to v.\n\n// init_dist() initialize dist[][].\nvoid init_dist()\n{\n  for (int i = 0; i < MAX_N; i++)\n    for (int j = 0; j < MAX_N; j++)\n      dist[i][j] = i == j ? 0 : INF;\n}\n\n// wrshall_floyd() calc minimum distances between all each towns.\nvoid warshall_floyd()\n{\n  for (int k = 0; k < N; k++)\n    for (int u = 0; u < N; u++)\n      for (int v = 0; v < N; v++)\n        dist[u][v] = min(dist[u][v], dist[u][k] + dist[k][v]);\n}\n\n// solve() solves question.\nvoid solve()\n{\n  warshall_floyd();\n\n  init_G();\n\n  const int s = N + N, t = s + 1;\n  // connect s and towns.\n  for (int u = 0; u < N; u++)\n    add_edge(s, u, 1);\n\n  // connect towns and t.\n  for (int u = 0; u < N; u++)\n    add_edge(u + N, t, 1);\n\n  // connect from u(=as[i]) to v(=as[j]) if dist[u][v] <= ts[j] - ts[i]\n  for (int i = 0; i < L; i++)\n    for (int j = 0; j < L; j++)\n      if (i != j && dist[as[i]][as[j]] <= ts[j] - ts[i])\n        add_edge(as[i], as[j] + N, 1);\n\n  printf(\"%d\\n\", L - max_flow(s, t));\n}\n\n// main() handles input.\nint main()\n{\n  while (true)\n  {\n    init_dist();\n\n    scanf(\"%d%d%d\", &N, &M, &L);\n    if (N == 0 && M == 0 & L == 0)\n      break;\n\n    // load roads.\n    for (int m = 0; m < M; m++)\n    {\n      int u, v, d;\n      scanf(\"%d%d%d\", &u, &v, &d);\n      dist[u][v] = d;\n      dist[v][u] = d;\n    }\n\n    // load presents.\n    for (int l = 0; l < L; l++)\n    {\n      scanf(\"%d%d\", as + l, ts + l);\n    }\n\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint const nMax = 1010;\nlong long road[2200][2200];\nint n,m,L,x,y,cost,judge,g[2200][2200],tot;\nint use[2200],from[2200];\nstruct SANTA{\n    int house;\n    long long time;\n}santa[nMax];\nstruct present{\n    int a;\n    long long time;\n}pre[nMax];\nbool match(int x)\n{\n    for(int i = L;i < 2 * L;i++){\n        if( g[x][i] && !use[i] ){\n            use[i] = 1;\n            if(from[i]==-1||match(from[i])){\n                from[i] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint hungary(){\n    tot = 0;\n    memset(from,-1,sizeof(from));\n    for(int i = 0;i < L;i++){\n        memset(use,0,sizeof(use));\n        if(match(i))\n            ++tot;\n    }\n    return tot;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L),n||m||L){\n        int ans = 0;\n        memset(road,63,sizeof(road));\n        for(int i = 1;i <= m;i++){\n            scanf(\"%d%d%d\",&x,&y,&cost);\n            if( road[x][y] > cost )\n                road[x][y] = road[y][x] = cost;\n        }\n        for(int k = 0;k < n;k++){\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < n;j++)\n                    if( road[i][j] > road[i][k] + road[k][j] ) road[i][j] = road[i][k] + road[k][j];\n            }\n        }\n        for(int i = 0;i < n;i++) road[i][i] = 0;\n        for(int i = 0;i < L;i++) scanf(\"%d%d\",&pre[i].a,&pre[i].time);\n        memset(g,0,sizeof(g));\n        for(int i = 0;i < L;i++){\n            for(int j = 0;j < L;j++)\n                if( i != j && road[pre[j].a][pre[i].a] <= pre[j].time - pre[i].time && pre[j].time >= pre[i].time ) g[i][j + L] = 1;\n        }\n        ans = L - hungary();\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<string>\n#include<algorithm>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  //print_setting();//設定表示  \n  return num_covers();\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if(n == 0) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\nconst Weight EPS = 0; // ???????°???°?????????1e-14\n\nstruct Edge {\n    ll src, dst;\n    ll cap = 1;\n    Weight weight; // ????°??????¨?????§???cost?????????\n    ll rev; // ????????°?????????????????¨\n    bool rev_flag = false; // rev??????1\n    Edge() {};\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n    Edge(int src, int dst, int cap, Weight cost): // ????°??????¨?????¨\n        src(src), dst(dst), cap(cap), weight(cost){ }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// ?????§?????¨????°??????¨????????????\n// ?????????????????§?????£????????????????????????????????????\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight, ll cap) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    Edge e = Edge(src, dst, weight);\n    e.cap = cap;\n    g[src].push_back(e); \n}\n\n// ??????????????????\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); } \nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); } \n\n// ??????????????????????????????1??????\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\n\n// Floyd Warshall\n// O(V^3)\n// ??\\???\n// g: ??£??\\????????¨?¨??????????????????°??????????????????????????¨???????????°????????????????¨±?????????\n// ??????\n// dist: dist[i][j]???i??????j???????????????????????????????????????????????°?????????????????????????????¨??§????????? \n//\n// ??¢???????????????????????????????????¨?????????????????´??§????£??????????\nvoid shortestPathFW(const Matrix &g, Matrix &dist) {\n    ll n = g.size();\n    dist = g;\n    rep(k, n) rep(i, n) rep(j, n)\n        if (dist[i][j] > dist[i][k] + dist[k][j])\n            dist[i][j] = dist[i][k] + dist[k][j];\n}\n// O(V^2)\n// ???????????????m??¨?????????n??????????????¨\nvoid initFW(Matrix& m, ll n){\n    m = Matrix(n, Array(n, INF));\n    rep(i, n) m[i][i] = 0;\n}\n\n// ?????¨??????????????°\n// ??\\??????\n// g : ?????¨??°?????????0 ... L-1 ????????´?????????L ... g.size()-1 ????????´????????????????????????\n// L : ?????¨??°??????????????´??????????????°???\n// ?????????matching : ??????????????°?????¨????????????????????????\n//\n// ??¨??????g????????????????????? ??? ??? ??°?????????\n// O(V (V + E))\nbool augment(const Graph& g, int u,\n        vector<int>& matchTo, vector<bool>& visited) {\n    if (u < 0) return true;\n    FOR(e, g[u]) if (!visited[e->dst]) {\n        visited[e->dst] = true;\n        if (augment(g, matchTo[e->dst], matchTo, visited)) {\n            matchTo[e->src] = e->dst;\n            matchTo[e->dst] = e->src;\n            return true;\n        }\n    }\n    return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n    const int n = g.size();\n    vector<int> matchTo(n, -1);\n    int match = 0;\n    rep(u, L) {\n        vector<bool> visited(n);\n        if (augment(g, u, matchTo, visited)) ++match;\n    }\n    rep(u, L) if (matchTo[u] >= 0) // make explicit matching\n        matching.push_back( Edge(u, matchTo[u], 1) );\n    return match;\n}\n// ?????¨??????????????°?????\\?????°??????????????§??¢??°???????§????\n// bool f(i, j) : ??????i in [0, L)????????????j in [0, R)??¨?????????????????°1, ???????????°0\ntemplate<class Function>\nvoid constructBiparitate(Graph& g, int L, int R, Function f) {\n    g = Graph(L + R);\n    rep(l, L) rep(r, R) if (f(l, r)) addDirected(g, l, L + r);\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m, l;\n    while (cin >> n >> m >> l && n) {\n        Matrix dist;\n        Matrix g_fw;\n        initFW(g_fw, n);\n        rep(i, m) {\n            ll u, v, d; cin >> u >> v >> d;\n            g_fw[u][v] = g_fw[v][u] = d;\n        }\n        shortestPathFW(g_fw, dist);\n\n        vll p(l), t(l);\n        rep(i, l) {\n            cin >> p[i] >> t[i];\n        }\n\n        Graph g(2*l);\n        rep(i, l) rep(j, l) if (i != j) {\n            if (dist[p[i]][p[j]] <= t[j] - t[i]) { // i -> j??????????????°\n                addDirected(g, i, l+j);\n            }\n        }\n//        vizGraph(g);\n        Edges matching;\n        int ret = bipartiteMatching(g, l, matching);\n        cout << l - ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\n#define MAX_V 2000\n#define INF 1e9\n \nint V,match[MAX_V];\nvector<int> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n \nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n\tint u = G[v][i],w = match[u];\n\tif(w < 0 || (!used[w] && dfs(w))){\n\t    match[v] = u;\n\t    match[u] = v;\n\t    return true;\n\t}\n    }\n    return false;\n}\n \nint bipartite_matching(){\n    int res = 0;\n    memset(match,-1,sizeof(match));\n    for(int v = 0 ; v < V ; v++){\n\tif(match[v] < 0){\n\t    memset(used,false,sizeof(used));\n\t    if(dfs(v)){ res++; }\n\t}\n    }\n    return res;\n}\n \nvoid init(){\n    for(int i = 0 ; i < MAX_V ; i++){\n\tG[i].clear();\n    }\n}\n \nint main(){\n    int N,M,L,a,b,c;\n    while(cin >> N >> M >> L, N){\n\tint d[MAX_N][MAX_N];\n\tfor(int i = 0 ; i < N ; i++){\n\t    for(int j = 0 ; j < N ; j++){\n\t\td[i][j] = (i != j ? INF : 0);  \n\t    }\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> a >> b >> c;\n\t    d[a][b] = d[b][a] = c;\n\t}\n \n\tint p[L],t[L];\n\tfor(int i = 0 ; i < L ; i++){\n\t    cin >> p[i] >> t[i];\n\t}\n\tfor(int i = 0 ; i < L ; i++){\n\t    for(int j = L-1 ; j > 0 ; j--){\n\t\tif(t[j] < t[j-1]){\n\t\t    swap(t[j],t[j-1]);\n\t\t    swap(p[j],p[j-1]);\n\t\t}\n\t    }\n\t}\n\tfor(int k = 0 ; k < N ; k++){\n\t    for(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t}\n\t    }\n\t}\n\tinit(); V = L;\n\tfor(int i = 0 ; i < L ; i++){\n\t    for(int j = i+1 ; j < L ; j++){\n\t\tif(d[p[i]][p[j]] <= t[j]-t[i]){\n\t\t    add_edge(i,j+L);\n\t\t}\n\t    }\n\t}\n\tcout << L-bipartite_matching() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint search(vector<int>& psort,vector<int>& tsort,int nos,int* santanow,int* santatime,int dist[1000][1000],int pos,int max,int upper){\n\tpos++;\n\tif(max == pos){\n\t\treturn nos;\n\t}\n\n\tvector<int> avalable;\n\tfor(int i = 0; i < nos; i++){\n\t\tint temp = santatime[i]  + dist[psort[pos]][santanow[i]];\n\t\tif(temp <= tsort[pos]){\n\t\t\tavalable.push_back(i);\n\t\t}\n\t}\n\n\tif(avalable.empty()){\n\t\tnos++;\n\t\tif(nos > upper){\n\t\t\treturn nos;\n\t\t}\n\t\tsantanow[nos-1] = psort[pos];\n\t\tsantatime[nos-1] = tsort[pos];\n\t\tnos = search(psort,tsort,nos,santanow,santatime,dist,pos,max,upper);\n\t}else{\n\t\tvector<int> noss;\n\t\tint min = max;\n\t\tfor(int i = 0; i < avalable.size(); i++){\n\t\t\tsantanow[avalable[i]] = psort[pos];\n\t\t\tsantatime[avalable[i]] = tsort[pos];\n\t\t\tnoss.push_back(search(psort,tsort,nos,santanow,santatime,dist,pos,max,upper));\n\t\t}\n\t\tfor(int i = 0; i < noss.size(); i++){\n\t\t\tif(min > noss[i]){\n\t\t\t\tmin = noss[i];\n\t\t\t}\n\t\t}\n\t\tnos = min;\n\t}\n\n\treturn nos;\n}\n\nint main(){\n\tint N,M,L;\n\tint u[1000],v[1000],d[1000],p[1000],t[1000];\n\tvector<int> numofsanta;\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\n\twhile(N != 0 || M != 0 || L != 0){\n\t\tint dist[1000][1000];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = 100000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> psort;\n\t\tvector<int> tsort; \n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d\",&u[i],&v[i],&d[i]);\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\n\t\t//Warshall-Floyd Algorithm\n\n    \tfor(int i = 0; i < N; i++){\n        \tfor(int j = 0; j < N; j++){\n            \tfor(int k = 0; k < N; k++){\n            \t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            \t}\n            }\n        }\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tvector<int>::iterator p_it = psort.begin();\n\t\t\tvector<int>::iterator t_it = tsort.begin();\t\n\t\t\tscanf(\"%d %d\",&p[i],&t[i]);\n\t\t\tif(i == 0){\n\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\ttsort.push_back(t[i]);\n\t\t\t}else{\n\t\t\t\tint siz = psort.size();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tif(tsort[j] > t[i]){\n\t\t\t\t\t\tpsort.insert(p_it,p[i]);\n\t\t\t\t\t\ttsort.insert(t_it,t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\t\t\ttsort.push_back(t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++p_it;\n\t\t\t\t\t\t++t_it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//探索打ち切り上限を求めておく\n\t\tint upper = 1;\n\t\tint max = psort.size();\n\t\tint uppernow[max],uppertime[max];\n        for(int i = 0; i < max; i++){\n            if(i == 0){\n                uppernow[0] = psort[0];\n\t\t\t\tuppertime[0] = tsort[0];\n            }else{\n                int siz = upper;\n                for(int j = 0; j < siz; j++){\n                    int temp = uppertime[j]  + dist[psort[i]][uppernow[j]];\n                    if(temp <= tsort[i]){\n                    \tuppernow[j] = psort[i];\n                    \tuppertime[j] = tsort[i];\n                        break;\n                    }else if(j == siz - 1){\n                        uppernow[upper] = psort[i];\n                        uppertime[upper] = tsort[i];\n                        upper++;\n                        break;\n                    }\n                }\n            }\n        }\n\n        int santanow[max],santatime[max];\n        santanow[0] = psort[0];\n\t\tsantatime[0] = tsort[0];\n\t\tint nos = 1;\n\t\tnos = search(psort,tsort,nos,santanow,santatime,dist,0,max,upper);\n\n\t\tnumofsanta.push_back(nos);\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t}\n\n\tfor(int i = 0; i < numofsanta.size(); i++){\n\t\tprintf(\"%d\\n\",numofsanta[i]);\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF 999999999\n\ntypedef pair<int,int> P;\n\nint n, m, l;\nint t[102][102];\nP p[1002];\n\nint V;\nvector<int> G[1002];\nint match[1002];\nbool used[1002];\n\n\nvoid floyd(){\n  for(int k = 0; k < n; k++){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        if(i == j) continue;\n        t[i][j] = min(t[i][j], t[i][k] + t[k][j]);\n      }\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    t[i][i] = 0;\n  }\n}\n\nvoid mkGraph(){\n  for(int i = 0; i < 1002; i++){\n    G[i].clear();\n  }\n  sort(p, p + l);\n\n  for(int i = 0; i < l; i++){\n    for(int j = i + 1; j < l; j++){\n      if(p[i].first + t[p[i].second][p[j].second] <= p[j].first){\n        G[i].push_back(j);\n        G[j].push_back(i);\n      }\n    }\n  }\n\n  V = l;\n}\n\nbool dfs(int v){\n  used[v] = true;\n\n  for(int i = 0; i < G[v].size(); i++){\n    int u = G[v][i];\n    int w = match[u];\n\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m >> l, n || m || l){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        t[i][j] = INF;\n      }\n    }\n\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      t[a][b] = t[b][a] = c;\n    }\n\n    for(int i = 0; i < l; i++){\n      cin >> p[i].second >> p[i].first;\n    }\n\n    floyd();\n    mkGraph();\n    cout << l - bipartite_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BipartiteMatching {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\tvector<int> used;\n\tBipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (augment(v)) cnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\tbool augment(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tBipartiteMatching bm(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tbm.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - bm.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <string.h>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge{int to, cap, rev;};\n\nvector< vector<edge> > G(2002);\nint level[2002];\nint iter[2002];\n\nvoid bfs(int s){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L, N){\n    vector< vector<int> > D(N, vector<int>(N, INF));\n    for(int i = 0; i < M; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      D[u][v] = d;\n      D[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) D[i][i] = 0;\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n    vector< pair<int,int> > V;\n    for(int i = 0; i < L; ++i){\n      int p, t;\n      cin >> p >> t;\n      V.push_back(make_pair(t, p));\n    }\n    sort(V.begin(), V.end());\n\n    for(int i = 0; i < L; ++i){\n      for(int j = 0; j < i; ++j){\n        int p_i = V[i].second, t_i = V[i].first, p_j = V[j].second, t_j = V[j].first;\n        if(D[p_j][p_i] <= t_i - t_j) add_edge(j, L + i, 1);\n      }\n    }\n    for(int i = 0; i < L; ++i){\n      add_edge(2*L, i, 1);\n      add_edge(L + i, 2*L+1, 1);\n    }\n    int ans = L - max_flow(2*L, 2*L+1);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define size(x) ((int)(x).size()) \n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int maxn = 1123;\nconst int inf = 5e8;\nint n, m;\nint d[111][111];\nint p[maxn], w[maxn];\nint vis[maxn];\nstd::vector<int> G[maxn];\n\nvoid init(int x){\n\tfor(int i = 0; i < x; i++){\n\t\tG[i].clear();\n\t}\n}\n\nint dfs(int x){\n\tfor(int i = 0; i < size(G[x]); i++){\n\t\tint u = G[x][i];\n\t\tif(!vis[u]){\n\t\t\tvis[u] = 1;\n\t\t\tif(p[u] < 0 || dfs(p[u])){\n\t\t\t\tp[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint match(int x){\n\tint num = 0;\n\tmemset(p, -1, sizeof(p));\n\tfor(int i = 0; i < x; i++){\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tif(dfs(i)){\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint L;\n\twhile(cin >> n >> m >> L && n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j) d[i][j] = 0;\n\t\t\t\telse d[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tinit(L);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\td[x][y] = z;\n\t\t\td[y][x] = z;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tcin >> p[i] >> w[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(d[p[i]][p[j]] + w[i] <= w[j] && i != j){\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << L - match(L) << endl;\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass MaxFlow{\n  typedef long long ll;\n  \n  struct edge{\n    int to;\n    ll cap;\n    int rev;\n    edge(){}\n    edge(int to, ll cap, int rev) : to(to), cap(cap), rev(rev){}\n  };\n  \n  std::vector<std::vector<edge> > G;\n  std::vector<int> level;\n  std::vector<int> iter;\n\n  void bfs(int s){\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n    \n  ll dfs(int v, int t, ll f){\n    if(v == t) return f;\n    \n    for(int &i = iter[v]; i < (int)G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] > level[v]){\n        ll d = dfs(e.to, t, std::min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \npublic:\n  MaxFlow(int V) :\n    G(std::vector<std::vector<edge> >(V)),\n    level(std::vector<int>(V)),\n    iter (std::vector<int>(V)) { }\n  \n  void add_edge(int from, int to, ll cap){\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n  }\n\n  ll solve(int s, int t){\n    ll res = 0, f;\n    for(;;){\n      bfs(s);\n      if(level[t] < 0) break;\n      std::fill(iter.begin(), iter.end(), 0);\n      while((f = dfs(s, t, LONG_LONG_MAX)) > 0) res += f;\n    }\n    return res;\n  }\n};\n\n\n\nint main(){\n\n  int n, m, l;\n  const int inf = 1000 * 1000 * 1000 + 7;\n  \n  while (cin >> n >> m >> l && n + m + l){\n    vector<vector<int> > adj(n, vector<int>(n, inf));\n    REP(i, m){\n      int a, b, c;\n      cin >> a >> b >> c;\n      assert(a < n && b < n) ;\n      adj[a][b] = c;\n      adj[b][a] = c;\n    }\n\n    REP(k, n) REP(i, n) REP(j, n){\n      adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);\n    }\n    int s = 2 * l;\n    int t = s + 1;\n    int V = t + 1;\n    MaxFlow mf(V);\n    vector<int> p(l), time(l);\n    \n    REP(i, l) cin >> p[i] >> time[i];\n    \n    REP(i, l) REP(j, l) if (p[i] != p[j]){\n      if (time[i] + adj[p[i]][p[j]] <= time[j]){\n        mf.add_edge(i, j + l, 1);\n      }\n    }\n    REP(i, l){\n      mf.add_edge(s, i, 1);\n      mf.add_edge(i + n, t, 1);\n    }\n    cout << l - mf.solve(s, t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2251\n\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <iostream>\n#include <limits>\n#include <math.h>\n#include <memory>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\n\nnamespace Util {\n    int bipartite_match(size_t, size_t, const function<bool(size_t, size_t)>&);\n    int min_path_cover_dag(size_t, const function<bool(size_t, size_t)>&);\n    int clamp_sum(int, int);\n};\n\nstruct Network {\n    struct Edge {\n        size_t to; // 行き先\n        int cap; // 容量\n        size_t rev; // 逆辺インデックス\n        Edge(size_t to, int cap, size_t rev): to(to), cap(cap), rev(rev) {};\n    };\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n    // コンストラクタ\n    explicit Network(size_t vertices) {\n        graph.resize(vertices);\n    }\n    // 辺を追加する\n    void add_edge(size_t from, size_t to, int cap) {\n        assert(from < graph.size() && to < graph.size());\n        graph[from].emplace_back(to, cap, graph[to].size());\n        graph[to].emplace_back(from, 0, graph[from].size() - 1);\n    }\n    // Ford-Fulkerson法で最大流を求める\n    int max_flow_ff(size_t s, size_t t) {\n        assert(s < graph.size() && t < graph.size());\n        int max_flow = 0;\n        while (true) {\n            vector<bool> used(graph.size(), false);\n            int flow = dfs_path(s, t, numeric_limits<int>::max(), used);\n            if (flow == 0) {\n                return max_flow;\n            }\n            max_flow += flow;\n        }\n    }\n    // 始点vから終点tへのパスをDFSで見つけて水を流す。流した分だけ各辺のcapacityが変化する。\n    // return 流した流量\n    // max_flow 見つけたパスに流す流量の最大値。それ以上は（流せても）流さない。\n    // used 訪問済み頂点フラグ\n    int dfs_path(size_t v, size_t t, int max_flow, vector<bool>& used) {\n        assert(used.size() == graph.size());\n        assert(v < graph.size() && t < graph.size());\n        if (v == t) {\n            return max_flow;\n        }\n        used[v] = true;\n        for (Edge& e : graph[v]) {\n            if (used[e.to] || e.cap == 0) { // 行き先が訪問済みか、これ以上流せない辺なら\n                continue;\n            }\n            int flow = dfs_path(e.to, t, min(e.cap, max_flow), used);\n            if (flow == 0) {\n                continue;\n            }\n            e.cap -= flow;\n            graph[e.to][e.rev].cap += flow;\n            return flow;\n        }\n        return 0;\n    }\n};\n\n// 重み付き有効グラフ、隣接行列表現\nstruct MatrixCostGraph {\n    // cost[i][j] = iからjへのコスト、接続されていない場合はintのmax。対角線は0。\n    vector<vector<int>> cost;\n    // コンストラクタ\n    MatrixCostGraph(size_t vertices) {\n        cost = vector<vector<int>>(vertices, vector<int>(vertices, numeric_limits<int>::max()));\n        for (size_t v = 0; v < vertices; v++) {\n            cost[v][v] = 0;\n        }\n    }\n    // エッジを追加する（単方向）\n    void set_edge(size_t from, size_t to, int edge_cost) {\n        cost[from][to] = edge_cost;\n    }\n    // エッジを追加する（双方向）\n    void set_edge_bidir(size_t from, size_t to, int edge_cost) {\n        cost[from][to] = edge_cost;\n        cost[to][from] = edge_cost;\n    }\n    // ワーシャルフロイド法で全点対最短路を求める\n    // O(N^3)\n    vector<vector<int>> warshall_floyd() const {\n        vector<vector<int>> ret = cost;\n        for (int k = 0; k < cost.size(); k++) {\n            for (int i = 0; i < cost.size(); i++) {\n                for (int j = 0; j < cost.size(); j++) {\n                    // ret[i][j]に頂点i,j,[0..k]までを使う場合の最短路を求める\n                    ret[i][j] = min(ret[i][j], Util::clamp_sum(ret[i][k], ret[k][j]));\n                }\n            }\n        }\n        return ret;\n    }\n};\n\nnamespace Util {\n    // 二部グラフの最大マッチングを求める\n    int bipartite_match(size_t u_size, size_t v_size, const function<bool(size_t, size_t)>& is_connected) {\n        Network net(u_size + v_size + 2); // 0=start, 1=end, uたち, vたち\n        const size_t U_START = 2;\n        const size_t V_START = U_START + u_size;\n        for (size_t u = 0; u < u_size; u++) {\n            net.add_edge(0, u + U_START, 1);\n        }\n        for (size_t v = 0; v < v_size; v++) {\n            net.add_edge(v + V_START, 1, 1);\n        }\n        for (size_t u = 0; u < u_size; u++) {\n            for (size_t v = 0; v < v_size; v++) {\n                if (is_connected(u, v)) {\n                    net.add_edge(u + U_START, v + V_START, 1);\n                }\n            }\n        }\n        return net.max_flow_ff(0, 1);\n    }\n    // DAGに対して最小パスカバーを求める\n    int min_path_cover_dag(size_t vertices, const function<bool(size_t, size_t)>& has_edge) {\n        assert(vertices <= numeric_limits<int>::max());\n        return (int)vertices - Util::bipartite_match(vertices, vertices,\n                                                     [vertices, &has_edge](size_t u, size_t v) -> bool {\n                                                         assert(v < vertices && u < vertices);\n                                                         return has_edge(u, v);\n                                                     });\n    }\n    int clamp_sum(int x, int y) {\n        return (int)min((ll)numeric_limits<int>::max(), max((ll)numeric_limits<int>::min(), (ll)x + (ll)y));\n    }\n}\n\nint main() {\n    int N, M, L;\n    while (true) {\n        cin >> N >> M >> L;\n        if (N == 0 && M == 0 && L == 0) {\n            return 0;\n        }\n        MatrixCostGraph roads(N);\n        for (int i = 0; i < M; i++) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            roads.set_edge_bidir(u, v, d);\n        }\n        vector<vector<int>> dists = roads.warshall_floyd();\n        struct Request {\n            int house_idx;\n            int time;\n        };\n        vector<Request> reqs;\n        for (int i = 0; i < L; i++) {\n            int house_idx, time;\n            cin >> house_idx >> time;\n            reqs.push_back((Request){house_idx, time});\n        }\n        auto has_edge = [&dists, &reqs](size_t u, size_t v) -> bool {\n            int time = reqs[v].time - reqs[u].time;\n            if (time <= 0) {\n                return false;\n            }\n            int dist = dists[reqs[u].house_idx][reqs[v].house_idx];\n            return dist <= time;\n        };\n//#ifdef DEBUG\n//        for (size_t u = 0; u < L; u++) {\n//            for (size_t v = 0; v < L; v++) {\n//                cout << \"[\" << u << \",\" << v << \"]=\" << has_edge(u, v) << endl;\n//            }\n//        }\n//#endif\n        int min_santas = Util::min_path_cover_dag(L, has_edge);\n        cout << min_santas << endl;\n    }\n}\n\n/*\n \n 10 10 10\n 0 1 39\n 2 3 48\n 3 5 20\n 4 8 43\n 3 9 10\n 8 9 40\n 3 4 5\n 5 7 20\n 1 7 93\n 1 3 20\n 0 0\n 1 100000000\n 2 100\n 3 543\n 4 500\n 5 400\n 6 300\n 7 200\n 8 100\n 9 100\n \n 10 10 9\n 0 1 39\n 2 3 48\n 3 5 20\n 4 8 43\n 3 9 10\n 8 9 40\n 3 4 5\n 5 7 20\n 1 7 93\n 1 3 20\n 0 0\n 2 100\n 3 543\n 4 500\n 5 400\n 6 300\n 7 200\n 8 100\n 9 100\n \n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Edge {\n\tint to, cap, rev;\n};\nvector< vector<Edge> > G;\nint dist[110][110];\n\nvoid add_edge(int from, int to, int cap) {\n//\tcout << from << \" \" << to << \" \" << cap << endl;\n\tG[from].pb({to, cap, (int)G[to].size()});\n\tG[to].pb({from, 0, (int)G[from].size()-1});\n}\nint cost[3000];\nvoid bfs(int s) {\n\tfill(cost, cost+3000, inf);\n\tqueue<int> Q; Q.push(s); cost[s] = 0;\n\twhile ( !Q.empty() ) {\n\t\tint v = Q.front(); Q.pop();\n\t\tEACH(e, G[v]) {\n\t\t\tif (e.cap > 0 && cost[v]+1 < cost[e.to]) {\n\t\t\t\tcost[e.to] = cost[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nbool used[3000];\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tif (used[s]) return 0;\n\tused[s] = true;\n\tEACH(e, G[s]) {\n\t\tif (e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (cost[t] == inf) break;\n\t\twhile (1) {\n\t\t\tfill(used, used+3000, false);\n\t\t\tint f = dfs(s, t, inf);\n\t\t\tif (f == 0) break;\n\t\t\tres += f;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n/*\n\tG.resize(4);\n\tadd_edge(0, 1, 5);\n\tadd_edge(0, 2, 4);\n\tadd_edge(1, 2, 3);\n\tadd_edge(1, 3, 10);\n\tadd_edge(2, 3, 5);\n\tcout << max_flow(0, 3) << endl;\n\treturn 0;\n*/\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tfill(dist[0], dist[110], inf);\n\t\tREP(i, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tdist[u][v] = min(dist[u][v], d);\n\t\t\tdist[v][u] = min(dist[v][u], d);\n\t\t}\n\t\tREP(i, N) dist[i][i] = 0;\n\t\tREP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tvector<P> task(L);\n\t\tREP(i, L) {\n\t\t\tint p, t; cin >> p >> t;\n\t\t\ttask[i] = P(p, t);\n\t\t}\n\t\tint s = L*2, t = s+1;\n\t\tG = vector< vector<Edge> >(t+1);\n\t\tREP(i, L) REP(j, L) {\n\t\t\tif (i == j) continue;\n\t\t\tif (task[i].second+dist[task[i].first][task[j].first] > task[j].second) continue;\n\t\t\tadd_edge(task[i].first, L+task[j].first, 1);\n\t\t}\n\t\tREP(i, L) add_edge(s, i, 1);\n\t\tREP(i, L) add_edge(L+i, t, 1);\n\t\tcout << L - max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nstruct edge{\n  int to,rev,f;\n};\nvector<edge> G[1111];\n\nbool used[1111];\nbool memo[1111];\n\nvoid init(){\n  memset(used,0,sizeof(used));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( (edge){to,G[to].size(),1} );\n  //G[to].push_back( (edge){from,G[from].size()-1,0} );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\nbool check(){\n  for(int i=0;i<L;i++) {\n    //cout <<i << \" : \" << used[i] << endl;\n    if( !used[i] ) return false;\n  }\n  return true;\n}\n\nint solve(){\n  int r1=0,r2=0;\n  for(int i=0;i<L;i++){\n    if( G[i].empty() ) r1++;\n    for(int j=0;j<(int)G[i].size();j++)\n      used[G[i][j].to] = true;\n  }\n  for(int i=0;i<L;i++)\n    if( !used[i] ) r2++;\n  return max(r1,r2);\n}\n\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n\n    for(int i=0;i<L;i++){\n      for(int j=i+1;j<L;j++){\n        ll len = W[pt[i].second][pt[j].second];\n        ll lt = pt[j].first - pt[i].first;\n        if( len <= lt )          \n          add_edge( i, j );\n      }\n    }\n    // for(int i=0;i<L;i++)\n    //add_edge(L,i);\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n\n    used[L] = true;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nstruct edge\n{\n  int to, cap, rev;\n};\n\nconst int MAX_N = 100;\n// const int MAX_M = 1000;\nconst int MAX_L = 1000;\nconst int MAX_V = MAX_N + MAX_N + 2;\nconst int INF = 1 << 28;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid init_G()\n{\n  for (int v = 0; v < MAX_V; v++)\n    G[v].clear();\n}\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if (v == t)\n    return f;\n\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); i++)\n  {\n    edge &e = G[v][i];\n\n    if (!used[e.to] && e.cap > 0)\n    {\n      int d = dfs(e.to, t, min(f, e.cap));\n\n      if (d > 0)\n      {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(const int s, const int t)\n{\n  int flow = 0;\n\n  for (;;)\n  {\n    memset(used, false, sizeof used);\n    int f = dfs(s, t, INF);\n\n    if (f == 0)\n      return flow;\n    else\n      flow += f;\n  }\n}\n\nint N; // number of houses\nint M; // number of roads\nint L; // number of requests\n\nint as[MAX_L], ts[MAX_L]; // delivery addresses and times.\nint dist[MAX_N][MAX_N];   // dist[u][v] is minimum distances from u to v.\n\n// init_dist() initialize dist[][].\nvoid init_dist()\n{\n  for (int i = 0; i < MAX_N; i++)\n    for (int j = 0; j < MAX_N; j++)\n      dist[i][j] = i == j ? 0 : INF;\n}\n\n// wrshall_floyd() calc minimum distances between all each towns.\nvoid warshall_floyd()\n{\n  for (int k = 0; k < N; k++)\n    for (int u = 0; u < N; u++)\n      for (int v = 0; v < N; v++)\n        dist[u][v] = min(dist[u][v], dist[u][k] + dist[k][v]);\n}\n\n// solve() solves question.\nvoid solve()\n{\n  warshall_floyd();\n\n  init_G();\n\n  const int s = N + N, t = s + 1;\n  // connect s and towns.\n  for (int u = 0; u < N; u++)\n    add_edge(s, u, 1);\n\n  // connect towns and t.\n  for (int u = 0; u < N; u++)\n    add_edge(u + N, t, 1);\n\n  // connect from u(=as[i]) to v(=as[j]) if dist[u][v] <= ts[j] - ts[i]\n  for (int i = 0; i < L; i++)\n    for (int j = 0; j < L; j++)\n      if (i != j && dist[as[i]][as[j]] <= ts[j] - ts[i])\n        add_edge(as[i], as[j] + N, 1);\n\n  printf(\"%d\\n\", L - max_flow(s, t));\n}\n\n// main() handles input.\nint main()\n{\n  while (true)\n  {\n    init_dist();\n\n    scanf(\"%d%d%d\", &N, &M, &L);\n    if (N == 0 && M == 0 & L == 0)\n      break;\n\n    // load roads.\n    for (int m = 0; m < M; m++)\n    {\n      int u, v, d;\n      scanf(\"%d%d%d\", &u, &v, &d);\n      dist[u][v] = d;\n      dist[v][u] = d;\n    }\n\n    // load presents.\n    for (int l = 0; l < L; l++)\n    {\n      scanf(\"%d%d\", as + l, ts + l);\n    }\n\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#define maxn 1100\n#define oo 1000000000\n#define clearAll(a) memset(a,0,sizeof(a))\n#define sq(a) ((a)*(a))\n\nusing namespace std;\n\ntypedef long long ll;\n\nvector<int> g[maxn];\nll d[115][115];\nint a[maxn];\nll t[maxn];\n\nint p[maxn],vis[maxn],n,m,l;\n\nint find(int u)\n{\n    int i;\n    int sz = g[u].size();\n\n    for(i=0;i<sz;i++)\n    {\n    \tint v = g[u][i];\n\n        if(vis[v]==0)\n        {\n            vis[v]=1;\n            if(p[v]==0||find(p[v])==1)\n            {\n                p[v]=u;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvoid build()\n{\n\tfor (int i=1;i<=l;i++)\n\t\tscanf(\"%d%lld\",&a[i],&t[i]);\n\tint x,y;\n\tfor (int i=1;i<=l;i++)\n\t\tfor (int j=1;j<=l;j++)\n\t\tif (i!=j)\n\t\t{\n\t\t\tx = a[i]+1; y = a[j]+1;\n\t\t\tif (d[x][y]+t[i]<=t[j])\n\t\t\t\tg[i].push_back(j);\n\t\t}\n}\n\nint main()\n{\n    //freopen(\"C:\\\\Users\\\\py\\\\Desktop\\\\input.txt\",\"r\",stdin);\n    //freopen(\"C:\\\\Users\\\\py\\\\Desktop\\\\output.txt\",\"w\",stdout);\n\n    while (scanf(\"%d%d%d\",&n,&m,&l)&&(n||m||l))\n    {\n\n    \tfor (int i=1;i<=l;i++)\n    \t\tg[i].clear();\n\n    \tint x,y,w;\n\n    \tfor (int i=1;i<=n;i++)\n    \t\tfor (int j=1;j<=n;j++)\n    \t\t\td[i][j]=oo;\n    \tfor (int i=1;i<=n;i++)\n    \t\td[i][i]=0;\n\n    \tfor (int i=1;i<=m;i++)\n    \t{\n    \t\tscanf(\"%d%d%d\",&x,&y,&w);\n    \t\tx++; y++;\n    \t\td[x][y]=d[y][x]=w;\n    \t}\n\n    \tfor (int k=1;k<=n;k++)\n    \t\tfor(int i=1;i<=n;i++)\n    \t\t\tfor (int j=1;j<=n;j++)\n    \t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    \tbuild();\n\n        clearAll(p);\n    \tint ans = 0;\n    \tfor (int i=1;i<=l;i++)\n    \t{\n    \t    clearAll(vis);\n    \t\tif (find(i)==1)\n    \t\t\tans++;\n    \t}\n\n    \tprintf(\"%d\\n\",l-ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define FIRST 100\n#define NUM 2100\n#define HUGE_NUM 9999999999999\n\nstruct Info{\n\tint house;\n\tll time;\n};\n\n\nint N,M,L;\nll dist_table[FIRST][FIRST];\nInfo info[1000];\n\nint V; //頂点数\nvector<int> G[NUM];\nint match[NUM];\nbool used[NUM];\n\nint boss[1000],height[1000];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)||\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1;\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(i == k){\n\t\t\t\tdist_table[i][k] = 0;\n\t\t\t}else{\n\t\t\t\tdist_table[i][k] = HUGE_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to;\n\tll dist;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %lld\",&from,&to,&dist);\n\t\tdist_table[from][to] = dist;\n\t\tdist_table[to][from] = dist;\n\t}\n\n\tfor(int mid = 0; mid < N; mid++){\n\t\tfor(int start = 0; start < N; start++){\n\t\t\tif(dist_table[start][mid] == HUGE_NUM)continue;\n\t\t\tfor(int end = 0; end < N; end++){\n\t\t\t\tif(dist_table[mid][end] == HUGE_NUM)continue;\n\t\t\t\tdist_table[start][end] = min(dist_table[start][end],dist_table[start][mid]+dist_table[mid][end]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < L; i++){\n\t\tscanf(\"%d %lld\",&info[i].house,&info[i].time);\n\t}\n\n\tfor(int i = 0; i < NUM; i++)G[i].clear();\n\n\tfor(int i = 0; i < L; i++){\n\t\tfor(int k = 0; k < L; k++){\n\t\t\tif(i == k || info[i].time >= info[k].time)continue;\n\n\t\t\tif(dist_table[info[i].house][info[k].house] <= info[k].time-info[i].time){\n\t\t\t\tadd_edge(i,L+k);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = 2*L;\n\tbipartie_matching();\n\n\tfor(int i = 0; i < L; i++){\n\t\tboss[i] = i;\n\t\theight[i] = i;\n\t}\n\n\tint another;\n\n\tfor(int i = 0; i < L; i++){\n\t\tif(match[i] == -1)continue;\n\t\tanother = match[i]-L;\n\t\tunite(i,another);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < L; i++){\n\t\tif(get_boss(i) == i)ans++;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\tif(N == 0 && M == 0 && L == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 100\n#define MAX_N 100\nusing namespace std;\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n  return max_flow(s,t);\n}\n\n\n\nint main(){\n  int n,m,l;\n  while(1){\n    vector<vector<int> >g(30,vector<int>(30,INF));\n  for(int i=0;i<30;i++) G[i].clear(),g[i][i]=0;\n  cin>>n>>m>>l;\n  if(!n&&!m&&!l)break;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    g[a][b]=g[b][a]=c;\n  }\n  vector<int>tl(30,INF);\n  for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[a]=b;\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n  \n  memset(can,0,sizeof(can));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      if(tl[j]==INF||\n\t (tl[i]==INF&&g[i][j]<=tl[j])||\n\t(tl[i]+g[i][j]<=tl[j])) can[i][j]=1;     \n    }\n  cout <<n-Biparite_Matching(n,n)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=2010;\n\nint X,Y;\nvector<int> graph[vmax];\nint match[vmax];\nbool used[vmax];\n\nbool dfs(int v){\n\tused[v]=true;\n\tfor(auto &u:graph[v]){\n\t\tint w=match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w)) ){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res=0;\n\trep(i,vmax) match[i]=-1;\n\trep(v,X+Y){\n\t\tif(match[v]<0){\n\t\t\trep(i,vmax) used[i]=0;\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint n,m,l;\nint dist[110][110];\npair<int,int> info[1010];\n\nint main(void){\n\twhile(cin >> n >> m >> l){\n\t\tif(n==0) break;\n\t\trep(i,vmax) graph[i].clear();\n\t\trep(i,n)rep(j,n) dist[i][j]=((i==j)?0:1<<20);\n\t\trep(i,m){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v]=min(dist[u][v],d);\n\t\t\tdist[v][u]=min(dist[v][u],d);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\n\t\trep(i,l) cin >> info[i].second >> info[i].first;\n\t\tsort(info,info+l);\n\t\tX=Y=l-1;\n\t\trep(i,l-1)rep(j,l-1){\n\t\t\tif(i>j) continue;\n\t\t\tint a=i,b=j+1;\n\t\t\tif(dist[info[b].second][info[a].second]>info[b].first-info[a].first) continue;\n\t\t\tb+=X-1;\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t\tcout << l-bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nclass BipMatch {\nprivate:\n  int v;\n  vector<vector<int> > g;\n  vector<int> match;\n  vector<bool> used;\n\n  bool dfs(int v) {\n    used[v] = true;\n    rep (i, g[v].size()) {\n      int u = g[v][i], w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n\tmatch[v] = u;\n\tmatch[u] = v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  BipMatch() : v(0) {}\n\n  int next() {\n    g.push_back(vector<int>());\n    match.push_back(0);\n    used.push_back(0);\n    return v++;\n  }\n\n  void add_edge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  int run() {\n    int res = 0;\n    fill(match.begin(), match.end(), -1);\n    rep (i, v) if (match[i] < 0) {\n      fill(used.begin(), used.end(), 0);\n      if (dfs(i)) res++;\n    }\n    return res;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (n == 0 && m == 0 && l == 0) break;\n    int dis[n][n];\n    rep (i, n) rep (j, n) dis[i][j] = 1e9;\n    rep (i, n) rep (j, n) dis[i][j] = 1e9;\n    rep (i, m) {\n      int u, v, d;\n      cin >> u >> v >> d;\n      dis[u][v] = min(dis[u][v], d);\n      dis[v][u] = min(dis[v][u], d);\n    }\n    int p[l], t[l];\n    rep (i, l) cin >> p[i] >> t[i];\n    rep (k, n) rep (i, n) rep (j, n) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n    BipMatch bm;\n    int left[l], right[l];\n    rep (i, l) left[i] = bm.next();\n    rep (i, l) right[i] = bm.next();\n    rep (i, l) rep (j, l) if (dis[p[i]][p[j]] <= t[j] - t[i]) bm.add_edge(left[i], right[j]);\n    cout << l - bm.run() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define size(x) ((int)(x).size()) \n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int maxn = 1123;\nconst int inf = 5e8;\nint n, m;\nint d[111][111];\nint p[maxn], w[maxn];\nint vis[maxn];\nstd::vector<int> G[maxn];\n\nvoid init(int x){\n\tfor(int i = 0; i < x; i++){\n\t\tG[i].clear();\n\t}\n}\n\nint dfs(int x){\n\tfor(int i = 0; i < size(G[x]); i++){\n\t\tint u = G[x][i];\n\t\tif(!vis[u]){\n\t\t\tvis[u] = 1;\n\t\t\tif(p[u] < 0 || dfs(p[u])){\n\t\t\t\tp[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint match(int x){\n\tint num = 0;\n\tmemset(p, -1, sizeof(p));\n\tfor(int i = 0; i < x; i++){\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tif(dfs(i)){\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint L;\n\twhile(cin >> n >> m >> L && n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfill(d[i], d[i]+n, inf);\n\t\t}\n\t\tinit(L);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\td[x][y] = z;\n\t\t\td[y][x] = z;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tcin >> p[i] >> w[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(d[p[i]][p[j]] + w[i] <= w[j] && i != j){\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << L - match(L) << endl;\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool bm_augment(const vector<vector<int> >& g, int u, vector<int>& match_to, vector<int>& visited) // {{{\n{\n  if (u < 0) {\n    return true;\n  }\n\n  for (vector<int>::const_iterator it(g[u].begin()); it != g[u].end(); ++it) {\n    if (!visited[*it]) {\n      visited[*it] = true;\n      if (bm_augment(g, match_to[*it], match_to, visited)) {\n        match_to[u] = *it;\n        match_to[*it] = u;\n        return true;\n      }\n    }\n  }\n  return false;\n} // }}}\n\nint bipartite_matching(const vector<vector<int> >& g)  // {{{\n{\n  const int N = g.size();\n  vector<int> match_to(N, -1);\n  int match = 0;\n  for (int u = 0; u < N; u++) {\n    vector<int> visited(N, false);\n    if (bm_augment(g, u, match_to, visited)) {\n      match++;\n    }\n  }\n  return match;\n} // }}}\n\nint main()\n{\n  int N, M, L;\n  while (scanf(\"%d %d %d\", &N, &M, &L) != EOF && N != 0) {\n    static const int INF = 10000000;\n    vector<vector<int> > dist(N, vector<int>(N, INF));\n    for (int i = 0; i < N; i++) {\n      dist[i][i] = 0;\n    }\n    for (int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      dist[u][v] = min(dist[u][v], d);\n      dist[v][u] = min(dist[v][u], d);\n    }\n    vector<pair<int,int> > pt(L);\n    for (int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &pt[i].first, &pt[i].second);\n    }\n\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    vector<vector<int> > g(2*L);\n    for (int i = 0; i < L; i++) {\n      for (int j = 0; j < L; j++) {\n        if (i == j) {\n          continue;\n        }\n        const int u = pt[i].first;\n        const int v = pt[j].first;\n        if (dist[u][v] <= pt[j].second - pt[i].second) {\n          g[i].push_back(j+L);\n        }\n      }\n    }\n    const int r = bipartite_matching(g);\n    printf(\"%d\\n\", L-r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e8;\nstruct Edge {\n    int src, dst;\n    Edge(int f, int t) :\n        src(f), dst(t) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph =  vector<Edges>;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\n\n// g[i][i] = 0, g[i][j] = INF ((i,j) \\nin E)\nvoid WarshallFloyd(Matrix &dist) {\n    int n = dist.size();\n\n    for (int k = 0; k < n; ++k)\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (dist[i][k] == INF || dist[k][j] == INF)\n                    continue;\n                if (dist[i][j] > dist[i][k] + dist[k][j])\n                    dist[i][j] = dist[i][k] + dist[k][j];\n            }\n}\n\n\nbool Augment(const Graph& g, int u,\n             vector<int>& matchTo, vector<bool>& visited) {\n    if (u < 0)\n        return true;\n\n    for (auto e : g[u])\n        if (!visited[e.dst]) {\n            visited[e.dst] = true;\n            if (Augment(g, matchTo[e.dst], matchTo, visited)) {\n                matchTo[e.src] = e.dst;\n                matchTo[e.dst] = e.src;\n                return true;\n            }\n        }\n\n    return false;\n}\n\n// ?????¨??°??????G=(A;B, E)????????§??????????????°????±???????\n// A:[0,L-1], B:[L,g.size()-1]\nint BipartiteMatching(const Graph& g, int L) {\n    const int n = g.size();\n    Edges matching;\n    vector<int> matchTo(n, -1);\n    int match = 0;\n\n    for (int u = 0; u < L; ++u) {\n        vector<bool> visited(n);\n        if (Augment(g, u, matchTo, visited))\n            ++match;\n    }\n\n    for (int u = 0; u < L; ++u)\n        if (matchTo[u] >= 0) // make explicit matching\n            matching.emplace_back(Edge(u, matchTo[u]));\n\n    return match;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, l;\n\n    while (cin >> n >> m >> l) {\n        if (n == 0 && m == 0 && l == 0)\n            break;\n\n        // Caluculate all pair shortest distance\n        int u, v, d;\n        Matrix dist(n, Array(n, INF));\n        for (int i = 0; i < m; ++i) {\n            cin >> u >> v >> d;\n            dist[u][v] = dist[v][u] = d;\n        }\n        for (int i = 0; i < n; ++i)\n            dist[i][i] = 0;\n        WarshallFloyd(dist);\n\n        // Find Minimum Path Cover\n        Graph g(2 * l);\n        vector<pair<int, int>> tp(l);\n        for (int i = 0; i < l; ++i)\n            cin >> tp[i].second >> tp[i].first;\n\n        sort(tp.begin(), tp.end());\n\n        for (int i = 0; i < l; ++i)\n            for (int j = i + 1; j < l; ++j)\n                if (tp[i].first + dist[tp[i].second][tp[j].second] <= tp[j].first)\n                    g[i].emplace_back(Edge(i, j + l));\n\n        cout << l - BipartiteMatching(g, l) << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct bipartite_matching{\n    static const int MAX_V=2010;\n    vector<int>G[MAX_V];\n    int match[MAX_V];\n    bool used[MAX_V];\n\n    void add_edge(int u,int v){\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v]=true;\n        for(int i=0;i<G[v].size();i++){\n            int u=G[v][i],w=match[u];\n            if(w<0||!used[w]&&dfs(w)){\n                match[v]=u;\n                match[u]=v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int matching(){\n        int res=0;\n        memset(match,-1,sizeof(match));\n        for(int v=0;v<MAX_V;v++){\n            if(match[v]<0){\n                memset(used,0,sizeof(used));\n                if(dfs(v))res++;\n            }\n        }\n        return res;\n    }\n};\n\nint N,M,L;\nconst int INF=1001001001001001001;\nint dist[100][100];\nvoid solve(){\n    fill_n(*dist,100*100,INF);\n    rep(i,N)dist[i][i]=0;\n\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        chmin(dist[a][b],c);\n        chmin(dist[b][a],c);\n    }\n    rep(k,N)rep(i,N)rep(j,N)chmin(dist[i][j],dist[i][k]+dist[k][j]);\n\n    vpint qs;\n    rep(i,L){\n        int a,b;\n        cin>>a>>b;\n        qs.pb(pint(b,a));\n    }\n\n    sort(all(qs));\n\n    bipartite_matching bm;\n    for(int i=0;i<L;i++){\n        for(int j=i+1;j<L;j++){\n            if(dist[qs[i].se][qs[j].se]<=qs[j].fi-qs[i].fi){\n                bm.add_edge(i*2+1,j*2);\n            }\n        }\n    }\n    cout<<L-bm.matching()<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>L,N||M||L)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef Int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i+L].push_back( Edge( i+L, j, 0 ) );\n                    g[j].push_back( Edge( j, i+L, 0 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        bipartiteMatching( g, L, edges );\n        int answer = L - edges.size();\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BipartiteMatching {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\tvector<int> used;\n\tBipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\trep(i, 0, n)match[i] = -1;\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\trep(i, 0, n)used[i] = false;\n\t\t\t\tif (augment(v))cnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\tbool augment(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tBipartiteMatching bm(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tbm.addEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - bm.maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 10000\n#define MAX_N 1001\nusing namespace std;\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n  return max_flow(s,t);\n}\n\n\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<l;i++)G[i].clear();\n    \n    if(!n&&!m&&!l)break;\n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    \n  memset(can,0,sizeof(can));\n  \n  for(int i=0;i<l;i++)\n    for(int j=0;j<l;j++)\n      if(i!=j&&tl[idx[i]]+g[idx[i]][idx[j]]<=tl[idx[j]])can[i][j]=1;\n  cout <<l-Biparite_Matching(l,l)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cstring>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++(i))\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++(i))\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nvector<int> vv[2010];\nint match[2010];\nbool used[2010];\n\n\nbool matchdfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0;i < vv[v].size();i++)\n\t{\n\t\tint u = vv[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w))\n\t\t{\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint two_matching_max(int l)\n{\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l)\n\t{\n\t\tif(match[v] < 0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint cou = 0;\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l)\n\t{\n\t\tif(cou == 2)break;cou++;\n\n\t\tREP(i,2010)vv[i].clear();\n\t\tint dist[n+1][n+1] = {};\n\t\tREP(i,n+1)REP(j,n+1)\n\t\t{\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse dist[i][j] = 5e8;\n\t\t}\n\t\t\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\t\t\n\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t{\n\t\t\tdist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j]);\n\t\t}\n\t\t\t\t\n\t\tvector<pair<int,int> > v(l);\n\t\t\n\t\tREP(i,l)\n\t\t{\n\t\t\tint p,t;\n\t\t\tcin >> p >> t;\n\t\t\tv[i] = MP(t,p);\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tREP(i,l)rep(j,i,l)\n\t\t{\n\t\t\t\n\t\t\tif(i == j)continue;\n\t\t\tif(v[j].FI - v[i].FI >= dist[v[j].SE][v[i].SE])\n\t\t\t{\n\t\t\t\tvv[i].PB(l+j);\n\t\t\t\tvv[l+j].PB(i);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tint ret =  l - two_matching_max(2*l) ;\n\t\tcout << ret << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass MaxFlow{\n  typedef long long ll;\n  \n  struct edge{\n    int to;\n    ll cap;\n    int rev;\n    edge(){}\n    edge(int to, ll cap, int rev) : to(to), cap(cap), rev(rev){}\n  };\n  \n  std::vector<std::vector<edge> > G;\n  std::vector<int> level;\n  std::vector<int> iter;\n\n  void bfs(int s){\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n    \n  ll dfs(int v, int t, ll f){\n    if(v == t) return f;\n    \n    for(int &i = iter[v]; i < (int)G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] > level[v]){\n        ll d = dfs(e.to, t, std::min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \npublic:\n  MaxFlow(int V) :\n    G(std::vector<std::vector<edge> >(V)),\n    level(std::vector<int>(V)),\n    iter (std::vector<int>(V)) { }\n  \n  void add_edge(int from, int to, ll cap){\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n  }\n\n  ll solve(int s, int t){\n    ll res = 0, f;\n    for(;;){\n      bfs(s);\n      if(level[t] < 0) break;\n      std::fill(iter.begin(), iter.end(), 0);\n      while((f = dfs(s, t, LONG_LONG_MAX)) > 0) res += f;\n    }\n    return res;\n  }\n};\n\n\n\nint main(){\n\n  int n, m, l;\n  const int inf = 1000 * 1000 * 1000 + 7;\n  \n  while (cin >> n >> m >> l && n + m + l){\n    vector<vector<int> > adj(n, vector<int>(n, inf));\n    REP(i, m){\n      int a, b, c;\n      cin >> a >> b >> c;\n      assert(a < n && b < n) ;\n      adj[a][b] = c;\n      adj[b][a] = c;\n    }\n\n    REP(k, n) REP(i, n) REP(j, n){\n      adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);\n    }\n    int s = 2 * l;\n    int t = s + 1;\n    int V = t + 1;\n    MaxFlow mf(V);\n    vector<int> p(l), time(l);\n    \n     REP(i, l) cin >> p[i] >> time[i];\n    \n    REP(i, l) REP(j, l) if (p[i] != p[j]){\n      if (time[i] + adj[p[i]][p[j]] <= time[j]){\n        mf.add_edge(i, j + l, 1);\n      }\n    }\n    REP(i, l){\n      mf.add_edge(s, i, 1);\n      mf.add_edge(i + l, t, 1);\n    }\n    cout << l - mf.solve(s, t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2251: Merry Christmas\n * ?¢?????????????????????????????????????????????????????????????????????????????????¨???????????¶??????????±?????°???????????°???????????????????????????????\n * ?±????????????????+????????????\n * ??????????????¨Floyd?±????????????´??????????????\\??????????????¶??´???????¶????????????????????????\\??????????????????????????\\???????????????????????¬???????????????????????°-?????§?????????2??????????±????\n */\n\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nvector<int> e[1010];\nbool vis[1010];\nint rec[1010];\nint n1;\n\nint n, m;\nint d[110][110];\n\nint p[1010], t[1010];\n\nbool Dfs(int u) {\n  for (vector<int>::iterator it = e[u].begin(); it != e[u].end(); ++it) {\n    int v = *it;\n    if (!vis[v]) {\n      vis[v] = true;\n      if (rec[v] == -1 || Dfs(rec[v])) {\n        rec[v] = u;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint Hungary() {\n  int ans = 0;\n  memset(rec, -1, sizeof(rec));\n  for (int i = 0; i < n1; ++i) {\n    memset(vis, 0, sizeof(vis));\n    if (Dfs(i)) ++ans;\n  }\n  return ans;\n}\n\nvoid Floyd() {\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n//  freopen(\"/Users/yogy/acm-challenge-workbook/db.in\", \"r\", stdin);\n  while (scanf(\"%d%d%d\", &n, &m, &n1) != EOF && n) {\n    memset(d, 0x3f, sizeof(d));\n    for (int i = 0; i < n; ++i) d[i][i] = 0;\n    for (int i = 0; i < m; ++i) {\n      int u, v, c;\n      scanf(\"%d%d%d\", &u, &v, &c);\n      d[u][v] = d[v][u] = c;\n    }\n    Floyd();\n    for (int i = 0; i < n1; ++i) {\n      scanf(\"%d%d\", &p[i], &t[i]);\n      e[i].clear();\n    }\n    for (int i = 0; i < n1; ++i) {\n      for (int j = 0; j < n1; ++j) {\n        if (i == j) continue;\n        if (t[i] + d[p[i]][p[j]] <= t[j]) {\n          e[i].push_back(j);\n        }\n      }\n    }\n    printf(\"%d\\n\", n1 - Hungary());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\ninline int min_int(int x, int y){\n  return (x<y)? x:y;\n}\nusing namespace std;\nclass Req{\npublic:\n  char house;\n  int time;\n};\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\nint dist[max_n][max_n];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\nint req_graph[max_l][max_l];\nint num_child[max_l];//各リクエストxの子の数\nint parent[max_l]; //被覆パスにおけるリクエストxの親\nint till[max_l];\nbool visited[max_l];\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j,h1,h2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++) for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n  } \n}\n\nint find(int i, bool root){\n  int child, x, found;\n  //親権の空いている子を探す\n  visited[i] = true;  \n  if(till[i] < num_child[i]){    \n    while((++(till[i])) < num_child[i]){\n      child = req_graph[i][till[i]];\n      if(parent[child] >= 0) continue;\n      parent[child] = i; //childを自分の子とする\n      return child;\n    }\n  }\n  //他の親から親権を譲ってもらえる子を探す  \n  for(int j = 0;j < num_child[i]; j++){\n    child = req_graph[i][j];\n    x = parent[child]; //x: childのパス上の親\n    if(visited[x]) continue; //閉路検出\n    found = find(x,false); //xからchildの親権をもらう交渉\n    if(found < 0) continue;\n    parent[child] = i; //childの親権獲得\n    return child;\n  }\n  return -1;\n}\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  memset(till,-1,l*sizeof(int));\n  memset(parent,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    memset(visited,0,l*sizeof(bool));\n    find(i,true);\n  }\n  for(int i=0;i<l;i++) if(parent[i]<0) num++;\n  return num;\n}\n\n//プレゼント配送に必要なサンタの数を出力する関数\nint santas(){\n  int u,v,d,i;\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  return res;\n}\n\n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;    \n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n#define MAX_V 110\nint n;\nvector<int> g[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvoid init(int n_) {\n\tn = n_;\n\trep(i, 0, n_)g[i].clear();\n}\nvoid addEdge(int u, int v) {\n\tg[u].emplace_back(v);\n\tg[v].emplace_back(u);\n}\nbool augment(int v) {\n\tused[v] = true;\n\tfor (int u : g[v]) {\n\t\tint w = match[u];\n\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatching() {\n\tint cnt = 0;\n\tfill(match, match + MAX_V, -1);\n\tfor (int v = 0; v < n; v++) {\n\t\tif (match[v] == -1) {\n\t\t\tfill(used, used + MAX_V, false);\n\t\t\tif (augment(v))cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tinit(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\taddEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<29;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = 0;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    if ( !D[i][k] || !D[k][j] ) continue;\n                    if ( !D[i][j] ) D[i][j] = D[i][k] + D[k][j];\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, j+L, 1 ) );\n                    g[j+L].push_back( Edge( j+L, i, 1 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        int answer = L - bipartiteMatching( g, L, edges );\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n#define MAX_V 2200\nint n;\nvector<int> g[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvoid init(int n_) {\n\tn = n_;\n\trep(i, 0, n_)g[i].clear();\n}\nvoid addEdge(int u, int v) {\n\tg[u].emplace_back(v);\n\tg[v].emplace_back(u);\n}\nbool augment(int v) {\n\tused[v] = true;\n\tfor (int u : g[v]) {\n\t\tint w = match[u];\n\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatching() {\n\tint cnt = 0;\n\tfill(match, match + MAX_V, -1);\n\tfor (int v = 0; v < n; v++) {\n\t\tif (match[v] == -1) {\n\t\t\tfill(used, used + MAX_V, false);\n\t\t\tif (augment(v))cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tinit(L + L);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\taddEdge(i, L + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto ans = L - maximumMatching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint search(vector<int>& psort,vector<int>& tsort,int nos,vector<int>& santanow,vector<int>& santatime,int dist[1000][1000],int pos,int max){\n\tpos++;\n\tif(max == pos){\n\t\treturn nos;\n\t}\n\n\tvector<int> avalable;\n\tfor(int i = 0; i < nos; i++){\n\t\tint temp = santatime[i]  + dist[psort[pos]][santanow[i]];\n\t\tif(temp <= tsort[pos]){\n\t\t\tavalable.push_back(i);\n\t\t}\n\t}\n\n\tif(avalable.empty()){\n\t\tsantanow.push_back(psort[pos]);\n\t\tsantatime.push_back(tsort[pos]);\n\t\tnos++;\n\t\tnos = search(psort,tsort,nos,santanow,santatime,dist,pos,max);\n\t}else{\n\t\tvector<int> noss;\n\t\tint min = nos + 10;\n\t\tfor(int i = 0; i < avalable.size(); i++){\n\t\t\tvector<int>::iterator itn = santanow.begin();\n\t\t\tvector<int>::iterator itt = santatime.begin();\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\titn++;\n\t\t\t\titt++;\n\t\t\t}\n\t\t\titt = santatime.erase(itt);\n\t\t\tsantatime.insert(itt,tsort[i]);\n\t\t\titn = santanow.erase(itn);\n\t\t\tsantanow.insert(itn,psort[i]);\n\t\t\tnoss.push_back(search(psort,tsort,nos,santanow,santatime,dist,pos,max));\n\t\t}\n\t\tfor(int i = 0; i < noss.size(); i++){\n\t\t\tif(min > noss[i]){\n\t\t\t\tmin = noss[i];\n\t\t\t}\n\t\t}\n\t\tnos = min;\n\t}\n\n\treturn nos;\n}\n\nint main(){\n\tint N,M,L;\n\tint u[1000],v[1000],d[1000],p[1000],t[1000];\n\tvector<int> numofsanta;\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\t\n\twhile(N != 0 || M != 0 || L != 0){\n\t\tint dist[1000][1000];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = 100000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> psort;\n\t\tvector<int> tsort; \n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d\",&u[i],&v[i],&d[i]);\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\n\t\t//Warshall-Floyd Algorithm\n\n    \tfor(int i = 0; i < N; i++){\n        \tfor(int j = 0; j < N; j++){\n            \tfor(int k = 0; k < N; k++){\n            \t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            \t}\n            }\n        }\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tvector<int>::iterator p_it = psort.begin();\n\t\t\tvector<int>::iterator t_it = tsort.begin();\t\t\t\t\n\t\t\tscanf(\"%d %d\",&p[i],&t[i]);\n\t\t\tif(i == 0){\n\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\ttsort.push_back(t[i]);\n\t\t\t}else{\n\t\t\t\tint siz = psort.size();\n\t\t\t\tfor(int j = 0; j < siz; j++){\n\t\t\t\t\tif(tsort[j] > t[i]){\n\t\t\t\t\t\tpsort.insert(p_it,p[i]);\n\t\t\t\t\t\ttsort.insert(t_it,t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == siz - 1){\n\t\t\t\t\t\tpsort.push_back(p[i]);\n\t\t\t\t\t\ttsort.push_back(t[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++p_it;\n\t\t\t\t\t\t++t_it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint nos = 1;\n\t\tvector<int> santanow;\n\t\tvector<int> santatime;\n\t\tsantanow.push_back(psort[0]);\n\t\tsantatime.push_back(tsort[0]);\n\t\tint max = psort.size();\n\t\tnos = search(psort,tsort,nos,santanow,santatime,dist,0,max);\n\n\t\tnumofsanta.push_back(nos);\n\t\tscanf(\"%d %d %d\",&N,&M,&L);\n\t}\n\n\tfor(int i = 0; i < numofsanta.size(); i++){\n\t\tprintf(\"%d\\n\",numofsanta[i]);\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1010;\nconst int oo = 1000000000;\nstruct edge\n{\n\tint v,next;\n}e[N * N];\n\nint head[N],cnt;\n\nvoid addedge(int u,int v)\n{\n\te[cnt].v = v;\n\te[cnt].next = head[u];\n\thead[u] = cnt ++;\n}\n\nint pre[N],visit[N];\nint f[N / 10][N / 10];\n\nint find(int u)\n{\n\tfor(int i = head[u]; i != -1; i = e[i].next)\n\t\tif(!visit[e[i].v]) {\n\t\t\tvisit[e[i].v] = 1;\n\t\t\tint tmp = pre[e[i].v];\n\t\t\tpre[e[i].v] = u;\n\t\t\tif(tmp == -1 || find(tmp)) return 1;\n\t\t\tpre[e[i].v] = tmp;\n\t\t}\n\treturn 0;\n}\n\nstruct point\n{\n\tint x,t;\n\tvoid read() {\n\t\tscanf(\"%d%d\",&x,&t);\n\t}\n\tfriend bool operator < (const point &p,const point &q) {\n\t\treturn p.t < q.t;\n\t}\n}a[N];\n\nint main()\n{\n\tint n,m,r;\n\tint x,y,z;\n\twhile(scanf(\"%d%d%d\",&n,&m,&r)) {\n\t\tif(!n && !m && !r) break;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tfor(int j = 0; j < n; j ++)\n\t\t\t\tf[i][j] = oo;\n\t\t\tf[i][i] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tmemset(head,-1,sizeof(head));\n\t\twhile(m --) {\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tf[x][y] = f[y][x] = min(z,f[x][y]);\n\t\t}\n\t\tfor(int k = 0; k < n; k ++)\n\t\t\tfor(int i = 0; i < n; i ++)\n\t\t\t\tfor(int j = 0; j < n; j ++)\n\t\t\t\t\tf[i][j] = min(f[i][j],f[i][k] + f[k][j]);\n\t\tfor(int i = 0; i < r; i ++)\n\t\t\ta[i].read();\n\t\tsort(a,a + r);\n\t\tmemset(pre,-1,sizeof(pre));\n\t\tint ans = r;\n\t\tfor(int i = 0; i < r; i ++)\n\t\t\tfor(int j = i + 1; j < r; j ++)\n\t\t\t\tif(f[a[i].x][a[j].x] + a[i].t <= a[j].t)\n\t\t\t\t\taddedge(i,j);\n\t\tfor(int i = 0; i < r; i ++) {\n\t\t\tmemset(visit,0,sizeof(visit));\n\t\t\tans -= find(i);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n,m,l;\nint u[1002],v[1002],d[1002];\nint p[1002],t[1002];\nint dist[102][102];\nint a;\nvector<P> b[102];\n\nvoid init(){\n\trep(i,102)rep(j,102)dist[i][j] = INF;\n\trep(i,102)dist[i][i] = 0;\n\ta = 0;\n\trep(i,102)b[i].clear();\n}\n\nint main(){\n\twhile(1){\n\t\tinit();\n\t\t\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n == 0)break;\n\t\trep(i,m)scanf(\"%d%d%d\",&u[i],&v[i],&d[i]);\n\t\trep(i,l)scanf(\"%d%d\",&p[i],&t[i]);\n\t\t\n\t\trep(i,m){\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)dist[i][j] = min ( dist[i][j] , dist[i][k] + dist[k][j] );\n\t\t\n\t\tvector<P> queries;\n\t\trep(i,l)queries.pb( P ( t[i] , p[i] ) );\n\t\tsor(queries);\n\t\t\n\t\trep(i,queries.size()){\n\t\t\tP q = queries[i];\n\t\t\tint id_ = 0 , id[2];\n\t\t\trep(j,a){\n\t\t\t\trep(k,b[j].size()){\n\t\t\t\t\tP r = b[j][k];\n\t\t\t\t\tif(dist[q.sc][r.sc] <= q.fr-r.fr){\n\t\t\t\t\t\tid[id_++] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(id_ >= 2)break;\n\t\t\t}\n\t\t\tif(id_ == 0){\n\t\t\t\tb[a].pb(q);\n\t\t\t\ta ++;\n\t\t\t}\n\t\t\telse if(id_ == 1){\n\t\t\t\tb[id[0]].clear();\n\t\t\t\tb[id[0]].pb(q);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[id[0]].insert(b[id[0]].end(),b[id[1]].begin(),b[id[1]].end());\n\t\t\t\tb[id[1]].clear();\n\t\t\t\tb[id[1]].pb(q);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(i + 1, j + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\n\nconst int MAX_N = 102;\nconst int MAX_L = 1005;\nconst int MAX_V = MAX_N << 1;\n\n\nstruct Request\n{\n\tint p;\n\tint t;\n\tbool operator < (const Request & y)const\n\t{\n\t\treturn t < y.t;\n\t}\n}r[MAX_L];\n\nint G[MAX_V][MAX_V];\nint deg[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v);\nbool dfs(const int & v);\nint bipartite_matching(const int V);\n\nint MAT[MAX_N][MAX_N];\nint _min(const int & a, int b);\nvoid warshall_floyd(int n);\n\n\nint main()\n{\n\tint N, M, L, u, v, d;\n\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &L);\n\t\tif (!N)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tmemset(deg, 0, sizeof(deg));\n\t\tmemset(MAT, 8, sizeof(MAT));\n\n\t\twhile (M--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tMAT[u][v] = d;\n\t\t\tMAT[v][u] = d;\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tMAT[i][i] = 0;\n\t\t}\n\t\twarshall_floyd(N);\n\t\t\n\t\tfor (int i = 0; i < L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &r[i].p, &r[i].t);\n\t\t}\n\t\tsort(r, r + L);\n\n\t\tfor (int i = 1; i < L; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (r[i].t - r[j].t >= MAT[r[i].p][r[j].p])\n\t\t\t\t{\n\t\t\t\t\tadd_edge(j, i + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", L - bipartite_matching(L << 1));\n\t}\n\t\n\treturn 0;\n}\n\nvoid add_edge(int u, int v)\n{\n\tG[u][deg[u]++] = v;\n\tG[v][deg[v]++] = u;\n}\n\nbool dfs(const int & v)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < deg[v]; i++)\n\t{\n\t\tconst int & u = G[v][i];\n\t\tconst int & w = match[u];\n\n\t\tif (w == -1 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(const int V)\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++)\n\t{\n\t\tif (match[v] == -1)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tres += dfs(v);\n\t\t}\n\t}\n\treturn res;\n}\n\nint _min(const int & a, int b)\n{\n\treturn a < b ? a : b;\n}\n\nvoid warshall_floyd(int n)\n{\n\tfor (int k = 0; k < n; k++)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tMAT[i][j] = _min(MAT[i][j], MAT[i][k] + MAT[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2251>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct edge {\n    int to; // 行き先\n    int cap; // 容量\n    int rev; // 逆辺\n    edge() {}\n    edge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {}\n};\n\nvector<vector<edge>> G; // グラフの隣接リスト表現\nvector<int> used; // DFSですでに調べたらフラグ\n\n// fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back(edge(to, cap, (int)G[to].size()));\n    G[to].push_back(edge(from, 0, (int)G[from].size() - 1));\n}\n\n// 増加パスをDFSで探す\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\nint N,M,L;\nll solve(){\n    ll res = 0;\n    vector<vector<ll>> dist(N,vector<ll>(N,LINF));\n    for(int i = 0; i < N;i++) dist[i][i] = 0;\n    for(int i = 0; i < M;i++){\n        ll u,v,d; cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = min(dist[u][v],d);\n    }\n    for(int i = 0; i < N;i++) for(int j = 0; j < N;j++) for(int k = 0; k < N;k++)\n        dist[j][k] = min(dist[j][k],dist[j][i]+dist[i][k]);\n    \n    vector<pii> pt(L);\n    for(auto& in:pt) cin >> in.first >> in.second;\n    sort(pt.begin(),pt.end(),[](const pii& c1,const pii &c2){ return c1.second > c2.second;});\n    \n    int S = L+L,T = S + 1;\n    G.clear(); G.resize(L+L+2);\n    used.clear(); used.resize(L+L+2);\n    for(int i = 0; i < L;i++){\n        for(int j = 0; j < L;j++){\n            if(i == j) continue;\n            if(pt[i].second > pt[j].second) continue;\n            int u = pt[i].first,v = pt[j].first;\n            if(dist[u][v] <= pt[j].second - pt[i].second){\n                add_edge(i,L+j,1);\n            }\n        }\n    }\n    for(int i = 0; i < L;i++){\n        add_edge(S,i,1);\n        add_edge(i+L,T,1);\n    }\n    res = L - max_flow(S,T);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N >> M >> L,N){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define\tMAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(cin>>N>>M>>L,N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w; cin>>u>>v>>w;\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)cin>>p[i]>>t[i];\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,l;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[3005];\nbool used[3005];\nint E[105][105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nint p[1005],t[1005];\nint main(){\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) return 0;\n\t\trep(i,105) rep(j,105){\n\t\t\tE[i][j] = INF;\n\t\t\tif(i==j) E[i][j] = 0;\n\t\t}\n\t\trep(i,1005){\n\t\t\tG[i].clear(); used[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tE[u][v] = E[v][u] = d;\n\t\t}\n\t\tfor(int i=0;i<l;i++) cin >> p[i] >> t[i];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tE[j][k] = min(E[j][k],E[j][i]+E[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(t[i]+E[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(i,j+1005,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) add_edge(2301,i,1);\n\t\tfor(int i=0;i<n;i++) add_edge(i+1005,2302,1);\n\t\tcout << l-max_flow(2301,2302) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Edge(int src, int dst) :\n    src(src), dst(dst) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\nint adj[100][100];\nint p[1000],t[1000];\n\nint main() {\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l) {\n    REP(i,n)REP(j,n)adj[i][j]=INF;\n    REP(i,n)adj[i][i]=0;\n    REP(i,m) {\n      int u,v,d;\n      cin>>u>>v>>d;\n      adj[u][v] = min(adj[u][v],d);\n      adj[v][u] = adj[u][v];\n    }\n    REP(k,n)REP(i,n)REP(j,n) {\n      adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);\n    }\n    //REP(i,n) {REP(j,n)cout<<adj[i][j]<<\" \";cout<<endl;}\n    Graph g(2*l);\n    REP(i,l) {\n      cin>>p[i]>>t[i];\n    }\n    REP(i,l) {\n      REP(j,l) {\n        if (i==j) continue;\n        if (adj[p[i]][p[j]] <= t[j]-t[i]) {\n          g[i].push_back(Edge(i,l+j));\n          g[l+j].push_back(Edge(l+j,i));\n        }\n      }\n    }\n    Edges e;\n    cout << l - bipartiteMatching(g, l, e) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\n#define INF 100000000\n\nusing namespace std;\n\nint V,match[202];\nbool used[202];\nvector<int>G[202];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  fill(match,match+202,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+202,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main(void){\n\n  int n,m,l,u,v,d,graph[101][101],p[1001],t[1001];\n\n  while(cin >> n >> m >> l,n|m|l){  \n\n    for(int i=0;i<2*n;i++)G[i].clear();\n\n    fill(graph[0],graph[101],INF);\n    for(int i=0;i<101;i++)graph[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      graph[u][v]=graph[v][u]=d;\n    }\n    \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[p[i]][p[j]]+t[i]<=t[j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tMinimumCostFlow mcf(L + L + 2);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tmcf.addArc(i, L + j, 1, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 0, L) {\n\t\t\tmcf.addArc(source, i, 1, 0);\n\t\t\tmcf.addArc(i, sink, 1, 0);\n\t\t\tmcf.addArc(L + i, sink, 1, 0);\n\t\t}\n\t\tauto ans = L + mcf.minimumCostFlow(source, sink, L);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nstruct request{int num, time;}re[2009];\nvector<int> g[2009];\nint match[2009];\nbool used[2009];\nint n, m, l;\nint INF=99999999;\nint d[2009][2009];\nvoid add_edge(int u, int v)\n{\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0; i<g[v].size(); i++)\n    {\n        int u=g[v][i], w=match[u];\n        if(w<0 || !used[w] && dfs(w))\n        {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\nint bipartite_matching()\n{\n    int res=0;\n    memset(match, -1, sizeof(match));\n    for(int v=0; v<n; v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used, 0, sizeof(used));\n            if(dfs(v))\n                res++;\n        }\n    }\n    return res;\n}\nvoid Floyd()\n{\n    for(int k=0; k<n; k++)\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                d[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n}\nint main()\n{\n    int f, t, dis;\n    while(~scanf(\"%d%d%d\", &n, &m, &l))\n    {\n        if(!(n+m+l)) break;\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                d[i][j]=INF;\n        for(int i=0; i<n; i++)\n            g[i].clear();\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%d\", &f, &t, &dis);\n            d[f][t]=dis;\n            d[t][f]=dis;\n        }\n        for(int i=0; i<n; i++)\n        {\n            d[i][i]=0;\n        }\n        Floyd();\n        for(int i=0; i<l; i++)\n        {\n            scanf(\"%d%d\", &re[i].num, &re[i].time);\n        }\n        for(int i=0; i<l; i++)\n        {\n            for(int j=0; j<l; j++)\n            {\n                if(i==j) continue;\n                if(d[re[i].num][re[j].num]<=re[j].time-re[i].time)\n                {\n                    add_edge(i, j+n);\n                }\n            }\n        }\n        printf(\"%d\\n\", l-bipartite_matching());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\nconst int maxn=110;\n\nvector <int > g[maxn];\nint from[maxn],tot;\nbool use[maxn];\nint N,M,L;\nint dis[maxn][maxn],que[maxn][2];\n\nbool match(int x){\n    for(int i=0;i<g[x].size();i++)\n    if(!use[g[x][i]]){\n        use[g[x][i]]=true;\n        if(from[g[x][i]]==-1||match(from[g[x][i]])){\n            from[g[x][i]]=x;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary(){\n    tot=0;\n    memset(from,255,sizeof from);\n    for(int i=1;i<=L;i++){\n        memset(use,0,sizeof(use));\n        if(match(i))\n            tot++;\n    }\n    return tot;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d\",&N,&M,&L)){\n        if(N==0&&M==0&&L==0) break;\n\n        for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n            if(i==j) dis[i][j]=0;\n            else dis[i][j]=0x3fffffff;\n\n        for(int i=1;i<=M;i++){\n            int t1,t2,t3;\n            scanf(\"%d%d%d\",&t1,&t2,&t3);\n            dis[t1][t2]=dis[t2][t1]=min(dis[t1][t2],t3);\n        }\n\n        for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n        for(int k=0;k<N;k++){\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n        }\n\n        for(int i=1;i<=L;i++) g[i].clear();\n        for(int i=1;i<=L;i++)\n            scanf(\"%d%d\",&que[i][0],&que[i][1]);\n\n        for(int i=1;i<=L;i++)\n        for(int j=1;j<=L;j++){\n            if(i!=j){\n                if(dis[que[i][0]][que[j][0]]<=que[j][1]-que[i][1])\n                    g[i].push_back(j);\n            }\n        }\n\n        printf(\"%d\\n\",L-hungary());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100;\nconst int L = 1000;\nconst int INF = 1e+8 + 10;\nconst int MAX_V = L * 2 + 2;\n\nstruct data{\n  int p, t;\n  data(int p=0, int t=0):p(p),t(t){}\n  bool operator < (const data &d) const {\n    return t < d.t;\n  }\n};\n\nstruct edge{\n  int to, cap, rev;\n  edge(int t=0, int c=0, int r=0):to(t),cap(c),rev(r){}\n};\n  \nvoid add_edge(const int &from, const int &to, const int &cap, vector<edge> G[MAX_V]){\n  G[from].push_back(edge(to, cap, G[to].size()));\n  G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n \nint dfs_f(int v, int t, int f, vector<edge> G[MAX_V], bool used[MAX_V]){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs_f(e.to, t, min(f, e.cap), G, used);\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s, int t, vector<edge> G[MAX_V]){\n  int flow = 0;\n  while(1){\n    bool used[MAX_V];\n    fill(used, used+MAX_V, false);\n    int f = dfs_f(s, t, INF, G, used);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\n\n\nint n, m, l, G[N][N];\nvector<data> v;\n\nint solve(){\n  vector<edge> fG[MAX_V];\n\n  for(int i=0;i<n;i++) G[i][i] = 0;\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n      }\n    }\n  }\n\n  sort(v.begin(), v.end());\n  for(int i=0;i<l;i++){\n    add_edge(l*2, i, 1, fG);\n    add_edge(l+i, l*2+1, 1, fG);\n    //add_edge(i, l+i, 1, fG);\n    for(int j=i+1;j<l;j++){\n      if(G[v[i].p][v[j].p] < INF && v[i].t + G[v[i].p][v[j].p] <= v[j].t) {\n        add_edge(j, l+i, 1, fG);\n      }\n    }\n  }\n\n  // ?????§???????????? = V - ????°?????????????\n  return l - max_flow(l*2, l*2+1, fG);\n}\n\nint main(){\n  int x, y, d;\n  while(cin >> n >> m >> l && (n|m|l)){\n    fill(G[0], G[n], INF);\n    v.clear();\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d;\n      G[x][y] = min(G[x][y], d);\n      G[y][x] = min(G[y][x], d);\n    }\n    for(int i=0;i<l;i++){\n      cin >> x >> y;\n      v.push_back(data(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint n, m, l;\nint d[1010][1010];\nbool used[1010];\nint match[1010]; \nvector<int> G[1010];\nvoid addedge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u); \n}\nstruct node{\n\tint p, t;\n}a[1010];\nbool cmp(node a1, node b1){\n\treturn a1.t < b1.t;\n}\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof match);\n\tfor(int v = 0; v < 2*l; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof used);\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(scanf(\"%d%d%d\", &n, &m, &l) != EOF){\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\tint u, v, c;\n\t\tmemset(d, 0x3f, sizeof d);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d\", &u, &v, &c);\n\t\t\td[u][v] = d[v][u] = c;\n\t\t}\n\t\tfor(int i =0; i < n; i++) d[i][i] = 0;\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tscanf(\"%d%d\", &a[i].p, &a[i].t);\n\t\t}\n\t\tfor(int i = 0; i < 2*l; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tsort(a, a+l, cmp);\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tfor(int j = i+1; j < l; j++){\n\t\t\t\tif(d[a[i].p][a[j].p] <= a[j].t - a[i].t){\n\t\t\t\t\taddedge(i, j+l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = l-bipartite_matching();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<string.h>\n#include<algorithm>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if(n == 0) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nconst int INF = 1e9;\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for(int v = 0; v < n; ++v){\n            if (match[v] < 0) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u: g[v]) {\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint N,M,L;\nint mat[110][110];\npair<int,int> node[1010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(cin >> N >> M >> L && N){\n        rep(i,N)rep(j,N) mat[i][j] = (i == j ? 0 : INF);\n        rep(i,M){\n            int u,v,d;\n            cin >> u >> v >> d;\n            mat[u][v] = mat[v][u] = d;\n        }\n        rep(k,N)rep(i,N)rep(j,N) mat[i][j] = min(mat[i][j], mat[i][k]+mat[k][j]);\n        rep(i,L) cin >> node[i].second >> node[i].first;\n        sort(node, node+L);\n\n        bipartite_matching bm(L*2);\n\n        rep(i,L)rep(j,i){\n            int dt = node[i].first - node[j].first;\n            int dist = mat[node[i].second][node[j].second];\n            if(dt >= dist){\n                bm.add_edge(j, i+L);\n            }\n        }\n\n        int f = bm.maximum_matching();\n        cout << L-f << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <cstdarg>\n#include <sys/time.h>\n#include <fstream>\n//#include \"cout.h\"\n\nusing namespace std;\n\n#define SZ(x) ((int)x.size())\n#define MSET(x,a) memset(x, a, (int)sizeof(x))\n#define PB push_back\n#define VI vector < int >\n#define PII pair < int, int >\n#define LL long long\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(), (v).end()\n#define FIT(it,v) for (typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define OUT(A) cout << #A << \" = \"<< (A) << endl\n#define OUT2(A, B) cout << \"(\" << #A << \", \" << #B << \") = (\" << (A) << \", \"<< (B) << \")\" << endl\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } \ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } \n\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n\n\n\n\n    const int MAX_V = 2010;\n    \n    int V; // 左の頂点数。忘れずに設定すること。\n    // ちなみに、Vは左右合わせた全部の頂点数でも問題ない。（左が終わった後に右からのをチェックしても、マッチ数は絶対増えない）\n    \n    \n    VI G[MAX_V]; // ちゃんとGもケースごとに全部clear。\n    int match[MAX_V];\n    bool used[MAX_V];\n    \n    void add_edge(int u, int v){\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n    \n    bool dfs(int v){\n        used[v] = true;\n        REP(i, SZ(G[v])){\n            int u = G[v][i], w = match[u];\n            if(w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    int bipartite_matching(){\n        int res = 0;\n        MSET(match, -1);\n        REP(v, V){\n            if(match[v] < 0){\n                MSET(used, 0);\n                if(dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n    \n    \n    \nint INF = (1<<29);\n\nint n, m, l;\nint g[110][110];\nint p[1010], t[1010];\n\nvoid init() {\n}\n\nvoid input() {\n\tREP(i, 110) REP(j, 110) g[i][j] = INF;\n\tREP(i, n) g[i][i] = 0;\n\tREP(i, m){\n\t\tint u, v, d;\n\t\tcin >> u >> v >> d;\n\t\tg[u][v] = d, g[v][u] = d;\n\t}\n\tREP(k, n) REP(i, n) REP(j, n) chmin(g[i][j], g[i][k]+g[k][j]);\n\tREP(i, l) cin >> p[i] >> t[i];\n}\n\nvoid solve() {\n\tV = l*2;\n\tREP(i, V) G[i].clear();\n\tREP(i, l) REP(j, l) if(i != j){\n\t\tif(t[i] + g[p[i]][p[j]] <= t[j]) add_edge(i, j+l);\n\t\tif(t[j] + g[p[j]][p[i]] <= t[i]) add_edge(j, i+l);\n\t}\n\tcout << l - bipartite_matching() + 1<< endl;\n}\n\nint main() {\n\tinit();\n\twhile(cin >> n >> m >> l){\n\t\tif(n == 0) break;\n\t\tinput();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[123][123];\nint n, m, l;\npair <int, int> work[1234];\nvector<int> G[4567];\nint result[4567], vis[4567];\n\nbool dfs(int u)\n{\n    vis[u] = 1;\n    for(int i = 0; i < G[u].size(); i++)\n    {\n        int t = G[u][i];\n        if(result[t] == -1 || !vis[result[t]] && dfs(result[t]))\n        {\n            result[t] = u;\n            result[u] = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(result, -1, sizeof result);\n    for(int i = 0; i < l; i++)\n    {\n        memset(vis, 0, sizeof vis);\n        res += dfs(i);\n    }\n    return res;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d\", &n, &m, &l), n + m + l)\n    {\n        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) dp[i][j] = i == j ? 0 : 1000000000;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y, u;\n            scanf(\"%d%d%d\", &x, &y, &u);\n            dp[x][y] = dp[y][x] = u;\n        }\n        for(int i = 0; i < l; i++)\n        {\n            int u, v;\n            scanf(\"%d%d\", &u, &v);\n            work[i] = make_pair(u, v);\n        }\n        for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n        for(int i = 0; i < l; i++)\n        {\n            for(int j = 0; j < l; j++)\n            {\n                if(i == j) continue;\n                if(dp[work[i].first][work[j].first] + work[i].second <= work[j].second)\n                {\n                    G[i].push_back(j + l);\n                }\n            }\n        }\n        printf(\"%d\\n\", l - hungary());\n        for(int i = 0; i < l; i++) G[i].clear();\n    }\n    return 0;\n}\n\n/*\n\n77 0 292\n4 1934\n29 2124\n1 1825\n68 1511\n20 1672\n46 1724\n46 2124\n66 2179\n48 1426\n62 1609\n7 1795\n4 2028\n52 2026\n32 1151\n20 1609\n32 1725\n1 1040\n52 1810\n22 1151\n30 1326\n18 2179\n65 2162\n50 1673\n29 1725\n15 1205\n59 2026\n41 2200\n1 2026\n46 2163\n49 1489\n53 1489\n32 1426\n0 1156\n59 1934\n13 1673\n18 2026\n20 1825\n1 1672\n24 2124\n48 2124\n66 2162\n39 1725\n37 1933\n52 1603\n32 1695\n12 2178\n69 1006\n74 1489\n40 2026\n35 1841\n34 2028\n0 2241\n24 1671\n21 1673\n25 1279\n57 1204\n56 1603\n6 2124\n60 2163\n1 1489\n10 1212\n66 2178\n63 1243\n71 2178\n23 1671\n50 1560\n10 1825\n8 2179\n69 1810\n40 1825\n6 2178\n22 1724\n75 1796\n58 983\n19 2124\n59 2179\n62 2026\n18 1279\n61 1695\n44 1153\n52 1795\n9 1796\n74 2179\n26 2026\n45 1561\n20 1151\n48 1279\n34 1724\n50 1609\n35 2178\n40 1673\n56 1204\n70 1672\n4 1695\n63 934\n45 1810\n25 1673\n61 1725\n46 1825\n31 2179\n64 2026\n32 1489\n75 1673\n49 2178\n36 1426\n25 969\n75 2241\n21 2200\n44 1040\n26 2124\n62 1841\n34 1795\n9 1489\n13 2178\n43 1489\n25 1609\n3 1695\n64 1811\n15 1212\n30 1795\n28 2026\n58 1243\n60 2162\n38 2124\n23 2162\n18 1795\n54 934\n48 1609\n16 1326\n27 1810\n64 1511\n12 2179\n2 1841\n45 1560\n10 1489\n60 1796\n65 1796\n49 1326\n35 1561\n11 1603\n72 1212\n20 1426\n25 1810\n45 2026\n56 1671\n64 1151\n69 2026\n4 1810\n75 2124\n22 1489\n65 1811\n55 1672\n51 2241\n1 2124\n53 1671\n36 1934\n31 2026\n76 934\n31 1695\n69 1795\n24 1934\n55 2241\n41 2241\n14 1933\n34 2179\n67 2241\n12 1825\n8 1672\n13 2026\n60 1156\n7 1673\n5 1489\n69 1561\n29 1561\n53 2124\n22 1934\n25 1489\n46 2179\n46 1550\n38 2179\n28 1796\n13 2179\n67 1489\n54 2241\n40 1724\n18 1368\n48 2179\n62 837\n57 2124\n69 2028\n22 1152\n64 2028\n46 2026\n47 1489\n56 1933\n70 1795\n74 2124\n10 2124\n57 1205\n58 1006\n13 2124\n36 2162\n34 1695\n66 1671\n8 1841\n5 1279\n3 1151\n11 2179\n1 2178\n48 1006\n43 1609\n47 1603\n27 1205\n47 1326\n55 1673\n35 2162\n24 2179\n18 2241\n26 1151\n54 1796\n35 2124\n1 1673\n39 2028\n64 2179\n14 1243\n18 1673\n46 1810\n25 2162\n38 1243\n26 1810\n5 2178\n14 1795\n58 1673\n61 1724\n73 1825\n12 1795\n18 1796\n38 1673\n15 1489\n47 1825\n37 2026\n67 1212\n39 1724\n25 1610\n2 2241\n72 992\n10 903\n27 2124\n67 2026\n52 1560\n60 1671\n26 2163\n41 1156\n25 1151\n18 1672\n48 1560\n29 1560\n6 2162\n9 1279\n28 1672\n4 1426\n45 1673\n52 1811\n26 1725\n18 1671\n17 1795\n69 1811\n22 1156\n17 2124\n2 1511\n30 1695\n10 1213\n59 1933\n35 1212\n74 2028\n48 1825\n2 1561\n53 2241\n18 1933\n50 1054\n74 1795\n63 1673\n7 1426\n32 1054\n8 969\n68 1934\n55 1841\n72 2179\n51 1279\n11 1560\n23 2178\n42 2241\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MAX (numeric_limits<int>::max()-1)/2\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(scanf(\"%d%d%d\",&N,&M,&L),N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=MAX;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)scanf(\"%d%d\",&p[i],&t[i]);\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    printf(\"%d\\n\",num);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match;\n  vector< bool > used;\n\n  Bipartite_Matching(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v)\n  {\n    used[v] = true;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(w == -1 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    match.assign(graph.size(), -1);\n    for(int i = 0; i < graph.size(); i++) {\n      if(match[i] == -1) {\n        used.assign(graph.size(), false);\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\nint main()\n{\n  int N, M, L;\n  int cost[100][100];\n  int p[1000], t[1000];\n\n  while(scanf(\"%d %d %d\", &N, &M, &L), L) {\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) cost[i][j] = INF;\n      cost[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++) {\n      int u, v, d;\n      scanf(\"%d %d %d\", &u, &v, &d);\n      cost[u][v] = cost[v][u] = d;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &p[i], &t[i]);\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n\n    Bipartite_Matching flow(L);\n    for(int i = 0; i < L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(i == j) continue;\n        if(t[j] - t[i] >= cost[p[i]][p[j]]) {\n          flow.add_edge(i, j);\n        }\n      }\n    }\n    printf(\"%d\\n\", L - flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=2102;\nconst int D_v_size=2102;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint g[110][110];\nint x[1100];\nint y[1100];\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]=999999999;\n\t\tfor(int i=0;i<a;i++)g[i][i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\tfor(int i=0;i<D_MAX_V;i++){\n\t\t\tD_G[i].clear();\n\t\t\tD_iter[i]=D_level[i]=0;\n\t\t}\n\t\tfor(int i=0;i<c;i++)scanf(\"%d%d\",x+i,y+i);\n\t\tint s=c*2;\n\t\tint t=c*2+1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tadd_edge(s,i,1);\n\t\t\tadd_edge(i+c,t,1);\n\t\t}\n\t\tfor(int i=0;i<c;i++)for(int j=0;j<c;j++){\n\t\t\tif(y[i]>=y[j])continue;\n\t\t\tif(y[i]+g[x[i]][x[j]]<=y[j]){\n\t\t\t\tadd_edge(i,j+c,1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",c-max_flow(s,t));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass MaxFlow{\n  typedef long long ll;\n  \n  struct edge{\n    int to;\n    ll cap;\n    int rev;\n    edge(){}\n    edge(int to, ll cap, int rev) : to(to), cap(cap), rev(rev){}\n  };\n  \n  std::vector<std::vector<edge> > G;\n  std::vector<int> level;\n  std::vector<int> iter;\n\n  void bfs(int s){\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n    \n  ll dfs(int v, int t, ll f){\n    if(v == t) return f;\n    \n    for(int &i = iter[v]; i < (int)G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] > level[v]){\n        ll d = dfs(e.to, t, std::min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \npublic:\n  MaxFlow(int V) :\n    G(std::vector<std::vector<edge> >(V)),\n    level(std::vector<int>(V)),\n    iter (std::vector<int>(V)) { }\n  \n  void add_edge(int from, int to, ll cap){\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n  }\n\n  ll solve(int s, int t){\n    ll res = 0, f;\n    for(;;){\n      bfs(s);\n      if(level[t] < 0) break;\n      std::fill(iter.begin(), iter.end(), 0);\n      while((f = dfs(s, t, LONG_LONG_MAX)) > 0) res += f;\n    }\n    return res;\n  }\n};\n\n\n\nint main(){\n\n  int n, m, l;\n  const int inf = 1000 * 1000 * 1000 + 7;\n  \n  while (cin >> n >> m >> l && n + m + l){\n    vector<vector<int> > adj(n, vector<int>(n, inf));\n    REP(i, m){\n      int a, b, c;\n      cin >> a >> b >> c;\n      assert(a < n && b < n) ;\n      adj[a][b] = c;\n      adj[b][a] = c;\n    }\n    \n    REP(i, n) adj[i][i] = 0;\n\n    REP(k, n) REP(i, n) REP(j, n){\n      adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);\n    }\n    int s = 2 * l;\n    int t = s + 1;\n    int V = t + 1;\n    MaxFlow mf(V);\n    vector<int> p(l), time(l);\n    \n    REP(i, l) cin >> p[i] >> time[i];\n    \n    REP(i, l) REP(j, l) if (i != j){\n      if (time[i] + adj[p[i]][p[j]] <= time[j]){\n        mf.add_edge(i, j + l, 1);\n      }\n    }\n    REP(i, l){\n      mf.add_edge(s, i, 1);\n      mf.add_edge(i + l, t, 1);\n    }\n    cout << l - mf.solve(s, t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2010\n#define MAX_N 1010\nusing namespace std;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j&&tl[i]+g[idx[i]][idx[j]]<=tl[j])add_edge(i,j);\n    V=l+l+2;\n    cout <<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<22;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = i==j?0:inf;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( !D[P[i]][P[j]] ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, j+L, 1 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        int answer = L - bipartiteMatching( g, L, edges );\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\n#include <cstring>\n\n#define MAX_V 10000\n#define INF 1000000000\n\nvoid add_edge(int,int);\nbool dfs(int);\nint bipartite_matching(int);\nvoid warshall_floyd(int);\n\nusing namespace std;\n\nvector<int>G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V],d[MAX_V][MAX_V];\n\n\n\nint main(void){\n  int n,m,l,p[MAX_V],t[MAX_V];\n\n  while(scanf(\"%d %d %d\",&n,&m,&l),n,m,l){\n    for(int i=0;i<MAX_V*2;i++)G[i].clear();\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  d[i][j]= i==j ?0:INF;\n\n      for(int i=0;i<m;i++){\n\t  int a,b,c; \n\t  scanf(\"%d %d %d\",&a,&b,&c);\n\t  d[a][b]=d[b][a]=c;\n\t}\n      warshall_floyd(n);\n\n      for(int i=0;i<l;i++)\n\tscanf(\"%d %d\",&p[i],&t[i]);\n\n      for(int i=0;i<l;i++){\n\tfor(int j=0;j<l;j++){\n\t  if(i==j)continue;\n\t  else if(t[i]+d[p[i]][p[j]]<=t[j])\n\t    add_edge(i,j+l);\n\t}\n      }\n\n      cout << l-bipartite_matching(2*l) << endl;\n    }\n  return 0;\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i < G[v].size();i++){\n    int u= G[v][i],w=match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\n\nint bipartite_matching(int V){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nvoid warshall_floyd(int V){\n  for(int i = 0; i < V; i++){\n    for(int j = 0; j < V; j++){\n      for(int k = 0; k < V; k++){\n\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 3050\n#define INF 1<<28\nvector<int> G[MAX_V];\nint match[MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\ntypedef pair<int,int> P;\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l){\n    for(int i=0;i<MAX_V;i++) G[i].clear();\n    int e[n][n];\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) e[i][j]=(i!=j)*INF;\n    for(int i=0;i<m;i++){\n      int u,v,d;\n      cin>>u>>v>>d;\n      e[u][v]=e[v][u]=d;\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n    vector<P> p(l);\n    for(int i=0;i<l;i++) cin>>p[i].first>>p[i].second;\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i==j) continue;\n\tint u=p[i].first,v=p[j].first;\n\tif(p[j].second-p[i].second>=e[u][v]) add_edge(u,l+v);\n      }\n    }\n    V=l*2;\n    cout<<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define MAX_V 2016\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nstruct edge{ int to,cap,rev; };\n\nint n,m,l;\nint dis[MAX][MAX];\nvpi vp;\nint V;\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n \nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n    e.cap-=d;\n    G[e.to][e.rev].cap+=d;\n    return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+MAX_V,0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nvoid init(){\n  FOR(i,0,MAX){\n    FOR(j,0,MAX){\n      if(i==j)dis[i][j]=0;\n      else dis[i][j]=inf;\n    }\n  }\n  FOR(i,0,MAX_V)G[i].clear();\n  vp.clear();\n}\n\nvoid wf(){\n  FOR(k,0,n)\n    FOR(i,0,n)\n      FOR(j,0,n)\n        dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n}\n\nvoid solve(){\n  int s=2*l;\n  int t=s+1;\n  V=t+1;\n  FOR(i,0,l){\n    add_edge(s,i,1);\n    add_edge(i+l,t,1);\n  }\n  FOR(i,0,l){\n    FOR(j,0,l){\n      if(i==j)continue;\n      if(vp[j].s<vp[i].s)continue;\n      if(dis[vp[i].f][vp[j].f]<=vp[j].s-vp[i].s)add_edge(i,j+l,1);\n    }\n  }\n  cout<<l-max_flow(s,t)<<endl;\n  return;\n}\n\nint main()\n{\n  while(1){\n    cin>>n>>m>>l;\n    if(n+m+l==0)break;\n    init();\n    FOR(i,0,m){\n      int u,v,d;\n      cin>>u>>v>>d;\n      dis[u][v]=d;\n      dis[v][u]=d;\n    }\n    FOR(i,0,l){\n      int p,t;\n      cin>>p>>t;\n      vp.pb(mp(p,t));\n    }\n    wf();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int INF = 10000000;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Cost cost;\n    Edge *back;\n    Edge(int from, int to, Flow c, Cost d, Edge *b) : from(from), to(to), capacity(c), flow(0), cost(d), back(b) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid make_edge(vector<vector<Edge<Flow,Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    auto *e = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    auto *back = e->back = new Edge<Flow,Cost>(dst, src, 0, -d, e);\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> h(N), dist(N);\n    vector<Edge<Flow,Cost>*> parent(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        dist[src] = 0;\n        fill(parent.begin(), parent.end(), nullptr);\n        priority_queue<pair<Cost,int>> q;\n        q.push(make_pair(0, src));\n        while(!q.empty()) {\n            const int n = q.top().second;\n            const Cost c = -q.top().first;\n            q.pop();\n            if(dist[n] < c) {\n                continue;\n            }\n            for(auto e : g[n]) {\n                if(e->capacity - e->flow > 0) {\n                    const Cost c2 = c + e->cost + h[n] - h[e->to];\n                    if(c2 < dist[e->to]) {\n                        dist[e->to] = c2;\n                        parent[e->to] = e;\n                        q.push(make_pair(-c2, e->to));\n                    }\n                }\n            }\n        }\n        if(parent[sink] == nullptr) {\n            break;\n        }\n\n        Flow to_push = f;\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            to_push = min(to_push, e->capacity - e->flow);\n        }\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            res.second += to_push * e->cost;\n            e->flow += to_push;\n            e->back->flow -= to_push;\n        }\n        f -= to_push;\n        res.first += to_push;\n        for(int i = 0; i < N; ++i) {\n            h[i] += dist[i];\n        }\n    }\n    return res;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<int>> dist(N, vector<int>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) {\n        dist[i][i] = 0;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] >= d) dist[i][j] = d;\n            }\n        }\n    }\n\n    vector<vector<Edge<int,int>*>> graph(L*2+2);\n    const int SRC = L*2;\n    const int SINK = SRC+1;\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const int in_node = i*2;\n        const int out_node = i*2+1;\n        make_edge(graph, SRC, in_node, 1, 0);\n        make_edge(graph, in_node, out_node, 1, 0);\n        make_edge(graph, out_node, SINK, INF, 0);\n        const int ni = queries[i].second;\n        for(int j = i+1; j < L; ++j) {\n            const int nj = queries[j].second;\n            if(dist[ni][nj] != -1 && queries[j].first - queries[i].first >= dist[ni][nj]) {\n                //cout << queries[i].second << ' ' << queries[j].second << endl;\n                make_edge(graph, out_node, j*2, 1, -1);\n            }\n        }\n    }\n    make_edge(graph, SRC, SINK, INF, 0);\n    const auto res = primal_dual(graph, SRC, SINK, L);\n    cout << L + res.second << endl;\n    for(auto &row : graph) {\n        for(auto e : row) {\n            delete e;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF 2000000000\n#define N 10005\n#define sz(b) (int)(b.size())\n#define pb push_back\nlong long d[109][109];\ntypedef struct\n{\n    int pos;\n    int t;\n}node;\nnode p[1009];\nint set[1009];\nvector<node>bel[1009];\nbool vis[1009];\nint findset(int x)\n{\n    return set[x]==x?x:set[x]=findset(set[x]);\n}\nvoid unionset(int x,int y)\n{\n    set[findset(x)]=findset(y);\n}\nint main()\n{\n    int n,m,i,j,k,l,x,y,z,fy;\n    bool wa;\n    while(1)\n    {\n        scanf(\"%d%d%d\",&n,&m,&l);\n        if(!n&&!m&&!l)return 0;\n        for(i=0;i<l;i++)\n        set[i]=i;\n        for(i=0;i<l;i++)\n        bel[i].clear();\n        for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        if(i!=j)d[i][j]=d[j][i]=INF;\n        else d[i][j]=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&z);\n            d[x][y]=d[y][x]=z;\n        }\n        for(k=0;k<n;k++)\n        for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        if(d[i][j]>d[i][k]+d[k][j])\n        d[i][j]=d[i][k]+d[k][j];\n        for(i=0;i<l;i++)\n        scanf(\"%d%d\",&p[i].pos,&p[i].t);\n        for(i=0;i<l;i++)\n        bel[i].push_back(p[i]);\n        for(i=0;i<l;i++)\n            for(j=0;j<i;j++)\n            {\n                fy=findset(j);\n                wa=0;\n                for(k=0;k<bel[fy].size();k++)\n                {\n                    if(d[bel[fy][k].pos][p[i].pos]<=abs(bel[fy][k].t-p[i].t))\n                    continue;\n                    else\n                    {\n                        wa=1;break;\n                    }\n                }\n                if(!wa)\n                {\n                    unionset(i,j);\n                    bel[fy].push_back(p[i]);\n                    break;\n                }\n            }\n        memset(vis,0,sizeof(vis));\n        for(i=0;i<l;i++)\n        vis[findset(i)]=1;\n        int ans=0;\n        for(i=0;i<l;i++)\n        if(vis[i])ans++;\n        printf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<set>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define INF (1<<30)\n#define maxn 1005\nint n,m,l;\nint dis[maxn][maxn],mark[maxn],t[maxn],sum=0;\nbool vis[maxn],f[maxn][maxn];\nbool dfs(int i)\n{\n    for(int j=0;j<l;j++)\n    {\n        if(!vis[j]&&f[i][j])\n        {\n            vis[j]=1;\n            if(mark[j]==-1||dfs(mark[j]))\n            {\n                mark[j]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n\n}\nvoid solve()\n{\n    memset(mark,-1,sizeof(mark));\n    for(int i=0;i<l;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if(dfs(i))sum++;\n    }\n}\nvoid build()\n{\n    int i,j;\n    for(i=0;i<l;i++)\n    {\n        for(j=0;j<l;j++)\n        {\n            if(dis[i][j]!=INF&&i!=j)\n            if(t[i]+dis[i][j]<=t[j])\n            {\n                 f[i][j]=1;\n            }\n        }\n    }\n}\nvoid floyd()\n{\n    int k,i,j;\n    for(k=0;k<n;k++)\n    {\n        for(i=0;i<n;i++)\n            for(j=0;j<n;j++)\n            if(dis[i][k]!=INF&&dis[k][j]!=INF)\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n}\nvoid update(int si,int k,int x)\n{\n    for(int i=0;i<si;i++)\n        dis[i][k]=dis[k][i]=dis[x][i];\n}\nint main()\n{\n     \n     while(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n     {\n         if(!n&&!m&&!l)break;\n         int i,j;\n         memset(f,0,sizeof(f));\n         sum=0;\n         for(i=0;i<=l;i++)\n            for(j=0;j<=l;j++)dis[i][j]=INF;\n         for(i=1;i<=m;i++)\n         {\n             int x,y,w;\n             scanf(\"%d%d%d\",&x,&y,&w);\n             dis[x][y]=dis[y][x]=w;\n         }\n         floyd();\n         int k=0;\n         memset(t,-1,sizeof(t));\n         for(i=1;i<=l;i++)\n         {\n             int x,y;\n             scanf(\"%d%d\",&x,&y);\n             if(t[x]==-1)t[x]=y;\n             else {t[n+k]=y;update(n+k,n+k,x);k++;}\n\n         }\n         build();\n         solve();\n         //printf(\"sum=%d\\n\",sum);\n         printf(\"%d\\n\",l-sum);\n\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<map>\nusing namespace std;\nconst int MAXN=1e9;\nint N,M,K;\nint d[105][105];\nvector<int>p[2086];\nbool vis[2086];\nint match[2086];\nint pi[1086];\nint t[1086];\nvoid edd(int u,int v)\n{\n    p[u].push_back(v);\n    p[v].push_back(u);\n\n}\nbool dfs(int v)\n{\n    vis[v]=1;\n    for(int i=0;i<p[v].size();i++)\n    {\n        int u=p[v][i];\n        int w=match[u];\n        if(w<0||!vis[w]&&dfs(w))\n        {\n            match[u]=v;\n            match[v]=u;\n            return 1;\n        }\n    }\n    return 0;\n}\nint judge()\n{   int res=0;\n    memset(match,-1,sizeof(match));\n    for(int i=0;i<2*K;i++)\n    {\n        if(match[i]<0)\n        {   memset(vis,0,sizeof(vis));\n            if(dfs(i))\n                res++;\n            //else continue;\n        }\n    }\n    return res;\n\n}\nint main()\n{\n    while(~scanf(\"%d %d %d\",&N,&M,&K)&&M&&N&&K)\n    {   for(int i=0;i<102;i++)\n        for(int j=0;j<102;j++)\n            d[i][j]=MAXN;\n        for(int i=0;i<2086;i++)\n            p[i].clear();\n        for(int i=0;i<102;i++)\n            d[i][i]=0;\n\n        int u,v,dis;\n        for(int i=0;i<M;i++)\n        {\n            scanf(\"%d %d %d\",&u,&v,&dis);\n            d[u][v]=d[v][u]=dis;\n        }\n            for(int k=0;k<N;k++)\n            for(int i=0;i<N;i++)\n            for(int j=0;j<N;j++)\n            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n        for(int i=0;i<K;i++)\n        {\n            scanf(\"%d %d\",&pi[i],&t[i]);\n        }\n        for(int i=0;i<K;i++)\n        for(int j=0;j<K;j++)\n        {\n            if(i==j)continue;\n\n                if(d[pi[i]][pi[j]]+t[i]<=t[j])\n                edd(i,j+K);\n        }\n       //judge();\n        printf(\"%d\\n\",K-judge());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\n\ntypedef int Cost;Cost CINF=1<<28;\nnamespace EGraph{\n\tstruct Edge{\n\t\tint from,to;Cost cost;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost) {};\n\t\tbool operator<(Edge r) const{\n\t\t\treturn cost<r.cost;\n\t\t}\n\t\tbool operator>(Edge r) const{\n\t\t\treturn cost>r.cost;\n\t\t}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\nnamespace MGraph{\n\ttypedef  vector<vector<Cost> > Mat;\n}\nnamespace ShortestPath{\n    using namespace MGraph;\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\nusing namespace EGraph;\n\nnamespace MaximamFlows{\n    using Flow=int;\n    const int INF = 1 << 28;\n    struct Edge{\n        int to;Flow cap;int rev;\n        Edge(int to,Flow cap,int rev) : to(to),cap(cap),rev(rev) {};\n    };\n    using Graph= vector<vector<Edge> >;\n\n    //dinic O(V^2*E)\n    class MaximamFlow{\n    private:\n            //iter　次に調べる時の開始位置 距離\n        vector<int> iter,dist;\n            //sからのbfs距離の計算\n        void bfs_dist(int s){\n            fill(ALL(dist),-1);dist[s]=0;\n            queue<int> que;que.push(s);\n            while(!que.empty()){\n                int v=que.front();que.pop();\n                EACH(e,G[v]){\n                    if(e->cap>0 && dist[e->to] == -1){\n                        dist[e->to]=dist[v]+1;\n                        que.push(e->to);\n                    }\n                }\n            }\n        }\n            //増加パス\n        Flow dfs_best_path(int v,int t,Flow f){\n            if(v==t)return f;\n            for(int &i =iter[v];i<(int)G[v].size();i++){\n                Edge& e=G[v][i];\n                if(e.cap>0 && dist[v]<dist[e.to]){\n                    Flow d=dfs_best_path(e.to,t,min(f,e.cap));\n                    if(d>0){\n                        e.cap-=d;G[e.to][e.rev].cap+=d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n    public:\n        int V;Graph G;\n        MaximamFlow(int V):V(V){\n            G=Graph(V);\n            dist=vector<int>(V);iter=vector<int>(V);\n        }\n\n        void add_edge(int from,int to,int cap){\n            int fromrev=G[to].size(),torev=G[from].size();\n            G[from].push_back(Edge(to,cap,fromrev));G[to].push_back(Edge(from,0,torev));\n        }\n        int max_flow(int s,int t){\n            Flow flow=0;\n            while(true){\n                bfs_dist(s);\n                if(dist[t]<0)return flow;\n                fill(ALL(iter),0);\n                Flow f;\n                while((f=dfs_best_path(s,t,INF))>0)flow+=f;\n            }return -1;\n        }\n    };\n}\nusing namespace MaximamFlows;\n\n\n//dagの最小パス被覆＝最大反鎖\nclass Main{\npublic:\n\tint N,M,L;\n\tMat g;\n\tvector<int> ps,ts;\n\tbool input(){\n\t\tnextInt(N);nextInt(M);nextInt(L);if(N==0)return false;\n\t\tg=Mat(N,vector<Cost>(N,CINF));\n\t\tREP(i,N)g[i][i]=0;\n\t\tREP(i,M){\n\t\t\tint u,v,d;nextInt(u);nextInt(v);nextInt(d);\n\t\t\tg[u][v]=g[v][u]=d;\n\t\t}\n\t\tps=vector<int>(L);ts=vector<int>(L);\n\t\tREP(i,L){\n\t\t\tnextInt(ps[i]);nextInt(ts[i]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run(){\n\t\twhile(input()){\n\t\t\twarshall_floyd(g);\n\t\t\tMaximamFlow mf(2*L+2);\n\t\t\tREP(i,L)REP(j,L)if(g[ps[i]][ps[j]]<=ts[j]-ts[i] &&i!=j){\n\t\t\t\tmf.add_edge(i, L+j,1);\n\t\t\t}\n\t\t\tREP(i,L)mf.add_edge(2*L,i,1);\n\t\t\tREP(j,L)mf.add_edge(L+j,2*L+1,1);\n\n\t\t\tcout <<L-mf.max_flow(2*L, 2*L+1)<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nbool G[2000][2000];\nint match[2000];\nbool used[2000];\n\nint V;\n\nvoid add_edge(int v, int u) {\n\tG[v][u] = G[u][v] = true;\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor(int i = 0; i < V; i++) {\n\t\tif(!G[v][i]) continue;\n\t\tint u = i, w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint calc() {\n\tint res = 0;\n\tfill(match, match + V, -1);\n\tfor(int v = 0; v < V; v++) {\n\t\tif(match[v] < 0) {\n\t\t\tfill(used, used + V, false);\n\t\t\tif(dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tV = 2 * L;\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tfor(int j = 0; j < V; j++) {\n\t\t\t\tG[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tadd_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<algorithm>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint const nMax = 1010;\nlong long road[200][200];\nint n,m,L,x,y,cost,judge;\nstruct SANTA{\n    int house;\n    long long time;\n}santa[nMax];\nstruct present{\n    int a;\n    long long time;\n}pre[nMax];\nbool cmp(present a,present b)\n{\n    return a.time < b.time;\n}\nbool cmp2(SANTA a,SANTA b)\n{\n    return a.time > b.time;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L),n||m||L){\n        int ans = 0;\n        memset(road,63,sizeof(road));\n        for(int i = 1;i <= m;i++){\n            scanf(\"%d%d%d\",&x,&y,&cost);\n            if( road[x][y] > cost )\n                road[x][y] = road[y][x] = cost;\n        }\n        for(int k = 0;k < n;k++){\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < n;j++)\n                    if( road[i][j] > road[i][k] + road[k][j] ) road[i][j] = road[i][k] + road[k][j];\n            }\n        }\n        for(int i = 0;i < n;i++) road[i][i] = 0;\n        for(int i = 0;i < L;i++) scanf(\"%d%d\",&pre[i].a,&pre[i].time);\n        sort(pre,pre+m,cmp);\n        //for(int i = 0;i < L;i++)printf(\"%d  %d\\n\",pre[i].a,pre[i].time);\n        for(int i = 0;i < L;i++){\n            judge = 0;\n            //for(int k = 1;k <= ans;k++)printf(\"%d %d\\n\",santa[k].house,santa[k].time);\n            if( i == 0 ) {\n                ans++;\n                santa[ans].house = pre[i].a;\n                santa[ans].time = pre[i].time;\n                continue;\n            }\n            for(int j = 1;j <= ans;j++){\n                if( road[santa[j].house][pre[i].a] <= pre[i].time - santa[j].time ){\n                    santa[j].house = pre[i].a;\n                    santa[j].time = pre[i].time;\n                    judge = 1;\n                    sort(santa+1,santa+ans+1,cmp2);\n                    break;\n                }\n            }\n            if( judge == 0 ){\n                ans++;\n                santa[ans].house = pre[i].a;\n                santa[ans].time = pre[i].time;\n            }\n            sort(santa+1,santa+ans+1,cmp2);\n        }\n        //for(int i = 1;i <= ans;i++)printf(\"%d %d\\n\",santa[i].house,santa[i].time);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nusing graph = std::vector<std::vector<int>>;\n\nbool dfs(graph const& g, int v, std::vector<int>& match, std::vector<bool>& used) {\n    used[v] = true;\n    for(auto u : g[v]) {\n        int w = match[u];\n        if(w < 0 || !used[w] && dfs(g, w, match, used)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(graph const& g) {\n    const int V = g.size();\n    std::vector<int> match(V, -1);\n    std::vector<bool> used(V);\n    int res = 0;\n    for(int v=0; v<V; ++v) {\n        if(match[v] < 0) {\n            std::fill(used.begin(), used.end(), false);\n            if(dfs(g, v, match, used)) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N, M, L;\n    while(cin >> N >> M >> L, N) {\n        vector<vector<int>> d(N, vector<int>(N, INF));\n        for(int i=0; i<N; ++i) {\n            d[i][i] = 0;\n        }\n        for(int i=0; i<M; ++i) {\n            int u, v, dd;\n            cin >> u >> v >> dd;\n            d[u][v] = d[v][u] = dd;\n        }\n        for(int k=0; k<N; ++k) {\n            for(int i=0; i<N; ++i) {\n                for(int j=0; j<N; ++j) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        vector<int> p(L), t(L);\n        for(int i=0; i<L; ++i) {\n            cin >> p[i] >> t[i];\n        }\n        graph g(L*2);\n        for(int i=0; i<L; ++i) {\n            for(int j=0; j<L; ++j) {\n                if(i == j) {\n                    continue;\n                }\n                if(d[p[i]][p[j]] <= t[j] - t[i]) {\n                    g[i].push_back(L+j);\n                }\n            }\n        }\n        cout << L - bipartite_matching(g) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<string.h>\n#include<algorithm>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if(n == 0) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LINF (1LL << 60)\n#define INF (1 << 30)\n#define MAX_N 2160\ntypedef long long  Int;\nstruct E{\n\tint to, rev;\n\tInt lim;\n\tE(int x, Int y, int z){\n\t\tto = x;\n\t\tlim = y;\n\t\trev = z;\n\t}\n};\n\nvector<E> edge[MAX_N];\nint lev[MAX_N];\nint iter[MAX_N];\n\nvoid make_edge(int a, int b, Int l){\n\tedge[a].push_back(E(b, l, edge[b].size()));\n\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n}\n\nInt dfs(int s, int g, Int f){\n\tif(s == g)return f;\n\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\tE &e = edge[s][i];\n\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\tInt tmp = dfs(e.to, g, min(f, e.lim));\n\t\tif(!tmp)continue;\n\t\te.lim -= tmp;\n\t\tedge[e.to][e.rev].lim += tmp;\n\t\treturn tmp;\n\t}\n\treturn 0;\n}\n\nvoid bfs(int x){\n\tqueue<int> q;\n\tq.push(x);\n\tint p = 0;\n\twhile(!q.empty()){\n\t\tfor(int i = q.size();i--;){\n\t\t\tint tmp = q.front();q.pop();\n\t\t\tif(lev[tmp] != INF)continue;\n\t\t\tlev[tmp] = p;\n\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == INF)q.push(edge[tmp][j].to);\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n}\n\nInt max_flow(int s, int g){\n\tInt res = 0;\n\tbool fin = false;\n\twhile(!fin){\n\t\tfill(lev, lev + MAX_N, INF);\n\t\tfill(iter, iter + MAX_N, 0);\n\t\tbfs(s);\n\t\tfin = true;\n\t\twhile(true){\n\t\t\tint p = dfs(s, g, INF);\n\t\t\tif(p == 0)break;\n\t\t\tfin = false;\n\t\t\tres += p;\n\t\t}\n\t}\t\n\treturn res;\n}\n\nint dist[108][108];\nint p[1080], t[1080];\nint main(){\n\tint n, m, l, u, v, d;\n\twhile(cin >> n >> m >> l, n|m|l){\n\t\tfor(int i = 0;i < 2160;i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\t\telse dist[i][j] = INF - 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tfor(int j = 0;j < n;j++)\n\t\t\t\tfor(int k = 0;k < n;k++)\n\t\t\t\t\tdist[j][k] = min(dist[j][i] + dist[i][k], dist[j][k]);\n\t\tfor(int i = 0;i < l ;i++){\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0;i < l;i++){\n\t\t\tmake_edge(l * 2, i, 1);\n\t\t\tmake_edge(i + l, l * 2+1, 1);\t\t\t\n\t\t\tfor(int j = 0;j < l;j++){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(t[i] + dist[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tmake_edge(i, j + l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << l - max_flow(l * 2, l * 2 + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\n/**\n * Dinic?????????????????§???\n *\n * ?????¨???????????¬????????????\n * template?????°???int V???????????°\n */\ntemplate<int V>\nstruct MaxFlow {\n    using T = int; /// ??????????????????\n    const T INF = 1<<28;\n    struct Edge {\n        int to, rev;\n        T cap;\n    };\n    vector<Edge> g[V];\n    int level[V];\n    int iter[V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    /// ??????????????????\n    void add(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n    }\n    /// ??????????????????\n    void add_multi(int from, int to, T cap) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n    }\n\n    void bfs(int s) {\n        fill_n(level, V, -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (Edge e: g[v]) {\n                if (e.cap <= 0) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap <= 0) continue;\n            if (level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d <= 0) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // s??????t???????????§????????????\n    T exec(int s, int t) {\n        T flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill_n(iter, V, 0);\n            T f;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\ntypedef pair<int, int> P;\nconst int MN = 110;\nconst int ML = 1100;\nMaxFlow<MN*2> mf;\n\nint dist[MN][MN];\nP qu[ML];\nbool solve() {\n    mf.init();\n    int n, m, l;\n    cin >> n >> m >> l;\n    if (!n) return false;\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = 1e8;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = d;\n        dist[v][u] = d;\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j],\n                    dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n\n\n    for (int i = 0; i < l; i++) {\n        int p, t;\n        cin >> p >> t;\n        qu[i] = P(t, p);\n    }\n    sort(qu, qu+l);\n\n    int vs = 2*MN-1;\n    int vt = 2*MN-2;\n    for (int i = 0; i < l; i++) {\n        for (int j = i+1; j < l; j++) {\n            int ap, at, bp, bt;\n            tie(at, ap) = qu[i];\n            tie(bt, bp) = qu[j];\n            if (dist[ap][bp] <= bt - at) {\n                mf.add(i, j+MN, 1);\n            }\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        mf.add(vs, i, 1);\n        mf.add(i+MN, vt, 1);\n    }\n    cout << l - mf.exec(vs, vt) << endl;\n    return true;\n}\n\nint main() {\n    while (true) {\n        if (!solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass MaxFlow{\n  typedef long long ll;\n  \n  struct edge{\n    int to;\n    ll cap;\n    int rev;\n    edge(){}\n    edge(int to, ll cap, int rev) : to(to), cap(cap), rev(rev){}\n  };\n  \n  std::vector<std::vector<edge> > G;\n  std::vector<int> level;\n  std::vector<int> iter;\n\n  void bfs(int s){\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n    \n  ll dfs(int v, int t, ll f){\n    if(v == t) return f;\n    \n    for(int &i = iter[v]; i < (int)G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] > level[v]){\n        ll d = dfs(e.to, t, std::min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \npublic:\n  MaxFlow(int V) :\n    G(std::vector<std::vector<edge> >(V)),\n    level(std::vector<int>(V)),\n    iter (std::vector<int>(V)) { }\n  \n  void add_edge(int from, int to, ll cap){\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n  }\n\n  ll solve(int s, int t){\n    ll res = 0, f;\n    for(;;){\n      bfs(s);\n      if(level[t] < 0) break;\n      std::fill(iter.begin(), iter.end(), 0);\n      while((f = dfs(s, t, LONG_LONG_MAX)) > 0) res += f;\n    }\n    return res;\n  }\n};\n\n\n\nint main(){\n\n  int n, m, l;\n  const int inf = 1000 * 1000 * 1000 + 7;\n  \n  while (cin >> n >> m >> l && n + m + l){\n    vector<vector<int> > adj(n, vector<int>(n, inf));\n    REP(i, m){\n      int a, b, c;\n      cin >> a >> b >> c;\n      assert(a < n && b < n) ;\n      adj[a][b] = c;\n      adj[b][a] = c;\n    }\n\n    REP(k, n) REP(i, n) REP(j, n){\n      adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);\n    }\n    int s = 2 * l;\n    int t = s + 1;\n    int V = t + 1;\n    MaxFlow mf(V);\n    vector<int> p(l), time(l);\n    \n    mv REP(i, l) cin >> p[i] >> time[i];\n    \n    REP(i, l) REP(j, l) if (p[i] != p[j]){\n      if (time[i] + adj[p[i]][p[j]] <= time[j]){\n        mf.add_edge(i, j + l, 1);\n      }\n    }\n    REP(i, l){\n      mf.add_edge(s, i, 1);\n      mf.add_edge(i + l, t, 1);\n    }\n    cout << l - mf.solve(s, t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 300;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[1001];\n        fill(used,used+1001,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            ct=node=0;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i = v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int minTime=-1;\n                int idx=0;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i = v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=time){\n                        if(minTime<time){\n                            minTime=ct-cost;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(minTime==-1)\n                    break;\n                //  êÎAóÔðXV\n                ct=v[idx].first;\n                node=v[idx].second;\n                used[idx]=true;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nbool augment(int u,vector<bool> &visited,const vector< vector<int> > &adj,vector<int> match[2]){\n\tif(u==-1) return true;\n\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tif(augment(match[1][v],visited,adj,match)){\n\t\t\t\tmatch[0][u]=v;\n\t\t\t\tmatch[1][v]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint BipartiteMatching(const vector< vector<int> > &adj,int R){\n\tint L=adj.size();\n\n\tvector<int> match[2];\n\tmatch[0].assign(L,-1);\n\tmatch[1].assign(R,-1);\n\n\tint ans=0;\n\tvector<bool> visited(R);\n\trep(u,L){\n\t\trep(v,R) visited[v]=false;\n\t\tif(augment(u,visited,adj,match)) ans++;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n;){\n\t\tstatic int dis[100][100];\n\t\trep(u,n) rep(v,n) dis[u][v]=INF;\n\t\trep(i,m){\n\t\t\tint u,v,d; scanf(\"%d%d%d\",&u,&v,&d);\n\t\t\tdis[u][v]=dis[v][u]=d;\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) if(dis[i][k]+dis[k][j]<dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j];\n\n\t\tstatic int p[1000],t[1000];\n\t\trep(i,l) scanf(\"%d%d\",p+i,t+i);\n\n\t\tvector< vector<int> > adj(l);\n\t\trep(u,l) rep(v,l) if(u!=v) {\n\t\t\tif(t[u]+dis[p[u]][p[v]]<=t[v]) adj[u].push_back(v);\n\t\t}\n\n\t\tprintf(\"%d\\n\",l-BipartiteMatching(adj,l));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct ford_fulkerson{\n    static const int INF=1001001001001001001;\n    static const int MAX_V=2010;\n    static const int SOURCE=MAX_V-2;\n    static const int SINK=MAX_V-1;\n\n    struct edge{\n        int to,cap,rev;\n        edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n    };\n    vector<edge>G[MAX_V];\n    bool used[MAX_V];\n\n    void add_edge(int from,int to,int cap){\n        G[from].push_back(edge(to,cap,G[to].size()));\n        G[to].push_back(edge(from,0,G[from].size()-1));\n    }\n\n    int dfs(int v,int t,int f){\n        if(v==t)return f;\n        used[v]=true;\n        for(int i=0;i<G[v].size();i++){\n            edge &e=G[v][i];\n            if(!used[e.to]&&e.cap>0){\n                int d=dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s=SOURCE,int t=SINK){\n        int flow=0;\n        for(;;){\n            memset(used,0,sizeof(used));\n            int f=dfs(s,t,INF);\n            if(f==0)return flow;\n            flow+=f;\n        }\n    }\n};\n\nint N,M,L;\nconst int INF=1001001001001001001;\nint dist[100][100];\nvoid solve(){\n    fill_n(*dist,100*100,INF);\n    rep(i,N)dist[i][i]=0;\n\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        chmin(dist[a][b],c);\n        chmin(dist[b][a],c);\n    }\n    rep(k,N)rep(i,N)rep(j,N)chmin(dist[i][j],dist[i][k]+dist[k][j]);\n\n    vpint qs;\n    rep(i,L){\n        int a,b;\n        cin>>a>>b;\n        qs.pb(pint(b,a));\n    }\n\n    sort(all(qs));\n\n    ford_fulkerson ff;\n    for(int i=0;i<L;i++){\n        for(int j=i+1;j<L;j++){\n            if(dist[qs[i].se][qs[j].se]<=qs[j].fi-qs[i].fi){\n                ff.add_edge(i*2+1,j*2,1);\n            }\n        }\n    }\n\n    for(int i=0;i<L;i++){\n        ff.add_edge(ford_fulkerson::SOURCE,i*2+1,1);\n        ff.add_edge(i*2,ford_fulkerson::SINK,1);\n    }\n\n    cout<<L-ff.max_flow()<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>L,N||M||L)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std ;\n\nconst long long N = 11000 ;\nconst long long M = 20000 ;\nconst long long INF = 1ll << 60 ;\nlong long n , m , l ;\nvector < long long > G[N] ;\nlong long map[N][N] , link[N] , vis[N] ;\nlong long s[N] , p[N] ;\n\ninline long long dfs( long long x )\n{\n\tfor( long long i = 0 ; i < G[x].size() ; i ++ )\n\t{\n\t\tlong long v = G[x][i] ;\n\t\tif( !vis[v] )\n\t\t{\n\t\t    vis[v] = 1 ;\n\t\t\tif( link[v] == -1 || dfs( link[v] ) )\n\t\t\t{\n\t\t\t\tlink[v] = x ;\n\t\t\t\treturn 1 ;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0 ;\n}\n\nint main()\n{\n\tlong long u , v , w ;\n\twhile( ~scanf(\"%lld %lld %lld\" , &n , &m , &l) )\n\t{\n\t    if( n == 0 && m == 0 && l == 0 )    break ;\n\t\tfor( long long i = 0 ; i < n ; i ++ )\n\t\t{\n\t\t\tfor( long long j = 0 ; j < n ; j ++ )\n\t\t\t{\n\t\t\t    if( i == j )    map[i][i] = 0 ;\n\t\t\t    else    map[i][j] = INF ;\n\t\t\t}\n\t\t}\n\t\tfor( long long i = 1 ; i <= m ; i ++ )\n\t\t{\n\t\t\tscanf(\"%lld %lld %lld\" , &u , &v , &w) ;\n\t\t\tmap[u][v] = map[v][u] = w ;\n\t\t}\n\t\tfor( long long i = 0 ; i < n ; i ++ )\n\t\t{\n\t\t\tfor( long long j = 0 ; j < n ; j ++ )\n\t\t\t{\n\t\t\t\tfor( long long k = 0 ; k < n ; k ++ )\n\t\t\t\t\tmap[i][j] = min( map[i][j] , map[i][k] + map[k][j] ) ;\n\t\t\t}\n\t\t}\n\t\tfor( long long i = 1 ; i <= l ; i ++ )\n\t\t\tscanf(\"%lld %lld\" , &s[i] , &p[i]) ;\n\t\tfor( long long i = 1 ; i <= l ; i ++ )\tG[i].clear() ;\n\t\tfor( long long i = 1 ; i <= l ; i ++ )\n\t\t{\n\t\t\tfor( long long j = 1 ; j <= l ; j ++ )\n\t\t\t{\n\t\t\t\tif( i == j )\tcontinue ;\n\t\t\t\tif( p[i] + map[s[i]][s[j]] <= p[j] )\n                    G[i].push_back( j ) ;\n\t\t\t}\n\t\t}\n\t\tmemset( link , -1 , sizeof( link ) ) ;\n\t\tlong long ans = 0 ;\n\t\tfor( long long i = 1 ; i <= l ; i ++ )\n\t\t{\n\t\t\tmemset( vis , 0 , sizeof( vis ) ) ;\n\t\t\tif( dfs( i ) )\n                ans ++ ;\n\t\t}\n\t\tprintf(\"%lld\\n\" , l - ans) ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n#define SOUR (L+L)\n#define SINK (L+L+1)\n\nint flow[2005][2005], capa[2005][2005],L,v[2020];\nbool DAG[1005][1005];\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nvoid Connect(vector<Node>& node, int u, int v, int w)\n{\n\tflow[v][u]+=w;\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\tnode[u].to.push_back(v);\n\tnode[v].to.push_back(u);\n}\n\nint dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i], fw=capa[p][next]-flow[p][next];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]+=f;\n\t\t\tflow[next][p]-=f;\n\t\t\t\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(capa[n][next]-flow[n][next] <= 0) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid Connect(int u, int v, int w, vector<Node>& graph)\n{\n\tgraph[u].to.push_back(v);\n\tgraph[v].to.push_back(u);\n\tcapa[u][v]+=w;\n\tcapa[v][u]+=w;\n\t\n\tflow[v][u]+=w;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(scanf(\"%d%d%d\", &N,&M,&L), (N||M||L))\n\t{\n\t\tint d[105][105];\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\t\td[i][j]=INF;\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\", &u,&v,&c);\n\t\t\td[u][v]=c;\n\t\t\td[v][u]=c;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<N; k++)\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n\t\t}\n\t\t\n\n\t\tint s[1005],t[1005];\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &s[i], &t[i]);\n\t\t}\n\n\t\tmemset(flow, 0, sizeof(flow));\n\t\tmemset(capa, 0, sizeof(capa));\n\t\tmemset(DAG, 0, sizeof(DAG));\n\n\t\tvector<Node> node(SINK+1);\n\n\t\tbool beg[1005]={0}, end[1005]={0};\n\t\tfor(int i=0; i<L; i++)\n\t\tfor(int j=0; j<L; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(d[s[i]][s[j]] + t[i] <= t[j])\n\t\t\t{\n\t\t\t\tDAG[i][j]=1;\n\t\t\t\tbeg[j]=1;\n\t\t\t\tend[i]=1;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]) \n\t\t\t{\n\t\t\t\tConnect(node, SOUR, i, INF);\n\t\t\t}\n\t\t\tif(!end[i]) \n\t\t\t{\n\t\t\t\tConnect(node, L+i, SINK, INF);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint add=0;\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tif(!beg[i]&&!end[i])\n\t\t\t{\n\t\t\t\t++add;\n\t\t\t}\n\t\t\tfor(int j=0; j<L; j++)\n\t\t\t{\n\t\t\t\tif(DAG[i][j])\n\t\t\t\t{\n\t\t\t\t\tConnect(node, i, L+j,1);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dinic(SOUR,SINK,node)+add);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint N,M,L;\nint map[110][110];\nint edge[1100][1100];\n\nstruct Node\n{\n\tint hou;\n\tint ti;\n}node[1200];\nint cx[1100];\nint cy[1100];\nbool vis[1100];\nvoid  floyed()\n{\n\tfor(int k=0;k<N;k++)\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\tif(i!=j&&j!=k&&i!=k)\n\t\t\t\t\t{\n\t\t\t\t\tmap[i][j]=min(map[i][k]+map[k][j],map[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n}\nint path(int u)\n{\n\tint v;\n\tfor(v=0;v<L;v++)\n\t\t{\n\t\tif(edge[u][v]&&!vis[v])\n\t\t\t{\n\t\t\tvis[v]=1;\n\t\t\tif(cy[v]==-1||path(cy[v]))\n\t\t\t\t{\n\t\t\t\tcx[u]=v;\n\t\t\t\tcy[v]=u;\n\t\t\t\treturn 1;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\nreturn 0;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&N,&M,&L)!=EOF)\n\t\t{\n\t\tif(N==0&&M==0&&L==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\t\n\t\t\t\t\tif(i==j)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j]=0x7fffff;\n\t\t\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\t\t{\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tmap[a][b]=c;\n\t\t\tmap[b][a]=c;\n\t\t\t}\n\t\tfloyed();\n\t\tfor(int i=0;i<L;i++)\n\t\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tnode[i].hou=a;\n\t\t\tnode[i].ti=b;\n\t\t\t}\n\t\tmemset(edge,0,sizeof(edge));\n\t\tfor(int i=0;i<L;i++)\n\t\t\t{\n\t\t\tfor(int j=0;j<L;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i!=j&&node[i].ti-node[j].ti>=map[node[i].hou][node[j].hou])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tedge[j][i]=1;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tmemset(cx,0xfffff,sizeof(cx));\n\t\tmemset(cy,0xfffff,sizeof(cy));\n\t\tint ans=0;\n\t\tfor(int i=0;i<L;i++)\n\t\t\t{\n\t\t\tif(cx[i]==-1)\n\t\t\t\t{\n\t\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\t\tans+=path(i);\n\t\t\t\t}\t\n\t\t\t}\n\t\tprintf(\"%d\\n\",L-ans);\n\t\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostMaximumFlow {\n\tusing Index = int;\n\tusing Flow = int;\n\tusing Cost = int;\n\tstatic const Flow kInfCapacity = INF;\n\tstatic const Cost kInfCost = INF;\n\tstruct Edge {\n\t\tIndex s, d;\n\t\tFlow capacity;\n\t\tCost cost;\n\t};\n\tusing Edges = vector<Edge>;\n\tusing Graph = vector<Edges>;\n\tGraph g;\n\tvoid init(Index n) { g.assign(n, Edges()); }\n\tvoid addArc(Index i, Index j, Flow capacity = kInfCapacity, Cost cost = Cost()) {\n\t\tEdge e, f; e.d = j, f.d = i; e.capacity = capacity, f.capacity = 0; e.cost = cost, f.cost = -cost;\n\t\tg[i].push_back(e); g[j].push_back(f);\n\t\tg[i].back().s = (Index)g[j].size() - 1; g[j].back().s = (Index)g[i].size() - 1;\n\t}\n\tvoid addEdge(Index i, Index j, Flow capacity = kInfCapacity, Cost cost = Cost()) {\n\t\taddArc(i, j, capacity, cost);\n\t\taddArc(j, i, capacity, cost);\n\t}\n\tpair<Cost, Flow> minimumCostMaximumFlow(Index s, Index t, Flow f = kInfCapacity, bool useSPFA = false) {\n\t\tint n = g.size();\n\t\tvector<Cost> dist(n); vector<Index> prev(n); vector<Index> prev_edge(n);\n\t\tpair<Cost, Flow> total = make_pair(0, 0);\n\t\tvector<Cost> potential(n);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), kInfCost);\n\t\t\tif (useSPFA || total.second == 0) {\n\t\t\t\tdeque<Index> q;\n\t\t\t\tq.push_back(s); dist[s] = 0; vector<bool> inqueue(n);\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tIndex i = q.front(); q.pop_front(); inqueue[i] = false;\n\t\t\t\t\tfor (Index ei = 0; ei < g[i].size(); ei++) {\n\t\t\t\t\t\tconst Edge &e = g[i][ei]; Index j = e.d; Cost d = dist[i] + e.cost;\n\t\t\t\t\t\tif (e.capacity > 0 && d < dist[j]) {\n\t\t\t\t\t\t\tif (!inqueue[j]) {\n\t\t\t\t\t\t\t\tinqueue[j] = true;\n\t\t\t\t\t\t\t\tq.push_back(j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist[j] = d; prev[j] = i; prev_edge[j] = ei;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvector<bool> vis(n);\n\t\t\t\tpriority_queue<pair<Cost, Index> > q;\n\t\t\t\tq.push(make_pair(-0, s)); dist[s] = 0;\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tIndex i = q.top().second; q.pop();\n\t\t\t\t\tif (vis[i]) continue;\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tfor (Index ei = 0; ei < (Index)g[i].size(); ei++) {\n\t\t\t\t\t\tconst Edge &e = g[i][ei];\n\t\t\t\t\t\tif (e.capacity <= 0) continue;\n\t\t\t\t\t\tIndex j = e.d; Cost d = dist[i] + e.cost + potential[i] - potential[j];\n\t\t\t\t\t\tif (dist[j] > d) {\n\t\t\t\t\t\t\tdist[j] = d; prev[j] = i; prev_edge[j] = ei;\n\t\t\t\t\t\t\tq.push(make_pair(-d, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == kInfCost) break;\n\t\t\tif (!useSPFA) for (Index i = 0; i < n; i++) potential[i] += dist[i];\n\n\t\t\tFlow d = f; Cost distt = 0;\n\t\t\tfor (Index v = t; v != s; ) {\n\t\t\t\tIndex u = prev[v]; const Edge &e = g[u][prev_edge[v]];\n\t\t\t\td = min(d, e.capacity); distt += e.cost; v = u;\n\t\t\t}\n\t\t\tf -= d; total.first += d * distt; total.second += d;\n\t\t\tfor (Index v = t; v != s; v = prev[v]) {\n\t\t\t\tEdge &e = g[prev[v]][prev_edge[v]];\n\t\t\t\te.capacity -= d; g[e.d][e.s].capacity += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, M, L; cin >> N >> M >> L&&N;) {\n\t\tvector<vector<int>> g(N, vector<int>(N, INF));\n\t\trep(i, 0, M) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\trep(i, 0, N)\n\t\t\tg[i][i] = 0;\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (g[i][k] != INF&&g[k][j] != INF)\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t}\n\n\t\tvector<int> p(L), t(L); rep(i, 0, L) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tMinimumCostMaximumFlow mcf;\n\t\tmcf.init(L + L + 2);\n\t\tint source = L + L, sink = source + 1;\n\t\trep(i, 0, L) {\n\t\t\trep(j, 0, L) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (g[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tmcf.addArc(i, L + j, 1, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 0, L) {\n\t\t\tmcf.addArc(source, i, 1, 0);\n\t\t\tmcf.addArc(i, sink, 1, 0);\n\t\t\tmcf.addArc(L + i, sink, 1, 0);\n\t\t}\n\t\tauto ans = L + mcf.minimumCostMaximumFlow(source, sink, L).first;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\ntypedef pair<int, int> P;\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[2010];\nint h[2010];\nint dist[2010];\nint prevv[2010], preve[2010];\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){ to, cap, cost, (int)G[to].size() });\n    G[to].push_back((edge){ from, 0, -cost, (int)G[from].size() - 1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > q;\n        fill(dist, dist + V, M);\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); ++i) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == M) return M;\n        for (int v = 0; v < V; ++v)\n            h[v] += dist[v];\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    while (1) {\n        int n, m, l;\n        cin >> n >> m >> l;\n        if (!n) return 0;\n\n        for (int i = 0; i < 2010; ++i) {\n            G[i].clear();\n\n        }\n        vector<vector<int>> dist(n, vector<int>(n, M));\n        for (int i = 0; i < n; ++i) {\n            dist[i][i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            dist[u][v] = dist[v][u] = d;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                for (int k = 0; k < n; ++k)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        vector<pair<int, int>> p(l);\n        for (int i = 0; i < l; ++i) {\n            cin >> p[i].second >> p[i].first;\n        }\n        sort(p.begin(), p.end());\n\n        V = l * 2 + 2;\n        for (int i = 0; i < l; ++i) {\n            add_edge(l * 2, i, 1, 0);\n            add_edge(i, l + i, 1, -1);\n            add_edge(l + i, l * 2 + 1, 1, 0);\n        }\n        for (int i = 0; i < l; ++i) {\n            for (int j = i + 1; j < l; ++j) {\n                if (dist[p[i].second][p[j].second] <= p[j].first - p[i].first) {\n                    add_edge(l + i, j, 1, 0);\n                }\n            }\n        }\n        int c = 0;\n        for (int i = 1; ; ++i) {\n            c += -min_cost_flow(l * 2, l * 2 + 1, 1);\n            if (c == l) {\n                cout << i << \"\\n\";\n                goto A;\n            }\n        }\n        A:\n        continue;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nstruct edge{\n  int to,rev,f;\n};\nvector<edge> G[2111];\n\nbool memo[2111];\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( (edge){to,G[to].size(),1} );\n  G[to].push_back( (edge){from,G[from].size()-1,0} );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\n\nbool dfs(int id,int t){\n  if( memo[id] ) return false;\n  memo[id] = true;\n  if( t == id ) return true;\n  for(int i=0;i<(int)G[id].size();i++){\n    edge &e= G[id][i];\n    if( e.f ) {\n      if( dfs(e.to,t) ){\n        e.f = 0;\n        G[e.to][e.rev].f = 1;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint solve(){\n  for(int i=0;i<L;i++){\n    memset(memo,0,sizeof(memo));\n    if( !dfs(2*L,2*L+1) ) return L-i;\n  }\n  return 0;\n}\n\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n\n    for(int i=0;i<L;i++){\n      for(int j=i+1;j<L;j++){\n        ll len = W[pt[i].second][pt[j].second];\n        ll lt = pt[j].first - pt[i].first;\n        if( len <= lt )          \n          add_edge( i, L+j );\n      }\n    }\n    for(int i=0;i<L;i++){\n      add_edge(2*L,i);\n      add_edge(i+L,2*L+1);\n    }\n\n    /*\n    for(int i=0;i<=L;i++){\n      cout << i << \": \" << pt[i].first<< \" \"<< pt[i].second << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \"  -> \" << G[i][j].to << endl;\n      }\n    }\n    */\n    \n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nint n,m,l;\nconst int INF=1000000000;\nconst int MAX_V = 200;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint main(){\n    while(cin>>n>>m>>l&&!(n==0&&m==0&&l==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)d[i][j]=0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            cin>>from>>to>>cost;\n            d[from][to]=d[to][from]=cost;\n        }\n        V=n;\n        warshall_floyd();\n        vector<P> v;\n        for(int i = 0; i < l; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            v.push_back(p);\n        }\n        sort(v.begin(),v.end());\n        int cnt=0;\n        bool used[200];\n        fill(used,used+200,false);\n        bool b=false;\n        while(1){\n            b=false;\n            int ct,node;\n            // àÁÆàãëÌ¨©çÔÉÆÁÄ¢­\n            for(int i = v.size()-1; i >= 0; i--){\n                if(used[i])continue;\n                used[i]=true;\n                node=v[i].second;\n                ct=v[i].first;\n                b=true;\n                break;\n            }\n            // æêÈ­ÈÁ½çIíè\n            if(!b)\n                break;\n            cnt++;\n            while(1){\n                int minTime=-1;\n                int idx;\n                // »ÝÌê©çeêÖÚ®µAeNGÌI¹ÔÈãÌÔÅI¦çêéêÌÈ©ÅAàÁÆàÔªß¢àÌðIÔ\n                for(int i = v.size()-1; i>=0;i--){\n                    if(used[i])continue;\n                    int to=v[i].second;\n                    int time=v[i].first;\n                    int cost=d[node][to];\n                    // ðð½·\n                    if(ct-cost>=time){\n                        if(minTime<time){\n                            minTime=ct-cost;\n                            idx=i;\n                        }\n                    }\n                }\n                // ðð½·àÌª³¯êÎbreak\n                if(minTime==-1)\n                    break;\n                //  êÎAóÔðXV\n                ct=v[idx].first;\n                node=v[idx].second;\n                used[idx]=true;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[123][123];\nint n, m, l;\npair <int, int> work[1234];\nvector<int> G[4567];\nint result[4567], vis[4567];\n\nbool dfs(int u)\n{\n    vis[u] = 1;\n    for(int i = 0; i < G[u].size(); i++)\n    {\n        int t = G[u][i];\n        if(result[t] == -1 || !vis[result[t]] && dfs(result[t]))\n        {\n            result[t] = u;\n            result[u] = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(result, -1, sizeof result);\n    for(int i = 0; i < l; i++)\n    {\n        memset(vis, 0, sizeof vis);\n        res += dfs(i);\n    }\n    return res;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d\", &n, &m, &l), n + m + l)\n    {\n        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) dp[i][j] = i == j ? 0 : 1000000000;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y, u;\n            scanf(\"%d%d%d\", &x, &y, &u);\n            dp[x][y] = dp[y][x] = u;\n        }\n        for(int i = 0; i < l; i++)\n        {\n            int u, v;\n            scanf(\"%d%d\", &u, &v);\n            work[i] = make_pair(u, v);\n        }\n        for(int k = 0; k < n; k++) for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n        for(int i = 0; i < l; i++)\n        {\n            for(int j = 0; j < l; j++)\n            {\n                if(i == j) continue;\n                if(dp[work[i].first][work[j].first] + work[i].second <= work[j].second)\n                {\n                    G[i].push_back(j + n);\n                }\n            }\n        }\n        printf(\"%d\\n\", l - hungary());\n        for(int i = 0; i < l; i++) G[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <map>\n#include <queue>\n#include <set>\n#include <cmath>\n\n#define PB push_back\n#define LL long long\n#define vi vector<int>\n#define pii pair<int,int>\n#define MP make_pair\n#define pll pair<LL,LL>\nusing namespace std;\n\nconst int Maxn=110;\nconst int Maxv=1110;\nint g[Maxn][Maxn],n,m,l;\nint vis[Maxv],match[Maxv];\nint head[Maxv],tot;\nconst int Inf=1e9+7;\nstruct Edge{\n    int to,next;\n}edge[Maxv*Maxv*2];\n\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    for(int i=0;i<Maxn;i++)\n        for(int j=0;j<Maxn;j++)\n            g[i][j]=i==j?0:Inf;\n    tot=0;\n}\n\nvoid add_edge(int u,int v)\n{\n    edge[tot].to=v;\n    edge[tot].next=head[u];\n    head[u]=tot++;\n}\n\nvoid Floyed()\n{\n    for(int k=0;k<n;k++)\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n}\n\nbool dfs(int u,int tar)\n{\n    for(int i=head[u];~i;i=edge[i].next)\n    {\n        int v=edge[i].to;\n        if(vis[v]==tar)\n            continue;\n        vis[v]=tar;\n        if(match[v]==-1||dfs(match[v],tar))\n        {\n            match[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int ret=0;\n    memset(match,-1,sizeof(match));\n    memset(vis,-1,sizeof(vis));\n    for(int i=0;i<l;i++)\n    {\n        ret+=dfs(i,i);\n    }\n    return ret;\n}\n\npii op[Maxv];\n\nbool cmp(pii a,pii b)\n{\n    return a.second<b.second;\n}\n\nint main()\n{\n    while(scanf(\"%d %d %d\",&n,&m,&l),n||m||l)\n    {\n        init();\n        while(m--)\n        {\n            int u,v,w;\n            scanf(\"%d %d %d\",&u,&v,&w);\n            g[u][v]=g[v][u]=min(g[u][v],w);\n        }\n        Floyed();\n        for(int i=0;i<l;i++)\n        {\n            int p,t;\n            scanf(\"%d %d\",&p,&t);\n            op[i]=MP(p,t);\n        }\n        for(int i=0;i<l;i++)\n        {\n            for(int j=0;j<l;j++)\n            {\n                int p1=op[i].first,p2=op[j].first;\n                int d=g[p1][p2];\n                if(i==j)\n                    continue;\n                if(d==0&&op[i].second==op[j].second)\n                    continue;\n                if(op[i].second+d<=op[j].second)\n                    add_edge(i,j);\n            }\n        }\n        printf(\"%d\\n\",l-hungary());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,l;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[1005];\nbool used[1005];\nint E[105][105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nint p[1005],t[1005];\nint main(){\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) return 0;\n\t\trep(i,105) rep(j,105){\n\t\t\tE[i][j] = INF;\n\t\t\tif(i==j) E[i][j] = 0;\n\t\t}\n\t\trep(i,1005){\n\t\t\tG[i].clear(); used[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tE[u][v] = E[v][u] = d;\n\t\t}\n\t\tfor(int i=0;i<l;i++) cin >> p[i] >> t[i];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tE[j][k] = min(E[j][k],E[j][i]+E[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(t[i]+E[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(p[i],p[j]+100,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) add_edge(201,i,1);\n\t\tfor(int i=0;i<n;i++) add_edge(i+100,202,1);\n\t\tcout << l-max_flow(201,202) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 300\nusing namespace std;\ntypedef pair<int,int> ii;\n\n// flow --- start\nstruct edge\n{\n  int to,cap,rev;\n  edge(int to=inf,int cap=inf,int rev=inf):to(to),cap(cap),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint level[MAX];\nint iter[MAX];\n\nvoid add_edge(int from,int to,int cap)\n{\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n  rep(i,MAX)level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty())\n    {\n      int v = que.front(); que.pop();\n      rep(i,G[v].size())\n\t{\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && level[e.to] < 0)\n\t    {\n\t      level[e.to] = level[v] + 1;\n\t      que.push(e.to);\n\t    }\n\t}\n    }\n} \n\nint dfs(int v,int t,int f)\n{\n  if(v == t)return f;\n  for(int &i = iter[v]; i < G[v].size() ; i++)\n    {\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to])\n\t{\n\t  int d = dfs(e.to,t,min(f,e.cap));\n\t  if(d > 0)\n\t    {\n\t      e.cap -= d;\n\t      G[e.to][e.rev].cap += d;\n\t      return d;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;)\n    {\n      bfs(s);\n      if(level[t] < 0)return flow;\n      rep(i,MAX)iter[i] = 0;\n      int f;\n      while((f = dfs(s,t,inf)) > 0)\n\tflow += f;\n    }\n}\n\n// flow --- end\n\n\nint N,M,L;\nint mincost[MAX][MAX];\nvector<ii> ps;\n\nint main()\n{\n  while(cin >> N >> M >> L,N|M|L)\n    {\n      rep(i,MAX)G[i].clear();\n      rep(i,MAX)rep(j,MAX)mincost[j][i] = inf;\n      rep(i,MAX)          mincost[i][i] = 0;\n\n      {\n\tint u,v,d;\n\trep(i,M)\n\t  {\n\t    cin >> u >> v >> d;\n\t    mincost[u][v] = mincost[v][u] = d;\n\t  }\n\trep(i,MAX)rep(j,MAX)rep(k,MAX)mincost[j][k] = min(mincost[j][k],mincost[j][i]+mincost[i][k]);\n\n\tps.clear();\n\tps.resize(L);\n\trep(i,L)cin >> ps[i].first >> ps[i].second;\n\tV = L;\t  \n\n\tint st = MAX-2,ed = MAX-1;\n\trep(i,V)        add_edge(st,i,inf);\n\trep(i,V)rep(j,V)if(i != j && ps[i].second+mincost[i][j] <= ps[j].second)add_edge(i,V+j,1);\n\trep(i,V)        add_edge(V+i,ed,1);\n\t/*\n\trep(i,2*N)\n\t  {\n\t    cout << \"start \" << i << endl;\n\t    rep(j,G[i].size())\n\t      {\n\t\tcout << \"(\" << G[i][j].to << \",\" << G[i][j].cap << \") \";\n\t      }\n\t    cout << endl;\n\t  }\n\t*/\n\tcout << N-max_flow(st,ed) << endl;\n\n      }\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge\n{\n    int to,cap,rev;\n};\n\nconst int MAX_N = 102;\n\nint d[MAX_N][MAX_N];\nvector<edge> G[MAX_N];\nint level[MAX_N];\nint iter[MAX_N];\nint n,m,L;\n\nvoid warshall_floyd()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,n){\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> L;\n        if(n == 0 && m == 0 && L == 0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = INF;\n            }\n        }\n        rep(i,m){\n            int x,y,z;\n            cin >> x >> y >> z;\n            d[x][y] = z;\n            d[y][x] = z;\n        }\n        vector<int> p(L),t(L);\n        rep(i,L){\n            cin >> p[i] >> t[i];\n        }\n        warshall_floyd();\n        rep(i,2*L+2){\n            G[i].clear();\n        }\n        rep(i,L){\n            rep(j,L){\n                if(t[i] + d[p[i]][p[j]] <= t[j]){\n                    add_edge(i,L+j+1,INF);\n                }\n            }\n        }\n        rep(i,L){\n            add_edge(0,i,1);\n            add_edge(L+i+1,2*L+1,1);\n        }\n        cout << L - max_flow(0,2*L+1) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++) if(pathParent[i] >= 0) printf(\"%d -> %d\\n\",pathParent[i],i);\n  printf(\"\\n\");\n  for(i=0;i<l;i++) printf(\"%3d\",pathParent[i]);\n  printf(\"\\n\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    //printf(\"tmp: %d -> %d\\n\",i,child);\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++) find(i);\n  for(int i=0;i<l;i++) if(pathParent[i]<0) num++;\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  int res = num_covers();\n  //print_setting();//設定表示  \n  return res;\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <limits>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n#define   min_int(a,b)  ( ((a)<(b) ) ? (a) : (b) )\nusing namespace std;\nclass Req{\npublic:\n  char house;\n  int time;\n};\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\nint dist[max_n][max_n];\nReq reqs[max_l];\n//????????¨??????x???????????????????????¨??????y????????????????????????????????°?????????DAG???\nint req_graph[max_l][max_l];\nint num_child[max_l];//???????????¨??????x???????????°\nint parent[max_l]; //?¢??????????????????????????????¨??????x??????\nint till[max_l];\nbool visited[max_l];\nint halfmax = (numeric_limits<int>::max())/2;\n  \n//????????????????????????????????¢????????????dist????¨????\nvoid compute_dist(){\n  register int i,j,k;\n    \n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        dist[i][j] = min_int(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        dist[i][j] = min_int(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graph????§????\nvoid compute_req_graph(){\n  int i,j,h1,h2;\n  \n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++) for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] != halfmax) //h1???h2??????????????????\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n  } \n}\n  \nint find(int i, bool root){\n  int child, x, found;\n  //????¨???????????????????????????¢???\n  visited[i] = true;  \n  if(till[i] < num_child[i]){    \n    while((++(till[i])) < num_child[i]){\n      child = req_graph[i][till[i]];\n      if(parent[child] >= 0) continue;\n      parent[child] = i; //child?????????????????¨??????\n      return child;\n    }\n  }\n  //???????????????????¨?????????£???????????????????????¢???  \n  for(int j = 0;j < num_child[i]; j++){\n    child = req_graph[i][j];\n    x = parent[child]; //x: child??????????????????\n    if(visited[x]) continue;\n    found = find(x,false); //x??????child???????¨???????????????????\n    if(found < 0) continue;\n    parent[child] = i; //child???????¨???????\n    return child;\n  }\n  return -1;\n}\n//req_graph??????????¢????????±????????¢??????°????????????\nint num_covers(){\n  int num=0;\n  memset(till,-1,l*sizeof(int));\n  memset(parent,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    memset(visited,0,l*sizeof(bool));\n    find(i,true);\n  }\n  for(int i=0;i<l;i++) if(parent[i]<0) num++;\n  return num;\n}\n  \n//?????¬?????????????????????????????????????????°?????????????????¢??°\nint santas(){\n  int u,v,d,i,j;\n  //??\\???????????????\n  for(i=0;i<n;i++) dist[i][i] = 0;\n  for(i=0;i<n;i++) for(j=i+1;j<n;j++) dist[i][j] = halfmax;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//????????????house?????????????????¢????????????dist????¨????\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graph????§????\n  int res = num_covers();\n  return res;\n}\n  \n//??\\??????????????¢??°\nint main(){\n  while(1){    \n    scanf(\"%d%d%d\",&n,&m,&l);\n    if((n == 0) && (m == 0) && (l == 0)) break;    \n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n       if(d>0){\n         e.cap-=d;\n         G[e.to][e.rev].cap+=d;\n         return d;\n       }\n      }\n    }\n    return 0;\n  }\n  \n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n       fl+=f;\n       lim-=f;\n      }\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(int s,int t,int from, int to){\n    for(int i=0;i<(int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n        if(e.cap==0&&flow(from,to,1)==0) {\n          flow(from,s,1);\n          flow(t,to,1);\n          return 1;\n        }\n      }\n    }\n    return 0;\n  }\n};\n\nint n,a[101][101],a1,a2,a3,p[1001],t[1001],m,m2;\n\nint main(){\nwhile(1){\n  r(i,101)r(j,101)a[i][j]=(i==j?0:1e8);\n  cin>>n>>m>>m2;\n  if(n==0)return 0;\n  r(i,m){\n    cin>>a1>>a2>>a3;\n    a[a2][a1]=a[a1][a2]=a3;\n  }\n  r(i,m2)cin>>p[i]>>t[i];\n  r(k,n)r(i,n)r(j,n)a[i][j]=min(a[i][j],a[i][k]+a[k][j]);\n  Dinic D(m2*2+2);\n  r(i,m2){\n    r(j,m2)if(i!=j){\n      if(a[p[i]][p[j]]+t[i]<=t[j]){\n        D.add_edge(i,j+m2,1);\n      }\n    }\n  }\n  r(i,m2)D.add_edge(m2*2,i,1);\n  r(i,m2)D.add_edge(i+m2,m2*2+1,1);\n  cout<<m2-D.flow(m2*2,m2*2+1,1e8)<<endl;\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll INF=1e16;\nstruct edge {int to; long long int cap; int rev;} ;\n \nvector<edge> G[2010];\nint level[2010];\nint iter[2010];\n \nvoid add_edge(int from, int to, long long int cap){\n\tedge e;\n\te.to=to, e.cap=cap, e.rev=G[to].size();\n\tG[from].push_back(e);\n\te.to=from, e.cap=0, e.rev=G[from].size()-1;\n\tG[to].push_back(e);\n}\n \nvoid bfs(int s){\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0; i<G[v].size(); i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n \nlong long int dfs(int v, int t, long long int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v]; i<G[v].size(); i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tlong long int d=dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nlong long int max_flow(int s, int t){\n\tlong long int flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlong long int f;\n\t\twhile((f=dfs(s, t, INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\nint n, m, l;\nll d[101][101];\nvoid init(){\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(i==j) d[i][j]=0;\n            else d[i][j]=INF;\n        }\n    }\n    for(int i=0; i<2010; i++){\n        G[i].clear();\n    }\n}\nint main()\n{\n    while(1){\n        cin>>n>>m>>l;\n        if(n==0) return 0;\n        init();\n        for(int i=0; i<m; i++){\n            int u, v, d0; cin>>u>>v>>d0;\n            d[u][v]=d[v][u]=d0;\n        }\n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    d[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n                }\n            }\n        }\n        int p[1010]; ll t[1010];\n        for(int i=0; i<l; i++){\n            cin>>p[i]>>t[i];\n        }\n        for(int i=0; i<l; i++){\n            for(int j=0; j<l; j++){\n                if(i==j) continue;\n                if(t[i]+d[p[i]][p[j]]<=t[j]){\n                    add_edge(i, j+l, 1);\n                }\n            }\n        }\n        int S=2*l, T=2*l+1;\n        for(int i=0; i<l; i++){\n            add_edge(S, i, 1);\n            add_edge(i+l, T, 1);\n        }\n        cout<<l-max_flow(S, T)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=false;\n    int N;\n    Graph g;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push(make_pair(Weight(0),s));\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push(make_pair(dist[e.to],e.to));\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nconst int INF=1e9;\nconst int LSIZE=1000;\nstruct Query{\n    int p,t;\n};\nbool operator<(Query lhs,Query rhs){\n    return lhs.t<rhs.t;\n}\nint solve(int n,int m,int l){\n    vector<vector<int>> d(n,vector<int>(n,INF));    \n    for(int i=0;i<n;i++) d[i][i]=0;\n\n    for(int i=0;i<m;i++){\n        int u,v,tmp;\n        cin>>u>>v>>tmp;\n        d[u][v]=d[v][u]=tmp;\n    }  \n    vector<Query> q(l);\n    for(int i=0;i<l;i++) cin>>q[i].p>>q[i].t;\n    sort(q.begin(),q.end());\n    \n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n    using Bit=bitset<LSIZE>;\n    vector<Bit> reachable(l);\n    vector<pair<int,int>> dag;\n    for(int i=l-1;i>=0;i--){\n        for(int j=i+1;j<l;j++){\n            if(reachable[i][j]) continue;\n            if(q[j].t-q[i].t>=d[q[i].p][q[j].p]){\n                reachable[i][j]=true;\n                reachable[i]|=reachable[j];\n                dag.push_back(make_pair(i,j));\n            }\n        }\n    }\n\n    Flow flow(2*l+4);\n    const int S0=2*l;\n    const int S1=2*l+1;\n    const int T1=2*l+2;\n    const int T0=2*l+3;\n    auto in=[&](int x){return x;};\n    auto out=[&](int x){return l+x;};\n\n    const int A=0;\n    const int B=1;\n    const int C=10;\n    flow.addEdge(S0,S1,n,0);\n    flow.addEdge(T1,T0,n,0);\n    for(int i=0;i<l;i++){\n        flow.addEdge(S1,in(i),n,B);\n    }\n    flow.addEdge(S1,T1,n,A);\n    for(auto e:dag){\n        flow.addEdge(out(e.first),in(e.second),n,0);\n    }\n    for(int i=0;i<l;i++){\n        flow.addEdge(in(i),out(i),n,0);\n    }\n    for(int i=0;i<l;i++){\n        flow.addEdge(out(i),in(i),1,C);\n        flow.addEdge(S0,out(i),1,0);\n        flow.addEdge(in(i),T0,1,0);\n    }\n    for(int i=0;i<l;i++){\n        flow.addEdge(out(i),T1,n,0);\n    }\n    int sumc=flow.minCostFlow(S0,T0,n+l);\n    sumc-=C*l;\n    int res=sumc+C*l-A*n;\n    cout<<res<<endl;\n\n    return 0;\n}\n\nint main(){\n    int n,m,l;\n    while(cin>>n>>m>>l,n){\n        solve(n,m,l);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nbool G[1000][1000];\nint match[1000];\nbool used[1000];\n\nstruct BipartiteMatching {\n\tint V;\n\n\tBipartiteMatching(int v) {\n\t\tV = v;\n\t}\n\n\tvoid add_edge(int v, int u) {\n\t\tG[v][u] = G[u][v] = true;\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < V; i++) {\n\t\t\tif(!G[v][i]) continue;\n\t\t\tint u = i, w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint calc() {\n\t\tint res = 0;\n\t\tfill(match, match + V, -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used, used + V, false);\n\t\t\t\tif(dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef long long ll;\nconst ll INF = 1LL << 50;\nll wf[100][100];\nint p[1000];\nll t[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, L;\n\twhile(cin >> N >> M >> L, N) {\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, d;\n\t\t\tcin >> u >> v >> d;\n\t\t\twf[u][v] = wf[v][u] = d;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++)\n\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tBipartiteMatching bp(2 * L);\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tG[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++) {\n\t\t\tfor(int j = 0; j < L; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint u = p[i], v = p[j];\n\t\t\t\tif(t[i] + wf[u][v] <= t[j]) {\n\t\t\t\t\tbp.add_edge(i, j + L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << L - bp.calc() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <cstdarg>\n#include <sys/time.h>\n#include <fstream>\n//#include \"cout.h\"\n\nusing namespace std;\n\n#define SZ(x) ((int)x.size())\n#define MSET(x,a) memset(x, a, (int)sizeof(x))\n#define PB push_back\n#define VI vector < int >\n#define PII pair < int, int >\n#define LL long long\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(), (v).end()\n#define FIT(it,v) for (typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define OUT(A) cout << #A << \" = \"<< (A) << endl\n#define OUT2(A, B) cout << \"(\" << #A << \", \" << #B << \") = (\" << (A) << \", \"<< (B) << \")\" << endl\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } \ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } \n\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n\n\n\n\n    const int MAX_V = 2010;\n    \n    int V; // 左の頂点数。忘れずに設定すること。\n    // ちなみに、Vは左右合わせた全部の頂点数でも問題ない。（左が終わった後に右からのをチェックしても、マッチ数は絶対増えない）\n    \n    \n    VI G[MAX_V]; // ちゃんとGもケースごとに全部clear。\n    int match[MAX_V];\n    bool used[MAX_V];\n    \n    void add_edge(int u, int v){\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n    \n    bool dfs(int v){\n        used[v] = true;\n        REP(i, SZ(G[v])){\n            int u = G[v][i], w = match[u];\n            if(w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    int bipartite_matching(){\n        int res = 0;\n        MSET(match, -1);\n        REP(v, V){\n            if(match[v] < 0){\n                MSET(used, 0);\n                if(dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n    \n    \n    \nint INF = (1<<29);\n\nint n, m, l;\nint g[110][110];\nint p[1010], t[1010];\n\nvoid init() {\n}\n\nvoid input() {\n\tREP(i, 110) REP(j, 110) g[i][j] = INF;\n\tREP(i, n) g[i][i] = 0;\n\tREP(i, m){\n\t\tint u, v, d;\n\t\tcin >> u >> v >> d;\n\t\tg[u][v] = d, g[v][u] = d;\n\t}\n\tREP(k, n) REP(i, n) REP(j, n) chmin(g[i][j], g[i][k]+g[k][j]);\n\tREP(i, l) cin >> p[i] >> t[i];\n}\n\nvoid solve() {\n\tV = l*2;\n\tREP(i, V) G[i].clear();\n\tREP(i, l) REP(j, l) if(i != j){\n\t\tif(t[i] + g[p[i]][p[j]] <= t[j]) add_edge(i, j+l);\n\t\tif(t[j] + g[p[j]][p[i]] <= t[i]) add_edge(j, i+l);\n\t}\n\tcout << l - bipartite_matching() << endl;\n}\n\nint main() {\n\tinit();\n\twhile(cin >> n >> m >> l){\n\t\tif(n == 0) break;\n\t\tinput();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool BFS(const Graph& g,const vi& side,const vi& match,vi& level)\n{\n\tint n=g.size();\n\tlevel.assign(n,n);\n\tqueue<pii> q;\n\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\tq.push(mp(i,0));\n\tbool res=false;\n\twhile(!q.empty()){\n\t\tpii cur=q.front(); q.pop();\n\t\tint u=cur.first,l=cur.second;\n\t\tif(level[u]<=l) continue;\n\t\tlevel[u]=l;\n\t\trep(i,g[u].size()){\n\t\t\tint v=g[u][i].dst;\n\t\t\tif(match[v]==-1)\n\t\t\t\tres=true;\n\t\t\telse\n\t\t\t\tq.push(mp(match[v],l+2));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool DFS(const Graph& g,const vi& side,int u,vi& match,vi& level)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(match[v]==-1 || level[match[v]]>level[u] && DFS(g,side,match[v],match,level)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\tlevel[u]=-1;\n\treturn false;\n}\n\nint HopcroftKarp(const Graph& g,const vi& side,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\tfor(vi level;BFS(g,side,match,level);)\n\t\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\t\tres+=DFS(g,side,i,match,level);\n\treturn res;\n}\n\nint MinPathCover(const Graph& g)\n{\n\tint n=g.size();\n\tGraph bg(2*n);\n\trep(i,n) foreach(e,g[i])\n\t\tbg[e->src].push_back(Edge(e->src,n+e->dst));\n\tvi side(2*n),match(2*n);\n\tfill(n+all(side),1);\n\treturn n-HopcroftKarp(bg,side,match);\n}\n\nint main()\n{\n\tfor(int n,m,l;cin>>n>>m>>l,n|m|l;){\n\t\tvvi dist(n,vi(n,INFTY));\n\t\trep(i,n) dist[i][i]=0;\n\t\trep(i,m){\n\t\t\tint u,v,d; cin>>u>>v>>d;\n\t\t\tdist[u][v]=dist[v][u]=d;\n\t\t}\n\t\tvi ps(l),ts(l);\n\t\trep(i,l) cin>>ps[i]>>ts[i];\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\t\tGraph g(l);\n\t\trep(i,l) rep(j,l) if(i!=j){\n\t\t\tint u=ps[i],v=ps[j];\n\t\t\tif(ts[i]+dist[u][v]<=ts[j])\n\t\t\t\tg[i].push_back(Edge(i,j));\n\t\t}\n\t\tcout<<MinPathCover(g)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Edge(int src, int dst) :\n    src(src), dst(dst) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\nint adj[100][100];\nint p[1000],t[1000];\n\nint main() {\n  int n,m,l;\n  while(cin>>n>>m>>l,n||m||l) {\n    REP(i,n)REP(j,n)adj[i][j]=INF;\n    REP(i,m) {\n      int u,v,d;\n      cin>>u>>v>>d;\n      adj[u][v] = min(adj[u][v],d);\n      adj[v][u] = adj[u][v];\n    }\n    REP(k,n)REP(i,n)REP(j,n) {\n      adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);\n    }\n    Graph g(2*l);\n    REP(i,l) {\n      cin>>p[i]>>t[i];\n    }\n    REP(i,l) {\n      REP(j,l) {\n        if (i==j) continue;\n        if (adj[p[i]][p[j]] <= t[j]-t[i]) {\n          g[i].push_back(Edge(i,l+j));\n          g[l+j].push_back(Edge(l+j,i));\n        }\n      }\n    }\n    Edges e;\n    cout << l - bipartiteMatching(g, l, e) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\nconst Int inf = 1<<22;\n\nconst int nsize = 101;\nconst int msize = 1001;\nconst int lsize = 1001;\nint N, M, L;\nInt D[nsize][nsize];\nInt P[lsize];\nInt T[lsize];\nInt E[nsize][nsize];\nint EC[nsize];\n\nvoid init() {\n    for ( int i = 0; i < nsize; i++ ) {\n        for ( int j = 0; j < nsize; j++ ) {\n            D[i][j] = i==j?0:inf;\n        }\n    }\n    for ( int i = 0; i < nsize; i++ ) {\n        EC[i] = 0;\n    }\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n//\nint main() {\n    while ( cin >> N >> M >> L ) {\n        if ( N == 0 && M == 0 && L == 0 ) break;\n        init();\n\n        for ( int i = 0; i < M; i++ ) {\n            int u, v, d;\n            cin >> u >> v >> d;\n            D[u][v] = D[v][u] = d;\n        }\n        for ( int i = 0; i < L; i++ ) {\n            int p, t;\n            cin >> p >> t;\n            P[i] = p;\n            T[i] = t;\n        }\n\n        // wf\n        for ( int k = 0; k < N; k++ ) {\n            for ( int i = 0; i < N; i++ ) {\n                for ( int j = 0; j < N; j++ ) {\n                    D[i][j] = min( D[i][j], D[i][k] + D[k][j] );\n                }\n            }\n        }\n\n        Graph g( 2*L );\n        for ( int i = 0; i < L; i++ ) {\n            for ( int j = 0; j < L; j++ ) {\n                if ( i == j ) continue;\n                if ( T[i] + D[P[i]][P[j]] <= T[j] ) {\n                    g[i].push_back( Edge( i, j+L, 1 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        int answer = L - bipartiteMatching( g, L, edges );\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF = 1e9;\n\nvoid dfs(vector< vector<int> > &G, vector<bool> &visited, int v){\n  visited[v] = true;\n  for(int i = 0; i < G[v].size(); ++i){\n    if(visited[G[v][i]]) continue;\n    dfs(G, visited, G[v][i]);\n    break;\n  }\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L, N){\n    vector< vector<int> > D(N, vector<int>(N, INF));\n    for(int i = 0; i < M; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      D[u][v] = d;\n      D[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) D[i][i] = 0;\n    for(int k = 0; k < N; ++k){\n      for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n    vector< pair<int,int> > V;\n    for(int i = 0; i < L; ++i){\n      int p, t;\n      cin >> p >> t;\n      V.emplace_back(t, p);\n    }\n    sort(V.begin(), V.end());\n    vector< vector<int> > G(L);\n    for(int i = 0; i < L; ++i){\n      for(int j = 0; j < i; ++j){\n        int p_i = V[i].second, t_i = V[i].first, p_j = V[j].second, t_j = V[j].first;\n        if(D[p_i][p_j] <= t_i - t_j) G[j].push_back(i);\n      }\n    }\n    vector<bool> visited(L, false);\n    int ans = 0;\n    for(int i = 0; i < L; ++i){\n      if(visited[i]) continue;\n      ++ans;\n      dfs(G, visited, i);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,l;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[3005];\nbool used[3005];\nint E[105][105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nint p[1005],t[1005];\nint main(){\n\twhile(1){\n\t\tcin >> n >> m >> l;\n\t\tif(n==0) return 0;\n\t\trep(i,105) rep(j,105){\n\t\t\tE[i][j] = INF;\n\t\t\tif(i==j) E[i][j] = 0;\n\t\t}\n\t\trep(i,1005){\n\t\t\tG[i].clear(); used[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tE[u][v] = E[v][u] = d;\n\t\t}\n\t\tfor(int i=0;i<l;i++) cin >> p[i] >> t[i];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tE[j][k] = min(E[j][k],E[j][i]+E[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(t[i]+E[p[i]][p[j]] <= t[j]){\n\t\t\t\t\tadd_edge(i,j+1005,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++) add_edge(2301,i,1);\n\t\tfor(int i=0;i<l;i++) add_edge(i+1005,2302,1);\n\t\tcout << l-max_flow(2301,2302) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 1000;\nconst int MAX_L = 1000;\nconst int MAX_GN = MAX_L * 2 + 2;\nconst int INF = 1 << 29;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\nint n, m, l;\nint dists[MAX_N][MAX_N];\npii reqs[MAX_L];\nvi nbrs[MAX_L];\nbool used[MAX_L];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m >> l;\n    if (n == 0) break;\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) dists[i][j] = INF;\n      dists[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n      int u, v, d;\n      cin >> u >> v >> d;\n      dists[u][v] = dists[v][u] = d;\n    }\n\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n\tfor (int j = 0; j < n; j++)\n\t  dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j]);\n\n    for (int i = 0; i < l; i++)\n      cin >> reqs[i].second >> reqs[i].first;\n    sort(reqs, reqs + l);\n    \n    for (int i = 0; i < l; i++) nbrs[i].clear();\n    \n    for (int i = 0; i < l; i++) {\n      pii& ri = reqs[i];\n      for (int j = i + 1; j < l; j++) {\n\tpii& rj = reqs[j];\n\tif (dists[ri.second][rj.second] + ri.first <= rj.first)\n\t  nbrs[i].push_back(j);\n      }\n    }\n    \n    memset(used, false, sizeof(used));\n    int nu = 0;\n    \n    for (int i = 0; i < l; i++)\n      if (! used[i]) {\n\tused[i] = true;\n\tnu++;\n\t\n\tfor (int u = i; u >= 0;) {\n\t  int k = -1;\n\t  vi& nbru = nbrs[u];\n\t  for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\t    int& v = *vit;\n\t    if (! used[v]) {\n\t      used[v] = true;\n\t      k = v;\n\t      break;\n\t    }\n\t  }\n\t  u = k;\n\t}\n      }\n\n    cout << nu << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <valarray>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int INF = 10000000;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow capacity, flow;\n    Cost cost;\n    Edge *back;\n    Edge() {}\n    Edge(int from, int to, Flow c, Cost d, Edge *b) : from(from), to(to), capacity(c), flow(0), cost(d), back(b) {}\n};\nEdge<int,int> _buf[(1000*1000 + 1000 + 100) * 2];\nint _bp;\n\ntemplate<class Flow, class Cost>\nvoid make_edge(vector<vector<Edge<Flow,Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    _buf[_bp] = Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    auto *e = &_buf[_bp];\n    _buf[_bp+1] = Edge<Flow,Cost>(dst, src, 0, -d, e);\n    auto *back = e->back = &_buf[_bp+1];\n    _bp += 2;\n    g[src].push_back(e);\n    g[dst].push_back(back);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> h(N), dist(N);\n    vector<Edge<Flow,Cost>*> parent(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        dist[src] = 0;\n        fill(parent.begin(), parent.end(), nullptr);\n        priority_queue<pair<Cost,int>> q;\n        q.push(make_pair(0, src));\n        while(!q.empty()) {\n            const int n = q.top().second;\n            const Cost c = -q.top().first;\n            q.pop();\n            if(dist[n] < c) {\n                continue;\n            }\n            for(auto e : g[n]) {\n                if(e->capacity - e->flow > 0) {\n                    const Cost c2 = c + e->cost + h[n] - h[e->to];\n                    if(c2 < dist[e->to]) {\n                        dist[e->to] = c2;\n                        parent[e->to] = e;\n                        q.push(make_pair(-c2, e->to));\n                    }\n                }\n            }\n        }\n        if(parent[sink] == nullptr) {\n            break;\n        }\n\n        Flow to_push = f;\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            to_push = min(to_push, e->capacity - e->flow);\n        }\n        for(int i = sink; i != src; i = parent[i]->from) {\n            auto e = parent[i];\n            res.second += to_push * e->cost;\n            e->flow += to_push;\n            e->back->flow -= to_push;\n        }\n        f -= to_push;\n        res.first += to_push;\n        for(int i = 0; i < N; ++i) {\n            h[i] += dist[i];\n        }\n    }\n    return res;\n}\n\nbool solve() {\n    int N, M, L;\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    vector<vector<int>> dist(N, vector<int>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = dist[v][u] = d;\n    }\n    for(int i = 0; i < N; ++i) {\n        dist[i][i] = 0;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(dist[i][k] == -1 || dist[k][j] == -1) continue;\n                const int d = dist[i][k] + dist[k][j];\n                if(dist[i][j] == -1 || dist[i][j] >= d) dist[i][j] = d;\n            }\n        }\n    }\n\n    _bp = 0;\n    vector<vector<Edge<int,int>*>> graph(L*2+2);\n    const int SRC = L*2;\n    const int SINK = SRC+1;\n    vector<pair<LL,int>> queries(L);\n    for(int i = 0; i < L; ++i) {\n        cin >> queries[i].second >> queries[i].first;\n    }\n    sort(queries.begin(), queries.end());\n    for(int i = 0; i < L; ++i) {\n        const int in_node = i*2;\n        const int out_node = i*2+1;\n        make_edge(graph, SRC, in_node, 1, 0);\n        make_edge(graph, in_node, out_node, 1, 0);\n        make_edge(graph, out_node, SINK, INF, 0);\n        const int ni = queries[i].second;\n        for(int j = i+1; j < L; ++j) {\n            const int nj = queries[j].second;\n            if(dist[ni][nj] != -1 && queries[j].first - queries[i].first >= dist[ni][nj]) {\n                //cout << queries[i].second << ' ' << queries[j].second << endl;\n                make_edge(graph, out_node, j*2, 1, -1);\n            }\n        }\n    }\n    make_edge(graph, SRC, SINK, INF, 0);\n    const auto res = primal_dual(graph, SRC, SINK, L);\n    cout << L + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=1010;\n\nint X,Y;\nvector<int> graph[vmax];\nint match[vmax];\nbool used[vmax];\n\nbool dfs(int v){\n\tused[v]=true;\n\tfor(auto &u:graph[v]){\n\t\tint w=match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w)) ){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res=0;\n\trep(i,vmax) match[i]=-1;\n\trep(v,X+Y){\n\t\tif(match[v]<0){\n\t\t\trep(i,vmax) used[i]=0;\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint n,m,l;\nint dist[110][110];\npair<int,int> info[1010];\n\nint main(void){\n\twhile(cin >> n >> m >> l){\n\t\tif(n==0) break;\n\t\trep(i,vmax) graph[i].clear();\n\t\trep(i,n)rep(j,n) dist[i][j]=((i==j)?0:1<<20);\n\t\trep(i,m){\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v]=min(dist[u][v],d);\n\t\t\tdist[v][u]=min(dist[v][u],d);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\n\t\trep(i,l) cin >> info[i].second >> info[i].first;\n\t\tsort(info,info+l);\n\t\tX=Y=l-1;\n\t\trep(i,l-1)rep(j,l-1){\n\t\t\tif(i>j) continue;\n\t\t\tint a=i,b=j+1;\n\t\t\tif(dist[info[b].second][info[a].second]>info[b].first-info[a].first) continue;\n\t\t\tb+=X-1;\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t\tcout << l-bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\ntypedef vector<vector<edge>> Graph;\nconstexpr int MAX_V = 2002;\n\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(Graph& G,int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(Graph &G,int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(Graph &G,int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(G,e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(Graph &G,int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(G,s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(G,s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tGraph g(2*l+2);\n\t\tvvi v(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi p(l), t(l);\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(g,i + 1, j + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(g,0, i + 1, 1);\n\t\tREP(i, l)add_edge(g,i + l + 1, 2 * l + 1, 1);\n\t\tcout << l - max_flow(g,0, 2 * l + 1) << endl;\n\t\tREP(i, MAX_V) {\n\t\t\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool BFS(const Graph& g,const vi& side,const vi& match,vi& level)\n{\n\tint n=g.size();\n\tlevel.assign(n,n);\n\tqueue<pii> q;\n\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\tq.push(mp(i,0));\n\tbool res=false;\n\twhile(!q.empty()){\n\t\tpii cur=q.front(); q.pop();\n\t\tint u=cur.first,l=cur.second;\n\t\tif(level[u]<=l) continue;\n\t\tlevel[u]=l;\n\t\trep(i,g[u].size()){\n\t\t\tint v=g[u][i].dst;\n\t\t\tif(match[v]==-1)\n\t\t\t\tres=true;\n\t\t\telse\n\t\t\t\tq.push(mp(match[v],l+2));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool DFS(const Graph& g,const vi& side,int u,vi& match,vi& level)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(match[v]==-1 || level[match[v]]>level[u] && DFS(g,side,match[v],match,level)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\tlevel[u]=-1;\n\treturn false;\n}\n\nint HopcroftKarp(const Graph& g,const vi& side,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\tfor(vi level;BFS(g,side,match,level);)\n\t\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\t\tres+=DFS(g,side,i,match,level);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m,l;cin>>n>>m>>l,n|m|l;){\n\t\tvvi dist(n,vi(n,INFTY));\n\t\trep(i,n) dist[i][i]=0;\n\t\trep(i,m){\n\t\t\tint u,v,d; cin>>u>>v>>d;\n\t\t\tdist[u][v]=dist[v][u]=d;\n\t\t}\n\t\tvi ts(n,-1);\n\t\trep(i,l){\n\t\t\tint v,t; cin>>v>>t;\n\t\t\tts[v]=t;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\t\tGraph g(2*n);\n\t\trep(i,n) rep(j,n){\n\t\t\tif(i==j || ts[i]==-1 || ts[j]==-1) continue;\n\t\t\tif(ts[i]+dist[i][j]<=ts[j])\n\t\t\t\tg[i].emplace_back(i,n+j);\n\t\t}\n\t\t\n\t\tvi side(2*n),match(2*n);\n\t\tfill(n+all(side),1);\n\t\tcout<<n-HopcroftKarp(g,side,match)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <limits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n        pa[s]=dag[s][i],pa[dag[s][i]]=s;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  while(cin>>N>>M>>L,N){\n    int d[N][N];\n    rep(i,N)rep(j,N)d[i][j]=(numeric_limits<int>::max()-1)/2;\n    rep(i,N)d[i][i]=0;\n    rep(i,M){\n      int u,v,w; cin>>u>>v>>w;\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L],t[L];\n    rep(i,L)cin>>p[i]>>t[i];\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?(d[i][k]+d[k][j]):d[i][j];\n    vector<int> dag[L];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[i].push_back(j);}\n\n    int num=L;\n    int pa[L]; memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[L]; memset(v,0,sizeof(v));\n      if(dfs(i,v,pa,dag)){num--;}\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector> \n#include<utility>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define ft first\n#define sd second\n#define MAX 1000*2+16 \nvector<int> arr[MAX];\nint x[MAX],vis[MAX];\nint dist[105][105];\nint N,M,L;\nvoid floyd()\n{\n\tint k,i,j;\n\tfor(i=0;i<N;i++)\n\t\tdist[i][i]=0;\n\tfor(k=0;k<N;k++)\n\t\tfor(i=0;i<N;i++)\n\t\t\tfor(j=0;j<N;j++)\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\t\t\t\t\n}\n\nint dfs(int v)\n{\n\tvis[v]=1;\n\tfor(int i=0;i<arr[v].size();i++)\n\t{\n\t\tint m=arr[v][i];\n\t\tint w=x[m];\n\t\tif(w<0||(!vis[w]&&dfs(w)))\n\t\t{\n\t\t\tx[v]=m;\n\t\t\tx[m]=v;\n\t\t\treturn 1;\n\t\t}\t\n\t}\n\treturn 0;\n}\nint V;\nint solve()\n{\n\tint ans=0;\n\tmemset(x,-1,sizeof(x));\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tif(x[i]<0)\n\t\t{\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tans+=dfs(i);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid add(int u,int v)\n{\n\tarr[u].push_back(v);\n\tarr[v].push_back(u);\n}\nint p[1050],t[1050]; \nint main()\n{\n\twhile(scanf(\"%d%d%d\",&N,&M,&L)!=EOF&&N)\n\t{\n\t\tV=L*2;\n\t\tmemset(dist,INF,sizeof(dist));\n\t\tint i,m1,m2,m3;\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&m1,&m2,&m3);\n\t\t\tdist[m1][m2]=dist[m2][m1]=m3;\n\t\t}\n\t\tfloyd();\n\t\tfor(i=0;i<L;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&m1,&m2);\n\t\t\tp[i]=m1;\n\t\t\tt[i]=m2;\n\t\t}\n\t\tfor(i=0;i<L;i++)\n\t\t{\n\t\t\tfor(int j=0;j<L;j++)\n\t\t\t{\n\t\t\t\tif(i!=j&&dist[p[i]][p[j]]+t[i]<=t[j])\n\t\t\t\t{\n\t\t\t\t\tadd(i*2,2*j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",L-solve());\n\t\tfor(i=0;i<V;i++)arr[i].clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005,INF=1<<29;\nint dis[MAX][MAX];\n\nvoid floyd(int N){\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                chmin(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n}\n\nstruct edge{int to;ll cap;int rev;};\n\nvector<edge> G[MAX];\nint level[MAX];\nint iter[MAX];\n\nvoid add_edge(int from,int to,ll cap){\n    G[from].push_back((edge){to,cap,int(G[to].size())});\n    G[to].push_back((edge){from,0LL,int(G[from].size())-1});\n}\n\nvoid BFS(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s] =0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();que.pop();\n        for(int i=0;i<G[v].size();i++){\n            edge &e =G[v][i];\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll DFS(int v,int t,ll f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<G[v].size();i++){\n        edge &e =G[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            ll d= DFS(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(int s,int t){\n    ll flow=0;\n    for(;;){\n        BFS(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        ll f;\n        while((f=DFS(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M,Q;cin>>N>>M>>Q;\n        if(N+M+Q==0) break;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++) dis[i][j]=INF;\n            dis[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;cin>>a>>b>>c;\n            dis[a][b]=c;\n            dis[b][a]=c;\n        }\n        \n        floyd(N);\n        \n        vector<pair<int,int>> S(Q);\n        for(int i=0;i<Q;i++) cin>>S[i].fi>>S[i].se;\n        \n        for(int i=0;i<2*Q+2;i++){\n            G[i].clear();\n            level[i]=0;\n            iter[i]=0;\n        }\n        \n        for(int i=0;i<Q;i++){\n            for(int j=0;j<Q;j++){\n                if(i==j) continue;\n                if(dis[S[i].fi][S[j].fi]<=S[j].se-S[i].se){\n                    add_edge(i,Q+j,1);\n                }\n            }\n        }\n        \n        for(int i=0;i<Q;i++){\n            add_edge(2*Q,i,1);\n            add_edge(i+Q,2*Q+1,1);\n        }\n        \n        cout<<Q-max_flow(2*Q,2*Q+1)<<\"\\n\";\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nbool augment(int u,vector<bool> &visited,const vector< vector<int> > &adj,vector<int> match[2]){\n\tif(u==-1) return true;\n\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tif(augment(match[1][v],visited,adj,match)){\n\t\t\t\tmatch[0][u]=v;\n\t\t\t\tmatch[1][v]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint BipartiteMatching(const vector< vector<int> > &adj,int R){\n\tint L=adj.size();\n\n\tvector<int> match[2];\n\tmatch[0].assign(L,-1);\n\tmatch[1].assign(R,-1);\n\n\tint ans=0;\n\tvector<bool> visited(R);\n\trep(u,L){\n\t\trep(v,R) visited[v]=false;\n\t\tif(augment(u,visited,adj,match)) ans++;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m,l;scanf(\"%d%d%d\",&n,&m,&l),n;){\n\t\tstatic int dis[100][100];\n\t\trep(u,n) rep(v,n) dis[u][v]=(u==v?0:INF);\n\t\trep(i,m){\n\t\t\tint u,v,d; scanf(\"%d%d%d\",&u,&v,&d);\n\t\t\tdis[u][v]=dis[v][u]=d;\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) if(dis[i][k]+dis[k][j]<dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j];\n\n\t\tstatic int p[1000],t[1000];\n\t\trep(i,l) scanf(\"%d%d\",p+i,t+i);\n\n\t\tvector< vector<int> > adj(l);\n\t\trep(u,l) rep(v,l) if(u!=v) {\n\t\t\tif(t[u]+dis[p[u]][p[v]]<=t[v]) adj[u].push_back(v);\n\t\t}\n\n\t\tprintf(\"%d\\n\",l-BipartiteMatching(adj,l));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<set>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define INF (10000005)\n#define maxn 1015\nint n,m,l;\nint dis[maxn][maxn],mark[maxn],t[maxn],sum=0;\nbool vis[maxn],f[maxn][maxn];\nbool dfs(int i)\n{\n    for(int j=0;j<l;j++)\n    {\n        if(!vis[j]&&f[i][j])\n        {\n            vis[j]=1;\n            if(mark[j]==-1||dfs(mark[j]))\n            {\n                mark[j]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n\n}\nvoid solve()\n{\n    memset(mark,-1,sizeof(mark));\n    for(int i=0;i<l;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if(dfs(i))sum++;\n    }\n}\nvoid build()\n{\n    int i,j;\n    for(i=0;i<l;i++)\n    {\n        for(j=0;j<l;j++)\n        {\n            if(dis[i][j]!=INF&&i!=j)\n            if(t[i]+dis[i][j]<=t[j])\n            {\n                 f[i][j]=1;\n            }\n        }\n    }\n}\nvoid floyd()\n{\n    int k,i,j;\n    for(k=0;k<n;k++)\n    {\n        for(i=0;i<n;i++)\n            for(j=0;j<n;j++)\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n}\nvoid update(int si,int k,int x)\n{\n    for(int i=0;i<si;i++)\n        dis[i][k]=dis[k][i]=dis[x][i];\n}\nint main()\n{\n    \n     while(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n     {\n         if(!n&&!m&&!l)break;\n         int i,j;\n         memset(f,0,sizeof(f));\n         sum=0;\n         //printf(\"INF=%d\\n\",1<<30);\n         for(i=0;i<=l;i++)\n            for(j=0;j<=l;j++)dis[i][j]=INF;\n         for(i=1;i<=m;i++)\n         {\n             int x,y,w;\n             scanf(\"%d%d%d\",&x,&y,&w);\n             dis[x][y]=dis[y][x]=w;\n         }\n         floyd();\n         int k=0;\n         memset(t,-1,sizeof(t));\n         for(i=1;i<=l;i++)\n         {\n             int x,y;\n             scanf(\"%d%d\",&x,&y);\n             if(t[x]==-1)t[x]=y;\n             else {t[n+k]=y;update(n+k,n+k,x);k++;}\n\n         }\n         build();\n         solve();\n         //printf(\"sum=%d\\n\",sum);\n         printf(\"%d\\n\",l-sum);\n\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2010\n#define MAX_N 1010\nusing namespace std;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<l+l+2;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j&&tl[i]+g[idx[i]][idx[j]]<=tl[j])add_edge(i,l+j);\n    \n    V=l+l;\n    cout <<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n \n#define INF 100000000\n \nusing namespace std;\n \nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n \nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res=0;\n  fill(match,match+2001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+2001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n \nint main(void){\n \n  int n,m,l,u,v,d,graph[101][101],p[1001],t[1001];\n \n  while(cin >> n >> m >> l,n|m|l){  \n \n    for(int i=0;i<2001;i++)G[i].clear();\n \n    fill(graph[0],graph[101],INF);\n    for(int i=0;i<101;i++)graph[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      graph[u][v]=graph[v][u]=d;\n    }\n     \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n     \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n \n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[p[i]][p[j]]+t[i]<=t[j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nunsigned d[100][100];\n\nstruct node{\n\tint v,next;\n}e[2000];\nint v[2000],p[1000],t[1000],c[2000];\nbool f[2000];\n\nbool dfs(int n)\n{\n\tint i,j,k;\n\n\tf[n]=1;\n\tfor(i=v[n];i>=0;i=e[i].next)\n\t{\n\t\tif((k=c[j=e[i].v])<0||!f[k]&&dfs(k))\n\t\t{\n\t\t\tc[i]=j;\n\t\t\tc[j]=i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint func(int n)\n{\n\tint s=0,i;\n\n\tmemset(c,-1,sizeof(c));\n\tfor(i=0;i<n;i++)\n\t{\n\t\tif(c[i]<0)\n\t\t{\n\t\t\tmemset(f,0,sizeof(f));\n\t\t\tif(dfs(i))\n\t\t\t\ts++;\n\t\t}\n\t}\n\n\treturn s;\n}\n\nint main()\n{\n\tint n,m,l,i,j,k,w;\n\n\twhile(scanf(\"%d%d%d\",&n,&m,&l))\n\t{\n\t\tif(!m&&!n&&!l)\n\t\t\tbreak;\n\n\t\tmemset(d,-1,sizeof(d));\n\t\tfor(k=0;k<n;k++)\n\t\t\td[k][k]=0;\n\t\tfor(k=0;k<m;k++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&i,&j,&w);\n\t\t\td[i][j]=d[j][i]=w;\n\t\t}\n\t\tfor(k=0;k<n;k++)\n\t\tfor(i=0;i<n;i++)\n\t\tfor(j=0;j<n;j++)\n\t\tif(d[i][k]!=-1&&d[k][j]!=-1)\n\t\t\td[i][j]=d[i][k]+d[k][j]<d[i][j]?d[i][k]+d[k][j]:d[i][j];\n\n\t\tmemset(v,-1,sizeof(v));\n\t\tfor(k=0;k<l;k++)\n\t\t\tscanf(\"%d%d\",&p[k],&t[k]);\n\t\tfor(k=i=0;i<l;i++)\n\t\tfor(j=0;j<l;j++)\n\t\t{\n\t\t\tif(i!=j&&d[p[i]][p[j]]!=-1&&t[i]+d[p[i]][p[j]]<=t[j])\n\t\t\t{\n\t\t\t\te[k].v=j+l;\n\t\t\t\te[k].next=v[i];\n\t\t\t\tv[i]=k++;\n\t\t\t\te[k].v=i;\n\t\t\t\te[k].next=v[j+l];\n\t\t\t\tv[j+l]=k++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",l-func(2*l));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nstruct request{int num, time;}re[2009];\nvector<int> g[2009];\nint match[2009];\nbool used[2009];\nint n, m, l;\nint INF=999999999;\nint d[2009][2009];\nvoid add_edge(int u, int v)\n{\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0; i<g[v].size(); i++)\n    {\n        int u=g[v][i], w=match[u];\n        if(w<0 || !used[w] && dfs(w))\n        {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\nint bipartite_matching()\n{\n    int res=0;\n    memset(match, -1, sizeof(match));\n    for(int v=0; v<n; v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used, 0, sizeof(used));\n            if(dfs(v))\n                res++;\n        }\n    }\n    return res;\n}\nvoid Floyd()\n{\n    for(int k=0; k<n; k++)\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                d[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n}\nint main()\n{\n    printf(\"%d\", INF);\n    int f, t, dis;\n    while(~scanf(\"%d%d%d\", &n, &m, &l))\n    {\n        if(!(n+m+l)) break;\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                d[i][j]=INF;\n        for(int i=0; i<2009; i++)\n            g[i].clear();\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%d\", &f, &t, &dis);\n            d[f][t]=dis;\n            d[t][f]=dis;\n        }\n        for(int i=0; i<n; i++)\n        {\n            d[i][i]=0;\n        }\n        Floyd();\n        for(int i=0; i<l; i++)\n        {\n            scanf(\"%d%d\", &re[i].num, &re[i].time);\n        }\n        for(int i=0; i<l; i++)\n        {\n            for(int j=0; j<l; j++)\n            {\n                if(i==j) continue;\n                if(d[re[i].num][re[j].num]<=re[j].time-re[i].time)\n                {\n                    add_edge(i, j+n);\n                    printf(\"!%d %d\\n\", re[i].num, re[j].num);\n                }\n            }\n        }\n        printf(\"%d\\n\", l-bipartite_matching());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n \n#define INF 100000000\n \nusing namespace std;\n \nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  fill(match,match+2001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+2001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main(void){  \n  int n,m,l,u,v,d,dist[101][101],graph[1001][1001],p[1001],t[1001];\n  \n  while(cin >> n >> m >> l,n|m|l){  \n    \n    for(int i=0;i<2001;i++)G[i].clear();\n    \n    fill(dist[0],dist[101],INF);\n    fill(graph[0],graph[1001],0);\n    \n    for(int i=0;i<101;i++)dist[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      dist[u][v]=dist[v][u]=d;\n    }\n    \n    for(int i=0;i<l;i++)\n      cin >> p[i] >> t[i];\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j && dist[p[i]][p[j]]+t[i]<=t[j])\n\t  graph[i][j]=1;\n    \n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[i][j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst int MAX_V_flow = 2010;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , 0 , G[from].size()-1 ) );\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\tint ret = 0,d = 1;\n\t\twhile(d > 0){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\td = dfs(s,t,INF);\n\t\t\tret += d;\n\t\t}\n\t\treturn ret;\n\t}\n}flow;\n\nint n,m,l;\nint u[1002],v[1002],d[1002];\nint p[1002],t[1002];\nint dist[102][102];\n\nvoid init(){\n\tflow.init();\n\trep(i,102)rep(j,102)dist[i][j] = INF;\n\trep(i,102)dist[i][i] = 0;\n}\n\nint main(){\n\twhile(1){\n\t\tinit();\n\t\t\n\t\tscanf(\"%d%d%d\",&n,&m,&l);\n\t\tif(n == 0)break;\n\t\trep(i,m)scanf(\"%d%d%d\",&u[i],&v[i],&d[i]);\n\t\trep(i,l)scanf(\"%d%d\",&p[i],&t[i]);\n\t\t\n\t\trep(i,m){\n\t\t\tdist[u[i]][v[i]] = d[i];\n\t\t\tdist[v[i]][u[i]] = d[i];\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)dist[i][j] = min ( dist[i][j] , dist[i][k] + dist[k][j] );\n\t\t\n\t\trep(i,l){\n\t\t\tflow.add_edge( 2*l+1 , 2*i , 1 );\n\t\t\tflow.add_edge( 2*i+1 , 2*l , 1 );\n\t\t\trep(j,l){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(dist[p[i]][p[j]] <= t[j]-t[i]){\n\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\tflow.add_edge( 2*i , 2*j+1 , 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << l - flow.flow( 2*l+1 , 2*l ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint N,M,L;\n\nll W[111][111];\nconst ll INF = 100000000000000LL;\nP pt[1111];\nvector<int> G[2111];\n\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      W[i][j] = INF;\n  for(int i=0;i<N;i++)\n    W[i][i] = 0;\n  for(int i=0;i<=2*L;i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from,int to){\n  G[from].push_back( to );\n  G[to].push_back( from );\n}\n\nvoid wsf(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n        W[j][k] = min( W[j][k], W[j][i] + W[i][k] );\n}\n\n\nbool used[2111];\nint match[2111];\nint V;\n\nint dfs(int v){\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u = G[v][i], w = match[u];\n    if( w < 0 || (!used[w] && dfs(w)) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset( match, -1, sizeof(match) );\n  for(int v=0;v<V;v++){\n    if( match[v] < 0 ) {\n      memset( used, 0, sizeof ( used ) );\n      if( dfs( v ) ) res++;\n    }\n  }\n  return res;\n}\n\nint solve(){\n  return L - bipartite_matching();\n}\n\nint main(){\n  while( cin >>N >> M >> L && ( N||M||L ) ){\n    init();\n    for(int i=0;i<M;i++){\n      ll u,v,l; cin >> u >> v >> l;\n      W[u][v] = l;\n      W[v][u] = l;\n    }\n    wsf();\n    for(int i=0;i<L;i++){\n      int p,t; cin >> p >> t;\n      pt[i] = P( t, p );\n    }\n    sort(pt,pt+L);\n\n    for(int i=0;i<L;i++){\n      for(int j=i+1;j<L;j++){\n        ll len = W[pt[i].second][pt[j].second];\n        ll lt = pt[j].first - pt[i].first;\n        if( len <= lt )          \n          add_edge( i, L+j );\n      }\n    }\n    V = 2 * L;\n    cout << solve() << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1e9;\n\nvector<vector<int> > shortest_path(vector<vector<int> > &g)\n{\n\tvector<vector<int> > dist;\n\tconst int n = g.size();\n\n\tdist = g;\n\n\tfor(int k = 0; k < n; ++k) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nstruct bi_graph {\n\n\tvector<vector<int> > g;\n\n\tvoid init(int n)\n\t{\n\t\tg.resize(n);\n\t}\n\n\tvoid add_edge(int from, int to)\n\t{\n\t\tg[from].push_back(to);\n\t\tg[to].push_back(from);\n\t}\n\n\tbool inner_dfs(int v, vector<bool> &used, vector<int> &match)\n\t{\n\t\tused[v] = true;\n\n\t\tfor(int i = 0; i < g[v].size(); ++i) {\n\t\t\tint u = g[v][i], w = match[u];\n\t\t\tif(w < 0 || !used[w] && inner_dfs(w, used, match)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint bipartite_matching()\n\t{\n\t\tint res = 0;\n\t\tconst int n = g.size();\n\t\tvector<int> match(n, -1);\n\t\tvector<bool> used(n, false);\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif(inner_dfs(v, used, match))\n\t\t\t\t\tres += 1;\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\twhile(true) {\n\n\t\tint n, m, l;\n\t\tvector<pair<int, int> > pt;\n\t\tvector<vector<int> > dist, g;\n\t\tbi_graph bg;\n\n\t\tscanf(\"%d%d%d\", &n, &m, &l);\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tg.resize(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tg[i].resize(n, inf);\n\t\t\tg[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\t\tg[u][v] = g[v][u] = d;\n\t\t}\n\t\tpt.resize(l);\n\t\tfor(int i = 0; i < l; ++i)\n\t\t\tscanf(\"%d%d\", &pt[i].first, &pt[i].second);\n\n\t\tdist = shortest_path(g);\n\n\t\tbg.init(l * 2);\n\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\tfor(int j = 0; j < l; ++j) {\n\n\t\t\t\tif(i == j)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint u = pt[i].first;\n\t\t\t\tint v = pt[j].first;\n\t\t\t\tint dt = pt[j].second - pt[i].second;\n\n\t\t\t\tif(dist[u][v] <= dt)\n\t\t\t\t\tbg.add_edge(i * 2, j * 2 + 1);\n\t\t\t}\n\t\t}\n\n\t\tint ans = l - bg.bipartite_matching();\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <algorithm>\n#include <cstring>\n\n#define MAX_V 1001\n#define INF 1000000000\n\nvoid add_edge(int,int);\nbool dfs(int);\nint bipartite_matching(int);\nvoid warshall_floyd(int);\n\nusing namespace std;\n\nvector<int>G[MAX_V];\nbool used[MAX_V];\nint match[MAX_V],d[MAX_V][MAX_V];\n\n\n\nint main(void){\n  int n,m,l,p[MAX_V],t[MAX_V];\n\n  while(scanf(\"%d %d %d\",&n,&m,&l),n,m,l){\n    for(int i=0;i<MAX_V*2;i++)G[i].clear();\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  d[i][j]= i==j ?0:INF;\n\n      for(int i=0;i<m;i++){\n\t  int a,b,c; \n\t  scanf(\"%d %d %d\",&a,&b,&c);\n\t  d[a][b]=d[b][a]=c;\n\t}\n      warshall_floyd(n);\n\n      for(int i=0;i<l;i++)\n\tscanf(\"%d %d\",&p[i],&t[i]);\n\n      for(int i=0;i<l;i++){\n\tfor(int j=0;j<l;j++){\n\t  if(i==j)continue;\n\t  else if(t[i]+d[p[i]][p[j]]<=t[j])\n\t    add_edge(i,j+l);\n\t}\n      }\n\n      cout << l-bipartite_matching(2*l) << endl;\n    }\n  return 0;\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i < G[v].size();i++){\n    int u= G[v][i],w=match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\n\nint bipartite_matching(int V){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nvoid warshall_floyd(int V){\n  for(int i = 0; i < V; i++){\n    for(int j = 0; j < V; j++){\n      for(int k = 0; k < V; k++){\n\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint prevV[2100], prevE[2100];\nint dist[2100];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\tint V = G.size();\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+1500, INF);\n\t\tdist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < V; ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\treturn INF;\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, M, L;\n\twhile ( cin >> N >> M >> L, N || M || L ) {\n\t\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tm[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u, v, d; cin >> u >> v >> d;\n\t\t\tm[u][v] = m[v][u] = d;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint s = 2*L+1, t = s+1;\n\t\tG.clear(); G.resize(t+1);\n\n\t\tvector<int> p(L), time(L);\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tcin >> p[i] >> time[i];\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tif (i != j && time[i] + m[p[i]][p[j]] <= time[j]) {\n\t\t\t\t\taddEdge(L+i, j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\taddEdge(s, i, 1, 0);\n\t\t\taddEdge(L+i, t, 1, 0);\n\t\t\taddEdge(i, L+i, 1, -1);\n\t\t}\n\n\t\tint r = 0;\n\t\tfor (int l = 1; l <= L; ++l) {\n\t\t\tr += flow(s, t, 1);\n\t\t\tif (r == -L) {\n\t\t\t\tcout << l << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define size(x) ((int)(x).size()) \n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int maxn = 1123;\nconst int inf = 5e8;\nint n, m;\nint d[111][111];\nint p[maxn], w[maxn];\nint vis[maxn];\nstd::vector<int> G[maxn];\n\nvoid init(int x){\n\tfor(int i = 0; i < x; i++){\n\t\tG[i].clear();\n\t}\n}\n\nint dfs(int x){\n\tfor(int i = 0; i < size(G[x]); i++){\n\t\tint u = G[x][i];\n\t\tif(!vis[u]){\n\t\t\tvis[u] = 1;\n\t\t\tif(p[u] < 0 || dfs(p[u])){\n\t\t\t\tp[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint match(int x){\n\tint num = 0;\n\tmemset(p, -1, sizeof(p));\n\tfor(int i = 0; i < x; i++){\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tif(dfs(i)){\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint L;\n\twhile(cin >> n >> m >> L && n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j) d[i][j] = 0;\n\t\t\t\telse d[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tinit(L);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\td[x][y] = z;\n\t\t\td[y][x] = z;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tcin >> p[i] >> w[i];\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(d[p[i]][p[j]] + w[i] <= w[j] && i != j){\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << L - match(L) << endl;\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\n#define INF 100000000\n\nusing namespace std;\n\nint V,match[2001];\nbool used[2001];\nvector<int>G[2001];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  fill(match,match+2001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+2001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint main(void){\n\n  int n,m,l,u,v,d,graph[101][101],p[1001],t[1001];\n\n  while(cin >> n >> m >> l,n|m|l){  \n\n    for(int i=0;i<2001;i++)G[i].clear();\n\n    fill(graph[0],graph[101],INF);\n    for(int i=0;i<101;i++)graph[i][i]=0;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> d;\n      graph[u][v]=graph[v][u]=d;\n    }\n    \n    for(int i=0;i<l;i++){\n      cin >> p[i] >> t[i];\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j && graph[p[i]][p[j]]+t[i]<=t[j])add_edge(i,j+l);\n      }\n    }\n    V=2*l;\n    cout << l-bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cstring>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nvector<int> vv[2010];\nint match[2010];\nbool used[2010];\n\n\nbool matchdfs(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0;i < vv[v].size();i++)\n\t{\n\t\tint u = vv[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w))\n\t\t{\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint two_matching_max(int l)\n{\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l)\n\t{\n\t\tif(match[v] < 0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint n,m,l;\n\twhile(cin >> n >> m >> l,n|m|l)\n\t{\t\t\n\t\tREP(i,2010)vv[i].clear();\n\t\tint dist[n+1][n+1] = {};\n\t\tREP(i,n+1)REP(j,n+1)\n\t\t{\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse dist[i][j] = 5e8;\n\t\t}\n\t\t\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tint u,v,d;\n\t\t\tcin >> u >> v >> d;\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\t\t\t\n\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t{\n\t\t\tdist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j]);\n\t\t}\n\t\t\n\t\tvector<pair<int,int> > v(l);\n\t\t\n\t\tREP(i,l)\n\t\t{\n\t\t\tint p,t;\n\t\t\tcin >> p >> t;\n\t\t\tv[i] = MP(t,p);\n\t\t}\n\t\t\t\t\n\t\tif(m == 0)\n\t\t{\n\t\t\tcout << n << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tREP(i,l)rep(j,i,l)\n\t\t{\n\t\t\tif(i == j)continue;\n\t\t\tif(v[j].FI - v[i].FI >= dist[v[j].SE][v[i].SE])\n\t\t\t{\n\t\t\t\tvv[i].PB(l+j);\n\t\t\t\tvv[l+j].PB(i);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tint ret =  l - two_matching_max(2*l) ;\n\t\tcout << ret << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint dfs(int s, int *v, int *pa, vector<int> *dag){\n  if(s<0)return 1;\n  rep(i,dag[s].size()){\n    if(!v[dag[s][i]]){\n      v[dag[s][i]]=1;\n      if(dfs(pa[dag[s][i]],v,pa,dag)){\n\tpa[s]=dag[s][i],pa[dag[s][i]]=s;\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int N,M,L;\n  \n  while(cin>>N>>M>>L,N){\n    int d[N][N];\n    memset(d,INT_MAX,sizeof(d));\n    rep(i,N)d[i][i]=0;\n\n    rep(i,M){\n      int u,v,w; cin>>u>>v>>w;\n      d[u][v]=w;d[v][u]=w;\n    }\n\n    int p[L], t[L];\n    rep(i,L)cin>>p[i]>>t[i];\n  \n    // calc shortest path\n    rep(i,N)rep(j,N)rep(k,N)d[i][j]=(d[i][j]>d[i][k]+d[k][j])?d[i][k]+d[k][j]:d[i][j];\n    // calc DAG\n    vector<int> dag[N];\n    rep(i,L)rep(j,L){if(i!=j && d[p[i]][p[j]]<=t[j]-t[i])dag[p[i]].push_back(p[j]),dag[p[j]].push_back(p[i]);}\n    // enumerate santas\n    int num=L;\n    int pa[L];memset(pa,-1,sizeof(pa));\n    rep(i,L){\n      int v[N];memset(v,0,sizeof(v));\n      if(dfs(p[i],v,pa,dag))num--;\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<string.h>\n#include<algorithm>\n#define max_n 100\n#define max_m 1000\n#define max_l 1000\n//#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\ninline int min(int x, int y){\n  return (x<y)? x:y;\n}\n\nusing namespace std;\n\nclass Req{\npublic:\n  char house;\n  int time;\n};\n\nclass LessReq {\npublic:\n    bool operator()(const Req& x, const Req& y) const {\n        return x.time < y.time; \n    }\n};\nint n,m,l;\n//char graph[max_n][max_n];\nint dist[max_n][max_n];\n//char req_house[max_l];\n//int req_time[max_l];\nReq reqs[max_l];\n//リクエストx配送後に、リクエストy配送可能かを示す有向グラフ（DAG）\n//bool req_graph[max_l][max_l];\nint req_graph[max_l][max_l+1];\nint num_child[max_l];//各リクエストxの子の数\nint pathParent[max_l]; //被覆パスにおけるリクエストxの親\nint searched1[max_l];\nint searched2[max_l]; \n\n//デバグ用 設定表示関数\nvoid print_setting(){\n  int i,j;\n  printf(\"(n,m,l)=(%3d,%3d,%3d)\\n\",n,m,l);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      printf(\"%4d\",dist[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d%4d\\n\",reqs[i].house,reqs[i].time);\n  }\n  printf(\"\\n\");\n  for(i=0;i<l;i++){\n    printf(\"%4d: \",i);\n    for(j=0;j<num_child[i];j++){\n      printf(\"%4d\",req_graph[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n//すべての宅間の最短距離を算出、distに記録\nvoid compute_dist(){\n  register int i,j,k;\n  \n  for(i=0;i<n;i++) dist[i][i] = 0;\n  /*\n  for(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++){\n    if(dist[i][k] < 0) continue;\n    if(dist[k][j] < 0) continue;\n    if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n    else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n   */\n  for(k=0;k<n;k++){\n    for(i=0;i<k;i++){\n      for(j=i+1;j<k;j++){  //i<j<k\n        if(dist[i][k] < 0) continue;\n        if(dist[j][k] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[j][k];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[j][k]);\n      }\n      for(j=k+1;j<n;j++){  //i<k<j\n        if(dist[i][k] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[i][k]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n    for(i=k+1;i<n;i++){\n      for(j=i+1;j<n;j++){  //k<i<j\n        if(dist[k][i] < 0) continue;\n        if(dist[k][j] < 0) continue;\n        if(dist[i][j] < 0) dist[i][j] = dist[k][i]+dist[k][j];\n        else dist[i][j] = min(dist[i][j],dist[k][i]+dist[k][j]);\n      }      \n    }\n  }\n  for(i=0;i<n;i++)for(j=i+1;j<n;j++){\n    dist[j][i] = dist[i][j];\n  }\n}\n//req_graphの構成\nvoid compute_req_graph(){\n  int i,j;\n  int h1,h2,t1,t2;\n\n  memset(num_child,0,l*sizeof(int));\n  for(i=0;i<l;i++){    \n    for(j=i+1;j<l;j++){\n      h1 = reqs[i].house; h2 = reqs[j].house;      \n      if((dist[h1][h2] >= 0)\n         && (dist[h1][h2] <= reqs[j].time - reqs[i].time)){\n        req_graph[i][num_child[i]++] = j;\n      }      \n      /*\n      if((dist[h1][h2] >= 0) && (dist[h1][h2] <= t2 - t1)){\n        req_graph[i][j] = true;\n        num_child[i]++;\n      }\n      else\n        req_graph[i][j] = false;\n      */      \n    }\n  }\n}\n\nint find(int i){\n  int child, x, found;\n  static bool on_find[max_l];\n  static bool firstInvocation = true;\n  \n  if(firstInvocation){\n    memset(on_find,0,sizeof(on_find));\n    firstInvocation = false;\n  }\n\n  /*\n  printf(\"%d: \",i);\n  for(int j=0;j<l;j++) printf(\"%d\",on_find[j]);\n  printf(\"\\n\");\n  */\n  \n  //親権の空いている子を探す\n  for(int j=searched1[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    if(pathParent[child] >= 0) continue;\n    pathParent[child] = i; //childを自分の子とする\n    searched1[i] = j; //探索点を記憶\n    return child;    \n  }\n  searched1[i] = num_child[i];\n  //printf(\"%d: search1 failed\\n\",i);\n  \n  //他の親から親権を譲ってもらえる子を探す\n  on_find[i] = true;\n  for(int j=searched2[i]+1;j<num_child[i];j++){\n    child = req_graph[i][j];\n    x = pathParent[child]; //x: childのパス上の親\n    if(on_find[x]) continue; //閉路検出\n    //printf(\"%d: %d has child of id %d\\n\",i,x,child);\n    found = find(x); //xにchildの親権を譲ってもらう\n    if(found < 0) continue;\n    pathParent[child] = i; //xからchildの親権をもらう\n    searched2[i] = j; //探索点を記憶\n    on_find[i] = false;\n    return child;\n  }\n  on_find[i] = false;\n  searched2[i] = num_child[i];\n  //printf(\"%d: search2 failed\\n\",i);\n  return -1; //リクエストiはどの子の親権も獲得できず\n}\n\n//req_graphのパス被覆を求め、被覆数を返す。\nint num_covers(){\n  int num=0;\n  \n  memset(pathParent,-1,l*sizeof(int));\n  memset(searched1,-1,l*sizeof(int));\n  memset(searched2,-1,l*sizeof(int));\n  for(int i=0;i<l;i++){\n    if(pathParent[i]<0) num++;\n    //    printf(\"(i,num) = (%4d,%4d)\\n\",i,num);\n    find(i);\n  }\n  return num;\n}\n\n//以下、ひとつの問題例を解くsantas関数\n//プレゼント配送に必要なサンタの数を出力\nint santas(){\n  int u,v,d;\n  int i;\n\n  //入力読み込み\n  memset(dist,-1,sizeof(dist));\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&u,&v,&d);\n    dist[u][v] = d;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d%d\",&(reqs[i].house),&(reqs[i].time));\n  }\n  compute_dist();//すべてのhouse間の最短距離を算出、distに記録\n  sort(reqs,reqs+l,LessReq());\n  compute_req_graph();//req_graphの構成\n  //print_setting();//設定表示  \n  return num_covers();\n}\n\n\n\n//以下メイン関数\nint main(){\n  while(1){\n    scanf(\"%d%d%d\",&n,&m,&l);\n    if(n == 0) break;\n    printf(\"%d\\n\",santas());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2002;\nvector<vector<edge>> G(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\nint v[100][100];\nint p[1000], l[1000];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tREP(i, n)REP(j, n)v[i][j] = INF;\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t\tv[b][a] = c;\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, l) {\n\t\t\tcin >> p[i] >> t[i];\n\t\t}\n\t\tREP(i, l) {\n\t\t\tREP(j, l) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (t[i] + v[p[i]][p[j]] <= t[j])add_edge(p[i] + 1, p[j] + l + 1, 1);\n\t\t\t}\n\t\t}\n\t\tREP(i, l)add_edge(0, i + 1, 1);\n\t\tREP(i, l)add_edge(i + l + 1, 2 * l + 1, 1);\n\t\tcout << n - max_flow(0, 2 * l + 1) << endl;\n\t\tREP(i, G.size()) {\n\t\t\tG[i].clear();\n\t\t\tlevel[i] = 0;\n\t\t\titer[i] = 0;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\nconst int MAX_V=2000;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v]=true;\n\trep(i,G[v].size()){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint nibu(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\trep(v,V){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\nint N,M,L,INF=1e9;\nll d[100][100];\nint p[1000],t[1000];\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>L;\n\t\tif(N==0) break;\n\t\trep(i,N) rep(j,N) if(i!=j) d[i][j]=INF;\n\t\trep(i,M){\n\t\t\tint u,v,di;\n\t\t\tcin>>u>>v>>di;\n\t\t\td[u][v]=di;\n\t\t\td[v][u]=di;\n\t\t}\n\t\trep(i,N) rep(j,N) rep(k,N) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\trep(i,L) cin>>p[i]>>t[i];\n\t\tV=2*L;\n\t\trep(i,V) G[i].clear();\n\t\trep(i,L) rep(j,L) if(i!=j){\n\t\t\tif(t[i]+d[p[i]][p[j]]<=t[j]){\n\t\t\t\tadd_edge(i,j+L);\n\t\t\t}\n\t\t}\n\t\tcout<<L-nibu()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint const nMax = 1010;\nlong long road[200][200];\nint n,m,L,x,y,cost,judge;\nstruct SANTA{\n    int house;\n    long long time;\n}santa[nMax];\nstruct present{\n    int a;\n    long long time;\n}pre[nMax];\nbool cmp(present a,present b)\n{\n    return a.time < b.time;\n}\nbool cmp2(SANTA a,SANTA b)\n{\n    return a.time > b.time;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L),n||m||L){\n        int ans = 0;\n        memset(road,63,sizeof(road));\n        for(int i = 1;i <= m;i++){\n            scanf(\"%d%d%d\",&x,&y,&cost);\n            if( road[x][y] > cost )\n                road[x][y] = road[y][x] = cost;\n        }\n        for(int k = 0;k < n;k++){\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < n;j++)\n                    if( road[i][j] > road[i][k] + road[k][j] ) road[i][j] = road[i][k] + road[k][j];\n            }\n        }\n        for(int i = 0;i < n;i++) road[i][i] = 0;\n        for(int i = 0;i < L;i++) scanf(\"%d%d\",&pre[i].a,&pre[i].time);\n        sort(pre,pre+m,cmp);\n        //for(int i = 0;i < L;i++)printf(\"%d  %d\\n\",pre[i].a,pre[i].time);\n        for(int i = 0;i < L;i++){\n            judge = 0;\n            sort(santa+1,santa+ans+1,cmp2);\n            if( i == 0 ) {\n                ans++;\n                santa[ans].house = pre[i].a;\n                santa[ans].time = pre[i].time;\n                continue;\n            }\n            for(int j = 1;j <= ans;j++){\n                if( road[santa[j].house][pre[i].a] <= pre[i].time - santa[j].time ){\n                    santa[j].house = pre[i].a;\n                    santa[j].time = pre[i].time;\n                    judge = 1;\n                    break;\n                }\n            }\n            if( judge == 0 ){\n                ans++;\n                santa[ans].house = pre[i].a;\n                santa[ans].time = pre[i].time;\n            }\n        }\n        //for(int i = 1;i <= ans;i++)printf(\"%d %d\\n\",santa[i].house,santa[i].time);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <string.h>\n#define INF 99999999\nusing namespace std;\n\ntypedef struct {\n    int num;\n    int time;\n}node;\nint n,l;\nint dis[105][105],w[1005][1005];\nint linker[1005],vis[1005];\nnode no[1005];\n\nvoid floyd() {\n    for(int k = 0;k < n;k++)\n        for(int i = 0;i < n;i++)\n            for(int j = 0;j < n;j++)\n                if(dis[i][k] < INF &&\n                   dis[k][j] < INF &&\n                   dis[i][j] > dis[i][k] + dis[k][j])\n                   dis[i][j] = dis[i][k] + dis[k][j];\n}\n\nbool dfs(int u) {\n    for(int v = 1;v <= l;v++)\n        if(w[u][v] && !vis[v]) {\n            vis[v] = 1;\n            if(linker[v] == -1 || dfs(linker[v])) {\n                linker[v] = u;\n                return true;\n            }\n        }\n    return false;\n}\n\nint hungary() {\n    int res = 0;\n    memset(linker,-1,sizeof(linker));\n    for(int u = 1;u <= l;u++) {\n        memset(vis,0,sizeof(vis));\n        if(dfs(u)) res++;\n    }\n    return res;\n}\n\nint main() {\n    int m;\n    //freopen(\"test.in\",\"r\",stdin);\n    while(~scanf(\"%d%d%d\",&n,&m,&l) && (n + m + l)) {\n        memset(w,0,sizeof(w));\n        for(int i = 0;i < n;i++)\n            for(int j = 0;j < n;j++) {\n                dis[i][j] = INF;\n                if(i == j) dis[i][j] = 0;\n            }\n\n\n        while(m--) {\n            int a,b,val;\n            scanf(\"%d%d%d\",&a,&b,&val);\n            dis[a][b] = val;\n            dis[b][a] = val;\n        }\n\n        floyd();\n\n        for(int i = 1;i <= l;i++)\n            scanf(\"%d%d\",&no[i].num,&no[i].time);\n\n        for(int i = 1;i <= l;i++)\n            for(int j = 1;j <= l;j++) {\n            if(i == j) continue;\n            int f = no[i].num,t = no[j].num;\n            int ft = no[i].time,tt = no[j].time;\n            if(ft + dis[f][t] <= tt) w[i][j] = 1;\n        }\n\n        printf(\"%d\\n\",l - hungary());\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2251 Merry Christmas\n// 2018.3.6 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 2002\nshort hi[MAX], to[MAX][MAX];\nchar  seen[MAX];\nshort matchL[MAX], matchR[MAX];\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (matchR[v] < 0 || bpm(matchR[v])) {\n\t\t\tmatchL[u] = v, matchR[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define INF 0x10101010\ntypedef struct { int p, t; } T;\nT pt[1002];\nint dist[102][102];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint cmp(T *a, T *b) { return a->t - b->t; }\n\nint main()\n{\n\tint N, M, L, u, v, d, k;\n\n\twhile (N = in()) {\n\t\tM = in(), L = in();\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tfor (k = 0; k < N; k++) dist[k][k] = 0;\n\t\tfor (k = 0; k < M; k++) {\n\t\t\tu = in(), v = in(), d = in();\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\tfor (k = 0; k < N; k++) {\n\t\t\tfor (u = 0; u < N; u++) if (dist[u][k] != INF) {\n\t\t\t\tfor (v = 0; v < N; v++) if (dist[k][v] != INF) {\n\t\t\t\t\td = dist[u][k] + dist[k][v];\n\t\t\t\t\tif (dist[u][v] > d) dist[u][v] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (k = 0; k < L; k++) pt[k].p = in(), pt[k].t = in();\n\n\t\tqsort(pt, L, sizeof(T), cmp);\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (u = 0; u < L; u++) for (v = 0; v < L; v++) if (u != v) {\n\t\t\tif (dist[pt[u].p][pt[v].p] <= pt[v].t-pt[u].t) to[u][hi[u]++] = v+L;\n\t\t}\n\n\t    memset(matchL, -1, L << 2);\n\t    memset(matchR, -1, L << 2);\n\t\tk = L;\n\t\tfor (u = 0; u < L; u++) {\n\t\t\tmemset(seen, 0, L << 1);\n\t\t\tif (bpm(u)) k--;\n\t\t}\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2251 Merry Christmas\n// 2018.3.6 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 2002\nshort hi[MAX], to[MAX][MAX];\nchar  seen[MAX];\nshort match[MAX];\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (match[v] < 0 || bpm(match[v])) {\n\t\t\tmatch[u] = v, match[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define INF 0x10101010\ntypedef struct { int p, t; } T;\nT pt[1002];\nint dist[102][102];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint cmp(T *a, T *b) { return a->t - b->t; }\n\nint main()\n{\n\tint N, M, L, u, v, d, k;\n\n\twhile (N = in()) {\n\t\tM = in(), L = in();\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tfor (k = 0; k < N; k++) dist[k][k] = 0;\n\t\tfor (k = 0; k < M; k++) {\n\t\t\tu = in(), v = in(), d = in();\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\tfor (k = 0; k < N; k++) {\n\t\t\tfor (u = 0; u < N; u++) if (dist[u][k] != INF) {\n\t\t\t\tfor (v = 0; v < N; v++) if (dist[k][v] != INF) {\n\t\t\t\t\td = dist[u][k] + dist[k][v];\n\t\t\t\t\tif (dist[u][v] > d) dist[u][v] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (k = 0; k < L; k++) pt[k].p = in(), pt[k].t = in();\n\n\t\tqsort(pt, L, sizeof(T), cmp);\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (u = 0; u < L; u++) for (v = 0; v < L; v++) if (u != v) {\n\t\t\tif (dist[pt[u].p][pt[v].p] <= pt[v].t-pt[u].t) to[u][hi[u]++] = v+L;\n\t\t}\n\n\t    memset(match, -1, L << 2);\n\t\tk = L;\n\t\tfor (u = 0; u < L; u++) {\n\t\t\tmemset(seen, 0, L << 1);\n\t\t\tif (bpm(u)) k--;\n\t\t}\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2251 Merry Christmas\n// 2018.3.6 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 2002\nshort hi[MAX], to[MAX][MAX];\nchar  seen[MAX];\nshort match[MAX];\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (match[v] < 0 || bpm(match[v])) {\n\t\t\tmatch[u] = v, match[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define INF 0x1010\nint dist[102][102];\nint p[1002], t[1002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint N, M, L, u, v, d, k;\n\n\twhile (N = in()) {\n\t\tM = in(), L = in();\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tfor (k = 0; k < N; k++) dist[k][k] = 0;\n\t\tfor (k = 0; k < M; k++) {\n\t\t\tu = in(), v = in(), d = in();\n\t\t\tdist[u][v] = dist[v][u] = d;\n\t\t}\n\t\tfor (k = 0; k < N; k++) {\n\t\t\tfor (u = 0; u < N; u++) if (dist[u][k] != INF) {\n\t\t\t\tfor (v = 0; v < N; v++) if (dist[k][v] != INF) {\n\t\t\t\t\td = dist[u][k] + dist[k][v];\n\t\t\t\t\tif (dist[u][v] > d) dist[u][v] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (k = 0; k < L; k++) p[k] = in(), t[k] = in();\n\t\tfor (u = 0; u < L; u++) for (v = 0; v < L; v++) if (u != v) {\n\t\t\tif (dist[p[u]][p[v]] <= t[v]-t[u]) to[u][hi[u]++] = v+L;\n\t\t}\n\n\t    memset(match, -1, L << 2);\n\t\tk = L;\n\t\tfor (u = 0; u < L; u++) {\n\t\t\tmemset(seen, 0, L << 1);\n\t\t\tif (bpm(u)) k--;\n\t\t}\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[1001],C[1001][1001],V[1000],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),m;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));\n    for(i=0;i<n;i++)for(j=0;j<n;j++)d[i][j]=i==j?0:999999;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<999999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));\n    for(i=0;i<n;i++)for(j=0;j<n;j++)d[i][j]=i==j?0:999999;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<999999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));memset(d,99,sizeof(d));\n\tfor(i=0;i<n;i++)d[i][i]=0;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<999999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));memset(d,99,sizeof(d));\n\tfor(i=0;i<n;i++)d[i][i]=0;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<99999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<math.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<sstream>\n//#include<ctype.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e4+5;\nconst ll mod = 1e9+7;\n\nint n, m, k;\nvector<int> G[maxn];\nint match[maxn];\t\t//匹配 \nbool used[maxn];\nint mp[maxn][maxn];\nvector<Pii> q;\n\n//?算任意?点?的最短距? \nvoid floyd(){\n    for(int l = 0; l < n;l++){\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < n;j++)\n                mp[i][j] = min(mp[i][j], mp[i][l] + mp[l][j]);\n        }\n    }\n}\n\n\nvoid addedge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n//dfs?找?广路 \nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w<0 || !used[w] && dfs(w)){\t//u未匹配?，或?有?广路 \n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//求解二分?的最大匹配 \nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v<n+k; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t} \n\treturn res;\n}\n\n//建?，到?一点后?能到?的点?? \nvoid build(){\n    for(int i = 0;i < q.size();i++){\n        for(int j = 0; j < q.size(); j++){\n            if(i == j) continue;\n            Pii a = q[i], b = q[j];\n            int tmp = b.second - a.second;\n            if(tmp >= mp[a.first][b.first]){\n            \taddedge(i, j+k);\n            }\n        }\n    }\n}\n\n\nint main(){\n\twhile(scanf(\"%d%d%d\", &n, &m, &k) == 3 &&(n||k||m)){\n\t\tq.clear();\n\t\tfor(int i = 0;i < 2*n;i++){\n\t        for(int j = 0;j < 2*n;j++){\n\t            if(i == j) mp[i][j] = 0;\n\t            else mp[i][j] = inf;\n\t        }\n    \t}\n    \t\n\t\tfor(int i=0; i<n+k; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\t \n\t\tfor(int i = 0;i < m;i++){\n            int u, v, w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            mp[u][v] = w;\n            mp[v][u] = w;\n        }\n        \n        for(int i = 0;i < k;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            q.push_back(make_pair(a,b));\n        }\n        \n        floyd();\n\t\tbuild();\n\t\t\n\t\tprintf(\"%d\\n\", k-bipartite_matching());\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));\n\t//memset(d,99,sizeof(d));for(i=0;i<n;i++)d[i][i]=0;\n    for(i=0;i<n;i++)for(j=0;j<n;j++)d[i][j]=i==j?0:999999;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\t//warshall-floyd\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<999999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));\n\tmemset(d,11,sizeof(d));for(i=0;i<n;i++)d[i][i]=0;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<99999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));\n\tmemset(d,11,sizeof(d));for(i=0;i<n;i++)d[i][i]=0;\n    //for(i=0;i<n;i++)for(j=0;j<n;j++)d[i][j]=i==j?0:99999;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\t//warshall-floyd\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<99999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int t,n,m,l,i,j,a,b,k,P[1001],T[1001],Q[2001],C[2001][2001],V[2001],d[1001][1001];\nint match(s){int i=l;for(;i<l+l;i++)if(C[s][i]&&!V[i])if(V[i]=1,Q[i]<0||match(Q[i]))return Q[s]=i,Q[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d%d\",&n,&m,&l),l;printf(\"%d\\n\",l-t)){\n\tmemset(C,0,sizeof(C));memset(Q,0xff,sizeof(Q));\n\t//memset(d,99,sizeof(d));for(i=0;i<n;i++)d[i][i]=0;\n    for(i=0;i<n;i++)for(j=0;j<n;j++)d[i][j]=i==j?0:99999;\n    for(i=0;i<m;i++)scanf(\"%d%d%d\",&a,&b,&k),d[a][b]=d[b][a]=k;\n\tfor(i=0;i<l;i++)scanf(\"%d%d\",P+i,T+i);\n\t//warshall-floyd\n\tfor(k=0;k<n;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\tfor(i=0;i<l;i++)for(j=0;j<l;j++)if(i!=j&&d[P[i]][P[j]]<99999&&T[i]+d[P[i]][P[j]]<=T[j])C[i][l+j]=C[l+j][i]=1;\n    for(t=i=0;i<l;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\n\t\tint[][] dist = new int[100][100];\n\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tArrays.fill(dist[i], 1 << 28);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\t\t\t\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tint[] t = new int[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n\t\t\t// Preflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t// System.out.println((l - pr.calc()));\n\t\t\tout.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\n\t\t\tlong[][] dist = new long[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dist[i], 1L << 60);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt(), v = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tlong[] t = new long[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextLong();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n//\t\t\tSystem.out.println((l - pr.calc()));\n\t\t\tSystem.out.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min) / 2;\n\t\t\t\tTreeSet<String> used = new TreeSet<String>();\n\t\t\t\tString state = \"\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n//\t\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t//\t\t\tSystem.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2, i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub,16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(0, i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2, c.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%03x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t//\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, 0, newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\n\t\tint[][] dist = new int[100][100];\n\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tArrays.fill(dist[i], 1 << 28);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tint[] t = new int[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Integer>[] g = new ArrayList[2 * l];\n\t\t\tfor (int i = 0; i < 2 * l; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(l + j);\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for (int i = 0; i < l; i++) {\n\t\t\t// g[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t// }\n\t\t\t// for (int i = 0; i < l; i++) {\n\t\t\t// g[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t// }\n\n\t\t\tSystem.out.println(l - bipartiteMatching(g, l));\n\t\t\t// Preflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t// System.out.println((l - pr.calc()));\n\t\t\t// out.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1,\n\t\t\t// g).MaxFlow()));\n\t\t}\n\t}\n\n\tboolean augment(ArrayList<Integer>[] g, int u, Integer[] matchTo, Boolean[] visited) {\n\t\tif (u < 0)\n\t\t\treturn true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tvisited[v] = true;\n\t\t\t\tif (augment(g, matchTo[v], matchTo, visited)) {\n\t\t\t\t\tmatchTo[u] = v;\n\t\t\t\t\tmatchTo[v] = u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartiteMatching(ArrayList<Integer>[] g, int L) {\n\t\tfinal int n = g.length;\n\t\tInteger[] matchTo = new Integer[n];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor (int i = 0; i < L; i++) {\n\t\t\tBoolean[] visited = new Boolean[n];\n\t\t\tArrays.fill(visited, false);\n\t\t\tif (augment(g, i, matchTo, visited))\n\t\t\t\tmatch++;\n\t\t}\n\t\treturn match;\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tclass Arrow {\n\t\tint cap;\n\t\tint flow;\n\t\tint from;\n\t\tint to;\n\n\t\tArrow(int from, int to) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cap = 1;\n\t\t\tthis.flow = 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\td[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[l][l];\n\t\t\tboolean e[][] = new boolean[l][l];\n\n//\t\t\tLinkedList<Arrow> A = new LinkedList<Arrow>();\n\n\t\t\t\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tif (d[req[i].p][req[j].p] <= -req[i].t + req[j].t) {\n\t\t\t\t\t\tr[i][j] = true;\n\t\t\t\t\t} \n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean s[] = new boolean[l];\n\t\t\tboolean t[] = new boolean[l];\n\n\t\t\tint count = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\tboolean end = true;\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (!s[i]) {\n\t\t\t\t\t\tif (dfs(s, t, r,e, i , new boolean[l],new boolean[l])) {\n\t\t\t\t\t\t\ts[i] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tend = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(end){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l-count);\n\t\t}\n\n\t}\n\n\tboolean dfs(boolean[] s, boolean[] t, boolean r[][], boolean e[][], int p , boolean[] passed , boolean[] p2) {\n\t\tif(passed[p]){\n\t\t\treturn  false;\n\t\t}else{\n\t\t\tpassed[p] = true;\n\t\t}\n\t\tfor(int  i = 0; i < t.length;i++){\n\t\t\tif(!r[p][i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(e[p][i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te[p][i] = true;\n\t\t\tif(!t[i]){\n\t\t\t\tt[i] = true;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t\tif(bdfs(s,t,r,e,i , passed , p2)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\te[p][i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tboolean bdfs(boolean[] s, boolean[] t, boolean r[][] , boolean[][] e, int p,boolean passed[] , boolean [] p2) {\n\t\tif(p2[p]){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tp2[p] = true;\n\t\t}\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\t\n\t\t\tif(!e[i][p]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te[i][p] = false;\n\t\t\t\n\t\t\tif(dfs(s,t,r,e,i ,passed , p2)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\te[i][p] = true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 29;\n\tvoid solve() {\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif (N + M + L == 0) break;\n\t\t\t\n\t\t\tint[][] distance = new int[N][N];\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\t//??????????±?????°??????????\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tTreeSet<String> used = new TreeSet<String>();\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min) / 2;\n\t\t\t\tused.clear();\n\t\t\t\tString state = \"\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tq.clear();\n//\t\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t//\t\t\tSystem.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2, i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub,16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(0, i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2, c.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%02x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t//\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, 0, newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min) / 2;\n\t\t\t\tTreeSet<String> used = new TreeSet<String>();\n\t\t\t\tString state = \"\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"000\";\n\t\t\t\t}\n//\t\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t//\t\t\tSystem.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 3, i * 3 + 3);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(0, i * 3);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 3 + 3, c.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%03d\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t//\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, 0, newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m, l;\n\tint[][] w;\n\tint[] p, t;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tl=sc.nextInt();\n\t\t\tif((n|m|l)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw=new int[n][n];\n\t\t\tp=new int[l];\n\t\t\tt=new int[l];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tArrays.fill(w[i], INF);\n\t\t\t\tw[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint u=sc.nextInt();\n\t\t\t\tint v=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tw[u][v]=w[v][u]=d;\n\t\t\t}\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tp[i]=sc.nextInt();\n\t\t\t\tt[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tw[i][j]=Math.min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV[] vs=new V[l*2];\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\tvs[i]=new V(i%l);\n\t\t}\n\t\tfor(int j=0; j<l; j++){\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint u=p[i];\n\t\t\t\tint v=p[j];\n\t\t\t\tif(t[i]+w[u][v]<=t[j]){\n\t\t\t\t\tvs[i].connect(vs[j+l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * for(int i=0; i<l*2; i++){ debug(\"i:\", i); for(V v : vs[i]){\n\t\t * debug(v.i); } }\n\t\t */\n\t\tint match=hopcroftKarp(vs);\n\t\tint ans=l-match;\n\t\t//debug(\"match\", match);\n\t\t//debug(\"ans\",ans);\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\t// debug(i, \":\", vs[i].pair!=null?vs[i].pair.i:-1);\n\t\t}\n\n\t\tprintln(ans+\"\");\n\t}\n\n\tint hopcroftKarp(V[] vs){\n\t\tfor(int match=0;;){\n\t\t\tQueue<V> que=new LinkedList<V>();\n\t\t\tfor(V v : vs){\n\t\t\t\tv.level=-1;\n\t\t\t}\n\t\t\tfor(V v : vs){\n\t\t\t\tif(v.pair==null){\n\t\t\t\t\tv.level=0;\n\t\t\t\t\tque.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(; !que.isEmpty();){\n\t\t\t\tV v=que.poll();\n\t\t\t\tfor(V u : v){\n\t\t\t\t\tV w=u.pair;\n\t\t\t\t\tif(w!=null&&w.level<0){\n\t\t\t\t\t\tw.level=v.level+1;\n\t\t\t\t\t\tque.offer(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(V v : vs){\n\t\t\t\tv.used=false;\n\t\t\t}\n\t\t\tint d=0;\n\t\t\tfor(V v : vs){\n\t\t\t\tif(v.pair==null&&dfs(v)){\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==0){\n\t\t\t\treturn match;\n\t\t\t}\n\t\t\tmatch+=d;\n\t\t}\n\t}\n\n\tboolean dfs(V v){\n\t\tv.used=true;\n\t\tfor(V u : v){\n\t\t\tV w=u.pair;\n\t\t\tif(w==null||!w.used&&v.level<w.level&&dfs(w)){\n\t\t\t\tv.pair=u;\n\t\t\t\tu.pair=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass V extends LinkedList<V>{\n\t\tV pair;\n\t\tboolean used;\n\t\tint i, level;\n\n\t\tV(int i){\n\t\t\tthis.i=i;\n\t\t}\n\n\t\tvoid connect(V v){\n\t\t\tadd(v);\n\t\t\tv.add(this);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\t// System.setIn(new FileInputStream(\"in.txt\"));\n\t\t}catch(Throwable e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n \npublic class Main {\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n \n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n \n        new Main().solver();\n \n        out.flush();\n    }\n \n    static long nl() {\n        try {\n            long num = 0;\n            boolean minus = false;\n            while ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n                ;\n            if (num == '-') {\n                num = 0;\n                minus = true;\n            } else {\n                num -= '0';\n            }\n \n            while (true) {\n                int b = is.read();\n                if (b >= '0' && b <= '9') {\n                    num = num * 10 + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n            }\n        } catch (IOException e) {\n        }\n        return -1;\n    }\n \n    static char nc() {\n        try {\n            int b = skip();\n            if (b == -1)\n                return 0;\n            return (char) b;\n        } catch (IOException e) {\n        }\n        return 0;\n    }\n \n    static double nd() {\n        try {\n            return Double.parseDouble(ns());\n        } catch (Exception e) {\n        }\n        return 0;\n    }\n \n    static String ns() {\n        try {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            if (b == -1)\n                return \"\";\n            sb.append((char) b);\n            while (true) {\n                b = is.read();\n                if (b == -1)\n                    return sb.toString();\n                if (b <= ' ')\n                    return sb.toString();\n                sb.append((char) b);\n            }\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n \n    public static char[] ns(int n) {\n        char[] buf = new char[n];\n        try {\n            int b = skip(), p = 0;\n            if (b == -1)\n                return null;\n            buf[p++] = (char) b;\n            while (p < n) {\n                b = is.read();\n                if (b == -1 || b <= ' ')\n                    break;\n                buf[p++] = (char) b;\n            }\n            return Arrays.copyOf(buf, p);\n        } catch (IOException e) {\n        }\n        return null;\n    }\n \n    public static byte[] nse(int n) {\n        byte[] buf = new byte[n];\n        try {\n            int b = skip();\n            if (b == -1)\n                return null;\n            is.read(buf);\n            return buf;\n        } catch (IOException e) {\n        }\n        return null;\n    }\n \n    static int skip() throws IOException {\n        int b;\n        while ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n            ;\n        return b;\n    }\n \n    static boolean eof() {\n        try {\n            is.mark(1000);\n            int b = skip();\n            is.reset();\n            return b == -1;\n        } catch (IOException e) {\n            return true;\n        }\n    }\n \n    static int ni() {\n        try {\n            int num = 0;\n            boolean minus = false;\n            while ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n                ;\n            if (num == '-') {\n                num = 0;\n                minus = true;\n            } else {\n                num -= '0';\n            }\n \n            while (true) {\n                int b = is.read();\n                if (b >= '0' && b <= '9') {\n                    num = num * 10 + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n            }\n        } catch (IOException e) {\n        }\n        return -1;\n    }\n \n    @SuppressWarnings(\"unchecked\")\n    void solver() {\n \n        int[][] dist = new int[100][100];\n \n        while (true) {\n            int n = ni();\n            int m = ni();\n            int l = ni();\n            if (n == 0 && m == 0 && l == 0)\n                break;\n            for (int i = 0; i < 100; i++) {\n                Arrays.fill(dist[i], 1 << 28);\n                dist[i][i] = 0;\n            }\n \n            for (int i = 0; i < m; i++) {\n                int u = ni(), v = ni(), d = ni();\n                dist[u][v] = d;\n                dist[v][u] = d;\n            }\n \n            int[] p = new int[l];\n            int[] t = new int[l];\n            for (int i = 0; i < l; i++) {\n                p[i] = ni();\n                t[i] = ni();\n            }\n \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        dist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n                    }\n                }\n            }\n \n            ArrayList<Integer>[] g = new ArrayList[2 * l];\n            for (int i = 0; i < 2 * l; i++) {\n                g[i] = new ArrayList<>();\n            }\n \n            for (int i = 0; i < l; i++) {\n                for (int j = 0; j < l; j++) {\n                    if (i == j)\n                        continue;\n                    if (dist[p[i]][p[j]] + t[i] <= t[j]) {\n                        g[i].add(l + j);\n                        // System.out.println(dist[p[i]][p[j]] + t[i]);\n                    }\n                }\n            }\n \n            // for (int i = 0; i < l; i++) {\n            // g[2 * l].add(new Edge(2 * l, i, 1));\n            // }\n            // for (int i = 0; i < l; i++) {\n            // g[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n            // }\n \n            System.out.println(l - bipartiteMatching(g, l));\n            // Preflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n            // System.out.println((l - pr.calc()));\n            // out.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1,\n            // g).MaxFlow()));\n        }\n    }\n \n    boolean augment(ArrayList<Integer>[] g, int u, Integer[] matchTo, Boolean[] visited) {\n        if (u < 0)\n            return true;\n        for (int v : g[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                if (augment(g, matchTo[v], matchTo, visited)) {\n                    matchTo[u] = v;\n                    matchTo[v] = u;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n \n    int bipartiteMatching(ArrayList<Integer>[] g, int L) {\n        final int n = g.length;\n        Integer[] matchTo = new Integer[n];\n        Arrays.fill(matchTo, -1);\n        int match = 0;\n        for (int i = 0; i < L; i++) {\n            Boolean[] visited = new Boolean[n];\n            Arrays.fill(visited, false);\n            if (augment(g, i, matchTo, visited))\n                match++;\n        }\n        return match;\n    }\n \n    class Edmonds_Kerp_MaxFlow {\n        int n;\n        int s;\n        int t;\n        ArrayList<Edge>[] g;\n        int[][] flow;\n        int[][] capacity;\n \n        @SuppressWarnings(\"unchecked\")\n        public Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n            this.g = g;\n            this.s = s;\n            this.t = t;\n            n = g.length;\n            flow = new int[n][n];\n            capacity = new int[n][n];\n \n            for (int i = 0; i < n; i++) {\n                for (Edge e : g[i]) {\n                    if (e.weight > 0) {\n                        g[e.dst].add(new Edge(e.dst, e.src, 0));\n                        capacity[e.src][e.dst] += e.weight;\n                    } else if (e.weight == 0) {\n                        continue;\n                    }\n                }\n            }\n        }\n \n        @SuppressWarnings(\"unchecked\")\n        int MaxFlow() {\n            int total = 0;\n            while (true) {\n                int[] prev = bfs();\n                if (prev[t] == -1)\n                    return total;\n                int inc = 1 << 30;\n                for (int i = t; prev[i] != -1; i = prev[i]) {\n                    inc = Math.min(inc, residue(prev[i], i));\n                }\n                for (int i = t; prev[i] != -1; i = prev[i]) {\n                    push(prev[i], i, inc);\n                }\n                total += inc;\n            }\n        }\n \n        int residue(int s, int t) {\n            return capacity[s][t] - flow[s][t];\n        }\n \n        int[] bfs() {\n            int[] prev = new int[n];\n            Arrays.fill(prev, -1);\n            ArrayDeque<Integer> que = new ArrayDeque<>();\n            que.add(s);\n            out: while (!que.isEmpty()) {\n                int v = que.poll();\n                for (Edge e : g[v]) {\n                    if (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n                        prev[e.dst] = v;\n                        que.add(e.dst);\n                        if (e.dst == t)\n                            break out;\n                    }\n                }\n            }\n            return prev;\n        }\n \n        void push(int s, int t, int inc) {\n            flow[s][t] += inc;\n            flow[t][s] -= inc;\n        }\n    }\n \n    class Preflow_Relabel {\n        int n;\n        int s;\n        int t;\n        ArrayList<Edge>[] g;\n        int[][] flow;\n        int[][] capacity;\n        int[] excess;\n        int[] height;\n        ArrayDeque<Integer>[] B;\n \n        void global_relabeling() {\n            ArrayDeque<Integer> que = new ArrayDeque<>();\n            boolean[] arrived = new boolean[n];\n            que.add(t);\n            while (!que.isEmpty()) {\n                int v = que.poll();\n                for (Edge e : g[v]) {\n                    if (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n                        height[e.dst] = height[v] + 1;\n                        arrived[e.dst] = true;\n                    }\n                }\n            }\n        }\n \n        @SuppressWarnings(\"unchecked\")\n        public Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n            this.g = g;\n            this.s = s;\n            this.t = t;\n            n = g.length;\n            flow = new int[n][n];\n            capacity = new int[n][n];\n            height = new int[n];\n            height[s] = n;\n            excess = new int[n];\n            B = new ArrayDeque[n + 1];\n            for (int i = 0; i <= n; i++) {\n                B[i] = new ArrayDeque<>();\n            }\n            B[height[s]].add(s);\n \n            for (int i = 0; i < n; i++) {\n                for (Edge e : g[i]) {\n                    if (e.weight > 0) {\n                        g[e.dst].add(new Edge(e.dst, e.src, 0));\n                        capacity[e.src][e.dst] += e.weight;\n                    } else if (e.weight == 0) {\n                        continue;\n                    }\n                }\n            }\n        }\n \n        int b = 0;\n \n        @SuppressWarnings(\"unchecked\")\n        int calc() {\n            int count = 0;\n            for (Edge e : g[s]) {\n                excess[s] += e.weight;\n                push(s, e.dst);\n                B[height[e.dst]].add(e.dst);\n            }\n            global_relabeling();\n            for (b = height[s]; b >= 0;) {\n                if (B[b].isEmpty()) {\n                    b--;\n                    continue;\n                }\n                int v = B[b].poll();\n                if (excess[v] == 0 || v == t || v == s || height[v] > n) {\n                    continue;\n                }\n \n                for (Edge e : g[v]) {\n                    if (height[e.src] == height[e.dst] + 1) {\n                        if (residue(e.src, e.dst) > 0) {\n                            push(e.src, e.dst);\n                            if (excess[v] == 0)\n                                break;\n                        }\n                    }\n                }\n                if (excess[v] > 0) {\n                    int min = 1 << 30;\n                    for (Edge e : g[v]) {\n                        if (residue(e.src, e.dst) > 0) {\n                            min = Math.min(min, height[e.dst]);\n                        }\n                    }\n                    height[v] = min + 1;\n                    if (height[v] < n) {\n                        B[height[v]].add(v);\n                        if (height[v] > b)\n                            b = height[v];\n                    }\n                }\n                if (++count % n == 0) {\n                    global_relabeling();\n                }\n            }\n            return excess[t];\n        }\n \n        int residue(int s, int t) {\n            return capacity[s][t] - flow[s][t];\n        }\n \n        void push(int u, int v) {\n            int delta = Math.min(excess[u], residue(u, v));\n            flow[u][v] += delta;\n            flow[v][u] -= delta;\n            excess[v] += delta;\n            excess[u] -= delta;\n            if (v != t && v != s && height[v] < n) {\n                B[height[v]].add(v);\n                if (b < height[v]) {\n                    b = height[v];\n                }\n            }\n        }\n    }\n \n    class Edge {\n        int src;\n        int dst;\n        int weight;\n \n        Edge(int src, int dst, int weight) {\n            this.src = src;\n            this.dst = dst;\n            this.weight = weight;\n        }\n    }\n \n    class DJSet {\n        int n;// the number of vertices\n        int[] d;\n \n        DJSet(int n) {\n            this.n = n;\n            d = new int[n];\n            Arrays.fill(d, -1);\n        }\n \n        int root(int x) {\n            return d[x] < 0 ? x : (d[x] = root(d[x]));\n        }\n \n        boolean setUnion(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (d[x] < d[y]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                // x>y\n                d[y] += d[x];\n                d[x] = y;\n            }\n            return x != y;\n        }\n \n        boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n \n        int size(int x) {\n            return d[root(x)] * (-1);\n        }\n \n        int count() {\n            int ct = 0;\n            for (int u : d) {\n                if (u < 0)\n                    ct++;\n            }\n            return ct;\n        }\n    }\n \n    void tr(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dist[i], 1 << 28);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tint[] t = new int[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n//\t\t\tPreflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t// System.out.println((l - pr.calc()));\n\t\t\tout.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\n\t\tint[][] dist = new int[100][100];\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tArrays.fill(dist[i], 1 << 28);\n\t\t\tdist[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tint[] t = new int[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n\t\t\t// Preflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t// System.out.println((l - pr.calc()));\n\t\t\tout.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 29;\n\tvoid solve() {\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif (N + M + L == 0) break;\n\t\t\t\n\t\t\tint[][] distance = new int[N][N];\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\t//??????????±?????°??????????\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m, l;\n\tint[][] w;\n\tint[] p, t;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tl=sc.nextInt();\n\t\t\tif((n|m|l)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw=new int[n][n];\n\t\t\tp=new int[l];\n\t\t\tt=new int[l];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tArrays.fill(w[i], INF);\n\t\t\t\tw[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint u=sc.nextInt();\n\t\t\t\tint v=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tw[u][v]=w[v][u]=d;\n\t\t\t}\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tp[i]=sc.nextInt();\n\t\t\t\tt[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tw[i][j]=Math.min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV[] vs=new V[l*2];\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\tvs[i]=new V(i%l);\n\t\t}\n\t\tfor(int j=0; j<l; j++){\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint u=p[i];\n\t\t\t\tint v=p[j];\n\t\t\t\tif(t[i]+w[u][v]<=t[j]){\n\t\t\t\t\tvs[i].connect(vs[j+l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(true)\n\t\t\tfor(int i=0; i<l*2; i++){\n\t\t\t\tdebug(\"i:\", i);\n\t\t\t\tfor(V v : vs[i]){\n\t\t\t\t\tdebug(v.i);\n\t\t\t\t}\n\t\t\t}\n\t\tint match=bm(vs);\n\t\tdebug(\"match\", match);\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\tdebug(i, \":\", vs[i].pair!=null?vs[i].pair.i:-1);\n\t\t}\n\n\t\tint ans=0;\n\n\t\tinit();\n\t\tfor(int i=0; i<l; i++){\n\t\t\tif(vs[i].pair!=null)\n\t\t\t\tunion(i, vs[i].pair.i);\n\t\t}\n\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tdebug(\"pa\",pa);\n\t\tfor(int i=0; i<l; i++){\n\t\t\tset.add(find(pa[i]));\n\t\t}\n\t\tans=set.size();\n\n\t\tprintln(ans+\"\");\n\t}\n\n\tint bm(V[] vs){\n\t\tint match=0;\n\t\tfor(V v : vs){\n\t\t\tif(v.pair==null){\n\t\t\t\tfor(V u : vs){\n\t\t\t\t\tu.used=false;\n\t\t\t\t}\n\t\t\t\tif(dfs(v)){\n\t\t\t\t\tmatch++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}\n\n\tboolean dfs(V v){\n\t\tv.used=true;\n\t\tfor(V u : v){\n\t\t\tV w=u.pair;\n\t\t\tif(w==null||!w.used&&dfs(w)){\n\t\t\t\tv.pair=u;\n\t\t\t\tu.pair=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass V extends LinkedList<V>{\n\t\tV pair;\n\t\tboolean used;\n\t\tint i;\n\n\t\tV(int i){\n\t\t\tthis.i=i;\n\t\t}\n\n\t\tvoid connect(V v){\n\t\t\tadd(v);\n\t\t\tv.add(this);\n\t\t}\n\t}\n\n\tint[] pa, rank;\n\n\tvoid init(){\n\t\tpa=new int[l];\n\t\trank=new int[l];\n\t\tfor(int i=0; i<l; i++){\n\t\t\tpa[i]=i;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(pa[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn pa[x]=find(pa[x]);\n\t\t}\n\t}\n\n\tvoid union(int x, int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]>rank[y]){\n\t\t\tpa[y]=x;\n\t\t}else{\n\t\t\tpa[x]=y;\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t//System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\t// System.setIn(new FileInputStream(\"in.txt\"));\n\t\t}catch(Throwable e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m, l;\n\tint[][] w;\n\tint[] p, t;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tl=sc.nextInt();\n\t\t\tif((n|m|l)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw=new int[n][n];\n\t\t\tp=new int[l];\n\t\t\tt=new int[l];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tArrays.fill(w[i], INF);\n\t\t\t\tw[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint u=sc.nextInt();\n\t\t\t\tint v=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tw[u][v]=w[v][u]=d;\n\t\t\t}\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tp[i]=sc.nextInt();\n\t\t\t\tt[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tw[i][j]=Math.min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV[] vs=new V[l*2];\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\tvs[i]=new V(i%l);\n\t\t}\n\t\tfor(int j=0; j<l; j++){\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint u=p[i];\n\t\t\t\tint v=p[j];\n\t\t\t\tif(t[i]+w[u][v]<=t[j]){\n\t\t\t\t\tvs[i].connect(vs[j+l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * for(int i=0; i<l*2; i++){ debug(\"i:\", i); for(V v : vs[i]){\n\t\t * debug(v.i); } }\n\t\t */\n\t\tint match=bm(vs);\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\t// debug(i, \":\", vs[i].pair!=null?vs[i].pair.i:-1);\n\t\t}\n\t\tint ans=0;\n\n\t\tinit();\n\t\tfor(int i=0; i<l; i++){\n\t\t\tif(vs[i].pair!=null)\n\t\t\t\tunion(i, vs[i].pair.i);\n\t\t}\n\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\t//debug(\"pa\", pa);\n\t\tfor(int i=0; i<l; i++){\n\t\t\tset.add(find(pa[i]));\n\t\t}\n\t\tans=set.size();\n\n\t\tprintln(ans+\"\");\n\t}\n\n\tint bm(V[] vs){\n\t\tint match=0;\n\t\tfor(V v : vs){\n\t\t\tif(v.pair==null){\n\t\t\t\tfor(V u : vs){\n\t\t\t\t\tu.used=false;\n\t\t\t\t}\n\t\t\t\tif(dfs(v)){\n\t\t\t\t\tmatch++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}\n\n\tboolean dfs(V v){\n\t\tv.used=true;\n\t\tfor(V u : v){\n\t\t\tV w=u.pair;\n\t\t\tif(w==null||!w.used&&dfs(w)){\n\t\t\t\tv.pair=u;\n\t\t\t\tu.pair=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass V extends LinkedList<V>{\n\t\tV pair;\n\t\tboolean used;\n\t\tint i;\n\n\t\tV(int i){\n\t\t\tthis.i=i;\n\t\t}\n\n\t\tvoid connect(V v){\n\t\t\tadd(v);\n\t\t\tv.add(this);\n\t\t}\n\t}\n\n\tint[] pa, rank;\n\n\tvoid init(){\n\t\tpa=new int[l];\n\t\trank=new int[l];\n\t\tfor(int i=0; i<l; i++){\n\t\t\tpa[i]=i;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(pa[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn pa[x]=find(pa[x]);\n\t\t}\n\t}\n\n\tvoid union(int x, int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]>rank[y]){\n\t\t\tpa[y]=x;\n\t\t}else{\n\t\t\tpa[x]=y;\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\t// System.setIn(new FileInputStream(\"in.txt\"));\n\t\t}catch(Throwable e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n// AC\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m, l;\n\tint[][] w;\n\tint[] p, t;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tl=sc.nextInt();\n\t\t\tif((n|m|l)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw=new int[n][n];\n\t\t\tp=new int[l];\n\t\t\tt=new int[l];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tArrays.fill(w[i], INF);\n\t\t\t\tw[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint u=sc.nextInt();\n\t\t\t\tint v=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tw[u][v]=w[v][u]=d;\n\t\t\t}\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tp[i]=sc.nextInt();\n\t\t\t\tt[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tw[i][j]=Math.min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV[] vs=new V[l*2];\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\tvs[i]=new V(i%l);\n\t\t}\n\t\tfor(int j=0; j<l; j++){\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint u=p[i];\n\t\t\t\tint v=p[j];\n\t\t\t\tif(t[i]+w[u][v]<=t[j]){\n\t\t\t\t\tvs[i].connect(vs[j+l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint match=hopcroftKarp(vs);\n\t\tint ans=l-match;\n\t\tprintln(ans+\"\");\n\t}\n\n\tint hopcroftKarp(V[] vs){\n\t\tfor(int match=0;;){\n\t\t\tQueue<V> que=new LinkedList<V>();\n\t\t\tfor(V v : vs){\n\t\t\t\tv.level=-1;\n\t\t\t}\n\t\t\tfor(V v : vs){\n\t\t\t\tif(v.pair==null){\n\t\t\t\t\tv.level=0;\n\t\t\t\t\tque.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(; !que.isEmpty();){\n\t\t\t\tV v=que.poll();\n\t\t\t\tfor(V u : v){\n\t\t\t\t\tV w=u.pair;\n\t\t\t\t\tif(w!=null&&w.level<0){\n\t\t\t\t\t\tw.level=v.level+1;\n\t\t\t\t\t\tque.offer(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(V v : vs){\n\t\t\t\tv.used=false;\n\t\t\t}\n\t\t\tint d=0;\n\t\t\tfor(V v : vs){\n\t\t\t\tif(v.pair==null&&dfs(v)){\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==0){\n\t\t\t\treturn match;\n\t\t\t}\n\t\t\tmatch+=d;\n\t\t}\n\t}\n\n\tboolean dfs(V v){\n\t\tv.used=true;\n\t\tfor(V u : v){\n\t\t\tV w=u.pair;\n\t\t\tif(w==null||!w.used&&v.level<w.level&&dfs(w)){\n\t\t\t\tv.pair=u;\n\t\t\t\tu.pair=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass V extends LinkedList<V>{\n\t\tV pair;\n\t\tboolean used;\n\t\tint i, level;\n\n\t\tV(int i){\n\t\t\tthis.i=i;\n\t\t}\n\n\t\tvoid connect(V v){\n\t\t\tadd(v);\n\t\t\tv.add(this);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\n\t\t\tlong[][] dist = new long[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dist[i], 1L << 60);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tlong[] t = new long[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = nl();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n//\t\t\tPreflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t// System.out.println((l - pr.calc()));\n\t\t\tout.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tTreeSet<String> used = new TreeSet<String>();\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min*2) / 3;\n\t\t\t\tused.clear();\n\t\t\t\tString state = \"000\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tq.clear();\n\t\t\t\t// Queue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t\t\t\t// System.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2 + 3, 3 + i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub, 16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(3, 3 + i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2 + 3,\n\t\t\t\t\t\t\t\t\tc.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%02x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, c.j + 1, String.format(\n\t\t\t\t\t\t\t\t\t\t\"%03x\", c.j) + newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 29;\n\tvoid solve() {\n\t\tint[][] distance = new int[100][100];\n\t\t\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif (N + M + L == 0) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tdistance[k][k] = 0;\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\t//??????????±?????°??????????\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 28;\n\tvoid solve() {\n\t\tint[][] distance = new int[100][100];\n\t\t\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 100; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tdistance[k][k] = 0;\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//package J;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tHashSet<String> used = new HashSet<String>((int) 1e6);\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + 3*min) / 4;\n\t\t\t\tused.clear();\n\t\t\t\tString state = \"000\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tq.clear();\n\t\t\t\t// Queue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\n\t\t\t\tint temp = 0;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t\t\t\t// System.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttemp = c.j;\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2 + 3, 3 + i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub, 16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(3, 3 + i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2 + 3,\n\t\t\t\t\t\t\t\t\tc.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%02x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, c.j + 1, String.format(\n\t\t\t\t\t\t\t\t\t\t\"%03x\", c.j) + newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check) {\n\t\t\t\t\tmax = Math.min(max,mid + l - temp);\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\n\t\tint[][] dist = new int[100][100];\n\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tArrays.fill(dist[i], 1 << 28);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\t\t\t\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tint[] t = new int[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n\t\t\t// Preflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t// System.out.println((l - pr.calc()));\n\t\t\tout.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package J.copy;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tclass Arrow {\n\t\tint cap;\n\t\tint flow;\n\t\tint from;\n\t\tint to;\n\n\t\tArrow(int from, int to) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cap = 1;\n\t\t\tthis.flow = 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tLinkedList<Arrow> A = new LinkedList<Arrow>();\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tif (d[req[i].p][req[j].p] <= -req[i].t + req[j].t) {\n\t\t\t\t\t\tA.add(new Arrow(i, j));\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean s[] = new boolean[l];\n\t\t\tboolean t[] = new boolean[l];\n\n\t\t\tint count = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\tboolean end = true;\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (!s[i]) {\n\t\t\t\t\t\tif (dfs(s, t, A, i , new boolean[l])) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tend = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(end){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l-count);\n\t\t}\n\n\t}\n\n\tboolean dfs(boolean[] s, boolean[] t, LinkedList<Arrow> A, int p, boolean[] passed) {\n\t\tif(passed[p]){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tpassed[p] = true;\n\t\t}\n\t\tfor(Arrow hen:A){\n\t\t\tif(hen.from != p){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(hen.flow == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\then.flow = 1;\n\t\t\ts[hen.from] = true;\n\t\t\tif(!t[hen.to]){\n\t\t\t\tt[hen.to] = true;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t\tif(bdfs(s,t,A,hen.to , passed)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\then.flow = 0;\n\t\t\t\ts[hen.from] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tboolean bdfs(boolean[] s, boolean[] t, LinkedList<Arrow> A, int p, boolean[] passed) {\n\t\tfor(Arrow hen:A){\n\t\t\tif(hen.to != p){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(hen.flow == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\then.flow = 0;\n\t\t\t\n\t\t\tif(dfs(s,t,A,hen.from , passed)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\then.flow = 1;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Merry Christmas\npublic class Main{\n\n\tint INF = 1<<29;\n\t\n\t@SuppressWarnings(\"unused\")\n\tint[] bipartiteMatching(boolean[][] graph) {\n\t\tint n = graph.length;\n\t\tif(n==0)return new int[0];\n\t\tint m = graph[0].length;\n\t\tint[] match = new int[m];\n\t\tArrays.fill(match, -1);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tboolean[] visited = new boolean[m];\n\t\t\tif (go(i,graph,visited,match)) res++;\n\t\t}\n\t\treturn match;\n\t}\n\tboolean go(int v,boolean[][] graph,boolean[] visited,int[] match) {\n\t\tint m = graph[0].length;\n\t\tfor (int i = 0; i < m; i++)  if (!visited[i] && graph[v][i] && match[i] == -1) {\n\t\t\tvisited[i] = true;\n\t\t\tmatch[i] = v;\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) if (!visited[i] && graph[v][i]) {\n\t\t\tvisited[i] = true;\n\t\t\tif (go(match[i],graph,visited,match)) {\n\t\t\t\tmatch[i] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tint[][] wf = new int[100][100];\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), L = sc.nextInt();\n\t\t\tif((n|m|L)==0)break;\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=INF;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), d = sc.nextInt();\n\t\t\t\twf[s][t] = wf[t][s] = d;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tboolean[][] e = new boolean[L][L];\n\t\t\tfor(int i=0;i<L;i++)for(int j=0;j<L;j++)e[i][j]=false;\n\t\t\tint[] p = new int[L], t = new int[L];\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tp[i] = sc.nextInt(); t[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<L;i++)for(int j=0;j<L;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(p[i]==p[j]){\n\t\t\t\t\tif(t[i]<t[j])e[i][j]=true;\n\t\t\t\t}\n\t\t\t\telse if(t[i]+wf[p[i]][p[j]]<=t[j])e[i][j]=true;\n\t\t\t}\n\t\t\tint[] r = bipartiteMatching(e);\n\t\t\tint res = 0;\n\t\t\tfor(int x:r)if(x!=-1)res++;\n\t\t\tSystem.out.println(L-res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tHashSet<String> used = new HashSet<String>();\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min*2) / 3;\n\t\t\t\tused.clear();\n\t\t\t\tString state = \"000\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tq.clear();\n\t\t\t\t// Queue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t\t\t\t// System.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2 + 3, 3 + i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub, 16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(3, 3 + i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2 + 3,\n\t\t\t\t\t\t\t\t\tc.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%02x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, c.j + 1, String.format(\n\t\t\t\t\t\t\t\t\t\t\"%03x\", c.j) + newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint l = sc.nextInt();\n\n\t\tint[][] dist = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.fill(dist, 1 << 30);\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt(), v = sc.nextInt(), d = sc.nextInt();\n\t\t\tdist[u][v] = d;\n\t\t\tdist[v][u] = d;\n\t\t}\n\n\t\tint[] p = new int[l];\n\t\tlong[] t = new long[l];\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tp[l] = sc.nextInt();\n\t\t\tt[l] = sc.nextLong();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Edge>[] g = new ArrayList[2 * n + 2];\n\t\tfor (int i = 0; i < 2 * n + 2; i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\tif (dist[p[i]][p[j]] <= t[j] - t[i]) {\n\t\t\t\t\tg[p[i]].add(new Edge(p[i], n + p[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[2 * n - 1].add(new Edge(2 * n - 1, i, 1));\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i + n].add(new Edge(i + n, 2 * n, 1));\n\t\t}\n\n\t\tPreflow_Relabel pr = new Preflow_Relabel(2 * n - 1, 2 * n, g);\n\t\tSystem.out.println((n - pr.calc()));\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min) / 2;\n\t\t\t\tTreeSet<String> used = new TreeSet<String>();\n\t\t\t\tString state = \"\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n//\t\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t//\t\t\tSystem.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2, i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub,16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(0, i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2, c.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%02x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t//\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, 0, newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 29;\n\tvoid solve() {\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif (N + M + L == 0) break;\n\t\t\t\n\t\t\tint[][] distance = new int[N][N];\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tdistance[k][k] = 0;\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\t//??????????±?????°??????????\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\n\t\t\tlong[][] dist = new long[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dist[i], 1L << 60);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt(), v = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tlong[] t = new long[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextLong();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n\t\t\tPreflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\tSystem.out.println((l - pr.calc()));\n//\t\t\tSystem.out.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tclass Arrow {\n\t\tint cap;\n\t\tint flow;\n\t\tint from;\n\t\tint to;\n\n\t\tArrow(int from, int to) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cap = 1;\n\t\t\tthis.flow = 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tLinkedList<Arrow> A = new LinkedList<Arrow>();\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tif (d[req[i].p][req[j].p] <= -req[i].t + req[j].t) {\n\t\t\t\t\t\tA.add(new Arrow(i, j));\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean s[] = new boolean[l];\n\t\t\tboolean t[] = new boolean[l];\n\n\t\t\tint count = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\tboolean end = true;\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (!s[i]) {\n\t\t\t\t\t\tif (dfs(s, t, A, i , new boolean[l])) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tend = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(end){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l-count);\n\t\t}\n\n\t}\n\n\tboolean dfs(boolean[] s, boolean[] t, LinkedList<Arrow> A, int p, boolean[] passed) {\n\t\tif(passed[p]){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tpassed[p] = true;\n\t\t}\n\t\tfor(Arrow hen:A){\n\t\t\tif(hen.from != p){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(hen.flow == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\then.flow = 1;\n\t\t\ts[hen.from] = true;\n\t\t\tif(!t[hen.to]){\n\t\t\t\tt[hen.to] = true;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t\tif(bdfs(s,t,A,hen.to , passed)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\then.flow = 0;\n\t\t\t\ts[hen.from] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tboolean bdfs(boolean[] s, boolean[] t, LinkedList<Arrow> A, int p, boolean[] passed) {\n\t\tfor(Arrow hen:A){\n\t\t\tif(hen.to != p){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(hen.flow == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\then.flow = 0;\n\t\t\t\n\t\t\tif(dfs(s,t,A,hen.from , passed)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\then.flow = 1;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main{\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 29;\n\tvoid solve() {\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif (N + M + L == 0) break;\n\t\t\t\n\t\t\tint[][] distance = new int[N][N];\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\t//??????????±?????°??????????\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tclass Node implements Comparable<Node> {\n\t\tint p, t;\n\t\tint j = 0;\n\t\tString s;\n\n\t\tNode(int p, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tNode(int p, int t, String s) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int compareTo(Node tar) {\n\t\t\treturn this.t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tif ((n | m | l) == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint d[][] = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() + 1;\n\t\t\t\tint v = sc.nextInt() + 1;\n\t\t\t\td[u][v] = d[v][u] = sc.nextInt();\n\t\t\t}\n\t\t\tNode[] req = new Node[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\treq[i] = new Node(sc.nextInt() + 1, sc.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(req);\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\td[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[0][i] = 0;\n\t\t\t}\n\n\t\t\tboolean r[][] = new boolean[n][n];\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = i + 1; j < l; j++) {\n\t\t\t\t\tr[req[i].p][req[j].p] = d[req[i].p][req[j].p] <= -req[i].t\n\t\t\t\t\t\t\t+ req[j].t;\n\t\t\t\t\t// System.out.println(i+\" \"+j+\" \" + r[req[i].p][req[j].p]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[0][i] = true;\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 0;\n\t\t\tTreeSet<String> used = new TreeSet<String>();\n\t\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\t\tfor (;;) {\n\t\t\t\tif (max == min)\n\t\t\t\t\tbreak;\n\t\t\t\tint mid = (max + min) / 2;\n\t\t\t\tused.clear();\n\t\t\t\tString state = \"000\";\n\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\tstate += \"00\";\n\t\t\t\t}\n\t\t\t\tq.clear();\n\t\t\t\t// Queue<Node> q = new LinkedList<Node>();\n\t\t\t\tq.add(new Node(0, 0, state));\n\t\t\t\tboolean check = false;\n\t\t\t\tfor (; !q.isEmpty();) {\n\t\t\t\t\tNode c = q.poll();\n\t\t\t\t\t// System.out.println(c.s);\n\t\t\t\t\tif (c.j == l) {\n\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (used.contains(c.s))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused.add(c.s);\n\t\t\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\t\t\tString sub = c.s.substring(i * 2 + 3, 3 + i * 2 + 2);\n\t\t\t\t\t\tint pos = Integer.valueOf(sub, 16);\n\t\t\t\t\t\tif (r[pos][req[c.j].p]) {\n\t\t\t\t\t\t\tString a = c.s.substring(3, 3 + i * 2);\n\t\t\t\t\t\t\tString b = c.s.substring(i * 2 + 2 + 3,\n\t\t\t\t\t\t\t\t\tc.s.length());\n\t\t\t\t\t\t\tString newS = a + String.format(\"%02x\", req[c.j].p)\n\t\t\t\t\t\t\t\t\t+ b;\n\t\t\t\t\t\t\tif (!used.contains(newS)) {\n\t\t\t\t\t\t\t\tNode sa = new Node(0, c.j + 1, String.format(\n\t\t\t\t\t\t\t\t\t\t\"%03x\", c.j) + newS);\n\t\t\t\t\t\t\t\tsa.j = c.j + 1;\n\t\t\t\t\t\t\t\tq.add(sa);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!check)\n\t\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"./data/judge/201707/2251.txt\";\n\t\n\tstatic final int INF = 1 << 28;\n\tvoid solve() {\n\t\tint[][] distance = new int[100][100];\n\t\t\n\t\twhile (true){\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint L = ni();\n\t\t\tif(N == 0 && M == 0 && L == 0) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 100; ++i){\n\t\t\t\tArrays.fill(distance[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = ni();\n\t\t\t\tint to = ni();\n\t\t\t\tint dis = ni();\n\t\t\t\tdistance[from][to] = dis;\n\t\t\t\tdistance[to][from] = dis;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\tdistance[k][k] = 0;\n\t\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\t\tdistance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] p = new int[L];\n\t\t\tint[] t = new int[L];\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\t\t\t\n\t\t\tinit(2 * L);\n\t\t\tfor (int i = 0; i < L; ++i){\n\t\t\t\tfor (int j = 0; j < L; ++j){\n\t\t\t\t\tif (i != j && t[i] + distance[p[i]][p[j]] <= t[j]){\n\t\t\t\t\t\taddEdge(2 * i, 2 * j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(L - bipartiteMatching());\n\t\t}\n\t}\n\t\n\t//??????????±?????°??????????\n\tList<Integer>[] g;\n\tint V;\n\tint[] matching;\n\tpublic void init(int n){\n\t\tV = n;\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) g[i] = new ArrayList<Integer>();\n\t\tmatching = new int[V];\n\t}\n\t\n\tpublic void addEdge(int from, int to){\n\t\tg[from].add(to);\n\t\tg[to].add(from);\n\t}\n\t\n\tpublic boolean dfs(int v, boolean[] visited){\n\t\tvisited[v] = true;\n\t\tfor (int u : g[v]){\n\t\t\tint w = matching[u];\n\t\t\tif (w == -1 || !visited[w] && dfs(w, visited)){\n\t\t\t\tmatching[u] = v;\n\t\t\t\tmatching[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int bipartiteMatching(){\n\t\tint res = 0;\n\t\tArrays.fill(matching, -1);\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tif (matching[i] < 0){\n\t\t\t\tif (dfs(i, new boolean[V])){\n\t\t\t\t\tres ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\tvoid run() throws Exception {\n\t\tis = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m, l;\n\tint[][] w;\n\tint[] p, t;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tl=sc.nextInt();\n\t\t\tif((n|m|l)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw=new int[n][n];\n\t\t\tp=new int[l];\n\t\t\tt=new int[l];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tArrays.fill(w[i], INF);\n\t\t\t\tw[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint u=sc.nextInt();\n\t\t\t\tint v=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tw[u][v]=w[v][u]=d;\n\t\t\t}\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tp[i]=sc.nextInt();\n\t\t\t\tt[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tw[i][j]=Math.min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV[] vs=new V[l*2];\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\tvs[i]=new V(i%l);\n\t\t}\n\t\tfor(int j=0; j<l; j++){\n\t\t\tfor(int i=0; i<l; i++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint u=p[i];\n\t\t\t\tint v=p[j];\n\t\t\t\tif(t[i]+w[u][v]<=t[j]){\n\t\t\t\t\tvs[i].connect(vs[j+l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * for(int i=0; i<l*2; i++){ debug(\"i:\", i); for(V v : vs[i]){\n\t\t * debug(v.i); } }\n\t\t */\n\t\tint match=bm(vs);\n\t\tfor(int i=0; i<l*2; i++){\n\t\t\t// debug(i, \":\", vs[i].pair!=null?vs[i].pair.i:-1);\n\t\t}\n\t\tint ans=0;\n\n\t\tinit();\n\t\tfor(int i=0; i<l; i++){\n\t\t\tif(vs[i].pair!=null)\n\t\t\t\tunion(i, vs[i].pair.i);\n\t\t}\n\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\t//debug(\"pa\", pa);\n\t\tfor(int i=0; i<l; i++){\n\t\t\t// set.add(find(pa[i]));\n\t\t}\n\t\tans=set.size();\n\n\t\tprintln(ans+\"\");\n\t}\n\n\tint bm(V[] vs){\n\t\tint match=0;\n\t\tfor(V v : vs){\n\t\t\tif(v.pair==null){\n\t\t\t\tfor(V u : vs){\n\t\t\t\t\tu.used=false;\n\t\t\t\t}\n\t\t\t\tif(dfs(v)){\n\t\t\t\t\tmatch++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}\n\n\tboolean dfs(V v){\n\t\tv.used=true;\n\t\tfor(V u : v){\n\t\t\tV w=u.pair;\n\t\t\tif(w==null||!w.used&&dfs(w)){\n\t\t\t\tv.pair=u;\n\t\t\t\tu.pair=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass V extends LinkedList<V>{\n\t\tV pair;\n\t\tboolean used;\n\t\tint i;\n\n\t\tV(int i){\n\t\t\tthis.i=i;\n\t\t}\n\n\t\tvoid connect(V v){\n\t\t\tadd(v);\n\t\t\tv.add(this);\n\t\t}\n\t}\n\n\tint[] pa, rank;\n\n\tvoid init(){\n\t\tpa=new int[l];\n\t\trank=new int[l];\n\t\tfor(int i=0; i<l; i++){\n\t\t\tpa[i]=i;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(pa[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn pa[x]=find(pa[x]);\n\t\t}\n\t}\n\n\tvoid union(int x, int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]>rank[y]){\n\t\t\tpa[y]=x;\n\t\t}else{\n\t\t\tpa[x]=y;\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\t// System.setIn(new FileInputStream(\"in.txt\"));\n\t\t}catch(Throwable e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\n\t\tint[][] dist = new int[100][100];\n\n\t\twhile (true) {\n\t\t\tint n = ni();\n\t\t\tint m = ni();\n\t\t\tint l = ni();\n\t\t\tif (n == 0 && m == 0 && l == 0)\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tArrays.fill(dist[i], 1 << 28);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\t\t\t\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = ni(), v = ni(), d = ni();\n\t\t\t\tdist[u][v] = d;\n\t\t\t\tdist[v][u] = d;\n\t\t\t}\n\n\t\t\tint[] p = new int[l];\n\t\t\tint[] t = new int[l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tp[i] = ni();\n\t\t\t\tt[i] = ni();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[2 * l + 2];\n\t\t\tfor (int i = 0; i < 2 * l + 2; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dist[p[i]][p[j]] + t[i] <= t[j]) {\n\t\t\t\t\t\tg[i].add(new Edge(i, l + j, 1));\n\t\t\t\t\t\t// System.out.println(dist[p[i]][p[j]] + t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[2 * l].add(new Edge(2 * l, i, 1));\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tg[i + l].add(new Edge(i + l, 2 * l + 1, 1));\n\t\t\t}\n\n\t\t\t Preflow_Relabel pr = new Preflow_Relabel(2 * l, 2 * l + 1, g);\n\t\t\t System.out.println((l - pr.calc()));\n//\t\t\tout.println((l - new Edmonds_Kerp_MaxFlow(2 * l, 2 * l + 1, g).MaxFlow()));\n\t\t}\n\t}\n\n\tclass Edmonds_Kerp_MaxFlow {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Edmonds_Kerp_MaxFlow(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint MaxFlow() {\n\t\t\tint total = 0;\n\t\t\twhile (true) {\n\t\t\t\tint[] prev = bfs();\n\t\t\t\tif (prev[t] == -1)\n\t\t\t\t\treturn total;\n\t\t\t\tint inc = 1 << 30;\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tinc = Math.min(inc, residue(prev[i], i));\n\t\t\t\t}\n\t\t\t\tfor (int i = t; prev[i] != -1; i = prev[i]) {\n\t\t\t\t\tpush(prev[i], i, inc);\n\t\t\t\t}\n\t\t\t\ttotal += inc;\n\t\t\t}\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tint[] bfs() {\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tque.add(s);\n\t\t\tout: while (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (prev[e.dst] == -1 && e.dst != s && residue(v, e.dst) > 0) {\n\t\t\t\t\t\tprev[e.dst] = v;\n\t\t\t\t\t\tque.add(e.dst);\n\t\t\t\t\t\tif (e.dst == t)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prev;\n\t\t}\n\n\t\tvoid push(int s, int t, int inc) {\n\t\t\tflow[s][t] += inc;\n\t\t\tflow[t][s] -= inc;\n\t\t}\n\t}\n\n\tclass Preflow_Relabel {\n\t\tint n;\n\t\tint s;\n\t\tint t;\n\t\tArrayList<Edge>[] g;\n\t\tint[][] flow;\n\t\tint[][] capacity;\n\t\tint[] excess;\n\t\tint[] height;\n\t\tArrayDeque<Integer>[] B;\n\n\t\tvoid global_relabeling() {\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\t\tboolean[] arrived = new boolean[n];\n\t\t\tque.add(t);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint v = que.poll();\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (residue(e.dst, v) > 0 && (height[v] + 1 < height[e.dst] || !arrived[e.dst])) {\n\t\t\t\t\t\theight[e.dst] = height[v] + 1;\n\t\t\t\t\t\tarrived[e.dst] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Preflow_Relabel(int s, int t, ArrayList<Edge>[] g) {\n\t\t\tthis.g = g;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tn = g.length;\n\t\t\tflow = new int[n][n];\n\t\t\tcapacity = new int[n][n];\n\t\t\theight = new int[n];\n\t\t\theight[s] = n;\n\t\t\texcess = new int[n];\n\t\t\tB = new ArrayDeque[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tB[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tB[height[s]].add(s);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : g[i]) {\n\t\t\t\t\tif (e.weight > 0) {\n\t\t\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0));\n\t\t\t\t\t\tcapacity[e.src][e.dst] += e.weight;\n\t\t\t\t\t} else if (e.weight == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint b = 0;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tint calc() {\n\t\t\tint count = 0;\n\t\t\tfor (Edge e : g[s]) {\n\t\t\t\texcess[s] += e.weight;\n\t\t\t\tpush(s, e.dst);\n\t\t\t\tB[height[e.dst]].add(e.dst);\n\t\t\t}\n\t\t\tglobal_relabeling();\n\t\t\tfor (b = height[s]; b >= 0;) {\n\t\t\t\tif (B[b].isEmpty()) {\n\t\t\t\t\tb--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint v = B[b].poll();\n\t\t\t\tif (excess[v] == 0 || v == t || v == s || height[v] > n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\tif (height[e.src] == height[e.dst] + 1) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tpush(e.src, e.dst);\n\t\t\t\t\t\t\tif (excess[v] == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (excess[v] > 0) {\n\t\t\t\t\tint min = 1 << 30;\n\t\t\t\t\tfor (Edge e : g[v]) {\n\t\t\t\t\t\tif (residue(e.src, e.dst) > 0) {\n\t\t\t\t\t\t\tmin = Math.min(min, height[e.dst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theight[v] = min + 1;\n\t\t\t\t\tif (height[v] < n) {\n\t\t\t\t\t\tB[height[v]].add(v);\n\t\t\t\t\t\tif (height[v] > b)\n\t\t\t\t\t\t\tb = height[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (++count % n == 0) {\n\t\t\t\t\tglobal_relabeling();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excess[t];\n\t\t}\n\n\t\tint residue(int s, int t) {\n\t\t\treturn capacity[s][t] - flow[s][t];\n\t\t}\n\n\t\tvoid push(int u, int v) {\n\t\t\tint delta = Math.min(excess[u], residue(u, v));\n\t\t\tflow[u][v] += delta;\n\t\t\tflow[v][u] -= delta;\n\t\t\texcess[v] += delta;\n\t\t\texcess[u] -= delta;\n\t\t\tif (v != t && v != s && height[v] < n) {\n\t\t\t\tB[height[v]].add(v);\n\t\t\t\tif (b < height[v]) {\n\t\t\t\t\tb = height[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint weight;\n\n\t\tEdge(int src, int dst, int weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : (d[x] = root(d[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (d[x] < d[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing C = System.Int32;\nusing V = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            while (true)\n            {\n                var n = ri;\n                var m = ri;\n                var l = ri;\n                if (n == 0) break;\n                var g = Enumerate(n, x => new long[n]);\n                for (int i = 0; i < n; i++)\n                    for (int j = i + 1; j < n; j++)\n                        g[i][j] = g[j][i] = INF;\n                for (int i = 0; i < m; i++)\n                {\n                    var f = ri;\n                    var t = ri;\n                    var c = ri;\n                    g[f][t] = g[t][f] = c;\n                }\n                for (int k = 0; k < n; k++)\n                    for (int i = 0; i < n; i++)\n                        for (int j = 0; j < n; j++)\n                            g[i][j] = Math.Min(g[i][j], g[i][k] + g[k][j]);\n                var G = new MaxFlow(2 * l + 2);\n                var u = new int[l];\n                var v = new int[l];\n                var src = 2 * l;\n                var sink = src + 1;\n                for (int i = 0; i < l; i++)\n                {\n                    G.AddDirectedEdge(src, i, 1);\n                    G.AddDirectedEdge(i + l, sink, 1);\n                    u[i] = ri;\n                    v[i] = ri;\n                    for (int j = 0; j < i; j++)\n                    {\n                        if (v[j] + g[u[j]][u[i]] <= v[i]) G.AddDirectedEdge(j, i + l, 1);\n                        if (v[i] + g[u[j]][u[i]] <= v[j]) G.AddDirectedEdge(i, j + l, 1);\n                    }\n                }\n                //for (int i = 0; i < 2 * l + 2; i++) foreach (var e in G.G[i]) if (e.Cap != 0) IO.Printer.Out.WriteLine($\"{i} {e.To} {e.Cost}\");\n                var mf = G.Execute(src, sink, INF);\n                IO.Printer.Out.WriteLine(l - mf);\n                //IO.Printer.Out.WriteLine(\"\");\n\n            }\n        }\n\n        const int INF = (int)1e9 + 1;\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n#region MaxFlow\npublic partial class MaxFlow\n{\n    public readonly List<Edge>[] G;\n    readonly int[] lv, iter;\n    public MaxFlow(int V)\n    {\n        G = new List<Edge>[V];\n        lv = new int[V];\n        iter = new int[V];\n        for (int i = 0; i < G.Length; i++)\n            G[i] = new List<Edge>();\n    }\n\n    public void AddDirectedEdge(int from, int to, C cap)\n    {\n        addEdge(from, to, cap, 0);\n    }\n\n    public void AddUndirectedEdge(int from, int to, C cap)\n    {\n        addEdge(from, to, cap, cap);\n    }\n    void addEdge(int f, int t, C c1, C c2)\n    {\n        var a = new Edge(t, c1);\n        var b = new Edge(f, c2);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n\n\n    public C Execute(int src, int sink, C f = -1)\n    {\n        C flow = 0;\n        if (f < 0) f = C.MaxValue;\n        while (f > 0)\n        {\n            bfs(src);\n            if (lv[sink] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            C df;\n            while ((df = dfs(src, sink, f)) > 0) { flow += df; f -= df; }\n        }\n        return flow;\n    }\n\n    void bfs(int s)\n    {\n        Array.Clear(lv, 0, lv.Length);\n        var q = new Queue<int>();\n        lv[s] = 1;\n        q.Enqueue(s);\n        while (q.Count > 0)\n        {\n            var v = q.Dequeue();\n            foreach (var e in G[v])\n                if (e.Cap > 0 && lv[e.To] == 0)\n                {\n                    lv[e.To] = lv[v] + 1;\n                    q.Enqueue(e.To);\n                }\n        }\n\n    }\n    C dfs(int v, int t, C f)\n    {\n        if (v == t) return f;\n        C ret = 0;\n        for (; iter[v] < G[v].Count; iter[v]++)\n        {\n            var e = G[v][iter[v]];\n            if (e.Cap <= 0 || lv[v] >= lv[e.To]) continue;\n            C df = dfs(e.To, t, Math.Min(f, e.Cap));\n            if (df <= 0) continue;\n            e.Cap -= df;\n            e.Rev.Cap += df;\n            ret += df; f -= df;\n            if (f == 0) break;\n        }\n        return ret;\n\n    }\n}\npublic class Edge\n{\n    public static void Link(Edge e1, Edge e2)\n    {\n        e1.Rev = e2; e2.Rev = e1;\n    }\n    public int To { get; private set; }\n    public Edge Rev { get; private set; }\n    public C Cap { get; set; }\n    public Edge(int t, C c)\n    {\n        To = t;\n        Cap = c;\n    }\n    public override string ToString()\n    {\n        return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n    }\n}\n#endregion\n\n#region MinCostFlow\npublic class MinCostFlow\n{\n    bool hasng;\n    public readonly List<Edge>[] G;\n    public MinCostFlow(int V)\n    {\n        G = new List<Edge>[V];\n        for (int i = 0; i < V; i++)\n            G[i] = new List<Edge>();\n\n    }\n    public void AddDirectedEdge(int from, int to, C cap, V cost)\n    {\n        addEdge(from, to, cap, 0, cost);\n    }\n\n    public KeyValuePair<C, V> Execute(int src, int sink, C f = C.MaxValue, V inf = V.MaxValue / 2)\n    {\n        var n = G.Length;\n        var dist = new V[n];\n        var prev = new int[n];\n        var prevEdge = new Edge[n];\n        var potential = new V[n];\n\n\n        C flow = 0;\n        V cost = 0;\n        var first = hasng;\n        while (f > 0)\n        {\n            for (int i = 0; i < G.Length; i++)\n                dist[i] = inf;\n\n            //shortest path\n            if (first)//spfa\n            {\n                var q = new Queue<int>();\n                q.Enqueue(src); dist[src] = 0;\n                var inQ = new bool[n];\n                while (q.Count > 0)\n                {\n                    var p = q.Dequeue();\n                    inQ[p] = false;\n                    foreach (var e in G[p])\n                    {\n                        var t = e.To;\n                        var d = dist[p] + e.Cost;\n                        if (e.Cap > 0 && d < dist[t])\n                        {\n                            if (!inQ[t])\n                            {\n                                inQ[t] = true;\n                                q.Enqueue(t);\n                            }\n                            dist[t] = d; prev[t] = p; prevEdge[t] = e;\n                        }\n                    }\n                }\n                first = false;\n            }\n            else//dijkstra\n            {\n                var vis = new bool[n];\n                var pq = new PriorityQueue<KeyValuePair<int, V>>((l, r) => l.Value.CompareTo(r.Value));\n                pq.Enqueue(new KeyValuePair<int, V>(src, 0));\n                dist[src] = 0;\n                while (pq.Count > 0)\n                {\n                    var p = pq.Dequeue().Key;\n                    if (vis[p]) continue;\n                    //Debug.WriteLine(p);\n                    vis[p] = true;\n                    foreach (var e in G[p])\n                    {\n                        if (e.Cap <= 0) continue;\n                        var t = e.To;\n                        if (vis[t]) continue;\n                        var d = dist[p] + e.Cost + potential[p] - potential[t];\n                        if (dist[t] > d)\n                        {\n                            dist[t] = d; prev[t] = p; prevEdge[t] = e;\n                            pq.Enqueue(new KeyValuePair<int, V>(t, d));\n                        }\n                    }\n                }\n\n\n            }\n\n\n            //update\n            {\n                if (dist[sink] == inf) break;\n                for (int i = 0; i < n; i++)\n                    potential[i] = Math.Min(inf, potential[i] + dist[i]);\n                C df = f;\n                V d = 0;\n                for (var v = sink; v != src; v = prev[v])\n                {\n                    var e = prevEdge[v];\n                    df = Math.Min(df, e.Cap); d += e.Cost;\n                }\n                if (d == 0) break;\n                f -= df; cost += df * d; flow += df;\n                for (var v = sink; v != src; v = prev[v])\n                {\n                    var e = prevEdge[v];\n                    e.Cap -= df; e.Rev.Cap += df;\n                }\n            }\n\n        }\n        return new KeyValuePair<C, V>(flow, cost);\n    }\n    void addEdge(int f, int t, C c1, C c2, V e)\n    {\n        if (e < 0) hasng = true;\n        var a = new Edge(t, c1, e);\n        var b = new Edge(f, c2, -e);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n    public class Edge\n    {\n        public static void Link(Edge e1, Edge e2)\n        {\n            e1.Rev = e2; e2.Rev = e1;\n        }\n        public int To { get; private set; }\n        public Edge Rev { get; private set; }\n        public V Cost { get; private set; }\n        public C Cap { get; set; }\n        public Edge(int t, C c, V e)\n        {\n            To = t;\n            Cap = c;\n            Cost = e;\n        }\n        public override string ToString()\n        {\n            return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n        }\n    }\n}\n#endregion\n\n#region BinaryHeap\npublic class PriorityQueue<T>\n{\n    readonly List<T> heap = new List<T>();\n    readonly Comparison<T> compare;\n    public PriorityQueue() { compare = Comparer<T>.Default.Compare; }\n\n    public PriorityQueue(Comparison<T> comparison) { compare = comparison; }\n    public PriorityQueue(IComparer<T> comparer) { compare = comparer.Compare; }\n\n    public void Enqueue(T item)\n    {\n        var pos = heap.Count;\n        heap.Add(item);\n        while (pos > 0)\n        {\n            var par = (pos - 1) / 2;\n            if (compare(heap[par], item) <= 0)\n                break;\n            heap[pos] = heap[par];\n            pos = par;\n        }\n        heap[pos] = item;\n\n    }\n\n    public T Dequeue()\n    {\n        var ret = heap[0];\n        var pos = 0;\n        var x = heap[heap.Count - 1];\n\n        while (pos * 2 + 1 < heap.Count - 1)\n        {\n            var lch = pos * 2 + 1;\n            var rch = pos * 2 + 2;\n            if (rch < heap.Count - 1 && compare(heap[rch], heap[lch]) < 0) lch = rch;\n            if (compare(heap[lch], x) >= 0)\n                break;\n            heap[pos] = heap[lch];\n            pos = lch;\n        }\n        heap[pos] = x;\n        heap.RemoveAt(heap.Count - 1);\n        return ret;\n\n    }\n    public T Peek() { return heap[0]; }\n    public int Count { get { return heap.Count; } }\n    public bool Any() { return heap.Count > 0; }\n\n    public T[] Items\n    {\n        get\n        {\n            var ret = heap.ToArray();\n            Array.Sort(ret, compare);\n            return ret;\n        }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tint[] s=sc.Ia;\n\t\twhile(s[0]!=0){\n\t\t\tint n=s[0],m=s[1],q=s[2];\n\t\t\tvar c=new int[n+1];\n\t\t\tlong inf=long.MaxValue>>1;\n\t\t\tvar dp=new long[n][];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdp[i]=new long[n];\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i!=j){dp[i][j]=inf;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint[] e=sc.Ia;\n\t\t\t\tdp[e[0]][e[1]]=dp[e[1]][e[0]]=e[2];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){dp[j][k]=Min(dp[j][k],dp[j][i]+dp[i][k]);}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar a=sc.Arr(q,()=>sc.Ia);\n\t\t\tint g=(q<<1)+1;\n\t\t\tvar fl=new Mfp(g+1);\n\t\t\tfor(int i = 0;i<q;i++) {\n\t\t\t\tfl.Edge(g-1,i,1);\n\t\t\t\tfl.Edge(i+q,g,1);\n\t\t\t\tfor(int j = i+1;j<q;j++) {\n\t\t\t\t\tif(dp[a[i][0]][a[j][0]]<=a[j][1]-a[i][1]){fl.Edge(i,j+q,1);}\n\t\t\t\t\telse if(dp[a[i][0]][a[j][0]]<=a[i][1]-a[j][1]){fl.Edge(j,i+q,1);}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.Append((q-fl.Dinic(g-1,g))+\"\\n\");\n\t\t\ts=sc.Ia;\n\t\t}\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Mfp{\n\tpublic List<int>[] li;\n\tprivate Dictionary<int,int>[] h;\n\tprivate bool[] b;\n\tprivate int[] l;\n\tprivate int n,ans,go;\n\tprivate const int inf=int.MaxValue;\n\tpublic Mfp(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t}\n\t}\n\tpublic void Edge(int a,int b,int c){\n\t\tif(a==b){return;}\n\t\tif(!h[a].ContainsKey(b)){\n\t\t\tli[a].Add(b);\n\t\t\tli[b].Add(a);\n\t\t\th[a].Add(b,c);\n\t\t\th[b].Add(a,0);\n\t\t}\n\t\telse{h[a][b]+=c;}\n\t}\n\tpublic int Dinic(int st,int go){\n\t\tthis.go=st;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tl=new int[n];\n\t\t\tvar qu=new Queue<Tuple<int,int>>();\n\t\t\tqu.Enqueue(Tuple.Create(st,1));\n\t\t\tl[st]=1;\n\t\t\twhile(qu.Count>0){\n\t\t\t\tvar e=qu.Dequeue();\n\t\t\t\tfor(int i=0;i<li[e.Item1].Count;i++){\n\t\t\t\t\tif(l[li[e.Item1][i]]==0&&h[e.Item1][li[e.Item1][i]]!=0){\n\t\t\t\t\t\tl[li[e.Item1][i]]=e.Item2+1;\n\t\t\t\t\t\tqu.Enqueue(Tuple.Create(li[e.Item1][i],e.Item2+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e.Item1==go){break;}\n\t\t\t}\n\t\t\tb=new bool[n];\n\t\t\tz=Fu3(go,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu3(int a,int p){\n\t\tif(a==go){return p;}\n\t\tint u=0;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&l[li[a][i]]<l[a]&&h[li[a][i]][a]!=0){\n\t\t\t\tint z=Fu3(li[a][i],Min(p-u,h[li[a][i]][a]));\n\t\t\t\th[li[a][i]][a]-=z;\n\t\t\t\th[a][li[a][i]]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u==0){b[a]=true;}\n\t\treturn u;\n\t}\n\tpublic int Ff(int st,int go){\n\t\tthis.go=go;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tb=new bool[n];\n\t\t\tz=Fu2(st,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu2(int a,int p){\n\t\tif(a==go){return p;}\n\t\tint u=0;\n\t\tb[a]=true;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu2(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u!=0){b[a]=false;}\n\t\treturn u;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\n\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t(0..n-1).each{|k|\n\t\tdist_k = dist[k]\n\t\t(0..n-1).each{|i|\n\t\t\tdist_i = dist[i]\n\t\t\tnext_dist_i = next_dist[i]\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist_i[j]\n\t\t\t\ty = dist_i[k] + dist_k[j]\n\t\t\t\tnext_dist_i[j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop do\n\tn, m, l = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tdist_mat = (1..n).map { [Float::INFINITY] * n }\n\t(0..n-1).each {|i| dist_mat[i][i] = 0}\n\tm.times do\n\t\tu, v, d = gets.split.map(&:to_i)\n\t\tdist_mat[u][v] = d\n\t\tdist_mat[v][u] = d\n\tend\n\tdist = warshall_floyd(dist_mat)\n\t\n\trequests = (1..l).map { gets.split.map(&:to_i) }\n\trequests.sort_by!(&:last)\n\t\n\t#path cover in DAG\n\tinitial_matchings = []\n\tg = {}\n\t(0..l-1).each { |i| g[i] = Set.new }\n\t(0..l-1).to_a.combination(2) do |i, j|\n\t\tu, t1 = requests[i]\n\t\tv, t2 = requests[j]\n\t\tif dist[u][v] <= t2 - t1\n\t\t\tg[i] << j\n\t\tend\n\tend\t\n\t\n\tuntil g.empty?\n\t\tu = g.keys[0]\n\t\treached = Set[u]\n\t\tpath = [u]\t\n\t\tloop do\n\t\t\tok = false\n\t\t\tg[u].each do |v|\n\t\t\t\tif ! reached.include?(v)\n\t\t\t\t\tok = true\n\t\t\t\t\tu = v\n\t\t\t\t\treached << u\n\t\t\t\t\tpath << u\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tbreak unless ok\n\t\tend\n\t\t\n\t\tpath.each do |u|\n\t\t\tg.each do |v, neighbour|\n\t\t\t\tneighbour.delete(u)\n\t\t\tend\n\t\t\tg.delete(u)\n\t\tend\n\t\tinitial_matchings += path.each_cons(2).to_a\n\tend\n\t\n\t# p initial_matchings.size\n\n\tg = {}\n\t(-1..2*l).each { |i| g[i] = Set.new }\n\t(0..l-1).each { |i| g[-1] << i }\n\t(l..2*l-1).each { |i| g[i] << 2*l }\n\n\t(0..l-1).to_a.combination(2) do |i, j|\n\t\tu, t1 = requests[i]\n\t\tv, t2 = requests[j]\n\t\tif dist[u][v] <= t2 - t1\n\t\t\tg[i] << l + j\n\t\tend\n\tend\t\n\n\tinitial_matchings.each do |i, j|\n\t\tg[-1].delete(i)\n\t\tg[i] << -1\n\t\tg[i].delete(l+j)\n\t\tg[l+j] << i\n\t\tg[l+j].delete(2*l)\n\t\tg[2*l] << l+j\n\tend\n\n\tmatching = initial_matchings.size\n\tloop do\n\t\tprev = {-1 => -2}\n\t\tstack = [-1]\n\t\tuntil stack.empty?\n\t\t\tu = stack.pop\n\t\t\tg[u].each do |v|\n\t\t\t\tnext if prev[v]\n\t\t\t\tprev[v] = u\n\t\t\t\tstack << v\n\t\t\tend\n\t\tend\n\t\tbreak if ! prev[2*l]\n\t\tmatching += 1\n\t\tpath = [2*l]\n\t\tpath << prev[path[-1]] until prev[path[-1]] == -2\n\t\tpath.each_cons(2) do |v, u|\n\t\t\tg[u].delete(v)\n\t\t\tg[v] << u\n\t\tend\n\tend\n\tp l - matching\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\n\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t(0..n-1).each{|k|\n\t\tdist_k = dist[k]\n\t\t(0..n-1).each{|i|\n\t\t\tdist_i = dist[i]\n\t\t\tnext_dist_i = next_dist[i]\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist_i[j]\n\t\t\t\ty = dist_i[k] + dist_k[j]\n\t\t\t\tnext_dist_i[j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop do\n\tn, m, l = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tdist_mat = (1..n).map { [Float::INFINITY] * n }\n\t(0..n-1).each {|i| dist_mat[i][i] = 0}\n\tm.times do\n\t\tu, v, d = gets.split.map(&:to_i)\n\t\tdist_mat[u][v] = d\n\t\tdist_mat[v][u] = d\n\tend\n\tdist = warshall_floyd(dist_mat)\n\t\n\trequests = (1..l).map { gets.split.map(&:to_i) }\n\trequests.sort_by!(&:last)\n\t\n\t#path cover in DAG\n\tg = {}\n\t(-1..2*l).each { |i| g[i] = Set.new }\n\t(0..l-1).each { |i| g[-1] << i }\n\t(l..2*l-1).each { |i| g[i] << 2*l }\n\n\t(0..l-1).to_a.combination(2) do |r1, r2|\n\t\tu, t1 = requests[r1]\n\t\tv, t2 = requests[r2]\n\t\tif dist[u][v] <= t2 - t1\n\t\t\tg[r1] << l + r2\n\t\tend\n\tend\t\n\n\tmatching = 0\n\tloop do\n\t\tprev = {-1 => -2}\n\t\tstack = [-1]\n\t\tuntil stack.empty?\n\t\t\tu = stack.pop\n\t\t\tg[u].each do |v|\n\t\t\t\tnext if prev[v]\n\t\t\t\tprev[v] = u\n\t\t\t\tstack << v\n\t\t\tend\n\t\tend\n\t\tbreak if ! prev[2*l]\n\t\tmatching += 1\n\t\tpath = [2*l]\n\t\tpath << prev[path[-1]] until prev[path[-1]] == -2\n\t\tpath.each_cons(2) do |v, u|\n\t\t\tg[u].delete(v)\n\t\t\tg[v] << u\n\t\tend\n\tend\n\tp l - matching\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nfrom collections import deque\nclass HopcroftKarp:\n    def __init__(self, N0, N1):\n        self.N0 = N0\n        self.N1 = N1\n        self.N = N = 2+N0+N1\n        self.G = [[] for i in range(N)]\n        for i in range(N0):\n            forward = [2+i, 1, None]\n            forward[2] = backward = [0, 0, forward]\n            self.G[0].append(forward)\n            self.G[2+i].append(backward)\n        self.backwards = bs = []\n        for i in range(N1):\n            forward = [1, 1, None]\n            forward[2] = backward = [2+N0+i, 0, forward]\n            bs.append(backward)\n            self.G[2+N0+i].append(forward)\n            self.G[1].append(backward)\n\n    def add_edge(self, fr, to):\n        #assert 0 <= fr < self.N0\n        #assert 0 <= to < self.N1\n        v0 = 2 + fr\n        v1 = 2 + self.N0 + to\n        forward = [v1, 1, None]\n        forward[2] = backward = [v0, 0, forward]\n        self.G[v0].append(forward)\n        self.G[v1].append(backward)\n\n    def bfs(self):\n        G = self.G\n        level = [None]*self.N\n        deq = deque([0])\n        level[0] = 0\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        self.level = level\n        return level[1] is not None\n\n    def dfs(self, v, t):\n        if v == t:\n            return 1\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w] and self.dfs(w, t):\n                e[1] = 0\n                rev[1] = 1\n                return 1\n        return 0\n\n    def flow(self):\n        flow = 0\n        G = self.G\n        bfs = self.bfs; dfs = self.dfs\n        while bfs():\n            *self.it, = map(iter, G)\n            while dfs(0, 1):\n                flow += 1\n        return flow\n\n    def matching(self):\n        return [cap for _, cap, _ in self.backwards]\n\ndef solve():\n    N, M, L = map(int, readline().split())\n    if N == 0:\n        return False\n    INF = 10**9\n    E = [[INF]*N for i in range(N)]\n    for i in range(M):\n        u, v, d = map(int, readline().split())\n        E[u][v] = E[v][u] = d\n    for i in range(N):\n        E[i][i] = 0\n    for k in range(N):\n        for i in range(N):\n            Ei = E[i]\n            for j in range(N):\n                Ei[j] = min(Ei[j], Ei[k] + E[k][j])\n    g = HopcroftKarp(L, L)\n\n    P = [list(map(int, readline().split())) for i in range(L)]\n    P.sort(key = lambda x: x[1])\n    for i in range(L):\n        pi, ti = P[i]\n        for j in range(i+1, L):\n            pj, tj = P[j]\n            if ti + E[pi][pj] <= tj:\n                g.add_edge(i, j)\n    write(\"%d\\n\" % (L - g.flow()))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass WarshallFloyd():\n    def __init__(self, e, n):\n        self.E = e\n        self.N = n\n\n    def search(self):\n        n = self.N\n        nl = list(range(n))\n        d = [[inf] * n for _ in nl]\n        for i in range(n):\n            d[i][i] = 0\n        for k,v in self.E.items():\n            dk = d[k]\n            for b,c in v:\n                # consider multiple edges\n                if dk[b] > c:\n                    dk[b] = c\n        for i in nl:\n            di = d[i]\n            for j in nl:\n                if i == j:\n                    continue\n                dj = d[j]\n                for k in nl:\n                    if i != k and j != k and dj[k] > dj[i] + di[k]:\n                        dj[k] = dj[i] + di[k]\n        return d\n\nclass Flow():\n    def __init__(self, e, N):\n        self.E = e\n        self.N = N\n        self.nl = list(range(N))\n\n    def max_flow(self, s, t):\n        r = 0\n        e = self.E\n        v = None\n\n        def f(c):\n            v[c] = 1\n            if c == t:\n                return 1\n            for i in e[c]:\n                if v[i] is None and f(i):\n                    e[c].remove(i)\n                    e[i].add(c)\n                    return 1\n            return\n\n        while True:\n            v = [None] * self.N\n            if f(s) is None:\n                break\n            r += 1\n\n        return r\n\ndef main():\n    rr = []\n\n    def f(n,m,l):\n        ma = [LI() for _ in range(m)]\n        la = [LI() for _ in range(l)]\n        e = collections.defaultdict(list)\n        for u,v,d in ma:\n            e[u].append((v,d))\n            e[v].append((u,d))\n        wf = WarshallFloyd(e,n)\n        wd = wf.search()\n        e2 = collections.defaultdict(set)\n        for i in range(l):\n            p1,t1 = la[i]\n            for j in range(l):\n                if i == j:\n                    continue\n                p2,t2 = la[j]\n                if wd[p1][p2] <= t2-t1:\n                    e2[i].add(j+l)\n            e2[l*2].add(i)\n            e2[i+l].add(l*2+1)\n        # for k,v in e2.items():\n        #     print('k,v',k,v)\n        fl = Flow(e2,l*2+2)\n        t = fl.max_flow(l*2,l*2+1)\n        # print('t',t)\n        return l - t\n\n    while 1:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]