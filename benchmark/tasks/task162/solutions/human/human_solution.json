[
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n  import scala.io.StdIn._\n\n\n\n  val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n  val toys = Array.tabulate(n){_ ⇒ readLine.trim.toInt}.let(i ⇒ (1 to m).map(a ⇒ i.map(t ⇒ if (t == a) 1 else 0).also(ar ⇒ for (idx ← 1 until ar.length) ar(idx) += ar(idx - 1)))).toArray\n  println(\n    minMove(toys, (1 << m) - 1)\n  )\n  def minMove(toys: Array[Array[Int]], usage: Int, rest: Int = 0)(implicit memo: Array[Option[Long]] = Array.tabulate(1 << toys.length){_ ⇒ None}): Long = {\n    memo(usage) match {\n      case Some(r) ⇒ r\n      case None if usage == 0 ⇒ 0\n      case None ⇒ {\n        usage.asIterable.map{t ⇒\n          minMove(toys, usage ^ (1 << t), rest + toys(t).last) + toys(t).last - toys(t)(rest + toys(t).last - 1) + (if (rest != 0) toys(t)(rest - 1) else 0)\n        }.min.also(r ⇒ memo(usage) = Some(r))\n      }\n    }\n  }\n  implicit class AsFlag(val value: Int){\n    def asIterable: Iterable[Int] = {\n      var i = 0\n      var v = value\n      var res = Nil: List[Int]\n      while (v != 0){\n        if (v % 2 == 1){\n          res ::= i\n        }\n        i += 1\n        v /= 2\n      }\n      res\n    }\n  }\n  implicit class ScopeFunc[T](val value: T){\n    def let[A](func: T ⇒ A): A = func(value)\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<string,int> P;\ntypedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\nint n,m;\nint cnt[20][100010],a,sum[20];\nint dp[1<<20];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int i=0;i<(1<<20);i++) dp[i]=INF;\n\n\tcin>>n>>m;\n\tREP(i,n) {\n\t\tcin>>a;a--;\n\t\tcnt[a][i+1]++;\n\t\tREP(j,m) cnt[j][i+1]+=cnt[j][i];\n\t}\n\tREP(i,m) sum[i]=cnt[i][n];\n\tdp[0]=0;\n\tfor(int S=0;S<(1<<m);S++) {\n\t\tint nui_sum=0;\n\t\tREP(i,m) if(S&(1<<i)) nui_sum+=sum[i]; //既に並んでいるぬいぐるみの合計\n\t\tREP(i,m) {\n\t\t\tif(S&(1<<i)) continue;\n\t\t\tint move=sum[i]-cnt[i][nui_sum+sum[i]]+cnt[i][nui_sum];\n\t\t\tdp[S|(1<<i)]=min(dp[S|(1<<i)],dp[S]+move);\n\t\t}\n\t}\n\tcout<<dp[(1<<m)-1]<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-7)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tint x;\n                                        \tint y,z,w;\n                                        \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\nunsigned int randxor()\n{\n    static unsigned int x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned int t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\n\nint a[100020];\nint rui[20][100020]={0};\nint dp[1<<20];\nint kosu[20]={0};\n  signed main(){\n  \t              cin.tie(0);\n    \t\tios::sync_with_stdio(false);\n\nint n,m;\n  \tcin>>n>>m;\n  \t\n  \tfor(int i=1;i<=n;i++){\n  \t\tcin>>a[i];\n  \t\ta[i]--;\n  \t\tkosu[a[i]]++;\n  \t\trui[a[i]][i]++;\n  \t}\n  \t\n  \tfor(int i=1;i<=n;i++)for(int j=0;j<m;j++)rui[j][i]+=rui[j][i-1];\n  \t\n  \tdp[0]=0;\n  \t\n  \tfor(int i=1;i<(1<<m);i++){\n  \t\tint wa=0;\n  \t\tfor(int j=0;j<m;j++)if(i&(1<<j))wa+=kosu[j];\n  \t\tint ans=inf*1000000ll;\n  \t\tfor(int j=0;j<m;j++)if(i&(1<<j)){\n  \t\t\tint val=dp[i^(1<<j)];\n  \t\t\tint dame=kosu[j]-(rui[j][wa]-rui[j][wa-kosu[j]]);\n  \t\t\tans=min(ans,val+dame);\n  \t\t}\n  \t\tdp[i]=ans;\n  \t}\n  \tcout<<dp[(1<<m)-1]<<endl;\n  \t\n  \treturn 0;\n                }\n                \n\n"
  },
  {
    "language": "C++",
    "code": "/*\nぬいぐるみの整理 (Plush Toys)\n<問題>\nある JOI 関係者は，おもちゃ屋で働いている．今日は，店内にあるぬいぐるみコーナーの整理をすることになった．\nぬいぐるみコーナーの棚には，N 個のぬいぐるみが左から右に一列に並べられている．\n棚は仕切りにより N 個の区画に区切られており，1 つの区画に 1 個のぬいぐるみを置く．\nこのおもちゃ屋は合計 M 種類のぬいぐるみを売っており，それぞれ 1 から M までの番号が付けられている．\n棚に並べられた N 個のぬいぐるみは，それぞれこの M 種類のうちのいずれかである．\nまた，それぞれの種類のぬいぐるみは，少なくとも 1 個は存在する．\n見栄えを良くするため，同じ種類のぬいぐるみが全て連続して棚に置かれるように，ぬいぐるみを並べ替えたい．\n次のような方法で，ぬいぐるみを並べ替えることにした．\n・N個のぬいぐるみのうちいくつかを選び，棚から取り出す．取り出さなかったぬいぐるみの位置は動かさない．\n・取り出したぬいぐるみを，好きな順に棚の空いている区画に戻していく．\n並べ替えた後，同じ種類のぬいぐるみが全て連続して棚に置かれていなければならない． \n並べ替えるために取り出すぬいぐるみの個数の最小値を求めるプログラムを作成せよ．\n<入力>\n入力は 1 + N 行からなる．\n1 行目には 2 個の整数 N, M (1 ≦ N ≦ 100000,\n1 ≦ M ≦ 20) が空白を区切りとして書かれており，ぬいぐるみが N 個あり，種類が M 種類あることを表す．\n続く N 行のそれぞれには，1 以上 M 以下の整数が書かれている．\nN 行のうちの i 行目 (1 ≦ i ≦ N) に書かれた整数は，\n棚の左から i 番目の区画に置かれたぬいぐるみの種類を表す．\n各種類について，少なくとも 1 個のぬいぐるみが存在していることが保証される．\n*/\n#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<cmath>\nusing namespace std;\nint p[110000];\n//sum[ぬいぐるみの種類][何番目にあるか]\nint sum[20][110000];\nint sz[20];\nint dp[1<<20];\nint main(void)\n{\n\tint a,b;cin>>a>>b;\n\tfor(int i=0;i<a;i++){\n\t\t//並べられているぬいぐるみの数\n\t\tcin>>p[i];\n\t\t//すべての番号を1小さくする\n\t\tp[i]--;\n\t\t//人形の種類のある位置に１にする。\n\t\tsum[p[i]][i+1]=1;\n\t\t//人形の種類の数\n\t\tsz[p[i]]++;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tsum[i][j+1]+=sum[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<b);i++)\n\t{\n\t\tdp[i]=999999999;\n\t}\n\tdp[0]=0;\n\tfor(int i=0;i<(1<<b);i++){\n\t\tint pos=0;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(i&(1<<j))pos+=sz[j];\n\t\t}\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i+(1<<j)]=min(dp[i+(1<<j)],dp[i]+sz[j]-sum[j][pos+sz[j]]+sum[j][pos]);\n\t\t}\n\t}\n\tcout<<dp[(1<<b)-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N, M, toys[100000];\nint cnt[20], sum[20][100001];\n\nint dp[1<<20];\n\nint solve(int idx, int bit)\n{\n  if(bit == (1<<M)-1) return 0;\n  int& ret =dp[bit];\n  if(~ret) return ret;\n  ret = inf;\n  for(int i =0; i < M; i++) {\n    if((bit >> i) & 1) continue;\n    ret = min(ret, solve(idx + cnt[i], bit | (1<<i)) + cnt[i] - (sum[i][idx+cnt[i]]-sum[i][idx]));\n  }\n  return ret;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M;\n  rep(i, N) cin >> toys[i], toys[i]--, cnt[toys[i]]++, sum[toys[i]][i+1]++;\n  rep(i, M) rep(j, N) sum[i][j+1] += sum[i][j];\n\n  memset(dp, -1, sizeof(dp));\n  cout << solve(0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 10000000\nint n,m;\nint r[100005] = {0};\nint dp[1 <<22] = {0};\nint sum[25][100005]={0};\nint an[22] = {0};\nint main()\n{\n\t\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> r[i];\n\t\tr[i]--;\n\t\tan[r[i]]++;\n\t\tsum[r[i]][i] = 1;\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tsum[i][j + 1] += sum[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < (1 << 20); i++){\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 0; i < (1 << m); i++){\n\t\tint cnt = 0;\n\t\tfor(int l = 0; l < m ; l++){\n\t\t\tif((i >> l) & 1) cnt+= an[l];\n\t\t}\n\t\tfor(int j = 0; j < m; j++){//j番目を並べる\n\t\t\tif((i >> j) & 1) continue;\n\t\t\tint s = dp[i];\n\t\t\ts += (an[j] - (sum[j][cnt+an[j]] - sum[j][cnt]));\t\n\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)], s);\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nint N, M;\nint P[112345];\nint c[23][112345];\nint n[23];\n\nint count(int p, int s, int e) {\n\treturn c[p][e - 1] - ((s == 0) ? 0 : c[p][s - 1]);\n}\n\nint memo[1 << 21];\n\nint dp(int i, int j, int b) {\n\tif (memo[i] != -1) return memo[i];\n\tif (b == 1) return memo[i] = count(log2(i), 0, j);\n\tint a = 0;\n\trep(p, M) {\n\t\tif (i & 1 << p) a = max(a, dp(i ^ (1 << p), j - n[p], b - 1) + count(p, j - n[p], j));\n\t}\n\treturn memo[i] = a;\n}\n\nint main() {\n\n\tmemset(memo, 0xFF, sizeof(memo));\n\n\tscanf(\"%d %d\", &N, &M);\n\n\trep(i, M) n[i] = 0;\n\n\trep(i, N) {\n\t\tscanf(\"%d\", &P[i]);\n\t\tn[P[i] - 1]++;\n\t}\n\n\trep(i, M) {\n\t\tint t = 0;\n\t\trep(j, N) {\n\t\t\tif (P[j] == i + 1) t++;\n\t\t\tc[i][j] = t;\n\t\t\tc[i][j + 1] = t;\n\t\t}\n\t}\n\tprintf(\"%d\", N - dp((1 << M) - 1, N, M));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[100000], dp[1048576], cnt[20];\nint func(int x, int y) {\n\tint xmem = x, z = 0, cn = 0;\n\tfor (int i = 0; i<20; i++) {\n\t\tif (xmem % 2 == 1)z += cnt[i];\n\t\txmem = xmem >> 1;\n\t\tif (xmem == 0)break;\n\t}\n\tfor (int i = z; i<(z + cnt[y]); i++)\n\t\tif (a[i] == y)cn++;\n\treturn (cnt[y] - cn + dp[x]);\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i<20; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i<n; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tcnt[a[i]]++;\n\t}\n\tdp[0] = 0;\n\tint j;\n\tfor (int i = 1; i<(1 << m); i++) {\n\t\tj = i;\n\t\tdp[i] = 2147483647;\n\t\tfor (int k = 0; k<20; k++) {\n\t\t\tif (j % 2 == 1)\n\t\t\t\tdp[i] = min(dp[i], func(i - (1 << k), k));\n\t\t\tj = j >> 1;\t\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define UNDEF (1 << 31)\n\nusing namespace std;\n\nunsigned int dp[1048576];\nint N,M,S[100000],R[20][100001];\n\nbool ibs(int bits,int ref)\n{\n\treturn ((1 << ref) & bits) == (1 << ref);\n}\n\nint sbt(int bits,int ref)\n{\n\treturn bits | (1 << ref);\n}\n\nvoid dfs(int bits)\n{\n\t{\n\t\tint tb;\n\t\tint cnt = 0;\n\t\tfor(int ii = 0;ii < M;ii++)\n\t\t{\n\t\t\tif(ibs(bits,ii))\n\t\t\t{\n\t\t\t\tcnt += R[ii][N];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tif(!ibs(bits,i))\n\t\t\t{\n\t\t\t\ttb = sbt(bits,i);\n\t\t\t\tdp[tb] = min(dp[tb],dp[bits]+(R[i][N] - (R[i][cnt+R[i][N]] - R[i][cnt])));\n\t\t\t\tdfs(tb);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor(int i = 0;i < 1048576;i++)\n\t{\n\t\tdp[i] = UNDEF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> S[i];\n\t\tS[i]--;\n\t\tfor(int k = 0;k < 20;k++)\n\t\t{\n\t\t\tR[k][i+1] = R[k][i];\n\t\t}\n\t\tR[S[i]][i+1]++;\n\t}\n\tdfs(0x00000000);\n\tint ref = 0;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tref = sbt(ref,i);\n\t}\n\tcout << dp[ref] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define INF (100000000)\n\ntypedef pair<int, int> P;\n\nint main() {\n    int N,M;\n    cin >> N >> M;\n\n    vector<int> D;\n    vector<P> DPAIR(M);\n    for(int i=0; i<M; ++i) DPAIR[i]=P(i,0);\n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        D.push_back(temp-1);\n        ++DPAIR[temp-1].second;\n    }\n\n    vector<int> DD[M];\n\n    for(int i=0; i<M; ++i) {\n        DD[i].resize(N);\n        DD[i][0]=(D[0]==i?1:0);\n        for(int j=1; j<N; ++j) {\n            DD[i][j]=DD[i][j-1]+(D[j]==i?1:0);\n        }\n    }\n\n    string ALPHA=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string istr=ALPHA.substr(0,M);\n    vector<int> indx(M+1);\n    map<string,P> mp;\n\n    for(int c=1; c<=M; ++c) {\n        string str=istr.substr(0,c);\n        indx[c]=M;\n        for(int i=0; i<c; ++i) indx[i]=i;\n        --indx[c-1];\n        while(indx[0]<M-c || c==M) {\n            int now=c-1;\n            while(indx[0]!=M-c || c==M) {\n                if(indx[now+1]-indx[now]>1) {\n                    ++indx[now];\n                    str[now]=istr[indx[now]];\n                    break;\n                } else if(indx[now]-indx[now-1]>1) {\n                    ++indx[now-1];\n                    str[now-1]=istr[indx[now-1]];\n                    for(int i=now; i<c; ++i) {\n                        indx[i]=indx[i-1]+1;\n                        str[i]=istr[indx[i]];\n                    }\n                    break;\n                } else {\n                    --now;\n                }\n            }\n\n            // main\n            int cnt=INF;\n            int len;\n            for(int i=0; i<c; ++i) { // most back position's index\n                string s=str;\n                s.erase(s.begin()+i);\n                if(s==\"\") {\n                    cnt=min(cnt,DPAIR[indx[i]].second-DD[indx[i]][DPAIR[indx[i]].second-1]);\n                    len=DPAIR[indx[i]].second;\n                } else {\n                    int fst=mp[s].first;\n                    int snd=mp[s].second;\n                    cnt=min(cnt,fst+DPAIR[indx[i]].second-DD[indx[i]][snd+DPAIR[indx[i]].second-1]+DD[indx[i]][snd-1]);\n                    len=snd+DPAIR[indx[i]].second;\n                }\n            }\n            \n            mp[str]=make_pair(cnt,len);\n            if(c==M) break;\n        }\n    }\n\n    cout << mp[istr].first << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint ruisekiwa[100001][20];\nint main() {\n\tmemset(ruisekiwa, 0, sizeof(ruisekiwa));\n\tint a, b;\n\tcin >> a >> b;\n\tint c[20]{};\n\tfor (int d = 0; d < a; d++) {\n\t\tint e;\n\t\tscanf(\"%d\", &e);\n\t\te--;\n\t\tc[e]++;\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\truisekiwa[d + 1][f] = c[f];\n\t\t}\n\t}\n\tunordered_map<int, int>MINCOST;//20 19.......2 1\n\tfor (int i = 1; i <= b; i++) {\n\t\tfor (int bit = 0; bit < (1 << b); bit++) {\n\t\t\tint sum = 0, r = 0;;\n\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tr += ruisekiwa[a][g];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == i) {\n\t\t\t\tint MIN = 1 << 29;\n\t\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\t\tint copy = 1 << g;\n\t\t\t\t\t\tbit -= copy;\n\t\t\t\t\t\tMIN = min(MIN, MINCOST[bit] + ruisekiwa[a][g] - (ruisekiwa[r][g] - ruisekiwa[r - ruisekiwa[a][g]][g]));\n\t\t\t\t\t\tbit += copy;\n\t\t\t\t\t}\n\t\t\t\t\tMINCOST[bit] = MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint k = 1 << 29;\n\tfor (int i = 0; i < (1 << b); i++) {\n\t\tk = min(k, MINCOST[i]);\n\t}\n\tcout << k << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[21];\nconst int MA=1<<21;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\trep(k,m)used[k]=0;\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\ncout<\"WA\";\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int inf = 2e9;\nconst ll INF = 2e18;\nconst ll MOD = 1e9+7;\nconst ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define rrep(i,a,b) for (int i = (a); i >= (b); i--)\n#define REP(i,n) rep(i,0,n)\n#define RREP(i,n) rrep(i,n,0)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nint n, m, cnt[20][112345], dp[1123456];\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0; i < n; ++i){\n    int tmp;\n    cin >> tmp;\n    for(int j = 0; j < m; ++j) cnt[j][i + 1] = cnt[j][i] + (j == tmp - 1);\n  }\n\n  // for(int i = 0; i < m; ++i) for(int j = 0; j <= n; ++j) printf(\"%d%c\", cnt[i][j], \" \\n\"[j == n]);\n\n  // for(int i = 0; i < m; ++i) printf(\"%d%c\", cnt[i][n], \" \\n\"[i == m - 1]);\n  for(int i = 1; i < 1 << m; ++i) dp[i] = inf;\n  for(int i = 0; i < 1 << m; ++i){\n    int sum = 0;\n    for(int j = 0; j < m; ++j) if((i >> j) & 1) sum += cnt[j][n];\n    for(int j = 0; j < m; ++j) if(!((i >> j) & 1)){\n      dp[i + (1 << j)] = min(dp[i + (1 << j)], dp[i] + cnt[j][n] - cnt[j][sum + cnt[j][n]] + cnt[j][sum]);\n    }\n  }\n\n  cout << dp[(1 << m) - 1] << endl;\n  //for(int i = 0; i < 1 << m; ++i) printf(\"%d%c\", dp[i], \" \\n\"[i == (1 << m) - 1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m;\nint p[100000 + 5];\nint cnt[25];\nint dp[1<<20];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) cin >> p[i];\n    rep(i, n) cnt[p[i]-1] += 1;\n    fill(dp, dp + (1<<m) + 1, 1e9);\n    dp[0] = 0;\n    rep(i, 1<<m) {\n        rep(j, m) {\n            if (i>>j & 1) {\n                int l = 0;\n                int r = 0;\n                rep(k, m) {\n                    if (k == j) r = cnt[k];\n                    else if (i>>k & 1) l += cnt[k];\n                }\n                int change = 0;\n                rep2(k, l, l + r) {\n                    if (p[k] - 1 != j)  change += 1;\n                }\n                dp[i] = min(dp[i], dp[i ^ (1<<j)] + change);\n            }\n        }\n    }\n    cout << dp[(1<<m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100001\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,A[N],Sum[20][N];\n\n\nint cost(int idx,int i){return Sum[i][n]-(Sum[i][idx+Sum[i][n]]-Sum[i][idx]);}\n\nint mem[1<<20],used[1<<20];\nint dfs(int sta,int idx){\n  if(sta==(1<<m)-1)return 0;\n  if(used[sta]++) return mem[sta];\n  int &res=mem[sta]=INF;\n  for(int i=0;i<m;i++){\n    if((sta>>i)&1)continue;\n    res=min(res,cost(idx,i)+dfs(sta|(1<<i),idx+Sum[i][n]));\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>A[i],A[i]--;\n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      Sum[i][j+1]+=Sum[i][j]+(A[j]==i);\n  cout <<dfs(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m;\nint main() {\n\tcin >> n >> m;\n\tvector<int> x(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i], x[i]--;\n\tvector<vector<int> > sum(m, vector<int>(n + 1, 0));\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum[i][j + 1] = sum[i][j] + (x[j] == i ? 1 : 0);\n\t\t}\n\t}\n\tvector<int> bsum(1 << m, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tbsum[j] = bsum[j - (1 << i)] + sum[i][n];\n\t\t}\n\t}\n\tvector<int> dp(1 << m, 999999999); dp[0] = 0;\n\tfor (int i = 1; i < 1 << m; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (!(i & (1 << j))) continue;\n\t\t\tdp[i] = min(dp[i], dp[i - (1 << j)] + (bsum[i] - bsum[i - (1 << j)]) - (sum[j][bsum[i]] - sum[j][bsum[i - (1 << j)]]));\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> T INF = 1000000007;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> v(n);\n    for (auto &&i : v) scanf(\"%d\", &i), i--;\n    vector<vector<int>> cnt(m, vector<int>(n+1, 0));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cnt[i][j+1] = cnt[i][j]+(v[j] != i);\n        }\n    }\n    vector<int> dp1(1<<m), dp2(1<<m, INF<int>);\n    for (int i = 0; i < (1 << m); ++i) {\n        for (int j = 0; j < m; ++j) {\n            if(i & (1 << j)){\n                dp1[i] = dp1[i^(1<<j)] + n-cnt[j][n];\n                break;\n            }\n        }\n    }\n    dp2[0] = 0;\n    for (int i = 0; i < (1 << m); ++i) {\n        for (int j = 0; j < m; ++j) {\n            if(i & (1 << j)){\n                dp2[i] = min(dp2[i], dp2[i^(1 << j)] + cnt[j][dp1[i]]-cnt[j][dp1[i-(1<<j)]]);\n            }\n        }\n    }\n    cout << dp2.back() << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int N, M; cin >> N >> M;\n  auto imos = vector<vector<int>>(M, vector<int>(N + 1, 0));\n  for (int j = 1; j <= N; ++j) {\n    int x; cin >> x;\n    --x;\n    ++imos[x][j];\n  }\n  for (int i = 0; i < M; ++i) {\n    for (int j = 1; j <= N; ++j) imos[i][j] += imos[i][j - 1];\n  }\n\n  auto dp = vector<int>(1 << M + 1, N);\n  dp[0] = 0;\n  for (int S = 0; S < 1 << M; ++S) {\n    int cur = 0;\n    for (int i = 0; i < M; ++i) if (S & 1 << i) cur += imos[i][N];\n    for (int i = 0; i < M; ++i) {\n      if (S & 1 << i) continue;\n      int exist = imos[i][cur + imos[i][N]] - imos[i][cur];\n      int need = imos[i][N] - exist;\n      dp[S | 1 << i] = min(dp[S | 1 << i], dp[S] + need);\n    }\n  }\n  cout << dp[(1 << M) - 1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m;\nint p[100000 + 5];\nint s[100000 + 5][25];\nint cnt[25];\nint dp[1<<21];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) cin >> p[i];\n    rep(i, n) cnt[p[i] - 1] += 1;\n    rep(i, n) s[i + 1][p[i] - 1] += 1;\n    rep(i, n)rep(j, m) s[i + 1][j] += s[i][j];\n    fill(dp, dp + (1<<m) + 1, 1e9);\n    dp[0] = 0;\n    rep(i, 1<<m) {\n        rep(j, m) {\n            if (i>>j & 1) {\n                int l = 0;\n                int r = 0;\n                rep(k, m) {\n                    if (k == j) r = cnt[k];\n                    else if (i>>k & 1) l += cnt[k];\n                }\n                r += l\n                int change = (r - l) - (s[r][j] - s[l][j]);\n                dp[i] = min(dp[i], dp[i ^ (1<<j)] + change);\n            }\n        }\n    }\n    cout << dp[(1<<m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a,n)   FOR(i,0,n)\n#define ALL(x)    (x).begin(),(x).end()\n#define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n#define mp        make_pair\n#define eb        emplace_back\n//typedef pair<LL, LL> P;\n//typedef pair<P, P> PP;\n\nint n, m, a;\nint dp[1 << 20], s[101010][25], li[25];\nint main() {\n\tcin >> n >> m;\n\tREP(i, 0, n) {\n\t\tcin >> a;\n\t\ts[i + 1][a - 1]++;\n\t\tli[a - 1]++;\n\t}\n\n\tREP(i, 0, n) REP(j, 0, m) s[i + 1][j] += s[i][j];\n\n\tREP(i,0, 1 << 20)dp[i] = INF;\n\tdp[0] = 0;\n\tREP(i, 0, (1 << m)) {\n\t\tint pos = 0;\n\t\tREP(j, 0, m) if ((i >> j) & 1) pos += li[j];\n\t\tREP(j, 0, m) {\n\t\t\tif ((i >> j) & 1) continue;\n\t\t\tdp[i + (1 << j)] = min(dp[(i + (1 << j))], dp[i] + li[j] - (s[pos + li[j]][j] - s[pos][j]));\n\t\t}\n\t}\n\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint dp[1<<20];\nint main (){\n  int n,m;\n  cin >> n >> m;\n  int nsum[20][n+1];\n  for(int i = 0; i < 20; i++){\n    nsum[i][0] = 0;\n  }\n  for(int i = 1; i < 1<<20; i++){\n    dp[i] = 10000009;\n  }\n  for(int i = 1; i <= n; i++){\n    int a;\n    cin >> a;\n    for(int j = 0; j < m; j++){\n      nsum[j][i] = nsum[j][i-1]+(a-1==j);\n    }\n  }\n  for(int i = 0; i < 1<<m;i++){\n    for(int j = 0; j < m;j++){\n      if(1<<j&i)continue;\n      int l = 0;\n      for(int k = 0; k < m; k++)if(1<<k&i)l += nsum[k][n];\n      dp[i+(1<<j)] = min(dp[i+(1<<j)],dp[i]+nsum[j][n]-(nsum[j][l+nsum[j][n]]-nsum[j][l]));\n    }\n  }\n  cout << dp[(1<<m)-1]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst ll INF=1LL<<60;\nconst int inf=1<<30;\nconst int mod=1e9+7;\nconst int MOD=998244353;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;cin >> n >> m;\n    vector<int> c(m);\n    vector<int> a(n);\n    vector<vector<int>> sum(m,vector<int>(n+1));\n    for(int i=0;i<n;i++){\n        cin >> a[i];\n        a[i]--;\n        c[a[i]]++;\n        for(int j=0;j<m;j++){\n            if(j==a[i]){\n                sum[j][i+1]=sum[j][i]+1;\n            }\n            else{\n                sum[j][i+1]=sum[j][i];\n            }\n        }\n    }\n    vector<int> dp(1<<m,n);\n    dp[0]=0;\n    for(int i=0;i<(1<<m);i++){\n        int t=0;\n        for(int j=0;j<m;j++){\n            if(i&(1<<j)){\n                t+=c[j];\n            }\n        }\n        for(int j=0;j<m;j++){\n            if(i&(1<<j)){\n                continue;\n            }\n            chmin(dp[i|(1<<j)],dp[i]+c[j]-(sum[j][t+c[j]]-sum[j][t]));\n        }\n    }\n    cout << dp[(1<<m)-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = 1000000;\nint dp[1<<20];\n\n\nint n,m;\nint p[20][100001];\nint num[20];\n\nint solve(int s){\n\tif(~dp[s])return dp[s];\n\tint res=INF;\n\tREP(i,m){\n\t\tif(!(s & 1<<i))continue;\n\t\tint nb = ~(1<<i) & s;\n\t\tint oth = 0;\n\t\tREP(j,m){\n\t\t\tif(!(nb & 1<<j))continue;\n\t\t\toth += num[j];\n\t\t}\n\t\tint am = p[i][oth + num[i]] - p[i][oth];\n\t\tres=min(res,solve(nb) + (num[i] - am));\n\t}\n\treturn dp[s] = res;\n}\n\nint main() {\n\tcin>>n>>m;\n\tREP(i,n){\n\t\tint k;\n\t\tcin>>k;\n\t\tk--;\n\t\tp[k][i+1]++;\n\t\tnum[k]++;\n\t}\n\tREP(i,n){\n\t\tREP(k,m)p[k][i+1]+=p[k][i];\n\t}\n\t// [a,b) p[k][b] - p[k][a]\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0]=0;\n\tcout<<solve((1<<m)-1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct joutai{\n  int saisyou;\n  int migihasi;\n};\n\nstruct joutai dp[1048576];\nint ruiseki[20][100001];\n\nint bekijou[21];\n\nint main(){\n  bekijou[0]=1;\n  for(int i=1;i<=20;i++){\n    bekijou[i]=2*bekijou[i-1];\n  }\n  int n, m;\n  cin >> n >> m;\n  int narabi;\n  int kosuu[20];\n  for(int i=0;i<m;i++){\n    kosuu[i]=0;\n    ruiseki[i][0]=0;\n  }\n  for(int i=0;i<n;i++){\n    cin >> narabi;\n    narabi--;\n    kosuu[narabi]++;\n    for(int j=0;j<m;j++){\n      ruiseki[j][i+1]=ruiseki[j][i];\n    }\n    ruiseki[narabi][i+1]++;\n  }\n  dp[0]={0,0};\n  int toridasu;\n  for(int i=1;i<bekijou[m];i++){\n    dp[i].saisyou=10000000;\n    for(int j=0;j<20;j++){\n      if(i&(1<<j)){\n        toridasu = dp[i^(1<<j)].saisyou + kosuu[j]\n         + ruiseki[j][dp[i^(1<<j)].migihasi] - ruiseki[j][dp[i^(1<<j)].migihasi+kosuu[j]];\n        dp[i].saisyou=(toridasu<dp[i].saisyou)?toridasu:dp[i].saisyou;\n        dp[i].migihasi=dp[i^(1<<j)].migihasi+kosuu[j];\n      }\n    }\n  }\n\n  cout << dp[bekijou[m]-1].saisyou << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint p[110000];\nint sum[20][110000];\nint sz[20];\nint dp[1 << 20];\nint main() {\n\tint a, b; scanf(\"%d%d\", &a, &b);\n\tfor (int i = 0; i<a; i++) {\n\t\tscanf(\"%d\", p + i);\n\t\tp[i]--;\n\t\tsum[p[i]][i + 1]++;\n\t\tsz[p[i]]++;\n\t}\n\tfor (int i = 0; i<b; i++)for (int j = 0; j<a; j++) {\n\t\tsum[i][j + 1] += sum[i][j];\n\t}\n\tfor (int i = 0; i<(1 << b); i++)dp[i] = 999999999;\n\tdp[0] = 0;\n\tfor (int i = 0; i<(1 << b); i++) {\n\t\tint pos = 0;\n\t\tfor (int j = 0; j<b; j++)if (i&(1 << j))pos += sz[j];\n\t\tfor (int j = 0; j<b; j++) {\n\t\t\tif (i&(1 << j))continue;\n\t\t\tdp[i + (1 << j)] = min(dp[i + (1 << j)], dp[i] + sz[j] - sum[j][pos + sz[j]] + sum[j][pos]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << b) - 1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct joutai{\n  int saisyou;\n  int migihasi;\n};\n\nstruct joutai dp[1048576];\nint ruiseki[20][100000];\n\nint bekijou[21];\n\nint main(){\n  bekijou[0]=1;\n  for(int i=1;i<=20;i++){\n    bekijou[i]=2*bekijou[i-1];\n  }\n  int n, m;\n  cin >> n >> m;\n  int narabi;\n  int kosuu[20];\n  for(int i=0;i<m;i++){\n    kosuu[i]=0;\n  }\n  for(int i=0;i<n;i++){\n    cin >> narabi;\n    narabi--;\n    kosuu[narabi]++;\n    for(int j=0;j<m;j++){\n      if(i>0){\n        ruiseki[j][i]=ruiseki[j][i-1];\n        if(narabi==j) ruiseki[j][i]++;\n      }else{\n        ruiseki[j][i]=0;\n        if(narabi==j) ruiseki[j][i]++;\n      }\n    }\n  }\n  dp[0]={0,0};\n  int toridasu;\n  for(int i=1;i<bekijou[m];i++){\n    dp[i].saisyou=1000000;\n    for(int j=0;j<20;j++){\n      if(i&(1<<j)){\n        toridasu = dp[i^(1<<j)].saisyou + kosuu[j]\n         + ruiseki[j][dp[i^(1<<j)].migihasi-1] - ruiseki[j][dp[i^(1<<j)].migihasi-1+kosuu[j]];\n        dp[i].saisyou=(toridasu<dp[i].saisyou)?toridasu:dp[i].saisyou;\n        dp[i].migihasi=dp[i^(1<<j)].migihasi+kosuu[j];\n      }\n    }\n  }\n\n  cout << dp[bekijou[m]-1].saisyou << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); ++i)\nusing namespace std;\n\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> cnt(M);\n    vector<vector<int>> sum(M, vector<int>(N + 1));\n    rep(i, N) {\n        int a; cin >> a; a--;\n        cnt[a]++;\n        sum[a][i + 1]++;\n    }\n    rep(i, M) rep(j, N) sum[i][j + 1] += sum[i][j];\n    vector<int> dp(1 << M, INF);\n    dp[0] = 0;\n    rep(bit, 1 << M) {\n        bitset<20> bs(bit);\n        int pos = 0;\n        rep(i, M) if(bs[i]) pos += cnt[i];\n        rep(i, M) if(!bs[i]) {\n            chmin(dp[bit | (1 << i)], dp[bit] + cnt[i] - sum[i][pos + cnt[i]] + sum[i][pos]);\n        }\n    }\n    cout << dp[(1 << M) - 1] << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\nint N,M;\nint num[20] = {};\nint wa[20][100001] = {};\n\nint dp[1048576]; //=10^6\nint solve(int state){\n    if(dp[state] != -1) return dp[state];\n\n    int sum = 0;\n    for(int i=0; i<M; i++){\n        if((state >> i)%2 == 1){\n            sum += num[i];\n        }\n    }\n\n    int re = INT_MAX;\n    for(int i=0; i<M; i++){\n        if((state >> i)%2 == 0){\n            re = min(re, num[i] - (wa[i][sum+num[i]] - wa[i][sum]) + solve(state + (1 << i)));\n        }\n    }\n    return dp[state] = re;\n}\n\nint main(){\n    \n    cin >> N >> M;\n    int A[100000];\n    for(int i=0; i<N; i++){\n        cin >> A[i];\n        A[i]--;\n        num[A[i]]++;\n\n        for(int j=0; j<M; j++){\n            wa[j][i+1] = wa[j][i];\n        }\n        wa[A[i]][i+1] += 1;\n    }\n\n    for(int i=0; i<(1 << M); i++){\n        dp[i] = -1;\n    }\n    dp[(1 << M) - 1] = 0;\n\n    cout << solve(0) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nint N, M, dp[1 << 21], toy[100005], sum[22][100005] = {}, cnt[22] = {};\n\nint main() {\n\t//input\n\tcin >> N >> M;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> toy[i];\n\t\tcnt[toy[i]]++;\n\t\tsum[toy[i]][i]++;\n\t\tfor (int j = 1; j <= M; j++) sum[j][i] += sum[j][i - 1];\n\t}\n\n\t//bitdp\n\tfor (int i = 0; i < (1 << M); i++) dp[i] = 999999;\n\tdp[0] = 0;\n\tfor (int i = 0; i < (1 << M); i++) {\n\t\tint ntc = 0;//now toy count\n\t\tfor (int j = 1; j <= M; j++)if (i&(1 << (j - 1)))ntc += cnt[j];\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (i&(1 << (j - 1))) continue;\n\t\t\tint diff = sum[j][ntc + cnt[j]] - sum[j][ntc];//toy j of true lange\n\t\t\tdiff = cnt[j] - diff;\n\t\t\tdp[(i | (1 << (j - 1)))] = min(dp[(i | (1 << (j - 1)))], dp[i] + diff);\n\t\t}\n\t}\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n, m, a[100005], sum[100005][25], dp[(1 << 20) + 5], cnt[25];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tfor (int i = 1; i <= n; i++)\n\tscanf(\"%d\", &a[i]);\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i]--;\n\t\tcnt[a[i]]++;\n\t\tsum[i][a[i]] = 1;\n\t\t\n\t\tfor(int j = 0; j < m; j++)\n\t\tsum[i][j] += sum[i - 1][j];\t\n\t}\t\n\t\n\tfor(int i = 1; i < (1 << m); i++)\n\tdp[i] = INF;\n\t\n\tfor (int i = 1; i < (1 << m); i++) {\n\t\tint len = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i & (1 << j))\n\t\t\tlen += cnt[j];\n\t\t}\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tint mask = i ^ (1 << j);\n\t\t\t\tint cool = len - cnt[j];\n\t\t\t\t//cool + 1 ~ len\n\t\t\t\tdp[i] = min(dp[i], dp[mask] + len - cool - (sum[len][j] - sum[cool][j]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[(1 << m) - 1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef std::pair<int, int> ipair;\nbool lessPair(const ipair& l, const ipair& r){return l.second < r.second;}\nbool morePair(const ipair& l, const ipair& r){return l.second > r.second;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst ll MOD = 1e9 + 7;\n// const long long INF = 1LL<<60;\nvoid add(long long &a, long long b) { a += b; if (a >= MOD) a -= MOD; }\nvoid sub(long long &a, long long b) { a -= b; if (a < 0) a += MOD; }\nvoid mul(long long &a, long long b) { a *= b; a %= MOD; }\nll llmin(ll a, ll b) { if (a < b) return a; else return b; }\nll llmax(ll a, ll b) { if (a < b) return b; else return a; }\nll llabs(ll a) { if (a >= 0) return a; else return - a; }\nll llmodpow(ll a, ll n) {\n   if (n == 0) return 1;\n   ll tmp = llmodpow(a, n / 2);\n   mul(tmp, tmp);\n   if (n & 1) mul(tmp, a);\n   return tmp;\n}\n\nint a[100010];\nint len[100010];\nint sum[21][100010];\nint dp[1<<20];\n\nint main() {\n   int N, M;\n   cin >> N >> M;\n   \n   for (int i = 0; i < N; i++) {\n      cin >> a[i];\n      a[i]--;\n      len[a[i]]++;\n      sum[a[i]][i + 1]++;\n   }\n   for (int i = 0; i < M; i++) {\n      for (int j = 0; j < N; j++) {\n         sum[i][j + 1] += sum[i][j];\n      }\n   }\n\n   for (int i = 0; i < (1<<M); i++) dp[i] = 999999999;\n   dp[0] = 0;\n   for (int i = 0; i < (1<<M); i++) {\n      int pos = 0;\n      for (int j = 0; j < M; j++) {\n         if (i & (1<<j)) pos += len[j];\n      }\n      for (int j = 0; j < M; j++) {\n         if (i & (1<<j)) continue;\n         dp[i + (1<<j)] = min(dp[i + (1<<j)], dp[i] + len[j] - (sum[j][pos + len[j]] - sum[j][pos]));\n      }\n   }\n   cout << dp[(1<<M) - 1] << endl;\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[20];\nconst int MA=(1<<20);\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=1;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\tmemset(used,0,sizeof used);\n\n\t\t\trep(k,n){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[t[k]];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<l<<\" \"<<r<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint n, m, kmax = 0;\nint a[100000], b[100000][20];\n\nint main()\n{\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i > 0)\n\t\t\t\tb[i][j] = b[i - 1][j];\n\t\t\telse\n\t\t\t\tb[i][j] = 0;\n\t\t}\n\t\tb[i][a[i] - 1]++;\n\t}\n\n\tvector<int> p(m);\n\tiota(p.begin(), p.end(), 1);\n\n\tdo {\n\t\tint t = 0, k = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s = b[n - 1][p[i] - 1];\n\t\t\tif (t > 0)\n\t\t\t\tk += b[s + t - 1][p[i] - 1] - b[t - 1][p[i] - 1];\n\t\t\telse\n\t\t\t\tk = b[s + t - 1][p[i] - 1];\n\t\t\tt += s;\n\t\t}\n\t\tif (kmax < k)\n\t\t\tkmax = k;\n\t} while (next_permutation(p.begin(), p.end()));\n\n\tcout << n - kmax << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\nint n, m, kmax = 0, km = 0;\nint a[100000], b[100000][20], c[20], d[20];\nbool f[20];\n\nstruct bk {\n\tint bm, jm, lr;\n\n\tbool operator < (const bk &bb) const {\n\t\treturn bm > bb.bm;\n\t}\n};\n\n\nvoid perm(int u, int s1, int s2, int k, int km) {\n\tif (u == m + 1) {\n\t\tif (kmax < k)\n\t\t\tkmax = k;\n\t\treturn;\n\t}\n\n\tif (k + km <= kmax)\n\t\treturn;\n\n\tpriority_queue<bk> que;\n\n\tfor (int j = 0; j < m; j++)\n\t\tif (!f[j]) {\n\t\t\tbk b1;\n\t\t\tb1.bm = b[s1][j];\n\t\t\tb1.jm = j;\n\t\t\tb1.lr = 1;\n\t\t\tque.push(b1);\n\t\t}\n\n\tfor (int j = 0; j < m; j++)\n\t\tif (!f[j]) {\n\t\t\tbk b2;\n\t\t\tb2.bm = b[s2 - d[j]][j];\n\t\t\tb2.jm = j;\n\t\t\tb2.lr = 2;\n\t\t\tque.push(b2);\n\t\t}\n\n\twhile (!que.empty()) {\n\t\tbk b3 = que.top();\n\t\tque.pop();\n\t\tint p = b3.jm;\n\t\tif (b3.lr == 1) {\n\t\t\tf[p] = 1;\n\t\t\tperm(u + 1, s1 + d[p], s2, k + b3.bm, km - c[p]);\n\t\t\tf[p] = 0;\n\t\t}\n\t\telse {\n\t\t\tf[p] = 1;\n\t\t\tperm(u + 1, s1, s2 - d[p], k + b3.bm, km - c[p]);\n\t\t\tf[p] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n >> m;\n\n\tmemset(d, 0, sizeof(d));\n\tmemset(b, 0, sizeof(b));\n\tmemset(f, 0, sizeof(f));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\td[a[i] - 1]++;\n\t}\n\n\tfor (int j = 0; j < m; j++) {\n\t\tfor (int i = 0; i < d[j]; i++) {\n\t\t\tif (j == a[i] - 1)\n\t\t\t\tb[0][j]++;\n\t\t}\n\t\tc[j] = b[0][j];\n\t\tfor (int i = 0; i < n - d[j]; i++) {\n\t\t\tint s = 0;\n\t\t\tif (j == a[i + d[j]] - 1)\n\t\t\t\ts++;\n\t\t\tif (j == a[i] - 1)\n\t\t\t\ts--;\n\t\t\tb[i + 1][j] = b[i][j] + s;\n\t\t\tif (c[j] < b[i + 1][j])\n\t\t\t\tc[j] = b[i + 1][j];\n\t\t}\n\t}\n\n\tfor (int j = 0; j < m; j++)\n\t\tkm += c[j];\n\n\tperm(1, 0, n, 0, km);\n\n\tcout << n - kmax << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Plush Toys\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <climits>\n\nusing namespace std;\n\nint A[100000], B[21] = {};\nint N, M;\n\nint getCost(vector<int> v) {\n    int cnt = 0;\n    int i = 0;\n\n    for(auto j : v) {\n        int k = B[j];\n        while(k > 0) {\n            if(A[i++] != j) cnt++;\n            k--;\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        B[A[i]]++;\n    }\n\n    vector<int> v(M);\n    iota(v.begin(), v.end(), 1);\n\n    int cost = INT_MAX;\n    do {\n        cost = min(cost, getCost(v));\n    } while( next_permutation(v.begin(), v.end()) );\n\n    cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint d[100010][25];\nint dp[(1<<20)+10];\n\nint main(void){\n\t          int i,j;\n\n\t      \t  cin.tie(0);\n\t      \t  ios_base::sync_with_stdio(false);\n\n\t          int N,M;\n\t          cin >> N >> M;\n\t          for(i=1;i<=N;i++){\n\t        \t  int x;\n\t        \t  cin >> x;\n\t        \t  for(j=1;j<=M;j++){\n\t        \t\t  if(x==j) d[i][j]=d[i-1][j]+1;\n\t        \t\t  else d[i][j]=d[i-1][j];\n\t        \t  }\n\t          }\n\n\t          for(i=1;i<(1<<M);i++) dp[i]=1e9;\n\n\t          for(i=0;i<(1<<M);i++){\n\t        \t  int p=0;\n\t        \t  for(j=0;j<M;j++){\n\t        \t\t  if(i&(1<<j)){\n\t        \t\t\t  p+=d[N][j+1];\n\t        \t\t  }\n\t        \t  }\n\n\t        \t  for(j=0;j<M;j++){\n\t        \t\t  if((i&(1<<j))==0){\n\t        \t\t\t  int q=p+d[N][j+1];\n\t        \t\t\t  int x=d[N][j+1]-(d[q][j+1]-d[p][j+1]);\n\n\t        \t\t\t  dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+x);\n\t        \t\t  }\n\t        \t  }\n\n\t          }\n\n\t          cout << dp[(1<<M)-1] <<'\\n';\n\n\t          return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> s(m, vector<int>(n+1, 0));\n    vector<int> dp(1<<m, n+1), v(n);\n    dp[0] = 0;\n    for(int i = 0; i < n; i++){\n        cin >> v[i];\n        v[i]--;\n        s[v[i]][i+1]++;\n    }\n    for(int i = 0; i < m; i++){\n        for(int j = 1; j <= n; j++){\n            s[i][j] += s[i][j-1];\n        }\n    }\n    for(int t = 1; t < 1<<m; t++){\n        for(int j = 0; j < m; j++){\n            if(((t>>j)&1) == 0)   continue;\n            int cnt = 0;\n            for(int k = 0; k < m; k++){\n                if(j == k)  continue;\n                if((t>>k)&1)    cnt += s[k][n];\n            }\n            dp[t] = min(dp[t], dp[t-(1<<j)] + s[j][n]-(s[j][cnt+s[j][n]]-s[j][cnt]));\n        }\n    }\n    cout << dp[(1<<m)-1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint n, m, kmax = 0;\nint a[100000], b[20][100000];\n\nint main()\n{\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i > 0)\n\t\t\t\tb[i][j] = b[i - 1][j];\n\t\t\telse\n\t\t\t\tb[i][j] = 0;\n\t\t}\n\t\tb[i][a[i] - 1]++;\n\t}\n\n\tvector<int> p(m);\n\tiota(p.begin(), p.end(), 1);\n\n\tdo {\n\t\tint t = 0, k = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s = b[n - 1][p[i] - 1];\n\t\t\tif (t > 0)\n\t\t\t\tk += b[s + t - 1][p[i] - 1] - b[t - 1][p[i] - 1];\n\t\t\telse\n\t\t\t\tk = b[s + t - 1][p[i] - 1];\n\t\t\tt += s;\n\t\t}\n\t\tif (kmax < k)\n\t\t\tkmax = k;\n\t} while (next_permutation(p.begin(), p.end()));\n\n\tcout << n - kmax << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nint N, M;\nint ans = 1 << 30;\nint C[21][100010];\nint num[21];\nint NU[100010];\n\nint DP[1 << 21][21];\nint ac[1 << 21];\nint main() {\n\tstd::cin >> N >> M;\n\tfor (int i = 1; i <= N; i++) {\n\t\tstd::cin >> NU[i];\n\t\tnum[NU[i]]++;\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tfor (int j = 1; j <= num[i]; j++) {\n\t\t\tif (NU[j] != i)C[i][num[i]]++;\n\t\t}\n\t\tfor (int j = num[i] + 1; j <= N; j++) {\n\t\t\tC[i][j] = C[i][j - 1];\n\t\t\tif (NU[j - num[i]] != i)C[i][j]--;\n\t\t\tif (NU[j] != i)C[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << (M + 1); i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tac[i] += num[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < (1 << M); i++) {\n\t\tfor (int j = 1; j <= M + 1; j++) {\n\t\t\tDP[i][j] = 1 << 30;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << (M + 1)) - 1; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (!(i >> j & 1))continue;\n\t\t\tDP[i][j] = DP[i^(1<<j)][M+1]+C[j][ac[i]];\n\t\t\tDP[i][M + 1] = std::min(DP[i][M + 1], DP[i][j]);\n\t\t}\n\t}\n\tstd::cout << DP[(1<<(M+1))-2][M] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<unordered_map>\nusing namespace std;\n\nint ruisekiwa[100001][20];\nint main() {\n\tmemset(ruisekiwa, 0, sizeof(ruisekiwa));\n\tint a, b;\n\tcin >> a >> b;\n\tint c[20]{};\n\tfor (int d = 0; d < a; d++) {\n\t\tint e;\n\t\tscanf(\"%d\", &e);\n\t\te--;\n\t\tc[e]++;\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\truisekiwa[d + 1][f] = c[f];\n\t\t}\n\t}\n\tunordered_map<int, int>MINCOST;//20 19.......2 1\n\tfor (int i = 1; i <= b; i++) {\n\t\tfor (int bit = 0; bit < (1 << b); bit++) {\n\t\t\tint sum = 0, r = 0;;\n\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tr += ruisekiwa[a][g];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == i) {\n\t\t\t\tint MIN = 1 << 29;\n\t\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\t\tint copy = 1 << g;\n\t\t\t\t\t\tbit -= copy;\n\t\t\t\t\t\tMIN = min(MIN, MINCOST[bit] + ruisekiwa[a][g] - (ruisekiwa[r][g] - ruisekiwa[r - ruisekiwa[a][g]][g]));\n\t\t\t\t\t\tbit += copy;\n\t\t\t\t\t}\n\t\t\t\t\tMINCOST[bit] = MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << b); i++) {\n\t\tcout << i << \" \" << MINCOST[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m;\nint dp[1<<20];\nint count[20][1<<17];\nint a[1<<17];\nint sum[20];\nmain()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];a[i]--;\n\t\tfor(int j=0;j<m;j++)count[j][i+1]=count[j][i]+(j==a[i]);\n\t}\n\tfor(int i=0;i<m;i++)sum[i]=count[i][n];\n\tfor(int i=1;i<1<<m;i++)dp[i]=1e9;\n\tfor(int i=0;i<1<<m;i++)\n\t{\n\t\tint pos=0;\n\t\tfor(int j=0;j<m;j++)if(i&(1<<j))pos+=sum[j];\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(i&(1<<j))continue;\n\t\t\tdp[i|(1<<j)]=min(dp[i|(1<<j)],\n\t\t\t\t\tdp[i]+sum[j]-count[j][pos+sum[j]]+count[j][pos]);\n\t\t}\n\t}\n\tcout<<dp[(1<<m)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct joutai{\n  int saisyou;\n  int migihasi;\n};\n\nstruct joutai dp[1048576];\nint ruiseki[20][100000];\n\nint bekijou[21];\n\nint main(){\n  bekijou[0]=1;\n  for(int i=1;i<=20;i++){\n    bekijou[i]=2*bekijou[i-1];\n  }\n  int n, m;\n  cin >> n >> m;\n  int narabi;\n  int kosuu[20];\n  for(int i=0;i<m;i++){\n    kosuu[i]=0;\n  }\n  for(int i=0;i<n;i++){\n    cin >> narabi;\n    narabi--;\n    kosuu[narabi]++;\n    for(int j=0;j<m;j++){\n      if(i>0){\n        ruiseki[j][i]=ruiseki[j][i-1];\n      }else{\n        ruiseki[j][i]=0;\n      }\n    }\n    ruiseki[narabi][i]++;\n  }\n  dp[0]={0,0};\n  int toridasu;\n  for(int i=1;i<bekijou[m];i++){\n    dp[i].saisyou=10000000;\n    for(int j=0;j<20;j++){\n      if(i&(1<<j)){\n        toridasu = dp[i^(1<<j)].saisyou + kosuu[j]\n         + ruiseki[j][dp[i^(1<<j)].migihasi-1] - ruiseki[j][dp[i^(1<<j)].migihasi-1+kosuu[j]];\n        dp[i].saisyou=(toridasu<dp[i].saisyou)?toridasu:dp[i].saisyou;\n        dp[i].migihasi=dp[i^(1<<j)].migihasi+kosuu[j];\n      }\n    }\n  }\n\n  cout << dp[bekijou[m]-1].saisyou << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) { a = min(a, b); }\nvoid mmax(int &a, int b) { a = max(a, b); }\nvoid sor(vel &v) { sort(v.begin(), v.end()); }\nint zero() { return 0; }\nint gcd(int a, int b) {\n\tif (a < b) return gcd(b, a);\n\tif (b == 0) return a;\n\tint r = a % b;\n\treturn gcd(b, r);\n}\nint ord(int a,int p) {\n\tif (a%p != 0) return 0;\n\treturn 1 + ord(a / p,p);\n}\nint rui(int a, int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\treturn a * rui(a, n - 1);\n}\nsigned main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvvel sum(m, vel(n + 1, 0));\n\tvel ko(m, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x; cin >> x;\n\t\tx--;\n\t\tko[x]++;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tsum[j][i] = sum[j][i - 1];\n\t\t}\n\t\tsum[x][i]++;\n\t}\n\tvel ru(m + 1, 1);\n\tfor (int i = 0; i < m; i++) {\n\t\tru[i + 1] = ru[i] * 2;\n\t}\n\tint rui = ru[m];\n\tvel dp(rui, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < rui; j++) {\n\t\t\tint dj = j;\n\t\t\tint pot = 0;\n\t\t\tint kin = 0;\n\t\t\tvel bi(m, 0);\n\t\t\tfor (int in = 0; in < m; in++) {\n\t\t\t\tbi[in] = dj % 2;\n\t\t\t\tkin += bi[in];\n\t\t\t\tpot += bi[in] * ko[in];\n\t\t\t\tdj = dj / 2;\n\t\t\t}\n\t\t\tif (kin == i) {\n\t\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\t\tif (bi[k] == 0) {\n\t\t\t\t\t\tmmax(dp[j + ru[k]], dp[j] + sum[k][pot + ko[k]] - sum[k][pot]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << n-dp[rui - 1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// written by @kakira9618\n// problem: https://www.ioi-jp.org/joi/2016/2017-yo/2017-yo-t4/2017-yo-t4.html\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n  \nint sum[20][100000]; // sum[c][i]: ???c???i???????????§??????????????????\nint count[20]; // count[c]: ???c??????????????????\nint dp[1 << 20]; // dp[i]: i????????£???????????????????????´????????????????????????????????????????????¨???????§£\nconst int INF = 1 << 29;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> C(N);\n\n    for(int i = 0; i < N; i++) {\n        cin >> C[i];\n        C[i]--;\n        count[C[i]]++;\n    }\n\n    // ?´???????????¨????\n    // O(NM)\n    for(int c = 0; c < M; c++) {\n        for(int i = 0; i < N; i++) {\n            if (C[i] == c) sum[c][i] = 1;\n        }\n    }\n    for(int c = 0; c < M; c++) {\n        int s = 0;\n        for(int i = 0; i < N; i++) {\n            s += sum[c][i];\n            sum[c][i] = s;\n        }\n    }\n\n    // BitDP?????????\n    for(int i = 0; i < 1 << M; i++) {\n        dp[i] = INF;\n    }\n    dp[0] = 0;\n\n    // BitDP\n    // ?????¨?????£???????????????????????¨?´????????????????????????£???????????????????????????????????¬?????????????????°????±????????????????\n    // O(2^M M)\n    for(int i = 0; i < 1 << M; i++) {\n        int s = 0;\n        for(int j = 0; j < M; j++) {\n            if (i >> j & 1) {\n                s += count[j];\n            }\n        }\n\n        for(int j = 0; j < M; j++) {\n            if (!(i >> j & 1)) {\n                dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + count[j] - (sum[j][s + count[j] - 1] - (s >= 1 ? sum[j][s - 1] : 0)));\n            }\n        }\n    }\n\n    cout << dp[(1 << M) - 1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint n, m;\n\nint dist[1 << 20];\nint cost[20][123456];\nint nui[123456];\nint ncount[20];\n\nint memo[1 << 20];\nint dp(int bit)\n{\n\tif (bit == 0)return 0;\n\tif (memo[bit] >= 0)return memo[bit];\n\tint ans = 123456789;\n\tfor (int i = 0; i < 20; ++i)\n\t{\n\t\tif (bit & (1 << i))\n\t\t{\n\t\t\tint lastbit = bit - (1 << i);\n\t\t\tans = min(ans, dp(lastbit) + cost[i][dist[lastbit]]);\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d\", &n, &m);\n\tmemset(memo, 0xff, sizeof(memo));\n\tfill(ncount, ncount + 20, 0);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", nui + i);\n\t\t--nui[i];\n\t\t++ncount[nui[i]];\n\t}\n\tdist[0] = 0;\n\tfor (int bit = 1; bit < (1 << m); ++bit)\n\t{\n\t\tint bigb = 0;\n\t\tfor (int i = 0; i < 20; ++i)\n\t\t{\n\t\t\tif (bit & (1 << i))\n\t\t\t{\n\t\t\t\tbigb = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdist[bit] = dist[bit - (1 << bigb)] + ncount[bigb];\n\t}\n\tfor (int j = 0; j < m; ++j)\n\t{\n\t\t//cost\n\t\tint price = 0;\n\t\tfor (int first = 0; first < ncount[j]; ++first)\n\t\t{\n\t\t\tif (nui[first] == j)\n\t\t\t{\n\t\t\t\t++price;\n\t\t\t}\n\t\t}\n\t\tfor (int shack = 0; shack <= n - ncount[j]; ++shack)\n\t\t{\n\t\t\tcost[j][shack] = ncount[j] - price;\n\t\t\tif (nui[shack] == j)\n\t\t\t{\n\t\t\t\t--price;\n\t\t\t}\n\t\t\tif (shack != n - ncount[j] && nui[shack + ncount[j]] == j)\n\t\t\t{\n\t\t\t\t++price;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp((1 << m) - 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> a(n), num(m, 0);\n    vector<vector<int>> sum(m, vector<int>(n+1, 0));\n    for(int i=0; i<n; i++){\n        cin >> a[i];\n        a[i]--;\n        num[a[i]]++;\n        sum[a[i]][i+1] = 1;\n    }\n    for(int i=0; i<m; i++){\n        for(int j=0; j<n; j++){\n            sum[i][j+1] += sum[i][j];\n        }\n    }\n\n    vector<int> dp(1<<m, inf);\n    dp[0] = 0;\n    for(int i=0; i<(1<<m); i++){\n        int bef = 0;\n        for(int j=0; j<m; j++){\n            if(i>>j&1){\n                bef += num[j];\n            }\n        }\n        for(int j=0; j<m; j++){\n            if(i>>j&1) continue;\n            int k = i | (1<<j);\n            dp[k] = min(dp[k], dp[i]+num[j]-(sum[j][bef+num[j]]-sum[j][bef]));\n        }\n    }\n    cout << dp.back() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll solve(){\n    ll res = 0;\n    ll N,M; cin >> N >> M;\n    vector<ll> toys(N); for(auto&in:toys) cin >> in;\n    vector<vector<ll>> cusum(N+1,vector<ll>(M));\n    for(int i = 0; i < N;i++){\n        toys[i]--;\n        for(int j = 0; j < M;j++){\n            cusum[i+1][j] = cusum[i][j] + (toys[i]==j);\n        }\n    }\n    vector<ll> bitdp(1<<M,LINF);\n    bitdp[0] = 0;\n    for(int i = 0; i < (1<<M);i++){\n        if(bitdp[i] == LINF) continue;\n        ll T = 0;\n        for(int j = 0; j < M;j++){\n            if((i>>j)&1) T += cusum[N][j];\n        }\n        for(int j = 0; j < M;j++){\n            if((i>>j)&1) continue;\n            bitdp[i|1<<j] = min(bitdp[i|1<<j],\n                                bitdp[i]+cusum[N][j]-(cusum[T+cusum[N][j]][j]-cusum[T][j]));\n        }\n    }\n    res = bitdp[(1<<M)-1];\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint sum[20][100001];\nint dp[1 << 20];\nint main() {\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\trep(i, n) {\n\t\tint a; scanf(\"%d\", &a);\n\t\tsum[a - 1][i + 1]++;\n\t}\n\trep(i, m) {\n\t\tfor (int j = 1; j <= n; j++)sum[i][j] += sum[i][j - 1];\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\trep(i, 1 << m) {\n\t\tint p = 0;\n\t\trep(j, m) {\n\t\t\tif (i >> j & 1)p += sum[j][n];\n\t\t}\n\t\trep(j, m) {\n\t\t\tif (i >> j & 1)continue;\n\t\t\tint up = sum[j][n];\n\t\t\tup -= sum[j][p + sum[j][n]] - sum[j][p];\n\t\t\tdp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + up);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << m) - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define UNDEF (1 << 31)\n\nusing namespace std;\n\nunsigned int dp[1048576];\nint N,M,S[100000],R[20][100001];\n\nbool ibs(int bits,int ref)\n{\n\treturn ((1 << ref) & bits) == (1 << ref);\n}\n\nint cbt(int bits,int ref)\n{\n\treturn (((0xffffffff) xor (1 << ref)) & bits);\n}\n\nint sbt(int bits,int ref)\n{\n\treturn bits | (1 << ref);\n}\n\nunsigned int getcount(int s,int l,int i)\n{\n\t\n}\n\nunsigned int dfs(int bits,int cnt)//???????????§???????????????????????????????????????\n{\n\tif(dp[bits] == UNDEF)\n\t{\n\t\tint tb;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tif(ibs(bits,i))\n\t\t\t{\n\t\t\t\ttb = cbt(bits,i);\n\t\t\t\tdp[bits] = min(dp[bits],dfs(tb,cnt-R[i][N])+(R[i][N] - (R[i][cnt] - R[i][cnt-R[i][N]])));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[bits];\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor(int i = 0;i < 1048576;i++)\n\t{\n\t\tdp[i] = UNDEF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> S[i];\n\t\tS[i]--;\n\t\tfor(int k = 0;k < 20;k++)\n\t\t{\n\t\t\tR[k][i+1] = R[k][i];\n\t\t}\n\t\tR[S[i]][i+1]++;\n\t}\n\tint ref = 0;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tref = sbt(ref,i);\n\t}\n\tint res = dfs(ref,N);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\nint n, m, kmax = 0, km = 0;\nint a[100000], b[100000][20], c[20], d[20];\nbool f[20];\ntypedef pair<int, int> bk;\n\nvoid perm(int u, int s, int k, int km) {\n\tif (u == m + 1) {\n\t\tif (kmax < k)\n\t\t\tkmax = k;\n\t\treturn;\n\t}\n\n\tif (k + km <= kmax)\n\t\treturn;\n\n\tpriority_queue<bk> que;\n\tbk b1;\n\n\tfor (int j = 0; j < m; j++) {\n\t\tif (!f[j]) {\n\t\t\tb1.first = b[s][j];\n\t\t\tb1.second = j;\n\t\t\tque.push(b1);\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tb1 = que.top();\n\t\tint kl = b1.first;\n\t\tint p = b1.second;\n\t\tque.pop();\n\t\tf[p] = 1;\n\t\tperm(u + 1, s + d[p], k + kl, km - c[p]);\n\t\tf[p] = 0;\n\t}\n}\n\nint main()\n{\n\tcin >> n >> m;\n\n\tmemset(d, 0, sizeof(d));\n\tmemset(b, 0, sizeof(b));\n\tmemset(f, 0, sizeof(f));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\td[a[i] - 1]++;\n\t}\n\n\tfor (int j = 0; j < m; j++) {\n\t\tfor (int i = 0; i < d[j]; i++) {\n\t\t\tif (j == a[i] - 1)\n\t\t\t\tb[0][j]++;\n\t\t}\n\t\tc[j] = b[0][j];\n\t\tfor (int i = 0; i < n - d[j]; i++) {\n\t\t\tint s = 0;\n\t\t\tif (j == a[i + d[j]] - 1)\n\t\t\t\ts++;\n\t\t\tif (j == a[i] - 1)\n\t\t\t\ts--;\n\t\t\tb[i + 1][j] = b[i][j] + s;\n\t\t\tif (c[j] < b[i + 1][j])\n\t\t\t\tc[j] = b[i + 1][j];\n\t\t}\n\t}\n\n\tfor (int j = 0; j < m; j++)\n\t\tkm += c[j];\n\n\tperm(1, 0, 0, km);\n\n\tcout << n - kmax << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nint N, M;\nint ans = 1 << 30;\nint C[21][100010];\nint num[21];\nint NU[100010];\n\nint DP[1 << 21][21];\nint ac[1 << 21];\nint main() {\n\tstd::cin >> N >> M;\n\tfor (int i = 1; i <= N; i++) {\n\t\tstd::cin >> NU[i];\n\t\tnum[NU[i]]++;\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tfor (int j = 1; j <= num[i]; j++) {\n\t\t\tif (NU[j] != i)C[i][num[i]]++;\n\t\t}\n\t\tfor (int j = num[i] + 1; j <= N; j++) {\n\t\t\tC[i][j] = C[i][j - 1];\n\t\t\tif (NU[j - num[i]] != i)C[i][j]--;\n\t\t\tif (NU[j] != i)C[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << (M + 1); i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tac[i] += num[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < 1 << (M + 1); i++) {\n\t\tfor (int j = 1; j <= M + 1; j++) {\n\t\t\tDP[i][j] = 1 << 30;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << (M + 1)) - 1; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (!(i >> j & 1))continue;\n\t\t\tDP[i][j] = DP[i^(1<<j)][M+1]+C[j][ac[i]];\n\t\t\tDP[i][M + 1] = std::min(DP[i][M + 1], DP[i][j]);\n\t\t}\n\t}\n\tstd::cout << DP[(1<<(M+1))-2][M] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = INT_MAX;\n\nvoid chmin(int &a, int b){\n    a = min(a, b);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int> > cnt(n+1, vector<int>(m));\n    for(int i=0;i<n;i++){\n        int a;\n        cin >> a;\n        a--;\n        cnt[i+1][a]++;\n        for(int j=0;j<m;j++){\n            cnt[i+1][j] += cnt[i][j];\n        }\n    }\n    vector<int> sum(1<<m), dp(1<<m, INF);\n    for(int S=1;S<1<<m;S++){\n        for(int i=0;i<m;i++){\n            if((S>>i)&1) sum[S] += cnt[n][i];\n        }\n    }\n    dp[0] = 0;\n    for(int S=1;S<1<<m;S++){\n        for(int i=0;i<m;i++){\n            if((S>>i)&1){\n                int T = S^(1<<i);\n                chmin(dp[S], dp[T] + cnt[n][i] - (cnt[sum[S]][i]-cnt[sum[T]][i]));\n            }\n        }\n    }\n    cout << dp[(1<<m)-1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n\nconst int inf = 1e9;\n\nint sum[25][100010];\nint cnt[25];\nint dp[1<<22];\n\nsigned main()\n{\n    int n, m; cin >> n >> m;\n\n    rep(i, n) {\n        int a; cin >> a;\n        --a;\n        sum[a][i+1]++;\n        cnt[a]++;\n    }\n\n    rep(i, m) {\n        rep(j, n) {\n            sum[i][j+1] += sum[i][j];\n        }\n    }\n\n    fill_n(dp, 1<<22, inf);\n\n    dp[0] = 0;\n\n    rep(bit, 1 << m) {\n        rep(i, m) {\n            if (!(bit & (1 << i))) {\n                int pos = 0;\n                rep(j, m) if (bit & 1 << j) pos += cnt[j];\n\n                int v = cnt[i] - sum[i][pos + cnt[i]] + sum[i][pos];\n\n                dp[bit | 1 << i] = min(dp[bit | 1 << i], dp[bit] + v);\n            }\n        }\n    }\n\n    cout << dp[(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, M;\nint p[100010], info[100010][20];\nint cnt[1 << 20], dp[1 << 20];\n\nsigned main() {\n    cin >> N >> M;\n    rep(i,0,N) {\n        cin >> p[i];\n        p[i]--;\n        rep(j,0,M) info[i+1][j] = info[i][j] + (j == p[i]);\n    }\n\n    rep(i,1,1<<M) dp[i] = INF;\n    rep(bit,0,1<<M) {\n        rep(k,0,M) {\n            if(bit >> k & 1) cnt[bit] += info[N][k];\n        }\n    }\n\n    rep(bit,0,1<<M) {\n        rep(k,0,M) {\n            if(bit >> k & 1) continue;\n            int nbit = bit | (1 << k);\n            int l = cnt[bit], r = cnt[nbit];\n            int rng = r - l;\n            int seg = info[r][k] - info[l][k];\n            chmin(dp[nbit], dp[bit] + (rng - seg));\n        }\n    }\n\n    cout << dp[(1<<M) - 1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define INF (100000000)\n\ntypedef pair<int, int> P;\n\nint main() {\n    int N,M;\n    cin >> N >> M;\n\n    vector<int> D;\n    vector<P> DPAIR(M);\n    for(int i=0; i<M; ++i) DPAIR[i]=P(i,0);\n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        D.push_back(temp-1);\n        ++DPAIR[temp-1].second;\n    }\n\n    vector<int> DD[M];\n\n    for(int i=0; i<M; ++i) {\n        DD[i].resize(N);\n        DD[i][0]=(D[0]==i?1:0);\n        for(int j=1; j<N; ++j) {\n            DD[i][j]=DD[i][j-1]+(D[j]==i?1:0);\n        }\n    }\n\n    string ALPHA=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string istr=ALPHA.substr(0,M);\n    vector<int> indx(M+1);\n    map<string,P> mp;\n\n    for(int c=1; c<=M; ++c) {\n        indx[c]=M;\n        for(int i=0; i<c; ++i) indx[i]=i;\n        --indx[c-1];\n        while(indx[0]<M-c || c==M) {\n            int now=c-1;\n            while(indx[0]!=M-c || c==M) {\n                if(indx[now+1]-indx[now]>1) {\n                    ++indx[now];\n                    break;\n                } else if(indx[now]-indx[now-1]>1) {\n                    ++indx[now-1];\n                    for(int i=now; i<c; ++i) indx[i]=indx[i-1]+1;\n                    break;\n                } else {\n                    --now;\n                }\n            }\n\n            // main\n            int cnt=INF;\n            int len;\n            string str=\"\";\n            for(int j=0; j<c; ++j) {\n                str.push_back(istr[indx[j]]);\n            }\n            for(int i=0; i<c; ++i) { // most back position's index\n                string s=str;\n                s.erase(s.begin()+i);\n                if(s==\"\") {\n                    cnt=min(cnt,DPAIR[indx[i]].second-DD[indx[i]][DPAIR[indx[i]].second-1]);\n                    len=DPAIR[indx[i]].second;\n                } else {\n                    int fst=mp[s].first;\n                    int snd=mp[s].second;\n                    cnt=min(cnt,fst+DPAIR[indx[i]].second-DD[indx[i]][snd+DPAIR[indx[i]].second-1]+DD[indx[i]][snd-1]);\n                    len=snd+DPAIR[indx[i]].second;\n                }\n            }\n            \n            mp[str]=make_pair(cnt,len);\n            if(c==M) break;\n        }\n    }\n\n    cout << mp[istr].first << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n\n  vector<int> NUM(M);\n  vector<vector<int>> SUM(M, vector<int>(N+1));\n  for(auto i = 0; i < N; ++i) {\n    int m;\n    cin >> m;\n    --m;\n    ++NUM[m];\n    ++SUM[m][i+1];\n    for(auto j = 0; j < M; ++j) SUM[j][i+1] += SUM[j][i];\n  }\n\n  auto test = [](int bit, int i) {return bit & (1 << i);};\n  auto set = [](int bit, int i) {return bit | (1 << i);};\n  auto cost = [&](int bit, int i) {\n    auto n = 0;\n    for(auto j = 0; j < M; ++j) if(test(bit, j)) n += NUM[j];\n    return SUM[i][n + NUM[i]] - SUM[i][n];\n  };\n\n  vector<int> dp(1 << M);\n  for(auto bit = 0; bit < (1<<M); ++bit)\n    for(auto i = 0; i < M; ++i)\n      if(!test(bit, i))\n        dp[set(bit, i)] = max(dp[set(bit, i)], dp[bit] + cost(bit, i));\n\n  cout << N - dp.back() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define inf 10e7\n\nint main(void) {\n  int n, m, i, j, k;\n  scanf(\"%d%d\", &n, &m);\n  int num = 1 << m;\n  int *dp, f[n], numt[m], *sum, ssum[n][m];\n  dp = (int*)malloc(sizeof(int) * num);\n  sum = (int*)malloc(sizeof(int) * num);\n  rep(i, m) {\n    numt[i] = 0;\n    rep(j, n) ssum[j][i] = 0;\n  }\n  rep(i, n) {\n    scanf(\"%d\", &f[i]);\n    f[i]--;\n    numt[f[i]]++;\n    if(!i) ssum[i][f[i]] = 1;\n    else {\n      rep(j, m) ssum[i][j] = ssum[i - 1][j];\n      ssum[i][f[i]]++;\n    }\n  }\n  rep(i, num) sum[i] = 0, dp[i] = inf;\n  rep(i, num) rep(j, m) {\n    if(i & (1 << j)) sum[i] += numt[j];\n  }\n  dp[0] = 0;\n  rep(i, num) {\n    rep(j, m) {\n      if(i){\n        if(dp[i | (1 << j)] > dp[i] - ssum[sum[i | (1 << j)] - 1][j] + ssum[sum[i] - 1][j] + numt[j]) dp[i | (1 << j)] = dp[i] - ssum[sum[i | (1 << j)] - 1][j] + ssum[sum[i] - 1][j] + numt[j];\n      } else {\n        if(dp[i | (1 << j)] > dp[i] - ssum[sum[i | (1 << j)] - 1][j] + numt[j]) dp[i | (1 << j)] = dp[i] - ssum[sum[i | (1 << j)] - 1][j] + numt[j];\n      }\n    }\n  }\n  /*rep(i, n) {\n    rep(j, m)printf(\"%d \", ssum[i][j]);\n    printf(\"\\n\");\n  }\n  rep(i, m) printf(\"%d \", numt[i]);\n  printf(\"\\n\");\n  rep(i, num) printf(\"%d \", sum[i]);\n  printf(\"\\n\");\n  rep(i, num) printf(\"%d \", dp[i]);\n  printf(\"\\n\");*/\n  printf(\"%d\\n\", dp[num - 1]);\n  free(dp);\n  free(sum);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[20];\nconst int MA=1<<20;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\nstring bitt(int x,int c){\n\tstring a=\"\";\nfor(int i=0;i<c;i++){\n\tif(x&(1<<i))a+=\"1\";\n\telse a+=\"0\";\n}\nreverse(a.begin(),a.end());\nreturn a;\n}\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=1;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\tmemset(used,0,sizeof used);\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[t[k]];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=max(1,ruikei);\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Plush Toys\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nint A[100000], B[21] = {};\nint N, M;\n\nint getCost(vector<int> v) {\n    int cnt = 0;\n    int i = 0;\n\n    for(auto j : v) {\n        int k = B[j];\n        while(k > 0) {\n            if(A[i++] != j) cnt++;\n            k--;\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        B[A[i]]++;\n    }\n\n    vector<int> v(M);\n    iota(v.begin(), v.end(), 1);\n\n    int cost = INT_MAX;\n    do {\n        cost = min(cost, getCost(v));\n    } while( next_permutation(v.begin(), v.end()) );\n\n    cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  int a[n],c[m];\n  memset(c,0,sizeof(c));\n  for(int i=0; i<n; i++) {\n    cin >> a[i];\n    a[i]--;\n    c[a[i]]++;\n  }\n  int d[m][n+1];\n  memset(d,0,sizeof(d));\n  for(int i=0; i<m; i++) {\n    for(int j=0; j<n; j++) d[i][j+1]+=d[i][j]+(a[j]==i);\n  }\n  int dp[1<<m];\n  fill(dp,dp+(1<<m),1<<29);\n  dp[0]=0;\n  for(int t=0; t<(1<<m); t++) {\n    int l=0;\n    for(int i=0; i<m; i++) if(t&(1<<i)) l+=c[i];\n    for(int i=0; i<m; i++) {\n      if(t&(1<<i)) continue;\n      int r=l+c[i];\n      dp[t|(1<<i)]=min(dp[t|(1<<i)],dp[t]+c[i]-d[i][r]+d[i][l]);\n    }\n  }\n  cout << dp[(1<<m)-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nint N, M;\nint P[112345];\nint c[23][112345];\nint n[23];\n\nint count(int p, int s, int e) {\n\treturn c[p][e - 1] - ((s == 0) ? 0 : c[p][s - 1]);\n}\n\nint memo[1 << 21];\n\nint dp(int i, int j, int b) {\n\tif (memo[i] != -1) return memo[i];\n\tif (b == 1) return memo[i] = count(log2(i), 0, j);\n\tint a = 0;\n\trep(p, M) {\n\t\tif (i & 1 << p) a = max(a, dp(i ^ (1 << p), j - n[p], b - 1) + count(p, j - n[p], j));\n\t}\n\treturn memo[i] = a;\n}\n\nint main() {\n\n\tmemset(memo, 0xFF, sizeof(memo));\n\n\tscanf(\"%d %d\", &N, &M);\n\n\trep(i, M) n[i] = 0;\n\n\trep(i, N) {\n\t\tscanf(\"%d\", &P[i]);\n\t\tn[P[i] - 1]++;\n\t}\n\n\trep(i, M) {\n\t\tint t = 0;\n\t\trep(j, N) {\n\t\t\tif (P[j] == i + 1) t++;\n\t\t\tc[i][j] = t;\n\t\t\tc[i][j + 1] = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", N - dp((1 << M) - 1, N, M));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Plush Toys\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <climits>\n\nusing namespace std;\n\nint A[100000], B[21] = {};\nint N, M;\n\nint main() {\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        B[A[i]]++;\n    }\n\n    vector<int> v(M);\n    iota(v.begin(), v.end(), 1);\n\n    int cost = INT_MAX;\n    do {\n        int cnt = 0;\n        int i = 0;\n\n        for(auto j : v) {\n            int k = B[j];\n            while(k > 0 && cnt < cost) {\n                if(A[i++] != j) cnt++;\n                k--;\n            }\n        }\n        cost = min(cost, cnt);\n    } while( next_permutation(v.begin(), v.end()) );\n\n    cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[100000], dp[1048576], cnt[20];\nint func(int x, int y) {\n\tint xmem = x, z = 0, cn = 0;\n\tfor (int i = 0; i<20; i++) {\n\t\tif (xmem % 2 == 1)z += cnt[i];\n\t\txmem = xmem / 2;\n\t}\n\tfor (int i = z; i<(z + cnt[y]); i++)\n\t\tif (a[i] == y)cn++;\n\treturn (cnt[y] - cn + dp[x]);\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i<20; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i<n; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tcnt[a[i]]++;\n\t}\n\tfor (int i = 0; i<1048576; i++)\n\t\tdp[i] = 2147483647;\n\tdp[0] = 0;\n\tint j;\n\tfor (int i = 1; i<(1 << m); i++) {\n\t\tj = i;\n\t\tfor (int k = 0; k<20; k++) {\n\t\t\tif (j % 2 == 1)\n\t\t\t\tdp[i] = min(dp[i], func(i - (1 << k), k));\n\t\t\tj = j / 2;\t\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100001\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,A[N],Sum[20][N];\n\n\nint cost(int idx,int i){return Sum[i][n]-(Sum[i][idx+Sum[i][n]]-Sum[i][idx]);}\n\nint mem[1<<20],used[1<<20];\nint dfs(int sta,int idx){\n  if(sta==(1<<m)-1)return 0;\n  if(used[sta]++) return mem[sta];\n  int &res=mem[sta]=INF;\n  for(int i=0;i<m;i++){\n    if((sta>>i)&1)continue;\n    res=min(res,cost(idx,i)+dfs(sta|(1<<i),idx+Sum[i][n]));\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>A[i],A[i]--;\n\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      Sum[i][j+1]+=Sum[i][j]+(A[j]==i);\n  cout <<dfs(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<std::vector<int>> cnt(m, std::vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        int x;\n        std::cin >> x;\n        --x;\n        ++cnt[x][i];\n    }\n\n    for (auto& v : cnt) {\n        for (int i = 1; i <= n; ++i) {\n            v[i] += v[i - 1];\n        }\n    }\n\n    std::vector<int> dp(1 << m, n);\n    dp[0] = 0;\n    for (int b = 0; b < (1 << m); ++b) {\n        int l = 0;\n        for (int i = 0; i < m; ++i) {\n            if ((b >> i) & 1) l += cnt[i].back();\n        }\n        for (int i = 0; i < m; ++i) {\n            if ((b >> i) & 1) continue;\n            int r = l + cnt[i].back();\n            int d = cnt[i].back() - (cnt[i][r] - cnt[i][l]);\n            dp[b | (1 << i)] = std::min(dp[b | (1 << i)], dp[b] + d);\n        }\n    }\n\n    std::cout << dp.back() << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct joutai{\n  int saisyou;\n  int migihasi;\n};\n\nstruct joutai dp[1048576];\nint ruiseki[20][100000];\n\nint bekijou[21];\n\nint main(){\n  bekijou[0]=1;\n  for(int i=1;i<=20;i++){\n    bekijou[i]=2*bekijou[i-1];\n  }\n  int n, m;\n  cin >> n >> m;\n  int narabi;\n  int kosuu[20];\n  for(int i=0;i<m;i++){\n    kosuu[i]=0;\n  }\n  for(int i=0;i<n;i++){\n    cin >> narabi;\n    narabi--;\n    kosuu[narabi]++;\n    for(int j=0;j<m;j++){\n      if(i>0){\n        ruiseki[j][i]=ruiseki[j][i-1];\n      }else{\n        ruiseki[j][i]=0;\n      }\n    }\n    ruiseki[narabi][i]++;\n  }\n  dp[0]={0,0};\n  int toridasu;\n  for(int i=1;i<bekijou[m];i++){\n    dp[i].saisyou=10000000;\n    for(int j=0;j<20;j++){\n      if(i&(1<<j)){\n        toridasu = dp[i^(1<<j)].saisyou + kosuu[j]\n         + ruiseki[j][dp[i^(1<<j)].migihasi-1] - ruiseki[j][dp[i^(1<<j)].migihasi-1+kosuu[j]];\n        dp[i].saisyou=(toridasu<dp[i].saisyou)?toridasu:dp[i].saisyou;\n        dp[i].migihasi=dp[i^(1<<j)].migihasi+kosuu[j];\n      }\n    }\n  }\n\n  cout << dp[bekijou[m]-1].saisyou << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint n, m, imos[20][100005], cnt[20], dp[1 << 20];\n\nint main() {\n\tcin >> n >> m;\n\t\n\tmemset(imos, 0, sizeof(imos));\n\tmemset(cnt, 0, sizeof(cnt));\n\t\n\tfor_(i,0,n) {\n\t\tint x; cin >> x; --x;\n\t\timos[x][i+1] = 1;\n\t\t++cnt[x];\n\t}\n\t\n\tfor_(i,0,m) for_(j,0,n) imos[i][j+1] += imos[i][j];\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0] = 0;\n\t\n\tfor_(S,0,1<<m) {\n\t\tif (dp[S] == -1) continue;\n\t\t\n\t\tint len = 0;\n\t\tfor_(i,0,m) len += cnt[i] * (S >> i & 1);\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tif (S >> i & 1) continue;\n\t\t\tint no_move = imos[i][len + cnt[i]] - imos[i][len];\n\t\t\tint nS = S | (1 << i);\n\t\t\tif (dp[nS] == -1) dp[nS] = 1e9;\n\t\t\tdp[nS] = min(dp[nS], dp[S] + cnt[i] - no_move);\n\t\t}\n\t}\n\t\n\tcout << dp[(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int N, M;\n  cin >> N >> M;\n  int T[N], C[M];\n  fill(C,C+M,0);\n  for(int i = 0; i < N; ++i){\n    cin >> T[i];\n    --T[i];\n    ++C[T[i]];\n  }\n\n  int dp[1<<M], INF = 1000000000;\n  fill(dp,dp+(1<<M),INF);\n  dp[0] = 0;\n  for(int i = 0; i < (1<<M); ++i){\n    int t = 0;\n    for(int j = 0; j < M; ++j){\n      if(i>>j & 1) t += C[j];\n    }\n    for(int j = 0; j < M; ++j){\n      if(!((i>>j) & 1)){\n        int s = dp[i] + C[j];\n        for(int k = t; k < t+C[j]; ++k){\n          if(T[k] == j) --s;\n        }\n        dp[i | (1<<j)] = min(dp[i | (1<<j)], s);\n      }\n    }\n  }\n\n  cout << dp[(1<<M)-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[1<<20][2];\nint list[100001][20];\nint n,m,r,w;\nint find(int a,int b,int t){\n\t//a~b?????????t??§???????????°????????°?????????\n\treturn b-a-(list[b][t]-list[a][t]);\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)list[0][i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>r;\n\t\tfor(int j=0;j<m;j++)list[i+1][j]=list[i][j];\n\t\tlist[i+1][r-1]++;\n\t}\n\tw=1;\n\tfor(int i=0;i<m;i++)w*=2;\n\tfor(int i=0;i<w;i++)dp[i][0]=1145141919;\n\tdp[0][0]=0,dp[0][1]=0;\n\n\tfor(int i=0;i<w;i++){\n\t\tbool will[20]={false};//????????§???????????????\n\t\tint e=1;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i%(e*2)<e)will[j]=true;\n\t\t\te*=2;\n\t\t}\n\n\t\te=1;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(will[j]){\n\t\t\t\tdp[i+e][1]=dp[i][1]+list[n][j];\n\t\t\t\tdp[i+e][0]=min(dp[i+e][0],dp[i][0]+find(dp[i][1],dp[i+e][1],j));\n\t\t\t}\n\t\t\te*=2;\n\t\t}\n\t}\n\tcout<<dp[w-1][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int MAX_M = 20;\n\nint N, M;\nint K[MAX_N];\nint sum[MAX_M][MAX_N + 1];\nint dp[1 << MAX_M], dp2[1 << MAX_M];\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i++) cin >> K[i];\n\tfill(sum[0], sum[M], 0);\n\tfor(int i = 0; i < N; i++) sum[K[i] - 1][i + 1]++;\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tsum[i][j] += sum[i][j - 1];\n\t\t}\n\t}\n\tfill(dp, dp + (1 << M), 0);\n\tfill(dp2, dp2 + (1 << M), 0);\n\tfor(int i = 1; i < (1 << M); i++){\n\t\tint minimum_num = MAX_N + 1;\n\t\tfor(int j = 0; j < M; j++){\n\t\t\tif(!(i & (1 << j))) continue;\n\t\t\tdp2[i] = dp2[i - (1 << j)] + sum[j][N];\n\t\t\tminimum_num = min(minimum_num, dp[i - (1 << j)] + sum[j][N] - (sum[j][dp2[i - (1 << j)] + sum[j][N]] - sum[j][dp2[i - (1 << j)]]));\n\t\t}\n\t\tdp[i] = minimum_num;\n\t}\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> v(n);\n    rep(i,n)cin>>v[i];\n    rep(i,n)v[i]--;\n    \n    static vector<vector<int>> r(m,vector<int>(n+1,0));\n    vector<int> num(20,0);\n    rep(i,v.size()){\n        num[v[i]]++;\n        r[v[i]][i+1] = 1;\n    }\n    rep(i,m){\n        rep(j,n){\n            r[i][j+1] += r[i][j];\n        }\n    }\n    \n    static int dp[1<<20];\n    static int len[1<<20];\n    rep(i,1<<20)dp[i] = INF;\n    rep(i,1<<20)len[i] = INF;\n    dp[0] = 0;\n    len[0] = 0;\n    \n    rep(bit,1<<m){\n        rep(piv,m){\n            if( (bit&(1<<piv))==0 ){\n                int left = len[bit], right = left + num[piv];\n                \n                int add = num[piv] - (r[piv][right] - r[piv][left]);\n                \n                dp[bit|(1<<piv)] = min(dp[bit|(1<<piv)], dp[bit] + add);\n                len[bit|(1<<piv)] = len[bit] + num[piv];\n            }\n        }\n    }\n    cout<<dp[(1<<m)-1]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint n, m, kmax = 0;\nint a[100000], b[20][100000];\n\nint main()\n{\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i > 0)\n\t\t\t\tb[i][j] = b[i - 1][j];\n\t\t\telse\n\t\t\t\tb[i][j] = 0;\n\t\t}\n\t\tb[i][a[i] - 1]++;\n\t}\n\n\tvector<int> p(m);\n\tiota(p.begin(), p.end(), 1);\n\n\tdo {\n\t\tint t = 0, k = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s = b[n - 1][p[i] - 1];\n\t\t\tif (t > 0)\n\t\t\t\tk += b[s + t - 1][p[i] - 1] - b[t - 1][p[i] - 1];\n\t\t\telse\n\t\t\t\tk = b[s + t - 1][p[i] - 1];\n\t\t\tt += s;\n\t\t}\n\t\tif (kmax < k)\n\t\t\tkmax = k;\n\t} while (next_permutation(p.begin(), p.end()));\n\n\tcout << n - kmax << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n\n  vector<int> toys(N);\n  vector<int> nums(M + 1, 0);\n  for (int i = 0; i < N; i++) {\n    cin >> toys[i];\n    nums[toys[i]]++;\n  }\n\n  int cnt = 0;\n  int offset = 0;\n  vector<bool> ok(M + 1, false);\n  for (int i = 1; i <= M; i++) {\n    int minJ = 0;\n    int minD = N;\n    for (int j = 1; j <= M; j++) {\n      if (ok[j]) {\n\tcontinue;\n      }\n      int d = 0;\n      for (int k = 0; k < nums[j]; k++) {\n\tif (toys[offset + k] != j) {\n\t  d++;\n\t}\n      }\n      if (d < minD) {\n\tminJ = j;\n\tminD = d;\n      }\n    }\n    cnt += minD;\n    offset += nums[minJ];\n    ok[minJ] = true;\n  }\n\n  cout << cnt << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[21];\nconst int MA=1<<21;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\trep(k,m)used[k]=0;\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\ncout<\"WA\";\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\n//cout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dp[1<<20];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n  VI sz(M);\n  VI xs(N);\n  REP(i,N){\n\tcin >> xs[i];\n\t--xs[i];\n\tsz[xs[i]]++;\n  }\n  VVI cnt(N+1, VI(M,0));\n  REP(i,N){\n\tREP(j,M)\n\t  cnt[i+1][j] = cnt[i][j] + (xs[i] == j);\n  }\n\n  fill(dp, dp+(1<<20), 1e9);\n\n  REP(j,M){\n\tdp[1<<j] = sz[j] - cnt[sz[j]][j];\n  }\n\n  for(int b=1;b<(1<<M);++b){\n\tint s = 0;\n\tREP(j,M) if(b>>j&1) s += sz[j];\n\tREP(j,M){\n\t  if((b>>j&1) == 1) continue;\n\t  mini(dp[b|(1<<j)], dp[b] + sz[j] - (cnt[s+sz[j]][j] - cnt[s][j]));\n\t}\n  }\n  cout << dp[(1<<M)-1] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define UNDEF (1 << 31)\n\nusing namespace std;\n\nunsigned int dp[1048576];\nint N,M,S[100000],R[20][100001];\n\nbool ibs(int bits,int ref)\n{\n\treturn ((1 << ref) & bits) == (1 << ref);\n}\n\nint sbt(int bits,int ref)\n{\n\treturn bits | (1 << ref);\n}\n\nvoid dfs(int bits,int cnt)\n{\n\t{\n\t\tint tb;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tif(!ibs(bits,i))\n\t\t\t{\n\t\t\t\ttb = sbt(bits,i);\n\t\t\t\tdp[tb] = min(dp[tb],dp[bits]+(R[i][N] - (R[i][cnt+R[i][N]] - R[i][cnt])));\n\t\t\t\tdfs(tb,cnt+R[i][N]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor(int i = 0;i < 1048576;i++)\n\t{\n\t\tdp[i] = UNDEF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> S[i];\n\t\tS[i]--;\n\t\tfor(int k = 0;k < 20;k++)\n\t\t{\n\t\t\tR[k][i+1] = R[k][i];\n\t\t}\n\t\tR[S[i]][i+1]++;\n\t}\n\tdfs(0x00000000,0);\n\tint ref = 0;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tref = sbt(ref,i);\n\t}\n\tcout << dp[ref] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,sum,rui;\nint b[21][100000];\nint memo[1<<20];\nint minimum=INT_MAX;\nvoid dp(int k,int bit,int total){\n\n  if(k != n){\n    for(int i=1;i<=m;i++){\n      if( (bit&(1<<i-1)) == 0){\n\tsum = n-b[i][n-1];\n\trui = (k == 0)? b[i][k+sum-1]:b[i][k+sum-1]-b[i][k-1];\n\t//printf(\"!%d(%d~%d),%d \",i,k,k+sum-1,total+rui);\n\tdp(k+sum,bit|(1<<i-1),total+rui);\n      }\n    }\n  }else {\n    minimum=min(minimum,total);\n    // puts(\"\");\n  }\n  \n}\nint main(){\n  int a;\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&a);\n    for(int j=1;j<=m;j++){\n      if(j != a) b[j][i]++;\n      if(i != 0) b[j][i] += b[j][i-1];\n    }\n  }\n\n  dp(0,0,0);\n  printf(\"%d\\n\",minimum);\n  \n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint n,m; cin >> n >> m;\n\tint cntm[21][100005];\n\tint sm[22];\n\tfor (int i = 1;i < m;i++){\n\t\tcntm[i][0] = 0;\n\t\tsm[i] = 0;\n\t}\n\n\tint a;\n\n\tfor (int i = 0;i < n;i++){\n\t\tcin >> a;\n\t\tfor (int j = 1;j <= m;j++){\n\t\t\tif(a == j) cntm[j][i+1] = cntm[j][i]+1;\n\t\t\telse cntm[j][i+1] = cntm[j][i];\n\t\t}\n\t\tsm[a]++;\n\t}\n\n\tint dp[1<<20];\n\tfill(dp,dp+(1<<20),INT_MAX);\n\n\tdp[0] = 0;\n\n\tfor (int i = 0;i < (1<<m);i++){\n\t\tfor (int j = 0;j < m;j++){\n\t\t\tif((i>>j & 1) == 0){\n\t\t\t\tint st = 0;\n\t\t\t\tfor (int k = 0;k < m;k++){\n\t\t\t\t\tif(i>>k&1)st += sm[k+1];\n\t\t\t\t}\n\t\t\t\tint next = sm[j+1] - (cntm[j+1][st+sm[j+1]] - cntm[j+1][st]);\n\t\t\t\tdp[i|1<<j] = min(dp[i|1<<j],dp[i]+next);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[(1<<m)-1] << endl;\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n#define mp std::make_pair\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::pair<int,int> PII;\n\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\ntypedef std::vector<PII> VPII;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\nint N, M;\nVI memo(1 << 20, -1);\nVI2 b(21, VI(100001, 0));\n\nint dp(int k,int bit){\n    if(k == N) return 0;\n    if(memo[bit] != -1) return memo[bit];\n\n    int ret = std::numeric_limits<int>::max();\n    FOR(i, 1, M+1) {\n        if( ( bit&1 << (i-1)) == 0){\n            int x = N-b[i][N];\n            int y = b[i][k+x]-b[i][k];\n            ret = std::min(ret,dp(k+x,bit|1<<(i-1))+y);\n        }\n    }\n    return memo[bit] = ret;\n}\n\nint main(){\n    std::cin >> N >> M;\n    FOR(i, 1, N+1) {\n        int a;\n        std::cin >> a;\n        FOR(j, 1, M+1) {\n            if(j != a) b[j][i]++;\n            b[j][i] += b[j][i-1];\n        }\n    }\n    std::cout << dp(0, 0) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// written by @kakira9618\n// problem: https://www.ioi-jp.org/joi/2016/2017-yo/2017-yo-t4/2017-yo-t4.html\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n  \nint sum[20][100000]; // sum[c][i]: ???c???i???????????§??????????????????\nint count[20]; // count[c]: ???c??????????????????\nint dp[1 << 20]; // dp[i]: i????????£???????????????????????´????????????????????????????????????????????¨???????§£\nconst int INF = 1 << 29;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> C(N);\n\n    for(int i = 0; i < N; i++) {\n        cin >> C[i];\n        C[i]--;\n        count[C[i]]++;\n    }\n\n    // ?´???????????¨????\n    // O(NM)\n    for(int c = 0; c < M; c++) {\n        for(int i = 0; i < N; i++) {\n            if (C[i] == c) sum[c][i] = 1;\n        }\n    }\n    for(int c = 0; c < M; c++) {\n        int s = 0;\n        for(int i = 0; i < N; i++) {\n            s += sum[c][i];\n            sum[c][i] = s;\n        }\n    }\n\n    // BitDP?????????\n    for(int i = 0; i < 1 << M; i++) {\n        dp[i] = INF;\n    }\n    dp[0] = 0;\n\n    // BitDP\n    // ?????¨?????£???????????????????????¨?´????????????????????????£???????????????????????????????????¬?????????????????°????±????????????????\n    // O(2^M M)\n    for(int i = 0; i < 1 << M; i++) {\n        int s = 0;\n        for(int j = 0; j < M; j++) {\n            if (i >> j & 1) {\n                s += count[j];\n            }\n        }\n        for(int j = 0; j < M; j++) {\n            if (!(i >> j & 1)) {\n                dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + count[j] - (sum[j][s + count[j] - 1] - sum[j][s >= 1 ? s - 1 : 0]));\n            }\n        }\n    }\n\n    cout << dp[(1 << M) - 1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define rep(i, a, n) for(int i = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int i = (int)(a);(i) <= (int)(n);++(i))\n#define repif(i, a, x) for(int i = (int)(a);(x);++(i))\n#define repr(i, a, n) for(int i = ((int)(a)-1);(i) >= (int)(n);--(i))\n#define reper(i, a, n) for(int i = (int)(a);(i) >= (int)(n);--(i))\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define CEIL(x) ((int)ceil(((double)x)))\n#define POW(x, y) ((int)pow(x, y))\n#define UNIQUE(x) (x).erase(unique(ALL((x))), end(x))\n#define gcd(x, y) __gcd(x, y)\n#define lcm(x, y) ((x)/gcd(x,y)*(y))\n#define isin(x, l, r) ((l) <= (x) and (x) < (r))\n#define fcout(n) cout << fixed << setprecision(n)\n#define rcout(n) cout << right << setw(n)\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define PI (acosl(-1))\n#define EPS (1e-10)\n#define INF LLONG_MAX\n#define INF32 INT32_MAX\n#define MOD 1000000007LL\nusing namespace std;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing PII = pair<int, int>;\nusing TIII = tuple<int, int, int>;\nusing VPII = vector<pair<int, int>>;\nusing VTIII = vector<tuple<int, int, int>>;\nusing Complex = complex<double>;\ntemplate<typename T, template<typename> typename C = less> using PQ = priority_queue<T, vector<T>, C<T>>;\ntemplate<typename T> inline bool chmax(T& a, const T& b, bool t = false){ if(a<b or (t and a == b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a, const T& b, bool t = false){ if(a>b or (t and a == b)){ a=b; return true; } return false; }\n\n\ntemplate<typename T>\nstruct CumulativeSum {\n    vector<T> dat;\n    CumulativeSum() = default;\n    CumulativeSum(const vector<T>& v){\n        int n = v.size();\n        dat.resize(n+1);\n        for(int i = 0;i < n;i++) dat[i+1] = dat[i]+v[i];\n    }\n    inline void add(int k, T a){\n        dat[k] += a;\n    }\n    inline void build(){\n        int n = dat.size();\n        for(int i = 0;i < n;i++) dat[i+1] += dat[i];\n    }\n    //[l, r)\n    inline T query(int l, int r) const {\n        return dat[r]-dat[l];\n    }\n};\n\n\nint N, M;\nint p[100010];\nCumulativeSum<int> S[20];\nint dp[1<<20];\n\n\nsigned main(){\n    cin >> N >> M;\n    rep(i, 0, N) cin >> p[i], p[i]--;\n\n    rep(i, 0, M){\n        vector<int> v(N);\n        rep(j, 0, N) v[j] = (p[j] == i);\n        S[i] = CumulativeSum<int>(v);\n    }\n\n    fill(dp, dp+(1<<M), INF);\n    dp[0] = 0;\n    rep(i, 0, 1<<M){\n        int off = 0;\n        rep(j, 0, M) if(((i>>j)&1) == 1) off += S[j].query(0, N);\n        rep(j, 0, M) if(((i>>j)&1) == 0){\n            int r = S[j].query(0, N);\n            chmin(dp[i|(1<<j)], dp[i]+(r-S[j].query(off, off+r)));\n        }\n    }\n\n    cout << dp[(1<<M)-1] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<typename T>\nvoid chmin(T &a, T b) {\n    a = min(a, b);\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<int> Cnt(m, 0);\n    auto sum = make_v(n + 1, m, 0);\n    REP(i, 0, n) {\n        int a;\n        cin >> a;\n        Cnt[a - 1]++;\n        sum[i + 1][a - 1]++;\n        REP(j, 0, m) {\n            sum[i + 1][j] += sum[i][j];\n        }\n    }\n\n    int size = 1 << m;\n    const int inf = 1 << 30;\n    auto dp = make_v(size, inf);\n    dp[0] = 0;\n    REP(i, 0, size) {\n        int bs = 0;\n        REP(j, 0, m) {\n            if ((i >> j) & 1) {\n                bs += Cnt[j];\n            }\n        }\n        REP(j, 0, m) {\n            if ((i >> j) & 1) continue;\n            int nbs = bs + Cnt[j];\n            int diff = sum[nbs][j] - sum[bs][j];\n            int len = Cnt[j];\n            chmin(dp[i | (1 << j)], dp[i] + len - diff);\n        }\n    }\n    cout << dp[size - 1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1e9;\n\nint N, M;\nint sum[20][100005] = {};\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tint tmp;\n\t\tcin >> tmp; tmp--;\n\t\tsum[tmp][i + 1] = 1;\n\t}\n\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsum[i][j + 1] += sum[i][j];\n\t\t}\n\t}\n\n\tvector<int> dp(1 << M, -INF);\n\tdp[0] = 0;\n\tfor (int i = 0; i < (1 << M); i++) {\n\t\tint l = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i & (1 << j)) l += sum[j][N];\n\t\t}\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint add = sum[j][l + sum[j][N]] - sum[j][l];\n\t\t\tdp[i | (1 << j)] = max(dp[i | (1 << j)], dp[i] + add);\n\t\t}\n\t}\n\n\tcout << N - dp[(1 << M) - 1] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define INF (100000000)\n\ntypedef pair<int, int> P;\n\nint main() {\n    int N,M;\n    cin >> N >> M;\n\n    vector<int> D;\n    vector<P> DPAIR(M);\n    for(int i=0; i<M; ++i) DPAIR[i]=P(i,0);\n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        D.push_back(temp-1);\n        ++DPAIR[temp-1].second;\n    }\n\n    vector<int> DD[M];\n\n    for(int i=0; i<M; ++i) {\n        DD[i].resize(N);\n        DD[i][0]=(D[0]==i?1:0);\n        for(int j=1; j<N; ++j) {\n            DD[i][j]=DD[i][j-1]+(D[j]==i?1:0);\n        }\n    }\n\n    int ans=INF;\n    do {\n        int cnt=DPAIR[0].second-DD[DPAIR[0].first][DPAIR[0].second-1];\n        int left=DPAIR[0].second;\n        for(int i=1; i<M; ++i) {\n            cnt+=DPAIR[i].second-(DD[DPAIR[i].first][left+DPAIR[i].second-1]-DD[DPAIR[i].first][left-1]);\n            left+=DPAIR[i].second;\n        }\n        ans=min(ans,cnt);\n    } while(next_permutation(DPAIR.begin(),DPAIR.end()));\n\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\nconstexpr int INF = 1 << 29;\nconstexpr int MOD = 1000000007;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> C(N);\n\tvector<int> cnt(M, 0);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> C[i];\n\t\tC[i]--;\n\t\tcnt[C[i]]++;\n\t}\n\n\tvector<vector<int>> acc(M, vector<int>(N + 1, 0));\n\tfor(int c = 0; c < M; c++) {\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tsum += C[i] == c ? 1 : 0;\n\t\t\tacc[c][i + 1] = sum; // acc[c][i + 1] : [0, i]\n\t\t}\n\t}\n\n\tvector<int> dp(1 << M, 1 << 30);\n\tdp[0] = 0;\n\n\tfor(int i = 0; i < 1 << M; i++) {\n\t\tint length = 0;\n\t\tfor(int j = 0; j < M; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tlength += cnt[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = 0; j < M; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tdp[i] = min(dp[i], dp[i & ~(1 << j)] + cnt[j] - (acc[j][length] - acc[j][length - cnt[j]]) );\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[(1 << M) - 1] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nint n, m;\n\nint dist[1 << 20];\nint cost[20][123456];\nint nui[123456];\nint ncount[20];\n\nint memo[1 << 20];\nint dp(int bit)\n{\n\tif (bit == 0)return 0;\n\tif (memo[bit] >= 0)return memo[bit];\n\tint ans = 123456789;\n\tfor (int i = 0; i < 20; ++i)\n\t{\n\t\tif (bit & (1 << i))\n\t\t{\n\t\t\tint lastbit = bit - (1 << i);\n\t\t\tans = min(ans, dp(lastbit) + cost[i][dist[lastbit]]);\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d\", &n, &m);\n\tmemset(memo, 0xff, sizeof(memo));\n\tfill(ncount, ncount + 20, 0);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", nui + i);\n\t\t--nui[i];\n\t\t++ncount[nui[i]];\n\t}\n\tdist[0] = 0;\n\tfor (int bit = 1; bit < (1 << m); ++bit)\n\t{\n\t\tint bigb = 0;\n\t\tfor (int i = 0; i < 20; ++i)\n\t\t{\n\t\t\tif (bit & (1 << i))\n\t\t\t{\n\t\t\t\tbigb = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdist[bit] = dist[bit - (1 << bigb)] + ncount[bigb];\n\t}\n\tfor (int j = 0; j < m; ++j)\n\t{\n\t\t//cost\n\t\tint price = 0;\n\t\tfor (int first = 0; first < ncount[j]; ++first)\n\t\t{\n\t\t\tif (nui[first] == j)\n\t\t\t{\n\t\t\t\t++price;\n\t\t\t}\n\t\t}\n\t\tfor (int shack = 0; shack <= n - ncount[j]; ++shack)\n\t\t{\n\t\t\tcost[j][shack] = ncount[j] - price;\n\t\t\tif (nui[shack] == j)\n\t\t\t{\n\t\t\t\t--price;\n\t\t\t}\n\t\t\tif (shack != n - ncount[j] && nui[shack + ncount[j]] == j)\n\t\t\t{\n\t\t\t\t++price;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp((1 << m) - 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n    ll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//???£??\\????????????¨???\n    ll to, cost;\n};\nstruct S {//????????????±?????\\????????????°\n    int from, to, cost;\n};\nstruct H {\n    int x, y;\n};\nll gcm(ll i, ll j) {//??????§???¬??´????°\n    if (i > j) swap(i, j);\n    if (i == 0) return j;\n    return gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n    return sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad??????§??¨???????2???????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nint n, m;\nint a[100000], b[20][100000], c[20];\nint dp[1048576];\nint solve(int s,int sum) {\n    if (s == (1 << m) - 1)\n        return 0;\n    if (dp[s] != -1) return dp[s];\n    int res = inf;\n    for (int i = 0; i < m; i++) {\n        if (!(s&(1 << i))) {\n            int ret = c[i] - b[i][sum + c[i]-1] + (sum != 0 ? b[i][sum-1] : 0);\n            res = min(res, solve(s | (1 << i), sum + c[i]) + ret);\n        }\n    }\n    return dp[s]=res;\n}\nsigned main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        c[--a[i]]++;\n        b[a[i]][i]++;\n        for (int j = 0; j < m; j++)\n            b[j][i + 1] = b[j][i];\n    }\n    for (int i = 0; i < 1048576; i++) \n        dp[i] = -1;\n    cout << solve(0, 0) << endl;\n    getchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M;\nint a[100000];\nint b[20][100001];\nint dp[(1<<20)];\nint main(){\n  scanf(\"%d %d\",&N,&M);\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&a[i]);\n    a[i]--;\n    b[a[i]][i+1]++;\n  }\n  for(int i=0;i<M;i++)\n    for(int j=0;j<N;j++)\n      b[i][j+1]+=b[i][j];\n  fill(dp,dp+(1<<M),1e9);\n  dp[0]=0;\n  for(int S=0;S<(1<<M);S++){\n    int p=0;\n    for(int i=0;i<M;i++)\n      if(S>>i&1)p+=b[i][N];\n    for(int i=0;i<M;i++){\n      if(S>>i&1)continue;\n      int cnt=b[i][N];\n      int cost=cnt-(b[i][p+cnt]-b[i][p]);\n      dp[S+(1<<i)]=min(dp[S+(1<<i)],dp[S]+cost);\n    }\n  }\n  printf(\"%d\\n\",dp[(1<<M)-1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint N, M;\nint A[100010];\nint cum[20][100010];\nint cnt[20];\nint memo[1 << 20];\n\nint rec(int sum, int bit) {\n    if (sum == N && !bit) return 0;\n    if (~memo[bit]) return memo[bit];\n    int res = 1 << 30;\n    REP(i, M) if (bit >> i & 1) {\n        res = min(res, cnt[i] - (cum[i][sum + cnt[i]] - cum[i][sum]) + rec(sum + cnt[i], bit - (1 << i)));\n    }\n    return memo[bit] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> M;\n    REP(i, N) {\n        cin >> A[i];\n        --A[i];\n        ++cum[A[i]][i + 1];\n        ++cnt[A[i]];\n    }\n    REP(i, 20) REP(j, N) cum[i][j + 1] += cum[i][j];\n    memset(memo, 0xff, sizeof(memo));\n    cout << rec(0, (1 << M) - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2019/11/06 Tazoe\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 200000;\t\t// 十分大きな定数\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\n\t// 累積和\n\tint sum[21][100001];\n\tfor(int i=1; i<=M; i++){\n\t\tsum[i][0] = 0;\n\t}\n\n\tfor(int j=1; j<=N; j++){\n\t\tfor(int i=1; i<=M; i++){\n\t\t\tsum[i][j] = sum[i][j-1];\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\tsum[m][j]++;\n\t}\n\n\t// ビットDP\n\tint dp[1<<20];\n\tint nS[1<<20];\t\t// 集合Sの個数\n\tfor(int S=0; S<(1<<M); S++){\n\t\tdp[S] = INF;\n\t\tnS[S] = -1;\n\t}\n\tdp[0] = 0;\n\tnS[0] = 0;\n\n\tfor(int S=1; S<(1<<M); S++){\n\t\tfor(int i=1; i<=M; i++){\n\t\t\tif(((S>>(i-1))&1)==1){\n\t\t\t\tint n = sum[i][N];\t\t\t\t// 種類iの個数\n\t\t\t\tint R = S^(1<<(i-1));\t\t\t\t// 種類iが含まれない集合\n\t\t\t\tint s = sum[i][nS[R]+n]-sum[i][nS[R]];\t// 種類iの区間に含まれる個数\n\n\t\t\t\tif(dp[S]>dp[R]+(n-s)){\n\t\t\t\t\tdp[S] = dp[R]+(n-s);\n\t\t\t\t\tnS[S] = nS[R]+n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[(1<<M)-1] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 20;\nconst int INF = 1 << 30;\n\ntemplate<typename T>class BIT {\n    public:\n    int n;\n    vector<T> bit;\n    \n    BIT(int n): n(n){\n        bit.resize(n);\n        fill(bit.begin(), bit.end(), (T)0);\n    }\n\n    void add(int idx, int x){\n        for(int i=idx;i<=this->n;i+=i&-i) bit[i] += x;\n    }\n\n    //bit[1]からbit[end]までの和 (閉区間)\n    T sum(int end){\n        T ret = (T)0;\n        for(int i=end;i>=1;i-=i&-i) ret += bit[i];\n        return ret;\n    }\n\n    //bit[1]からbit[end]までの和 (閉区間)\n    T sum_range(int start, int end){\n        return sum(end) - sum(start-1);\n    }\n};\n\nint a[MAX_N], count_toy[MAX_M], dp[1<<MAX_M], count_dp[1<<MAX_M];\nvector< BIT<int> > trees(MAX_M, BIT<int>(MAX_N+1));\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    for(int i=0;i<n;++i) {\n        cin >> a[i];\n        a[i]--;\n        count_toy[a[i]]++;\n        trees[a[i]].add(i+1, 1);\n    }\n\n    count_dp[0] = 0;\n    for(int bit=0;bit<(1<<m);++bit) {\n        for(int i=0;i<m;i++) {\n            if(bit & (1 << i) || count_dp[bit|(1<<i)]) continue;\n            count_dp[bit|(1<<i)] = count_dp[bit] + count_toy[i];\n        }\n    }\n\n    fill(dp, dp+(1<<m), INF);\n    dp[0] = 0;\n    for(int bit=0;bit<(1<<m);++bit) {\n        for(int i=0;i<m;++i) {\n            if(bit & (1 << i)) continue;\n            dp[bit | (1<<i)] = min(\n                dp[bit | (1<<i)], \n                dp[bit] + count_toy[i] - trees[i].sum_range(count_dp[bit]+1, count_dp[bit]+count_toy[i])\n            );\n        }\n        // cerr << bitset<4>(bit) << \": \" << dp[bit] << endl;\n    }\n\n    cout << dp[(1<<m)-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nint N, M;\nint a[112345];\nint cnt[112345][20];\nint dp[1<<20];\n\nint main() {\n\tcin >> N >> M;\n\tREP(i, N) scanf(\"%d\", a + i), a[i]--;\n\t\n\tREP(i, N) cnt[i + 1][a[i]]++;\n\tREP(j, M) REP(i, N) cnt[i + 1][j] += cnt[i][j];\n\t\n\tfill(dp, dp + (1<<M), INF);\n\t\n\tdp[0] = 0;\n\tREP(s, 1<<M) { // ??¢????????£???????????°\n\t\tint c = 0;\n\t\tREP(i, M) if (s >> i & 1) c += cnt[N][i];\n\t\tREP(i, M) if (!(s >> i & 1)) {\n\t\t\tint p = cnt[N][i] - (cnt[c + cnt[N][i]][i] - cnt[c][i]);\n\t\t\tchmin(dp[s | 1<<i], dp[s] + p);\n\t\t}\n\t}\n\t\n\tcout << dp[(1<<M)-1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint search(int);\nint **line;\nint N, M;\nint main() {\n\tcin >> N >> M;\n\tline = new int*[N + 1];\n\tline[0] = new int[M + 1]{ 0 };\n\tint dummy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tcin >> dummy;\n\t\tline[i] = new int[M + 1];\n\t\tfor (int j = 1; j <= M; ++j) {\n\t\t\tline[i][j] = line[i - 1][j];\n\t\t}\n\t\t++line[i][dummy];\n\t}\n\tint *dp;\n\tdp = new int[1 << M];\n\tdp[0] = 0;\n\tfor (int i = 1; i < (1 << M); ++i) {\n\t\tdp[i] = N + 1;\n\t}\n\tfor (int i = 0; i < (1 << M) - 1; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (!(i&(1 << j))) {\n\t\t\t\tint nlong = search(i);\n\t\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + line[N][j + 1] - (line[nlong + line[N][j + 1]][j + 1] - line[nlong][j + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n}\nint search(int use) {\n\tint res = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (use&(1 << i)) {\n\t\t\tres += line[N][i + 1];\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n,m,a[100000],cnt[20] = {},imos[100001][20] = {};\n\tint dp[1 << 20] = {};\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tcnt[a[i]]++;\n\t\tfor(int j = 0;j < m;j++) imos[i + 1][j] = imos[i][j];\n\t\timos[i + 1][a[i]]++;\n\t}\n\tfor(int i = 0;i < (1 << 20);i++){\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1;i < (1 << m);i++){\n\t\tint sum = 0;\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif((i >> j) & 1) sum += cnt[j];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tdp[i] = min(dp[i],dp[i & ~(1 << j)] + cnt[j] - (imos[sum][j] - imos[sum - cnt[j]][j]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\nlong long int const LL_MAX = 10000000000000000; // 10^16\nint const INT_MAX = 100000000; // 10^8\n\nint DP_sum[21][100001];\nint doll_sum[21];\nint DP[2000000];\nint Sum[2000000];\n\nint main(){\n\t\n\tint N, M;\n\t\n\tcin >> N >> M;\n\t\n\tfor(int i = 0; i <= M; i++){\n\t\tDP_sum[i][0] = 0;\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tint num;\n\t\tcin >> num;\n\t\tfor(int j = 1; j <= M; j++){\n\t\t\tDP_sum[j][i] = DP_sum[j][i - 1];\n\t\t}\n\t\tDP_sum[num][i]++;\n\t}\n\t\n\tfor(int i = 0; i <= M; i++){\n\t\tdoll_sum[i] = DP_sum[i][N];\n\t}\n\t\n\tfor(int i = 0; i < 2000000; i++){\n\t\tDP[i] = INT_MAX;\n\t}\n\t\n\tSum[0] = 0;\n\tDP[0] = 0;\n\t\n\tfor(int i = 0; i < (1 << M); i++){\n\t\tint hoge = i;\n\t\tint comp = 1;\n\t\tfor(int j = 1; j <= M; j++){\n\t\t\tif(hoge % 2 == 1){\n\t\t\t\tSum[i] = Sum[i - comp] + doll_sum[j];\n\t\t\t\tDP[i] = min(DP[i], DP[i - comp] + doll_sum[j] - (DP_sum[j][Sum[i]] - DP_sum[j][Sum[i - comp]]));\n\t\t\t}\n\t\t\thoge /= 2;\n\t\t\tcomp *= 2;\n\t\t}\n\t}\n\t\n\tcout << DP[(1 << M) - 1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,b[21][100001]={};\nint memo[1<<20];\nint dp(int k,int bit){\n  if(k == n) return 0;\n  if(memo[bit] != -1) return memo[bit];\n  int ret = INT_MAX;\n  for(int i=1;i<=m;i++){\n    if( (bit&1<<i-1) == 0){\n      int isum = n-b[i][n];\n      int rui = b[i][k+isum]-b[i][k];\n      ret = min(ret,dp(k+isum,bit|1<<i-1)+rui);\n    }\n  }\n  return memo[bit] = ret;\n}\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  int a;\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",&a);\n    for(int j=1;j<=m;j++){\n      if(j != a) b[j][i]++;\n      b[j][i] += b[j][i-1];\n    }\n  }\n  fill(memo,memo+(1<<20),-1);\n  printf(\"%d\\n\",dp(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void chmin(int &a, int b) { a = min(a, b); }\n\nint N, M;\nint sum[20][100001];\nint dp[1 << 20];\n\nint main()\n{\n  scanf(\"%d %d\", &N, &M);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    sum[--K][i + 1]++;\n    for(int j = 0; j < 20; j++) {\n      sum[j][i + 1] += sum[j][i];\n    }\n  }\n\n  memset(dp, 0x3f, sizeof(dp));\n  dp[0] = 0;\n  for(int i = 0; i < (1 << M); i++) {\n    int left = 0;\n    for(int j = 0; j < M; j++) {\n      if((i >> j) & 1) left += sum[j][N];\n    }\n    for(int j = 0; j < M; j++) {\n      if((i >> j) & 1) continue;\n      chmin(dp[i | (1 << j)], dp[i] + sum[j][N] - sum[j][left + sum[j][N]] + sum[j][left]);\n    }\n  }\n\n  printf(\"%d\\n\", dp[(1 << M) - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint **dp;\nint **line;\nint search(int, int);\nint N, M;\nint finish;\nint main() {\n\tcin >> N >> M;\n\tline = new int*[N + 1];\n\tline[0] = new int[M + 1]{ 0 };\n\tint dummy;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tline[i] = new int[M + 1];\n\t\tfor (int j = 1; j <= M; ++j) {\n\t\t\tline[i][j] = line[i - 1][j];\n\t\t}\n\t\tcin >> dummy;\n\t\t++line[i][dummy];\n\t}\n\tdp = new int*[N + 1];\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdp[i] = new int[1 << M];\n\t\tfor (int j = 0; j < (1 << M); ++j) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tfinish = (1 << M) - 1;\n\tcout << search(0, 0) << endl;\n\treturn 0;\n}\nint search(int place, int use) {\n\tif (dp[place][use] != -1)return dp[place][use];\n\tif (use == finish) {\n\t\treturn 0;\n\t\tdp[place][use] = 0;\n\t}\n\tint res = N + 1;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!(use&(1 << i))) {\n\t\t\tres = min(res, search(place + line[N][i + 1], use | (1 << i)) + line[N][i + 1] - (line[place + line[N][i + 1]][i + 1] - line[place][i + 1]));\n\t\t}\n\t}\n\tdp[place][use] = res;\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_M 20\n#define MAX_N 100000\n\nint N,M;\nint cnt[MAX_N+1][MAX_M];\n\nint memo[1<<MAX_M];\nint csum[1<<MAX_M];\n\ninline int cntToy(int toy, int begin, int end){\n\t//printf(\"cntToy(%d,%d,%d)=%d\\n\",toy+1, begin, end,cnt[end][toy] - cnt[begin][toy]);\n\treturn cnt[end][toy] - cnt[begin-1][toy];\n}\n\ninline int cntToyAll(int toy){\n\treturn cnt[N][toy];\n}\n\nint dp(const int bits, const int n){\n\tif(bits == 0) return 0;\n\tif(csum[bits] != 0) return memo[bits];\n\tcsum[bits] = n;\n\tint best = 1<<21;\n\tfor(int toy=0; toy<M; ++toy){\n\t\tconst int toyBit = (1<<toy);\n\t\tif( toyBit & bits ){\n\t\t\tconst int b = bits^toyBit;\n\t\t\tconst int x = dp(b, n - cntToyAll(toy));\n\t\t\tconst int begin = csum[b]+1;\n\t\t\tconst int y = x + (cntToyAll(toy) - cntToy(toy, begin, n));\n\t\t\tbest = min(best,y);\n\t\t}\n\t}\n\t//printf(\"n=%d memo[#%x]=%d\\n\",n, bits, best);\n\treturn memo[bits] = best;\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i=1; i<=N; ++i){\n\t\tfor(int j=0; j<M; ++j){\n\t\t\tcnt[i][j] = cnt[i-1][j];\n\t\t}\n\t\tint t;\n\t\tcin >> t;\n\t\tcnt[i][t-1]++;\n\t}\n\tcout << dp((1<<M)-1, N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n    ll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//???£??\\????????????¨???\n    ll to, cost;\n};\nstruct S {//????????????±?????\\????????????°\n    int from, to, cost;\n};\nstruct H {\n    int x, y;\n};\nll gcm(ll i, ll j) {//??????§???¬??´????°\n    if (i > j) swap(i, j);\n    if (i == 0) return j;\n    return gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n    return sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad??????§??¨???????2???????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nint n, m;\nint a[100000], b[20][100000], c[20];\nint dp[1048576];\nint solve(int s,int sum) {\n    if (s == (1 << m) - 1)\n        return 0;\n    if (dp[s] != -1) return dp[s];\n    int res = inf;\n    for (int i = 0; i < m; i++) {\n        if (!(s&(1 << i))) {\n            int ret = c[i] - b[i][sum + c[i]-1] + (sum != 0 ? b[i][sum-1] : 0);\n            res = min(res, solve(s | (1 << i), sum + c[i]) + ret);\n        }\n    }\n    return dp[s]=res;\n}\nsigned main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        c[--a[i]]++;\n        b[a[i]][i]++;\n        for (int j = 0; j < m; j++)\n            b[j][i + 1] = b[j][i];\n    }\n    for (int i = 0; i < 1048576; i++) \n        dp[i] = -1;\n    cout << solve(0, 0) << endl;\n    getchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> sum(M, vector<int>(N + 1));\n    for (int i = 0; i < N; i++) {\n        int x;\n        cin >> x;\n        sum[--x][i + 1] = 1;\n    }\n\n    for (int i = 0; i < M; i++) {\n        for (int j = 1; j <= N; j++) {\n            sum[i][j] += sum[i][j - 1];\n        }\n    }\n    \n    constexpr int INF = 114514;\n    vector<int> dp(1 << M, INF);    \n    dp[0] = 0;\n    \n    for (int i = 0; i < (1 << M); i++) {\n        int s = 0;\n        for (int j = 0; j < M; j++) {\n            if (i >> j & 1) {\n                s += sum[j][N];\n            }\n        }\n        for (int j = 0; j < M; j++) {\n            if (i >> j & 1) continue;\n            int ni = i | (1 << j);\n            int cost = sum[j][N] - sum[j][s + sum[j][N]] + sum[j][s];\n            dp[ni] = min(dp[ni], dp[i] + cost);\n        }\n    }    \n    cout << dp[(1 << M) - 1] << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[21];\nconst int MA=1<<21;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\trep(k,m)used[k]=0;\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<int>> cnt(N + 1, vector<int>(M));\n\tfor (int i = 0; i < N; i++) {\n\t\tint t;\n\t\tcin >> t; t--;\n\t\tcnt[i + 1] = cnt[i];\n\t\tcnt[i + 1][t]++;\n\t}\n\tvector<int> dp(1 << M, N);\n\tdp[0] = 0;\n\tfor (int i = 0; i < (1 << M); i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tsum += cnt[N][j];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((i & (1 << j)) == 0) {\n\t\t\t\tint dis = cnt[N][j] - (cnt[sum + cnt[N][j]][j] - cnt[sum][j]);\n\t\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + dis);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp.back() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "7 2\n1\n2\n2\n2\n1\n2\n1"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint imos[20][100010];\nint dp[1<<21];\nint main(){\n    int n, m;\n    cin>>n>>m;\n    for(int i=0;i<1<<m;i++)dp[i]=n;\n    dp[0]=0;\n    int sz[20]={};\n    for(int i=1;i<=n;i++){\n        int tmp;\n        cin>>tmp;\n        tmp--;\n        sz[tmp]++;\n        imos[tmp][i] = 1;\n        for(int j=0;j<m;j++)imos[j][i] += imos[j][i-1];\n    }\n    for(int i=0;i<(1<<m);i++){\n        int pos=0;\n        for(int j=0, b=1;j<m;j++, b<<=1)if(i & b)pos+=sz[j];\n        for(int j=0, b=1;j<m;j++, b<<=1){\n            if(i&b)continue;\n            int next = i + b;\n            dp[next] = min(dp[next], dp[i] + sz[j] - ( imos[j][pos+sz[j]] - imos[j][pos] ) );\n        }\n    }\n    cout<<dp[(1<<m)-1]<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[6] = {1, 0, -1, 0,1,1};\nconst int dy[6] = {0, 1, 0, -1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N,M;\n    cin >> N >> M;\n    vector<int> A(N);\n    vector<int> cnt(N,0);\n    vector<vector<int>> S(N+1,vector<int> (M,0));\n    for(int i=0; i<N; i++){\n        cin >> A[i];\n        A[i]--;\n        cnt[A[i]]++;\n        for(int j=0; j<M; j++){\n            S[i+1][j] += S[i][j] + (A[i] == j);\n        }\n    }\n    vector<ll> dp(1LL<<M,inf);\n    dp[0] = 0;\n    for(int bit=0; bit<(1LL<<M); bit++){\n        int sum = 0;\n        for(int i=0; i<M; i++){\n            if(bit & (1LL<<i)) sum += cnt[i];\n        }\n        for(int i=0; i<M; i++){\n            if(bit & (1LL<<i)) continue;\n            int nbit = bit | (1LL<<i);\n            int res = cnt[i] - (S[sum+cnt[i]][i] - S[sum][i]);\n            chmin(dp[nbit],dp[bit]+res);\n        }\n    }\n    // for(int i=0; i<(1LL<<M); i++){\n    //     cout << \"check: \" << i << \" \" << dp[i] << enld;\n    // }\n    cout << dp[(1LL<<M)-1] << enld;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n,m,a[100000],cnt[20] = {},imos[100001][20] = {};\n\tint dp[1 << 20] = {};\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tcnt[a[i]]++;\n\t\tfor(int j = 0;j < m;j++) imos[i + 1][j] = imos[i][j];\n\t\timos[i + 1][a[i]]++;\n\t}\n\tfor(int i = 0;i < (1 << 20);i++){\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1;i < (1 << n);i++){\n\t\tint sum = 0;\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif((i >> j) & 1) sum += cnt[j];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tdp[i] = min(dp[i],dp[i & ~(1 << j)] + cnt[j] - (imos[sum][j] - imos[sum - cnt[j]][j]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\nconst int INF = 200010;\n\nint N, M;\nint a[100010], cnt[25];\nvector<int> pos[100010];\nint toy[1 << 20], dp[1 << 20];\n\nint solve() {\n    queue<int> q; q.push(0);\n    while(!q.empty()) {\n        int bit = q.front(); q.pop();\n        rep(i,0,M) {\n            if(bit >> i & 1) continue;\n            int nbit = bit | (1 << i);\n            int lb = toy[bit], ub = toy[nbit];\n            // printf(\"debug: lb = %d, ub = %d\\n\", lb, ub);\n            int rng = ub - lb;\n\n            int ub2 = lower_bound(pos[i].begin(), pos[i].end(), ub) - pos[i].begin();\n            int lb2 = lower_bound(pos[i].begin(), pos[i].end(), lb) - pos[i].begin();\n            // printf(\"lb = %d, ub = %d\\n\", lb2, ub2);\n            int cnt = ub2 - lb2;\n\n            // printf(\"bit = %d, nbit = %d, rng = %d, cnt = %d\\n\", bit, nbit, rng, cnt);\n\n            if(dp[nbit] > dp[bit] + (rng - cnt)) {\n                dp[nbit] = dp[bit] + (rng - cnt);\n                q.push(nbit);\n            }\n        }\n    }\n    return dp[(1 << M) - 1];\n}\n\nint main() {\n    cin >> N >> M;\n    rep(i,0,1<<M) dp[i] = INF;\n    dp[0] = 0;\n\n    rep(i,0,N) {\n        cin >> a[i]; a[i]--;\n        pos[a[i]].push_back(i);\n        cnt[a[i]]++;\n    }\n    rep(bit,0,1<<M) rep(i,0,M) if(bit >> i & 1) toy[bit] += cnt[i];\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N, M;\n  cin >> N >> M;\n  int a[N];\n  int c[M]{};\n  for (int i = 0; i < N; i++) {\n    cin >> a[i];\n    a[i]--;\n    c[a[i]]++;\n  }\n  // 累積和\n  int b[M][N + 1]{};\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < M; j++) {\n      if (a[i] == j) {\n        b[j][i + 1] = b[j][i] + 1; \n      } else {\n        b[j][i + 1] = b[j][i];\n      }\n    }\n  }\n  // bitDP\n  int n = 1<<M;\n  int dp[n]{};\n  for (int i = 0; i < n; i++) {\n    dp[i] = N;\n  }\n  dp[0] = 0;\n  for (int i = 0; i < n; i++) {\n    // 整列させたぬいぐるみの数\n    int l = 0;\n    for (int j = 0; j < M; j++) {\n      if ((i & (1<<j)) != 0) {\n        l += c[j];\n      }\n    }\n    for (int j = 0; j < M; j++) {\n      int t = (1<<j);\n      if ((i & t) == 0) {\n        int idx = (i | t);\n        // l 以降にぬいぐるみjを置くためのコスト\n        int cost = c[j] - (b[j][l + c[j]] - b[j][l]); \n        dp[idx] = min(dp[idx], dp[i] + cost);\n      }\n    }\n  }\n  cout << dp[n - 1] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nstruct H {\n\tint x, y;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nint n, m;\nint a[100000], b[20][100000], c[20];\nint dp[1048576];\nint solve(int s,int sum) {\n\tif (s == (1 << m) - 1)\n\t\treturn 0;\n\tif (dp[s] != -1) return dp[s];\n\tint res = inf;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!(s&(1 << i))) {\n\t\t\tint ret = c[i] - b[i][sum + c[i]-1] + (sum != 0 ? b[i][sum-1] : 0);\n\t\t\tres = min(res, solve(s | (1 << i), sum + c[i]) + ret);\n\t\t}\n\t}\n\treturn res;\n}\nsigned main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tc[--a[i]]++;\n\t\tb[a[i]][i]++;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tb[j][i + 1] = b[j][i];\n\t}\n\tfor (int i = 0; i < 1048576; i++) \n\t\tdp[i] = -1;\n\tcout << solve(0, 0) << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m;\nint p[100000 + 5];\nint s[100000 + 5][25];\nint cnt[25];\nint dp[1<<21];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) cin >> p[i];\n    rep(i, n) cnt[p[i] - 1] += 1;\n    rep(i, n) s[i + 1][p[i] - 1] += 1;\n    rep(i, n)rep(j, m) s[i + 1][j] += s[i][j];\n    fill(dp, dp + (1<<m) + 1, 1e9);\n    dp[0] = 0;\n    rep(i, 1<<m) {\n        rep(j, m) {\n            if (i>>j & 1) {\n                int l = 0;\n                int r = 0;\n                rep(k, m) {\n                    if (k == j) r = cnt[k];\n                    else if (i>>k & 1) l += cnt[k];\n                }\n                r += l;\n                int change = (r - l) - (s[r][j] - s[l][j]);\n                dp[i] = min(dp[i], dp[i ^ (1<<j)] + change);\n            }\n        }\n    }\n    cout << dp[(1<<m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tvector<int> x(n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &x[i]), x[i]--;\n\tvector<vector<int> > sum(m, vector<int>(n + 1, 0));\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum[i][j + 1] = sum[i][j] + (x[j] == i ? 1 : 0);\n\t\t}\n\t}\n\tvector<int> bsum(1 << m, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tbsum[j] = bsum[j - (1 << i)] + sum[i][n];\n\t\t}\n\t}\n\tvector<int> dp(1 << m, 999999999); dp[0] = 0;\n\tfor (int i = 1; i < 1 << m; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (!(i & (1 << j))) continue;\n\t\t\tdp[i] = min(dp[i], dp[i - (1 << j)] + (bsum[i] - bsum[i - (1 << j)]) - (sum[j][bsum[i]] - sum[j][bsum[i - (1 << j)]]));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << m) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tint n, m, mini, maxm, toy[10000],ans=0;\n\tbool bo;\n\tcin >> n >> m;\n\tmini = 1;\n\tmaxm = m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> toy[i];\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tbo = true;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (toy[j] == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (toy[j] == i && bo) {\n\t\t\t\ttoy[j] = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbo = false;\n\t\t\t}\n\t\t\tif (toy[j] == i) {\n\t\t\t\tans++;\n\t\t\t\ttoy[i] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n, m;\nint dp[1 << 20];\nint cnt[20][101010];\nint nui[101010];\nint sum[20];\nint main() {\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tcin >> nui[i];\n\t\tnui[i]--;\n\t\tfor (int j = 0; j < m; j++)cnt[j][i + 1] = cnt[j][i] + (j == nui[i] ? 1 : 0);\n\t}\n\tREP(i, m)sum[i] = cnt[i][n];\n\tREP(i, (1 << m))dp[i] = HINF;\n\tdp[0] = 0;\n\tREP(i, (1 << m)) {\n\t\tint pos = 0;\n\t\tREP(j, m)if (i&(1 << j))pos += sum[j];\n\t\tREP(j, m) {\n\t\t\tif (i&(1 << j))continue;\n\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + sum[j] - cnt[j][pos + sum[j]] + cnt[j][pos]);\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint a;\nint r[32][101010];\nint cnt[32];\n\nint dp[1 << 20];\n\nint dfs(int c = 0, int s = 0)\n{\n  int &ret = dp[c];\n\n  if (ret != -1) return ret;\n\n  ret = 0;\n\n  for (int i = 0; i < m; i++){\n    if ((c >> i) & 1) continue;\n    ret = max(ret, dfs(c + (1 << i), s + cnt[i]) + (r[i][s + cnt[i]] - r[i][s]));\n  }\n\n  return ret;\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++){\n    cin >> a;\n    a--;\n    cnt[a]++;\n    r[a][i]++;\n  }\n\n  for (int j = 0; j < m; j++){\n    for (int i = 1; i <= n; i++){\n      r[j][i] += r[j][i - 1];\n    }\n  }\n\n  cout << n - dfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint N, M;\nvector<int>memo;\nint dfs(bitset<20>&used,const vector<vector<int>>&sums,const vector<int>&nums,const int now) {\n\tif (memo[used.to_ulong()] != -1)return  memo[used.to_ulong()];\n\tif (used.count() == M)return memo[used.to_ulong()]=0;\n\tint ans = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!used[i]) {\n\t\t\tused[i] = true;\n\t\t\tans = max(ans,sums[i][now + nums[i]] - sums[i][now] + dfs(used, sums, nums, now + nums[i]));\n\t\t\tused[i] = false;\n\t\t}\n\t}\n\treturn memo[used.to_ulong()] = ans;\n}\n\nint main() {\n\tcin >> N >> M;\n\tmemo = vector<int>(1 << M,-1);\n\tvector<int>vs(N);\n\tvector<int>nums(M);\n\tvector<vector<int>>sums(M, vector<int>(N + 1));\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> vs[i]; vs[i]--;\n\t\tnums[vs[i]]++;\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (j == vs[i]) {\n\t\t\t\tsums[j][i + 1] = sums[j][i] + 1;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tsums[j][i + 1] = sums[j][i];\n\t\t\t}\n\t\t}\n\t}\n\tbitset<20>bs;\n\tint ans = dfs(bs, sums, nums,0);\n\tcout << N - ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nint N, M;\nint ans = 1 << 30;\nint C[21][100010];\nint num[21];\nint NU[100010];\n\nint DP[1 << 21][21];\nint ac[1 << 21];\nint main() {\n\tstd::cin >> N >> M;\n\tfor (int i = 1; i <= N; i++) {\n\t\tstd::cin >> NU[i];\n\t\tnum[NU[i]]++;\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tfor (int j = 1; j <= num[i]; j++) {\n\t\t\tif (NU[j] != i)C[i][num[i]]++;\n\t\t}\n\t\tfor (int j = num[i] + 1; j <= N; j++) {\n\t\t\tC[i][j] = C[i][j - 1];\n\t\t\tif (NU[j - num[i]] != i)C[i][j]--;\n\t\t\tif (NU[j] != i)C[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << (M + 1); i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tac[i] += num[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < 1 << (M + 1); i++) {\n\t\tfor (int j = 1; j <= M + 1; j++) {\n\t\t\tDP[i][j] = 1 << 30;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << (M + 1)) - 1; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (!(i >> j & 1))continue;\n\t\t\tDP[i][j] = DP[i^(1<<j)][M+1]+C[j][ac[i]];\n\t\t\tDP[i][M + 1] = std::min(DP[i][M + 1], DP[i][j]);\n\t\t}\n\t}\n\tstd::cout << DP[(1<<(M+1))-2][M + 1] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m;\nint p[100000 + 5];\nint cnt[25];\nint dp[1<<25];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) cin >> p[i];\n    rep(i, n) cnt[p[i]-1] += 1;\n    fill(dp, dp + (1<<m) + 1, 1e9);\n    dp[0] = 0;\n    rep(i, 1<<m) {\n        rep(j, m) {\n            if (i>>j & 1) {\n                int l = 0;\n                int r = 0;\n                rep(k, m) {\n                    if (k == j) r = cnt[k];\n                    else if (i>>k & 1) l += cnt[k];\n                }\n                int change = 0;\n                rep2(k, l, l + r) {\n                    if (p[k] - 1 != j)  change += 1;\n                }\n                dp[i] = min(dp[i], dp[i ^ (1<<j)] + change);\n            }\n        }\n    }\n    cout << dp[(1<<m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m;\nint p[100000 + 5];\nint s[100000 + 5][25];\nint cnt[25];\nint dp[1<<21];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) cin >> p[i];\n    rep(i, n) cnt[p[i] - 1] += 1;\n    rep(i, n) s[i][p[i] - 1] += 1;\n    rep(i, n - 1)rep(j, m) s[i + 1][j] += s[i][j];\n    fill(dp, dp + (1<<m) + 1, 1e9);\n    dp[0] = 0;\n    rep(i, 1<<m) {\n        rep(j, m) {\n            if (i>>j & 1) {\n                int l = 0;\n                int r = 0;\n                rep(k, m) {\n                    if (k == j) r = cnt[k];\n                    else if (i>>k & 1) l += cnt[k];\n                }\n                int change = r-(s[r+l-1][j]-s[max(l-1,0LL)][j]);\n                dp[i] = min(dp[i], dp[i ^ (1<<j)] + change);\n            }\n        }\n    }\n    cout << dp[(1<<m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[20];\nconst int MA=1<<20;\nint sum[21][10001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=1;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\tmemset(used,0,sizeof used);\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[t[k]];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<l<<\" \"<<r<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define INF 9223372036854775807\n#define min hfkjashgkjhsjskdjrsiuguiegiuweu\nll a[100000],sum[21],wa[21][100000],flg[21],min,n,m;\nvoid func(int c,int s,int p){\n//\tcout<<c<<' '<<s<<' '<<p<<endl;\n\tint i,t,d;\n\tif(c==0){\n\t\tif(min>s) min=s;\n\t}\n\telse {\n\t\tfor(i=1;i<=m;i++){\n\t\t\tif(flg[i]!=1){\n\t\t\t\tflg[i]=1;\n//\t\t\t\tcout<<wa[i][p+sum[i]+1]<<' '<<wa[i][p]<<endl;\n\t\t\t\td=sum[i]-(wa[i][p+sum[i]]-wa[i][p]);\n//\t\t\t\tcout<<d<<endl;\n\t\t\t\tfunc(c-1,s+d,p+sum[i]);\n\t\t\t\tflg[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint i,j;\n\tcin>>n>>m;\n\tfor(i=1;i<=m;i++) sum[i]=0;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>a[i]; sum[a[i]]++;\n\t}\n//\tfor(i=1;i<=m;i++) cout<<sum[i]<<endl;\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=0;j<n;j++) wa[i][j]=0;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\twa[i][j]=wa[i][j-1];\n\t\t\tif(a[j]==i) wa[i][j]++;\n\t\t}\n\t}\n/*\tfor(i=1;i<=m;i++){\n\t\tfor(j=0;j<=n;j++) cout<<wa[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\tfor(i=1;i<m;i++) flg[i]=0;\n\tmin=INF;\n\tfunc(m,0,0);\n\tcout<<min<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint r[25][252525], v[25];\nint x[252525];\nint dp[2525252];\nint solve(int r1, int r2, int u) {\n\treturn r[u][r2] - r[u][r1];\n}\nint main() {\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i]; x[i]--; r[x[i]][i]++; v[x[i]]++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 1; j <= 199995; j++)r[i][j] += r[i][j - 1];\n\t}\n\tfor (int i = 0; i < (1 << m); i++)dp[i] = 999999999;\n\tdp[0] = 0;\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tint bit[20]; for (int j = 0; j < m; j++)bit[j] = (i / (1 << j)) % 2;\n\t\tint sum = 0; for (int j = 0; j < m; j++) { if (bit[j] == 1)sum += v[j]; }\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (bit[j] == 1)continue;\n\t\t\tint KOSUU = v[j] - solve(sum, sum + v[j], j);\n\t\t\tdp[i + (1 << j)] = min(dp[i + (1 << j)], dp[i] + KOSUU);\n\t\t}\n\t}\n\tcout << dp[(1 << m) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int(i) = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int(i) = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define pb push_back\n#define MP(a, b) make_pair((a), (b))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nint dp[(1 << 20)];\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> doll(N);\n    rep(i, N) { cin >> doll[i]; }\n    vector<vector<int>> sum(M, vector<int>(N + 1));\n    for(int k = 0; k < M; k++) {\n        for(int i = 0; i < N; i++) {\n            if(doll[i] == k + 1)\n                sum[k][i + 1] = sum[k][i] + 1;\n            else\n                sum[k][i + 1] = sum[k][i];\n        }\n    }\n\n    for(int bit = 0; bit < (1 << M); bit++)\n        dp[bit] = INF;\n    dp[0] = 0;\n    for(int bit = 0; bit < (1 << M); bit++) {\n        int pos = 0;\n        rep(i, M) if(bit & (1 << i)) pos += sum[i][N];\n        for(int i = 0; i < M; i++) {\n            if(bit & (1 << i))\n                continue;\n            dp[bit | (1 << i)] =\n                min(dp[bit | (1 << i)],\n                    dp[bit] +\n                        (sum[i][N] - (sum[i][pos + sum[i][N]] - sum[i][pos])));\n        }\n    }\n    cout << dp[(1 << M) - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,sum,rui;\nint b[21][100000];\nint memo[1<<20];\nint dp(int k,int bit){\n  int ret = INT_MAX;\n\n  if(k == n){\n    //puts(\"\");\n    return 0;\n  }\n  if(memo[bit] != -1) return memo[bit];\n  for(int i=1;i<=m;i++){\n    if( (bit&(1<<i-1)) == 0){\n      sum = n-b[i][n-1];\n      rui = (k == 0)? b[i][k+sum-1]:b[i][k+sum-1]-b[i][k-1];\n      // printf(\"!%d(%d~%d),%d \",i,k,k+sum-1,rui);\n      ret = min(ret,dp(k+sum,bit|(1<<i-1))+rui);\n    }\n  }\n  \n  return memo[bit] = ret;\n}\nint main(){\n  fill(memo,memo+(1<<20),-1);\n  \n  int a;\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&a);\n    for(int j=1;j<=m;j++){\n      if(j != a) b[j][i]++;\n      if(i != 0) b[j][i] += b[j][i-1];\n    }\n  }\n\n  printf(\"%d\\n\",dp(0,0));\n  \n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[20];\nconst int MA=1<<20;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\nstring bitt(int x,int c){\n\tstring a=\"\";\nfor(int i=0;i<c;i++){\n\tif(x&(1<<i))a+=\"1\";\n\telse a+=\"0\";\n}\nreverse(a.begin(),a.end());\nreturn a;\n}\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\tmemset(used,0,sizeof used);\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint A[111111];\nint S[20][111111];\nint cnt[20];\nint dp[1<<20];\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,N)cin>>A[i],A[i]--;\n    rep(i,N){\n        S[A[i]][i+1]++;\n        cnt[A[i]]++;\n    }\n    rep(i,M)rep(j,N)S[i][j+1]+=S[i][j];\n\n    fill_n(dp,1<<20,INT_MAX);\n    dp[0]=0;\n    rep(i,1<<M){\n        int s=0;\n        rep(j,M)if(i>>j&1)s+=cnt[j];\n        rep(j,M){\n            if(i>>j&1)continue;\n            int tmp=S[j][s+cnt[j]]-S[j][s];\n            tmp=cnt[j]-tmp;\n            chmin(dp[i|(1<<j)],dp[i]+tmp);\n        }\n    }\n\n    cout<<dp[(1<<M)-1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint ruisekiwa[100001][20];\nint main() {\n\tmemset(ruisekiwa, 0, sizeof(ruisekiwa));\n\tint a, b;\n\tcin >> a >> b;\n\tint c[20]{};\n\tfor (int d = 0; d < a; d++) {\n\t\tint e;\n\t\tscanf(\"%d\", &e);\n\t\te--;\n\t\tc[e]++;\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\truisekiwa[d + 1][f] = c[f];\n\t\t}\n\t}\n\tunordered_map<int, int>MINCOST;//20 19.......2 1\n\tfor (int i = 1; i <= b; i++) {\n\t\tfor (int bit = 0; bit < (1 << b); bit++) {\n\t\t\tint sum = 0, r = 0;;\n\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tr += ruisekiwa[a][g];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == i) {\n\t\t\t\tint MIN = 1 << 29;\n\t\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\t\tint copy = 1 << g;\n\t\t\t\t\t\tbit -= copy;\n\t\t\t\t\t\tMIN = min(MIN, MINCOST[bit] + ruisekiwa[a][g] - (ruisekiwa[r][g] - ruisekiwa[r - ruisekiwa[a][g]][g]));\n\t\t\t\t\t\tbit += copy;\n\t\t\t\t\t}\n\t\t\t\t\tMINCOST[bit] = MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << MINCOST[(1 << b) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n,k,a[100009],dp[1<<20],rui[100009][20],cnt[20],sum[1<<20];\n\nint main(){\n  cin>>n>>k;\n  r(i,n){\n    cin>>a[i]; a[i]--;\n    cnt[a[i]]++;\n    rui[i][a[i]]++;\n  }\n  r(i,n-1){\n    r(j,k) rui[i+1][j]+=rui[i][j];\n  }\n  r(i,1<<20)dp[i]=1e9;\n  r(i,1<<20){\n    r(j,20){\n      if(i&(1<<j))sum[i]+=cnt[j];\n    }\n  }\n  dp[0]=0;\n  for(int i=0;i<(1<<k);i++){\n    for(int j=0;j<k;j++){\n      if(i&(1<<j))continue;\n      dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+cnt[j]-(rui[sum[i|(1<<j)]-1][j]- (i==0?0:rui[sum[i]-1][j]) ));\n    }\n  }\n  cout<<dp[(1<<k)-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nint N, M;\nint ans = 1 << 30;\nint C[21][100010];\nint num[21];\nint NU[100010];\n\nvoid dfs(int s,int cost,int sx) {  \n\tif (s == (1 << (M + 1)) - 2) {\n\t\tans = std::min(ans, cost);\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (!(s >> i & 1)) {\n\t\t\tdfs(s | 1 << i, cost+ C[i][sx + num[i]], sx + num[i]);\n\t\t}\n\t}\n}\n\n\nint main() {\n\tstd::cin >> N >> M;\n\tfor (int i = 1; i <= N; i++) {\n\t\tstd::cin >> NU[i];\n\t\tnum[NU[i]]++;\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tfor (int j = 1; j <= num[i]; j++) {\n\t\t\tif (NU[j] != i)C[i][num[i]]++;\n\t\t}\n\t\tfor (int j = num[i] + 1; j <= N; j++) {\n\t\t\tC[i][j] = C[i][j - 1];\n\t\t\tif (NU[j - num[i]] != i)C[i][j]--;\n\t\t\tif (NU[j] != i)C[i][j]++;\n\t\t}\n\t}\n\tdfs(0, 0, 0);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint dp[1<<21];\nint sum[20][100001];\nint a[100001];\nint main(){\n    int n,m;\n    cin>>n>>m;\n    rep(i,n) cin>>a[i];\n    rep(i,m)rep(j,n){\n        sum[i][j+1]=sum[i][j]+(a[j]-1==i);\n    }\n    rep(i,1<<m) dp[i]=1000100010;\n    dp[0]=0;\n    rep(i,(1<<m)){\n        int cnt=0;\n        rep(j,m){\n            if(i>>j&1) cnt+=sum[j][n];\n        }\n        rep(j,m){\n            if(i>>j&1) continue;\n            else{\n                dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+sum[j][n]-(sum[j][sum[j][n]+cnt]-sum[j][cnt]));\n            }\n        }\n    }\n    cout<<dp[(1<<m)-1]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> acc(m, vector<int>(n + 1, 0));\n    vector<int> cnt(m, 0);\n    for (int i = 1; i <= n; i++) {\n        int k; cin >> k; k--;\n        acc[k][i] = 1;\n        cnt[k]++;\n    }\n    for (int k = 0; k < m; k++) {\n        for (int i = 1; i <= n; i++) {\n            acc[k][i] += acc[k][i - 1];\n        }\n    }\n    vector<int> dp(1 << m, INF);\n    dp[0] = 0;\n    for (int b = 0; b < 1 << m; b++) {\n        int pos = 0;\n        for (int k = 0; k < m; k++) if (b & (1 << k)) pos += cnt[k];\n        for (int k = 0; k < m; k++) if (!(b >> k & 1)) {\n            int cost = cnt[k] - (acc[k][pos + cnt[k]] - acc[k][pos]);\n            chmin(dp[b | 1 << k], dp[b] + cost);\n        }\n    }\n    cout << dp[(1 << m) - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Plush Toys\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <climits>\n\nusing namespace std;\n\nint A[100000], B[21] = {};\nint N, M;\n\nint main() {\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        B[A[i]]++;\n    }\n\n    bool aranged[M + 1];\n    for(int i = 1; i < M + 1; i++) aranged[i] = false;\n\n    int total_cost = 0;\n\n    int index = 0;\n    for(int i = 0; i < M; i++) {\n        int min_cost = INT_MAX, num;\n        for(int j = 1; j < M + 1; j++) {\n            if(aranged[j]) continue;\n            int cost = 0;\n            for(int k = 0; k < B[j]; k++) {\n                if(A[index + k] != j) cost++;\n            }\n            if(min_cost > cost) {\n                min_cost = cost;\n                num = j;\n            }\n        }\n        total_cost += min_cost;\n        aranged[num] = true;\n        index += B[num];\n    }\n\n    cout << total_cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int N, M;\n  cin >> N >> M;\n  int T[N], C[N+1][M];\n  for(int i = 0; i <= N; ++i) fill(C[i],C[i]+M,0);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j) C[i+1][j] = C[i][j];\n    cin >> T[i];\n    --T[i];\n    ++C[i+1][T[i]];\n  }\n  /*\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < M; ++j) cout << C[i][j];\n    cout << endl;\n  }\n  */\n  int dp[1<<M], INF = 1000000000;\n  fill(dp,dp+(1<<M),INF);\n  dp[0] = 0;\n  for(int i = 0; i < (1<<M); ++i){\n    int t = 0;\n    for(int j = 0; j < M; ++j){\n      if((i>>j) & 1) t += C[N][j];\n    }\n    for(int j = 0; j < M; ++j){\n      if(!((i>>j) & 1)){\n        int c = C[N][j], s = dp[i] + c;\n        s -= C[t+c][j];\n        //if(t > 0) s += C[t-1][j];\n        s += C[t][j];\n        //cout << i << \" \" << j << \" \" << t << \" \" << c << endl;\n        dp[(i | (1<<j))] = min(dp[(i | (1<<j))], s);\n      }\n    }\n  }\n  //for(int i = 0; i < (1<<M); ++i) cout << dp[i] << \" \";\n  //cout << endl;\n  cout << dp[(1<<M)-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1001001001\nusing namespace std;\n\nint num[21],dp[1<<20],rui[100010][21];\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\tint tmp;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>tmp;\n\t\trui[i][tmp-1]++;\n\t\tnum[tmp-1]++;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\trui[i][j]+=rui[i-1][j];\n\t\t}\n\t}\n\n\tfill(dp,dp+(1<<M),INF);\n\tdp[0]=0;\n\tint cnt;\n\tfor(int i=0;i<(1<<M);i++){\n\t\tcnt=0;\n\t\tfor(int j=0;j<M;j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tcnt+=num[j];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<M;j++){\n\t\t\tif(!(i&(1<<j))){\n\t\t\t\tint hog=(i|(1<<j));\n\t\t\t\tdp[hog]=min(dp[hog],dp[i]+num[j]-(rui[cnt+num[j]][j]-rui[cnt][j]));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[(1<<M)-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint n, m, kmax = 0;\nint a[100000], b[20][100000];\n\nint main()\n{\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i > 0)\n\t\t\t\tb[i][j] = b[i - 1][j];\n\t\t\telse\n\t\t\t\tb[i][j] = 0;\n\t\t}\n\t\tb[i][a[i] - 1]++;\n\t}\n\n\tvector<int> p(m);\n\tiota(p.begin(), p.end(), 1);\n\n\tdo {\n\t\tint t = 0, k = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s = b[n - 1][p[i] - 1];\n\t\t\tif (t > 0)\n\t\t\t\tk += b[s + t - 1][p[i] - 1] - b[t - 1][p[i] - 1];\n\t\t\telse\n\t\t\t\tk = b[s + t - 1][p[i] - 1];\n\t\t\tt += s;\n\t\t}\n\t\tif (kmax < k)\n\t\t\tkmax = k;\n\t} while (next_permutation(p.begin(), p.end()));\n\n\tcout << n - kmax << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[100001];\nconst int MA=1<<21;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\trep(k,m)used[k]=0;\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint a[100000];\nint ct[20]={};\nint s[20][100001]={};\n\nint dp[1<<20];\n\nint main()\n{\n    int n,m;\n    cin >>n >>m;\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n        ++ct[a[i]];\n    }\n\n    rep(i,m)rep(j,n) s[i][j+1] = s[i][j]+(a[j]==i);\n    \n    fill(dp,dp+(1<<20),n);\n    dp[0]=0;\n    rep(i,1<<m)\n    {\n        int st=0;\n        rep(j,m)if(i>>j&1) st+=ct[j];\n\n        rep(j,m)if(!(i>>j&1))\n        {\n            int num = s[j][st+ct[j]] - s[j][st];\n            int nx = i|(1<<j);\n            dp[nx] = min(dp[nx],dp[i]+(ct[j]-num));\n        }\n    }\n\n    cout << dp[(1<<m)-1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int a[n],s[m][n+1],t=1<<m,inf=1<<25;\n  for(int i=0;i<m;i++) s[i][0]=0;\n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    for(int j=0;j<m;j++){\n      s[j][i+1]=s[j][i]+(a[i]-1==j);\n    }\n  }\n  int dp[1<<20];\n  for(int i=0;i<t;i++) dp[i]=inf;\n  dp[0]=0;\n  for(int i=0;i<t;i++){\n    for(int j=0;j<m;j++){\n      if((i>>j)&1) continue;\n      int p=0;\n      for(int k=0;k<m;k++) if((i>>k)&1) p+=s[k][n];\n      dp[i+(1<<j)]=min(dp[i+(1<<j)],dp[i]+s[j][n]-(s[j][p+s[j][n]]-s[j][p]));\n    }\n  }\n  cout<<dp[t-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[1<<20][2];\nint list[100001][20];\nint n,m,r,w;\nint find(int a,int b,int t){\n\t//a~b?????????t??§???????????°????????°?????????\n\treturn b-a-(list[b][t]-list[a][t]);\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)list[0][i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>r;\n\t\tfor(int j=0;j<m;j++)list[i+1][j]=list[i][j];\n\t\tlist[i+1][r-1]++;\n\t}\n\tw=1;\n\tfor(int i=0;i<m;i++)w*=2;\n\tfor(int i=0;i<w;i++)dp[i][0]=1145141919;\n\tdp[0][0]=0,dp[0][1]=0;\n\n\tfor(int i=0;i<w;i++){\n\t\tbool will[20]={false};//????????§???????????????\n\t\tint e=1;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i%(e*2)<e)will[j]=true;\n\t\t\te*=2;\n\t\t}\n\n\t\te=1;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(will[j]){\n\t\t\t\tdp[i+e][1]=dp[i][1]+list[n][j];\n\t\t\t\tdp[i+e][0]=min(dp[i+e][0],dp[i][0]+find(dp[i][1],dp[i+e][1],j));\n\t\t\t}\n\t\t\te*=2;\n\t\t}\n\t}\n\tcout<<dp[w-1][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nint N, M;\nint P[112345];\nint c[23][112345];\nint n[23];\n\nint count(int p, int s, int e) {\n\treturn c[p][e - 1] - ((s == 0) ? 0 : c[p][s - 1]);\n}\n\nint memo[1 << 21];\n\nint dp(int i, int j, int b) {\n\tif (memo[i] != -1) return memo[i];\n\tif (b == 1) return memo[i] = count(log2(i), 0, j);\n\tint a = 0;\n\trep(p, M) {\n\t\tif (i & 1 << p) a = max(a, dp(i ^ (1 << p), j - n[p], b - 1) + count(p, j - n[p], j));\n\t}\n\treturn memo[i] = a;\n}\n\nint main() {\n\n\tmemset(memo, 0xFF, sizeof(memo));\n\n\tscanf(\"%d %d\", &N, &M);\n\n\trep(i, M) n[i] = 0;\n\n\trep(i, N) {\n\t\tscanf(\"%d\", &P[i]);\n\t\tn[P[i] - 1]++;\n\t}\n\n\trep(i, M) {\n\t\tint t = 0;\n\t\trep(j, N) {\n\t\t\tif (P[j] == i + 1) t++;\n\t\t\tc[i][j] = t;\n\t\t\tc[i][j + 1] = t;\n\t\t}\n\t}\n\tprintf(\"%d\", N - dp((1 << M) - 1, N, M));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<int>v(N + 1);\n\tvector<vector<int>>sum(M + 1, vector<int>(N + 1));\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> v[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum[v[i]][i]++;\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tsum[j][i] += sum[j][i - 1];\n\t\t}\n\t}\n\tvector<int>dp(1 << M, MOD);\n\tdp[0] = 0;\n\tfor (int i = 0; i < 1 << M; i++) {\n\t\tint used = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tused += sum[j + 1][N];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((i >> j) & 1)continue;\n\t\t\tdp[i + (1 << j)] = min(dp[i + (1 << j)], dp[i] + sum[j + 1][N] - (sum[j + 1][used + sum[j + 1][N]] - sum[j + 1][used]));\n\t\t}\n\t}\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2147483647\n#define INF_LL 9223372036854775807\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<int> > toys(M,vector<int>(N+1,0));\n\tfor (int i = 0; i < N; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == tmp-1) {\n\t\t\t\ttoys[j][i + 1] += toys[j][i] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttoys[j][i + 1] += toys[j][i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> dp(1 << M, INF / 2); //集合Sを敷き詰めたときの動かすぬいぐるみ\n\tvector<int> top(1 << M, 0); //集合Sを敷き詰めたとき、次に動かす最初のぬいぐるみの位置\n\tdp[0] = 0;\n\tfor (int i = 0; i < (1 << M); i++) {\n\t\tfor (int j = 0; j < M; j++) { //次におくぬいぐるみ\n\t\t\tif (i & (1 << j)) continue; //既に置いてたらcontinue\n\t\t\tif (dp[i] + toys[j][N] - (toys[j][top[i] + toys[j][N]] - toys[j][top[i]]) < dp[i + (1 << j)]) {\n\t\t\t\tdp[i + (1 << j)] = dp[i] + toys[j][N] - (toys[j][top[i] + toys[j][N]] - toys[j][top[i]]);\n\t\t\t\ttop[i + (1 << j)] = top[i] + toys[j][N];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define INF 9223372036854775807\n#define min hfkjashgkjhsjskdjrsiuguiegiuweu\nll a[100000],sum[21],wa[21][100000],flg[21],min,n,m;\nvoid func(int c,int s,int p){\n\tint i,t,d;\n\tif(c==0){\n\t\tif(min>s) min=s;\n\t}\n\telse {\n\t\tfor(i=1;i<=m;i++){\n\t\t\tif(flg[i]!=1){\n\t\t\t\tflg[i]=1;\n\t\t\t\td=wa[i][p+sum[i]]-wa[i][p];\n\t\t\t\tfunc(c-1,s+d,p+sum[i]);\n\t\t\t\tflg[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\t\nint main(void){\n\tint i,j;\n\tcin>>n>>m;\n\tfor(i=1;i<=m;i++) sum[i]=0;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a[i]; sum[a[i]]++;\n\t}\t\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=0;j<n;j++) wa[i][j]=0;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(j!=0) wa[i][j]=wa[i][j-1];\n\t\t\tif(a[j]==i) wa[i][j]++;\n\t\t}\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=0;j<n;j++) cout<<wa[i][j]<<' ';\n\t\tcout<<endl;\n\t}\n\tfor(i=1;i<m;i++) flg[i]=0;\n\tmin=INF;\n\tfunc(m,0,0);\n\tcout<<min<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[20];\nconst int MA=1<<20;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\nstring bitt(int x,int c){\n\tstring a=\"\";\nfor(int i=0;i<c;i++){\n\tif(x&(1<<i))a+=\"1\";\n\telse a+=\"0\";\n}\nreverse(a.begin(),a.end());\nreturn a;\n}\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\tmemset(used,0,sizeof used);\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100002;\nconst int MAX_M = 20;\n\nint sm[MAX_M][MAX_N];\nint cnt[MAX_M];\nint dp[1<<MAX_M];\nint num[1<<MAX_M];\nint n,m;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint a;\n\tfor(int i=1;i<n+1;i++){\n\t\tscanf(\"%d\",&a);\n\t\tcnt[a-1]++;\n\t\trep(j,m){\n\t\t\tif(j==a-1){\n\t\t\t\tsm[j][i] = sm[j][i-1] + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsm[j][i] = sm[j][i-1];\n\t\t}\n\t}\n\trep(i,1<<m){\n\t\tdp[i] = INF;\n\t}\n\trep(i,1<<m){\n\t\trep(j,m){\n\t\t\tif(i & (1<<j)){\n\t\t\t\tnum[i] += cnt[j];\n\t\t\t}\n\t\t}\n\t}\n\tdp[0] = 0;\n\tfor(int i=1;i<(1<<m);i++){\n\t\trep(j,m){\n\t\t\tif(i & (1<<j)){\n\t\t\t\tdp[i] = min(dp[i],dp[i-(1<<j)]+cnt[j]-(sm[j][num[i]]-sm[j][num[i-(1<<j)]]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[(1<<m)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\tb += MOD;\n\ta += b;\n\ta %= MOD;\n}\n\nint dp[1111111],d[22][111111];\n\nint main(void){\n\tint n,m,i,j,a,p;\n\tcin >> n >> m;\n\tfill(d[0],d[22],0);\n\tfill(dp,dp+1111111,INF);\n\tfor(i=0; i<n; ++i){\n\t\tcin >> a; --a;\n\t\t++d[a][i+1];\n\t\tfor(j=0; j<m; ++j){\n\t\t\td[j][i+1] += d[j][i];\n\t\t}\n\t}\n\tdp[0] = 0;\n\tfor(i=0; i<(1<<m); ++i){\n\t\tp = 0;\n\t\tfor(j=0; j<m; ++j){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tp += d[j][n];\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<m; ++j){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta = d[j][n];\n\t\t\tdp[i+(1<<j)] = min(dp[i+(1<<j)],dp[i]+d[j][n]-(d[j][a+p]-d[j][p]));\n\t\t}\n\t}\n\tcout << dp[(1<<m)-1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#define DEBUG for(int k=0;k<n;k++){printf(\"%3d \",toy[k]);}cout<<ans<<endl;\nusing namespace std;\nvoid check();\nint n, m, mini, maxm, toy[10000], ans = 0;\n\tbool bo, bo1;\nint main() {\n\t\n\tcin >> n >> m;\n\tmini = 1;\n\tmaxm = m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> toy[i];\n\t}\n\tcheck();\n\t\t\n\tfor (int i = 1; i <= m; i++) {\n\t\t\n\t\t//DEBUG;\n\t\tbo = true;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (toy[j] == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (toy[j] == i && bo) {\n\t\t\t\ttoy[j] = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbo = false;\n\t\t\t}\n\t\t\tif (toy[j] == i) {\n\t\t\t\tans++;\n\t\t\t\ttoy[j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\t//DEBUG;\n\tcout << ans << endl;\n\treturn 0;\n}\nvoid check(){\n\tfor (int l = n - 1; l >= 0; l--) {\n\t\tif (toy[l] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (toy[l] == maxm) {\n\t\t\ttoy[l] = -1;\n\t\t}\n\t\telse if (toy[l] == maxm - 1 && l!=n-1) {\n\t\t\tmaxm--;\n\t\t\ttoy[l] = -1;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint N, M;\nint dp[1 << 20];\nint ruisekiwa[100001][20];\nint in[100000];\nint kindtonum[20];\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t\tkindtonum[in[i] - 1]++;\n\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (in[i - 1] - 1 == j)ruisekiwa[i][j]++;\n\t\t\truisekiwa[i][j] += ruisekiwa[i - 1][j];\n\n\t\t}\n\n\t}\n\tfor (int i = 1; i < (1 << M); i++) dp[i] = 1000000007;\n\tfor (int i = 0; i < (1 << M); i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i & (1 << j))continue;\n\n\t\t\tint cost = 0;\n\t\t\tint totalnum = 0;\n\t\t\tfor (int k = 0; k < M; k++)if (i & (1 << k))totalnum += kindtonum[k];\n\n\t\t\t//cout << i << \" \" << j << \" \" << totalnum << endl;\n\n\t\t\tfor (int k = 0; k < M; k++)if (k != j)cost +=\n\t\t\t\t(ruisekiwa[totalnum + kindtonum[j]][k] - ruisekiwa[totalnum][k]);\n\n\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost);\n\n\t\t}\n\n\t}\n\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//Plush Toys\n#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    int A[N + 1], cumsum[M][N + 1];\n    for(int i = 0; i < M; i++) {\n        for(int j = 0; j < N + 1; j++) {\n            cumsum[i][j] = 0;\n        }\n    }\n\n    for (int i = 1; i < N + 1; i++) {\n        cin >> A[i];\n        A[i]--;\n        cumsum[A[i]][i]++;\n    }\n\n    for(int i = 0; i < M; i++) {\n        for(int j = 1; j < N + 1; j++) {\n            cumsum[i][j] += cumsum[i][j - 1];\n        }\n    }\n\n    int dp[1 << M];\n    for(int i = 0; i < (1 << M); i++) dp[i] = INT_MAX;\n    dp[0] = 0;\n    for(int s = 0; s < (1 << M); s++) {\n        int p = 0;\n        for(int i = 0; i < M; i++) {\n            if(s & 1 << i) p += cumsum[i][N];\n        }\n        for(int i = 0; i < M; i++) {\n            if(s & 1 << i) continue;\n            int cost = dp[s] + (cumsum[i][N] - cumsum[i][p + cumsum[i][N]] + cumsum[i][p]);\n            dp[s + (1 << i)] = min(dp[s + (1 << i)], cost);\n        }\n    }\n\n    cout << dp[(1 << M) - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int MAX_M = 20;\n\nint N, M;\nint K[MAX_N];\nint sum[MAX_M][MAX_N + 1];\nint dp[1 << MAX_M];\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i++) cin >> K[i];\n\tfill(sum[0], sum[M], 0);\n\tfor(int i = 0; i < N; i++) sum[K[i] - 1][i + 1]++;\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tsum[i][j] += sum[i][j - 1];\n\t\t}\n\t}\n\tfill(dp, dp + (1 << M), 0);\n\tfor(int i = 1; i < (1 << M); i++){\n\t\tint minimum_num = MAX_N + 1;\n\t\tfor(int j = 0; j < M; j++){\n\t\t\tif(!(i & (1 << j))) continue;\n\t\t\tint replaced_doll_num = 0;\n\t\t\tfor(int k = 0; k < M; k++){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tif(i & (1 << k)) replaced_doll_num += sum[k][N];\n\t\t\t}\n\t\t\tminimum_num = min(minimum_num, dp[i - (1 << j)] + sum[j][N] - (sum[j][replaced_doll_num + sum[j][N]] - sum[j][replaced_doll_num]));\n\t\t}\n\t\tdp[i] = minimum_num;\n\t}\n\tcout << dp[(1 << M) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> v(n);\n    rep(i,n)cin>>v[i];\n    rep(i,n)v[i]--;\n    \n    static vector<vector<int>> r(m,vector<int>(n+1,0));\n    vector<int> num(20,0);\n    rep(i,v.size()){\n        num[v[i]]++;\n        r[v[i]][i+1] = 1;\n    }\n    rep(i,m){\n        rep(j,n){\n            r[i][j+1] += r[i][j];\n        }\n    }\n    \n    static int dp[1<<20];\n    static int len[1<<20];\n    rep(i,1<<20)dp[i] = INF;\n    rep(i,1<<20)len[i] = INF;\n    dp[0] = 0;\n    len[0] = 0;\n    \n    rep(bit,1<<m){\n        rep(piv,m){\n            if( (bit&(1<<piv))==0 ){\n                int left = len[bit], right = left + num[piv];\n                \n                int add = 0;\n                rep(i,m){\n                    if( ((bit|1<<piv) & 1<<i)==0 ){\n                        add += r[i][right] - r[i][left];\n                    }\n                }\n                add += num[piv] - r[piv][len[bit]+num[piv]];\n                \n                dp[bit|(1<<piv)] = min(dp[bit|(1<<piv)], dp[bit] + add);\n                len[bit|(1<<piv)] = len[bit] + num[piv];\n            }\n        }\n    }\n    cout<<dp[(1<<m)-1]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, sum[1000000][20],ssum[1<<20], last, cnt, ans, a[1000000], dp[1 << 20] = {};\nint dd[4][2] = { {1,0},{0,1},{ -1,0 },{ 0,-1 } };\nstring str,ss;\nstruct Edge { LL to; };\nvector<Pll>vec[1000][1000];\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nint main() {\n\tcin >> n >> m;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\trep(j, 20) {\n\t\t\tsum[i + 1][j] = sum[i][j];\n\t\t\tif (a[i]-1 == j)sum[i + 1][j]++;\n\t\t}\n\t}\n\trep(i, 1 << m) {\n\t\tdp[i] = INF/2;\n\t\trep(j, m)\n\t\t\tif (i & 1 << j)\n\t\t\t\tssum[i] += sum[n][j];\n\t}\n\tdp[0] = 0;\n\trep(i, 1 << m) {\n\t\trep(j, m) {\n\t\t\tif (!(i&(1 << j))) {\n\t\t\t\tdp[i + (1 << j)] = min(dp[i] + sum[n][j] - (sum[ssum[i + (1 << j)]][j] - sum[ssum[i]][j]), dp[i + (1 << j)]);\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << dp[(1 << m)-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint main(){\n\n\tint POW[21];\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\n\tint* table = new int[N];\n\tint num[M];\n\tfor(int i = 0; i < M; i++)num[i] = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\ttable[i]--;\n\t\tnum[table[i]]++;\n\t}\n\n\tint* dp = new int[POW[M]];\n\n\tfor(int i = 0; i < POW[M]; i++)dp[i] = BIG_NUM;\n\n\tdp[0] = 0;\n\n\tint next_start_pos,next_state;\n\tstack<int> S;\n\n\tfor(int state = 0; state < POW[M]; state++){\n\n\t\tnext_start_pos = 0;\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tnext_start_pos += num[loop];\n\t\t\t}else{\n\t\t\t\tS.push(loop);\n\t\t\t}\n\t\t}\n\n\t\twhile(!S.empty()){\n\t\t\tnext_state = state+POW[S.top()];\n\n\t\t\tint tmp = num[S.top()];\n\t\t\tfor(int i = 0; i < num[S.top()]; i++){\n\t\t\t\tif(table[next_start_pos+i] == S.top()){\n\t\t\t\t\ttmp--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[next_state] = min(dp[next_state],dp[state]+tmp);\n\n\t\t\tS.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[POW[M]-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2676345#1\n#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\nint n,m;\nint t[21];\nconst int MA=1<<21;\nint sum[21][100001];//累積和\nint cntu[21];//各種類が何個使われているか\n\nint dp[MA];//attention!\n\nconst int INF=1000000007;\n\n\nint main(){\ncin>>n>>m;\nrep(i,n){\ncin>>t[i];\ncntu[t[i]]++;\n}\nfor(int i=1;i<=m;i++){\n\tfor(int j=0;j<n;j++){\n\t\tif(t[j]==i)sum[i][j+1]=1;\n\t}\n\tfor(int j=2;j<=n;j++)sum[i][j]+=sum[i][j-1];\n\t//for(int j=0;j<=n;j++)cout<<sum[i][j]<<\" \";cout<<endl;\n}\n\n\nrep(i,MA)dp[i]=INF;\ndp[0]=0;\n\nbool used[20];\nint cnt,ruikei;\n\nfor(int i=0;i<m;i++){\n\tfor(int j=0;j<(1<<m);j++){//0から2^m-1まで回す\n\t\t\tcnt=0;\n\t\t\truikei=0;\n\t\t\trep(k,m)used[k]=0;\n\n\t\t\trep(k,m){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[k]=1;\n\t\t\t\t\truikei+=cntu[k+1];\n\t\t\t\t}\n\t\t\t}//ここまでで、jのbitを把握\n\t\t\tif(cnt!=i)continue;\n\t\t\t\n\t\t\trep(k,m){\n\t\t\t\tif(used[k]==0){\n\t\t\t\t\tint next=j+(1<<k);\n\t\t\t\t\tint add;\n\t\t\t\t\tint l=ruikei;\n\t\t\t\t\tint r=ruikei+cntu[k+1];\n\t\t\t\t\tadd=cntu[k+1]-(sum[k+1][r]-sum[k+1][l]);\n\t\t\t\t\t//cout<<j<<\" \"<<next<<\" \"<<add<<endl;\n\t\t\t\t\tdp[next]=min(dp[next],dp[j]+add);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t}\n}\ncout<\"WA\";\n\n//for(int i=0;i<(1<<m);i++)cout<<i<<\" \"<<dp[i]<<endl;\ncout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint ruisekiwa[100001][20];\nint main() {\n\tmemset(ruisekiwa, 0, sizeof(ruisekiwa));\n\tint a, b;\n\tcin >> a >> b;\n\tint c[20]{};\n\tfor (int d = 0; d < a; d++) {\n\t\tint e;\n\t\tscanf(\"%d\", &e);\n\t\te--;\n\t\tc[e]++;\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\truisekiwa[d + 1][f] = c[f];\n\t\t}\n\t}\n\tunordered_map<int, int>MINCOST;//20 19.......2 1\n\tfor (int i = 1; i <= b; i++) {\n\t\tfor (int bit = 0; bit < (1 << b); bit++) {\n\t\t\tint sum = 0, r = 0;;\n\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tr += ruisekiwa[a][g];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == i) {\n\t\t\t\tint MIN = 1 << 29;\n\t\t\t\tfor (int g = 0; g < 22; g++) {\n\t\t\t\t\tif (bit >> g & 1) {\n\t\t\t\t\t\tint copy = 1 << g;\n\t\t\t\t\t\tbit -= copy;\n\t\t\t\t\t\tMIN = min(MIN, MINCOST[bit] + ruisekiwa[a][g] - (ruisekiwa[r][g] - ruisekiwa[r - ruisekiwa[a][g]][g]));\n\t\t\t\t\t\tbit += copy;\n\t\t\t\t\t}\n\t\t\t\t\tMINCOST[bit] = MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << b); i++) {\n\t\tcout << i << \" \" << MINCOST[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000000;\n\nint n, m, a[100001], c1[20], c2[20][100001];\nint bit[1<<20], len[1<<20];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < m; i++) c1[i] = 0;\n  for (int i = 0; i < m; i++) c2[i][0] = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n    c1[a[i]]++;\n    for (int j = 0; j < m; j++) c2[j][i] = c2[j][i - 1];\n    c2[a[i]][i]++;\n  }\n  for (int i = 0; i <= (1 << m) - 1; i++) bit[i] = INF;\n  bit[0] = 0, len[0] = 0;\n  for (int i = 0; i <= (1 << m) - 1; i++) {\n    for (int j = 0; j < m; j++) {\n      if (i & (1 << j)) continue;\n      int newi = i + (1 << j);\n      len[newi] = len[i] + c1[j];\n      int temp = c1[j] - (c2[j][len[newi]] - c2[j][len[i]]);\n      bit[newi] = min(bit[newi], bit[i] + temp);\n    }\n  }\n  printf(\"%d\\n\", bit[(1 << m) - 1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define INF 1145141919\n\nint N, M;\nint S[20][200000];\nint C[20];\nint dp[1<<20];\n\nint main() {\n  cin >> N >> M;\n  for (int i=0; i<N; i++) {\n    int s; cin >> s;\n    s--;\n    S[s][i]++;\n    C[s]++;\n  }\n  for (int i=0; i<M; i++) {\n    for (int j=1; j<N; j++) S[i][j] += S[i][j-1];\n  }\n\n  for (int i=0; i<(1<<M); i++) dp[i] = INF;\n  dp[0] = 0;\n  for (int i=0; i<(1<<M); i++) {\n    int t = 0;\n    for (int j=0; j<M; j++) if (i & (1<<j)) t += C[j];\n    for (int j=0; j<M; j++) {\n      if (i & (1<<j)) continue;\n      int s = C[j] - (S[j][t+C[j]-1] - S[j][t-1]);\n      dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + s);\n    }\n  }\n  cout << dp[(1<<M)-1] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//q4.cpp\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint sum[20][SIZE] = {};\nint cc[20] = {};\nint dp[1 << 20];\n\nint main(){\n  int n,m;\n  int a;\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",&a);\n    a--;\n    sum[a][i]++;\n    cc[a]++;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++)\n      sum[j][i+1] += sum[j][i];\n  }\n\n  for(int i=0;i<(1<<m);i++){\n    dp[i] = -INF;\n  }\n  dp[0] = 0;\n  \n  for(int i=0;i<(1<<m);i++){\n    int l = 0,r;\n\n    for(int j=0;j<m;j++){\n      if((i>>j) & 1) l += cc[j];\n    }\n\n    for(int j=0;j<m;j++){\n      if((i>>j) & 1) continue;\n\n      r = l + cc[j];\n      \n      int add = sum[j][r] - sum[j][l];\n\n      dp[(1 << j)+i] = max(dp[(1<<j)+i], dp[i]+add);\n    }\n  }\n\n  printf(\"%d\\n\",n - dp[(1<<m)-1]);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<int> num(M);\n    vector<vector<int>> sum(N + 1, vector<int>(M));\n    for(int i = 0; i < N; ++i) {\n        int a; cin >> a;\n        sum[i + 1][a - 1]++;\n        num[a - 1]++;\n        for(int j = 0; j < M; ++j) {\n            sum[i + 1][j] += sum[i][j];\n        }\n    }\n\n    vector<int> dp(1 << M, INF);\n    dp[0] = 0;\n    vector<int> len(1 << M);\n    for(int S = 0; S < (1 << M); ++S) {\n        for(int i = 0; i < M; ++i) {\n            if(S & (1 << i)) {\n                continue;\n            }\n            int l = len[S], r = len[S] + num[i];\n            dp[S | (1 << i)] = min(dp[S | (1 << i)], dp[S] + (r - l) - (sum[r][i] - sum[l][i]));\n            len[S | (1 << i)] = r;\n        }\n    }\n\n    cout << dp.back() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[1<<20];\nint rsk[21][100002]={0};\nint main(void){\n\tint n,m;\n\tint i,j,k;\n\tint box[100000];\n\tint kind[21]={0};\n\tint now,now_kazu;\n\tint next,next_kazu;\n\tint cost,cost_before;\n\tint cnt;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tcin>>box[i];\n\t\tkind[box[i]-1]++;\n\t\trsk[box[i]-1][i+1]++;\n\t}\n\t// for(i=0;i<m;i++)\tcout<<kind[i]<<\" \";\tcout<<endl;\n\tfor(i=0;i<m;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\trsk[i][j+1]+=rsk[i][j];\n\t\t}\n\t}\n\t// for(i=0;i<m;i++){\n\t\t// for(j=0;j<=n;j++){\n\t\t\t// cout<<rsk[i][j]<<\" \";\n\t\t// }\n\t\t// cout<<endl;\n\t// }\n\tfor(i=0;i<1<<m;i++)\tdp[i]=INT_MAX;\n\tdp[0]=0;\n\tfor(i=0;i<(1<<m)-1;i++){\n\t\tnow=i;\n\t\t// printf(\"now=%d\\n\",now);\n\t\tfor(j=0;j<m;j++){\n\t\t\tnext=(1<<j);\n\t\t\t// printf(\"next=%d\\n\",next);\n\t\t\tif((now&next)==0){\n\t\t\t\t// printf(\"now=%d next=%d\\n\",now,next);\n\t\t\t\tnow_kazu=0;\n\t\t\t\tnext_kazu=0;\n\t\t\t\tfor(k=0;k<m;k++){\n\t\t\t\t\t// printf(\"k=%d 1<<k=%d kind[k]=%d\\n\",k,1<<k,kind[k]);\n\t\t\t\t\tif((now&(1<<k))!=0)\t\tnow_kazu+=kind[k];\n\t\t\t\t\tif((next&(1<<k))!=0)\tnext_kazu+=kind[k];\t\n\t\t\t\t}\n\t\t\t\tnext_kazu+=now_kazu;\n\t\t\t\t// printf(\"now_kazu=%d next_kazu=%d\\n\",now_kazu,next_kazu);\n\t\t\t\tcost=0;\n\t\t\t\tfor(k=0;k<m;k++){\n\t\t\t\t\tif(j!=k)\tcost+=rsk[k][next_kazu]-rsk[k][now_kazu];\n\t\t\t\t}\n\t\t\t\tcost_before=0;\n\t\t\t\tif(dp[now]!=INT_MAX)\tcost_before+=dp[now];\n\t\t\t\t// printf(\"coming\\n\");\n\t\t\t\t// printf(\"now|next=%d mix=%d cost=%d cost_before=%d\\n\",now|next,cost+cost_before,cost,cost_before);\n\t\t\t\tdp[now|next]=min(dp[now|next],cost+cost_before);\n\t\t\t\t// for(int l=0;l<(1<<m);l++){\n\t\t\t\t\t// cout<<dp[l]<<\" \";\n\t\t\t\t// }\n\t\t\t\t// cout<<endl;\n\t\t\t}\n\t\t}\n\t\t// printf(\"\\n\");\n\t}\n\tcout<<dp[(1<<m)-1]<<endl;\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nconst int inf = 1000000;\n\nint n, m;\nint s[20][100001];\nint r[1 << 20];\nint dp[1 << 20];\n\nint main(){\n  scanf(\"%d%d\", &n, &m);\n  rep(j, n){\n    int x;\n    scanf(\"%d\", &x);\n    s[x - 1][j + 1] = 1;\n  }\n  rep(i, m){\n    rep(j, n){\n      s[i][j + 1] += s[i][j];\n    }\n  }\n  rep(i, 1 << m){\n    rep(j, m){\n      if(!(i >> j & 1)){\n        r[i] += s[j][n];\n      }\n    }\n  }\n  fill_n(dp, 1 << m, inf);\n  dp[(1 << m) - 1] = 0;\n  for(int i = (1 << m) - 1; i >= 0; --i){\n    rep(j, m){\n      if(i >> j & 1){\n        dp[i - (1 << j)] = min(dp[i] + s[j][n] - (s[j][r[i - (1 << j)]] - s[j][r[i]]), dp[i - (1 << j)]);\n      }\n    }\n  }\n  printf(\"%d\\n\", dp[0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint N;\nint M;\nvector<int> A;\nvector<int> cnt;\n\nvector<vector<int>> sum;\n\nint main(){\n  cin >> N >> M;\n  A.resize(N);\n  cnt.resize(M);\n  sum.resize(M,vector<int>(N + 1,0));\n  rep(i,0,N - 1){\n    cin >> A[i];\n    A[i]--;\n    cnt[A[i]]++;\n    rep(j,0,M - 1){\n      sum[j][i + 1] += sum[j][i] + (A[i] == j);\n    }\n  }\n\n  vector<i64> dp(1 << M,1e9);\n  dp[0] = 0;\n  for(int s = 0;s < 1 << M;s++){\n    int start = 0;\n    rep(i,0,M - 1){\n      if(s & (1 << i)){\n        start += cnt[i];\n      }\n    }\n    rep(i,0,M - 1){\n      if(!(s & (1 << i))){\n        int t = s | (1 << i);\n        int end = start + cnt[i] - 1;\n        int nhere = sum[i][start] - sum[i][0] + sum[i][N] - sum[i][end + 1];\n        dp[t] = min(dp[t],dp[s] + nhere);\n      }\n    }\n\n  }\n\n  cout << dp[(1 << M) - 1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n// 1. dp?????????\nint dp[(1<<20)];\n// 2. n?????????\nint N,M;\nint D[21][100001]={};\nint R;\n// 7. calc?????????\nint calc(int k){\n\t// 8. dp???????????°??????\n\tif(dp[k]>=0)return dp[k];\n\t// 9. dp????¨????\n\tint dd[20]={};\n\tint total=0;\n\tfor (int i=0;i<20;i++){\n\t\tint p=(1<<i);\n\t\tif((p&k)==p){\n\t\t\tdd[i]=1;\n\t\t\ttotal+=D[i][N];\n\t\t}\n\t}\n\tdp[k]=N+1;\n\tfor(int i=0;i<20;i++){\n\t\tif(dd[i]==1){\n\t\t\tint k2=k-(1<<i);\n\t\t\tdp[k]=min(dp[k],calc(k2)+D[i][N]-D[i][total]+D[i][total-D[i][N]]);\n\t\t}\n\n\t}\n\treturn dp[k];\n}\n\n\nint main() {\n\tcin>>N>>M;\n\n\t//3.?????????\n\tfor(int i=0;i<(1<<20);i++){\n\t\tdp[i]=-1;\n\t}\n\t//4.??\\???\n\tint d1;\n\tfor(int i=1;i<N+1;i++){\n\t\tcin>>d1;\n\t\tfor(int j=0;j<20;j++)D[j][i]=D[j][i-1];\n\t\tD[d1-1][i]++;\n\t}\n\t//5.???????????¨???\n\tdp[0]=0;\n\t//6.??????\n\n\tcout<<calc((1<<M)-1)<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint main(){\n\n\tint POW[21];\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\n\tint* table = new int[N];\n\tint num[M];\n\tfor(int i = 0; i < M; i++)num[i] = 0;\n\n\tint** ruisekiwa = new int*[M];\n\tfor(int i = 0; i < M; i++){\n\t\truisekiwa[i] = new int[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\truisekiwa[i][k] = 0;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\ttable[i]--;\n\t\tnum[table[i]]++;\n\t\truisekiwa[table[i]][i]++;\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 1; k < N; k++){\n\t\t\truisekiwa[i][k] += ruisekiwa[i][k-1];\n\t\t}\n\t}\n\n\tint* dp = new int[POW[M]];\n\n\tfor(int i = 0; i < POW[M]; i++)dp[i] = BIG_NUM;\n\n\tdp[0] = 0;\n\n\tint next_start_pos,next_state;\n\tstack<int> S;\n\n\tfor(int i = 0; i < M; i++){\n\t\tnext_state = POW[i];\n\n\t\tint tmp = num[i];\n\t\ttmp -= ruisekiwa[i][num[i]-1];\n\t\tdp[next_state] = tmp;\n\t}\n\n\tfor(int state = 1; state < POW[M]; state++){\n\n\t\tnext_start_pos = 0;\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tnext_start_pos += num[loop];\n\t\t\t}else{\n\t\t\t\tS.push(loop);\n\t\t\t}\n\t\t}\n\n\t\twhile(!S.empty()){\n\t\t\tnext_state = state+POW[S.top()];\n\n\t\t\tint tmp = num[S.top()];\n\n\t\t\ttmp -= (ruisekiwa[S.top()][next_start_pos+num[S.top()]-1]-ruisekiwa[S.top()][next_start_pos-1]);\n\n\t\t\tdp[next_state] = min(dp[next_state],dp[state]+tmp);\n\n\t\t\tS.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[POW[M]-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (100000000)\n\ntypedef pair<int, int> P;\n\nint main() {\n    int N,M;\n    cin >> N >> M;\n\n    vector<int> D;\n    vector<P> DP;\n    for(int i=0; i<M; ++i) DP.push_back(P(i,0));\n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        D.push_back(temp-1);\n        ++DP[temp-1].second;\n    }\n\n    int ans=INF;\n    while(next_permutation(DP.begin(),DP.end())) {\n        int bc=0;\n        int cnt=0;\n        for(int i=0; i<M; ++i) {\n            bc+=(i==0?0:DP[i-1].second);\n            for(int j=0; j<DP[i].second; ++j) {\n                if(D[bc+j]!=DP[i].first) ++cnt;\n            }\n        }\n        ans=min(ans,cnt);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define INF 1145141919\n\nint N, M;\nint S[20][100000];\nint C[20];\nint dp[1<<20];\n\nint main() {\n  cin >> N >> M;\n  for (int i=0; i<N; i++) {\n    int s; cin >> s;\n    s--;\n    S[s][i]++;\n    C[s]++;\n  }\n  for (int i=0; i<M; i++) {\n    for (int j=1; j<N; j++) S[i][j] += S[i][j-1];\n  }\n\n  for (int i=0; i<(1<<M); i++) dp[i] = INF;\n  dp[0] = 0;\n  for (int i=0; i<(1<<M); i++) {\n    int t = 0;\n    for (int j=0; j<M; j++) if (i & (1<<j)) t += C[j];\n    for (int j=0; j<M; j++) {\n      if (i & (1<<j)) continue;\n      int s = C[j] - (S[j][t+C[j]-1] - S[j][t-1]);\n      dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + s);\n    }\n  }\n  cout << dp[(1<<M)-1] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n#define mp std::make_pair\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::pair<int,int> PII;\n\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\ntypedef std::vector<PII> VPII;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\nint N, M;\nVI p;\nVI n(21, 0);\nVI2 c(23, VI(112345));\nVI memo(1 << 21, -1);\n\ninline int count(int p, int l, int r) {\n    return c[p][r-1] - ((l == 0) ? 0 : c[p][l-1]);\n}\n\nint dp(int i, int j, int b) {\n    if(memo[i] != -1) return memo[i];\n    if(b == 1) return memo[i] = count(log2(i), 0, j);\n    \n    int a = 0;\n    REP(p, M) {\n        if(i & 1 << p) {\n            a = std::max(a, dp(i ^ (1 << p), j - n[p], b - 1) + count(p, j - n[p], j));\n        }\n    }\n    return (memo[i] = a);\n}\n \nint main() {\n    std::cin >> N >> M;\n    p.resize(N);\n    REP(i, N) {\n        std::cin >> p[i];\n        ++n[p[i] - 1];\n    }\n\n    REP(i, M) {\n        int t = 0;\n        REP(j, N) {\n            if(p[j] == i + 1) ++t;\n            c[i][j] = t;\n            c[i][j-1] = t;\n        }\n    }\n\n    int res = N - dp((1 << M) - 1, N, M);\n\n    std::cout << res << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    int n,m;\n    cin>>n>>m;\n    vector<vector<int>> d(n+1,vector<int>(m,0));\n    for(int i = 0;i < n;++i) {\n        int t;\n        cin>>t;\n        --t;\n        ++d[i+1][t];\n    }\n    for(int i = 0;i < m;++i) {\n        for(int j = 0;j < n;++j) {\n            d[j+1][i]+=d[j][i];\n        }\n    }\n\n    vector<int> mae(1<<m,0);\n    for(int bit = 0;bit < 1<<m;++bit) {\n        for(int j = 0;j < m;++j) {\n            if((bit & (1<<j))==0)continue;\n            mae[bit]+=d[n][j];\n        }\n    }\n\n    vector<int> dp(1<<m,n+1);\n    dp[0]=0;\n    for(int bit = 1;bit < 1<<m;++bit) {\n        for(int j = 0;j < m;++j) {\n            if((bit & (1<<j))==0)continue;\n            int nv=dp[bit-(1<<j)];\n            nv+=mae[bit]-mae[bit-(1<<j)]-(d[mae[bit]][j]-d[mae[bit-(1<<j)]][j]);\n            dp[bit]=min(dp[bit],nv);\n        }\n    }\n    cout<<dp.back()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint a[100010], b[25][100010], cnt[25];\nPII dp[1LL<<20];\nsigned main(void)\n{\n  int n, m;\n  cin >> n >> m;\n  REP(i, n) {\n    cin >> a[i];\n    cnt[a[i]-1]++;\n    b[a[i]-1][i] = 1;\n  }\n\n  REP(i, m) FOR(j, 1, n) b[i][j] += b[i][j-1];\n  // REP(i, m) {\n  //   REP(j, n) {\n  //     cout << b[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n\n  REP(i, 1LL<<20) dp[i] = {INF, INF};\n  dp[0] = {0, 0};\n\n  REP(i, (1LL<<m)-1) {\n    // cout << \"i:\" << i << endl;\n    REP(j, m) if(!(i>>j&1)) {\n      // [ dp[i].second, dp[i].second+cnt[j] ) ????????????????¨????j?????°\n      int tmp = dp[i].second == 0 ? 0 : b[j][dp[i].second-1];\n      int kind = b[j][dp[i].second+cnt[j]-1] - tmp;\n      // cout << j << \" \" << kind << \" \";\n      // cout << dp[i].second+cnt[j]-1 << \" \" << b[j][dp[i].second+cnt[j]-1] << \" \" << dp[i].second-1 << \" \" << tmp << endl;\n      chmin(dp[i|1LL<<j], MP(dp[i].first+cnt[j]-kind, dp[i].second+cnt[j]));\n      // cout << dp[i|1LL<<j].first << endl;\n    }\n  }\n  // REP(i, 1LL<<m) cout << dp[i].first << \",\" << dp[i].second << \" \"; cout << endl;\n  cout << dp[(1LL<<m)-1].first << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m;\nint p[100000 + 5];\nint s[100000 + 5][25];\nint cnt[25];\nint dp[1<<21];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) cin >> p[i];\n    rep(i, n) cnt[p[i] - 1] += 1;\n    rep(i, n) s[i + 1][p[i] - 1] += 1;\n    rep(i, n)rep(j, m) s[i + 1][j] += s[i][j];\n    fill(dp, dp + (1<<m) + 1, 1e9);\n    dp[0] = 0;\n    rep(i, 1<<m) {\n        rep(j, m) {\n            if (i>>j & 1) {\n                int l = 0;\n                int r = 0;\n                rep(k, m) {\n                    if (k == j) r = cnt[k];\n                    else if (i>>k & 1) l += cnt[k];\n                }\n                int change = r - (s[r + l][j] - s[l][j]);\n                dp[i] = min(dp[i], dp[i ^ (1<<j)] + change);\n            }\n        }\n    }\n    cout << dp[(1<<m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m;\n\tcin>>n>>m;\n\tvector<ll> gumi(n);\n\tvector<ll> gumi_c(m);\n\tvector<vector<ll>> gumi_sum(n,vector<ll>(m));\n\tREP(i,n) cin>>gumi[i];\n\tREP(i,n) gumi_c[i]=0;\n\tREP(i,n) REP(j,m) gumi_sum[i][j]=0;\n\tREP(i,n) {\n\t\tgumi_c[gumi[i]-1]++;\n\t\tREP(j,m) if(i!=0) gumi_sum[i][j]+=gumi_sum[i-1][j];\n\t\tgumi_sum[i][gumi[i]-1]++;\n\t}\n\tvector<ll> dp(1<<m,INF);\n\tdp[0]=0;\n\tREP(bit,(1<<m)) {\n\t\tvector<ll> used;\n\t\tll buf=bit;\n\t\tREP(i,m) {\n\t\t\tif(buf%2) used.pb(i);\n\t\t\tbuf/=2;\n\t\t}\n\t\tll sum=0;\n\t\tREP(i,(ll)used.size()) sum+=gumi_c[used[i]];\n\t\tREP(i,(ll)used.size()) {\n\t\t\tif((ll)used.size()==1) dp[bit]=(gumi_c[used[i]]-(gumi_sum[sum-1][used[i]]));\n\t\t\telse dp[bit]=min(dp[bit],dp[bit^(1<<used[i])]+(gumi_c[used[i]]-(gumi_sum[sum-1][used[i]]-gumi_sum[sum-1-gumi_c[used[i]]][used[i]])));\n\t\t}\n\t}\n\tcout<<dp[(1<<m)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint p[110000];\nint sum[20][110000];\nint sz[20];\nint dp[1<<20];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tp[i]--;\n\t\tsum[p[i]][i+1]++;\n\t\tsz[p[i]]++;\n\t}\n\tfor(int i=0;i<b;i++)for(int j=0;j<a;j++){\n\t\tsum[i][j+1]+=sum[i][j];\n\t}\n\tfor(int i=0;i<(1<<b);i++)dp[i]=999999999;\n\tdp[0]=0;\n\tfor(int i=0;i<(1<<b);i++){\n\t\tint pos=0;\n\t\tfor(int j=0;j<b;j++)if(i&(1<<j))pos+=sz[j];\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tdp[i+(1<<j)]=min(dp[i+(1<<j)],dp[i]+sz[j]-sum[j][pos+sz[j]]+sum[j][pos]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[(1<<b)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\n#define INF (100000000)\n\ntypedef pair<int, int> P;\n\nint main() {\n    int N,M;\n    cin >> N >> M;\n\n    vector<int> D;\n    vector<P> DPAIR(M);\n    for(int i=0; i<M; ++i) DPAIR[i]=P(i,0);\n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        D.push_back(temp-1);\n        ++DPAIR[temp-1].second;\n    }\n\n    vector<int> DD[M];\n\n    for(int i=0; i<M; ++i) {\n        DD[i].resize(N);\n        DD[i][0]=(D[0]==i?1:0);\n        for(int j=1; j<N; ++j) {\n            DD[i][j]=DD[i][j-1]+(D[j]==i?1:0);\n        }\n    }\n\n    string ALPHA=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string istr=ALPHA.substr(0,M);\n    vector<int> indx(M+1);\n    map<string,P> mp;\n\n    for(int c=1; c<=M; ++c) {\n        indx[c]=M;\n        for(int i=0; i<c; ++i) indx[i]=i;\n        --indx[c-1];\n        while(indx[0]<M-c || c==M) {\n            int now=c-1;\n            while(indx[0]!=M-c || c==M) {\n                if(indx[now+1]-indx[now]>1) {\n                    ++indx[now];\n                    break;\n                } else if(indx[now]-indx[now-1]>1) {\n                    ++indx[now-1];\n                    for(int i=now; i<c; ++i) indx[i]=indx[i-1]+1;\n                    break;\n                } else {\n                    --now;\n                }\n            }\n\n            // main\n            int cnt=INF;\n            int len;\n            for(int i=0; i<c; ++i) { // most back position's index\n                string s=\"\";\n                for(int j=0; j<c; ++j) {\n                    if(j==i) continue;\n                    s.push_back(istr[indx[j]]);\n                }\n                if(s==\"\") {\n                    cnt=min(cnt,DPAIR[indx[i]].second-DD[indx[i]][DPAIR[indx[i]].second-1]);\n                    len=DPAIR[indx[i]].second;\n                } else {\n                    int fst=mp[s].first;\n                    int snd=mp[s].second;\n                    cnt=min(cnt,fst+DPAIR[indx[i]].second-DD[indx[i]][snd+DPAIR[indx[i]].second-1]+DD[indx[i]][snd-1]);\n                    len=snd+DPAIR[indx[i]].second;\n                }\n           }\n           string s=\"\";\n           for(int i=0; i<c; ++i) {\n               s.push_back(istr[indx[i]]);\n           }\n           mp[s]=make_pair(cnt,len);\n\n            if(c==M) break;\n        }\n    }\n\n    cout << mp[istr].first << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// template.cpp {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long;\n#define reps(i, a, n) for (lint i = (a); i < (lint)(n); ++i)\n#define rep(i, n) reps(i, 0, n)\nstruct pre_{pre_(){cin.tie(0);ios::sync_with_stdio(0);}} pre__;\n// }}}\n\nint n, m;\nconst int INF = 1e9 + 9;\nint imos[21][100010];\nint cnt[21];\nint memo[1 << 20];\n\ninline void chmin(int &a, const int& b) {\n  a = min(a, b);\n}\n\nint dfs(int s) {\n  if (s == (1 << m) - 1) return 0;\n  if (memo[s] != -1) return memo[s];\n\n  int c = 0;\n  int res = INF;\n  rep(i, m) {\n    if (s & (1 << i)) c += cnt[i];\n  }\n\n  rep(i, m) {\n    if (s & (1 << i)) continue;\n    chmin(res, dfs(s | (1 << i)) + cnt[i] - (imos[i][c + cnt[i]] - imos[i][c]));\n  }\n\n  return memo[s] = res;\n}\n\nsigned main() {\n  fill(memo, memo + (1 << 20), -1);\n  cin >> n >> m;\n  rep(i, n) {\n    int type;\n    cin >> type;\n    cnt[type - 1]++;\n    imos[type - 1][i + 1] = 1;\n  }\n  rep(i, m) rep(j, n) {\n    imos[i][j + 1] += imos[i][j];\n  }\n  /*\n  rep(i, m) rep(j, n) {\n    cerr << imos[i][j + 1] << (j != n - 1 ? ' ' : '\\n');\n  }\n  */\n\n  cout << dfs(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n#include<set>\n \nusing namespace std;\n \n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n \ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\nint IN[100001],type[21];\nint rui[21][100001];\nint dp[1<<20];\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\trep(i,N){\n\t\tcin>>IN[i];\n\t\tIN[i]--;\n\t\ttype[IN[i]]++;\n\t\trui[IN[i]][i]++;\n\t}\n\tvector<int>v;\n\trep(i,M){\n\t\trep(j,N-1){\n\t\t\trui[i][j+1]+=rui[i][j];\n\t\t}\n\t\tv.push_back(i);\n\t}\n\t//cout<<rui[0][6]<<endl;\n/*int ans=INF;\n\tdo{\n\t\tint tmp=0,now=0;\n\t\trep(i,M){\n\t\t\tif(now-1>=0)\n\t\t\t\ttmp+=(rui[v[i]][now-1]);\n\t//\t\tcout<<tmp<<\" \";\n\t\t\ttmp+=(rui[v[i]][N-1]-rui[v[i]][now+type[v[i]]-1]);\n\t//\t\tcout<<tmp<<\" \";\n\t\t\tnow+=type[v[i]];\n\t//\t\tcout<<endl;\n\t\t}\n\t//\tcout<<endl;\n\t\tans=min(tmp,ans);\n\t}while(next_permutation(v.begin(),v.end())); //??¨?????? O(M!*M) ??????;;??????bitDP???*/\n\trep(i,1<<M)dp[i]=99999999;\n\tdp[0]=0;\n\trep(i,1<<M){\n\t\tint now=0,used[21];\n\t\trep(j,M){\n\t\t\tused[j]=(i>>j)&1;\n\t\t\tif(used[j])now+=type[j];\n\t\t}\n\t\trep(j,M){\n\t\t\tif(used[j])continue;\n\t\t\tint tmp=dp[i];\n\t\t\tif(now-1>=0)\n\t\t\t\ttmp+=rui[j][now-1];\n\t\t\ttmp+=(rui[j][N-1]-rui[j][now+type[j]-1]);\n\t\t\tdp[i+(1<<j)]=min(dp[i+(1<<j)],tmp);\n\t\t}\n\t}\n\tcout<<dp[(1<<M)-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*0633　ぬいぐるみの整理\n ビットdp　８０点ぐらい\n*/\n#include<cstdio>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint dp[1<<21],ss[1<<21],s2[21][100001];\nint main(void)\n{\n\tint i,j,s[21],n,m,a[100000],x,k,mask[21],s1,wk,wk2;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<n;i++)\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=m;i++)\ts[i]=0;\n\tfor(i=0;i<n;i++)\ts[a[i]]++;\n\tfor(i=0;i<(1<<m);i++)\t{\n\t\tx=i;\tss[i]=0;\t\n\t\tfor(j=1;j<=m;j++)\t{\n\t\t\tif(x%2==1)\tss[i]+=s[j];\n\t\t\tx=x/2;\n\t\t}\n\t}\n\tfor(i=1;i<=m;i++)\t{\n\t\ts2[i][0]=0;\twk=0;\n\t\tfor(j=0;j<n;j++)\t{\n\t\t\tif(a[j]==i)\t{\n\t\t\t\twk++;\n\t\t\t}\n\t\t\ts2[i][j+1]=wk;\n\t\t}\n\t}\n//\tfor(i=1;i<=m;i++)\t{\n//\t\tfor(j=0;j<n;j++)\t{\n//\t\t\tprintf(\"%d \",s2[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tmask[1]=1;\n\tfor(i=2;i<=m;i++)\tmask[i]=mask[i-1]*2;\n\tfor(i=0;i<(1<<m);i++)\tdp[i]=n;\n\tdp[0]=0;\n\tfor(i=0;i<(1<<m);i++)\t{\n\t\tx=i;\n\t\tfor(j=1;j<=m;j++)\t{\n\t\t\tif((x&mask[j])==0)\t{\n\t\t\t\ts1=s[j]-(s2[j][ss[i]+s[j]]-s2[j][ss[i]]);\n//\t\t\t\tprintf(\" %d %df s1=%d\\n\",i,j,s1);\n\t\t\t\twk=i|mask[j];\n\t\t\t\tdp[wk]=min(dp[wk],dp[i]+s1);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(i=0;i<(1<<m);i++)\tprintf(\" %d %d\\n\",i,dp[i]);\n\tprintf(\"%d\\n\",dp[(1<<m)-1]);\n\treturn 0;\n}\n\t\t\n\t\t\t\t\n\n\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n#include<string.h>\n//#include<time.h>\n//#define pi acos(-1.0)\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\n#define min(a,b) a<b?a:b\nint dp[1048576],s[20][100000];\nint main(){\n\tint n, m, i, j, p, a[20] = {};\n\tfscanf(stdin, \"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++) {\n\t\tfscanf(stdin, \"%d\", &p);\n\t\tp--;\n\t\ts[p][i + 1]++;\n\t\ta[p]++;\n\t}\n\tfor (i = 0; i < m; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\ts[i][j + 1] += s[i][j];\n\tfor (i = 1; i < 1 << m; i++)dp[i] = 999999999;\n\tfor (i = 0; i < 1 << m; i++) {\n\t\tp = 0;\n\t\tfor (j = 0; j < m; j++) if (i&(1 << j))p += a[j];\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tif (i&(1 << j))continue;\n\t\t\tdp[i + (1 << j)] = min(dp[i + (1 << j)], dp[i] + a[j] - s[j][p + a[j]] + s[j][p]);\n\t\t}\n\t}\n\tP(d, dp[(1 << m)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define NMAX 100000\n#define MMAX 20\n#define INF 1000000000\nint n, m, imos[MMAX][NMAX+1], dp[1<<MMAX];\nint rec(int S, int v);\nint main(void)\n{\n  int i, j, d;\n  scanf(\"%d %d\", &n, &m);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &d);\n    d--;\n    for (j = 0; j < m; j++) {\n      if (d != j) imos[j][i+1]++;\n      imos[j][i+1] += imos[j][i];\n    }\n  }\n  memset(dp, -1, sizeof(dp));\n  dp[(1<<m)-1] = 0;\n  printf(\"%d\\n\", rec(0, 0));\n}\n\nint rec(int S, int v)\n{\n  int i, res = INF;\n  if (dp[S] != -1) return dp[S];\n  for (i = 0; i < m; i++) {\n    if (!(S & 1 << i)) {\n      int lans, isum = n - imos[i][n], icnt = imos[i][v+isum] - imos[i][v];\n      lans = rec(S | 1 << i, v + isum) + icnt;\n      if (res > lans) res = lans;\n    }\n  }\n  return dp[S] = res;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n//#include<string.h>\n//#include<time.h>\n//#define pi acos(-1.0)\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\n#define min(a,b) a<b?a:b\nint dp[1<<20],s[20][100000];\nint main(){\n\tint n, m, i, j, p, a[20] = {};\n\tfscanf(stdin, \"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++) {\n\t\tfscanf(stdin, \"%d\", &p);\n\t\tp--;\n\t\ts[p][i + 1]++;\n\t\ta[p]++;\n\t}\n\tfor (i = 0; i < m; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\ts[i][j + 1] += s[i][j];\n\tfor (i = 1; i < (1 << m); i++) dp[i] = 999999999;\n\tfor (i = 0; i < (1 << m); i++) {\n\t\tp = 0;\n\t\tfor (j = 0; j < m; j++) if (i&(1 << j))p += a[j];\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tif (i&(1 << j))continue;\n\t\t\tdp[i + (1 << j)] = min(dp[i + (1 << j)], dp[i] + a[j] - s[j][p + a[j]] + s[j][p]);\n\t\t}\n\t}\n\tP(d, dp[(1 << m)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N_MAX 100000\n#define M_MAX 20\n\nint N, M;\nint nuigurumi[N_MAX + 1];\n\nint ncount[M_MAX];\n\nint haiti[M_MAX][N_MAX + 1];\n\nint memo[1 << M_MAX];\n\nint search(int done, int pos) {\n\tint ret = -1;\n\tint candidate;\n\tint i;\n\tif (done == (1 << M) - 1) return 0;\n\tif (memo[done]) return ~memo[done];\n\tfor (i = 0; i < M; i++) {\n\t\tif (!(done & (1 << i))) {\n\t\t\tcandidate = ncount[i] - (haiti[i][pos + ncount[i] - 1] - haiti[i][pos - 1]);\n\t\t\tcandidate += search(done | (1 << i), pos + ncount[i]);\n\t\t\tif (ret < 0 || candidate < ret) ret = candidate;\n\t\t}\n\t}\n\treturn ~(memo[done] = ~ret);\n}\n\nint main(void) {\n\tint i, j;\n\tif (scanf(\"%d%d\", &N, &M) != 2) return 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (scanf(\"%d\", &nuigurumi[i]) != 1) return 1;\n\t\tncount[--nuigurumi[i]]++;\n\t\thaiti[nuigurumi[i]][i]++;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\tfor (j = 1; j <= N; j++) {\n\t\t\thaiti[i][j] += haiti[i][j - 1];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", search(0, 1));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0633: Plush Toys\n// 2017.12.5 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint p[100002];\nint f[22][100002], c[22];\nint dp[1050000];\n\nchar buf[15], *bp;\nint getInt()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, i, j, k, v, x, lim;\n\n\tfgets(bp=buf, 15, stdin);\n\tn = getInt(), bp++, m = getInt();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(bp=buf, 15, stdin), v = getInt()-1;\n\t\tf[v][i+1]++, c[v]++;\n\t}\n\tfor (i = 0; i < m; i++) for (j = 0; j < n; j++) f[i][j+1] += f[i][j];\n\n\tmemset(dp, 0x55, sizeof(dp));\n\tdp[0] = 0, lim = 1 << m;\n\tfor (i = 0; i < lim; i++){\n\t\tfor (v = 0, j = 0; j < m; j++) if (i & (1<<j)) v += c[j];\n\t\tfor (k = 1, j = 0; j < m; j++, k <<= 1) if (!(i & k)) {\n\t\t\tx = dp[i] + c[j] - f[j][v + c[j]] + f[j][v];\n\t\t\tif (dp[i+k] > x) dp[i+k] = x;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[lim-1]);\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\n\n\nfun main(args: Array<String>?) {\n    val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n    val dolls = IntArray(n){ readLine()!!.toInt()}\n    val count = IntArray(m){0}\n    val sumCount = Array(m){IntArray(n){0} }\n    for (i in dolls.indices) {\n        count[dolls[i] - 1]++\n        sumCount[dolls[i] - 1][i]++\n        if (i > 0) for (j in sumCount.indices) {\n            sumCount[j][i] += sumCount[j][i - 1]\n        }\n    }\n    val memo = IntArray(1 shl m){Int.MAX_VALUE}\n    memo[0] = 0\n    for (i in memo.indices) {\n        val left = (0 until m).filter{i and (1 shl it) != 0}.sumBy(count::get)\n        for (j in 0 until m) if (i and (1 shl j) == 0) {\n            val right = left + count[j] - 1\n            val sum = if (left > 0) sumCount[j][right] - sumCount[j][left - 1] else sumCount[j][right]\n            memo[i or (1 shl j)] = java.lang.Math.min(memo[i or (1 shl j)], memo[i] + (count[j] - sum))\n        }\n    }\n    println(memo.last())\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint spaceNum = sc.nextInt();\n\t\tint dollTypeNum = sc.nextInt();\n\t\tint space[] = new int[spaceNum];\n\t\tint dollType[] = new int[dollTypeNum];  //添え字に注意\n\t\tint cursor = 0;\n\t\tint count = 0;\n\n\t\tfor(int i = 0; i < spaceNum; i++) {\n\t\t\tspace[i] = sc.nextInt();\n\t\t\tfor(int j = 1; j <= dollTypeNum; j++) {\n\t\t\t\tif(space[i] == j) {\n\t\t\t\t\tdollType[j - 1]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Integer> typeList= new ArrayList<Integer>();\n\t\tfor(int i = 0; i < dollTypeNum; i++) {\n\t\t\ttypeList.add(i + 1);\n\t\t}\n\n\t\tfor(int i = 0; i < dollTypeNum; i++) {\n\t\t\tFillIn fi = new FillIn();\n\t\t\tfi.fill_in(cursor, space, typeList, dollType);\n\t\t\tcursor += dollType[fi.getNum() - 1];\n\t\t\tcount += fi.getMin();\n\n\t\t\tIterator<Integer> iter = typeList.iterator();\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tint type = iter.next();\n\t\t\t\tif(type == fi.getNum()) iter.remove();  //getした値を変数に入れてもいいかも\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(count);\n\t}\n}\n\nclass FillIn {\n\tint num = 0;\n\tint min = Integer.MAX_VALUE;\n\t//最小の操作回数で埋められるぬいぐるみ番号を探すメソッド\n\t//fill_in_in_order(埋める開始点, 操作前のぬいぐるみ配列, 埋め終わってないぬいぐるみ番号を入れたリスト, ぬいぐるみ番号別の個数を入れた配列);\n\tpublic void fill_in(int start, int[] array, List<Integer> list, int[] type) {\n\t\tint cursor;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < list.size(); i++) {  //埋め終わってないぬいぐるみ番号のループ\n\t\t\tcursor = start;\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < type[list.get(i) - 1]; j++) {  //その番号のぬいぐるみの個数のループ\n\t\t\t\tif(array[cursor] == list.get(i)) count++;  //cursor = jでもいいかも\n\t\t\t\tcursor++;\n\t\t\t}\n\t\t\tif(type[list.get(i) - 1] - count < min) {\n\t\t\t\tnum = list.get(i);\n\t\t\t\tmin = type[num - 1] - count;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int getNum() {\n\t\treturn this.num;\n\t}\n\n\tpublic int getMin() {\n\t\treturn this.min;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\tstatic int N;\n\tstatic int M;\n\tstatic int[] ar;\n\tstatic int[] c;\n\tstatic int INF = 2 << 28;\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tar = new int[N];\n\t\tc  = new int[M];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tar[i] = sc.nextInt()-1;\n\t\t\tc[ar[i]]++;\n\t\t}\n\t\t\n\n\t\tint[][] dp = new int[M+1][1 << M];\n\t\tint[][] dd = new int[M+1][1 << M];\n\t\tint[][] ck = new int[M][N];\n\t\t\n\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t\tArrays.fill(dd[i], INF);\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tArrays.fill(ck[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdd[0][0] = 0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint tmp = dd[i][j];\n\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tint next = j & (1 << k);\n\t\t\t\t\tint sum  = 0;\n\t\t\t\t\tif(ck[k][tmp] == INF) {\n\t\t\t\t\t\tfor(int l = 0; l < c[k]; l++) {\n\t\t\t\t\t\t\tif(ar[l + tmp] != k) sum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tck[k][tmp] = sum;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = ck[k][tmp];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+1][j | (1 << k)] = Math.min(dp[i+1][j | (1 << k)], dp[i][j] + sum);\n\t\t\t\t\tdd[i+1][j | (1 << k)] = tmp + c[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[dp.length-1][dp[0].length-1]);\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\t\t\tint now = type;\n\t\t\tint min = 0;\n\t\t\twhile (now>1) {\n\t\t\t\tdouble[][] data = new double[now][2];\n\t\t\t\tint pointer = 0;\n\t\t\t\tdouble dmax = -1;\n\t\t\t\tint dposit = -1;\n\t\t\t\tfor (int i=0; i<now; i++) {\n\t\t\t\t\tdouble diff = 0;\n\t\t\t\t\tList<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[num.get(i)]));\n\t\t\t\t\tList<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\tcopy.addAll(c);\n\t\t\t\t\tif (c.contains(num.get(i)+1)) {\n\t\t\t\t\t\tCollections.sort(c);\n\t\t\t\t\t\tint same = c.lastIndexOf(num.get(i)+1)-c.indexOf(num.get(i)+1)+1;\n\t\t\t\t\t\t//System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\tdiff+=count[num.get(i)]-same;\n\t\t\t\t\t} else diff += count[num.get(i)];\n\t\t\t\t\tdata[i][0] = (count[num.get(i)] - diff)/count[num.get(i)];  //割り合い\n\t\t\t\t\tdata[i][1] = diff;\n\t\t\t\t\tif (data[i][0] > dmax) {\n\t\t\t\t\t\tdmax = data[i][0];\n\t\t\t\t\t\tdposit = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin += data[dposit][1];\n\t\t\t\tnow--;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Plush Toys\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint N, M;\n\t\tN = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tM = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[] P = new int[N];\n\t\tint[] C = new int[M];\n\t\tint[] S = new int[1 << M];\n\t\tint[][] diff = new int[N][M];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tP[i] = parseInt(br.readLine()) - 1;\n\t\t\tC[P[i]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 1) {\n\t\t\t\t\tS[i] += C[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(diff[i], -1);\n\t\t}\n\n\t\t//\n\t\tint[] dp = new int[1 << M];\n\n\t\tArrays.fill(dp, INF);\n\t\tdp[0] = 0;\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 0) {\n\t\t\t\t\tif (diff[S[i]][j] == -1) {\n\t\t\t\t\t\tdiff[S[i]][j] = 0;\n\t\t\t\t\t\tfor (int k = 0; k < C[j]; k++) {\n\t\t\t\t\t\t\tif (P[S[i] + k] != j) diff[S[i]][j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i | 1 << j] = Math.min(dp[i | 1 << j], dp[i] + diff[S[i]][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[(1 << M) - 1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\tpublic static final int BIG_NUM = 2000000000;\n\tpublic static final int MOD = 1000000007;\n\tpublic static final long HUGE_NUM = 99999999999999999L;\n\tpublic static final double EPS = 0.000000001;\n\n\tpublic static final int SIZE = 21;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\t//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint POW[] = new int[SIZE];\n\t\tPOW[0] = 1;\n\t\tfor(int i = 1; i < SIZE; i++){\n\n\t\t\tPOW[i] = POW[i-1]*2;\n\t\t}\n\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint N = scanner.nextInt();\n\t\tint M = scanner.nextInt();\n\n\t\t//種類の個数を記録\n\t\tint table[] = new int[M];\n\t\tfor(int i = 0; i < table.length; i++){\n\n\t\t\ttable[i] = 0;\n\t\t}\n\n\t\t//移動するぬいぐるみの個数を求めるための累積和テーブル\n\t\tint ruisekiwa[][] = new int[M][N];\n\t\tfor(int row = 0; row < M; row++){\n\t\t\tfor(int col = 0; col < N; col++){\n\n\t\t\t\truisekiwa[row][col] = 0;\n\t\t\t}\n\t\t}\n\n\n\t\tint tmp;\n\n\t\tfor(int i = 0; i < N; i++){\n\n\t\t\ttmp = scanner.nextInt();\n\t\t\ttmp--;\n\t\t\ttable[tmp]++;\n\t\t\truisekiwa[tmp][i] += 1;\n\t\t}\n\n\t\tfor(int row = 0; row < M; row++){\n\t\t\tfor(int col = 1; col < N; col++){\n\n\t\t\t\truisekiwa[row][col] += ruisekiwa[row][col-1];\n\t\t\t}\n\t\t}\n\n\t\tint dp[] = new int[POW[M]];\n\n\t\tdp[0] = 0;\n\t\tfor(int state = 1; state < POW[M]; state++){\n\n\t\t\tdp[state] = BIG_NUM;\n\t\t}\n\n\t\tint left,right;\n\t\tint tmp_sum,next_state,add,loc;\n\n\t\tfor(int state = 0; state < POW[M]-1; state++){\n\n\t\t\ttmp_sum = 0;\n\n\t\t\t//配置済のぬいぐるみの個数を求める\n\t\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\t\tif((state & POW[loop]) != 0){\n\t\t\t\t\ttmp_sum += table[loop];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tleft = tmp_sum;\n\n\t\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\t\tif((state & POW[loop]) == 0){ //次に置くぬいぐるみ\n\n\t\t\t\t\tright = tmp_sum+table[loop]-1;\n\n\t\t\t\t\t//範囲より左\n\t\t\t\t\tif(left == 0){\n\n\t\t\t\t\t\tadd = 0;\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tadd = ruisekiwa[loop][left-1];\n\t\t\t\t\t}\n\t\t\t\t\t//範囲より右\n\t\t\t\t\tadd += (ruisekiwa[loop][N-1]-ruisekiwa[loop][right]);\n\n\t\t\t\t\tnext_state = state+POW[loop];\n\t\t\t\t\tdp[next_state] = Math.min(dp[next_state],dp[state]+add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[POW[M]-1]);\n    }\n}\n\n\nclass UTIL{\n\n    //String→intへ変換\n    public static int getNUM(String tmp_str){\n\n        return Integer.parseInt(tmp_str);\n    }\n\n    //文字が半角数字か判定する関数\n    public static boolean isNumber(String tmp_str){\n\n        if(tmp_str == null || tmp_str.length() == 0){\n\n            return false;\n        }\n\n        Pattern pattern = Pattern.compile(\"\\\\A[0-9]+\\\\z\");\n        Matcher matcher = pattern.matcher(tmp_str);\n        return matcher.matches();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "package aoj.volume06.joi2016;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Plush Toys\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint N, M;\n\t\tN = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tM = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[] P = new int[N];\n\t\tint[] C = new int[M];\n\t\tint[] S = new int[1 << M];\n\t\tint[][] diff = new int[N][M];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tP[i] = parseInt(br.readLine()) - 1;\n\t\t\tC[P[i]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 1) {\n\t\t\t\t\tS[i] += C[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tfor (int k = 0; k < C[j]; k++) {\n\t\t\t\t\tif (i + k < N && P[i + k] != j) diff[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dp = new int[1 << M];\n\n\t\tArrays.fill(dp, INF);\n\t\tdp[0] = 0;\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 0) {\n\t\t\t\t\tdp[i | 1 << j] = Math.min(dp[i | 1 << j], dp[i] + diff[S[i]][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[(1 << M) - 1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Plush Toys\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint N, M;\n\t\tN = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tM = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[] P = new int[N];\n\t\tint[] C = new int[M];\n\t\tint[] S = new int[1 << M];\n\t\tint[][] diff = new int[N][M];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tP[i] = parseInt(br.readLine()) - 1;\n\t\t\tC[P[i]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 1) {\n\t\t\t\t\tS[i] += C[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tfor (int k = 0; k < C[j]; k++) {\n\t\t\t\t\tif (i + k < N && P[i + k] != j) diff[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dp = new int[1 << M];\n\n\t\tArrays.fill(dp, INF);\n\t\tdp[0] = 0;\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 0) {\n\t\t\t\t\tdp[i | 1 << j] = Math.min(dp[i | 1 << j], dp[i] + diff[S[i]][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[(1 << M) - 1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t\t List<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[a]));\n\t\t\t\t\t List<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\t copy.addAll(c);\n\t\t\t\t\t if (c.contains(a+1)) {\n\t\t\t\t\t\t Collections.sort(c);\n\t\t\t\t\t\t int same = c.lastIndexOf(a+1)-c.indexOf(a+1)+1;\n\t\t\t\t\t\t //System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\t diff+=count[a]-same;\n\t\t\t\t\t } else diff += count[a];\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\tstatic int N;\n\tstatic int M;\n\tstatic int[] ar;\n\tstatic int[] c;\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tar = new int[N];\n\t\tc  = new int[M];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tar[i] = sc.nextInt()-1;\n\t\t\tc[ar[i]]++;\n\t\t}\n\t\tint ans = dfs(0, new int[M], new boolean[M]);\n\t\tSystem.out.println(ans);\n\t}\n\tstatic int dfs(int id, int[] a, boolean[] b) {\n\t\tif(id == M) {\n\t\t\tint now = 0;\n\t\t\tint ret = 0;\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tint cc = c[a[i]];\n\t\t\t\tfor(int j = 0; j < cc; j++) {\n\t\t\t\t\tif(ar[j + now] != a[i]) ret++;\n\t\t\t\t}\n\t\t\t\tnow += cc;\n\t\t\t}\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tint min = 2 << 29;\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(b[i]) continue;\n\t\t\t\tb[i] = true;\n\t\t\t\ta[id] = i;\n\t\t\t\tmin = Math.min(min, dfs(id+1,a,b));\n\t\t\t\tb[i] = false;\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\t\t\tint now = type;\n\t\t\tint min = 0;\n\t\t\tint pointer = 0;\n\t\t\twhile (now>1) {\n\t\t\t\tdouble[][] data = new double[now][2];\n\t\t\t\tdouble dmax = -1;\n\t\t\t\tint dposit = -1;\n\t\t\t\tfor (int i=0; i<now; i++) {\n\t\t\t\t\tdouble diff = 0;\n\t\t\t\t\tList<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[num.get(i)]));\n\t\t\t\t\tList<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\tcopy.addAll(c);\n\t\t\t\t\tif (c.contains(num.get(i)+1)) {\n\t\t\t\t\t\tCollections.sort(c);\n\t\t\t\t\t\tint same = c.lastIndexOf(num.get(i)+1)-c.indexOf(num.get(i)+1)+1;\n\t\t\t\t\t\t//System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\tdiff+=count[num.get(i)]-same;\n\t\t\t\t\t} else diff += count[num.get(i)];\n\t\t\t\t\tdata[i][0] = (count[num.get(i)] - diff)/count[num.get(i)];  //割り合い\n\t\t\t\t\t//System.out.println(data[i][0] );\n\t\t\t\t\tdata[i][1] = diff;\n\t\t\t\t\tif (data[i][0] > dmax) {\n\t\t\t\t\t\tdmax = data[i][0];\n\t\t\t\t\t\tdposit = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer += count[num.get(dposit)];\n\t\t\t\tmin += data[dposit][1];\n\t\t\t\tnum.remove(dposit);\n\t\t\t\tnow--;\n\t\t\t}\n\t\t\t//最後の羅列\n\t\t\tList<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[num.get(0)]));\n\t\t\tList<Integer> copy = new ArrayList<Integer>();\n\t\t\tcopy.addAll(c);\n\t\t\tif (c.contains(num.get(0)+1)) {\n\t\t\t\tCollections.sort(c);\n\t\t\t\tint same = c.lastIndexOf(num.get(0)+1)-c.indexOf(num.get(0)+1)+1;\n\t\t\t\tmin+=count[num.get(0)]-same;\n\t\t\t} else min += count[num.get(0)];\n\t\t\t//--------------------------------------------------\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\t\t\tint now = type;\n\t\t\tint min = 0;\n\t\t\twhile (now>1) {\n\t\t\t\tdouble[][] data = new double[now][2];\n\t\t\t\tint pointer = 0;\n\t\t\t\tdouble dmax = -1;\n\t\t\t\tint dposit = -1;\n\t\t\t\tfor (int i=0; i<now; i++) {\n\t\t\t\t\tdouble diff = 0;\n\t\t\t\t\tList<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[num.get(i)]));\n\t\t\t\t\tList<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\tcopy.addAll(c);\n\t\t\t\t\tif (c.contains(num.get(i)+1)) {\n\t\t\t\t\t\tCollections.sort(c);\n\t\t\t\t\t\tint same = c.lastIndexOf(num.get(i)+1)-c.indexOf(num.get(i)+1)+1;\n\t\t\t\t\t\t//System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\tdiff+=count[num.get(i)]-same;\n\t\t\t\t\t} else diff += count[num.get(i)];\n\t\t\t\t\tdata[i][0] = (count[num.get(i)] - diff)/count[num.get(i)];  //割り合い\n\t\t\t\t\tdata[i][1] = diff;\n\t\t\t\t\tif (data[i][0] > dmax) {\n\t\t\t\t\t\tdmax = data[i][0];\n\t\t\t\t\t\tdposit = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin += data[dposit][1];\n\t\t\t\tnow--;\n\t\t\t}\n\t\t\tSystem.out.println(min+1);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Plush Toys\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint N, M;\n\t\tN = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tM = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[] P = new int[N];\n\t\tint[] C = new int[M];\n\t\tint[] S = new int[1 << M];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tP[i] = parseInt(br.readLine()) - 1;\n\t\t\tC[P[i]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 1) {\n\t\t\t\t\tS[i] += C[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dp = new int[1 << M];\n\n\t\tArrays.fill(dp, INF);\n\t\tdp[0] = 0;\n\n\t\tfor (int i = 0; i < 1 << M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif ((i >> j & 1) == 0) {\n\t\t\t\t\tint diff = 0;\n\t\t\t\t\tfor (int k = 0; k < C[j]; k++) {\n\t\t\t\t\t\tif (P[S[i] + k] != j) diff++;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i | 1 << j] = Math.min(dp[i | 1 << j], dp[i] + diff);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[(1 << M) - 1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t\t List<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[a]));\n\t\t\t\t\t List<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\t copy.addAll(c);\n\t\t\t\t\t if (c.contains(a+1)) {\n\t\t\t\t\t\t Collections.sort(c);\n\t\t\t\t\t\t int same = c.lastIndexOf(a+1)-c.indexOf(a+1)+1;\n\t\t\t\t\t\t //System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\t diff+=count[a]-same;\n\t\t\t\t\t } else diff += count[a];\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tint[] shelf = new int[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) {\n\t\t\t\tnum.add(i);\n\t\t\t}\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t\t for (int i=pointer; i<pointer+count[a];i++) {\n\t\t\t\t\t\t if (shelf[i]!=a+1) diff++;\n\t\t\t\t\t }\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//listを配列に変更したバージョン\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint spaceNum = sc.nextInt();\n\t\tint dollTypeNum = sc.nextInt();\n\t\tint space[] = new int[spaceNum];  //棚の初期状態\n\t\tint dollType[] = new int[dollTypeNum];  //ぬいぐるみが種類ごとにいくつあるか(添え字に注意)\n\t\tint cursor = 0;\n\t\tint count = 0;\n\n\t\tint flag[] = new int[dollTypeNum];  //ぬいぐるみの種類ごとに使用したかどうかを判定するフラグ\n\n\t\tfor(int i = 0; i < spaceNum; i++) {\n\t\t\tspace[i] = sc.nextInt();\n\t\t\tfor(int j = 1; j <= dollTypeNum; j++) {\n\t\t\t\tif(space[i] == j) {\n\t\t\t\t\tdollType[j - 1]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t////////////////////////////////////////////////////////////////////ここまではOK\n\n\t\tfor(int i = 0; i < dollTypeNum; i++) {\n\t\t\tFillIn2 fi = new FillIn2();\n\t\t\tfi.fill_in(cursor, space, flag, dollType);\n\t\t\tcursor += dollType[fi.getNum() - 1];\n\t\t\tcount += fi.getMin();\n\n\t\t\tflag[fi.getNum() - 1] = 1;\n\t\t}\n\n\t\tSystem.out.println(count);\n\t}\n}\n\nclass FillIn2 {\n\tprivate int num = 0;\n\tprivate int min = Integer.MAX_VALUE;\n\t//最小の操作回数で埋められるぬいぐるみ番号を探すメソッド\n\t/*  fill_in_in_order(埋める開始点, 操作前のぬいぐるみ配列, 埋め終わってないぬいぐるみ番号を入れたリスト,\n\tぬいぐるみ番号別の個数を入れた配列);  */\n\tpublic void fill_in(int start, int[] array, int[] flag, int[] type) {\n\t\tint cursor;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < flag.length; i++) {  //埋め終わってないぬいぐるみ番号のループ\n\t\t\tcursor = start;\n\t\t\tcount = 0;\n\t\t\tif(flag[i] == 0) {\n\t\t\t\tfor(int j = 0; j < type[i]; j++) {  //その番号のぬいぐるみの個数のループ\n\t\t\t\t\tif(array[cursor] == i + 1) count++;\n\t\t\t\t\tcursor++;\n\t\t\t\t}\n\t\t\t\tif(type[i] - count < min) {\n\t\t\t\t\t//iのforループを回してここで求めたnumが最小操作回数で埋められるぬいぐるみ番号、minがその操作回数\n\t\t\t\t\tnum = i + 1;\n\t\t\t\t\tmin = type[i] - count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int getNum() {\n\t\treturn this.num;\n\t}\n\n\tpublic int getMin() {\n\t\treturn this.min;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t //System.out.println(l);\n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t\t List<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[a]));\n\t\t\t\t\t List<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\t copy.addAll(c);\n\t\t\t\t\t //System.out.println(copy + \"   \" + (a+1));\n\t\t\t\t\t while (copy.contains(Integer.valueOf(a+1))) {\n\t\t\t\t\t\t copy.remove(Integer.valueOf(a+1));\n\t\t\t\t\t }\n\t\t\t\t\t diff+=copy.size();\n\t\t\t\t\t //System.out.println(copy + \"   \" + diff);\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t    \n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t     if (diff > min) break;\n\t\t\t\t\t List<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[a]));\n\t\t\t\t\t List<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\t copy.addAll(c);\n\t\t\t\t\t if (c.contains(a+1)) {\n\t\t\t\t\t\t Collections.sort(c);\n\t\t\t\t\t\t int same = c.lastIndexOf(a+1)-c.indexOf(a+1)+1;\n\t\t\t\t\t\t //System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\t diff+=count[a]-same;\n\t\t\t\t\t } else diff += count[a];\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main_JOI_Prelim2017_0633 {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t //System.out.println(l);\n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t\t List<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[a]));\n\t\t\t\t\t List<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\t copy.addAll(c);\n\t\t\t\t\t //System.out.println(copy + \"   \" + (a+1));\n\t\t\t\t\t while (copy.contains(Integer.valueOf(a+1))) {\n\t\t\t\t\t\t copy.remove(Integer.valueOf(a+1));\n\t\t\t\t\t }\n\t\t\t\t\t diff+=copy.size();\n\t\t\t\t\t //System.out.println(copy + \"   \" + diff);\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tMap<String,int[]> database = new TreeMap<>();  //0:pointer 1:数\n\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tInteger[] shelf = new Integer[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\n\t\t\tfor (int i=0; i<type; i++) num.add(i);\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t//System.out.println(l);\n\t\t\t\tint pointer=0;\n\t\t\t\tint turn=type-2;\n\t\t\t\tint diff = 0;\n\t\t\t\twhile (turn >= 0) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tfor (int i=0; i<=turn; i++) s+=l.get(i)+\"/\";  //キー作成\n\t\t\t\t\tif (database.containsKey(s)) {\n\t\t\t\t\t\t//System.out.println(\"キー発見： \"+s);\n\t\t\t\t\t\tpointer+=database.get(s)[0];\n\t\t\t\t\t\tdiff+=database.get(s)[1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tturn--;\n\t\t\t\t}\n\t\t\t\tturn++;\n\t\t\t\t//残りの分\n\t\t\t\tfor (int i=turn; i<l.size(); i++) {\n\t\t\t\t\tint a = l.get(i);\n\t\t\t\t\tif (diff > min) break;\n\t\t\t\t\tList<Integer> c = Arrays.asList(Arrays.copyOfRange(shelf, pointer, pointer+count[a]));\n\t\t\t\t\tList<Integer> copy = new ArrayList<Integer>();\n\t\t\t\t\tcopy.addAll(c);\n\t\t\t\t\tif (c.contains(a+1)) {\n\t\t\t\t\t\tCollections.sort(c);\n\t\t\t\t\t\tint same = c.lastIndexOf(a+1)-c.indexOf(a+1)+1;\n\t\t\t\t\t\t//System.out.println(same + \"   \" + c.lastIndexOf(a+1) +\" / \" +  c.indexOf(a+1));\n\t\t\t\t\t\tdiff+=count[a]-same;\n\t\t\t\t\t} else diff += count[a];\n\t\t\t\t\tpointer+=count[a];\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tfor (int j=0; j<=i; j++) s+=l.get(j)+\"/\";  //キー作成\n\t\t\t\t\t//System.out.println(\"キー登録： \"+s);\n\t\t\t\t\tdatabase.put(s, new int[] {pointer,diff});\n\t\t\t\t}\n\t\t\t\tmin = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//listを配列に変更したバージョン\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint spaceNum = sc.nextInt();\n\t\tint dollTypeNum = sc.nextInt();\n\t\tint space[] = new int[spaceNum];  //棚の初期状態\n\t\tint dollType[] = new int[dollTypeNum];  //ぬいぐるみが種類ごとにいくつあるか(添え字に注意)\n\t\tint cursor = 0;\n\t\tint count = 0;\n\n\t\tint flag[] = new int[dollTypeNum];  //ぬいぐるみの種類ごとに使用したかどうかを判定するフラグ\n\n\t\tfor(int i = 0; i < spaceNum; i++) {\n\t\t\tspace[i] = sc.nextInt();\n\t\t\tfor(int j = 1; j <= dollTypeNum; j++) {\n\t\t\t\tif(space[i] == j) {\n\t\t\t\t\tdollType[j - 1]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t////////////////////////////////////////////////////////////////////ここまではOK\n\n\t\tfor(int i = 0; i < dollTypeNum; i++) {\n\t\t\tFillIn2 fi = new FillIn2();\n\t\t\tfi.fill_in(cursor, space, flag, dollType);\n\t\t\tcursor += dollType[fi.getNum() - 1];\n\t\t\tcount += fi.getMin();\n\n\t\t\tflag[fi.getNum() - 1] = 1;\n\t\t}\n\n\t\tSystem.out.println(count);\n\t}\n}\n\nclass FillIn2 {\n\tprivate int num = 0;\n\tprivate float ratio = -1;\n\tprivate int time = 0;  //求める操作回数を入れる変数\n\t//(埋められるまでの操作回数)÷(その番号のぬいぐるみの個数)の割合が低いものから埋めていく\n\t/*  fill_in(埋める開始点, 操作前のぬいぐるみ配列, 埋め終わってないぬいぐるみ番号を判別するフラグ列,\n\tぬいぐるみ番号別の個数を入れた配列);  */\n\tpublic void fill_in(int start, int[] array, int[] flag, int[] type) {\n\t\tint cursor;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < flag.length; i++) {  //埋め終わってないぬいぐるみ番号のループ\n\t\t\tcursor = start;\n\t\t\tcount = 0;\n\t\t\tif(flag[i] == 0) {\n\t\t\t\tfor(int j = 0; j < type[i]; j++) {  //その番号のぬいぐるみの個数のループ\n\t\t\t\t\t//System.out.println(j + \" \" + cursor);\n\n\t\t\t\t\tif(array[cursor] == i + 1) count++;\n\t\t\t\t\tcursor++;\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"count:\" + count + \" ratio:\" + (float)(count) / (float)(type[i]));\n\t\t\t\tif((float)(count) / (float)(type[i]) > ratio) {\n\t\t\t\t\t//iのforループを回してここで求めたnumがぬいぐるみ番号、minがその操作回数\n\t\t\t\t\tnum = i + 1;\n\t\t\t\t\ttime = type[i] - count;\n\t\t\t\t\tratio = (float)(count) / (float)(type[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"num:\" + num);\n\t\t//System.out.println();\n\t}\n\n\n\tpublic int getNum() {\n\t\treturn this.num;\n\t}\n\n\tpublic int getMin() {\n\t\treturn this.time;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint space = sc.nextInt();\n\t\t\tint type = sc.nextInt();\n\t\t\tint[] shelf = new int[space];\n\t\t\tint[] count = new int[type];\n\t\t\tList<Integer> num = new ArrayList<Integer>(type);\n\t\t\tfor (int i=0; i<space; i++) {\n\t\t\t\tint j =sc.nextInt();\n\t\t\t\tshelf[i]=j;\n\t\t\t\tcount[j-1]++;\n\t\t\t}\n\t\t\tfor (int i=0; i<type; i++) {\n\t\t\t\tnum.add(i);\n\t\t\t}\n\n\t\t\tList<List<Integer>> p = new ArrayList<List<Integer>>();\n\t\t\tp = permutation2(p,num,new ArrayList<Integer>());\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (List<Integer> l : p) {\n\t\t\t\t int pointer=0;\n\t\t\t\t int diff = 0;\n\t\t\t\t for (int a:l) {\n\t\t\t\t\t if (diff>min) break;\n\t\t\t\t\t for (int i=pointer; i<pointer+count[a];i++) {\n\t\t\t\t\t\t if (shelf[i]!=a+1) diff++;\n\t\t\t\t\t }\n\t\t\t\t\t pointer+=count[a];\n\t\t\t\t }\n\t\t\t\t min = Math.min(min, diff);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\t//数字版（List型）\n\tstatic List<List<Integer>> permutation2(List<List<Integer>>list,List<Integer> input, List<Integer> ans) {  //順列で範囲の順番をすべて計算\n\t\tif (input.size() <= 1) {\n\t\t\tList<Integer> l = new ArrayList<Integer>(ans); //最後の数字はここでくっつく\n\t\t\tl.addAll(input);\n\t\t\tlist.add(l);  //listに組み合わせを追加\n\t\t} else {\n\t\t\tfor (int i=0; i<input.size(); i++) {  //inputの1、2、3…個目を分離して、残りの方に挿入する\n\t\t\t\tList<Integer> i1 = new ArrayList<Integer>();\n\t\t\t\tfor (int j=0; j<i;j++) i1.add(input.get(j));\n\t\t\t\tfor (int j=i+1; j<input.size();j++) i1.add(input.get(j));\n\t\t\t\tList<Integer> i2 = new ArrayList<Integer>(ans);\n\t\t\t\ti2.add(input.get(i));\n\t\t\t\tpermutation2(list ,i1, i2); //空白を入れる\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\tstatic int N;\n\tstatic int M;\n\tstatic int[] ar;\n\tstatic int[] c;\n\tstatic int INF = 2 << 28;\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tar = new int[N];\n\t\tc  = new int[M];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tar[i] = sc.nextInt()-1;\n\t\t\tc[ar[i]]++;\n\t\t}\n\t\tint[][] dp = new int[M+1][1 << M];\n\t\tint[][] dd = new int[M+1][1 << M];\n\t\t\n\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t\tArrays.fill(dd[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdd[0][0] = 0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint tmp = dd[i][j];\n\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tint next = j & (1 << k);\n\t\t\t\t\tint sum  = 0;\n\t\t\t\t\tfor(int l = 0; l < c[k]; l++) {\n\t\t\t\t\t\tif(ar[l + tmp] != k) sum++;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+1][j | (1 << k)] = Math.min(dp[i+1][j | (1 << k)], dp[i][j] + sum);\n\t\t\t\t\tdd[i+1][j | (1 << k)] = tmp + c[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[dp.length-1][dp[0].length-1]);\n\t\t\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var m = int.Parse(line[1]);\n        var a = new int[n];\n        var c = new int[m + 1];\n        var dp = new int[(1 << m)];\n        for (int i = 0; i < 1 << m; i++) dp[i] = 99999999;\n        dp[0] = 0;\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = int.Parse(Console.ReadLine().Trim());\n            c[a[i]]++;\n        }\n        var b = new int[m + 1, n + 1];\n        for (int i = 0; i < n; i++)\n            for (int j = 1; j <= m; j++)\n            {\n                if (a[i] == j) b[j, i + 1] = b[j, i] + 1;\n                else b[j, i + 1] = b[j, i];\n            }\n        var ans = getAns(b, c, m, dp);\n        Console.WriteLine(ans);\n    }\n    static int getAns(int[,] b, int[] c, int m, int[] dp)\n    {\n        var imax = 1 << m;\n        for (int i = 0; i < imax; i++)\n        {\n            var t = 0;\n            for (int j = 1; j <= m; j++)\n                if (((i >> (j - 1)) & 1) == 1) t += c[j];\n            for (int j = 1; j <= m; j++)\n                if (((i >> (j - 1)) & 1) == 0)\n                {\n                    var w = (i | (1 << (j - 1)));\n                    var w2 = c[j] - (b[j, t + c[j]] - b[j, t]);\n                    dp[w] = Min(dp[w], dp[i] + w2);\n                }\n        }\n        return dp[imax - 1];\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace _0633\n{\n\tclass Program\n\t{\n\t\tstatic int limit;\n\t\tstatic int list_int(List<int> list)\n\t\t{\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < limit; i++)\n\t\t\t{\n\t\t\t\tif (list.Contains(i)) ret += 1 << i;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\tlimit = x[1];\n\t\t\tint[] toys = new int[x[0]]; int[] counts = new int[x[1]];\n\t\t\tfor (int i = 0; i < x[0]; i++)\n\t\t\t{\n\t\t\t\tint b = int.Parse(Console.ReadLine());b--;\n\t\t\t\ttoys[i] = b; counts[b]++;\n\t\t\t}\n\t\t\tList<List<int>>[] kouho = new List<List<int>>[limit + 1];\n\t\t\tfor (int i = 0; i <= limit; i++) kouho[i] = new List<List<int>>();\n\t\t\tfor (int i = 0; i < (1 << limit); i++)\n\t\t\t{\n\t\t\t\tList<int> now = new List<int>(); int count = 0;\n\t\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((i & 1 << j) > 0) { now.Add(j); count++; }\n\t\t\t\t}\n\t\t\t\tkouho[count].Add(now);\n\t\t\t}\n\t\t\tTuple<int, int>[] dp = new Tuple<int, int>[(int)Math.Pow(2, limit)];//cost count\n\t\t\tdp[0] = new Tuple<int, int>(0, 0);\n\t\t\tfor (int i = 1; i <= x[1]; i++)\n\t\t\t{\n\t\t\t\tforeach (var list in kouho[i])\n\t\t\t\t{\n\t\t\t\t\tint code = list_int(list);\n\t\t\t\t\tTuple<int, int> min = new Tuple<int, int>(int.MaxValue, 0);\n\t\t\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((code & 1 << j) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint now = dp[code ^ (1 << j)].Item1;\n\t\t\t\t\t\t\tfor (int k = 0; k < counts[j]; k++)\n\t\t\t\t\t\t\t\tif (toys[dp[code ^ (1 << j)].Item2 + k] != j) now++;\n\t\t\t\t\t\t\tif (now < min.Item1) min = new Tuple<int, int>(now, dp[code ^ (1 << j)].Item2 + counts[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[code] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(dp[(1 << limit) - 1].Item1);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace _0633\n{\n\tclass Program\n\t{\n\t\tstatic int limit;\n\t\tstatic int list_int(List<int> list)\n\t\t{\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < limit; i++)\n\t\t\t{\n\t\t\t\tif (list.Contains(i)) ret += 1 << i;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\tlimit = x[1];\n\t\t\tint[] toys = new int[x[0]]; int[] counts = new int[limit];\n\t\t\tfor (int i = 0; i < x[0]; i++)\n\t\t\t{\n\t\t\t\tint b = int.Parse(Console.ReadLine());b--;\n\t\t\t\ttoys[i] = b; counts[b]++;\n\t\t\t}\n\t\t\tList<List<int>>[] kouho = new List<List<int>>[limit + 1];\n\t\t\tfor (int i = 0; i <= limit; i++) kouho[i] = new List<List<int>>();\n\t\t\tfor (int i = 0; i < (1 << limit); i++)\n\t\t\t{\n\t\t\t\tList<int> now = new List<int>(); int count = 0;\n\t\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((i & 1 << j) > 0) { now.Add(j); count++; }\n\t\t\t\t}\n\t\t\t\tkouho[count].Add(now);\n\t\t\t}\n\t\t\tint[,] changesum = new int[limit, x[0]+1];\n\t\t\tfor (int i = 0; i < limit; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < x[0]; j++)\n\t\t\t\t{\n\t\t\t\t\tchangesum[i, j + 1] = changesum[i, j];\n\t\t\t\t\tif (toys[j] != i) changesum[i, j + 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tTuple<int, int>[] dp = new Tuple<int, int>[(int)Math.Pow(2, limit)];//cost count\n\t\t\tdp[0] = new Tuple<int, int>(0, 0);\n\t\t\tfor (int i = 1; i <= x[1]; i++)\n\t\t\t{\n\t\t\t\tforeach (var list in kouho[i])\n\t\t\t\t{\n\t\t\t\t\tint code = list_int(list);\n\t\t\t\t\tTuple<int, int> min = new Tuple<int, int>(int.MaxValue, 0);\n\t\t\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((code & 1 << j) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar before = dp[code ^ (1 << j)];\n\t\t\t\t\t\t\tint now = before.Item1;\n\t\t\t\t\t\t\tnow += changesum[j, before.Item2 + counts[j]] - changesum[j, before.Item2];\n\t\t\t\t\t\t\tif (now < min.Item1) min = new Tuple<int, int>(now, before.Item2 + counts[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[code] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(dp[(1 << limit) - 1].Item1);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace _0633\n{\n\tclass Program\n\t{\n\t\tstatic int limit;\n\t\tstatic int list_int(List<int> list)\n\t\t{\n\t\t\tint ret = 0;\n\t\t\tfor (int i = 0; i < limit; i++)\n\t\t\t{\n\t\t\t\tif (list.Contains(i)) ret += 1 << i;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\tlimit = x[1];\n\t\t\tint[] toys = new int[x[0]]; int[] counts = new int[x[1]];\n\t\t\tfor (int i = 0; i < x[0]; i++)\n\t\t\t{\n\t\t\t\tint b = int.Parse(Console.ReadLine());b--;\n\t\t\t\ttoys[i] = b; counts[b]++;\n\t\t\t}\n\t\t\tList<List<int>>[] kouho = new List<List<int>>[limit + 1];\n\t\t\tfor (int i = 0; i <= limit; i++) kouho[i] = new List<List<int>>();\n\t\t\tfor (int i = 0; i < (1 << limit); i++)\n\t\t\t{\n\t\t\t\tList<int> now = new List<int>(); int count = 0;\n\t\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((i & 1 << j) > 0) { now.Add(j); count++; }\n\t\t\t\t}\n\t\t\t\tkouho[count].Add(now);\n\t\t\t}\n\t\t\tTuple<int, int>[] dp = new Tuple<int, int>[(int)Math.Pow(2, limit)];//cost count\n\t\t\tdp[0] = new Tuple<int, int>(0, 0);\n\t\t\tfor (int i = 1; i <= x[1]; i++)\n\t\t\t{\n\t\t\t\tforeach (var list in kouho[i])\n\t\t\t\t{\n\t\t\t\t\tint code = list_int(list);\n\t\t\t\t\tTuple<int, int> min = new Tuple<int, int>(int.MaxValue, 0);\n\t\t\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((code & 1 << j) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint now = dp[code ^ (1 << j)].Item1;\n\t\t\t\t\t\t\tfor (int k = 0; k < counts[j]; k++)\n\t\t\t\t\t\t\t\tif (toys[dp[code ^ (1 << j)].Item2 + k] != j) now++;\n\t\t\t\t\t\t\tif (now < min.Item1) min = new Tuple<int, int>(now, dp[code ^ (1 << j)].Item2 + counts[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[code] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(dp[(1 << limit) - 1].Item1);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn, m = map(int, raw_input().split())\ncnt = [0 for _ in range(n)]\ncntS = [[0 for _ in range(n)] for _ in range(m)]\n\nfor i in range(n):\n  k = input()-1\n  cnt[k] += 1\n  cntS[k][i] = 1\n\nfor k in range(m):\n  for i in range(n-1):\n    cntS[k][i+1] += cntS[k][i]\n\ndp = [sys.maxint/4 for _ in range(1<<m)]\ndp[0] = 0\n\nfor S in range((1<<m)-1):\n  for k in range(m):\n    if not (S>>k&1):\n      idx = 0\n      for i in range(m):\n        if S>>i&1:\n          idx += cnt[i]\n\n      if idx+cnt[k] <= n:\n        dp[S|1<<k] = min(dp[S|1<<k], dp[S] + cnt[k]-(cntS[k][idx+cnt[k]-1]-(cntS[k][idx-1] if idx-1>=0 else 0)))\n     \nprint dp[(1<<m)-1]"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\ndef minimum_cost(rest, init, dic):\n  if rest in dic:\n    return dic[rest]\n\n  if rest == ():\n    return 0\n\n  ret = INF\n  for nex in rest:\n    nex_init = init + acc[nex]\n    ret = min(ret, minimum_cost(tuple(i for i in rest if i != nex), nex_init, dic) +\\\n                   acc[nex] - (cums[nex][nex_init] - cums[nex][init]))\n  dic[rest] = ret\n  return ret\n\nn, m = map(int, input().split())\nacc = [0] * m\ncums = [[0] for _ in range(m)]\nfor _ in range(n):\n  acc[int(input()) - 1] += 1\n  for i in range(m):\n    cums[i].append(acc[i])\n\ndic = {}\nprint(minimum_cost(tuple(i for i in range(m)), 0, dic))\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n  def minimum_cost(rest, h, init, dic):\n    if h in dic:\n      return dic[h]\n  \n    if not h:\n      return 0\n  \n    ret = INF\n    for nex in rest:\n      accnex = acc[nex]\n      cumsnex = cums[nex]\n      nex_init = init + accnex\n      nex_rest = rest[:]\n      nex_rest.remove(nex)\n      nex_h = h - 2 ** nex\n      tmp =  minimum_cost(nex_rest, nex_h, nex_init, dic) +\\\n                     accnex - (cumsnex[nex_init] - cumsnex[init])\n      if ret > tmp:\n        ret = tmp\n    dic[h] = ret\n    return ret\n  \n  n, m = map(int, input().split())\n  acc = [0] * m\n  cums = [[0] for _ in range(m)]\n  for _ in range(n):\n    acc[int(input()) - 1] += 1\n    for i in range(m):\n      cums[i].append(acc[i])\n  \n  dic = {}\n  h = sum([2 ** i for i in range(m)])\n  print(minimum_cost([i for i in range(m)], h, 0, dic))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn, m = map(int, raw_input().split())\ncnt = [0 for _ in range(n)]\ncntS = [[0 for _ in range(n)] for _ in range(m)]\n\nfor i in range(n):\n  k = input()-1\n  cnt[k] += 1\n  cntS[k][i] = 1\n\nfor k in range(m):\n  for i in range(n-1):\n    cntS[k][i+1] += cntS[k][i]\n\ndp = [sys.maxint/4 for _ in range(1<<m)]\ndp[0] = 0\n\nidx = [0 for _ in range(1<<m)]\nfor S in range((1<<m)-1):\n  for i in range(m):\n    if S>>i&1:\n      idx[S] += cnt[i]\n\nfor S in range((1<<m)-1):\n  for k in range(m):\n    if not (S>>k&1):\n      if idx[S]+cnt[k] <= n:\n        dp[S|1<<k] = min(dp[S|1<<k], dp[S] + cnt[k]-(cntS[k][idx[S]+cnt[k]-1]-(cntS[k][idx[S]-1] if idx[S]-1>=0 else 0)))\n     \nprint dp[(1<<m)-1]"
  },
  {
    "language": "Python",
    "code": "def main():\n    N,M = map(int,input().split())\n    a = [int(input())-1 for _ in N*[0]]\n    sum = [N*[0] for _ in 20*[0]]\n    cnt = 20*[0]\n    ans_bit = 0\n    for i in range(N):\n        ans_bit = ans_bit | (1<<a[i])\n        cnt[a[i]] += 1\n        sum[a[i]][i] += 1\n        if i-1 >= 0:\n            for j in range(20):\n                sum[j][i] += sum[j][i-1]\n    dp = [10**9]*(1<<20)\n    dp[0] = 0\n    for bit in range(1<<20):\n        if( dp[bit] == 10**9 ):\n            continue\n        v = 0\n        for used in range(20):\n            if( (bit>>used) & 1 ):\n                v += cnt[used]\n        for use in range(20):\n            if( cnt[use] == 0 ):\n                continue\n            if( (bit>>use) & 1 ):\n                continue\n            w = v + cnt[use]\n            not_move = sum[use][w-1]\n            if( v-1 >= 0 ):\n                not_move -= sum[use][v-1]\n            move = cnt[use] - not_move\n            dp[bit|(1<<use)] = min(dp[bit|(1<<use)],\n                                   dp[bit]+move)\n    print(dp[ans_bit])\n            \n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n  def minimum_cost(rest, init, dic):\n    if rest in dic:\n      return dic[rest]\n  \n    if rest == ():\n      return 0\n  \n    ret = INF\n    for nex in rest:\n      accnex = acc[nex]\n      cumsnex = cums[nex]\n      nex_init = init + accnex\n      tmp =  minimum_cost(tuple([i for i in rest if i != nex]), nex_init, dic) +\\\n                     accnex - (cumsnex[nex_init] - cumsnex[init])\n      if ret > tmp:\n        ret = tmp\n    dic[rest] = ret\n    return ret\n  \n  n, m = map(int, input().split())\n  acc = [0] * m\n  cums = [[0] for _ in range(m)]\n  for _ in range(n):\n    acc[int(input()) - 1] += 1\n    for i in range(m):\n      cums[i].append(acc[i])\n  \n  dic = {}\n  print(minimum_cost(tuple(i for i in range(m)), 0, dic))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nD = [[0]*(N+1) for i in range(M)]\ncnts = [0]*M\nfor i in range(N):\n    v = int(input())\n    cnts[v-1] += 1\n    D[v-1][i+1] = 1\nfor i in range(M):\n    d = D[i]\n    for j in range(1, N+1):\n        d[j] += d[j-1]\nmemo = [None]*(2**M)\nmemo[2**M-1] = 0\ndef dfs(state, idx):\n    if memo[state] is not None:\n        return memo[state]\n    res = N\n    for i in range(M):\n        if state & (1 << i) == 0:\n            need = cnts[i] - (D[i][cnts[i] + idx] - D[i][idx])\n            res = min(res, need + dfs(state | (1 << i), idx + cnts[i]))\n    memo[state] = res\n    return res\nprint(dfs(0, 0))"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nN2 = 2**N.bit_length()\nD = [[0]*(N2+1) for i in range(M)]\ndef get(i, k):\n    data = D[i]\n    s = 0\n    while k:\n        s += data[k]\n        k -= k & -k\n    return s\ndef add(i, k, x):\n    data = D[i]\n    while k <= N2:\n        data[k] += x\n        k += k & -k\ncnts = [0]*M\nfor i in range(N):\n    v = int(input())\n    cnts[v-1] += 1\n    add(v-1, i+1, 1)\nmemo = {2**M-1: 0}\ndef dfs(state, idx):\n    if state in memo:\n        return memo[state]\n    res = N\n    for i in range(M):\n        if state & (1 << i) == 0:\n            need = cnts[i] - (get(i, cnts[i] + idx) - get(i, idx))\n            res = min(res, need + dfs(state | (1 << i), idx + cnts[i]))\n    memo[state] = res\n    return res\nprint(dfs(0, 0))"
  }
]