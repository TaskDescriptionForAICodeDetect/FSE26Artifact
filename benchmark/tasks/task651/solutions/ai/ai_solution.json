[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX_R 100\n#define MAX_C 100\n#define MAX_K 1000\n\nint R, C, K;\nint grid[MAX_R+1][MAX_C+1];\nint item_counts[MAX_R+1];\nint dp[MAX_R+1][MAX_C+1][4];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve() {\n    memset(dp, 0, sizeof(dp));\n    memset(item_counts, 0, sizeof(item_counts));\n\n    for (int i = 0; i < K; i++) {\n        int r, c, v;\n        scanf(\"%d %d %d\", &r, &c, &v);\n        grid[r][c] += v;\n    }\n\n    for (int r = 1; r <= R; r++) {\n        for (int c = 1; c <= C; c++) {\n            for (int k = 0; k <= 3; k++) {\n                if (grid[r][c] && item_counts[r] < 3) {\n                    dp[r][c][k+1] = max(dp[r][c][k+1], dp[r][c-1][k] + grid[r][c]);\n                    dp[r][c][k+1] = max(dp[r][c][k+1], dp[r-1][c][k] + grid[r][c]);\n                } else {\n                    dp[r][c][k] = max(dp[r][c][k], dp[r][c-1][k]);\n                    dp[r][c][k] = max(dp[r][c][k], dp[r-1][c][k]);\n                }\n            }\n        }\n    }\n\n    return dp[R][C][3];\n}\n\nint main() {\n    scanf(\"%d %d %d\", &R, &C, &K);\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_R 3005\n#define MAX_C 3005\n\ntypedef struct {\n    int r, c, v;\n} Item;\n\nint cmp(const void *a, const void *b) {\n    Item *ia = (Item *)a;\n    Item *ib = (Item *)b;\n    if (ia->r != ib->r) return ia->r - ib->r;\n    return ia->c - ib->c;\n}\n\nlong long dp[MAX_R][MAX_C][4];\nItem items[MAX_R * MAX_C];\n\nint main() {\n    int R, C, K;\n    scanf(\"%d %d %d\", &R, &C, &K);\n    \n    for (int i = 0; i < K; i++) {\n        scanf(\"%d %d %d\", &items[i].r, &items[i].c, &items[i].v);\n    }\n    \n    qsort(items, K, sizeof(Item), cmp);\n    \n    int item_idx = 0;\n    memset(dp, -1, sizeof(dp));\n    dp[1][1][0] = 0;\n    \n    for (int i = 1; i <= R; i++) {\n        for (int j = 1; j <= C; j++) {\n            while (item_idx < K && items[item_idx].r == i && items[item_idx].c == j) {\n                for (int k = 2; k >= 0; k--) {\n                    if (dp[i][j][k] != -1) {\n                        if (dp[i][j][k+1] < dp[i][j][k] + items[item_idx].v) {\n                            dp[i][j][k+1] = dp[i][j][k] + items[item_idx].v;\n                        }\n                    }\n                }\n                item_idx++;\n            }\n            \n            for (int k = 0; k <= 3; k++) {\n                if (dp[i][j][k] == -1) continue;\n                if (i + 1 <= R) {\n                    if (dp[i+1][j][0] < dp[i][j][k]) {\n                        dp[i+1][j][0] = dp[i][j][k];\n                    }\n                }\n                if (j + 1 <= C) {\n                    if (dp[i][j+1][k] < dp[i][j][k]) {\n                        dp[i][j+1][k] = dp[i][j][k];\n                    }\n                }\n            }\n        }\n    }\n    \n    long long max = 0;\n    for (int k = 0; k <= 3; k++) {\n        if (dp[R][C][k] > max) {\n            max = dp[R][C][k];\n        }\n    }\n    \n    printf(\"%lld\\n\", max);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    int R, C, K;\n    cin >> R >> C >> K;\n    vector<vector<int>> grid(R + 1, vector<int>(C + 1, 0));\n    for (int i = 0; i < K; ++i) {\n        int r, c, v;\n        cin >> r >> c >> v;\n        grid[r][c] = v;\n    }\n\n    vector<vector<vector<long long>>> dp(R + 1, vector<vector<long long>>(C + 1, vector<long long>(4, 0)));\n\n    for (int i = 1; i <= R; ++i) {\n        for (int j = 1; j <= C; ++j) {\n            for (int k = 0; k <= 3; ++k) {\n                // Move from left\n                if (j > 1) {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);\n                }\n                // Move from top\n                if (i > 1) {\n                    long long max_prev = *max_element(dp[i - 1][j].begin(), dp[i - 1][j].end());\n                    dp[i][j][k] = max(dp[i][j][k], max_prev);\n                }\n            }\n            // Pick the current item if possible\n            if (grid[i][j] > 0) {\n                for (int k = 3; k >= 1; --k) {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1] + grid[i][j]);\n                }\n            }\n        }\n    }\n\n    long long ans = *max_element(dp[R][C].begin(), dp[R][C].end());\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int R = sc.nextInt();\n        int C = sc.nextInt();\n        int K = sc.nextInt();\n\n        List<List<int[]>> items = new ArrayList<>();\n        for (int i = 0; i <= R; i++) {\n            items.add(new ArrayList<>());\n        }\n        for (int i = 0; i < K; i++) {\n            int r = sc.nextInt();\n            int c = sc.nextInt();\n            int v = sc.nextInt();\n            items.get(r).add(new int[]{c, v});\n        }\n\n        long[][][] dp = new long[R + 2][C + 2][4];\n        for (int i = 1; i <= R; i++) {\n            Collections.sort(items.get(i), (a, b) -> Integer.compare(a[0], b[0()));\n            for (int j = 1; j <= C; j++) {\n                for (int k = 0; k <= 3; k++) {\n                    dp[i][j][k] = Math.max(dp[i - 1][j][3], dp[i][j - 1][k]);\n                }\n                for (int[] item : items.get(i)) {\n                    if (item[0] == j) {\n                        for (int k = 3; k >= 1; k--) {\n                            dp[i][j][k] = Math.max(dp[i][j][k], dp[i][j][k - 1] + item[1]);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(dp[R][C][3]);\n    }\n}",
    "timestamp": "2025-08-05 22:27:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxItemCollector {\n    public static int collectMaxItems(int R, int C, int K, int[] rows, int[] cols, int[] values) {\n        int[][] grid = new int[R + 1][C + 1];\n        List<int[]> items = new ArrayList<>();\n        \n        for (int i = 0; i < K; i++) {\n            grid[rows[i]][cols[i]] = values[i];\n            items.add(new int[]{rows[i], cols[i], values[i]});\n        }\n        \n        int[][] dp = new int[R + 1][C + 1];\n        int[][][] itemCount = new int[R + 1][C + 1][4];\n        \n        for (int r = 1; r <= R; r++) {\n            for (int c = 1; c <= C; c++) {\n                dp[r][c] = dp[r - 1][c] > dp[r][c - 1] ? dp[r - 1][c] : dp[r][c - 1];\n                \n                for (int k = 0; k < 3; k++) {\n                    itemCount[r][c][k] = Math.max(itemCount[r - 1][c][k], itemCount[r][c - 1][k]);\n                }\n                \n                if (grid[r][c] > 0) {\n                    for (int k = 2; k >= 0; k--) {\n                        if (itemCount[r][c][k] < 3) {\n                            int newVal = dp[r][c] + grid[r][c];\n                            int[] newItemCount = Arrays.copyOf(itemCount[r][c], 4);\n                            newItemCount[k + 1]++;\n                            \n                            if (newVal > dp[r][c]) {\n                                dp[r][c] = newVal;\n                                itemCount[r][c] = newItemCount;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[R][C];\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int R = scanner.nextInt();\n        int C = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        int[] rows = new int[K];\n        int[] cols = new int[K];\n        int[] values = new int[K];\n        \n        for (int i = 0; i < K; i++) {\n            rows[i] = scanner.nextInt();\n            cols[i] = scanner.nextInt();\n            values[i] = scanner.nextInt();\n        }\n        \n        int result = collectMaxItems(R, C, K, rows, cols, values);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:27:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXR = 2000;\nconst int MAXC = 2000;\n\nint main() {\n    int R, C, K;\n    cin >> R >> C >> K;\n\n    vector<vector<int>> grid(R+1, vector<int>(C+1, 0));\n    vector<vector<pair<int, int>>> items(R+1);\n\n    for (int i = 0; i < K; i++) {\n        int r, c, v;\n        cin >> r >> c >> v;\n        items[r].push_back({c, v});\n    }\n\n    for (int r = 1; r <= R; r++) {\n        sort(items[r].begin(), items[r].end(), \n            [](const pair<int, int>& a, const pair<int, int>& b) {\n                return a.second > b.second;\n            });\n    }\n\n    vector<vector<vector<int>>> dp(R+1, vector<vector<int>>(C+1, vector<int>(4, 0)));\n\n    for (int r = 1; r <= R; r++) {\n        for (int c = 1; c <= C; c++) {\n            for (int k = 0; k <= 3; k++) {\n                dp[r][c][0] = max(dp[r][c][0], dp[r][c-1][k]);\n                dp[r][c][0] = max(dp[r][c][0], dp[r-1][c][k]);\n\n                for (int j = 0; j < min(k+1, (int)items[r].size()); j++) {\n                    if (items[r][j].first == c) {\n                        dp[r][c][k+1] = max(dp[r][c][k+1], \n                            max(dp[r][c-1][k] + items[r][j].second,\n                                dp[r-1][c][k] + items[r][j].second));\n                    }\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int k = 0; k <= 3; k++) {\n        result = max(result, dp[R][C][k]);\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:27:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_value_sum(r, c, k, items):\n    item_grid = [[] for _ in range(r)]\n    \n    for ri, ci, vi in items:\n        item_grid[ri - 1].append((ci, vi))\n    \n    for row in item_grid:\n        row.sort()\n\n    dp = [[0] * 4 for _ in range(c + 1)]\n    \n    for i in range(r):\n        new_dp = [[0] * 4 for _ in range(c + 1)]\n        \n        for j in range(1, c + 1):\n            new_dp[j][0] = max(dp[j][0], new_dp[j - 1][0])\n            for t in range(1, 4):\n                new_dp[j][t] = max(dp[j][t], new_dp[j][t - 1])\n                new_dp[j][t] = max(new_dp[j][t], new_dp[j - 1][t])\n\n            current_sum = 0\n            item_count = 0\n            for col, value in item_grid[i]:\n                if col == j:\n                    current_sum += value\n                    item_count += 1\n                    for t in range(3, 0, -1):\n                        if t <= item_count:\n                            new_dp[j][t] = max(new_dp[j][t], new_dp[j - 1][t - 1] + current_sum)\n                        if t > item_count:\n                            new_dp[j][t] = max(new_dp[j][t], new_dp[j - 1][t] + current_sum)\n\n        dp = new_dp\n\n    return max(dp[c])\n\n# Setup for testing\nr = 3\nc = 3\nk = 5\nitems = [(1, 2, 3), (2, 2, 5), (3, 3, 2), (1, 3, 6), (2, 3, 1)]\nprint(max_value_sum(r, c, k, items))",
    "timestamp": "2025-08-13 10:47:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxItemCollection {\n\n    static class Item {\n        int row, col, value;\n\n        Item(int row, int col, int value) {\n            this.row = row;\n            this.col = col;\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int R = sc.nextInt();\n        int C = sc.nextInt();\n        int K = sc.nextInt();\n        \n        List<Item>[] itemGrid = new List[R + 1];\n        for (int i = 0; i <= R; i++) {\n            itemGrid[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < K; i++) {\n            int r = sc.nextInt();\n            int c = sc.nextInt();\n            int v = sc.nextInt();\n            itemGrid[r].add(new Item(r, c, v));\n        }\n\n        long[][][] dp = new long[R + 1][C + 1][4];\n\n        for (int r = 1; r <= R; r++) {\n            Collections.sort(itemGrid[r], (a, b) -> a.col - b.col);\n\n            Iterator<Item> iterator = itemGrid[r].iterator();\n            Item currentItem = iterator.hasNext() ? iterator.next() : null;\n\n            for (int c = 1; c <= C; c++) {\n                for (int k = 0; k <= 3; k++) {\n                    dp[r][c][0] = Math.max(dp[r][c][0], dp[r - 1][c][k]);\n                    dp[r][c][0] = Math.max(dp[r][c][0], dp[r][c - 1][k]);\n                }\n\n                for (int k = 0; k < 3; k++) {\n                    dp[r][c][k + 1] = dp[r][c][k];\n                }\n\n                while (currentItem != null && currentItem.col == c) {\n                    for (int k = 2; k >= 0; k--) {\n                        dp[r][c][k + 1] = Math.max(dp[r][c][k + 1], dp[r][c][k] + currentItem.value);\n                    }\n                    currentItem = iterator.hasNext() ? iterator.next() : null;\n                }\n            }\n        }\n\n        long maxSum = 0;\n        for (int k = 0; k <= 3; k++) {\n            maxSum = Math.max(maxSum, dp[R][C][k]);\n        }\n        \n        System.out.println(maxSum);\n    }\n}",
    "timestamp": "2025-08-13 10:47:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int r, c, v;\n} Item;\n\nint compare(const void *a, const void *b) {\n    return ((Item *)b)->v - ((Item *)a)->v;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    int R, C, K;\n    scanf(\"%d %d %d\", &R, &C, &K);\n\n    Item items[K];\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d %d %d\", &items[i].r, &items[i].c, &items[i].v);\n    }\n\n    qsort(items, K, sizeof(Item), compare);\n\n    int dp[R + 1][C + 1][4];\n    memset(dp, 0, sizeof(dp));\n\n    int item_index = 0;\n    for (int r = 1; r <= R; r++) {\n        for (int c = 1; c <= C; c++) {\n            for (int k = 0; k < 4; k++) {\n                dp[r][c][k] = dp[r][c - 1][k];\n                if (k > 0) {\n                    dp[r][c][k] = max(dp[r][c][k], dp[r][c - 1][k - 1]);\n                }\n                dp[r][c][k] = max(dp[r][c][k], dp[r - 1][c][3]);\n            }\n\n            while (item_index < K && items[item_index].r == r && items[item_index].c == c) {\n                for (int k = 3; k > 0; k--) {\n                    dp[r][c][k] = max(dp[r][c][k], dp[r][c][k - 1] + items[item_index].v);\n                }\n                item_index++;\n            }\n        }\n    }\n\n    int max_value = 0;\n    for (int k = 0; k < 4; k++) {\n        max_value = max(max_value, dp[R][C][k]);\n    }\n\n    printf(\"%d\\n\", max_value);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:47:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxSum(R, C, items) {\n  const dp = Array.from({ length: R + 1 }, () => Array.from({ length: C + 1 }, () => [0, 0, 0, 0]));\n  const itemMap = Array.from({ length: R + 1 }, () => Array.from({ length: C + 1 }, () => []));\n  \n  items.forEach(([r, c, v]) => {\n    itemMap[r][c].push(v);\n  });\n  \n  for (let r = 1; r <= R; r++) {\n    for (let c = 1; c <= C; c++) {\n      // Sort items in decreasing order of value for the current cell.\n      itemMap[r][c].sort((a, b) => b - a);\n      \n      // Take 0 to 3 items from the current cell at (r, c).\n      for (let pick = 0; pick <= Math.min(3, itemMap[r][c].length); pick++) {\n        let sum = itemMap[r][c].slice(0, pick).reduce((acc, v) => acc + v, 0);\n        \n        // Update DP from the top (r-1, c).\n        for (let prevPick = 0; prevPick <= 3 && prevPick + pick <= 3; prevPick++) {\n          dp[r][c][prevPick + pick] = Math.max(dp[r][c][prevPick + pick], dp[r - 1][c][prevPick] + sum);\n        }\n        \n        // Update DP from the left (r, c-1).\n        for (let prevPick = 0; prevPick <= 3 && prevPick + pick <= 3; prevPick++) {\n          dp[r][c][prevPick + pick] = Math.max(dp[r][c][prevPick + pick], dp[r][c - 1][prevPick] + sum);\n        }\n      }\n    }\n  }\n  \n  return Math.max(...dp[R][C]);\n}",
    "timestamp": "2025-08-13 10:47:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(R, C, K, items):\n    # Create a grid to track items\n    grid = [[[] for _ in range(C)] for _ in range(R)]\n    for r, c, v in items:\n        grid[r-1][c-1].append(v)\n    \n    # Sort items in each cell in descending order\n    for r in range(R):\n        for c in range(C):\n            grid[r][c].sort(reverse=True)\n    \n    # DP with states: [row][col][items taken in current row]\n    dp = [[[0] * 4 for _ in range(C)] for _ in range(R)]\n    \n    # Initialize first cell\n    for k in range(min(len(grid[0][0]), 3) + 1):\n        dp[0][0][k] = sum(grid[0][0][:k])\n    \n    # Fill first row\n    for c in range(1, C):\n        for k in range(4):\n            for prev_k in range(4):\n                curr_max = dp[0][c-1][prev_k]\n                take_count = min(k, len(grid[0][c]))\n                curr_max += sum(grid[0][c][:take_count])\n                dp[0][c][k] = max(dp[0][c][k], curr_max)\n    \n    # Fill rest of grid\n    for r in range(1, R):\n        for c in range(C):\n            for k in range(4):\n                # Coming from top\n                for prev_k in range(4):\n                    if prev_k + k <= 3:\n                        curr_max = dp[r-1][c][prev_k]\n                        take_count = min(k, len(grid[r][c]))\n                        curr_max += sum(grid[r][c][:take_count])\n                        dp[r][c][k] = max(dp[r][c][k], curr_max)\n                \n                # Coming from left\n                if c > 0:\n                    for prev_k in range(4):\n                        curr_max = dp[r][c-1][prev_k]\n                        take_count = min(k, len(grid[r][c]))\n                        curr_max += sum(grid[r][c][:take_count])\n                        dp[r][c][k] = max(dp[r][c][k], curr_max)\n    \n    # Return max value at destination\n    return max(dp[R-1][C-1])\n\n# Input parsing and solving\nR, C, K = map(int, input().split())\nitems = []\nfor _ in range(K):\n    r, c, v = map(int, input().split())\n    items.append((r, c, v))\n\nprint(solve(R, C, K, items))",
    "timestamp": "2025-08-13 10:47:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxItemSum(R, C, K, items) {\n    // Create a 2D grid to store maximum value at each cell\n    const dp = Array.from({ length: R }, () => Array(C).fill(0));\n    \n    // Create a 2D grid to track item counts per row\n    const itemCount = Array.from({ length: R }, () => Array(C).fill(0));\n    \n    // Sort items by row and column\n    items.sort((a, b) => {\n        if (a[0] !== b[0]) return a[0] - b[0];\n        return a[1] - b[1];\n    });\n    \n    // Initialize first cell\n    dp[0][0] = 0;\n    \n    // Preprocess items for quick lookup\n    const itemMap = new Map();\n    for (const [r, c, v] of items) {\n        if (!itemMap.has(r-1)) itemMap.set(r-1, []);\n        itemMap.get(r-1).push([c-1, v]);\n    }\n    \n    // Dynamic programming\n    for (let r = 0; r < R; r++) {\n        for (let c = 0; c < C; c++) {\n            // Check if current cell has an item\n            const cellItems = itemMap.get(r)?.filter(item => item[0] === c) || [];\n            \n            // Sort cell items by value in descending order\n            cellItems.sort((a, b) => b[1] - a[1]);\n            \n            // Update max values from previous cells\n            if (r > 0) {\n                dp[r][c] = dp[r-1][c];\n                itemCount[r][c] = itemCount[r-1][c];\n            }\n            if (c > 0) {\n                if (dp[r][c-1] > dp[r][c]) {\n                    dp[r][c] = dp[r][c-1];\n                    itemCount[r][c] = itemCount[r][c-1];\n                }\n            }\n            \n            // Add items respecting the 3-item per row limit\n            for (const [_, value] of cellItems) {\n                if (itemCount[r][c] < 3) {\n                    dp[r][c] += value;\n                    itemCount[r][c]++;\n                }\n            }\n        }\n    }\n    \n    return dp[R-1][C-1];\n}",
    "timestamp": "2025-08-13 10:48:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    R, C, K = map(int, data[idx:idx+3])\n    idx +=3\n    \n    items = [[0]*(C+1) for _ in range(R+1)]\n    for _ in range(K):\n        r, c, v = map(int, data[idx:idx+3])\n        idx +=3\n        items[r][c] = v\n    \n    # DP table: dp[i][j][k] = max value at (i,j) with k items picked in row i\n    dp_prev = [[0]*4 for _ in range(C+2)]\n    \n    for i in range(1, R+1):\n        dp_curr = [[0]*4 for _ in range(C+2)]\n        for j in range(1, C+1):\n            # Not picking the current item\n            for k in range(4):\n                if j > 1:\n                    dp_curr[j][k] = max(dp_curr[j][k], dp_curr[j-1][k])\n                else:\n                    if k == 0:\n                        dp_curr[j][k] = max(dp_curr[j][k], max(dp_prev[j][0], dp_prev[j][1], dp_prev[j][2], dp_prev[j][3]))\n                    else:\n                        dp_curr[j][k] = 0  # can't have k>0 without picking\n            \n            # Picking the current item (if possible)\n            v = items[i][j]\n            if v > 0:\n                for k in range(3, 0, -1):\n                    if j > 1:\n                        if dp_curr[j-1][k-1] + v > dp_curr[j][k]:\n                            dp_curr[j][k] = dp_curr[j-1][k-1] + v\n                    else:\n                        if k == 1:\n                            max_prev = max(dp_prev[j][0], dp_prev[j][1], dp_prev[j][2], dp_prev[j][3])\n                            if max_prev + v > dp_curr[j][k]:\n                                dp_curr[j][k] = max_prev + v\n        dp_prev = dp_curr\n    \n    print(max(dp_prev[C][0], dp_prev[C][1], dp_prev[C][2], dp_prev[C][3]))\n\nsolve()",
    "timestamp": "2025-08-13 10:48:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [R, C, K] = input[0].split(' ').map(Number);\n    const items = Array.from({ length: R + 1 }, () => Array(C + 1).fill(0));\n    \n    for (let i = 1; i <= K; i++) {\n        const [r, c, v] = input[i].split(' ').map(Number);\n        items[r][c] = v;\n    }\n    \n    const dp = Array.from({ length: R + 1 }, () => \n        Array.from({ length: C + 1 }, () => \n            Array(4).fill(0)\n        )\n    );\n    \n    for (let i = 1; i <= R; i++) {\n        for (let j = 1; j <= C; j++) {\n            const v = items[i][j];\n            for (let k = 0; k <= 3; k++) {\n                // Move from left\n                dp[i][j][k] = Math.max(dp[i][j][k], dp[i][j - 1][k]);\n                if (k > 0 && v > 0) {\n                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i][j - 1][k - 1] + v);\n                }\n            }\n            // Move from top\n            const maxPrev = Math.max(...dp[i - 1][j]);\n            for (let k = 0; k <= 3; k++) {\n                dp[i][j][k] = Math.max(dp[i][j][k], maxPrev);\n                if (k === 1 && v > 0) {\n                    dp[i][j][k] = Math.max(dp[i][j][k], maxPrev + v);\n                }\n            }\n        }\n    }\n    \n    console.log(Math.max(...dp[R][C]));\n}\n\nsolve();",
    "timestamp": "2025-08-13 10:48:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Item {\n    int row, col, value;\n};\n\nint main() {\n    int R, C, K;\n    cin >> R >> C >> K;\n    vector<vector<Item>> items(R + 1);\n\n    for (int i = 0; i < K; ++i) {\n        int r, c, v;\n        cin >> r >> c >> v;\n        items[r].push_back({r, c, v});\n    }\n\n    for (int r = 1; r <= R; ++r) {\n        sort(items[r].begin(), items[r].end(), [](Item &a, Item &b) {\n            return a.col < b.col;\n        });\n    }\n\n    vector<vector<vector<long long>>> dp(R + 1, vector<vector<long long>>(C + 1, vector<long long>(4, 0)));\n\n    for (int r = 1; r <= R; ++r) {\n        for (int c = 1; c <= C; ++c) {\n            dp[r][c][0] = max(dp[r - 1][c][0], dp[r][c - 1][0]);\n            dp[r][c][1] = dp[r][c][2] = dp[r][c][3] = -1;\n        }\n    }\n\n    for (int r = 1; r <= R; ++r) {\n        for (int c = 1; c <= C; ++c) {\n            for (int k = 0; k < 4; ++k) {\n                dp[r][c][k] = max(dp[r][c][k], dp[r - 1][c][0]);\n                dp[r][c][k] = max(dp[r][c][k], dp[r][c - 1][k]);\n            }\n\n            int itemCount = 0;\n            long long currentValue = 0;\n            for (const auto& item : items[r]) {\n                if (item.col == c) {\n                    currentValue = item.value;\n                    break;\n                }\n            }\n\n            if (currentValue > 0) {\n                dp[r][c][1] = max(dp[r][c][1], dp[r][c][0] + currentValue);\n                \n                for (int k = 1; k < 3; ++k) {\n                    dp[r][c][k + 1] = max(dp[r][c][k + 1], dp[r][c][k] + currentValue);\n                }\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int k = 0; k < 4; ++k) {\n        result = max(result, dp[R][C][k]);\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:00:46"
  }
]