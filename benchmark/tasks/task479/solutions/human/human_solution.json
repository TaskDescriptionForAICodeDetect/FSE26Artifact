[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  cin>>p;\n  bool f=1;\n  for(int i=0;i<n-1;i++){\n    Line l(p[i],p[i+1]);\n    for(int j=0;j<n-1;j++){\n      if(abs(j-i)<=1) continue;\n      Segment s(p[j],p[j+1]);      \n      Point c=getCrossPointLL(l,s);\n      if(getDistanceSP(s,c)<EPS) f=0;\n      \n    }\n  }\n  cout<<(f?\"Possible\":\"Impossible\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n  \nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> V;\n  double x, y;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y;\n    V.emplace_back(x,y);\n  }\n  for(int i = 1; i < N; ++i){\n    P d = V[i] - V[i-1], o1 = V[i-1] + 0.5/abs(d)*d, o2 = V[i] - 0.5/abs(d)*d;\n    for(int j = i+1; j < N; ++j){\n      if(dot(V[j-1]-o1,d)*dot(V[j]-o1,d) < -EPS ||\n         dot(V[j-1]-o2,d)*dot(V[j]-o2,d) < -EPS){\n\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < -EPS;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Point> ps;\n\tREP(i, n)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps.push_back(Point{ x, y });\n\t}\n\tvector<Line> ls;\n\tREP(i, n - 1) ls.push_back(Line{ ps[i], ps[i + 1] });\n\tbool f = true;\n\tFOR(i, 1, n - 1)\n\t{\n\t\tPoint v1 = ps[i] - ps[i - 1];\n\t\tPoint v2 = ps[i] - ps[i + 1];\n\t\tif (dot(v1, v2) < -EPS) f = false;\n\t}\n\tREP(i, ls.size())\n\t{\n\t\tPoint v = ls[i].a - ls[i].b;\n\t\tPoint t(-v.imag(),v.real());\n\t\tLine l1(ls[i].a, ls[i].a + t);\n\t\tLine l2(ls[i].b, ls[i].b + t);\n\t\tREP(j, ls.size())\n\t\t{\n\t\t\tif (abs(i - j) <= 1) continue;\n\t\t\tif (isis_ls(l1, ls[j]) || isis_ls(l2, ls[j])) f = false;\n\t\t}\n\t}\n\tputs(f ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nbool check(vector<long double> x, vector<long double> y)\n{\n\t// Translation.\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tx[i] -= x[0];\n\t\ty[i] -= y[0];\n\t}\n\n\tx[0] = 0.0L;\n\ty[0] = 0.0L;\n\n\t\n\t// Query.\n\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Rotate.\n\n\t\tlong double ang = PI / 2.0L - atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double angl = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(angl);\n\t\t\t\ty[j] = radi * sinl(angl);\n\t\t\t}\n\t\t}\n\n\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i + 1 != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i + 1];\n\t\t\t\ty[j] -= y[i + 1];\n\t\t\t}\n\t\t}\n\n\t\tx[i + 1] = 0;\n\t\ty[i + 1] = 0;\n\n\n\t\t// Check.\n\n\t\tfor (int j = i + 2; j < N; j++)\n\t\t{\n\t\t\tif (y[j] < 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tvector<long double> x;\n\tvector<long double> y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tif (check(x, y))\n\t{\n\t\tprintf(\"Possible\\n\");\n\t}\n\telse\n\t{\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\n\t\tif (check(x, y))\n\t\t{\n\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing Point=complex<ld>;\n\nconst double EPS=1e-10l;\nint main(){\n    int n;\n    cin>>n;\n    vector<Point> ps(n);\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        ps[i]=Point(x,y);\n    }\n    bool res0=true;\n    for(int i=0;i<n-1;i++){\n        vector<Point> psm(n);\n        ld l=abs(ps[i+1]-ps[i]);\n        Point r=l*Point(0,1)/(ps[i+1]-ps[i]);\n        //cerr<<\"#\"<<i<<endl;\n        for(int j=0;j<n;j++){\n            psm[j]=r*(ps[j]-ps[i]);\n            //cerr<<psm[j]<<endl;\n        }\n        for(int j=0;j<i;j++){\n            res0&=(psm[j].imag()<psm[i].imag()+EPS);\n        }\n        for(int j=i+2;j<n;j++){\n            res0&=(psm[j].imag()>psm[i+1].imag()-EPS);\n        }\n    }\n    reverse(ps.begin(),ps.end());\n    bool res1=true;\n    for(int i=0;i<n-1;i++){\n        vector<Point> psm(n);\n        ld l=abs(ps[i+1]-ps[i]);\n        Point r=l*Point(0,1)/(ps[i+1]-ps[i]);\n        //cerr<<\"#\"<<i<<endl;\n        for(int j=0;j<n;j++){\n            psm[j]=r*(ps[j]-ps[i]);\n            //cerr<<psm[j]<<endl;\n        }\n        for(int j=0;j<i;j++){\n            res1&=(psm[j].imag()<psm[i].imag()+EPS);\n        }\n        for(int j=i+2;j<n;j++){\n            res1&=(psm[j].imag()>psm[i+1].imag()-EPS);\n        }\n    }\n    cout<<(res0||res1 ? \"Possible\" : \"Impossible\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std; int N;\nstruct Point { long double px, py; };\nstruct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point c = { a.px - b.px,a.py - b.py }; return c; }\nSegment rot90(Point p1, Point p2) {\n\tSegment g; Point P1, P2, P3 = Minus(p2, p1);\n\tlong double c = max(P3.px, P3.py);\n\tlong double S1 = 2e8l / c; P3.px *= c; P3.py *= c;\n\tP1.px = -P3.py; P1.py = P3.px;\n\tP2.px = P3.py; P2.py = -P3.px;\n\tP1.px += p1.px; P1.py += p1.py;\n\tP2.px += p1.px; P2.py += p2.py;\n\tg.p1 = P1; g.p2 = P2; return g;\n}\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4, int V) {\n\tif (V == 0 || V == N - 2)return (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(const Segment& s1, const Segment& s2, int V) { return its(s1.p1, s1.p2, s2.p1, s2.p2, V); }\nint main() {\n\tSegment a[1000]; Point b[1000];\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> b[i].px >> b[i].py;\n\t\tif (i < N - 1)a[i].p1 = b[i];\n\t\tif (i >= 1)a[i - 1].p2 = b[i];\n\t}\n\tint OK = 1;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tSegment L1 = rot90(a[i].p1, a[i].p2);\n\t\tSegment L2 = rot90(a[i].p2, a[i].p1);\n\t\tint OK2 = 1;\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i || j == i - 1)continue;\n\t\t\tif (its(a[j], L1, j) == true)OK2 = 0;\n\t\t}\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i || j == i + 1)continue;\n\t\t\tif (its(a[j], L2, j) == true)OK2 = 0;\n\t\t}\n\t\tif (OK2 == 0)OK = 0;\n\t}\n\tif (OK == 1)cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=1;i<n;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tconv = convex_hull(ps);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<C> ps2;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps2.push_back(z);\n\t\t}\n\t\tconv = convex_hull(ps2);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\n\n\nPolygon AndrewMonotoneChain(vector<Point> ps)\n{\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++]) // lower-hull\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>= 0; ch[k++]=ps[i--]) // upper-hull\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nenum { OUT, ON, IN };\nint convexContains(const Polygon& P, const Point& p)\n{\n  const int n = P.size();\n  Point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-Point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (semige(Point(P[a]-g).det(P[c]-g), 0.0)) { // angle < 180 deg\n      if (semige(Point(P[a]-g).det(p-g), 0.0) && semile(Point(P[c]-g).det(p-g), 0.0)) b = c;\n      else a = c;\n    } else {\n      if (semile(Point(P[a]-g).det(p-g), 0.0) && semige(Point(P[c]-g).det(p-g), 0.0)) a = c;\n      else b = c;\n    }\n  }\n  b %= n;\n  if (semile(Point(P[a] - p).det(P[b] - p), 0.0)) return 0;\n  if (semige(Point(P[a] - p).det(P[b] - p), 0.0)) return 2;\n  return 1;\n}\n\n\nint n;\ndouble x, y;\nvector<Point> P;\nPolygon G;\n\nint main(int argc, char *argv[])\n{\n  cin >> n;\n  rep(i, n){\n    cin >> x >> y;\n    P.pb(Point(x, y));\n  }\n\n  bool ok = true;\n  rrep(i, 3, n){\n    G.clear();\n    copy(P.begin(), P.begin() + i, back_inserter(G));\n    G = AndrewMonotoneChain(G);\n    if(convexContains(G, P[i]) == IN){\n      ok = false;\n      break;\n    }\n  }\n  \n  if(ok) rrep(i, 0, n - 3){\n    G.clear();\n    copy(P.begin() + i + 1, P.end(), back_inserter(G));\n    G = AndrewMonotoneChain(G);\n    if(convexContains(G, P[i]) == IN){\n      ok = false;\n      break;\n    }\n  }\n\n  puts(ok ? \"Possible\" : \"Impossible\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-9;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nP rot(P base,P a,D theta){ return base+polar(abs(a-base),arg(a-base)+theta); }\n\nint n;\nvector<P> ps;\n\nint main(){\n  cin>>n;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  bool ok=true;\n  rep(i,n){\n    if(i<n-1){\n      P dir=ps[i+1]-ps[i];\n      D theta=PI/2.0 - atan2(dir.Y,dir.X);\n      rep(j,n){\n        P crt=ps[j]-ps[i];\n        crt=rot(P(0,0),crt,theta);\n        if(j<i&&crt.Y>eps)ok=false;\n        if(j>i&&crt.Y<-eps)ok=false;\n      }\n    }\n    if(i>0){\n      P dir=ps[i-1]-ps[i];\n      D theta=atan2(-1,0) - atan2(dir.Y,dir.X);\n      rep(j,n){\n        P crt=ps[j]-ps[i];\n        crt=rot(P(0,0),crt,theta);\n        if(j<i&&crt.Y>eps)ok=false;\n        if(j>i&&crt.Y<-eps)ok=false;\n      }\n    }\n  }\n  if(ok)cout<<\"Possible\"<<endl;\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\n\n\nPolygon AndrewMonotoneChain(vector<Point> ps)\n{\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++]) // lower-hull\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>= 0; ch[k++]=ps[i--]) // upper-hull\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p)\n{\n  bool in = false;\n  for (int i = 0; i < P.size(); ++i) {\n    Point a = currPoint(P,i) - p, b = nextPoint(P,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (a.det(b) < 0) in = !in;\n    if (a.det(b) == 0 && a.dot(b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nint n;\ndouble x, y;\nvector<Point> P;\nPolygon G;\n\nint main(int argc, char *argv[])\n{\n  cin >> n;\n  rep(i, n){\n    cin >> x >> y;\n    P.pb(Point(x, y));\n  }\n\n  bool ok = true;\n  rrep(i, 2, n - 1){\n    G.clear();\n    copy(P.begin(), P.begin() + i, back_inserter(G));\n    ok &= (contains(G, P[i + 1]) == OUT);\n  }\n\n  rrep(i, 2, n - 1){\n    G.clear();\n    copy(P.end() - i, P.end(), back_inserter(G));\n    ok &= (contains(G, P[n - i - 1]) == OUT);\n  }\n\n  puts(ok ? \"Possible\" : \"Impossible\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point c = { a.px - b.px,a.py - b.py }; return c; }\nSegment rot90(Point p1, Point p2) {\n\tSegment g; Point P1, P2, P3 = Minus(p2, p1);\n\tlong double c = max(P3.px, P3.py);\n\tlong double S1 = 2e8l / c; P3.px *= c; P3.py *= c;\n\tP1.px = -P3.py; P1.py = P3.px;\n\tP2.px = P3.py; P2.py = -P3.px;\n\tP1.px += p1.px; P1.py += p1.py;\n\tP2.px += p1.px; P2.py += p2.py;\n\tg.p1 = P1; g.p2 = P2; return g;\n}\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n}\nbool its(const Segment& s1, const Segment& s2) { return its(s1.p1, s1.p2, s2.p1, s2.p2); }\nint main() {\n\tSegment a[1000]; Point b[1000]; int N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> b[i].px >> b[i].py;\n\t\tif (i < N - 1)a[i].p1 = b[i];\n\t\tif (i >= 1)a[i - 1].p2 = b[i];\n\t}\n\tint OK = 1;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tSegment L1 = rot90(a[i].p1, a[i].p2);\n\t\tSegment L2 = rot90(a[i].p2, a[i].p1);\n\t\tint OK2 = 1;\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i)continue;\n\t\t\tif (its(a[j], L1) == true)OK2 = 0;\n\t\t}\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i)continue;\n\t\t\tif (its(a[j], L2) == true)OK2 = 0;\n\t\t}\n\t\tif (OK2 == 0)OK = 0;\n\t}\n\tif (OK == 1)cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nbool calcGaiseki(Point left,Point base, Point right){\n\tdouble gaiseki = (left.x-base.x)*(right.y - base.y)-(left.y-base.y)*(right.x-base.x);\n\tif(gaiseki < -0.00000001)return false;\n\telse{\n\t\treturn true;\n\t}\n}\n\ndouble calc_S(Polygon g){\n\n\tint N = g.size();\n\tdouble ret = 0;\n\n\tfor(int i = 0; i < g.size(); i++){\n\t\tret += cross(g[i],g[(i+1)%N]);\n\t}\n\treturn ret/2.0;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -1;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0,Point p1,Point p2){\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//http://www.prefield.com/algorithm/geometry/convex_hull.html\nPolygon ConvexHull(Polygon V)\n{\n  int N = V.size(), k = 0;\n\n  sort(V.begin(), V.end());\n\n  Polygon ret(2*N);\n  for (int i = 0; i < N; ret[k++] = V[i++]) // lower-hull\n  while (k >= 2 && ccw(ret[k-2], ret[k-1], V[i]) <= 0) --k;\n  for (int i = N-2, t = k+1; i >= 0; ret[k++] = V[i--]) // upper-hull\n    while (k >= t && ccw(ret[k-2], ret[k-1], V[i]) <= 0) --k;\n\n  ret.resize(k-1);\n\n  return ret;\n}\n\nbool is_ok(Polygon p){\n\n\tdouble pre_S = -1.0,tmp_S;\n\n\tfor(int i = 0; i < p.size(); i++){\n\t\tif(i < 2)continue;\n\n\t\tPolygon p2;\n\t\tfor(int k = 0; k <= i; k++){\n\t\t\tp2.push_back(p[k]);\n\t\t}\n\n\t\tp2 = ConvexHull(p2);\n\n\t\ttmp_S = calc_S(p2);\n\n\t\tif(fabs(tmp_S-pre_S) < EPS){\n\t\t\treturn false;\n\t\t}\n\t\tpre_S = tmp_S;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tPolygon p;\n\tdouble tmp_x,tmp_y;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%lf %lf\",&tmp_x,&tmp_y);\n\t\tp.push_back(Point(tmp_x,tmp_y));\n\t}\n\n\tif(!is_ok(p)){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\n\treverse(p.begin(),p.end());\n\n\tif(!is_ok(p)){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"Possible\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nlong double deg(long double px, long double py) {\n\tlong double T = px / sqrtl(px * px + py * py);\n\tlong double E = acos(T) * 180.0L / 3.14159265358979L;\n\tif (py >= 0) return E;\n\treturn 360.0L - E;\n}\n\nint N, x[1009], y[1009];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) cin >> x[i] >> y[i];\n\n\tbool ok = false;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\t// ---------------------------- 辺の最初で判定 ----------------------------\n\t\tlong double maxa = 0, maxb = 0, maxc = 0, maxd = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tlong double D1 = deg(x[i] - x[i + 1], y[i] - y[i + 1]);\n\t\t\tlong double D2 = deg(x[j] - x[i], y[j] - y[i]);\n\n\t\t\tlong double SA = D1 - D2; if (SA < -180.0L) SA += 360.0L; else if (SA > 180.0L) SA -= 360.0L;\n\t\t\tif (SA < 0.0L) maxa = max(maxa, -SA);\n\t\t\telse maxb = max(maxb, SA);\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tlong double D1 = deg(x[i + 1] - x[i], y[i + 1] - y[i]);\n\t\t\tlong double D2 = deg(x[j] - x[i], y[j] - y[i]);\n\n\t\t\tlong double SA = D1 - D2; if (SA < -180.0L) SA += 360.0L; else if (SA > 180.0L) SA -= 360.0L;\n\t\t\tif (SA < 0.0L) maxc = max(maxc, -SA);\n\t\t\telse maxd = max(maxd, SA);\n\t\t}\n\t\tif (maxa + maxb > 180.0L || maxb + maxc > 180.0L || maxc + maxd > 180.0L || maxd + maxa > 180.0L) {\n\t\t\tok = true;\n\t\t}\n\n\t\t// -------------------------- 辺の最後で判定 -----------------------------\n\t\tmaxa = 0; maxb = 0; maxc = 0;\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tlong double D1 = deg(x[i] - x[i + 1], y[i] - y[i + 1]);\n\t\t\tlong double D2 = deg(x[j] - x[i + 1], y[j] - y[i + 1]);\n\n\t\t\tlong double SA = D1 - D2; if (SA < -180.0L) SA += 360.0L; else if (SA > 180.0L) SA -= 360.0L;\n\t\t\tif (SA < 0.0L) maxa = max(maxa, -SA);\n\t\t\telse maxb = max(maxb, SA);\n\t\t}\n\t\tfor (int j = i + 2; j < N; j++) {\n\t\t\tlong double D1 = deg(x[i + 1] - x[i], y[i + 1] - y[i]);\n\t\t\tlong double D2 = deg(x[j] - x[i + 1], y[j] - y[i + 1]);\n\n\t\t\tlong double SA = D1 - D2; if (SA < -180.0L) SA += 360.0L; else if (SA > 180.0L) SA -= 360.0L;\n\t\t\tif (SA < 0.0L) maxc = max(maxc, -SA);\n\t\t\telse maxd = max(maxd, SA);\n\t\t}\n\t\tif (maxa + maxb > 180.0L || maxb + maxc > 180.0L || maxc + maxd > 180.0L || maxd + maxa > 180.0L) {\n\t\t\tok = true;\n\t\t}\n\t}\n\tif (ok == true) cout << \"Impossible\" << endl;\n\telse cout << \"Possible\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\n\n\nPolygon AndrewMonotoneChain(vector<Point> ps)\n{\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++]) // lower-hull\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>= 0; ch[k++]=ps[i--]) // upper-hull\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p)\n{\n  bool in = false;\n  for (int i = 0; i < P.size(); ++i) {\n    Point a = currPoint(P,i) - p, b = nextPoint(P,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (a.det(b) < 0) in = !in;\n    if (a.det(b) == 0 && a.dot(b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nint n;\ndouble x, y;\nvector<Point> P;\nPolygon G;\n\nint main(int argc, char *argv[])\n{\n  cin >> n;\n  rep(i, n){\n    cin >> x >> y;\n    P.pb(Point(x, y));\n  }\n\n  bool ok = true;\n  rrep(i, 2, n - 1){\n    G.clear();\n    copy(P.begin(), P.begin() + i, back_inserter(G));\n    ok &= (contains(G, P[i + 1]) == OUT);\n  }\n\n  rrep(i, 2, n - 1){\n    G.clear();\n    copy(P.end() - i, P.end(), back_inserter(G));\n    ok &= (contains(G, P[i - 1]) == OUT);\n  }\n\n  puts(ok ? \"Possible\" : \"Impossible\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst double EPS = 1e-8;\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nint main(){\n    int n;\n    cin >> n;\n    VP v(n);\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        v[i] = P(x,y);\n    }\n\n    bool ans = true;\n    for(int r=0; r<2; r++){\n        for(int i=2; i<n-1; i++){\n            bool s1 = false;\n            for(int j=0; j<i; j++){\n                bool s2 = true;\n                int comp = ccw(v[i], v[j], v[(j+1)%i]);\n                for(int k=0; k<i; k++){\n                    if(k!=j && comp!=ccw(v[i], v[j], v[k])){\n                        s2 = false;\n                    }\n                }\n                if(s2){ s1 = true; break; }\n            }\n            if(!s1){ ans = false; break; }\n        }\n        reverse(v.begin(), v.end());\n    }\n    if(ans) cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=1;i<n;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tif(ps.size()>2){\n\t\t\tconv = convex_hull(ps);\n\t\t\tif(contains(conv,z)==2){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<C> ps2;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps2.push_back(z);\n\t\t}\n\t\tif(ps2.size()>2){\n\t\t\tconv = convex_hull(ps2);\n\t\t\tif(contains(conv,z)==2){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \n#define PI 3.1415926535897932384626433832795L\n \nusing namespace std;\n \nint N, X, Y;\n \nvector<long double> x;\nvector<long double> y;\n \nint main()\n{\n    scanf(\"%d\", &N);\n \n    for (int i = 0; i < N; i++)\n    {\n        scanf(\"%d\", &X);\n        scanf(\"%d\", &Y);\n \n        x.push_back(X);\n        y.push_back(Y);\n    }\n \n    bool ok = true;\n \n    for (int i = 0; i < N - 1; i++)\n    {\n        // Translation.\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                x[j] -= x[i];\n                y[j] -= y[i];\n            }\n        }\n \n        x[i] = 0;\n        y[i] = 0;\n \n        // Rotate.\n \n        long double ang = PI - atan2l(y[i + 1], x[i + 1]);\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                long double ang2 = atan2l(y[j], x[j]) + ang;\n                long double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n \n                x[j] = radi * cosl(ang2);\n                y[j] = radi * sinl(ang2);\n            }\n        }\n        \n        long double maxc = -999.0L, minc = 999.0;\n \n        for(int j = i + 1; j < n; j++)\n        {\n            long double ang2 = atan2l(y[j], x[j]);\n            \n            maxc = max(maxc, ang2);\n            minc = min(minc, ang2);\n        }\n        \n        ang = -atan2l(y[i + 1], x[i + 1]);\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                long double ang2 = atan2l(y[j], x[j]) + ang;\n                long double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n \n                x[j] = radi * cosl(ang2);\n                y[j] = radi * sinl(ang2);\n            }\n        }\n        \n        long double maxd = -999.0L, mind = 999.0;\n \n        for(int j = 0; j < i; j++)\n        {\n            long double ang2 = atan2l(y[j], x[j]);\n            \n            maxd = max(maxc, ang2);\n            mind = min(minc, ang2);\n        }\n        \n        mind += PI;\n        maxd += PI;\n        \n        if(maxc - minc > PI || maxd - mind > PI) ok = false;\n    }\n \n    printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-3;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = false;\n\t\tint[] ord = convexHull(x, y);\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tif (ord[i] == 0) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t} else if (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t} else if (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1) {\n\t\t\t\tfor (int v : lisr) {\n\t\t\t\t\tfor (int u : lisl) {\n\t\t\t\t\t\tif (Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])) {\n\t\t\t\t\t\t\tf &= false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tint[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\tif (x[o1] != x[o2])\n\t\t\t\t\treturn Double.compare(x[o1], x[o2]);\n\t\t\t\tif (y[o1] != y[o2]) {\n\t\t\t\t\treturn Double.compare(y[o1], y[o2]);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tR EPS = 1e-9;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nint f = 0;\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y+EPS < b.Y;}\n\tbool operator==(const P &a, const P &b){return abs(a-b) < EPS;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n}\n\nint n;\n\nint check(P p, const vector<P> &a, const vector<P> &b){\n\tconst R PI = 2*atan2(1, 0);\n\tvector<pair<R, int>> args(1, make_pair(INF, 0));\n\tfor(auto &q : a){\n\t\tR a = arg(q - p);\n\t\targs.eb(a, 0);\n\t\targs.eb(a+2*PI, 0);\n\t}\n\tfor(auto &q : b){\n\t\tR a = arg(q - p);\n\t\targs.eb(a, 1);\n\t\targs.eb(a+2*PI, 1);\n\t}\n\tsort(ALL(args));\n\tint j=0;\n\tint ans = n-1;\n\tint c[2] = {0, 0};\n\tREP(i, n-1){\n\t\twhile(args[j].first < args[i].first+PI- EPS) c[args[j++].second]++;\n\t\tif(c[0] == 0 && c[1] == b.size()) return 1;\n\t\tif(c[1] == 0 && c[0] == a.size()) return 1;\n\t\tc[args[i].second]--;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> n;\n\tvector<P> p, q;\n\tREP(i, n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp.eb(x, y);\n\t}\n\tREP(i, n){\n\t\tP t = p.back();\n\t\tp.pop_back();\n\t\tif(!check(t, p, q)){\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tq.pb(t);\n\t}\n\tcout << \"Possible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<(m)+EPS)\n#define GE(n,m) ((n)+EPS>(m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c)>EPS) return 1;\n  if (cross(b,c)<-EPS) return -1; \n  if (dot(b,c)<-EPS) return 2; \n  if (norm(b)<norm(c)) return -2; \n  return 0; \n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\nVP convexHull(VP ps) { \n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i=0;i<n;ch[k++]=ps[i++])\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  for (int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])\n    while (k>=t&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  ch.resize(k-1);\n  return ch;\n}\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\nint main(){\n  int n;\n  cin>>n;\n  P p[n];\n  rep(i,n){\n    double a1,a2;\n    cin>>a1>>a2;\n    p[i]=P(a1,a2);\n  }\n  VP p1,p2;\n  rep(i,n)p1.push_back(p[i]);\n  rep(i,n){\n    if(i)p1.push_back(p[i-1]);\n    p1.erase(p1.begin());\n    VP a1,a2;\n    if(p2.size()>=3){\n      a2=convexHull(p2);\n      if(inConvex(p[i],a2)==1){cout<<\"Impossible\"<<endl;goto L;}\n    }\n  }\n  cout<<\"Possible\"<<endl;L:;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rep(i,n) for (int i = 0; i < n; i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n//#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\n/*\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n    cerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n    out<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n    out<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\n*/\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\nint n;\nP p[1000];\nL lines[1000];\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nVP convexHull(VP ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end(), [](const P& left, const P& right) { return left.X < right.X || (left.X == right.X && left.Y < right.Y);});\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n\n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n\nvoid solve() {\n    cin >> n;\n    rep(i,n) {\n        D x, y; cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int i = 1; i < n-1; i++) {\n        VP lvp, rvp;\n        rep(j,i+1) lvp.push_back(p[j]);\n        for (int j = i; j < n; j++) rvp.push_back(p[j]);\n        VP lcon, rcon;\n        lcon = convexHull(lvp);\n        rcon = convexHull(rvp);\n        bool ok = false;\n        rep(j,lcon.size()) {\n            if (EQ(lcon[j], p[i])) ok = true;\n        }\n        if (!ok) {\n            cout << \"Impossible\" << endl;\n            return;\n        }\n        ok = false;\n        rep(j,rcon.size()) {\n            if (EQ(rcon[j], p[i])) ok = true;\n        }\n        if (!ok) {\n            cout << \"Impossible\" << endl;\n            return;\n        }\n        rep(j,lcon.size()) {\n            if (EQ(lcon[j], p[i])) continue;\n            if (inCcwConvex(rcon, lcon[j])) {\n                cout << \"Impossible\" << endl;\n                return;\n            }\n        }\n        rep(j,rcon.size()) {\n            if (EQ(rcon[j], p[i])) continue;\n            if (inCcwConvex(lcon, rcon[j])) {\n                cout << \"Impossible\" << endl;\n                return;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\nll cross(ll x1,ll y1,ll x2,ll y2){\n\treturn x1*y2 - x2*y1;\n}\n\nbool is_over(ll x1,ll y1,ll x2,ll y2,ll a,ll b){\n\tif(cross(x2-x1,y2-y1,a-x1,b-y1)>0){\n\t\treturn 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\nbool is_cross(ll ax,ll ay,ll bx,ll by,ll cx,ll cy,ll dx,ll dy){\n\tll ta = (cx-dx) * (ay-cy) + (cy-dy) * (cx-ax);\n\tll tb = (cx-dx) * (by-cy) + (cy-dy) * (cx-bx);\n\tll tc = (ax-bx) * (cy-ay) + (ay-by) * (ax-cx);\n\tll td = (ax-bx) * (dy-ay) + (ay-by) * (ax-dx);\n\tif(ta>0)ta=1;\n\telse ta = -1;\n\tif(tb>0)tb=1;\n\telse tb = -1;\n\tif(tc>0)tc=1;\n\telse tc = -1;\n\tif(td>0)td=1;\n\telse td = -1;\n\treturn tc*td < 0 && ta*tb <0;\n}\n\nbool p[2000];\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<ll>x(n),y(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=0;i<n-1;i++){\n\t\tvector<int>v,w;\n\t\tfor(int j=i+2;j<n;j++){\n\t\t\tif(is_over(x[i],y[i],x[i+1],y[i+1],x[j],y[j])){\n\t\t\t\tv.PB(j);\n\t\t\t}else{\n\t\t\t\tw.PB(j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<v.size();j++){\n\t\t\tfor(int k=0;k<w.size();k++){\n\t\t\t\tif(is_cross(x[i],y[i],x[i+1],y[i+1],x[v[j]],y[v[j]],x[w[k]],y[w[k]])){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag)break;\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-12;\n\nbool lt(double a, double b){\n  return a < b - EPS;\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid print(const vector<complex<double>>& pts){\n  for(complex<double> p: pts){\n    cout << p.real() << \" \" << p.imag() << endl;\n  }\n  cout << \"===\";\n  cout << endl;\n}\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    //print(pts);\n\n    moveToO(i+1, pts);\n    //print(pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nbool check(vector<long double> x, vector<long double> y)\n{\n\t// Translation.\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tx[i] -= x[0];\n\t\ty[i] -= y[0];\n\t}\n\n\tx[0] = 0.0L;\n\ty[0] = 0.0L;\n\n\t\n\t// Query.\n\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Rotate.\n\n\t\tlong double ang = PI / 2.0L - atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double angl = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(angl);\n\t\t\t\ty[j] = radi * sinl(angl);\n\t\t\t}\n\t\t}\n\n\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i + 1 != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i + 1];\n\t\t\t\ty[j] -= y[i + 1];\n\t\t\t}\n\n\t\t\tx[i + 1] = 0;\n\t\t\ty[i + 1] = 0;\n\t\t}\n\n\n\t\t// Check.\n\n\t\tfor (int j = i + 2; j < N; j++)\n\t\t{\n\t\t\tif (y[j] < 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tvector<long double> x;\n\tvector<long double> y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tif (check(x, y))\n\t{\n\t\tprintf(\"Possible\\n\");\n\t}\n\telse\n\t{\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\n\t\tif (check(x, y))\n\t\t{\n\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=1;i<n;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tconv = convex_hull(ps);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<C> ps2;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps2.push_back(z);\n\t\t}\n\t\tconv = convex_hull(ps);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long double>x(N);\n\tvector<long double>y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tvector<long double>r;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tauto box = atan2l(y[j] - y[i], x[j] - x[i]);\n\t\t\tif (box < 0)box += acosl(-1);\n\t\t\telse box -= acosl(-1);\n\t\t\tr.push_back(box);\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tr.push_back(atan2l(y[j] - y[i], x[j] - x[i]));\n\t\t}\n\t\tsort(r.begin(), r.end());\n\t\tM = r.size();\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tr.push_back(r[j]+acosl(-1) * 2);\n\t\t}\n\t\tbool flag = false;\n\t\tlong double a = MOD;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\ta = min(a, r[j + M - 1] - r[j]);\n\t\t\tif (r[j + M - 1] - r[j] <= acosl(-1)) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t//cout << setprecision(20) << a << endl;\n\t\tif (!flag) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//if (i == N - 3) {\n\t\t//\tfor (auto j : r)cout << setprecision(20) << j << endl;\n\t\t//}\n\t}\n\tcout << \"Possible\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nbool check(vector<long double> x, vector<long double> y)\n{\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i];\n\t\t\t\ty[j] -= y[i];\n\t\t\t}\n\t\t}\n\n\t\tx[i] = 0.0L;\n\t\ty[i] = 0.0L;\n\n\t\t// Rotate.\n\n\t\tlong double ang = PI / 2.0L - atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double ang2 = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(ang2);\n\t\t\t\ty[j] = radi * sinl(ang2);\n\t\t\t}\n\t\t}\n\n\t\t// Check.\n\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (y[j] < -0.00000001L)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tvector<long double> x;\n\tvector<long double> y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tif (check(x, y))\n\t{\n\t\tprintf(\"Possible\\n\");\n\t}\n\telse\n\t{\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\n\t\tif (check(x, y))\n\t\t{\n\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nvector<long double> x;\nvector<long double> y;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tbool ok = true;\n\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i];\n\t\t\t\ty[j] -= y[i];\n\t\t\t}\n\t\t}\n\n\t\tx[i] = 0;\n\t\ty[i] = 0;\n\n\t\t// Rotate.\n\n\t\tlong double ang = PI / 2 - atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double ang2 = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(ang2);\n\t\t\t\ty[j] = radi * sinl(ang2);\n\t\t\t}\n\t\t}\n\n\t\t// Check.\n\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (y[j] < -0.00000001L)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nPolygon p;\n\nbool check(){\n  if(n<=3)return true;\n  Polygon P;\n  FOR(i,0,n){\n    if(3<=i && contains(P,p[i]))return false;\n    P.pb(p[i]);\n    P=convex_hull(P);\n  }\n  return true;\n}\n\nbool solve(){\n  if(!check())return false;\n  reverse(all(p));\n  if(!check())return false;\n  return true;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  cout<<(solve() ? \"Possible\" : \"Impossible\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=__int128;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> x(n),y(n);\n    for(int i=0;i<n;i++){\n        long long xx,yy;\n        cin>>xx>>yy;\n        x[i]=xx,y[i]=yy;\n    }\n    bool res0=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res0&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res0&=(xx*a+yy*b<=0);\n        }\n    }\n    reverse(x.begin(),x.end());\n    reverse(y.begin(),y.end());\n    bool res1=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res1&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res1&=(xx*a+yy*b<=0);\n        }\n    }\n    \n    cout<<(res0 || res1 ? \"Possible\" : \"Impossible\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<(m)+EPS)\n#define GE(n,m) ((n)+EPS>(m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c)>EPS) return 1;\n  if (cross(b,c)<-EPS) return -1; \n  if (dot(b,c)<-EPS) return 2; \n  if (norm(b)<norm(c)) return -2; \n  return 0; \n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\nVP convexHull(VP ps) { \n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i=0;i<n;ch[k++]=ps[i++])\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  for (int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])\n    while (k>=t&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  ch.resize(k-1);\n  return ch;\n}\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\nint main(){\n  int n;\n  cin>>n;\n  P p[n];\n  rep(i,n){\n    double a1,a2;\n    cin>>a1>>a2;\n    p[i]=P(a1,a2);\n  }\n  VP p1,p2;\n  rep(i,n)p1.push_back(p[i]);\n  rep(i,n){\n    if(i)p1.push_back(p[i-1]);\n    p1.erase(p1.begin());\n    VP a1;\n    if(p1.size()>=3){\n      a1=convexHull(p1);\n      if(inConvex(p[i],a1)==1){cout<<\"Impossible\"<<endl;goto L;}\n    }\n    if(p2.size()>=3){\n      a1=convexHull(p2);\n      if(inConvex(p[i],a1)==1){cout<<\"Impossible\"<<endl;goto L;}\n    }\n  }\n  cout<<\"Possible\"<<endl;L:;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-12)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  cin>>p;\n  bool f=1;\n  for(int i=0;i<n-1;i++){\n    Line l(p[i],p[i+1]);\n    for(int j=max(0,i-2);j<min(n-1,i+2);j++){\n      if(abs(j-i)<=1) continue;\n      Segment s(p[j],p[j+1]);      \n      Point c=getCrossPointLL(l,s);\n      if(getDistanceSP(s,c)<=EPS&&\n\t abs(p[j]-c)>EPS&&\n\t abs(p[j+1]-c)>EPS){\n\tif(0){\n\t  cout<<i<<\" \"<<j<<endl;\n\t  cout<<\"Segment \"<<p[i]<<\" \"<<p[i+1]<<endl;\n\t  cout<<\"Segment \"<<p[j]<<\" \"<<p[j+1]<<endl;\n\t  cout<<c<<\" C\"<<endl;\n\t}\n\tf=0;\n      }\n    }\n  }\n  cout<<(f?\"Possible\":\"Impossible\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> pt;\n#define pb push_back\n#define mp make_pair\npt P[1005];\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble x,y; scanf(\"%lf%lf\",&x,&y);\n\t\tP[i] = pt(x,y);\n\t}\n\tif(n<=3){\n\t\tputs(\"Possible\"); return 0;\n\t}\n\tvector<pair<double,int> >vec;\n\tfor(int i=2;i<=n;i++){\n\t\tvec.pb(mp(arg(P[i]-P[1]),i));\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].first-vec[i-1].first > 3.141592653589793-1e-10){\n\t\t\tgoto ok;\n\t\t}\n\t}\n\tif(vec[vec.size()-1].first-vec[0].first < 3.141592653589793+1e-10){\n\t\tgoto ok;\n\t}\n\tputs(\"Impossible\"); return 0; ok:;\n\tvec.clear();\n\tfor(int i=1;i<n;i++){\n\t\tvec.pb(mp(arg(P[i]-P[n]),i));\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].first-vec[i-1].first > 3.141592653589793-1e-10){\n\t\t\tgoto ok2;\n\t\t}\n\t}\n\tif(vec[vec.size()-1].first-vec[0].first < 3.141592653589793+1e-10){\n\t\tgoto ok2;\n\t}\n\tputs(\"Impossible\"); return 0; ok2:;\n\tfor(int i=2;i<n;i++){\n\t\tvec.clear();\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tvec.pb(mp(arg(P[j]-P[i]),j));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t//\tfor(int j=0;j<vec.size();j++) cout << vec[j].second << \" \"; cout << endl;\n\t\tfor(int j=1;j<vec.size();j++){\n\t\t\tif( ((vec[j].second<i) ^ (vec[j-1].second<i)) == 1){\n\t\t\t\tbool p = (vec[j].second<i); int cnt = 1;\n\t\t\t\tfor(int k=(j+1)%vec.size();k!=j;k=(k+1)%vec.size()){\n\t\t\t\t\tif( (vec[k].second<i) != p){\n\t\t\t\t\t\tif( (p==1&&cnt==i-1) || (p==0&&cnt==n-i) ){\n\t\t\t\t\t\t\t//j..k\n\t\t\t\t\t\t\tdouble A = vec[k].first-vec[j].first; if(A<0) A+=2*3.1415926535897932;\n\t\t\t\t\t\t\t//(k+1)%vec.size()...(j+vec.size()-1)%vec.size()\n\t\t\t\t\t\t\tdouble B = vec[(j+vec.size()-1)%vec.size()].first-vec[(k+1)%vec.size()].first; if(B<0) A+=2*3.1415926535897932;\n\t\t\t\t\t\t\t//cout << A << \" \" << B << endl;\n\t\t\t\t\t\t\tif(A > 3.141592653589793+1e-10 || B > 3.141592653589793+1e-10){\n\t\t\t\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto nxt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnxt:;\n\t}\n\tputs(\"Possible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\n\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\nD calc_area(vector<P>& poly) {\n  D res = 0;\n  int sz=poly.size();\n  for (int i = 0; i < sz; i++){\n    res += cross(poly[i], poly[(i+1)%sz]);\n  }\n  return res/2.0;\n}\n\nbool judge(vector<P>& ps){\n  D crt=-1;\n  rep(i,ps.size())if(i>=2){\n    vector<P> a;\n    rep(j,i+1)a.push_back(ps[i]);\n    a=convex_hull(a);\n    D nxt=calc_area(a);\n    if(abs(crt-nxt)<eps)return false;\n    crt=nxt;\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  vector<P> ps;\n  cin>>n;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  bool ok=true;\n  if(!judge(ps))ok=false;\n  reverse(all(ps));\n  if(!judge(ps))ok=false;\n  if(ok)cout<<\"Possible\"<<endl;\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//入れ方を2通り試す. 点0->1…の順で入れる場合は,\n//・点i-1->iをy軸正方向にした状態で点iを原点に置けるか(1<=i<n)\n//・点i->i+1をy軸正方向にした状態で点iを原点に置けるか(0<=i<n-1)\n//を判定するだけ. もう一方の入れ方は, 点番号の反転をすれば上記と同じ判定法.\n//回転がO(N)なので、全部でO(N^2)で解ける. (y_i > 0なので, 易しい)\n#include <iostream>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\nPoint p[1000];\n\nvoid move(Point q[], int id, Point mul) {\n\tint i;\n\tfor (i = 0; i < n; i++) q[i] = p[i];\n\tfor (i = 0; i < n; i++) q[i] *= mul;\n\tPoint trans = -q[id];\n\tfor (i = 0; i < n; i++) q[i] += trans;\n}\n\n//ここが本質\nbool isOk(Point q[], int id) {\n\tconst double eps = 0;\n\tint i;\n\tfor (i = 0; i < id; i++) { if (q[i].imag() > eps) return false; }\n\tfor (i = id + 1; i < n; i++) { if (q[i].imag() < -eps) return false; }\n\treturn true;\n}\n\nbool regalA(int id) {\n\tstatic Point q[1000];\n\tPoint mul = Point(0, 1) / (p[id] - p[id - 1]); mul /= abs(mul);\n\tmove(q, id, mul);\n\treturn isOk(q, id);\n}\n\nbool regalB(int id) {\n\tstatic Point q[1000];\n\tPoint mul = Point(0, 1) / (p[id + 1] - p[id]); mul /= abs(mul);\n\tmove(q, id, mul);\n\treturn isOk(q, id);\n}\n\nbool check() {\n\tint i;\n\tfor (i = 1; i < n; i++) if (!regalA(i)) return false;\n\tfor (i = 0; i + 1 < n; i++) if (!regalB(i)) return false;\n\treturn true;\n}\n\nvoid reverseP() {\n\tint l = 0, r = n - 1;\n\twhile (l < r) {\n\t\tswap(p[l], p[r]);\n\t\tl++; r--;\n\t}\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t}\n\t\n\tbool res = check(); reverseP(); res |= check();\n\tif (res) cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing Point=complex<ld>;\n\nconst double EPS=1e-12l;\nint main(){\n    int n;\n    cin>>n;\n    vector<Point> ps(n);\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        ps[i]=Point(x,y);\n    }\n    bool res0=true;\n    for(int i=0;i<n-1;i++){\n        vector<Point> psm(n);\n        ld l=abs(ps[i+1]-ps[i]);\n        Point r=l*Point(0,1)/(ps[i+1]-ps[i]);\n        //cerr<<\"#\"<<i<<endl;\n        for(int j=0;j<n;j++){\n            psm[j]=r*(ps[j]-ps[i]);\n            //cerr<<psm[j]<<endl;\n        }\n        for(int j=0;j<i;j++){\n            res0&=(psm[j].imag()<=psm[i].imag()+EPS);\n        }\n        for(int j=i+2;j<n;j++){\n            res0&=(psm[j].imag()>=psm[i+1].imag()-EPS);\n        }\n    }\n    reverse(ps.begin(),ps.end());\n    bool res1=true;\n    for(int i=0;i<n-1;i++){\n        vector<Point> psm(n);\n        ld l=abs(ps[i+1]-ps[i]);\n        Point r=l*Point(0,1)/(ps[i+1]-ps[i]);\n        //cerr<<\"#\"<<i<<endl;\n        for(int j=0;j<n;j++){\n            psm[j]=r*(ps[j]-ps[i]);\n            //cerr<<psm[j]<<endl;\n        }\n        for(int j=0;j<i;j++){\n            res1&=(psm[j].imag()<=psm[i].imag()+EPS);\n        }\n        for(int j=i+2;j<n;j++){\n            res1&=(psm[j].imag()>=psm[i+1].imag()-EPS);\n        }\n    }\n    cout<<(res0||res1 ? \"Possible\" : \"Impossible\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//入れ方を2通り試す. 点0->1…の順で入れる場合は,\n//・点i-1->iをy軸正方向にした状態で点iを原点に置けるか(1<=i<n)\n//・点i->i+1をy軸正方向にした状態で点iを原点に置けるか(0<=i<n-1)\n//を判定するだけ. もう一方の入れ方は, 点番号の反転をすれば上記と同じ判定法.\n//回転がO(N)なので、全部でO(N^2)で解ける. (y_i > 0なので, 易しい)\n#include <iostream>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\nPoint p[1000];\n\nvoid move(Point q[], int id, Point mul) {\n\tint i;\n\tfor (i = 0; i < n; i++) q[i] = p[i];\n\tfor (i = 0; i < n; i++) q[i] *= mul;\n\tPoint trans = -q[id];\n\tfor (i = 0; i < n; i++) q[i] += trans;\n}\n\n//ここが本質\nbool isOk(Point q[], int id) {\n\tconst double eps = 1e-10;\n\tint i;\n\tfor (i = 0; i < id; i++) { if (q[i].imag() > eps) return false; }\n\tfor (i = id + 1; i < n; i++) { if (q[i].imag() < -eps) return false; }\n\treturn true;\n}\n\nbool regalA(int id) {\n\tstatic Point q[1000];\n\tPoint mul = Point(0, 1) / (p[id] - p[id - 1]); mul /= abs(mul);\n\tmove(q, id, mul);\n\treturn isOk(q, id);\n}\n\nbool regalB(int id) {\n\tstatic Point q[1000];\n\tPoint mul = Point(0, 1) / (p[id + 1] - p[id]); mul /= abs(mul);\n\tmove(q, id, mul);\n\treturn isOk(q, id);\n}\n\nbool check() {\n\tint i;\n\tfor (i = 1; i < n; i++) if (!regalA(i)) return false;\n\tfor (i = 0; i + 1 < n; i++) if (!regalB(i)) return false;\n\treturn true;\n}\n\nvoid reverseP() {\n\tint l = 0, r = n - 1;\n\twhile (l < r) {\n\t\tswap(p[l], p[r]);\n\t\tl++; r--;\n\t}\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t}\n\t\n\tbool res = check(); reverseP(); res |= check();\n\tif (res) cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS=1e-10;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> p) {\n  int n=p.size(),k=0;\n  sort(p.begin(),p.end());\n  vector<P> q(2*n);\n  for(int i=0;i<n;q[k++]=p[i++])\n    while(k>=2&&ccw(q[k-2],q[k-1],p[i])<=0) --k;\n  for(int i=n-2,t=k+1;i>=0;q[k++]=p[i--])\n    while(k>=t&&ccw(q[k-2],q[k-1],p[i])<=0) --k;\n  q.resize(k-1);\n  return q;\n}\n\ndouble area(vector<P> p) {\n  double a=0;\n  for(int i=0; i<(int)p.size(); i++) a+=cross(p[i],p[(i+1)%p.size()]);\n  return fabs(a)/2;\n}\n\nvector<P> v;\nint n;\nbool ck() {\n  vector<P> a;\n  double d[n];\n  for(int i=0; i<n; i++) {\n    a.push_back(v[i]);\n    d[i]=0;\n    if(a.size()<3) continue;\n    vector<P> b=convex_hull(a);\n    d[i]=area(b);\n    if(d[i]-d[i-1]<EPS) return 0;\n  }\n  return 1;\n}\n\nint main() {\n  cin >> n;\n  for(int i=0; i<n; i++) {\n    double x,y;\n    cin >> x >> y;\n    v.push_back(P(x,y));\n  }\n  for(int t=0; t<2; t++) {\n    if(!ck()) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n    reverse(v.begin(),v.end());\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS=1e-10;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n \nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n \nvector<P> convex_hull(vector<P> p) {\n  int n=p.size(),k=0;\n  sort(p.begin(),p.end());\n  vector<P> q(2*n);\n  for(int i=0;i<n;q[k++]=p[i++])\n    while(k>=2&&ccw(q[k-2],q[k-1],p[i])<=0) --k;\n  for(int i=n-2,t=k+1;i>=0;q[k++]=p[i--])\n    while(k>=t&&ccw(q[k-2],q[k-1],p[i])<=0) --k;\n  q.resize(k-1);\n  return q;\n}\n \ndouble area(vector<P> p) {\n  double a=0;\n  for(int i=0; i<(int)p.size(); i++) a+=cross(p[i],p[(i+1)%p.size()]);\n  return fabs(a)/2;\n}\n \nint main() {\n  int n;\n  cin >> n;\n  vector<P> v(n);\n  for(int i=0; i<n; i++) {\n    double x,y;\n    cin >> x >> y;\n    v[i]=P(x,y);\n  }\n  for(int t=0; t<2; t++) {\n    vector<P> a;\n    double d[n];\n    for(int i=0; i<n; i++) {\n      a.push_back(v[i]);\n      d[i]=0;\n      if(a.size()<3) continue;\n      vector<P> b=convex_hull(a);\n      d[i]=area(b);\n      if(d[i]-d[i-1]<EPS) {\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n    reverse(v.begin(),v.end());\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nvector<long double> x;\nvector<long double> y;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tbool ok = true;\n\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i];\n\t\t\t\ty[j] -= y[i];\n\t\t\t}\n\t\t}\n\n\t\tx[i] = 0;\n\t\ty[i] = 0;\n\n\t\t// Rotate.\n\n\t\tlong double ang = PI / 2 - atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double ang2 = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(ang2);\n\t\t\t\ty[j] = radi * sinl(ang2);\n\t\t\t}\n\t\t}\n\n\t\t// Check.\n\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (y[j] <= 0)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \n#define PI 3.1415926535897932384626433832795L\n \nusing namespace std;\n \nint N, X, Y;\n \nvector<long double> x;\nvector<long double> y;\n \nint main()\n{\n    scanf(\"%d\", &N);\n \n    for (int i = 0; i < N; i++)\n    {\n        scanf(\"%d\", &X);\n        scanf(\"%d\", &Y);\n \n        x.push_back(X);\n        y.push_back(Y);\n    }\n \n    bool ok = true;\n \n    for (int i = 0; i < N - 1; i++)\n    {\n        // Translation.\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                x[j] -= x[i];\n                y[j] -= y[i];\n            }\n        }\n \n        x[i] = 0;\n        y[i] = 0;\n \n        // Rotate.\n \n        long double ang = PI - atan2l(y[i + 1], x[i + 1]);\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                long double ang2 = atan2l(y[j], x[j]) + ang;\n                long double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n \n                x[j] = radi * cosl(ang2);\n                y[j] = radi * sinl(ang2);\n            }\n        }\n        \n        long double maxc = -999.0L, minc = 999.0;\n \n        for(int j = i + 1; j < N; j++)\n        {\n            long double ang2 = atan2l(y[j], x[j]);\n            \n            maxc = max(maxc, ang2);\n            minc = min(minc, ang2);\n        }\n        \n        ang = -atan2l(y[i + 1], x[i + 1]);\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                long double ang2 = atan2l(y[j], x[j]) + ang;\n                long double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n \n                x[j] = radi * cosl(ang2);\n                y[j] = radi * sinl(ang2);\n            }\n        }\n        \n        long double maxd = -999.0L, mind = 999.0;\n \n        for(int j = 0; j < i; j++)\n        {\n            long double ang2 = atan2l(y[j], x[j]);\n            \n            maxd = max(maxc, ang2);\n            mind = min(minc, ang2);\n        }\n        \n        mind += PI;\n        maxd += PI;\n        \n        if(maxc - minc > PI || maxd - mind > PI) ok = false;\n    }\n \n    printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> pt;\n#define pb push_back\n#define mp make_pair\npt P[1005];\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble x,y; scanf(\"%lf%lf\",&x,&y);\n\t\tP[i] = pt(x,y);\n\t}\n\tfor(int i=2;i<n;i++){\n\t\tvector<pair<double,int> >vec;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tvec.pb(mp(arg(P[j]-P[i]),j));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\t//for(int j=0;j<vec.size();j++) cout << vec[j].second << \" \"; cout << endl;\n\t\tfor(int j=1;j<vec.size();j++){\n\t\t\tif( ((vec[j].second<i) ^ (vec[j-1].second<i)) == 1){\n\t\t\t\tbool p = (vec[j].second<i); int cnt = 1;\n\t\t\t\tfor(int k=(j+1)%vec.size();k!=j;k=(k+1)%vec.size()){\n\t\t\t\t\tif( (vec[k].second<i) != p){\n\t\t\t\t\t\tif( (p==1&&cnt==i-1) || (p==0&&cnt==n-i) ){\n\t\t\t\t\t\t\tgoto nxt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnxt:;\n\t}\n\tputs(\"Possible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n  \nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> V;\n  double x, y;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y;\n    V.emplace_back(x,y);\n  }\n  for(int i = 1; i < N; ++i){\n    P d = V[i] - V[i-1], o1 = V[i-1] + 0.5/abs(d)*d, o2 = V[i] - 0.5/abs(d)*d;\n    for(int j = 1; j < N; ++j){\n      if(i == j) continue;\n      if(dot(V[j-1]-o1,d)*dot(V[j]-o1,d) < 0 ||\n         dot(V[j-1]-o2,d)*dot(V[j]-o2,d) < 0){\n\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = complex<ld>;\nusing L = pair<V, V>;\nconstexpr ld PI = static_cast<ld>(3.1415926535898);\nconstexpr ld EPS = static_cast<ld>(1e-12);\n\n// 点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n// inline bool operator<(const C a, const C b){\n//     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n// }\n\nnamespace std\n{\ninline bool equal(const ld a, const ld b)\n{\n    return (-EPS < a - b and a - b < EPS);\n}\n\ninline bool operator<(const V& a, const V& b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\ninline bool operator==(const V& c1, const V& c2)\n{\n    return (equal(c1.real(), c2.real()) and equal(c1.imag(), c2.imag()));\n}\n\ninline bool operator!=(const V& a, const V& b)\n{\n    return !(a == b);\n}\n}\n\ninline ld Sqrt(const ld x)\n{\n    return (x < 0 ? 0 : sqrt(x));\n}\n\ninline V normalize(const V& c)\n{\n    return c / abs(c);\n}\n\ninline ld arg(const V& a, const V& b)\n{\n    return arg(b * conj(a));\n}\n\ninline ld cross(const V& a, const V& b)\n{\n    return imag(conj(a) * b);\n}\n\ninline ld dot(const V& a, const V& b)\n{\n    return real(conj(a) * b);\n}\n\ninline int ccw(const V& a, const V& b, const V& c)\n{\n    if (cross(b - a, c - a) > 0) {\n        return +1;  // counter clockwise\n    }\n    if (cross(b - a, c - a) < 0) {\n        return -1;  // clockwise\n    }\n    if (dot(b - a, c - a) < 0) {\n        return +2;  // c--a--b on line\n    }\n    if (norm(b - a) < norm(c - a)) {\n        return -2;  // a--b--c on line\n    }\n    return 0;  //b--a--c on line\n}\n\ninline bool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l.second - l.first, m.second - m.first)) > EPS or abs(cross(l.second - l.first, m.first - l.first)) < EPS;\n}\n\ninline bool intersectLS(const L& l, const L& s)\n{\n    return cross(l.second - l.first, s.first - l.first) * cross(l.second - l.first, s.second - l.first) < EPS;\n}\n\ninline bool intersectLP(const L& l, const V& p)\n{\n    return abs(cross(l.second - p, l.first - p)) < EPS;\n}\n\ninline bool intersectSS(const L& s, const L& t)\n{\n    return ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 and ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\ninline bool intersectSP(const L& s, const V& p)\n{\n    return abs(s.first - p) + abs(s.second - p) - abs(s.second - s.first) < EPS;\n}\n\ninline V crosspointLL(const L& l, const L& m)\n{\n    const ld A = cross(l.second - l.first, m.second - m.first);\n    const ld B = cross(l.second - l.first, l.second - m.first);\n    //同一直線のとき\n    if (abs(A) < EPS and abs(B) < EPS) {\n        return m.first;\n    }\n    return m.first + (B / A) * (m.second - m.first);\n}\n\n//点pを直線l上に射影\ninline V projection(const L& l, const V& p)\n{\n    const ld t = dot(p - l.first, l.first - l.second) / norm(l.first - l.second);\n    return l.first + t * (l.first - l.second);\n}\n\n//crosspointCLに使用する関数(命名が謎です)\ninline ld gettime(const V& c1, const V& c2)\n{\n    return (dot(c1, c2) < 0 ? -1.0 : 1.0) * abs(c2) / abs(c1);\n}\n\n//円と直線の交点\ninline vector<V> crosspointCL(const V& c1, const ld r1, const L& l)\n{\n    const V a = l.first;\n    const V b = l.second;\n    vector<V> res;\n    const V target = projection(L(a, b), c1);\n    const V base = normalize(b - a);\n    const ld h = abs(c1 - target);\n    if (r1 + EPS < h) {\n        return res;\n    }\n    const ld w = Sqrt(r1 * r1 - h * h);\n    const ld LL = gettime(normalize(b - a), target - a) - w;\n    const ld RR = LL + w * 2.0;\n    res.push_back(a + base * LL);\n    if (equal(LL, RR)) {\n        return res;\n    }\n    res.push_back(a + base * RR);\n    return res;\n}\n\n//円と線分の交点\ninline vector<V> crosspointCS(const V& c1, const ld r1, const L& s)\n{\n    vector<V> tmp = crosspointCL(c1, r1, s);\n    vector<V> res;\n    for (int i = 0; i < tmp.size(); i++) {\n        if (abs(s.second - s.first) == abs(s.first - tmp[i]) + abs(s.second - tmp[i])) {\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n\n//円どうしの交点\ninline L crosspointCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    const V a = conj(c2 - c1);\n    const V b = (r2 * r2 - r1 * r1 - (c2 - c1) * conj(c2 - c1));\n    const V c = r1 * r1 * (c2 - c1);\n    const V d = b * b - (ld)4.0 * a * c;\n    const V z1 = (-b + sqrt(d)) / ((ld)2.0 * a) + c1;\n    const V z2 = (-b - sqrt(d)) / ((ld)2.0 * a) + c1;\n    return L(z1, z2);\n}\n\n//点pを直線lを軸として対称移動\ninline V reflection(const L& l, const V& p)\n{\n    return p + (projection(l, p) - p) * (ld)2.0;\n}\n\n//点と直線の距離\ninline ld distanceLP(const L& l, const V& p)\n{\n    return abs(p - projection(l, p));\n}\n\n//直線と直線の距離\ninline ld distanceLL(const L& l, const L& m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\n\n//直線と線分の距離\ninline ld distanceLS(const L& l, const L& s)\n{\n    if (intersectLS(l, s)) {\n        return 0;\n    }\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\n//線分と点の距離\ninline ld distanceSP(const L& s, const V& p)\n{\n    const V r = projection(s, p);\n    if (intersectSP(s, r)) {\n        return abs(r - p);\n    }\n    return min(abs(s.first - p), abs(s.second - p));\n}\n\n//線分と線分の距離\ninline ld distanceSS(const L& s, const L& t)\n{\n    if (intersectSS(s, t)) {\n        return 0;\n    }\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\ninline ld getarea(const V& c1, const ld r1, const V& a, const V& b)\n{\n    const V va = c1 - a;\n    const V vb = c1 - b;\n    const ld A = abs(va);\n    const ld B = abs(vb);\n    const ld f = cross(va, vb);\n    const ld d = distanceSP(L(a, b), c1);\n    ld res = 0;\n    if (equal(f, (ld)0.0)) {\n        return 0;\n    }\n    if (A < r1 + EPS and B < r1 + EPS) {\n        return f * (ld)0.5;\n    }\n    if (d > r1 - EPS) {\n        return r1 * r1 * M_PI * arg(va, vb) / ((ld)2.0 * M_PI);\n    }\n    vector<V> u = crosspointCS(c1, r1, L(a, b));\n    u.insert(u.begin(), a);\n    u.push_back(b);\n    for (int i = 0; i + 1 < (int)u.size(); i++) {\n        res += getarea(c1, r1, u[i], u[i + 1]);\n    }\n    return res;\n}\n\n//円と多角形の共通部分の面積\ninline ld getcrossarea(const vector<V>& t, const V& c1, const ld r1)\n{\n    const int n = t.size();\n    if (n < 3) {\n        return 0;\n    }\n    ld res = 0;\n    for (int i = 0; i < n; i++) {\n        const V a = t[i];\n        const V b = t[(i + 1) % n];\n        res += getarea(c1, r1, a, b);\n    }\n    return res;\n}\n\n//凸包を求める(O(nlogn))\ninline vector<V> convex_hull(vector<V> ps)\n{\n    const int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    vector<V> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) {\n        while (k >= 2 and ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {\n        while (k >= t and ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\n//凸性判定\ninline bool isconvex(const vector<V>& ps)\n{\n    for (int i = 0; i < ps.size(); i++) {\n        if (ccw(ps[(i + ps.size() - 1) % ps.size()], ps[i], ps[(i + 1) % ps.size()])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//多角形の符号付き面積(左回りが正)\ninline ld area(const vector<V>& ps)\n{\n    ld A = 0;\n    for (int i = 0; i < ps.size(); i++) {\n        A += cross(ps[i], ps[(i + 1) % ps.size()]);\n    }\n    return A / (ld)2.0;\n}\n\n//凸多角形を直線で切断した時の左側の図形\nvector<V> convex_cut(const vector<V>& ps, const L& l)\n{\n    vector<V> Q;\n    for (int i = 0; i < ps.size(); i++) {\n        const V A = ps[i];\n        const V B = ps[(i + 1) % ps.size()];\n        if (ccw(l.first, l.second, A) != -1) {\n            Q.push_back(A);\n        }\n        if (ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) {\n            Q.push_back(crosspointLL(L(A, B), l));\n        }\n    }\n    return Q;\n}\n\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<V>& ps, const V& p)\n{\n    bool flag = false;\n    for (int i = 0; i < ps.size(); i++) {\n        V a = ps[i] - p;\n        V b = ps[(i + 1) % ps.size()] - p;\n        if (imag(a) > imag(b)) {\n            swap(a, b);\n        }\n        if (imag(a) <= 0 and 0 < imag(b)) {\n            if (cross(a, b) < 0) {\n                flag = not flag;\n            }\n        }\n        if (cross(a, b) == 0 and dot(a, b) <= 0)\n            return 1;\n    }\n    return flag ? 2 : 0;\n}\n\n//凸多角形の交差\nvector<V> convex_intersection(const vector<V>& ps, const vector<V>& qs)\n{\n    vector<V> rs;\n    const int a = ps.size();\n    const int b = qs.size();\n    for (int i = 0; i < a; i++) {\n        if (contains(qs, ps[i])) {\n            rs.push_back(ps[i]);\n        }\n    }\n    for (int i = 0; i < b; i++) {\n        if (contains(ps, qs[i])) {\n            rs.push_back(qs[i]);\n        }\n    }\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            const L l1(ps[i], ps[(i + 1) % a]);\n            const L l2(qs[j], qs[(j + 1) % b]);\n            if (intersectSS(l1, l2)) {\n                rs.push_back(crosspointLL(l1, l2));\n            }\n        }\n    }\n    sort(rs.begin(), rs.end());\n    rs.erase(unique(rs.begin(), rs.end()), rs.end());\n    if (rs.size() <= 1) {\n        return rs;\n    }\n    return convex_hull(rs);\n}\n\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ninline ld convex_diameter(const vector<V>& ps)\n{\n    const int n = ps.size();\n    int is = 0;\n    int js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) {\n            is = i;\n        }\n        if (imag(ps[i]) < imag(ps[js])) {\n            js = i;\n        }\n    }\n    ld maxd = abs(ps[is] - ps[js]);\n    int i;\n    int maxi;\n    int j;\n    int maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(ps[(i + 1) % ps.size()] - ps[i], ps[(j + 1) % ps.size()] - ps[j]) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        if (abs(ps[i] - ps[j]) > maxd) {\n            maxd = abs(ps[i] - ps[j]);\n            maxi = i;\n            maxj = j;\n        }\n    } while (i != is or j != js);\n    return maxd;\n}\n\ninline bool compyx(const V& c1, const V& c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ninline ld closest_pair(const vector<V>::iterator a, const int n)\n{\n    if (n <= 1) {\n        return 1e100;\n    }\n    int m = n / 2;\n    ld x = a[m].real();\n    ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n    inplace_merge(a, a + m, a + n, compyx);\n    vector<V> b;\n    for (int i = 0; i < n; i++) {\n        if (abs(x - a[i].real()) >= d) {\n            continue;\n        }\n        for (int j = 0; j < b.size(); j++) {\n            V dp = a[i] - b[b.size() - 1 - j];\n            if (dp.imag() >= d) {\n                break;\n            }\n            d = min(d, abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n//最近点対を求める\ninline ld compute_shortest(const vector<V>::iterator a, const int n)\n{\n    sort(a, a + n);\n    return closest_pair(a, n);\n}\n\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\ninline int getstateCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    ld d = abs(c1 - c2);\n    if (d > r1 + r2 + EPS) {\n        return 4;\n    }\n    if (d > r1 + r2 - EPS) {\n        return 3;\n    }\n    if (d > abs(r1 - r2) + EPS) {\n        return 2;\n    }\n    if (d > abs(r1 - r2) - EPS) {\n        return 1;\n    }\n    return 0;\n}\n\n//点から円へ接線を引いた時の接点\ninline V gettangentCP_(const V& c1, const ld r1, const V& p, const int flg)\n{\n    const V base = c1 - p;\n    const ld w = Sqrt(norm(base) - r1 * r1);\n    const V s = p + base * V(w, r1 * flg) / norm(base) * w;\n    return s;\n}\n\n//点から円への接線\ninline vector<L> gettangentCP(const V& c1, const ld r1, const V& p)\n{\n    vector<L> res;\n    const V s = gettangentCP_(c1, r1, p, 1);\n    const V t = gettangentCP_(c1, r1, p, -1);\n    //点が円の周上にある場合\n    if (s == t) {\n        res.push_back(L(s, s + (c1 - p) * V(0, 1)));\n    } else {\n        res.push_back(L(p, s));\n        res.push_back(L(p, t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\ninline L getintangent(const V& c1, const ld r1, const V& c2, const ld r2, const ld flg)\n{\n    const V base = c2 - c1;\n    const ld w = r1 + r2;\n    const ld h = Sqrt(norm(base) - w * w);\n    const V k = base * V(w, h * flg) / norm(base);\n    return L(c1 + k * r1, c2 - k * r2);\n}\n\n//2円の共通外接線を求める\ninline L getouttangent(const V& c1, const ld r1, const V& c2, const ld r2, const ld flg)\n{\n    const V base = c2 - c1;\n    const ld h = r2 - r1;\n    const ld w = Sqrt(norm(base) - h * h);\n    const V k = base * V(w, h * flg) / norm(base) * V(0, flg);\n    return L(c1 + k * r1, c2 + k * r2);\n}\n\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\ninline vector<L> gettangentCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    vector<L> res;\n    const ld d = abs(c1 - c2);\n    if (d > r1 + r2 + EPS) {\n        res.push_back(getintangent(c1, r1, c2, r2, 1));\n    }\n    if (d > r1 + r2 - EPS) {\n        res.push_back(getintangent(c1, r1, c2, r2, -1));\n    }\n    if (d > abs(r1 - r2) + EPS) {\n        res.push_back(getouttangent(c1, r1, c2, r2, 1));\n    }\n    if (d > abs(r1 - r2) - EPS) {\n        res.push_back(getouttangent(c1, r1, c2, r2, -1));\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<V> v(N);\n    vector<V> rev(N);\n    vector<vector<V>> cv(N);\n    vector<vector<V>> revcv(N);\n    for (int i = 0; i < N; i++) {\n        ld x, y;\n        cin >> x >> y;\n        v[i] = {x, y};\n        rev[N - 1 - i] = {x, y};\n    }\n    for (int i = 0; i < N; i++) {\n        cv[i] = convex_hull(vector<V>(v.begin(), v.begin() + i + 1));\n        revcv[i] = convex_hull(vector<V>(rev.begin(), rev.begin() + i + 1));\n    }\n    for (int i = 0; i < N; i++) {\n        if (convex_intersection(cv[i], revcv[N - i - 1]).size() >= 3) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <complex>\nusing namespace std;\n\nconst double EPS = 1e-7;\n\nbool lt(double a, double b){\n  //cout << a << \" < \" << b+EPS << endl;\n  return a < b + EPS;\n}\nbool eq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\ndouble angle(complex<double> a, complex<double> b){\n  double dot = a.real() * b.real() + a.imag() * b.imag();\n  return dot / (double)(abs(a)*abs(b));\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(eq(0, pts.at(target).real()));\n    assert(eq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(!lt(p.imag(), 0.0)){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(!lt(0.0, p.imag())){\n      return false;\n    }\n  }\n  return true;\n}\n\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n  for(int i = 0; i < n-1; i++){\n\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n    /*\n      for(int j = 0; j < n; j++){\n      cout << pts[j] << \" \";\n      }\n    cout << endl;\n    */\n    moveToO(i+1, pts);\n    /*\n      for(int j = 0; j < n; j++){\n      cout << pts[j] << \" \";\n      }\n    cout << endl;\n    */\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point c = { a.px - b.px,a.py - b.py }; return c; }\nSegment rot90(Point p1, Point p2) {\n\tSegment g; Point P1, P2, P3 = Minus(p2, p1);\n\tlong double c = max(P3.px, P3.py);\n\tlong double S1 = 2e10l / c; P3.px *= c; P3.py *= c;\n\tP1.px = -P3.py; P1.py = P3.px;\n\tP2.px = P3.py; P2.py = -P3.px;\n\tP1.px += p1.px; P1.py += p1.py;\n\tP2.px += p1.px; P2.py += p2.py;\n\tg.p1 = P1; g.p2 = P2; return g;\n}\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n}\nbool its(const Segment& s1, const Segment& s2) { return its(s1.p1, s1.p2, s2.p1, s2.p2); }\nint main() {\n\tSegment a[1000]; Point b[1000]; int N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> b[i].px >> b[i].py;\n\t\tif (i < N - 1)a[i].p1 = b[i];\n\t\tif (i >= 1)a[i - 1].p2 = b[i];\n\t}\n\tint OK = 1;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tSegment L1 = rot90(a[i].p1, a[i].p2);\n\t\tSegment L2 = rot90(a[i].p2, a[i].p1);\n\t\tint OK2 = 1;\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i)continue;\n\t\t\tif (its(a[j], L1) == true)OK2 = 0;\n\t\t}\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i)continue;\n\t\t\tif (its(a[j], L2) == true)OK2 = 0;\n\t\t}\n\t\tif (OK2 == 0)OK = 0;\n\t}\n\tif (OK == 1)cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\n\nbool lt(double a, double b){\n  return a < b - EPS;\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid print(const vector<complex<double>>& pts){\n  for(complex<double> p: pts){\n    cout << p.real() << \" \" << p.imag() << endl;\n  }\n  cout << \"===\";\n  cout << endl;\n}\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    //print(pts);\n\n    moveToO(i+1, pts);\n    //print(pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = long long;\nusing Point =  complex<ld>;\nconst ld eps = 0;//1e-9;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < 0)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nint main(){\n    int n;\n    cin>>n;\n    Point p[n];\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        p[i]=Point(x,y);\n    }\n    bool ok=true;\n    rep(_,2){\n        rep(i,n-1){\n            Point ls,rs,lp,rp;\n            ls=rs=2ll*p[i]-p[i+1];\n            lp=rp=p[i+1];\n            rep(j,i){\n                if(ccw(p[i],p[i+1],p[j])==-1&&ccw(p[i],ls,p[j])==1)ls=p[j];\n                if(ccw(p[i],p[i+1],p[j])==1&&ccw(p[i],rs,p[j])==-1)rs=p[j];\n            }\n            REP(j,i+2,n){\n                if(ccw(p[i],p[i+1],p[j])==-1&&ccw(p[i],lp,p[j])==-1)lp=p[j];\n                if(ccw(p[i],p[i+1],p[j])==1&&ccw(p[i],rp,p[j])==1)rp=p[j];\n            }\n            if(ccw(p[i],ls,rs)==1)ok=false;\n            if(ccw(p[i],lp,rp)==-1)ok=false;\n            if(ccw(p[i],ls,lp)==-1)ok=false;\n            if(ccw(p[i],rs,rp)==1)ok=false;\n        }\n        reverse(p,p+n);\n    }\n    if(ok){\n        cout<<\"Possible\"<<endl;\n    }\n    else cout<<\"Impossible\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr double EPS = 1e-10;\n\nstruct Point {\n    double x, y;\n\n    Point() {}\n    Point(double x, double y) : x{x}, y{y} {}\n\n    Point operator - (const Point& p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble dot(const Point& a, const Point& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point& p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point& p)\n{\n    return sqrt(norm(p));\n}\n\nconstexpr int COUNTER_CLOCKWISE = +1;\nconstexpr int CLOCKWISE         = -1;\nconstexpr int ONLINE_BACK       = +2;\nconstexpr int ONLINE_FRONT      = -2;\nconstexpr int ON_SEGMENT        = +0;\nusing Vector = Point;\n\nint ccw(const Point& p0, const Point& p1, const Point& p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nusing Polygon = vector<Point>;\n\nbool sortY(Point p1, Point p2)\n{\n    if (p1.y != p2.y) {\n        return (p1.y - p2.y < -EPS);\n    } else { \n        return (p1.x - p2.x < -EPS);\n    }\n}\n\nPolygon convex_hull(Polygon &ps)\n{\n    int N = ps.size(), j = 0;\n    Polygon pg(N * 2);\n    sort(ps.begin(), ps.end(), sortY);\n    for (int i = 0; i < N; i++) {\n        while (j > 1 && cross(pg[j - 1] - pg[j - 2], ps[i] - pg[j - 1]) <= 0) {\n            j--;\n        }\n        pg[j++] = ps[i];\n    }\n    int k = j;\n    for (int i = N - 2; i >= 0; i--) {\n        while (j > k && cross(pg[j - 1] - pg[j - 2], ps[i] - pg[j - 1]) <= 0) {\n            j--;\n        }\n        pg[j++] = ps[i];\n    }\n    pg.resize(j - 1);\n    return pg;\n}\n\ndouble area(const Polygon& pg)\n{\n    int N = pg.size();\n    double res = 0;\n    for (int i = 0; i < N; i++) {\n        res += cross(pg[i], pg[(i + 1) % N]);\n    }\n    return abs(res) / 2.0;\n}\n\nbool pass_snake(const vector<Point>& ps)\n{\n    int N = ps.size();\n    Polygon p;\n    double curr = 0, prev = 0;\n    \n    for (int i = 0; i < N; i++) {\n        p.emplace_back(ps[i]);\n        \n        if (i >= 2) {            \n            p = convex_hull(p);\n            curr = area(p);\n\n            if (abs(curr - prev) < EPS) {\n                return 0;\n            }\n        \n            prev = curr;\n        }\n    }\n    \n    return 1;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<Point> ps(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ps[i].x >> ps[i].y;\n    }\n    \n    bool poss = 1;\n    for (int i = 0; i < 2; i++) {\n        poss &= pass_snake(ps);\n        reverse(ps.begin(), ps.end());\n    }\n\n    cout << (poss ? \"Possible\" : \"Impossible\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define ALL(container) (container).begin(), (container).end()\n#define pb push_back\n#define eb emplace_back\n\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\ntypedef long double R;\ntypedef complex<R> P;\nR EPS = 1e-6;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return abs(a.X-b.X) > EPS ? a.X < b.X : a.Y+EPS < b.Y;}\n\tbool operator==(const P &a, const P &b){return abs(a-b) < EPS;}\n}\n\ninline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline R inp(const P& a, const P& b){return (conj(a)*b).X;}\ninline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\ninline P unit(const P& p){return p/abs(p);}\ninline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\ninline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\tint res = sig(outp(t-s, p-s));\n\tif(res || !adv) return res;\n\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n}\nstruct L : public vector<P>{\t// line\n\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\tL(){}\n\tP dir()const {return at(1) - at(0);}\n};\nstruct S : public L{\t// segment\n\tS(const P &p1, const P &p2):L(p1, p2){}\n\tS(){}\n};\ninline P crosspoint(const L &l, const L &m){\n\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\nstruct G : public vector<P>{\n\tG(size_type size=0):vector(size){}\n\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\n\tR area()const {\n\t\tR sum = 0;\n\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\treturn abs(sum / 2.);\n\t}\n\tG convex_hull(bool online = false) {\n\t\tif(size() < 2) return *this;\n\t\tsort(ALL(*this));\n\t\tG r;\n\t\tr.resize((int)size()*2);\n\t\tint k=0;\n\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\tint t = k;\n\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\tr.resize(k-1);\n\t\treturn r;\n\t}\n\tG cut(const L &l)const {\n\t\tG g;\n\t\tREP(i, size()){\n\t\t\tconst S &s = edge(i);\n\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t}\n\t\treturn g;\n\t}\n\tG cut(const G &l)const {\n\t\tG g = (*this);\n\t\tREP(i, l.size()){\n\t\t\tg = g.cut(l.edge(i));\n\t\t}\n\t\treturn g;\n\t}\n};\n\nint n;\n\nint check(G a, G b){\n\ta = a.convex_hull();\n\tb = b.convex_hull();\n\treturn b.area() < EPS || a.cut(b).area() < EPS;\n}\n\nint main(){\n\tcin >> n;\n\tG p, q;\n\tREP(i, n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp.eb(x, y);\n\t}\n\tREP(i, n){\n\t\tq.pb(p.back());\n\t\tif(!check(p, q)){\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tp.pop_back();\n\t}\n\tcout << \"Possible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nbool check(vector<long double> x, vector<long double> y)\n{\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i];\n\t\t\t\ty[j] -= y[i];\n\t\t\t}\n\t\t}\n\n\t\tx[i] = 0.0L;\n\t\ty[i] = 0.0L;\n\n\t\t// Rotate.\n\n\t\tbool ok = false;\n\n\t\tfor (long double target = 0.0L; target < PI; target += 0.1L)\n\t\t{\n\t\t\tlong double ang = target - atan2l(y[i + 1], x[i + 1]);\n\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tlong double ang2 = atan2l(y[j], x[j]) + ang;\n\t\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\t\tx[j] = radi * cosl(ang2);\n\t\t\t\t\ty[j] = radi * sinl(ang2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check.\n\n\t\t\tbool ok2 = true;\n\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tif (y[j] < -0.00000001L)\n\t\t\t\t{\n\t\t\t\t\tok2 = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok2)\n\t\t\t{\n\t\t\t\tok = true; break;\n\t\t\t}\n\t\t}\n\n\t\tif (!ok) return false;\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tvector<long double> x;\n\tvector<long double> y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tif (check(x, y))\n\t{\n\t\tprintf(\"Possible\\n\");\n\t}\n\telse\n\t{\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\n\t\tif (check(x, y))\n\t\t{\n\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//入れ方を2通り試す. 点0->1…の順で入れる場合は,\n//・点i-1->iをy軸正方向にした状態で点iを原点に置けるか(1<=i<n)\n//・点i->i+1をy軸正方向にした状態で点iを原点に置けるか(0<=i<n-1)\n//を判定するだけ. もう一方の入れ方は, 点番号の反転をすれば上記と同じ判定法.\n//回転がO(N)なので、全部でO(N^2)で解ける. (y_i > 0なので, 易しい)\n#include <iostream>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\nPoint p[1000];\n\nvoid move(Point q[], int id, Point mul) {\n\tint i;\n\tfor (i = 0; i < n; i++) q[i] = p[i];\n\tfor (i = 0; i < n; i++) q[i] *= mul;\n\tPoint trans = -q[id];\n\tfor (i = 0; i < n; i++) q[i] += trans;\n}\n\n//ここが本質\nbool isOk(Point q[], int id) {\n\tconst double eps = 1e-6;\n\tint i;\n\tfor (i = 0; i < id; i++) { if (q[i].imag() > eps) return false; }\n\tfor (i = id + 1; i < n; i++) { if (q[i].imag() < -eps) return false; }\n\treturn true;\n}\n\nbool regalA(int id) {\n\tstatic Point q[1000];\n\tPoint mul = Point(0, 1) / (p[id] - p[id - 1]); mul /= abs(mul);\n\tmove(q, id, mul);\n\treturn isOk(q, id);\n}\n\nbool regalB(int id) {\n\tstatic Point q[1000];\n\tPoint mul = Point(0, 1) / (p[id + 1] - p[id]); mul /= abs(mul);\n\tmove(q, id, mul);\n\treturn isOk(q, id);\n}\n\nbool check() {\n\tint i;\n\tfor (i = 1; i < n; i++) if (!regalA(i)) return false;\n\tfor (i = 0; i + 1 < n; i++) if (!regalB(i)) return false;\n\treturn true;\n}\n\nvoid reverseP() {\n\tint l = 0, r = n - 1;\n\twhile (l < r) {\n\t\tswap(p[l], p[r]);\n\t\tl++; r--;\n\t}\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t}\n\t\n\tbool res = check(); reverseP(); res |= check();\n\tif (res) cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < -EPS;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Point> ps;\n\tREP(i, n)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps.push_back(Point{ x, y });\n\t}\n\tvector<Line> ls;\n\tREP(i, n - 1) ls.push_back(Line{ ps[i], ps[i + 1] });\n\tbool f = true;\n\tFOR(i, 1, n - 1)\n\t{\n\t\tPoint v1 = ps[i] - ps[i - 1];\n\t\tPoint v2 = ps[i] - ps[i + 1];\n\t\tif (dot(v1, v2) > -EPS) f = false;\n\t}\n\tREP(i, ls.size())\n\t{\n\t\tPoint v = ls[i].a - ls[i].b;\n\t\tPoint t(-v.imag(),v.real());\n\t\tLine l1(ls[i].a, ls[i].a + t);\n\t\tLine l2(ls[i].b, ls[i].b + t);\n\t\tREP(j, ls.size())\n\t\t{\n\t\t\tif (abs(i - j) <= 1) continue;\n\t\t\tif (isis_ls(l1, ls[j]) || isis_ls(l2, ls[j])) f = false;\n\t\t}\n\t}\n\tputs(f ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=0;i<n-3;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tconv = convex_hull(ps);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> pt;\n#define pb push_back\n#define mp make_pair\npt P[1005];\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble x,y; scanf(\"%lf%lf\",&x,&y);\n\t\tP[i] = pt(x,y) * polar(1.0,1e-5);\n\t}\n\tif(n<=3){\n\t\tputs(\"Possible\"); return 0;\n\t}\n\tvector<pair<double,int> >vec;\n\tfor(int i=2;i<=n;i++){\n\t\tvec.pb(mp(arg(P[i]-P[1]),i));\n\t}\n\tsort(vec.begin(),vec.end());\n\t//for(int i=0;i<vec.size();i++) cout << vec[i].first << endl;\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].first-vec[i-1].first > 3.141592653589793-1e-10){\n\t\t\tgoto ok;\n\t\t}\n\t}\n\tif(vec[vec.size()-1].first-vec[0].first < 3.141592653589793+1e-10){\n\t\tgoto ok;\n\t}\n\tputs(\"Impossible\"); return 0; ok:;\n\tvec.clear();\n\tfor(int i=1;i<n;i++){\n\t\tvec.pb(mp(arg(P[i]-P[n]),i));\n\t}\n\tsort(vec.begin(),vec.end());\n\t//for(int i=0;i<vec.size();i++) cout << vec[i].first << endl;\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].first-vec[i-1].first > 3.141592653589793-1e-10){\n\t\t\tgoto ok2;\n\t\t}\n\t}\n\tif(vec[vec.size()-1].first-vec[0].first < 3.141592653589793+1e-10){\n\t\tgoto ok2;\n\t}\n\tputs(\"Impossible\"); return 0; ok2:;//puts(\"OK\");\n\tfor(int i=2;i<n;i++){\n\t\tvec.clear();\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tvec.pb(mp(arg(P[j]-P[i]),j));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\t//for(int j=0;j<vec.size();j++) cout << vec[j].first << \" \" << vec[j].second << \" \"; cout << endl;\n\t\tfor(int j=1;j<vec.size();j++){\n\t\t\tif( ((vec[j].second<i) ^ (vec[j-1].second<i)) == 1){\n\t\t\t\tbool p = (vec[j].second<i); int cnt = 1;\n\t\t\t\tfor(int k=(j+1)%vec.size();k!=j;k=(k+1)%vec.size()){\n\t\t\t\t\tif( (vec[k].second<i) != p){\n\t\t\t\t\t\tif( (p==1&&cnt==i-1) || (p==0&&cnt==n-i) ){\n\t\t\t\t\t\t    //cout << j << \" \" << k << endl;\n\t\t\t\t\t\t\t//j..(k+vec.size()-1)%vec.size()\n\t\t\t\t\t\t\tdouble A = vec[(k+vec.size()-1)%vec.size()].first-vec[j].first; if(A<0) A+=2*3.1415926535897932;\n\t\t\t\t\t\t\t//k%vec.size()...(j+vec.size()-1)%vec.size()\n\t\t\t\t\t\t\tdouble B = vec[(j+vec.size()-1)%vec.size()].first-vec[k].first; if(B<0) A+=2*3.1415926535897932;\n\t\t\t\t\t\t\t//cout << A << \" \" << B << endl;\n\t\t\t\t\t\t\tif(A > 3.141592653589793+1e-10 || B > 3.141592653589793+1e-10){\n\t\t\t\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto nxt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnxt:;\n\t}\n\tputs(\"Possible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<(m)+EPS)\n#define GE(n,m) ((n)+EPS>(m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c)>EPS) return 1;\n  if (cross(b,c)<-EPS) return -1; \n  if (dot(b,c)<-EPS) return 2; \n  if (norm(b)<norm(c)) return -2; \n  return 0; \n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\nVP convexHull(VP ps) { \n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i=0;i<n;ch[k++]=ps[i++])\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  for (int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])\n    while (k>=t&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  ch.resize(k-1);\n  return ch;\n}\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\nint main(){\n  int n;\n  cin>>n;\n  P p[n];\n  rep(i,n){\n    double a1,a2;\n    cin>>a1>>a2;\n    p[i]=P(a1,a2);\n  }\n  VP p1,p2;\n  rep(i,n)p1.push_back(p[i]);\n  rep(i,n){\n    if(i)p2.push_back(p[i-1]);\n    p1.erase(p1.begin());\n    VP a1,a2;\n    if(p1.size()>=3){\n      a1=convexHull(p1);\n      if(inConvex(p[i],a1)==1){cout<<\"Impossible\"<<endl;goto L;}\n    }\n    if(p2.size()>=3){\n      a2=convexHull(p2);\n      if(inConvex(p[i],a2)==1){cout<<\"Impossible\"<<endl;goto L;}\n    }\n  }\n  cout<<\"Possible\"<<endl;L:;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n \n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n \n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n \n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n \n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n    int s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n    int s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n    if(end) return (s1&s2)==(LEFT|RIGHT);\n    return (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n \n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n     \n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n    if(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n    if(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n    return abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n \n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n    int n=pol.size();\n    R sum=0;\n    rep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n    return abs(sum/2.0);\n}\n \n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n    int n=pol.size();\n    rep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n    return true;\n}\n \n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n    int n=pol.size(),res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n        bool f=sgn(imag(p-pol[i]))>=0;\n        bool s=sgn(imag(p-pol[(i+1)%n]))<0;\n        int sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n        bool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n        if(can&&f==s) res+=(2*f-1);\n    }\n    return res?2:0;\n}\n \n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n    VP check{l.s,l.t};\n    int n=pol.size();\n    rep(i,n){\n        L edge={pol[i],pol[(i+1)%n]};\n        if(iss(l,edge)) reg(check,cross(l,edge));\n    }\n    sort(_all(check));\n    n=check.size();\n    rep(i,n-1){\n        P m=(check[i]+check[i+1])/R(2.0);\n        if(in_polygon(pol,m)==false) return false;\n    }\n    return true;\n}\n \n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n    int n=pol.size(),k=0;\n    sort(_all(pol));\n    VP res(2*n);\n \n    //??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n    // down\n    rep(i,n){\n        while(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n        res[k++]=pol[i];\n    }\n    // up\n    int t=k;\n    rrep(i,n-1){\n        while(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n        res[k++]=pol[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n \nint main(void){\n    int n; cin >> n;\n\n    VP points(n);\n    for(auto & e : points) cin >> e;\n\n    string res = \"Possible\";\n    rep(i, n){\n        VP ps;\n        auto check = [&]{\n            VP convex = convex_hull(ps);\n            return in_polygon(convex, points[i]) == 0;\n        };\n\n        if(i >= 1){\n            ps = VP(begin(points), begin(points) + i);\n            if(not check()){\n                res = \"Impossible\";\n                break;\n            }\n        }\n        if(i < n - 1){\n            ps = VP(begin(points) + i + 1, end(points));\n            if(not check()){\n                res = \"Impossible\";\n                break;\n            }\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\ntypedef double D;      // À•W’l‚ÌŒ^Bdouble‚©long double‚ð‘z’è\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ‹–—eŒë·B–â‘è‚É‚æ‚Á‚Ä•Ï‚¦‚é\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) <= (m) + EPS)\n#define GE(n,m) ((n) + EPS >= (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// ŠOÏ@cross(a,b) = |a||b|sinƒÆ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nVP convexHull(VP ps) {  // Œ³‚Ì“_W‡‚ªƒ\\[ƒg‚³‚ê‚Ä‚¢‚¢‚È‚çVP&‚É\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // —]Œv‚È“_‚àŠÜ‚Þ‚È‚ç == -1 ‚Æ‚·‚é\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\n\nint main(){\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\tvector<double> x(N), y(N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lf%lf\", &x[i], &y[i]);\n\t}\n\tD newS, oldS;\n\toldS = -1;\n\tfor(i = 2; i <= N; i++){\n//\t\tprintf(\"i = %d\\n\", i);\n\t\tVP ps(i);\n\t\tfor(j = 0; j < i; j++){\n\t\t\tps[j] = P(x[j], y[j]);\n\t\t}\n\t\tVP ch = convexHull(ps);\n//\t\tprintf(\"ch.size() = %d\\n\", ch.size());\n\t\tnewS = area(ch);\n//\t\tprintf(\"newS = %lf\\n\", newS);\n\t\tif(LE(newS, oldS)){\n//\t\t\tprintf(\"1(i, oldS, newS) = (%d, %lf, %lf)\\n\", i, oldS, newS);\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\toldS = newS;\n\t}\n\toldS = -1;\n\tfor(i = 2; i <= N; i++){\n//\t\tprintf(\"i = %d\\n\", i);\n\t\tVP ps(i);\n\t\tfor(j = 0; j < i; j++){\n\t\t\tps[j] = P(x[N - 1 - j], y[N - 1 - j]);\n\t\t}\n\t\tVP ch = convexHull(ps);\n//\t\tprintf(\"ch.size() = %d\\n\", ch.size());\n\t\tnewS = area(ch);\n//\t\tprintf(\"newS = %lf\\n\", newS);\n\t\tif(LE(newS, oldS)){\n//\t\t\tprintf(\"2(i, oldS, newS) = (%d, %lf, %lf)\\n\", i, oldS, newS);\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\toldS = newS;\n\t}\n\tprintf(\"Possible\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr long double pi = acos(-1.0L), eps = 1e-10;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i];\n  }\n  bool valid = true;\n  for (int i = 1; i < n - 1; ++i) {\n    vector<pair<long double, int>> p;\n    for (int j = 0; j < n; ++j) {\n      if (j != i) {\n        p.emplace_back(atan2l(y[j] - y[i], x[j] - x[i]), j);\n      }\n    }\n    sort(begin(p), end(p));\n    p.push_back(p[0]);\n    p.back().first += 2 * pi;\n    int cnt = 0;\n    for (int j = 0; j < n - 1; ++j) {\n      cnt += (p[j].second < i) ^ (p[j + 1].second < i);\n    }\n    if (cnt != 2) {\n      valid = false;\n      break;\n    }\n    long double a = 0, b = 0;\n    for (int j = 0; j < n - 1; ++j) {\n      if (p[j].second < i and p[j + 1].second < i) {\n        a += p[j + 1].first - p[j].first;\n      }\n      if (p[j].second > i and p[j + 1].second > i) {\n        b += p[j + 1].first - p[j].first;\n      }\n    }\n    if (a > pi + eps or b > pi + eps) {\n      valid = false;\n      break;\n    }\n  }\n  cout << (valid ? \"Possible\\n\" : \"Impossible\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-12;\n\nbool lt(double a, double b){\n  return a < b - EPS;\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid print(const vector<complex<double>>& pts){\n  for(complex<double> p: pts){\n    cout << p.real() << \" \" << p.imag() << endl;\n  }\n  cout << \"===\";\n  cout << endl;\n}\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    print(pts);\n\n    moveToO(i+1, pts);\n    print(pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\nC++\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=__int128;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> x(n),y(n);\n    for(int i=0;i<n;i++){\n        long long xx,yy;\n        cin>>xx>>yy;\n        x[i]=xx,y[i]=yy;\n    }\n    bool res0=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res0&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res0&=(xx*a+yy*b<=0);\n        }\n    }\n    reverse(x.begin(),x.end());\n    reverse(y.begin(),y.end());\n    bool res1=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res1&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res1&=(xx*a+yy*b<=0);\n        }\n    }\n    \n    cout<<(res0 || res1 ? \"Possble\" : \"Impossible\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-12;\n\nbool lt(double a, double b){\n  return a < b - EPS;\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid print(const vector<complex<double>>& pts){\n  for(complex<double> p: pts){\n    cout << p.real() << \" \" << p.imag() << endl;\n  }\n  cout << \"===\";\n  cout << endl;\n}\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    print(pts);\n\n    moveToO(i+1, pts);\n    print(pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, int> ld_i;\n\nint main() {\n\tld PI = acosl(-1);\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> x[i] >> y[i];\n\tfor (int k = 0; k < N; k++) {\n\t\tvector<ld_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i == k) continue;\n\t\t\tld a = atan2l(x[i] - x[k], y[i] - y[k]);\n\t\t\tv.push_back(ld_i(a, i < k));\n\t\t}\n\t\tint n = v.size();\n\t\tsort(v.begin(), v.end());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv.push_back(v[i]);\n\t\t\tv.back().first += PI*2;\n\t\t}\n\t\tint a = 0, b = 0, j = 0;\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (; v[j].first < v[i].first + PI; j++)\n\t\t\t\tif (v[j].second) a++;\n\t\t\t\telse b++;\n\t\t\tif ((a == k && b == 0) || (a == 0 && b == N - 1 - k))\n\t\t\t\tok = true;\n\t\t\tif (v[i].second) a--;\n\t\t\telse b--;\n\t\t}\n\t\tif (!ok) {\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> x(n),y(n);\n    for(int i=0;i<n;i++){\n        cin>>x[i]>>y[i];\n    }\n    bool res0=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res0&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res0&=(xx*a+yy*b<=0);\n        }\n    }\n    bool res1=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res1&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res1&=(xx*a+yy*b<=0);\n        }\n    }\n    \n    cout<<(res0 || res1 ? \"Possble\" : \"Impossible\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = complex<ld>;\nusing L = pair<V, V>;\nconstexpr ld PI = static_cast<ld>(3.1415926535898);\nconstexpr ld EPS = static_cast<ld>(1e-12);\n\n// 点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n// inline bool operator<(const C a, const C b){\n//     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n// }\n\nnamespace std\n{\ninline bool equal(const ld a, const ld b)\n{\n    return (-EPS < a - b and a - b < EPS);\n}\n\ninline bool operator<(const V& a, const V& b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\ninline bool operator==(const V& c1, const V& c2)\n{\n    return (equal(c1.real(), c2.real()) and equal(c1.imag(), c2.imag()));\n}\n\ninline bool operator!=(const V& a, const V& b)\n{\n    return !(a == b);\n}\n}\n\ninline ld Sqrt(const ld x)\n{\n    return (x < 0 ? 0 : sqrt(x));\n}\n\ninline V normalize(const V& c)\n{\n    return c / abs(c);\n}\n\ninline ld arg(const V& a, const V& b)\n{\n    return arg(b * conj(a));\n}\n\ninline ld cross(const V& a, const V& b)\n{\n    return imag(conj(a) * b);\n}\n\ninline ld dot(const V& a, const V& b)\n{\n    return real(conj(a) * b);\n}\n\ninline int ccw(const V& a, const V& b, const V& c)\n{\n    if (cross(b - a, c - a) > 0) {\n        return +1;  // counter clockwise\n    }\n    if (cross(b - a, c - a) < 0) {\n        return -1;  // clockwise\n    }\n    if (dot(b - a, c - a) < 0) {\n        return +2;  // c--a--b on line\n    }\n    if (norm(b - a) < norm(c - a)) {\n        return -2;  // a--b--c on line\n    }\n    return 0;  //b--a--c on line\n}\n\ninline bool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l.second - l.first, m.second - m.first)) > EPS or abs(cross(l.second - l.first, m.first - l.first)) < EPS;\n}\n\ninline bool intersectLS(const L& l, const L& s)\n{\n    return cross(l.second - l.first, s.first - l.first) * cross(l.second - l.first, s.second - l.first) < EPS;\n}\n\ninline bool intersectLP(const L& l, const V& p)\n{\n    return abs(cross(l.second - p, l.first - p)) < EPS;\n}\n\ninline bool intersectSS(const L& s, const L& t)\n{\n    return ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 and ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\ninline bool intersectSP(const L& s, const V& p)\n{\n    return abs(s.first - p) + abs(s.second - p) - abs(s.second - s.first) < EPS;\n}\n\ninline V crosspointLL(const L& l, const L& m)\n{\n    const ld A = cross(l.second - l.first, m.second - m.first);\n    const ld B = cross(l.second - l.first, l.second - m.first);\n    //同一直線のとき\n    if (abs(A) < EPS and abs(B) < EPS) {\n        return m.first;\n    }\n    return m.first + (B / A) * (m.second - m.first);\n}\n\n//点pを直線l上に射影\ninline V projection(const L& l, const V& p)\n{\n    const ld t = dot(p - l.first, l.first - l.second) / norm(l.first - l.second);\n    return l.first + t * (l.first - l.second);\n}\n\n//crosspointCLに使用する関数(命名が謎です)\ninline ld gettime(const V& c1, const V& c2)\n{\n    return (dot(c1, c2) < 0 ? -1.0 : 1.0) * abs(c2) / abs(c1);\n}\n\n//円と直線の交点\ninline vector<V> crosspointCL(const V& c1, const ld r1, const L& l)\n{\n    const V a = l.first;\n    const V b = l.second;\n    vector<V> res;\n    const V target = projection(L(a, b), c1);\n    const V base = normalize(b - a);\n    const ld h = abs(c1 - target);\n    if (r1 + EPS < h) {\n        return res;\n    }\n    const ld w = Sqrt(r1 * r1 - h * h);\n    const ld LL = gettime(normalize(b - a), target - a) - w;\n    const ld RR = LL + w * 2.0;\n    res.push_back(a + base * LL);\n    if (equal(LL, RR)) {\n        return res;\n    }\n    res.push_back(a + base * RR);\n    return res;\n}\n\n//円と線分の交点\ninline vector<V> crosspointCS(const V& c1, const ld r1, const L& s)\n{\n    vector<V> tmp = crosspointCL(c1, r1, s);\n    vector<V> res;\n    for (int i = 0; i < tmp.size(); i++) {\n        if (abs(s.second - s.first) == abs(s.first - tmp[i]) + abs(s.second - tmp[i])) {\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n\n//円どうしの交点\ninline L crosspointCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    const V a = conj(c2 - c1);\n    const V b = (r2 * r2 - r1 * r1 - (c2 - c1) * conj(c2 - c1));\n    const V c = r1 * r1 * (c2 - c1);\n    const V d = b * b - (ld)4.0 * a * c;\n    const V z1 = (-b + sqrt(d)) / ((ld)2.0 * a) + c1;\n    const V z2 = (-b - sqrt(d)) / ((ld)2.0 * a) + c1;\n    return L(z1, z2);\n}\n\n//点pを直線lを軸として対称移動\ninline V reflection(const L& l, const V& p)\n{\n    return p + (projection(l, p) - p) * (ld)2.0;\n}\n\n//点と直線の距離\ninline ld distanceLP(const L& l, const V& p)\n{\n    return abs(p - projection(l, p));\n}\n\n//直線と直線の距離\ninline ld distanceLL(const L& l, const L& m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\n\n//直線と線分の距離\ninline ld distanceLS(const L& l, const L& s)\n{\n    if (intersectLS(l, s)) {\n        return 0;\n    }\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\n//線分と点の距離\ninline ld distanceSP(const L& s, const V& p)\n{\n    const V r = projection(s, p);\n    if (intersectSP(s, r)) {\n        return abs(r - p);\n    }\n    return min(abs(s.first - p), abs(s.second - p));\n}\n\n//線分と線分の距離\ninline ld distanceSS(const L& s, const L& t)\n{\n    if (intersectSS(s, t)) {\n        return 0;\n    }\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\ninline ld getarea(const V& c1, const ld r1, const V& a, const V& b)\n{\n    const V va = c1 - a;\n    const V vb = c1 - b;\n    const ld A = abs(va);\n    const ld B = abs(vb);\n    const ld f = cross(va, vb);\n    const ld d = distanceSP(L(a, b), c1);\n    ld res = 0;\n    if (equal(f, (ld)0.0)) {\n        return 0;\n    }\n    if (A < r1 + EPS and B < r1 + EPS) {\n        return f * (ld)0.5;\n    }\n    if (d > r1 - EPS) {\n        return r1 * r1 * M_PI * arg(va, vb) / ((ld)2.0 * M_PI);\n    }\n    vector<V> u = crosspointCS(c1, r1, L(a, b));\n    u.insert(u.begin(), a);\n    u.push_back(b);\n    for (int i = 0; i + 1 < (int)u.size(); i++) {\n        res += getarea(c1, r1, u[i], u[i + 1]);\n    }\n    return res;\n}\n\n//円と多角形の共通部分の面積\ninline ld getcrossarea(const vector<V>& t, const V& c1, const ld r1)\n{\n    const int n = t.size();\n    if (n < 3) {\n        return 0;\n    }\n    ld res = 0;\n    for (int i = 0; i < n; i++) {\n        const V a = t[i];\n        const V b = t[(i + 1) % n];\n        res += getarea(c1, r1, a, b);\n    }\n    return res;\n}\n\n//凸包を求める(O(nlogn))\ninline vector<V> convex_hull(vector<V> ps)\n{\n    const int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    vector<V> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) {\n        while (k >= 2 and ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {\n        while (k >= t and ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\n//凸性判定\ninline bool isconvex(const vector<V>& ps)\n{\n    for (int i = 0; i < ps.size(); i++) {\n        if (ccw(ps[(i + ps.size() - 1) % ps.size()], ps[i], ps[(i + 1) % ps.size()])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//多角形の符号付き面積(左回りが正)\ninline ld area(const vector<V>& ps)\n{\n    ld A = 0;\n    for (int i = 0; i < ps.size(); i++) {\n        A += cross(ps[i], ps[(i + 1) % ps.size()]);\n    }\n    return A / (ld)2.0;\n}\n\n//凸多角形を直線で切断した時の左側の図形\nvector<V> convex_cut(const vector<V>& ps, const L& l)\n{\n    vector<V> Q;\n    for (int i = 0; i < ps.size(); i++) {\n        const V A = ps[i];\n        const V B = ps[(i + 1) % ps.size()];\n        if (ccw(l.first, l.second, A) != -1) {\n            Q.push_back(A);\n        }\n        if (ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) {\n            Q.push_back(crosspointLL(L(A, B), l));\n        }\n    }\n    return Q;\n}\n\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<V>& ps, const V& p)\n{\n    bool flag = false;\n    for (int i = 0; i < ps.size(); i++) {\n        V a = ps[i] - p;\n        V b = ps[(i + 1) % ps.size()] - p;\n        if (imag(a) > imag(b)) {\n            swap(a, b);\n        }\n        if (imag(a) <= 0 and 0 < imag(b)) {\n            if (cross(a, b) < 0) {\n                flag = not flag;\n            }\n        }\n        if (cross(a, b) == 0 and dot(a, b) <= 0)\n            return 1;\n    }\n    return flag ? 2 : 0;\n}\n\n//凸多角形の交差\nvector<V> convex_intersection(const vector<V>& ps, const vector<V>& qs)\n{\n    vector<V> rs;\n    const int a = ps.size();\n    const int b = qs.size();\n    for (int i = 0; i < a; i++) {\n        if (contains(qs, ps[i])) {\n            rs.push_back(ps[i]);\n        }\n    }\n    for (int i = 0; i < b; i++) {\n        if (contains(ps, qs[i])) {\n            rs.push_back(qs[i]);\n        }\n    }\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            const L l1(ps[i], ps[(i + 1) % a]);\n            const L l2(qs[j], qs[(j + 1) % b]);\n            if (intersectSS(l1, l2)) {\n                rs.push_back(crosspointLL(l1, l2));\n            }\n        }\n    }\n    sort(rs.begin(), rs.end());\n    rs.erase(unique(rs.begin(), rs.end()), rs.end());\n    if (rs.size() <= 1) {\n        return rs;\n    }\n    return convex_hull(rs);\n}\n\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ninline ld convex_diameter(const vector<V>& ps)\n{\n    const int n = ps.size();\n    int is = 0;\n    int js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) {\n            is = i;\n        }\n        if (imag(ps[i]) < imag(ps[js])) {\n            js = i;\n        }\n    }\n    ld maxd = abs(ps[is] - ps[js]);\n    int i;\n    int maxi;\n    int j;\n    int maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(ps[(i + 1) % ps.size()] - ps[i], ps[(j + 1) % ps.size()] - ps[j]) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        if (abs(ps[i] - ps[j]) > maxd) {\n            maxd = abs(ps[i] - ps[j]);\n            maxi = i;\n            maxj = j;\n        }\n    } while (i != is or j != js);\n    return maxd;\n}\n\ninline bool compyx(const V& c1, const V& c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ninline ld closest_pair(const vector<V>::iterator a, const int n)\n{\n    if (n <= 1) {\n        return 1e100;\n    }\n    int m = n / 2;\n    ld x = a[m].real();\n    ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n    inplace_merge(a, a + m, a + n, compyx);\n    vector<V> b;\n    for (int i = 0; i < n; i++) {\n        if (abs(x - a[i].real()) >= d) {\n            continue;\n        }\n        for (int j = 0; j < b.size(); j++) {\n            V dp = a[i] - b[b.size() - 1 - j];\n            if (dp.imag() >= d) {\n                break;\n            }\n            d = min(d, abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n//最近点対を求める\ninline ld compute_shortest(const vector<V>::iterator a, const int n)\n{\n    sort(a, a + n);\n    return closest_pair(a, n);\n}\n\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\ninline int getstateCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    ld d = abs(c1 - c2);\n    if (d > r1 + r2 + EPS) {\n        return 4;\n    }\n    if (d > r1 + r2 - EPS) {\n        return 3;\n    }\n    if (d > abs(r1 - r2) + EPS) {\n        return 2;\n    }\n    if (d > abs(r1 - r2) - EPS) {\n        return 1;\n    }\n    return 0;\n}\n\n//点から円へ接線を引いた時の接点\ninline V gettangentCP_(const V& c1, const ld r1, const V& p, const int flg)\n{\n    const V base = c1 - p;\n    const ld w = Sqrt(norm(base) - r1 * r1);\n    const V s = p + base * V(w, r1 * flg) / norm(base) * w;\n    return s;\n}\n\n//点から円への接線\ninline vector<L> gettangentCP(const V& c1, const ld r1, const V& p)\n{\n    vector<L> res;\n    const V s = gettangentCP_(c1, r1, p, 1);\n    const V t = gettangentCP_(c1, r1, p, -1);\n    //点が円の周上にある場合\n    if (s == t) {\n        res.push_back(L(s, s + (c1 - p) * V(0, 1)));\n    } else {\n        res.push_back(L(p, s));\n        res.push_back(L(p, t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\ninline L getintangent(const V& c1, const ld r1, const V& c2, const ld r2, const ld flg)\n{\n    const V base = c2 - c1;\n    const ld w = r1 + r2;\n    const ld h = Sqrt(norm(base) - w * w);\n    const V k = base * V(w, h * flg) / norm(base);\n    return L(c1 + k * r1, c2 - k * r2);\n}\n\n//2円の共通外接線を求める\ninline L getouttangent(const V& c1, const ld r1, const V& c2, const ld r2, const ld flg)\n{\n    const V base = c2 - c1;\n    const ld h = r2 - r1;\n    const ld w = Sqrt(norm(base) - h * h);\n    const V k = base * V(w, h * flg) / norm(base) * V(0, flg);\n    return L(c1 + k * r1, c2 + k * r2);\n}\n\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\ninline vector<L> gettangentCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    vector<L> res;\n    const ld d = abs(c1 - c2);\n    if (d > r1 + r2 + EPS) {\n        res.push_back(getintangent(c1, r1, c2, r2, 1));\n    }\n    if (d > r1 + r2 - EPS) {\n        res.push_back(getintangent(c1, r1, c2, r2, -1));\n    }\n    if (d > abs(r1 - r2) + EPS) {\n        res.push_back(getouttangent(c1, r1, c2, r2, 1));\n    }\n    if (d > abs(r1 - r2) - EPS) {\n        res.push_back(getouttangent(c1, r1, c2, r2, -1));\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<V> v(N);\n    vector<vector<V>> cv(N);\n    for (int i = 0; i < N; i++) {\n        ld x, y;\n        cin >> x >> y;\n        v[i] = {x, y};\n    }\n    for (int i = 0; i < N; i++) {\n        cv[i] = convex_hull(vector<V>(v.begin(), v.begin() + i + 1));\n    }\n    for (int i = 1; i < N; i++) {\n        if (contains(cv[i - 1], v[i]) == 2) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    reverse(v.begin(), v.end());\n    for (int i = 0; i < N; i++) {\n        cv[i] = convex_hull(vector<V>(v.begin(), v.begin() + i + 1));\n    }\n    for (int i = 1; i < N; i++) {\n        if (contains(cv[i - 1], v[i]) == 2) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nbool solve(){\n    int n;\n    cin >>n;\n    vector<ll> x(n),y(n);\n    rep(i,n) cin >>x[i] >>y[i];\n\n    rep(i,n-1){\n        ll Dx = x[i+1]-x[i], Dy = y[i+1]-y[i];\n\n        ll b = Dx*x[i] + Dy*y[i] - x[i+1]*Dx - y[i+1]*Dy;\n        for(int j=i+1; j<n; ++j){\n            ll t = Dx*x[j] + Dy*y[j] - x[i+1]*Dx - y[i+1]*Dy;\n            if(b<0 && t<0) return false;\n            if(b>0 && t>0) return false;\n        }\n    }\n\n    return true;\n}\n\nint main(){\n    cout << (solve()?\"Possible\":\"Impossible\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nbool check(vector<long double> x, vector<long double> y)\n{\n\t// Translation.\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tx[i] -= x[0];\n\t\ty[i] -= y[0];\n\t}\n\n\tx[0] = 0.0L;\n\ty[0] = 0.0L;\n\n\t\n\t// Query.\n\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Rotate.\n\n\t\tlong double ang = PI / 2.0L - atan2l(y[i + 1], x[i + 1);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double angl = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(angl);\n\t\t\t\ty[j] = radi * sinl(angl);\n\t\t\t}\n\t\t}\n\n\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i + 1 != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i + 1];\n\t\t\t\ty[j] -= y[i + 1];\n\t\t\t}\n\n\t\t\tx[i + 1] = 0;\n\t\t\ty[i + 1] = 0;\n\t\t}\n\n\n\t\t// Check.\n\n\t\tfor (int j = i + 2; j < N; j++)\n\t\t{\n\t\t\tif (y[j] < 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tvector<long double> x;\n\tvector<long double> y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tif (check(x, y))\n\t{\n\t\tprintf(\"Possible\\n\");\n\t}\n\telse\n\t{\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\n\t\tif (check(x, y))\n\t\t{\n\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\nll cross(ll x1,ll y1,ll x2,ll y2){\n\treturn x1*y2 - x2*y1;\n}\n\nbool is_over(ll x1,ll y1,ll x2,ll y2,ll a,ll b){\n\tif(cross(x2-x1,y2-y1,a-x1,b-y1)>0){\n\t\treturn 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\nbool is_cross(ll ax,ll ay,ll bx,ll by,ll cx,ll cy,ll dx,ll dy){\n\tll ta = (cx-dx) * (ay-cy) + (cy-dy) * (cx-ax);\n\tll tb = (cx-dx) * (by-cy) + (cy-dy) * (cx-bx);\n\tll tc = (ax-bx) * (cy-ay) + (ay-by) * (ax-cx);\n\tll td = (ax-bx) * (dy-ay) + (ay-by) * (ax-dx);\n\tif(ta>0)ta=1;\n\telse ta = -1;\n\tif(tb>0)tb=1;\n\telse tb = -1;\n\tif(tc>0)tc=1;\n\telse tc = -1;\n\tif(td>0)td=1;\n\telse td = -1;\n\treturn tc*td < 0 && ta*tb <0;\n}\n\nbool p[2000];\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<ll>x(n),y(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=0;i<n-1;i++){\n\t\tvector<int>v,w;\n\t\tfor(int j=i+2;j<n;j++){\n\t\t\tif(is_over(x[i],y[i],x[i+1],y[i+1],x[j],y[j])){\n\t\t\t\tv.PB(j);\n\t\t\t}else{\n\t\t\t\tw.PB(j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<v.size();j++){\n\t\t\tfor(int k=0;k<w.size();k++){\n\t\t\t\tif(is_cross(x[i],y[i],x[i+1],y[i+1],x[v[j]],y[v[j]],x[w[k]],y[w[k]])){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag)break;\n\t\tbool q=0,r=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tfor(int k=i+2;k<n;k++){\n\t\t\t\tif(is_over(x[i+1],y[i+1],x[k],y[k],x[j],y[j])){\n\t\t\t\t\tq=1;\n\t\t\t\t}else{\n\t\t\t\t\tr=1;\n\t\t\t\t}\n\t\t\t\tif(q&&r){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag)break;\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n  \nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> V;\n  double x, y;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y;\n    V.emplace_back(x,y);\n  }\n  for(int i = 1; i < N; ++i){\n    P d = V[i] - V[i-1];\n    bool f = false, g = false;\n    for(int j = 0; j < N; ++j){\n      if(i == j || j == i-1) continue;\n      if(dot(d,V[j]-V[i]) < 0){\n        if(cross(d,V[j]-V[i]) < 0) f = true;\n        else g = true;\n      }\n    }\n    if(f && g){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point c = { a.px - b.px,a.py - b.py }; return c; }\nSegment rot90(Point p1, Point p2) {\n\tSegment g; Point P1, P2, P3 = Minus(p2, p1);\n\tlong double c = max(P3.px, P3.py);\n\tlong double S1 = 2e9l / c; P3.px *= c; P3.py *= c;\n\tP1.px = -P3.py; P1.py = P3.px;\n\tP2.px = P3.py; P2.py = -P3.px;\n\tP1.px += p1.px; P1.py += p1.py;\n\tP2.px += p1.px; P2.py += p2.py;\n\tg.p1 = P1; g.p2 = P2; return g;\n}\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n}\nbool its(const Segment& s1, const Segment& s2) { return its(s1.p1, s1.p2, s2.p1, s2.p2); }\nint main() {\n\tSegment a[1000]; Point b[1000]; int N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> b[i].px >> b[i].py;\n\t\tif (i < N - 1)a[i].p1 = b[i];\n\t\tif (i >= 1)a[i - 1].p2 = b[i];\n\t}\n\tint OK = 1;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tSegment L1 = rot90(a[i].p1, a[i].p2);\n\t\tSegment L2 = rot90(a[i].p2, a[i].p1);\n\t\tint OK2 = 1;\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i)continue;\n\t\t\tif (its(a[j], L1) == true)OK2 = 0;\n\t\t}\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i)continue;\n\t\t\tif (its(a[j], L2) == true)OK2 = 0;\n\t\t}\n\t\tif (OK2 == 0)OK = 0;\n\t}\n\tif (OK == 1)cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=1;i<n;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tconv = convex_hull(ps);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<C> ps2;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps2.push_back(z);\n\t\t}\n\t\tconv = convex_hull(ps2);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> x(n),y(n);\n    for(int i=0;i<n;i++){\n        cin>>x[i]>>y[i];\n    }\n    bool res0=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res0&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res0&=(xx*a+yy*b<=0);\n        }\n    }\n    reverse(x.begin(),x.end());\n    reverse(y.begin(),y.end());\n    bool res1=true;\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<i;j++){\n            ll xx=x[i+1]-x[i];\n            ll yy=y[i+1]-y[i];\n            ll a=x[j]-x[i];\n            ll b=y[j]-y[i];\n            res1&=(xx*a+yy*b<=0);\n        }\n        for(int j=i+2;j<n;j++){\n            ll xx=x[i]-x[i+1];\n            ll yy=y[i]-y[i+1];\n            ll a=x[j]-x[i+1];\n            ll b=y[j]-y[i+1];\n            res1&=(xx*a+yy*b<=0);\n        }\n    }\n    \n    cout<<(res0 || res1 ? \"Possble\" : \"Impossible\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n  \nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> V;\n  double x, y;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y;\n    V.emplace_back(x,y);\n  }\n  for(int i = 1; i < N; ++i){\n    P d = V[i] - V[i-1];\n    double l = 0, r = 0;\n    for(int j = i+1; j < N; ++j){\n      //if(i == j || j == i-1) continue;\n      P v = V[j] - V[i];\n      if(cross(d,V[j]-V[i]) > 0){\n        l = max(l,acos(dot(d,v)/abs(d)/abs(v)));\n      }else{\n        r = max(r,acos(dot(d,v)/abs(d)/abs(v)));\n      }\n    }\n    if(r + l > acos(-1)){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef long double R;\n\tconst R INF = 1e8;\n\tR EPS = 1e-12;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nint f = 0;\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y+EPS < b.Y;}\n\tbool operator==(const P &a, const P &b){return abs(a-b) < EPS;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n}\n\nint n;\n\nint check(P p, const vector<P> &a, const vector<P> &b){\n\tconst R PI = 2*atan2(1, 0);\n\tvector<pair<R, int>> args(1, make_pair(INF, 0));\n\tfor(auto &q : a){\n\t\tR a = arg(q - p);\n\t\targs.eb(a, 0);\n\t\targs.eb(a+2*PI, 0);\n\t}\n\tfor(auto &q : b){\n\t\tR a = arg(q - p);\n\t\targs.eb(a, 1);\n\t\targs.eb(a+2*PI, 1);\n\t}\n\tsort(ALL(args));\n\tint j=0;\n\tint ans = n-1;\n\tint c[2] = {0, 0};\n\tREP(i, n-1){\n\t\twhile(args[j].first < args[i].first+PI- EPS) c[args[j++].second]++;\n\t\tif(c[0] == 0 && c[1] == b.size()) return 1;\n\t\tif(c[1] == 0 && c[0] == a.size()) return 1;\n\t\tc[args[i].second]--;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> n;\n\tvector<P> p, q;\n\tREP(i, n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp.eb(x, y);\n\t}\n\tREP(i, n){\n\t\tP t = p.back();\n\t\tp.pop_back();\n\t\tif(!check(t, p, q)){\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tq.pb(t);\n\t}\n\tcout << \"Possible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-7;\n\nbool lt(double a, double b){\n  return a < (b - EPS);\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\ndouble angle(complex<double> a, complex<double> b){\n  double dot = a.real() * b.real() + a.imag() * b.imag();\n  return dot / (double)(abs(a)*abs(b));\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      //      cout << target << \" \" << i << \"JJJ\" << endl;\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n  check(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    moveToO(i+1, pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\n#define PI 3.1415926535897932384626433832795L\n\nusing namespace std;\n\nint N, X, Y;\n\nvector<long double> x;\nvector<long double> y;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\tx.push_back(X);\n\t\ty.push_back(Y);\n\t}\n\n\tbool ok = true;\n\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\t// Translation.\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tx[j] -= x[i];\n\t\t\t\ty[j] -= y[i];\n\t\t\t}\n\t\t}\n\n\t\tx[i] = 0;\n\t\ty[i] = 0;\n\n\t\t// Rotate.\n\n\t\tlong double ang = -atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double ang2 = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(ang2);\n\t\t\t\ty[j] = radi * sinl(ang2);\n\t\t\t}\n\t\t}\n\n\t\tlong double maxc = -999.0L, minc = 999.0;\n\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tlong double ang2 = atan2l(y[j], x[j]);\n\n\t\t\tmaxc = max(maxc, ang2);\n\t\t\tminc = min(minc, ang2);\n\t\t}\n\n\t\tang = PI - atan2l(y[i + 1], x[i + 1]);\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tlong double ang2 = atan2l(y[j], x[j]) + ang;\n\t\t\t\tlong double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n\n\t\t\t\tx[j] = radi * cosl(ang2);\n\t\t\t\ty[j] = radi * sinl(ang2);\n\t\t\t}\n\t\t}\n\n\t\tlong double maxd = -999.0L, mind = 999.0;\n\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tlong double ang2 = atan2l(y[j], x[j]);\n\n\t\t\tmaxd = max(maxd, ang2);\n\t\t\tmind = min(mind, ang2);\n\t\t}\n\n\t\tif (maxc - minc > PI || (maxd - mind > PI && i != 0)) ok = false;\n\t}\n\n\tprintf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nbool in(double A,double B,double C){\n\t//angle in\n\t//角度がAとBの間かどうかを調べる\n\tif(A>B){swap(A,B);}\n\treturn ((A<C&&C<B)==(B-A<pai));\n}\ndouble R(double X){return (X>0?X-pai:X+pai);}\nint main(void){\n\tint n,i,j;cin>>n;\n\t\n\t//各点について考えるだけでok?\n\tvector<pair<double,double>>pot(n);\n\tfor(i=0;i<n;i++){cin>>pot[i].fir>>pot[i].sec;}\n\tbool can=true;\n\tfor(i=1;i<n-1;i++){\n\t\tdouble A=atan2(pot[i-1].fir-pot[i].fir,pot[i-1].sec-pot[i].sec);\n\t\tdouble B=atan2(pot[i+1].fir-pot[i].fir,pot[i+1].sec-pot[i].sec);\n\t\t//AとBの間がセーフ\n\t\tfor(j=0;j<i;j++){\n\t\t\tdouble C=atan2(pot[j].fir-pot[i].fir,pot[j].sec-pot[i].sec);\n\t\t\tif(in(B,R(A),C)){can=false;break;}\n\t\t\tif(in(A,B,C)){A=C;}\n\t\t\tif(in(A,B,R(C))){B=R(C);}\n\t\t}\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tdouble C=atan2(pot[j].fir-pot[i].fir,pot[j].sec-pot[i].sec);\n\t\t\tif(in(A,R(B),C)){can=false;break;}\n\t\t\tif(in(A,B,C)){B=C;}\n\t\t\tif(in(A,B,R(C))){A=R(C);}\n\t\t}\n\t}\n\tcout<<(can?\"P\":\"Imp\")<<\"ossible\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, int> ld_i;\n\nint main() {\n\tld PI = acosl(-1);\n\tint N; cin >> N;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> x[i] >> y[i];\n\tfor (int k = 0; k < N; k++) {\n\t\tvector<ld_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i == k) continue;\n\t\t\tld a = atan2l(x[i] - x[k], y[i] - y[k]);\n\t\t\tv.push_back(ld_i(a, i < k));\n\t\t}\n\t\tint n = v.size();\n\t\tsort(v.begin(), v.end());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv.push_back(v[i]);\n\t\t\tv.back().first += PI*2;\n\t\t}\n\t\tint a = 0, b = 0, j = 0;\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (; v[j].first < v[i].first + PI; j++)\n\t\t\t\tif (v[j].second) a++;\n\t\t\t\telse b++;\n\t\t\tif ((a == k && b == 0) || (a == 0 && b == N - 1 - k))\n\t\t\t\tok = true;\n\t\t\tif (v[i].second) a--;\n\t\t\telse b--;\n\t\t}\n\t\tif (!ok) {\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nbool lt(double a, double b){\n  return a < b - EPS;\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid print(const vector<complex<double>>& pts){\n  for(complex<double> p: pts){\n    cout << p.real() << \" \" << p.imag() << endl;\n  }\n  cout << \"===\";\n  cout << endl;\n}\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    //print(pts);\n\n    moveToO(i+1, pts);\n    //print(pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \n#define PI 3.1415926535897932384626433832795L\n \nusing namespace std;\n \nint N, X, Y;\n \nvector<long double> x;\nvector<long double> y;\n \nint main()\n{\n    scanf(\"%d\", &N);\n \n    for (int i = 0; i < N; i++)\n    {\n        scanf(\"%d\", &X);\n        scanf(\"%d\", &Y);\n \n        x.push_back(X);\n        y.push_back(Y);\n    }\n \n    bool ok = true;\n \n    for (int i = 0; i < N - 1; i++)\n    {\n        // Translation.\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                x[j] -= x[i];\n                y[j] -= y[i];\n            }\n        }\n \n        x[i] = 0;\n        y[i] = 0;\n \n        // Rotate.\n \n        long double ang = PI - atan2l(y[i + 1], x[i + 1]);\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                long double ang2 = atan2l(y[j], x[j]) + ang;\n                long double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n \n                x[j] = radi * cosl(ang2);\n                y[j] = radi * sinl(ang2);\n            }\n        }\n        \n        long double maxc = -999.0L, minc = 999.0;\n \n        for(int j = i + 1; j < n; j++)\n        {\n            long double ang2 = atan2l(y[j], x[j]);\n            \n            maxc = max(maxc, ang2);\n            minc = min(minc, ang2);\n        }\n        \n        long double ang = -atan2l(y[i + 1], x[i + 1]);\n \n        for (int j = 0; j < N; j++)\n        {\n            if (i != j)\n            {\n                long double ang2 = atan2l(y[j], x[j]) + ang;\n                long double radi = sqrtl(x[j] * x[j] + y[j] * y[j]);\n \n                x[j] = radi * cosl(ang2);\n                y[j] = radi * sinl(ang2);\n            }\n        }\n        \n        long double maxd = -999.0L, mind = 999.0;\n \n        for(int j = 0; j < i; j++)\n        {\n            long double ang2 = atan2l(y[j], x[j]);\n            \n            maxd = max(maxc, ang2);\n            mind = min(minc, ang2);\n        }\n        \n        mind += PI;\n        maxd += PI;\n        \n        if(maxc - minc > PI || maxd - mind > PI) ok = false;\n    }\n \n    printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst double EPS = 1e-8;\ntypedef complex<double> P;\ntypedef vector<P> VP;\ndouble cross(P a, P b){\n    return (conj(a)*b).imag();\n}\nint lccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    return 0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    VP v(n);\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        v[i] = P(x,y);\n    }\n\n    bool ans = true;\n    for(int r=0; r<2; r++){\n        for(int i=2; i<n-1; i++){\n            bool s1 = false;\n            for(int j=0; j<i; j++){\n                bool s2 = true;\n                int comp = lccw(v[i], v[j], v[i+1]);\n                for(int k=0; k<i; k++){\n                    if(k != j && comp == lccw(v[i], v[j], v[k])){\n                        s2 = false;\n                        break;\n                    }\n                }\n                if(s2){ s1 = true; break; }\n            }\n            if(!s1){ ans = false; break; }\n        }\n        reverse(v.begin(), v.end());\n    }\n    if(ans) cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { Point c = { a.px - b.px,a.py - b.py }; return c; }\nSegment rot90(Point p1, Point p2) {\n\tSegment g; Point P1, P2, P3 = Minus(p2, p1);\n\tlong double c = max(P3.px, P3.py);\n\tlong double S1 = 2e8l / c; P3.px *= c; P3.py *= c;\n\tP1.px = -P3.py; P1.py = P3.px;\n\tP2.px = P3.py; P2.py = -P3.px;\n\tP1.px += p1.px; P1.py += p1.py;\n\tP2.px += p1.px; P2.py += p2.py;\n\tg.p1 = P1; g.p2 = P2; return g;\n}\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) < 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) < 0);\n}\nbool its(const Segment& s1, const Segment& s2) { return its(s1.p1, s1.p2, s2.p1, s2.p2); }\nint main() {\n\tSegment a[1000]; Point b[1000]; int N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> b[i].px >> b[i].py;\n\t\tif (i < N - 1)a[i].p1 = b[i];\n\t\tif (i >= 1)a[i - 1].p2 = b[i];\n\t}\n\tint OK = 1;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tSegment L1 = rot90(a[i].p1, a[i].p2);\n\t\tSegment L2 = rot90(a[i].p2, a[i].p1);\n\t\tint OK2 = 1;\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i || j == i - 1)continue;\n\t\t\tif (its(a[j], L1) == true)OK2 = 0;\n\t\t}\n\t\tfor (int j = 0; j < N - 1; j++) {\n\t\t\tif (j == i || j == i + 1)continue;\n\t\t\tif (its(a[j], L2) == true)OK2 = 0;\n\t\t}\n\t\tif (OK2 == 0)OK = 0;\n\t}\n\tif (OK == 1)cout << \"Possible\" << endl;\n\telse cout << \"Impossible\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=1;i<n;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tconv = convex_hull(ps);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<C> ps2;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps2.push_back(z);\n\t\t}\n\t\tconv = convex_hull(ps2);\n\t\tif(contains(conv,z)==2){\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-6)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nPolygon p;\n\nbool check(){\n  if(n<=3)return true;\n  Polygon P;\n  FOR(i,0,n){\n    if(3<=i && contains(P,p[i]))return false;\n    P.pb(p[i]);\n    P=convex_hull(P);\n  }\n  return true;\n}\n\nbool solve(){\n  if(check())return true;\n//  reverse(all(p));\n//  if(check())return true;\n  return false;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  cout<<(solve() ? \"Possible\" : \"Impossible\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble f(double x, double y) {\n\tif (y < x) y += M_PI * 2;\n\treturn y - x;\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i];\n\tbool pos = true;\n\tfor (int i = 0; i < n; i++)\n\t\tif (i == 0 || i == n - 1) {\n\t\t\tbool ok = false;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tll dx = x[j] - x[i], dy = y[j] - y[i];\n\t\t\t\tbool a = false, b = false;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tif ((x[k] - x[i]) * dy - (y[k] - y[i]) * dx > 0)\n\t\t\t\t\t\ta = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tb = true;\n\t\t\t\t}\n\t\t\t\tif (!a || !b) ok = true;\n\t\t\t}\n\t\t\tif (!ok) pos = false;\n\t\t}\n\t\telse {\n\t\t\tvector<d_i> p;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tp.push_back(d_i(atan2(y[j] - y[i], x[j] - x[i]), j < i));\n\t\t\t}\n\t\t\tint m = p.size();\n\t\t\tsort(p.begin(), p.end());\n\t\t\tbool ok = false;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (p[j].second != p[(j + 1) % m].second || p[j].second != p[(j + m - 1) % m].second) {\n\t\t\t\t\tvector<bool> a(2), b(2);\n\t\t\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\t\t\tif (k == j) continue;\n\t\t\t\t\t\tif (f(p[j].first, p[k].first) < M_PI) a[p[k].second] = true;\n\t\t\t\t\t\telse b[p[k].second] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(a[0] && b[0]) && !(a[1] && b[1]) && !(a[0] && a[1]) && !(b[0] && b[1]))\n\t\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\tif (!ok) pos = false;\n\t\t}\n\t\tcout << (pos ? \"Possible\" : \"Impossible\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long double ld;\ntypedef pair<ld, int> ld_i;\n \nint main() {\n    ld PI = acosl(-1);\n    int N; cin >> N;\n    vector<int> x(N), y(N);\n    for (int i = 0; i < N; i++)\n        cin >> x[i] >> y[i];\n    for (int k = 0; k < N; k++) {\n        vector<ld_i> v;\n        for (int i = 0; i < N; i++) {\n            if (i == k) continue;\n            ld a = atan2l(x[i] - x[k], y[i] - y[k]);\n            v.push_back(ld_i(a, i < k));\n        }\n        int n = v.size();\n        sort(v.begin(), v.end());\n        for (int i = 0; i < n; i++) {\n            v.push_back(v[i]);\n            v.back().first += PI*2;\n        }\n        int a = 0, b = 0, j = 0;\n        bool ok = false;\n        for (int i = 0; i < n; i++) {\n            for (; v[j].first < v[i].first + PI; j++)\n                if (v[j].second) a++;\n                else b++;\n            if ((a == k && b == 0) || (a == 0 && b == N - 1 - k))\n                ok = true;\n            if (v[i].second) a--;\n            else b--;\n        }\n        if (!ok) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS=1e-10;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> p) {\n  int n=p.size(),k=0;\n  sort(p.begin(),p.end());\n  vector<P> q(2*n);\n  for(int i=0;i<n;q[k++]=p[i++])\n    while(k>=2&&ccw(q[k-2],q[k-1],p[i])<=0) --k;\n  for(int i=n-2,t=k+1;i>=0;q[k++]=p[i--])\n    while(k>=t&&ccw(q[k-2],q[k-1],p[i])<=0) --k;\n  q.resize(k-1);\n  return q;\n}\n\ndouble area(vector<P> p) {\n  double a=0;\n  for(int i=0; i<(int)p.size(); i++) a+=cross(p[i],p[(i+1)%p.size()]);\n  return fabs(a)/2;\n}\n\nvector<P> v;\nint n;\nbool ck(int k) {\n  vector<P> a;\n  double d[n];\n  for(int i=k; i<n; i++) {\n    a.push_back(v[i]);\n    d[i]=0;\n    if(a.size()<3) continue;\n    vector<P> b=convex_hull(a);\n    d[i]=area(b);\n    if(d[i]-d[i-1]<EPS) return 0;\n  }\n  return 1;\n}\n\nint main() {\n  cin >> n;\n  for(int i=0; i<n; i++) {\n    double x,y;\n    cin >> x >> y;\n    v.push_back(P(x,y));\n  }\n  for(int t=0; t<2; t++) {\n    for(int i=0; i<n; i++) {\n      if(!ck(i)) {\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n    reverse(v.begin(),v.end());\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI = acos(-1);\nint n;\nvector<P> t;\n\ndouble Arg(P a,P b){\n  return arg( b*conj(a) );\n}\n\nbool check(){\n  for(int i=0;i+1<n;i++){\n    double maxm=-10;\n    double mini=10;\n    for(int j=i+2;j<n;j++){\n      P base=t[i+1]-t[i];\n      P target=t[j]-t[i+1];\n      maxm=max(maxm,Arg(base,target));\n      mini=min(mini,Arg(base,target));\n    }\n    if( maxm-mini > PI )return true;\n  }\n  return false;\n}\n\nint main(){\n  cin>>n;\n  t.resize(n);\n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    t[i]=P(x,y);\n  }\n  if( check() ){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  reverse(t.begin(),t.end());\n  if( check() ){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nPolygon p;\n\nbool check(){\n  if(n<=3)return true;\n  Polygon P;\n  P.pb(p[0]);\n  P.pb(p[1]);\n  P.pb(p[2]);\n  FOR(i,3,n){\n    if(contains(P,p[i])!=0)return false;\n    P.pb(p[i]);\n    P=convex_hull(P);\n  }\n  return true;\n}\n\nbool solve(){\n  if(check())return true;\n  reverse(all(p));\n  if(check())return true;\n  return false;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  cout<<(solve() ? \"Possible\" : \"Impossible\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\n\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\nD calc_area(vector<P>& poly) {\n  D res = 0;\n  int sz=poly.size();\n  for (int i = 0; i < sz; i++){\n    res += cross(poly[i], poly[(i+1)%sz]);\n  }\n  return res/2.0;\n}\n\nbool judge(vector<P>& ps){\n  D crt=-1;\n  rep(i,ps.size())if(i>=2){\n    vector<P> a;\n    rep(j,i+1)a.push_back(ps[j]);\n    a=convex_hull(a);\n    D nxt=calc_area(a);\n    if(abs(crt-nxt)<eps)return false;\n    crt=nxt;\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  vector<P> ps;\n  cin>>n;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  bool ok=true;\n  if(!judge(ps))ok=false;\n  reverse(all(ps));\n  if(!judge(ps))ok=false;\n  if(ok)cout<<\"Possible\"<<endl;\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld,int> P;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define pb push_back\n#define fr first\n#define sc second\n\nconst ld PI = 3.14159265359;\nconst ld EPS = 0.0;\n\nbool f(vector<ld> vec){\n\tif(vec.size() == 0)return true;\n\tif(vec[vec.size()-1]-vec[0] < PI+EPS)return true;\n\tfor(int j = 0 ; j+1 < vec.size() ; j ++){\n\t\tif(vec[j+1]-vec[j] > PI-EPS)return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n;\n\tint x[1002],y[1002];\n\tscanf(\"%d\",&n);\n\trep1(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\t\n\trep1(i,n){\n\t\tvector<long double> v[2];\n\t\tvector<P> vec;\n\t\trep1(j,i-1){\n\t\t\tv[0].pb(atan2((ld)(y[j]-y[i]),(ld)(x[j]-x[i])));\n\t\t\tvec.pb(P(atan2((ld)(y[j]-y[i]),(ld)(x[j]-x[i])),j));\n\t\t}\n\t\tfor(int j = i+1 ; j <= n ; j ++){\n\t\t\tv[1].pb(atan2((ld)(y[j]-y[i]),(ld)(x[j]-x[i])));\n\t\t\tvec.pb(P(atan2((ld)(y[j]-y[i]),(ld)(x[j]-x[i])),j));\n\t\t}\n\t\t\n\t\tif(!f(v[0]) || !f(v[1])){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int j = 0 ; j+1 < vec.size() ; j ++){\n\t\t\tif((i-vec[j].sc)*(i-vec[j+1].sc)<0)cnt ++;\n\t\t}\n\t\tif(cnt >= 3){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(cnt == 2){\n\t\t\tint s = 0;\n\t\t\twhile((i-vec[s].sc)*(i-vec[s+1].sc)>0)s++;\n\t\t\tint t = s+1;\n\t\t\twhile((i-vec[t].sc)*(i-vec[t+1].sc)>0)t++;\n\t\t\tt ++;\n\t\t\tif(vec[s].fr+2*PI-vec[t].fr > PI+EPS || vec[t-1].fr-vec[s+1].fr > PI+EPS){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(cnt == 1){\n\t\t\tint s = 0;\n\t\t\twhile((i-vec[s].sc)*(i-vec[s+1].sc)>0)s++;\n\t\t\tif(vec[s].fr-vec[0].fr > PI+EPS || vec[vec.size()-1].fr-vec[s+1].fr > PI+EPS){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a)const{return sig(x-a.x)?sig(x-a.x)<0:sig(y-a.y)<0;}\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint convexHull(int n, Pt p[], Pt q[]) {\n\tint m = 0, i, r;\n\tsort(p, p + n);\n\tfor (i = 0; i < n; q[m++] = p[i++]) for (; m > 1 && sig(tri(q[m - 2], q[m - 1], p[i])) <= 0; --m);\n\tfor (i = n - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(tri(q[m - 2], q[m - 1], p[i])) <= 0; --m);\n\treturn m - 1;\n}\nint sGP(int n, Pt p[], Pt a) {\n\tint side = -1, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tPt p0 = p[i] - a, p1 = p[i + 1] - a;\n\t\tif (sig(p0.det(p1)) == 0 && sig(p0.dot(p1)) <= 0) return 0;\n\t\tif (p0.y > p1.y) swap(p0, p1);\n\t\tif (sig(p0.y) <= 0 && 0 < sig(p1.y) && sig(p0.det(p1)) > 0) side = -side;\n\t}\n\treturn side;\n}\ndouble x[1100];\ndouble y[1100];\nPt p[1100];\nPt tmp[1100];\nPt con[1100];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\tfor(int i=0;i<a;i++)p[i]=Pt(x[i],y[i]);\n\tbool ok=true;\n\tfor(int i=1;i<a-1;i++){\n\t\tfor(int j=0;j<=i;j++)tmp[j]=p[j];\n\t\tint m=convexHull(i+1,tmp,con);\n\t\tif(sGP(m,con,p[i+1])==1)ok=false;\n\t}\n\t//if(ok){printf(\"Possible\\n\");return 0;}\n\treverse(p,p+a);\n\t//ok=true;\n\tfor(int i=1;i<a-1;i++){\n\t\tfor(int j=0;j<=i;j++)tmp[j]=p[j];\n\t\tint m=convexHull(i+1,tmp,con);\n\t\tif(sGP(m,con,p[i+1])==1)ok=false;\n\t}\n\tif(ok){printf(\"Possible\\n\");return 0;}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\n\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<double>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=0;i<n;i++){\n\t\tvector<C> ps;\n\t\tvector<C> conv;\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps.push_back(z);\n\t\t}\n\t\tcomplex<double> z(x[i],y[i]);\n\t\tif(ps.size()>2){\n\t\t\tconv = convex_hull(ps);\n\t\t\tif(contains(conv,z)==2){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<C> ps2;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tcomplex<double> z(x[j],y[j]);\n\t\t\tps2.push_back(z);\n\t\t}\n\t\tif(ps2.size()>2){\n\t\t\tconv = convex_hull(ps2);\n\t\t\tif(contains(conv,z)==2){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nusing point = std::complex<ld>;\nusing polygon = std::vector<point>;\n\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = std::acos(-1.0);\n\nld dot(point const& a, point const& b) {\n    return std::real(std::conj(a) * b);\n}\nld cross(point const& a, point const& b) {\n    return std::imag(std::conj(a) * b);\n}\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps) return 1;            // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps) return -1;          // a -> b -> c : clockwise\n    if(dot(b, c) < 0) return 2;                // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\npolygon convex_hull(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps),\n              [](point const& p1, point const& p2) {\n                  return std::real(p1) < std::real(p2)\n                         || (std::real(p1) <= std::real(p2) && std::imag(p1) < std::imag(p2));\n              });\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2 * n);\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && ccw(qs[k - 2], qs[k - 1], ps[i]) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    for(int i = n - 2, t = k; i >= 0; --i) {\n        while(k > t && ccw(qs[k - 2], qs[k - 1], ps[i]) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    qs.resize(k - 1);\n    return qs;\n}\n\nld area(polygon const& poly) {\n    const int n = poly.size();\n    ld res = 0;\n    for(int i = 0; i < n; ++i) {\n        res += cross(poly[i], poly[(i + 1) % n]);\n    }\n    return res / 2;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<point> ps(n);\n    for(int i = 0; i < n; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        ps[i] = point(x, y);\n    }\n    auto check = [&](vector<point> const& ps) {\n        polygon poly = {ps[0], ps[1]};\n        bool res = false;\n        for(int i = 2; i < n; ++i) {\n            const ld s1 = area(convex_hull(poly));\n            poly.push_back(ps[i]);\n            const ld s2 = area(convex_hull(poly));\n            res |= fabs(s1 - s2) < eps;\n        }\n        return res;\n    };\n    bool ng = check(ps);\n    reverse(begin(ps), end(ps));\n    ng |= check(ps);\n\n    cout << (!ng ? \"Possible\" : \"Impossible\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> Pol;\nconst D eps=1e-9;\nbool eq(D a,D b){return abs(a-b)<eps;}\nint sig(D a){return eq(a,0)?0:(a>0?1:-1);}\nbool compxy(const P& l,const P& r){\n\treturn eq(l.real(),r.real()) ? l.imag()<r.imag() : l.real()<r.real();\n}\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(sig(cro(b-a,c-a))!=0) return sig(cro(b-a,c-a));\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(c-b),abs(a-c))) return -2;\n\tif(eq(abs(a-c)+abs(a-b),abs(c-b))) return 2;\n}\nPol conv(Pol p){\n\tint N=p.size(),k=0;\n\tsort(all(p),compxy);\n\tPol ret(2*N);\n\trep(i,N){\n\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p[i])<=0) --k;\n\t\tret[k++]=p[i];\n\t}\n\tfor(int i=N-2,t=k+1;i>=0;i--){\n\t\twhile(k>=t&&ccw(ret[k-2],ret[k-1],p[i])<=0) --k;\n\t\tret[k++]=p[i];\n\t}\n\tret.resize(k-1);\n\treturn ret;\n}\nint contain(Pol pol,P p){\n\tbool in=false;\n\trep(i,pol.size()){\n\t\tP a=pol[i]-p,b=pol[(i+1)%pol.size()]-p;\n\t\tif(ccw(a,b,P(0,0))==0) return 0;\n\t\tif(imag(a)>imag(b)) swap(a,b);\n\t\tif(sig(imag(a))<=0 && 0<sig(imag(b)) && ccw(P(0,0),a,b)==1) in=!in;\n\t}\n\treturn in?1:-1;\n}\nP p[1000];\nbool solve(){\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tdouble x,y;\n\t\tcin>>x>>y;\n\t\tp[i]=P(x,y);\n\t}\n\tfor(int i=3;i<N;i++){\n\t\tPol vs;\n\t\trep(j,i) vs.pb(p[j]);\n\t\tvs=conv(vs);\n\t\tif(contain(vs,p[i])==1) return false;\n\t}\n\treverse(p,p+N);\n\tfor(int i=3;i<N;i++){\n\t\tPol vs;\n\t\trep(j,i) vs.pb(p[j]);\n\t\tvs=conv(vs);\n\t\tif(contain(vs,p[i])==1) return false;\n\t}\n\treturn true;\n}\nint main(){\n\tif(solve()) puts(\"Possible\");\n\telse puts(\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\nll cross(ll x1,ll y1,ll x2,ll y2){\n\treturn x1*y2 - x2*y1;\n}\n\nbool is_over(ll x1,ll y1,ll x2,ll y2,ll a,ll b){\n\tif(cross(x2-x1,y2-y1,a-x1,b-y1)>0){\n\t\treturn 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\nbool is_cross(ll ax,ll ay,ll bx,ll by,ll cx,ll cy,ll dx,ll dy){\n\tll ta = (cx-dx) * (ay-cy) + (cy-dy) * (cx-ax);\n\tll tb = (cx-dx) * (by-cy) + (cy-dy) * (cx-bx);\n\tll tc = (ax-bx) * (cy-ay) + (ay-by) * (ax-cx);\n\tll td = (ax-bx) * (dy-ay) + (ay-by) * (ax-dx);\n\tif(ta>0)ta=1;\n\telse ta = -1;\n\tif(tb>0)tb=1;\n\telse tb = -1;\n\tif(tc>0)tc=1;\n\telse tc = -1;\n\tif(td>0)td=1;\n\telse td = -1;\n\treturn tc*td < 0 && ta*tb <0;\n}\n\nbool p[2000];\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<ll>x(n),y(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tbool flag = 0;\n\tfor(int i=0;i<n-1;i++){\n\t\tvector<int>v,w;\n\t\tfor(int j=i+2;j<n;j++){\n\t\t\tif(is_over(x[i],y[i],x[i+1],y[i+1],x[j],y[j])){\n\t\t\t\tv.PB(j);\n\t\t\t}else{\n\t\t\t\tw.PB(j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<v.size();j++){\n\t\t\tfor(int k=0;k<w.size();k++){\n\t\t\t\tif(is_cross(x[i],y[i],x[i+1],y[i+1],x[v[j]],y[v[j]],x[w[k]],y[w[k]])){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag)break;\n\t\tbool q=0,r=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tfor(int k=i+1;k<n;k++){\n\t\t\t\tif(is_over(x[i+1],y[i+1],x[k],y[k],x[j],y[j])){\n\t\t\t\t\tq=1;\n\t\t\t\t}else{\n\t\t\t\t\tr=1;\n\t\t\t\t}\n\t\t\t\tif(q&&r){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag)break;\n\t}\n\tif(flag){\n\t\tcout << \"Impossible\" << endl;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 500;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nusing speP = pair<ld, int>;\n\nstruct edge {\n\tint to; ld cost;\n};\nld dist(P a, P b) {\n\tld dx = b.first - a.first;\n\tld dy = b.second - a.second;\n\treturn sqrt(pow(dx, 2) + pow(dy, 2));\n}\n\nbool ison(P a, P l, P r) {\n\tld cl = dist(a, l);\n\tld cr = dist(a, r);\n\tld cm = dist(l, r);\n\treturn abs(cl + cr - cm) < eps;\n}\n\nint ban(P a, P b, P l, P r) {\n\tif (!ison(l, a, b))swap(l, r);\n\tint dx1 = b.first - a.first;\n\tint dy1 = b.second - a.second;\n\tint dx2 = r.first - l.first;\n\tint dy2 = r.second - l.second;\n\tint z = dx1 * dx2 + dy1 * dy2;\n\tif (z == 0)return 3;\n\tif (z > 0)return 1;\n\tif (z < 0)return 2;\n}\nint n;\nld x[1000], y[1000];\nld tx[1000], ty[1000];\nld td[1000];\n\nld cr[1000];\nvoid solve() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, n - 1) {\n\t\ttx[i] = abs(x[i + 1] - x[i]);\n\t\tty[i] = abs(y[i + 1] - y[i]);\n\t\ttd[i] = sqrt(pow(tx[i], 2) + pow(ty[i], 2));\n\t}\n\trep1(i, n - 2) {\n\t\tld dx1 = x[i] - x[i - 1];\n\t\tld dy1 = y[i] - y[i - 1];\n\t\tld dx2 = x[i + 1] - x[i];\n\t\tld dy2 = y[i + 1] - y[i];\n\t\tld u = dx1 * dy2 - dy1 * dx2;\n\t\tld dif = dx1 * dx2 + dy1 * dy2;\n\t\tld r1 = sqrt(pow(dx1, 2) + pow(dy1, 2));\n\t\tld r2 = sqrt(pow(dx2, 2) + pow(dy2, 2));\n\t\tdif = acos(dif / (r1*r2));\n\t\tif (u > 0) {\n\t\t\tcr[i] = dif;\n\t\t}\n\t\telse {\n\t\t\tcr[i] = -dif;\n\t\t}\n\t}\n\tbool ans = true;\n\trep(i, n - 1) {\n\t\tld le = 0, ri = 0;\n\t\tld cx = td[i], cy = 0;\n\t\tld r = 0;\n\t\tbool f = true;\n\t\tld z = 0;\n\t\tfor (int j = i + 1; j < n - 1; j++) {\n\t\t\tr += cr[j];\n\t\t\tld nx = cx + td[j] * cos(r);\n\t\t\tld ny = cy + td[j] * sin(r);\n\n\t\t\tld u = cx * ny - cy * nx;\n\t\t\tld dif = cx * nx + cy * ny;\n\t\t\tld r1 = sqrt(pow(cx, 2) + pow(cy, 2));\n\t\t\tld r2 = sqrt(pow(nx, 2) + pow(ny, 2));\n\t\t\tdif = acos(dif / (r1*r2));\n\t\t\tif (u < 0) {\n\t\t\t\tz -= dif;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tz += dif;\n\t\t\t}\n\t\t\tle = min(le, z);\n\t\t\tri = max(ri, z);\n\n\t\t\tcx = nx, cy = ny;\n\t\t}\n\t\tif (ri - le >= pi) {\n\t\t\t//cout << \"ar\" << le<<\" \"<<ri<<endl;\n\t\t\tans = false; break;\n\t\t}\n\t\tif (i == 0)continue;\n\t\tld ss = 0;\n\t\tss = -cr[i];\n\t\t//cout << cr[i] << \" \" << ss << endl;\n\t\tz = ss; r = ss;\n\t\tcx = td[i - 1] * cos(r), cy = td[i - 1]*sin(r);\n\t\t//if (i == 2)cout << \"!!! \" << atan2(cy, cx) << \" \" << z << endl;\n\t\tld le2 = ss, ri2 = ss;\n\t\tfor (int j = i - 2; j >= 0; j--) {\n\t\t\tr -= cr[j+1];\n\t\t\tld nx = cx + td[j] * cos(r);\n\t\t\tld ny = cy + td[j] * sin(r);\n\n\t\t\tld u = cx * ny - cy * nx;\n\t\t\tld dif = cx * nx + cy * ny;\n\t\t\tld r1 = sqrt(pow(cx, 2) + pow(cy, 2));\n\t\t\tld r2 = sqrt(pow(nx, 2) + pow(ny, 2));\n\t\t\tdif = acos(dif / (r1*r2));\n\t\t\t//if (i == 2)cout << \"!! \" << atan2(cy,cx)<<\" \"<<z << endl;\n\t\t\tif (u < 0) {\n\t\t\t\tz -= dif;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tz += dif;\n\t\t\t}\n\t\t\tle2 = min(le2, z);\n\t\t\tri2 = max(ri2, z);\n\n\t\t\tcx = nx, cy = ny;\n\t\t}\n\t\tif (ri2 - le2 >= pi) {\n\t\t\t//cout << \"ar\" << endl;\n\t\t\tans = false; break;\n\t\t}\n\t\tle2 -= pi; ri2 -= pi;\n\t\twhile (le2 <0)le2 += 2 * pi;\n\t\twhile (ri2 < 0)ri2 += 2 * pi;\n\t\twhile (le2 >= 2 * pi)le2 -= 2 * pi;\n\t\twhile (ri2 >= 2 * pi)ri2 -= 2 * pi;\n\t\tvector<speP> v;\n\t\tv.push_back({ le,0 });\n\t\tv.push_back({ ri,1 });\n\t\tv.push_back({ le2,2 });\n\t\tv.push_back({ ri2,3 });\n\t\tsort(all(v));\n\t\tvector<int> ids;\n\t\trep(j, 4)ids.push_back(v[j].second);\n\t\tif (ids == vec{0, 1, 2, 3} || ids == vec{1, 2, 3, 0}) {\n\t\t\t//\n\t\t}\n\t\telse {\n\t\t\t//cout << \"?? \" << i << \" \" << le << \" \" << ri << \" \" << le2 << \" \" << ri2 << endl;\n\t\t\tans = false; break;\n\t\t}\n\t}\n\tif (ans) {\n\t\tcout << \"Possible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\t//rep(i, 4)cout << cr[i] << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\t//init_f(); init();\n\t//int t; cin >> t; rep(i, t)solve();\n\t//while (cin >> n, n)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\n\ndouble dot(P a, P b){ return a.X * b.X + a.Y * b.Y;}\n\ndouble cross(P a, P b){ return a.X * b.Y - a.Y * b.X;}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> V;\n  double x, y;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y;\n    V.emplace_back(x,y);\n  }\n  for(int i = 1; i < N; ++i){\n    P d = V[i] - V[i-1];\n    double l = 0, r = 0;\n    for(int j = i+1; j < N; ++j){\n      //if(i == j || j == i-1) continue;\n      P v = V[j] - V[i];\n      if(cross(d,V[j]-V[i]) > 0){\n        l = max(l,acos(dot(d,v)/abs(d)/abs(v)));\n      }else{\n        r = max(r,acos(dot(d,v)/abs(d)/abs(v)));\n      }\n    }\n    if(r + l > acos(-1)){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n    for(int j = 0; j < i; ++j){\n      P v = V[j] - V[i];\n      if(cross(d,V[j]-V[i]) > 0){\n        if(l > acos(dot(d,v)/abs(d)/abs(v))){\n          cout << \"Impossible\" << endl;\n          return 0;\n        }\n      }else{\n        if(r > acos(dot(d,v)/abs(d)/abs(v))){\n          cout << \"Impossible\" << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = complex<ld>;\nusing L = pair<V, V>;\nconstexpr ld PI = static_cast<ld>(3.1415926535898);\nconstexpr ld EPS = static_cast<ld>(1e-12);\n\n// 点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n// inline bool operator<(const C a, const C b){\n//     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n// }\n\nnamespace std\n{\ninline bool equal(const ld a, const ld b)\n{\n    return (-EPS < a - b and a - b < EPS);\n}\n\ninline bool operator<(const V& a, const V& b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\ninline bool operator==(const V& c1, const V& c2)\n{\n    return (equal(c1.real(), c2.real()) and equal(c1.imag(), c2.imag()));\n}\n\ninline bool operator!=(const V& a, const V& b)\n{\n    return !(a == b);\n}\n}\n\ninline ld Sqrt(const ld x)\n{\n    return (x < 0 ? 0 : sqrt(x));\n}\n\ninline V normalize(const V& c)\n{\n    return c / abs(c);\n}\n\ninline ld arg(const V& a, const V& b)\n{\n    return arg(b * conj(a));\n}\n\ninline ld cross(const V& a, const V& b)\n{\n    return imag(conj(a) * b);\n}\n\ninline ld dot(const V& a, const V& b)\n{\n    return real(conj(a) * b);\n}\n\ninline int ccw(const V& a, const V& b, const V& c)\n{\n    if (cross(b - a, c - a) > 0) {\n        return +1;  // counter clockwise\n    }\n    if (cross(b - a, c - a) < 0) {\n        return -1;  // clockwise\n    }\n    if (dot(b - a, c - a) < 0) {\n        return +2;  // c--a--b on line\n    }\n    if (norm(b - a) < norm(c - a)) {\n        return -2;  // a--b--c on line\n    }\n    return 0;  //b--a--c on line\n}\n\ninline bool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l.second - l.first, m.second - m.first)) > EPS or abs(cross(l.second - l.first, m.first - l.first)) < EPS;\n}\n\ninline bool intersectLS(const L& l, const L& s)\n{\n    return cross(l.second - l.first, s.first - l.first) * cross(l.second - l.first, s.second - l.first) < EPS;\n}\n\ninline bool intersectLP(const L& l, const V& p)\n{\n    return abs(cross(l.second - p, l.first - p)) < EPS;\n}\n\ninline bool intersectSS(const L& s, const L& t)\n{\n    return ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 and ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\ninline bool intersectSP(const L& s, const V& p)\n{\n    return abs(s.first - p) + abs(s.second - p) - abs(s.second - s.first) < EPS;\n}\n\ninline V crosspointLL(const L& l, const L& m)\n{\n    const ld A = cross(l.second - l.first, m.second - m.first);\n    const ld B = cross(l.second - l.first, l.second - m.first);\n    //同一直線のとき\n    if (abs(A) < EPS and abs(B) < EPS) {\n        return m.first;\n    }\n    return m.first + (B / A) * (m.second - m.first);\n}\n\n//点pを直線l上に射影\ninline V projection(const L& l, const V& p)\n{\n    const ld t = dot(p - l.first, l.first - l.second) / norm(l.first - l.second);\n    return l.first + t * (l.first - l.second);\n}\n\n//crosspointCLに使用する関数(命名が謎です)\ninline ld gettime(const V& c1, const V& c2)\n{\n    return (dot(c1, c2) < 0 ? -1.0 : 1.0) * abs(c2) / abs(c1);\n}\n\n//円と直線の交点\ninline vector<V> crosspointCL(const V& c1, const ld r1, const L& l)\n{\n    const V a = l.first;\n    const V b = l.second;\n    vector<V> res;\n    const V target = projection(L(a, b), c1);\n    const V base = normalize(b - a);\n    const ld h = abs(c1 - target);\n    if (r1 + EPS < h) {\n        return res;\n    }\n    const ld w = Sqrt(r1 * r1 - h * h);\n    const ld LL = gettime(normalize(b - a), target - a) - w;\n    const ld RR = LL + w * 2.0;\n    res.push_back(a + base * LL);\n    if (equal(LL, RR)) {\n        return res;\n    }\n    res.push_back(a + base * RR);\n    return res;\n}\n\n//円と線分の交点\ninline vector<V> crosspointCS(const V& c1, const ld r1, const L& s)\n{\n    vector<V> tmp = crosspointCL(c1, r1, s);\n    vector<V> res;\n    for (int i = 0; i < tmp.size(); i++) {\n        if (abs(s.second - s.first) == abs(s.first - tmp[i]) + abs(s.second - tmp[i])) {\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n\n//円どうしの交点\ninline L crosspointCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    const V a = conj(c2 - c1);\n    const V b = (r2 * r2 - r1 * r1 - (c2 - c1) * conj(c2 - c1));\n    const V c = r1 * r1 * (c2 - c1);\n    const V d = b * b - (ld)4.0 * a * c;\n    const V z1 = (-b + sqrt(d)) / ((ld)2.0 * a) + c1;\n    const V z2 = (-b - sqrt(d)) / ((ld)2.0 * a) + c1;\n    return L(z1, z2);\n}\n\n//点pを直線lを軸として対称移動\ninline V reflection(const L& l, const V& p)\n{\n    return p + (projection(l, p) - p) * (ld)2.0;\n}\n\n//点と直線の距離\ninline ld distanceLP(const L& l, const V& p)\n{\n    return abs(p - projection(l, p));\n}\n\n//直線と直線の距離\ninline ld distanceLL(const L& l, const L& m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\n\n//直線と線分の距離\ninline ld distanceLS(const L& l, const L& s)\n{\n    if (intersectLS(l, s)) {\n        return 0;\n    }\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\n//線分と点の距離\ninline ld distanceSP(const L& s, const V& p)\n{\n    const V r = projection(s, p);\n    if (intersectSP(s, r)) {\n        return abs(r - p);\n    }\n    return min(abs(s.first - p), abs(s.second - p));\n}\n\n//線分と線分の距離\ninline ld distanceSS(const L& s, const L& t)\n{\n    if (intersectSS(s, t)) {\n        return 0;\n    }\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\ninline ld getarea(const V& c1, const ld r1, const V& a, const V& b)\n{\n    const V va = c1 - a;\n    const V vb = c1 - b;\n    const ld A = abs(va);\n    const ld B = abs(vb);\n    const ld f = cross(va, vb);\n    const ld d = distanceSP(L(a, b), c1);\n    ld res = 0;\n    if (equal(f, (ld)0.0)) {\n        return 0;\n    }\n    if (A < r1 + EPS and B < r1 + EPS) {\n        return f * (ld)0.5;\n    }\n    if (d > r1 - EPS) {\n        return r1 * r1 * M_PI * arg(va, vb) / ((ld)2.0 * M_PI);\n    }\n    vector<V> u = crosspointCS(c1, r1, L(a, b));\n    u.insert(u.begin(), a);\n    u.push_back(b);\n    for (int i = 0; i + 1 < (int)u.size(); i++) {\n        res += getarea(c1, r1, u[i], u[i + 1]);\n    }\n    return res;\n}\n\n//円と多角形の共通部分の面積\ninline ld getcrossarea(const vector<V>& t, const V& c1, const ld r1)\n{\n    const int n = t.size();\n    if (n < 3) {\n        return 0;\n    }\n    ld res = 0;\n    for (int i = 0; i < n; i++) {\n        const V a = t[i];\n        const V b = t[(i + 1) % n];\n        res += getarea(c1, r1, a, b);\n    }\n    return res;\n}\n\n//凸包を求める(O(nlogn))\ninline vector<V> convex_hull(vector<V> ps)\n{\n    const int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    vector<V> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) {\n        while (k >= 2 and ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {\n        while (k >= t and ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\n//凸性判定\ninline bool isconvex(const vector<V>& ps)\n{\n    for (int i = 0; i < ps.size(); i++) {\n        if (ccw(ps[(i + ps.size() - 1) % ps.size()], ps[i], ps[(i + 1) % ps.size()])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//多角形の符号付き面積(左回りが正)\ninline ld area(const vector<V>& ps)\n{\n    ld A = 0;\n    for (int i = 0; i < ps.size(); i++) {\n        A += cross(ps[i], ps[(i + 1) % ps.size()]);\n    }\n    return A / (ld)2.0;\n}\n\n//凸多角形を直線で切断した時の左側の図形\nvector<V> convex_cut(const vector<V>& ps, const L& l)\n{\n    vector<V> Q;\n    for (int i = 0; i < ps.size(); i++) {\n        const V A = ps[i];\n        const V B = ps[(i + 1) % ps.size()];\n        if (ccw(l.first, l.second, A) != -1) {\n            Q.push_back(A);\n        }\n        if (ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) {\n            Q.push_back(crosspointLL(L(A, B), l));\n        }\n    }\n    return Q;\n}\n\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<V>& ps, const V& p)\n{\n    bool flag = false;\n    for (int i = 0; i < ps.size(); i++) {\n        V a = ps[i] - p;\n        V b = ps[(i + 1) % ps.size()] - p;\n        if (imag(a) > imag(b)) {\n            swap(a, b);\n        }\n        if (imag(a) <= 0 and 0 < imag(b)) {\n            if (cross(a, b) < 0) {\n                flag = not flag;\n            }\n        }\n        if (cross(a, b) == 0 and dot(a, b) <= 0)\n            return 1;\n    }\n    return flag ? 2 : 0;\n}\n\n//凸多角形の交差\nvector<V> convex_intersection(const vector<V>& ps, const vector<V>& qs)\n{\n    vector<V> rs;\n    const int a = ps.size();\n    const int b = qs.size();\n    for (int i = 0; i < a; i++) {\n        if (contains(qs, ps[i])) {\n            rs.push_back(ps[i]);\n        }\n    }\n    for (int i = 0; i < b; i++) {\n        if (contains(ps, qs[i])) {\n            rs.push_back(qs[i]);\n        }\n    }\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            const L l1(ps[i], ps[(i + 1) % a]);\n            const L l2(qs[j], qs[(j + 1) % b]);\n            if (intersectSS(l1, l2)) {\n                rs.push_back(crosspointLL(l1, l2));\n            }\n        }\n    }\n    sort(rs.begin(), rs.end());\n    rs.erase(unique(rs.begin(), rs.end()), rs.end());\n    if (rs.size() <= 1) {\n        return rs;\n    }\n    return convex_hull(rs);\n}\n\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ninline ld convex_diameter(const vector<V>& ps)\n{\n    const int n = ps.size();\n    int is = 0;\n    int js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) {\n            is = i;\n        }\n        if (imag(ps[i]) < imag(ps[js])) {\n            js = i;\n        }\n    }\n    ld maxd = abs(ps[is] - ps[js]);\n    int i;\n    int maxi;\n    int j;\n    int maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(ps[(i + 1) % ps.size()] - ps[i], ps[(j + 1) % ps.size()] - ps[j]) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        if (abs(ps[i] - ps[j]) > maxd) {\n            maxd = abs(ps[i] - ps[j]);\n            maxi = i;\n            maxj = j;\n        }\n    } while (i != is or j != js);\n    return maxd;\n}\n\ninline bool compyx(const V& c1, const V& c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ninline ld closest_pair(const vector<V>::iterator a, const int n)\n{\n    if (n <= 1) {\n        return 1e100;\n    }\n    int m = n / 2;\n    ld x = a[m].real();\n    ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n    inplace_merge(a, a + m, a + n, compyx);\n    vector<V> b;\n    for (int i = 0; i < n; i++) {\n        if (abs(x - a[i].real()) >= d) {\n            continue;\n        }\n        for (int j = 0; j < b.size(); j++) {\n            V dp = a[i] - b[b.size() - 1 - j];\n            if (dp.imag() >= d) {\n                break;\n            }\n            d = min(d, abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n//最近点対を求める\ninline ld compute_shortest(const vector<V>::iterator a, const int n)\n{\n    sort(a, a + n);\n    return closest_pair(a, n);\n}\n\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\ninline int getstateCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    ld d = abs(c1 - c2);\n    if (d > r1 + r2 + EPS) {\n        return 4;\n    }\n    if (d > r1 + r2 - EPS) {\n        return 3;\n    }\n    if (d > abs(r1 - r2) + EPS) {\n        return 2;\n    }\n    if (d > abs(r1 - r2) - EPS) {\n        return 1;\n    }\n    return 0;\n}\n\n//点から円へ接線を引いた時の接点\ninline V gettangentCP_(const V& c1, const ld r1, const V& p, const int flg)\n{\n    const V base = c1 - p;\n    const ld w = Sqrt(norm(base) - r1 * r1);\n    const V s = p + base * V(w, r1 * flg) / norm(base) * w;\n    return s;\n}\n\n//点から円への接線\ninline vector<L> gettangentCP(const V& c1, const ld r1, const V& p)\n{\n    vector<L> res;\n    const V s = gettangentCP_(c1, r1, p, 1);\n    const V t = gettangentCP_(c1, r1, p, -1);\n    //点が円の周上にある場合\n    if (s == t) {\n        res.push_back(L(s, s + (c1 - p) * V(0, 1)));\n    } else {\n        res.push_back(L(p, s));\n        res.push_back(L(p, t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\ninline L getintangent(const V& c1, const ld r1, const V& c2, const ld r2, const ld flg)\n{\n    const V base = c2 - c1;\n    const ld w = r1 + r2;\n    const ld h = Sqrt(norm(base) - w * w);\n    const V k = base * V(w, h * flg) / norm(base);\n    return L(c1 + k * r1, c2 - k * r2);\n}\n\n//2円の共通外接線を求める\ninline L getouttangent(const V& c1, const ld r1, const V& c2, const ld r2, const ld flg)\n{\n    const V base = c2 - c1;\n    const ld h = r2 - r1;\n    const ld w = Sqrt(norm(base) - h * h);\n    const V k = base * V(w, h * flg) / norm(base) * V(0, flg);\n    return L(c1 + k * r1, c2 + k * r2);\n}\n\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\ninline vector<L> gettangentCC(const V& c1, const ld r1, const V& c2, const ld r2)\n{\n    vector<L> res;\n    const ld d = abs(c1 - c2);\n    if (d > r1 + r2 + EPS) {\n        res.push_back(getintangent(c1, r1, c2, r2, 1));\n    }\n    if (d > r1 + r2 - EPS) {\n        res.push_back(getintangent(c1, r1, c2, r2, -1));\n    }\n    if (d > abs(r1 - r2) + EPS) {\n        res.push_back(getouttangent(c1, r1, c2, r2, 1));\n    }\n    if (d > abs(r1 - r2) - EPS) {\n        res.push_back(getouttangent(c1, r1, c2, r2, -1));\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<V> v(N);\n    vector<V> rev(N);\n    vector<vector<V>> cv(N);\n    vector<vector<V>> revcv(N);\n    for (int i = 0; i < N; i++) {\n        ld x, y;\n        cin >> x >> y;\n        v[i] = {x, y};\n        rev[N - 1 - i] = {x, y};\n    }\n    for (int i = 0; i < N; i++) {\n        cv[i] = convex_hull(vector<V>(v.begin(), v.begin() + i + 1));\n        revcv[i] = convex_hull(vector<V>(rev.begin(), rev.begin() + i + 1));\n    }\n    if (contains(cv[N - 2], v[N - 1]) == 2) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n    if (contains(revcv[N - 2], v[0]) == 2) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    for (int i = 1; i < N - 1; i++) {\n        if (contains(cv[i - 1], v[i]) == 2 or contains(revcv[N - 2], v[i]) == 2) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> pt;\n#define pb push_back\n#define mp make_pair\npt P[1005];\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble x,y; scanf(\"%lf%lf\",&x,&y);\n\t\tP[i] = pt(x,y) * polar(1.0,1e-5);\n\t}\n\tif(n<=3){\n\t\tputs(\"Possible\"); return 0;\n\t}\n\tvector<pair<double,int> >vec;\n\tfor(int i=2;i<=n;i++){\n\t\tvec.pb(mp(arg(P[i]-P[1]),i));\n\t}\n\tsort(vec.begin(),vec.end());\n\t//for(int i=0;i<vec.size();i++) cout << vec[i].first << endl;\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].first-vec[i-1].first > 3.141592653589793-1e-10){\n\t\t\tgoto ok;\n\t\t}\n\t}\n\tif(vec[vec.size()-1].first-vec[0].first < 3.141592653589793+1e-10){\n\t\tgoto ok;\n\t}\n\tputs(\"Impossible\"); return 0; ok:;\n\tvec.clear();\n\tfor(int i=1;i<n;i++){\n\t\tvec.pb(mp(arg(P[i]-P[n]),i));\n\t}\n\tsort(vec.begin(),vec.end());\n\t//for(int i=0;i<vec.size();i++) cout << vec[i].first << endl;\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].first-vec[i-1].first > 3.141592653589793-1e-10){\n\t\t\tgoto ok2;\n\t\t}\n\t}\n\tif(vec[vec.size()-1].first-vec[0].first < 3.141592653589793+1e-10){\n\t\tgoto ok2;\n\t}\n\tputs(\"Impossible\"); return 0; ok2:; //puts(\"OK\");\n\tfor(int i=2;i<n;i++){\n\t\tvec.clear();\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tvec.pb(mp(arg(P[j]-P[i]),j));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\t//for(int j=0;j<vec.size();j++) cout << vec[j].first << \" \" << vec[j].second << \" \"; cout << endl;\n\t\tfor(int j=1;j<vec.size();j++){\n\t\t\tif( ((vec[j].second<i) ^ (vec[j-1].second<i)) == 1){\n\t\t\t\tbool p = (vec[j].second<i); int cnt = 1;\n\t\t\t\tfor(int k=(j+1)%vec.size();k!=j;k=(k+1)%vec.size()){\n\t\t\t\t\tif( (vec[k].second<i) != p){\n\t\t\t\t\t\tif( (p==1&&cnt==i-1) || (p==0&&cnt==n-i) ){\n\t\t\t\t\t\t    //cout << j << \" \" << k << endl;\n\t\t\t\t\t\t\t//j..(k+vec.size()-1)%vec.size()\n\t\t\t\t\t\t\tdouble A = vec[(k+vec.size()-1)%vec.size()].first-vec[j].first; if(A<0) A+=2*3.1415926535897932;\n\t\t\t\t\t\t\t//k%vec.size()...(j+vec.size()-1)%vec.size()\n\t\t\t\t\t\t\tdouble B = vec[j-1].first-vec[k].first; if(B<0) B+=2*3.1415926535897932;\n\t\t\t\t\t\t\t//cout << A << \" \" << B << endl;\n\t\t\t\t\t\t\t//cout << vec[(k+vec.size()-1)%vec.size()].first << \" \" << vec[j].first << endl;\n\t\t\t\t\t\t\tif(A > 3.141592653589793+1e-10 || B > 3.141592653589793+1e-10){\n\t\t\t\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto nxt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnxt:;\n\t}\n\tputs(\"Possible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-7;\n\nbool lt(double a, double b){\n  return a < b - EPS;\n}\nbool mdeq(double a, double b){\n  return abs(a - b) < EPS;\n}\n\ndouble angle(complex<double> a, complex<double> b){\n  double dot = a.real() * b.real() + a.imag() * b.imag();\n  return dot / (double)(abs(a)*abs(b));\n}\n\nvoid moveToO(int target, vector<complex<double>>& pts){\n  complex<double> amount = pts[target];\n  for(complex<double>& p: pts){\n    p = p - amount;\n  }\n}\n\nvoid rotate(int target, vector<complex<double>>& pts){\n  double amount;\n  {\n    //complex<double> right(1.0, 0.0);\n    assert(mdeq(0, pts.at(target).real()));\n    assert(mdeq(0, pts.at(target).imag()));\n\n    complex<double> b(pts.at(target+1) - pts.at(target));\n    amount = M_PI/2.0 - atan2(b.imag(), b.real());\n  }\n  \n  for(complex<double>& p: pts){\n    p = complex<double>(p.real()*cos(amount) - p.imag()*sin(amount),\n\t\t\tp.real()*sin(amount) + p.imag()*cos(amount));\n  }\n}\n\nbool check(int target, vector<complex<double>>& pts){\n  \n  for(int i = 0; i < target; i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() <= 0)){\n    if(lt(0.0, p.imag())){\n      return false;\n    }\n  }\n\n  for(size_t i = target + 1; i < pts.size(); i++){\n    complex<double> p = pts[i];\n    //if(!(p.imag() >= 0)){\n    if(lt(p.imag(), 0.0)){\n      //      cout << 0.0 << \" \" << p.imag() << \"JJJ\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\n\nint main(void){\n  int n; cin >> n;\n  vector<complex<double>> pts(n);\n  for(int i = 0; i < n; i++){\n    int x, y; cin >> x >> y;\n    //pts[i].real(x);\n    //pts[i].imag(y);\n    pts[i] = complex<double>(x, y);\n  }\n  \n  moveToO(0, pts);\n\n\n  for(int i = 0; i < n-1; i++){\n    rotate(i, pts);\n    if(check(i, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n\n    moveToO(i+1, pts);\n    if(check(i+1, pts) == false){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon ps(n);\n  for(int i=0;i<n;i++) cin>>ps[i];\n  auto NO=[](){cout<<\"Impossible\"<<endl;exit(0);};\n  for(int uku=0;uku<2;uku++){\n    Polygon qs;\n    qs.push_back(ps[0]);\n    qs.push_back(ps[1]);\n    double res=0;\n    for(int i=2;i<n;i++){\n      qs.push_back(ps[i]);\n      qs=andrewScan(qs);\n      double tmp=area(qs);\n      if(tmp<=exchange(res,tmp)+EPS) NO();\n    }\n    reverse(ps.begin(),ps.end());\n  }  \n  cout<<\"Possible\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2635 Snake\n// 2018.3.19 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// [library]\n\n//#define getchar_unlocked()  getchar()\nint in()\t// get non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int x, y; } PP;\n\n#define INF\t\t 1e8\n#define EPS\t\t 1e-8\n#define EQ(a,b)  (fabs((a)-(b))<EPS)\n\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble cross(PP a, PP b) { return (double)a.x * b.y - (double)a.y * b.x; }\n\ndouble polygon_area(int n, PP *p)\n{\n   int i;\n   double s;\n\n   if (n < 3) return 0;\n   s = 0; p[n] = p[0];\n   for (i = 0; i < n; i++) s += cross(p[i], p[i+1]);\n   return fabs(s)/2;\n}\n\nint cmp(PP *a, PP *b) {\n\tif (a->y - b->y) return a->y - b->y;\n\treturn a->x - b->x;\n}\n\nint convex_hull(int n, PP *ps, PP *po)\n{\n\tint i, k, j = 0;\n\n\tqsort(ps, n, sizeof(PP), cmp);\n\tfor (i = 0; i < n; i++) {\n\t\twhile (j > 1 && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\tk = j;\n\tfor (i = n - 2; i >= 0; i--) {\n\t\twhile (j > k && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\treturn j-1;\n}\n// [\\library]  \n\nPP  snake[1002];\nPP  pp[2][1002];\n\nvoid reverse(int n, PP *p)\n{\n\tint i, j;\n\tmemcpy(pp[0], p, sizeof(PP)*n);\n\tj = n, i = 0; while (j--) p[i++] = pp[0][j];\n}\n\nint check(int n, PP *p)\n{\n\tint i, k, k1, k2;\n\tdouble prev, s;\n\n\tprev = 0, k = 0, k1 = 0, k2 = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tpp[k1][k++] = p[i];\n\t\tif (i < 2) continue;\n\t\tk = convex_hull(k, pp[k1], pp[k2]);\n\t\ts = polygon_area(k, pp[k2]);\n\t\tif (EQ(s, prev)) return 0;\n\t\tprev = s, k1 = k2, k2 = !k2;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint n, i, ans;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) snake[i].x = in(), snake[i].y = in();\n\tans = 0;\n\tif (check(n, snake)) {\n\t\treverse(n, snake);\n\t\tif (check(n, snake)) ans = 1;\n\t}\n\tputs(ans? \"Possible\": \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2635 Snake\n// 2018.3.19 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// [library]\n\n//#define getchar_unlocked()  getchar()\nint in()\t// get non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int x, y; } PP;\n\n#define INF\t\t 1e8\n#define EPS\t\t 1e-8\n#define EQ(a,b)  (fabs((a)-(b))<EPS)\n\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nlong long cross(PP a, PP b) { return (long long)a.x * b.y - (long long)a.y * b.x; }\n\nlong long polygon_area(int n, PP *p)\n{\n   int i;\n   long long s;\n\n   if (n < 3) return 0;\n   s = 0; p[n] = p[0];\n   for (i = 0; i < n; i++) s += cross(p[i], p[i+1]);\n   return s;\n}\n\nint cmp(PP *a, PP *b) {\n\tif (a->y - b->y) return a->y - b->y;\n\treturn a->x - b->x;\n}\n\nint convex_hull(int n, PP *ps, PP *po)\n{\n\tint i, k, j = 0;\n\n\tqsort(ps, n, sizeof(PP), cmp);\n\tfor (i = 0; i < n; i++) {\n\t\twhile (j > 1 && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\tk = j;\n\tfor (i = n - 2; i >= 0; i--) {\n\t\twhile (j > k && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\treturn j-1;\n}\n// [\\library]  \n\nPP  snake[1002];\nPP  pp[2][1002];\n\nvoid reverse(int n, PP *p)\n{\n\tint i, j;\n\tmemcpy(pp[0], p, sizeof(PP)*n);\n\tj = n, i = 0; while (j--) p[i++] = pp[0][j];\n}\n\nint check(int n, PP *p)\n{\n\tint i, k, k1, k2;\n\tlong long prev, s;\n\n\tprev = 0, k = 0, k1 = 0, k2 = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tpp[k1][k++] = p[i];\n\t\tif (i < 2) continue;\n\t\tk = convex_hull(k, pp[k1], pp[k2]);\n\t\ts = polygon_area(k, pp[k2]);\n\t\tif (s == prev) return 0;\n\t\tprev = s, k1 = k2, k2 = !k2;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint n, i, ans;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) snake[i].x = in(), snake[i].y = in();\n\tans = 0;\n\tif (check(n, snake)) {\n\t\treverse(n, snake);\n\t\tif (check(n, snake)) ans = 1;\n\t}\n\tputs(ans? \"Possible\": \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-3;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = false;\n\t\tint[] ord = convexHull(x, y);\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tif (ord[i] == 0) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t} else if (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t} else if (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1) {\n\t\t\t\tfor (int v : lisr) {\n\t\t\t\t\tfor (int u : lisl) {\n\t\t\t\t\t\tif (Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])) {\n\t\t\t\t\t\t\tf &= false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tint[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\tif (x[o1] != x[o2])\n\t\t\t\t\treturn Double.compare(x[o1], x[o2]);\n\t\t\t\tif (y[o1] != y[o2]) {\n\t\t\t\t\treturn Double.compare(y[o1], y[o2]);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-2;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1){\n\t\t\t\tfor(int v:lisr){\n\t\t\t\t\tfor(int u:lisl){\n\t\t\t\t\t\tif(Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])){\n\t\t\t\t\t\t\tf&=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = INF, l = INF;\n\t\t\tint rv = -1, lv = -1;\n\t\t\t// x[i-1],y[i-1]?????´???????????£??????\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (r > theta) {\n\t\t\t\t\t\tr = theta;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (l > theta) {\n\t\t\t\t\t\tl = theta;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tif (Line2D.linesIntersect(x[rv], y[rv], x[lv], y[lv], x[i], y[i], x[i - 1], y[i - 1])) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = INF, l = INF;\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t\trv = j;\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t\tlv = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tint t1 = Line2D.relativeCCW(x[rv], y[rv], x[lv], y[lv], x[i], y[i]);\n\t\t\t\tint t2 = Line2D.relativeCCW(x[rv], y[rv], x[lv], y[lv], x[i - 1], y[i - 1]);\n\t\t\t\tif (t1 * t2 == -1)\n\t\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble r = Math.PI, l = Math.PI;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tSystem.out.println(\"Impossible\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Possible\");\n\t\t}\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tint d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tint rv = -1, lv = -1;\n\t\t\t// x[i-1],y[i-1]?????´???????????£??????\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (r < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (l < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1\n\t\t\t\t\t&& Line2D.linesIntersect(x[rv], y[rv], x[lv], y[lv], x[i], y[i], x[i - 1], y[i - 1])) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-6;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = false;\n\t\tint[] ord = convexHull(x, y);\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tif (ord[i] == 0) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t} else if (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t} else if (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1) {\n\t\t\t\tfor (int v : lisr) {\n\t\t\t\t\tfor (int u : lisl) {\n\t\t\t\t\t\tif (Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])) {\n\t\t\t\t\t\t\tf &= false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tint[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\tif (x[o1] != x[o2])\n\t\t\t\t\treturn Double.compare(x[o1], x[o2]);\n\t\t\t\tif (y[o1] != y[o2]) {\n\t\t\t\t\treturn Double.compare(y[o1], y[o2]);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble r = Math.PI, l = Math.PI;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tint d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble r = Math.PI, l = Math.PI;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-3;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1){\n\t\t\t\tfor(int v:lisr){\n\t\t\t\t\tfor(int u:lisl){\n\t\t\t\t\t\tif(Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])){\n\t\t\t\t\t\t\tf&=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble r = Math.PI, l = Math.PI;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = INF, l = INF;\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t\trv = j;\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t\tlv = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tif(!Line2D.linesIntersect(x[rv], y[rv], x[lv], y[lv], x[i], y[i], x[i-1], y[i-1])){\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int n, i, m;\n    double[] x, y;\n    n = sc.nextInt();\n    x = new double[n]; y = new double[n];\n    for(i = 0;i < n;i++){\n      x[i] = sc.nextDouble(); y[i] = sc.nextDouble();\n    }\n    m = getconvexhull(x, y, n);\n    if(n == m)out.println(\"Possible\");\n    else out.println(\"Impossible\");\n\n    sc.close();\n  }\n  private static int getconvexhull(double[] x, double[] y, int n){\n    int i, numr, numl;\n    double[] resx, resy, anslx, ansly;\n    mergesort(x, y, 0, n);\n    resx = new double[n]; resy = new double[n];\n    numr = rcovering(x, y, n, resx, resy);\n    if(n == numr)return numr;\n    else{\n      anslx = new double[n]; ansly = new double[n];\n      reverse(x, y, n);\n      numl = rcovering(x, y, n, anslx, ansly);\n      for(i = 0;i < numl;i++){\n        resx[numr + i] = anslx[i]; resy[numr + i] = ansly[i];\n      }\n    }\n    return (numr + numl);\n  }\n  private static int rcovering(double[] x, double[] y, int n,\n                                double[] ansx, double[] ansy){\n    int i, num;\n    ansx[0] = x[0]; ansy[0] = y[0]; ansx[1] = x[1]; ansy[1] = y[1];\n    num = 2;\n    for(i = 2;i < n;i++){\n      ansx[num] = x[i]; ansy[num] = y[i];\n      num = gscan(ansx, ansy, num);\n    }\n    if(ansx[num - 1] == x[n - 1] && ansy[num - 1] == y[n - 1])num--;\n    return num;\n  }\n  private static void reverse(double[] x, double[] y, int n){\n    double tmp;\n    int i;\n    for(i = 0;i < n / 2;i++){\n      tmp = x[i]; x[i] = x[n - 1 - i]; x[n - 1 - i] = tmp;\n      tmp = y[i]; y[i] = y[n - 1 - i]; y[n - 1 - i] = tmp;\n    }\n    return;\n  }\n  private static int gscan(double[] ansx, double[] ansy, int num){\n    double s1x, s1y, s2x, s2y;\n    for(;num > 0;){\n      if(num == 1)return ++num;\n      s1x = ansx[num - 1] - ansx[num]; s1y = ansy[num - 1] - ansy[num];\n      s2x = ansx[num - 2] - ansx[num]; s2y = ansy[num - 2] - ansy[num];\n      if(s1x * s2y - s2x * s1y > 0){\n        ansx[num - 1] = ansx[num]; ansy[num - 1] = ansy[num--];\n      }else return ++num;\n    }\n    return num;\n  }\n  private static void mergesort(double[] x, double[] y, int l, int r){\n    int m, c;\n    if(l + 1 >= r)return;\n    else{\n      m = (l + r) / 2;\n      mergesort(x, y, l, m); mergesort(x, y, m, r); merge(x, y, l, m, r);\n      return;\n    }\n  }\n  private static void merge(double[] x, double[] y, int l, int m, int r){\n    int nl, nr;\n    int i, j, k;\n    double infi = 1010001000;\n    double[] xl, xr, yl, yr;\n    nl = m - l; nr = r - m;\n    xl = new double[nl + 1]; xr = new double[nr + 1];\n    yl = new double[nl + 1]; yr = new double[nr + 1];\n    for(i = 0;i < nl;i++){ xl[i] = x[l + i]; yl[i] = y[l + i]; }\n    for(i = 0;i < nr;i++){ xr[i] = x[m + i]; yr[i] = y[m + i]; }\n    xl[nl] = infi; xr[nr] = infi; yl[nl] = infi; yr[nr] = infi;\n    i = 0; j = 0;\n    for(k = l;k < r;k++){\n      if(alow(xl[i], yl[i], xr[j], yr[j])){ x[k] = xl[i]; y[k] = yl[i++]; }\n      else{ x[k] = xr[j]; y[k] = yr[j++]; }\n    }\n    return;\n  }\n  private static boolean alow(double ax, double ay, double bx, double by){\n    if(ay < by || (ay == by && ax <= bx))return true;\n    else return false;\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-6;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = false;\n\t\tint[] ord = convexHull(x, y);\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tif (ord[i] == 0) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t} else if (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t} else if (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1) {\n\t\t\t\tfor (int v : lisr) {\n\t\t\t\t\tfor (int u : lisl) {\n\t\t\t\t\t\tif (Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])) {\n\t\t\t\t\t\t\tf &= false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tint[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\tif (x[o1] != x[o2])\n\t\t\t\t\treturn Double.compare(x[o1], x[o2]);\n\t\t\t\tif (y[o1] != y[o2]) {\n\t\t\t\t\treturn Double.compare(y[o1], y[o2]);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble r = Math.PI, l = Math.PI;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble r = Math.PI, l = Math.PI;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble theta = angle(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tr = Math.min(r, theta);\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tl = Math.min(l, theta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r + l <= Math.PI) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble angle(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn Math.acos(dot / (Math.sqrt(d1) * Math.sqrt(d2)));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint n = ni();\n\t\tdouble[] x = new double[n];\n\t\tdouble[] y = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = nd();\n\t\t\ty[i] = nd();\n\t\t}\n\t\tboolean f = (checker(x, y, n)) && (checker(reverse(x), reverse(y), n));\n\t\tout.println(f ? \"Possible\" : \"Impossible\");\n\t}\n\n\tdouble[] reverse(double[] a) {\n\t\tdouble[] ret = new double[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tret[i] = a[a.length - 1 - i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdouble eps = 1e-1;\n\n\tboolean checker(double[] x, double[] y, int n) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdouble INF = 999999;\n\t\t\tdouble r = -INF, l = -INF;\n\t\t\tArrayList<Integer> lisr = new ArrayList<>();\n\t\t\tArrayList<Integer> lisl = new ArrayList<>();\n\t\t\tint rv = -1, lv = -1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble cos = cos(new double[] { x[i - 1] - x[i], y[i - 1] - y[i] },\n\t\t\t\t\t\tnew double[] { x[j] - x[i], y[j] - y[i] });\n\t\t\t\tint t = Line2D.relativeCCW(x[i], y[i], x[i - 1], y[i - 1], x[j], y[j]);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tif (Math.abs(r - cos) < eps) {\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (r + eps < cos) {\n\t\t\t\t\t\tr = cos;\n\t\t\t\t\t\trv = j;\n\t\t\t\t\t\tlisr.clear();\n\t\t\t\t\t\tlisr.add(j);\n\t\t\t\t\t}\n\t\t\t\t} else if (t == 1) {\n\t\t\t\t\tif (Math.abs(l - cos) < eps) {\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (l + eps < cos) {\n\t\t\t\t\t\tl = cos;\n\t\t\t\t\t\tlv = j;\n\t\t\t\t\t\tlisl.clear();\n\t\t\t\t\t\tlisl.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rv != -1 && lv != -1){\n\t\t\t\tfor(int v:lisr){\n\t\t\t\t\tfor(int u:lisl){\n\t\t\t\t\t\tif(Line2D.linesIntersect(x[v], y[v], x[u], y[u], x[i], y[i], x[i - 1], y[i - 1])){\n\t\t\t\t\t\t\tf&=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\n\tdouble cos(double[] v, double[] u) {\n\t\tdouble dot = 0;\n\t\tfor (int i = 0; i < v.length; i++)\n\t\t\tdot = v[i] * u[i];\n\t\tdouble d1 = 0, d2 = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\td1 += v[i] * v[i];\n\t\t\td2 += u[i] * u[i];\n\t\t}\n\t\treturn dot / (Math.sqrt(d1) * Math.sqrt(d2));\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar n=arr.shift();\nif(n<=3){\n   console.log(\"Possible\");\n   return;\n}\narr=arr.map(function(v){\n   return v.split(\" \").map(Number);\n});\nfor(var j=0;j<2;j++){\n   for(var i=3;i<arr.length;i++){\n      var v0=arr[i-3][j];\n      var v1=arr[i-2][j];\n      var v2=arr[i-1][j];\n      var v3=arr[i][j];\n      var flag=false;\n      if(v3>=v2 && v2>=v1 && v1>=v0)flag=true;\n      if(v3<=v2 && v2<=v1 && v1<=v0)flag=true;\n      if(flag==false){\n         console.log(\"Impossible\");\n         return;\n      }\n   }\n}\nconsole.log(\"Possible\");"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar n=arr.shift();\nif(n<=3){\n   console.log(\"possible\");\n   return;\n}\narr=arr.map(function(v){\n   return v.split(\" \").map(Number);\n});\nfor(var j=0;j<2;j++){\n   for(var i=3;i<arr.length;i++){\n      var v0=arr[i-3][j];\n      var v1=arr[i-2][j];\n      var v2=arr[i-1][j];\n      var v3=arr[i][j];\n      var flag=false;\n      if(v3>=v2 && v2>=v1 && v1>=v0)flag=true;\n      if(v3<=v2 && v2<=v1 && v1<=v0)flag=true;\n      if(flag==false){\n         console.log(\"Impossible\");\n         return;\n      }\n   }\n}\nconsole.log(\"possible\");"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.math;\nimport std.algorithm;\nimport std.typecons;\nimport std.stdio;\n\nvoid main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tlong[] x=new long[n],y=new long[n];\n\tforeach(i;0..n)\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\talias Tuple!(long,\"x\",long,\"y\",int,\"k\") p;\n\tp[] ps = new p[n-1];\n\tforeach(i;0..n){\n\t\tint c;\n\t\tint u1;\n\t\tint u2;\n\t\tforeach(j;0..n)\n\t\t\tif(j<i){\n\t\t\t\tif(y[j]>=y[i]){\n\t\t\t\t\tps[c++]=p(x[j]-x[i],y[j]-y[i],0);\n\t\t\t\t\tu1++;\n\t\t\t\t}else\n\t\t\t\t\tps[c++]=p(x[i]-x[j],y[i]-y[j],1);\n\t\t\t}else if(j>i){\n\t\t\t\tif(y[j]>=y[i]){\n\t\t\t\t\tps[c++]=p(x[j]-x[i],y[j]-y[i],2);\n\t\t\t\t\tu2++;\n\t\t\t\t}else\n\t\t\t\t\tps[c++]=p(x[i]-x[j],y[i]-y[j],3);\n\t\t\t}\n\t\tsort!((a,b)=>a.x*b.y>a.y*b.x)(ps);\n\t\tif((u1==0||u1==i)&&(u2==0||u2==(n-i-1)))\n\t\t\tcontinue;\n\t\tbool ok=false;\n\t\tforeach(v;ps){\n\t\t\tif(v.k==0)\n\t\t\t\tu1--;\n\t\t\telse if(v.k==1)\n\t\t\t\tu1++;\n\t\t\telse if(v.k==2)\n\t\t\t\tu2--;\n\t\t\telse if(v.k==3)\n\t\t\t\tu2++;\n\t\t\telse\n\t\t\t\tassert(false);\n\t\t\tif((u1==0||u1==i)&&(u2==0||u2==(n-i-1))){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef dot3(p0, p1, p2):\n    x0, y0 = p0; x1, y1 = p1; x2, y2 = p2\n    return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\ndef cross3(p0, p1, p2):\n    x0, y0 = p0; x1, y1 = p1; x2, y2 = p2\n    return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\ndef dist2(p0, p1):\n    x0, y0 = p0; x1, y1 = p1\n    return (x0 - x1)**2 + (y0 - y1)**2\ndef solve():\n    N = int(readline())\n    P = [list(map(int, readline().split())) for i in range(N)]\n    ok = 1\n    for i in range(N-1):\n        p0 = P[i]; p1 = P[i+1]\n        d0 = dist2(p0, p1)**.5\n        el0 = [-d0, d0]; el1 = [-d0, d0]\n        er0 = [-d0, d0]; er1 = [-d0, d0]\n        for j in range(i):\n            q0 = P[j]\n            d1 = dist2(p0, q0)**.5\n            d2 = dist2(p1, q0)**.5\n            sv = cross3(p0, p1, q0)\n\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i+2, N):\n            q1 = P[j]\n            d1 = dist2(p1, q1)**.5\n            d2 = dist2(p0, q1)**.5\n            sv = cross3(p1, p0, q1)\n\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if (not max(el0[0], er0[0]) <= min(el0[1], er0[1])\n         or not max(el1[0], er0[0]) <= min(el1[1], er1[1])):\n            ok = 0\n            break\n    if ok:\n        write(\"Possible\\n\")\n    else:\n        write(\"Impossible\\n\")\nsolve()\n"
  }
]