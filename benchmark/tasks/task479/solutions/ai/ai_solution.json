[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool is_point_inside_line_segment(Point p, Point a, Point b) {\n    return fabs(cross_product(a, b, p)) < EPS &&\n           p.x >= fmin(a.x, b.x) && p.x <= fmax(a.x, b.x) &&\n           p.y >= fmin(a.y, b.y) && p.y <= fmax(a.y, b.y);\n}\n\nbool line_segments_intersect(Point a, Point b, Point c, Point d) {\n    double cp1 = cross_product(a, b, c);\n    double cp2 = cross_product(a, b, d);\n    double cp3 = cross_product(c, d, a);\n    double cp4 = cross_product(c, d, b);\n\n    if (fabs(cp1) < EPS && is_point_inside_line_segment(c, a, b)) return true;\n    if (fabs(cp2) < EPS && is_point_inside_line_segment(d, a, b)) return true;\n    if (fabs(cp3) < EPS && is_point_inside_line_segment(a, c, d)) return true;\n    if (fabs(cp4) < EPS && is_point_inside_line_segment(b, c, d)) return true;\n\n    return (cp1 * cp2 < 0) && (cp3 * cp4 < 0);\n}\n\nbool can_pass_through_hole(Point *vertices, int n) {\n    Point origin = {0, 0};\n    int crossings = 0;\n\n    for (int i = 0; i < n; i++) {\n        Point a = vertices[i];\n        Point b = vertices[(i + 1) % n];\n\n        if (line_segments_intersect(a, b, origin, (Point){0, -1})) {\n            crossings++;\n        }\n    }\n\n    return crossings % 2 == 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Point *vertices = malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &vertices[i].x, &vertices[i].y);\n    }\n\n    printf(\"%s\\n\", can_pass_through_hole(vertices, n) ? \"YES\" : \"NO\");\n\n    free(vertices);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nbool can_pass_through_hole(Point polyline[], int n) {\n    double min_sum = INFINITY;\n    double max_diff = -INFINITY;\n\n    for (int i = 0; i < n; i++) {\n        double x = polyline[i].x;\n        double y = polyline[i].y;\n        double sum = x + y;\n        double diff = x - y;\n\n        if (sum < min_sum) min_sum = sum;\n        if (diff > max_diff) max_diff = diff;\n    }\n\n    return (min_sum <= 0) && (max_diff >= 0);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point polyline[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polyline[i].x, &polyline[i].y);\n    }\n\n    if (can_pass_through_hole(polyline, n)) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    double cross(const Point& p) const { return x * p.y - y * p.x; }\n    double dot(const Point& p) const { return x * p.x + y * p.y; }\n    double norm() const { return sqrt(x*x + y*y); }\n    Point normalize() const { double n = norm(); return Point(x/n, y/n); }\n    Point rotate90() const { return Point(-y, x); }\n};\n\nbool isPointInsidePolygon(const Point& p, const vector<Point>& poly) {\n    int n = poly.size();\n    bool inside = false;\n    for (int i = 0, j = n - 1; i < n; j = i++) {\n        if (((poly[i].y > p.y) != (poly[j].y > p.y)) &&\n            (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x))\n            inside = !inside;\n    }\n    return inside;\n}\n\nbool canPassThroughHole(const vector<Point>& poly) {\n    Point hole(0, 0);\n    if (isPointInsidePolygon(hole, poly)) return false;\n\n    int n = poly.size();\n    for (int i = 0; i < n - 1; ++i) {\n        Point a = poly[i], b = poly[i+1];\n        if (a.cross(b) == 0) continue; // Collinear with origin\n        Point normal = (b - a).rotate90().normalize();\n        double d = normal.dot(a);\n        if (d < 0) {\n            bool allNegative = true;\n            for (const Point& p : poly) {\n                if (normal.dot(p) >= 0) {\n                    allNegative = false;\n                    break;\n                }\n            }\n            if (allNegative) return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> poly(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> poly[i].x >> poly[i].y;\n    }\n    cout << (canPassThroughHole(poly) ? \"YES\" : \"NO\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PolylineThroughHole {\n    public static boolean canPassThroughHole(int[][] vertices) {\n        int n = vertices.length;\n        if (n == 1) {\n            return vertices[0][0] == 0 && vertices[0][1] == 0;\n        }\n\n        List<double[]> edges = new ArrayList<>();\n        for (int i = 0; i < n - 1; i++) {\n            int x1 = vertices[i][0], y1 = vertices[i][1];\n            int x2 = vertices[i + 1][0], y2 = vertices[i + 1][1];\n            edges.add(new double[]{x2 - x1, y2 - y1});\n        }\n\n        double maxDistance = 0;\n        for (int[] vertex : vertices) {\n            double distance = Math.sqrt(vertex[0] * vertex[0] + vertex[1] * vertex[1]);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n            }\n        }\n\n        double[] origin = {0, 0};\n        for (double[] edge : edges) {\n            double x1 = 0, y1 = 0;\n            double x2 = edge[0], y2 = edge[1];\n            double a = y2 - y1;\n            double b = x1 - x2;\n            double c = x2 * y1 - x1 * y2;\n            double distance = Math.abs(c) / Math.sqrt(a * a + b * b);\n            if (distance <= maxDistance) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] vertices = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            vertices[i][0] = scanner.nextInt();\n            vertices[i][1] = scanner.nextInt();\n        }\n        System.out.println(canPassThroughHole(vertices) ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 21:53:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PolylineHoleProblem {\n    public static boolean canPassThroughHole(double[][] vertices) {\n        int n = vertices.length;\n        \n        // Check winding number around origin\n        double windingAngle = 0;\n        for (int i = 0; i < n; i++) {\n            double x1 = vertices[i][0];\n            double y1 = vertices[i][1];\n            double x2 = vertices[(i + 1) % n][0];\n            double y2 = vertices[(i + 1) % n][1];\n            \n            double angle = Math.atan2(x1 * y2 - x2 * y1, x1 * x2 + y1 * y2);\n            windingAngle += angle;\n        }\n        \n        return Math.abs(windingAngle) > Math.PI;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        double[][] polyline = {{1, 1}, {-1, 1}, {-1, -1}, {1, -1}};\n        System.out.println(canPassThroughHole(polyline));\n    }\n}",
    "timestamp": "2025-08-05 21:53:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble cross_product(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool is_point_inside_polygon(const vector<Point>& polygon, const Point& point) {\n    int n = polygon.size();\n    int inside_count = 0;\n\n    for (int i = 0; i < n; ++i) {\n        Point p1 = polygon[i];\n        Point p2 = polygon[(i + 1) % n];\n\n        if ((p1.y > point.y) != (p2.y > point.y)) {\n            double x_intersect = p1.x + (point.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);\n            if (point.x < x_intersect) {\n                inside_count++;\n            }\n        }\n    }\n\n    return inside_count % 2 == 1;\n}\n\nbool can_pass_through_hole(const vector<Point>& polyline) {\n    Point hole = {0, 0};\n\n    // Check if hole is inside the polyline\n    if (!is_point_inside_polygon(polyline, hole)) {\n        return false;\n    }\n\n    // Check if polyline can move to y < 0\n    int above_count = 0, below_count = 0;\n    for (const auto& point : polyline) {\n        if (point.y > 0) above_count++;\n        if (point.y < 0) below_count++;\n    }\n\n    return above_count > 0 && below_count > 0;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> polyline(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> polyline[i].x >> polyline[i].y;\n    }\n\n    cout << (can_pass_through_hole(polyline) ? \"YES\" : \"NO\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from math import atan2, sin, cos\n\ndef can_pass_through_hole(vertices):\n    n = len(vertices)\n    \n    # Check if any vertex is already in y < 0\n    if all(y > 0 for _, y in vertices):\n        return False\n    \n    # Translate vertices to make (0, 0) the centroid\n    cx = sum(x for x, _ in vertices) / n\n    cy = sum(y for _, y in vertices) / n\n    vertices = [(x - cx, y - cy) for x, y in vertices]\n    \n    # Check if polyline can be rotated to pass through (0, 0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate rotation angle to align vertex i with (0, 0)\n            x_diff, y_diff = vertices[j][0] - vertices[i][0], vertices[j][1] - vertices[i][1]\n            angle = -atan2(y_diff, x_diff)\n\n            # Rotate all vertices\n            rotated_vertices = [\n                (x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle))\n                for x, y in vertices\n            ]\n\n            # Check if all vertices are in y < 0 after rotation\n            if all(y < 0 for _, y in rotated_vertices):\n                return True\n    \n    return False\n\n# Example Usage:\nvertices = [(1, 1), (-1, 2), (-2, -1), (0, -3)]\nprint(can_pass_through_hole(vertices)) # Output depends on the specific polyline input",
    "timestamp": "2025-08-13 07:49:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\n\npublic class PolylineThroughHole {\n\n    public static boolean canPassThroughHole(Point2D[] vertices) {\n        // Check if any vertex is at (0, 0)\n        for (Point2D vertex : vertices) {\n            if (vertex.getX() == 0 && vertex.getY() == 0) {\n                return true;\n            }\n        }\n\n        // Check if any line segment intersects with (0,0) and y < 0 using translations\n        for (Point2D vertex : vertices) {\n            // Translate so vertex is at (0, 0)\n            double dx = -vertex.getX();\n            double dy = -vertex.getY();\n\n            // Check if entire polyline can be translated down\n            boolean canTranslateBelowZero = true;\n            for (Point2D checkVertex : vertices) {\n                if (checkVertex.getY() + dy >= 0) {\n                    canTranslateBelowZero = false;\n                    break;\n                }\n            }\n\n            if (canTranslateBelowZero) {\n                return true;\n            }\n        }\n\n        // Check for rotation possibilities\n        for (int i = 0; i < vertices.length - 1; i++) {\n            for (int j = i + 1; j < vertices.length; j++) {\n                Point2D p1 = vertices[i];\n                Point2D p2 = vertices[j];\n                \n                double dx = p2.getX() - p1.getX();\n                double dy = p2.getY() - p1.getY();\n                \n                double length = Math.sqrt(dx * dx + dy * dy);\n                \n                double sinTheta = dy / length;\n                double cosTheta = dx / length;\n\n                // Check if polyline can be rotated\n                boolean canRotate = true;\n                for (Point2D vertex : vertices) {\n                    double newX = cosTheta * (vertex.getX() - p1.getX()) + sinTheta * (vertex.getY() - p1.getY()) + p1.getX();\n                    double newY = -sinTheta * (vertex.getX() - p1.getX()) + cosTheta * (vertex.getY() - p1.getY()) + p1.getY();\n                    \n                    if (newY >= 0) {\n                        canRotate = false;\n                        break;\n                    }\n                }\n\n                if (canRotate) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Point2D[] vertices = {\n            new Point2D.Double(-1, 1),\n            new Point2D.Double(1, 1),\n            new Point2D.Double(0, -2),\n        };\n\n        boolean result = canPassThroughHole(vertices);\n        System.out.println(\"Can the polyline pass through the hole and move entirely to y < 0? \" + result);\n    }\n}",
    "timestamp": "2025-08-13 07:49:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAXN 1000\n#define EPSILON 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\nPoint vertices[MAXN];\nint n;\n\nint is_below_x_axis(Point *v, int n) {\n    for (int i = 0; i < n; ++i) {\n        if (v[i].y >= 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ndouble cross_product(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint can_pass_through_hole() {\n    for (int i = 0; i < n; ++i) {\n        if (fabs(vertices[i].x) < EPSILON && fabs(vertices[i].y) < EPSILON) {\n            return is_below_x_axis(vertices, n);\n        }\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        if (cross_product(vertices[i], vertices[i + 1]) < 0) {\n            return is_below_x_axis(vertices, n);\n        }\n    }\n    Point reference = {0, 0};\n    double min_dist = (vertices[0].y - reference.y) * (vertices[0].y - reference.y);\n    int min_index = 0;\n    for (int i = 1; i < n; ++i) {\n        double dist = (vertices[i].y - reference.y) * (vertices[i].y - reference.y);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n    double angle = atan2(-vertices[min_index].y, -vertices[min_index].x);\n    for (int i = 0; i < n; ++i) {\n        double x = vertices[i].x, y = vertices[i].y;\n        vertices[i].x = x * cos(angle) - y * sin(angle);\n        vertices[i].y = x * sin(angle) + y * cos(angle);\n    }\n    return is_below_x_axis(vertices, n);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%lf %lf\", &vertices[i].x, &vertices[i].y);\n    }\n    if (can_pass_through_hole()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 07:49:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_pass_through_hole(vertices):\n    # Check if the polyline passes through the origin\n    crosses_origin = False\n    for i in range(len(vertices)):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % len(vertices)]\n        \n        if (y1 <= 0 and y2 > 0) or (y1 > 0 and y2 <= 0):\n            # Compute x-coordinate of intersection with y=0\n            x_intersect = x1 - y1 * (x2 - x1) / (y2 - y1)\n            if abs(x_intersect) <= 1e-10:\n                crosses_origin = True\n                break\n    \n    if not crosses_origin:\n        return False\n    \n    # Check winding number for lower half-plane\n    winding_number = 0\n    for i in range(len(vertices)):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % len(vertices)]\n        \n        if y1 <= 0 and y2 > 0:\n            if (x2 - x1) * (0 - y1) > (0 - x1) * (y2 - y1):\n                winding_number += 1\n        elif y1 > 0 and y2 <= 0:\n            if (x2 - x1) * (0 - y1) < (0 - x1) * (y2 - y1):\n                winding_number -= 1\n    \n    return winding_number == 1",
    "timestamp": "2025-08-13 07:49:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef can_pass_through_hole(polyline):\n    n = len(polyline)\n    if n == 1:\n        return polyline[0][1] < 0\n    \n    min_y = min(y for x, y in polyline)\n    if min_y >= 0:\n        return False\n    \n    max_y = max(y for x, y in polyline)\n    if max_y <= 0:\n        return True\n    \n    min_x = min(x for x, y in polyline)\n    max_x = max(x for x, y in polyline)\n    \n    for i in range(n - 1):\n        x1, y1 = polyline[i]\n        x2, y2 = polyline[i + 1]\n        \n        if y1 * y2 < 0:\n            x_intersect = x1 - y1 * (x2 - x1) / (y2 - y1)\n            if x_intersect == 0 and (min_x <= 0 <= max_x):\n                return False\n    \n    convex_hull = []\n    for point in polyline:\n        while len(convex_hull) >= 2 and cross(convex_hull[-2], convex_hull[-1], point) <= 0:\n            convex_hull.pop()\n        convex_hull.append(point)\n    \n    lower = len(convex_hull)\n    for point in reversed(polyline):\n        while len(convex_hull) > lower and cross(convex_hull[-2], convex_hull[-1], point) <= 0:\n            convex_hull.pop()\n        convex_hull.append(point)\n    \n    convex_hull = convex_hull[:-1]\n    \n    for i in range(len(convex_hull)):\n        p1 = convex_hull[i]\n        p2 = convex_hull[(i + 1) % len(convex_hull)]\n        if p1[1] * p2[1] <= 0:\n            if p1[1] == p2[1]:\n                if p1[1] == 0 and ((p1[0] <= 0 <= p2[0]) or (p2[0] <= 0 <= p1[0])):\n                    return False\n            else:\n                x_intersect = p1[0] - p1[1] * (p2[0] - p1[0]) / (p2[1] - p1[1])\n                if abs(x_intersect) < 1e-9:\n                    return False\n    \n    return True\n\ndef cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])",
    "timestamp": "2025-08-13 07:50:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nbool canPassHole(const vector<Point>& polyline) {\n    int n = polyline.size();\n    \n    // Check if any segment crosses the origin (0, 0)\n    for (int i = 0; i < n; ++i) {\n        Point p1 = polyline[i];\n        Point p2 = polyline[(i + 1) % n];\n        \n        // Line connecting p1 to p2 crosses the x-axis\n        if ((p1.y > 0 && p2.y < 0) || (p1.y < 0 && p2.y > 0)) {\n            double xCross = p1.x + (p2.x - p1.x) * (-p1.y) / (p2.y - p1.y);\n            if (xCross == 0) {\n                return true; // Tangential crossing through (0,0)\n            }\n        }\n    }\n    \n    // Check if Entire Polyline can be moved across the x-axis to y < 0 \n    double minY = polyline[0].y, maxY = polyline[0].y;\n    for (const Point& p : polyline) {\n        minY = min(minY, p.y);\n        maxY = max(maxY, p.y);\n    }\n\n    return (maxY <= 0 || minY >= 0);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> polyline(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> polyline[i].x >> polyline[i].y;\n    }\n    \n    if (canPassHole(polyline)) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:41:04"
  }
]