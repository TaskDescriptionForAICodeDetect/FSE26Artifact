[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000001], y[1000001];\nll dp[2000001][2];\nconst ll inf = 9000000000000000000;\nll solve(int i/*????????§??????*/, ll j, short c) {\n\tll sum = inf;\n\tif (c == 0) {//????????§???????¬?????¨?\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = abs(i - w);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (ll z = 0; z < (ll)x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, res + 1+dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = abs(i - h);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (ll z = 0; z < (ll)y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, res + 1 + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tint l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll u1, u2;\n\t\tcin >> u2 >> u1;\n\t\tx[u1].push_back(A{ u2,i });\n\t\ty[u2].push_back(A{ u1,i });\n\t\tif (u1 == 1 && u2 == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tdp[i][0] = -1;\n\t\tdp[i][1] = -1;\n\t}\n\tll ans;\n\tif (l[0]!=-1) {\n\t\tans = min(1 + solve(1, l[1], 0), solve(1, l[0], 1));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tans = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (ans >= inf)\n\t\tans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M)if(no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\tif(no.di==0){\n\t\t\t\tfor(ite=se[0][no.x].begin();ite!=se[0][no.x].end();ite++){\n\t\t\t\t\tif(used[1].count(make_pair(no.x,*ite))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.y)+no.d+1,no.x,*ite,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(ite=se[1][no.y].begin();ite!=se[1][no.y].end();ite++){\n\t\t\t\t\tif(used[0].count(make_pair(*ite,no.y))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.x)+no.d+1,*ite,no.y,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tpriority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin() - 1;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin() - 1;\n\t\t\n\t\tif( 0 <= pr && pr < sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\tif( 0 <= pc && pc < sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨????????????????\n\tsc[h-1].push_back(w-1);\n\tsr[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tint d,x,y,di;\n\tnode(){\n\n\t}\n\tnode(int dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg;\n\tset<int>::iterator ite;\n\tint M,N,K,res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\tif(se[0][1].count(1)>0)flg=true;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tused[1-no.di].insert(make_pair(no.x,no.y));\n\t\tif(flg){\n\t\t\tflg=false;\n\t\t\tused[1].erase(make_pair(1,1));\n\t\t}\n\t\tif(no.x==M&&no.y==N){\n\t\t\tres=no.d-1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t}\n\t\t}\n\t\twhile(!sag.empty()){\n\t\t\tno2=sag.top();sag.pop();\n\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t}\n\t\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n \n//#define DEBUG\n \nconstexpr int K_MAX = 200000;\nconstexpr uint64_t INF = (uint64_t)(100000) * 200000;\nint W, H, K;\nstruct edge {\n\tunsigned cost, to;\n\tedge()noexcept {}\n\tedge(int cost, int to)noexcept:cost(cost), to(to) {}\n};\nstd::vector<edge> graph[K_MAX + 2][2];//???????????±?\\?\nint K_x[K_MAX + 2];\nint K_y[K_MAX + 2];\nuint64_t d[K_MAX + 2][2];\nvoid dijk()\n{\n\tusing P = std::pair<uint64_t, uint32_t>;//cost, to(30,2)\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> que;\n\tfor (auto& arr1 : d)for (auto& i : arr1) { i = INF; }\n\td[0][0] = 0;\n\tque.emplace(0, 0);\n\t{\n\t\tauto npos_raw = que.top(); que.pop();\n\t\tconst uint8_t mode = (uint8_t)(npos_raw.second & 0x3);\n\t\tconst uint32_t npos = (uint32_t)(npos_raw.second >> 2);\n\t\tconst auto& ncost = npos_raw.first;\n\t\t//if(d[npos][mode] < ncost){continue;}\n \n\t\tfor (const auto& next : graph[npos][mode]) {\n\t\t\tconst auto next_cost = ncost + next.cost;\n\t\t\tif (next_cost < d[next.to][mode]) {\n\t\t\t\td[next.to][mode] = next_cost;\n\t\t\t\tque.emplace(next_cost, (next.to << 2) | mode);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\tauto npos_raw = que.top(); que.pop();\n\t\tconst uint8_t mode = (uint8_t)(npos_raw.second & 0x3);\n\t\tconst uint32_t npos = (uint32_t)(npos_raw.second >> 2);\n\t\tconst auto& ncost = npos_raw.first;\n\t\tif (d[npos][mode] < ncost) { continue; }\n \n\t\tfor (const auto& next : graph[npos][mode]) {\n\t\t\tconst auto next_cost = ncost + next.cost;\n\t\t\tif (next_cost < d[next.to][mode]) {\n\t\t\t\td[next.to][mode] = next_cost;\n\t\t\t\tque.emplace(next_cost, (next.to << 2) | mode);\n\t\t\t}\n\t\t}\n\t\tif (ncost + 1 < d[npos][mode ^ 1]) {\n\t\t\td[npos][mode ^ 1] = ncost + 1;\n\t\t\tque.emplace(ncost + 1, (npos << 2) | (mode ^ 1));\n\t\t}\n\t}\n}\n \nint main()\n{\n\tstd::cin >> W >> H >> K;\n\tK_x[0] = K_y[0] = 0;\n\tK_x[1] = W - 1; K_y[1] = H - 1;\n\tfor (int i = 0; i < K; ++i) {\n\t\tstd::cin >> K_x[2 + i] >> K_y[2 + i];\n\t\t--K_x[2 + i];\n\t\t--K_y[2 + i];\n\t}\n\t{\n\t\tstatic std::pair<int, int> temp[K_MAX + 2];\n\t\t//X?????????\n\t\tfor (int i = 0; i < K + 2; ++i) {\n\t\t\ttemp[i].first = K_x[i];\n\t\t\ttemp[i].second = i;\n\t\t}\n\t\tstd::sort(temp, temp + K + 2);\n\t\tfor (int i = 1; i < K + 2; ++i) {\n\t\t\tif (temp[i - 1].first == temp[i].first) {\n\t\t\t\tauto i1 = temp[i - 1].second;\n\t\t\t\tauto i2 = temp[i].second;\n\t\t\t\tgraph[i1][0].emplace_back(std::abs(K_y[i2] - K_y[i1]), i2);\n\t\t\t\tgraph[i2][0].emplace_back(std::abs(K_y[i1] - K_y[i2]), i1);\n\t\t\t}\n\t\t}\n\t\t//Y?????????\n\t\tfor (int i = 0; i < K + 2; ++i) {\n\t\t\ttemp[i].first = K_y[i];\n\t\t\ttemp[i].second = i;\n\t\t}\n\t\tstd::sort(temp, temp + K + 2);\n\t\tfor (int i = 1; i < K + 2; ++i) {\n\t\t\tif (temp[i - 1].first == temp[i].first) {\n\t\t\t\tauto i1 = temp[i - 1].second;\n\t\t\t\tauto i2 = temp[i].second;\n\t\t\t\tgraph[i1][1].emplace_back(std::abs(K_x[i2] - K_x[i1]), i2);\n\t\t\t\tgraph[i2][1].emplace_back(std::abs(K_x[i1] - K_x[i2]), i1);\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG\n\tstd::cout << \"---------------------\\n\";\n\tfor (int i = 0; i < K + 2; ++i) {\n\t\tstd::cout << \"from(\" << K_x[i] << ',' << K_y[i]<<'$'<<i << \"):\";\n\t\tfor (auto& k : graph[i][0]) {\n\t\t\tstd::cout << \"(\" << K_x[k.to] << ',' << K_y[k.to] << '?' << k.cost << '$' << k.to << \")\";\n\t\t}\n\t\tstd::cout << \"|\";\n\t\tfor (auto& k : graph[i][1]) {\n\t\t\tstd::cout << \"(\" << K_x[k.to] << ',' << K_y[k.to] << '?' << k.cost << '$' << k.to << \")\";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n#endif \n \n\tdijk();\n#ifdef DEBUG\n\tstd::cout << \"---------------------\\n\";\n\tfor (int i = 0; i < K + 2; ++i) {\n\t\tstd::cout << \"(\" << K_x[i] << ',' << K_y[i] << '?' << d[i][0] << '|' << d[i][1] << \")\";\n\t}\n\tstd::cout << std::endl;\n#endif\n \n\tauto res = std::min(d[1][0], d[1][1]);\n\t(res == INF ? (std::cout << -1) : (std::cout << res)) << std::endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nll abs(ll a) {\n  return a >= 0 ? a : -a;\n}\n\nll min(ll a, ll b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, m, n, x, y, sm = 1, l;\n  ll inf = 10e15;\n  scanf(\"%d%d%d\", &m, &n, &k);\n  vector< pair<int, int> > node[k + 2];\n  vector< pair<int, int> > vec1[m], vec2[n];\n  while(sm < k + 2) sm *= 2;\n  pair<ll, ll> seg[sm * 2 + 1];\n  ll dis[k + 2];\n  char flag[k + 2];\n  for(i = 0; i < k + 2; ++i) dis[i] = inf, flag[i] = 1;\n  dis[0] = 0, flag[0] = 0;\n  for(i = 0; i <= 2 * sm; ++i) seg[i].first = inf, seg[i].second = i - sm;\n  seg[1].second = 0;\n  vec1[0].push_back(make_pair(0, 0));\n  vec1[m - 1].push_back(make_pair(n - 1, k + 1)), vec2[n - 1].push_back(make_pair(m - 1, k + 1));\n  for(i = 1; i <= k; ++i) {\n    scanf(\"%lld%lld\", &x, &y);\n    x--, y--;\n    vec1[x].push_back(make_pair(y, i));\n    vec2[y].push_back(make_pair(x, i));\n  }\n  for(i = 0; i < m; ++i) {\n    for(j = 0; j < vec1[i].size(); ++j) for(l = 0; l < vec1[i].size(); ++l) if(j != l) {\n      node[vec1[i][j].second].push_back(make_pair(abs(vec1[i][j].first - vec1[i][l].first) + (vec1[i][l].second == k + 1 ? 0 : 1), vec1[i][l].second));\n    }\n  }\n  for(i = 0; i < n; ++i) {\n    for(j = 0; j < vec2[i].size(); ++j) for(l = 0; l < vec2[i].size(); ++l) if(j != l) {\n      node[vec2[i][j].second].push_back(make_pair(abs(vec2[i][j].first - vec2[i][l].first) + (vec2[i][l].second == k + 1 ? 0 : 1), vec2[i][l].second));\n    }\n  }\n  int now = 0;\n  while( 1 ) {\n    int tmp;\n    for(i = 0; i < node[now].size(); ++i) {\n      if(flag[node[now][i].second] && dis[node[now][i].second] > dis[now] + node[now][i].first) {\n        dis[node[now][i].second] = dis[now] + node[now][i].first;\n        seg[node[now][i].second + sm].first = dis[now] + node[now][i].first;\n        tmp = node[now][i].second + sm;\n        tmp /= 2;\n        while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n      }\n    }\n    if(!flag[seg[1].second]) {\n      dis[k + 1] = -1;\n      break;\n    } else {\n      if(seg[1].second == k + 1) break;\n      flag[seg[1].second] = 0;\n      now = seg[1].second;\n      seg[seg[1].second + sm].first = inf;\n      ll tmp = seg[1].second + sm;\n      tmp /= 2;\n      while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n    }\n  }\n  printf(\"%lld\\n\", dis[k + 1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nstruct data{\n    int v,c,d;\n    data(int v,int c,int d):v(v),c(c),d(d){}\n    bool operator<(const data &d)const{\n        return c>d.c;\n    }\n};\n\nconst int SIZE=200000;\nconst int INF=1001001001001001001LL;\nint W,H,K;\nint X[SIZE],Y[SIZE];\n\nvpint row[SIZE],col[SIZE];\n\nint to[SIZE][4];\nint cost[SIZE][4];\n\nint dist[SIZE][2];\n\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n\n    cin>>W>>H>>K;\n    rep(i,K){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n        row[Y[i]].pb(pint(X[i],i));\n        col[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(col[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,(int)row[i].size()-1){\n            pint &v=row[i][j],&u=row[i][j+1];\n            to[v.se][1]=u.se;cost[v.se][1]=u.fi-v.fi;\n            to[u.se][3]=v.se;cost[u.se][3]=u.fi-v.fi;\n        }\n    }\n    rep(i,W){\n        rep(j,(int)col[i].size()-1){\n            pint &v=col[i][j],&u=col[i][j+1];\n            to[v.se][2]=u.se;cost[v.se][2]=u.fi-v.fi;\n            to[u.se][0]=v.se;cost[u.se][0]=u.fi-v.fi;\n        }\n    }\n\n    if(col[0].size()==0){\n        cout<<-1<<endl;\n        return 0;\n    }\n\n    pint start=col[0][0];\n    fill_n(*dist,SIZE*2,INF);\n    dist[start.se][0]=start.fi;\n    priority_queue<data>que;\n    que.push(data(start.se,start.fi,0));\n\n    while(que.size()){\n        data d=que.top();que.pop();\n        if(dist[d.v][d.d]<d.c)continue;\n        if(dist[d.v][1-d.d]>d.c+1){\n            dist[d.v][1-d.d]=d.c+1;\n            que.push(data(d.v,d.c+1,1-d.d));\n        }\n\n        rep(i,4){\n            if(i%2!=d.d)continue;\n            int t=to[d.v][i],c=cost[d.v][i];\n            if(t==-1)continue;\n            if(dist[t][d.d]<=d.c+c)continue;\n            dist[t][d.d]=d.c+c;\n            que.push(data(t,d.c+c,d.d));\n        }\n    }\n    int mi=INF;\n\n    rep(i,K){\n        if(X[i]==W-1){\n            chmin(mi,dist[i][0]+H-1-Y[i]);\n        }\n        if(Y[i]==H-1){\n            chmin(mi,dist[i][1]+W-1-X[i]);\n        }\n    }\n\n    cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct p1 {\n\tint idx, x, y;\n};\nbool operator<(const p1& r1, const p1& r2) {\n\tif (r1.y != r2.y) return r1.y < r2.y;\n\treturn r1.x < r2.x;\n}\nstruct edge {\n\tint to; long long cost; int type;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint H, W, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<p1> p(N);\n\tfor (int i = 0; i < N; i++) cin >> p[i].x >> p[i].y, p[i].x--, p[i].y--, p[i].idx = i;\n\tp.push_back(p1{ N, W - 1, H - 1 }); N++;\n\tvector<vector<p1> > ex(W), ey(H);\n\tfor (int i = 0; i < N; i++) {\n\t\tex[p[i].x].push_back(p[i]);\n\t\tey[p[i].y].push_back(p[i]);\n\t}\n\tfor (int i = 0; i < W; i++) sort(ex[i].begin(), ex[i].end());\n\tfor (int i = 0; i < H; i++) sort(ey[i].begin(), ey[i].end());\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 1; j < ex[i].size(); j++) {\n\t\t\tint d = ex[i][j].y - ex[i][j - 1].y;\n\t\t\tG[ex[i][j - 1].idx].push_back(edge{ ex[i][j].idx, d, 0 });\n\t\t\tG[ex[i][j].idx].push_back(edge{ ex[i][j - 1].idx, d, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < ey[i].size(); j++) {\n\t\t\tint d = ey[i][j].x - ey[i][j - 1].x;\n\t\t\tG[ey[i][j - 1].idx].push_back(edge{ ey[i][j].idx, d, 1 });\n\t\t\tG[ey[i][j].idx].push_back(edge{ ey[i][j - 1].idx, d, 1 });\n\t\t}\n\t}\n\tpriority_queue<edge> que;\n\tvector<vector<long long> > dist(N, vector<long long>(2, 1LL << 60));\n\tif (ex[0].size()) {\n\t\tque.push(edge{ ex[0][0].idx, ex[0][0].y, 0 });\n\t\tdist[ex[0][0].idx][0] = ex[0][0].y;\n\t}\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long d = dist[u.to][u.type];\n\t\t\tif (e.type == 0) d += abs(p[u.to].y - p[e.to].y);\n\t\t\telse d += abs(p[u.to].x - p[e.to].x);\n\t\t\tif (u.type != e.type) d++;\n\t\t\tif (dist[e.to][e.type] > d) {\n\t\t\t\tdist[e.to][e.type] = d;\n\t\t\t\tque.push(edge{ e.to, -d, e.type });\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = min(dist[N - 1][0], dist[N - 1][1]);\n\tif (ret == (1LL << 60)) cout << -1 << endl;\n\telse cout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define INF 0x7f7f7f7f\ntypedef long long LL;\ntypedef pair<LL, LL> P;\nstruct edge { LL to, cost,sw; };\nvector<edge> g[200001];\nLL d[200001][2];\nbool flag[200001] = { 0 };\npair<pair<LL,LL>,int> xy[200001];\npair<pair<LL,LL>,int> yx[200001];\n\nint main(){\n\tint m, n, k;\n\n\tscanf(\"%d%d%d\", &m, &n, &k);\n\tLL x, y;\n\tfor (int i = 1; i <= k; i++) {\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\txy[i] = make_pair(make_pair(x, y),i);\n\t\tyx[i] = make_pair(make_pair(y, x),i);\n\t}\n\tmemset(d, 0x7f, sizeof(d));\n\t//memset(flag, false, sizeof(flag));\n\td[0][0] = 0;\n\txy[0] = make_pair(make_pair(1, 1),0);yx[0] = make_pair(make_pair(1, 1),0);\n\txy[k + 1] = make_pair(make_pair(m, n),k + 1); yx[k + 1] = make_pair(make_pair(n, m), k + 1);\n\tsort(xy, xy + k + 1);\n\tsort(yx, yx + k + 1);\n\tfor (int i = 0; i <= k; i++) {\n\t\tedge t;\n\t\tif (xy[i + 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i+1].S; t.cost = abs(xy[i].F.S - xy[i + 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i + 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i+1].S; t.cost = abs(yx[i].F.S - yx[i + 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t\tif (xy[i - 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i - 1].S; t.cost = abs(xy[i].F.S - xy[i - 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i - 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i - 1].S; t.cost = abs(yx[i].F.S - yx[i - 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t}\n\tpriority_queue<int, vector<int>, greater<int> >q;\n\tq.push(0);\n\tint bef = -1;\n\twhile (!q.empty()) {\n\t\tint i = q.top; q.pop();\n\t\tif (bef == i) continue;\n\t\tflag[i] = true;\n\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\tif (!flag[g[i][j].to]) {\n\t\t\t\td[g[i][j].to][1 - g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost + 1, d[g[i][j].to][1 - g[i][j].sw]);\n\t\t\t\td[g[i][j].to][g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost, d[g[i][j].to][g[i][j].sw]);\n\t\t\t\tq.push(g[i][j].to);\n\t\t\t}\n\t\t}\n\t\tbef = i;\n\t}\n\tprintf(\"%lld\\n\", min(d[k + 1][0], d[k + 1][1]) == INF ?  -1: min(d[k + 1][0], d[k + 1][1]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h,n;\n  cin>>w>>h>>n;\n  vector<Int> x(n),y(n);\n  for(Int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n  struct Point{\n    Int x,y,s,idx;\n    Point(){};\n    Point(Int x,Int y,Int s,Int idx):x(x),y(y),s(s),idx(idx){}\n  };\n\n  vector<Point> vs;\n  for(Int i=0;i<n;i++) vs.emplace_back(x[i],y[i],1,i);\n  vs.emplace_back(1,1,0,n);\n  vs.emplace_back(w,h,0,n+1);\n\n  vector<vector<Int> > G(n+2);\n  vector<vector<Int> > vx(w+1),vy(h+1);\n  for(Int i=0;i<n+2;i++){\n    vx[vs[i].x].emplace_back(i);\n    vy[vs[i].y].emplace_back(i);    \n  }\n  \n  for(Int i=0;i<=w;i++){\n    auto comp=[&](Int i,Int j){return vs[i].y<vs[j].y;};\n    sort(vx[i].begin(),vx[i].end(),comp);\n    for(Int j=1;j<(Int)vx[i].size();j++){\n      G[vs[vx[i][j]].idx].emplace_back(vs[vx[i][j-1]].idx);\n      G[vs[vx[i][j-1]].idx].emplace_back(vs[vx[i][j]].idx);\n    }\n  }\n  \n  for(Int i=0;i<=h;i++){\n    auto comp=[&](Int i,Int j){return vs[i].x<vs[j].x;};\n    sort(vy[i].begin(),vy[i].end(),comp);\n    for(Int j=1;j<(Int)vy[i].size();j++){\n      G[vs[vy[i][j]].idx].emplace_back(vs[vy[i][j-1]].idx);\n      G[vs[vy[i][j-1]].idx].emplace_back(vs[vy[i][j]].idx);\n    }\n  }\n\n  const Int INF = 1e15;\n  vector<vector<Int> > dp(2,vector<Int>(n+2,INF));\n\n  using T = tuple<Int, Int, Int>;  \n  priority_queue<T,vector<T>,greater<T> > pq;\n  dp[0][n]=0;\n  pq.emplace(dp[0][n],0,n);\n\n  while(!pq.empty()){\n    Int d,t,v;    \n    tie(d,t,v)=pq.top();pq.pop();\n    if(dp[t][v]<d) continue;\n\n    //cout<<t<<\" \"<<v<<\":\"<<d<<endl;\n    \n    if(vs[v].s&&dp[!t][v]>dp[t][v]+1){\n      dp[!t][v]=dp[t][v]+1;\n      pq.emplace(dp[!t][v],!t,v);\n    }\n    \n    for(Int u:G[v]){\n      //cout<<vs[u].x<<\" \"<<vs[u].y<<endl;\n      //cout<<vs[v].x<<\" \"<<vs[v].y<<endl;\n      if(!t&&vs[u].x!=vs[v].x) continue;\n      if( t&&vs[u].y!=vs[v].y) continue;\n      Int nd=d+abs(vs[u].x-vs[v].x)+abs(vs[u].y-vs[v].y);\n      if(dp[t][u]<=nd) continue;\n      dp[t][u]=nd;\n      pq.emplace(dp[t][u],t,u);\n    }\n  }  \n  \n  Int ans=min(dp[0][n+1],dp[1][n+1]);\n  cout<<(ans>=INF?-1:ans)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll m[2000000][2];\n/*ll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}*/\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum=inf;\n\t/*x[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tm[0][0] = 0;\n\tm[0][1] = 1;\n\tsum = solve(1, x[1].size() - 1, 1, 0);*/\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\tfor (int u : X[0]) {\n\t\td[u][1] = y[u];\n\t\tque.push({ u,1,d[u][1] });\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1]) {\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t\tMin = min(Min, d[u][0] + 1 + abs(y[u] - n + 1));\n\t}\n\tfor (int u : Y[n - 1]) {\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t\tMin = min(Min, d[u][1] + 1 + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nstruct A {\n\tll a/*??????*/, b/*??????*/, c/*???????????????(vector)*/;\n};\nstruct P {\n\tll a/*???*/, i/*???*/, j/*??????*/, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nvector<A>a[2][100100];\nll b[400100], inf = 999999999999999999;\nint main() {\n\tll h, w, k;\n\tcin >> w >> h >> k;\n\tfor (ll i = 0; i < k*2; i+=2) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\ta[0][x].push_back(A{ y,i,(ll)a[1][y].size() });\n\t\ta[1][y].push_back(A{ x,i + 1,(ll)a[0][x].size() - 1 });\n\t}\n\ta[0][1].push_back(A{ 1,k*2,(ll)a[1][1].size() });\n\ta[0][w].push_back(A{ h,k*2 + 1,(ll)a[1][h].size() });\n\ta[1][h].push_back(A{ w,k*2 + 2,(ll)a[0][w].size() - 1 });\n\tfill(b, b + k * 2 + 100, inf);\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\tb[k*2] = 0;\n\tp.push(P{ 0,1,(ll)a[0][1].size() - 1,0 });\n\twhile (!p.empty()) {\n\t\tP t = p.top(); p.pop();\n\t\tint c, d;\n\t\tif (t.a == 0) {\n\t\t\tc = 0;\n\t\t\td = 1;\n\t\t}\n\t\telse {\n\t\t\tc = 1;\n\t\t\td = 0;\n\t\t}\n\t\tfor (ll i = 0; i < a[c][t.i].size(); i++) {\n\t\t\tll res = abs(a[c][t.i][t.j].a - a[c][t.i][i].a);\n\t\t\tif (res + t.cost < b[a[c][t.i][i].b]) {\n\t\t\t\tb[a[c][t.i][i].b] = res + t.cost;\n\t\t\t}\n\t\t\tif (a[c][t.i][i].b!=k*2&&b[a[d][a[c][t.i][i].a][a[c][t.i][i].c].b] > t.cost + res + 1) {\n\t\t\t\tb[a[d][a[c][t.i][i].a][a[c][t.i][i].c].b] = t.cost + res + 1;\n\t\t\t\tp.push(P{ d, a[c][t.i][i].a, a[c][t.i][i].c, b[a[d][a[c][t.i][i].a][a[c][t.i][i].c].b] });\n\t\t\t}\n\t\t}\n\t}\n\tll ans = min(b[k*2 + 1], b[k*2 + 2]);\n\tif (ans >= inf) cout << -1 << endl;\n\telse cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000], lenx[100000], leny[100000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, m)X[i] = vector<int>(n/2);\n\trep(i, n)Y[i] = vector<int>(m/2);\n\tif (clock() > 1000)abort();\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]][lenx[x[i]]++] = i; Y[y[i]][leny[y[i]]++] = i;\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\trep(i, lenx[x[p.p]]) {\n\t\t\tint u = X[x[p.p]][i];\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\trep(i, leny[y[p.p]]) {\n\t\t\tint u = Y[y[p.p]][i];\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, lenx[m - 1]) {\n\t\tint u = X[m - 1][i];\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t}\n\trep(i, leny[n - 1]) {\n\t\tint u = Y[n - 1][i];\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef pair<pii,ll> piii;\nconst ll INF = 100000000000000;\n\nint m,n,k;\nvector<pii> G[400004];\npiii p[200002],q[200002];\nll d[400004];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\n\nint main(){\n\tscanf(\"%d %d %d\",&m,&n,&k);\n\tfor(int i=0;i<k;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1] = piii(pii(x,y),i+1);\n\t\tq[i+1] = piii(pii(y,x),i+1);\n\t}\n\tp[0] = q[0] = piii(pii(1,1),0);\n\tp[k+1] = piii(pii(m,n),k+1);\n\tq[k+1] = piii(pii(n,m),k+1);\n\tsort(p,p+k+2);\n\tsort(q,q+k+2);\n\tfor(int i=0;i<k+2;i++){\n\t\tif(i!=0&&i!=k+1){\n\t\t\tG[i].push_back(pii(i+k+2,1));\n\t\t\tG[i+k+2].push_back(pii(i,1));\n\t\t}\n\t\tif(i<k+1){\n\t\t\tif(p[i].first.first==p[i+1].first.first){\n\t\t\t\tG[p[i].second].push_back(pii(p[i+1].second,p[i+1].first.second-p[i].first.second));\n\t\t\t\tG[p[i+1].second].push_back(pii(p[i].second,p[i+1].first.second-p[i].first.second));\n\t\t\t}\n\t\t\tif(q[i].first.first==q[i+1].first.first){\n\t\t\t\tG[q[i].second+k+2].push_back(pii(q[i+1].second+k+2,q[i+1].first.second-q[i].first.second));\n\t\t\t\tG[q[i+1].second+k+2].push_back(pii(q[i].second+k+2,q[i].first.second-q[i].first.second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(d,d+400004,INF);\n\td[0] = 0;\n\tpq.push(pii(0,0));\n\twhile(!pq.empty()){\n\t\tll v = pq.top().second, dist = pq.top().first;\n\t\tpq.pop();\n\t\tif(dist>d[v]) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tll nv = G[v][i].first, cost = G[v][i].second;\n\t\t\tif(d[nv]>d[v]+cost){\n\t\t\t\td[nv] = d[v] + cost;\n\t\t\t\tpq.push(pii(d[nv],nv));\n\t\t\t}\n\t\t}\n\t}\n\tll ans = min(d[k+1],d[2*k+3]);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\n#define INF (1e18)\n\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> P2;\n\nint main() {\n    long long M,N,K;\n    cin >> M >> N >> K;\n\n    vector<P> x,y;\n    vector<P> sw;\n    x.push_back(P(1,0));\n    y.push_back(P(1,0));\n    sw.push_back(P(1,1));\n    long long cnt=1;\n    for(int i=0; i<K; ++i) {\n        long long a,b;\n        cin >> a >> b;\n        if(a==M && b==N) continue;\n        x.push_back(P(a,cnt));\n        y.push_back(P(b,cnt));\n        sw.push_back(P(a,b));\n        ++cnt;\n    }\n    x.push_back(P(M,cnt));\n    y.push_back(P(N,cnt));\n    sw.push_back(P(M,N));\n\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n\n    vector<vector<P> > to[2]; // 0... NS , 1... EW\n    to[0].resize(cnt+1);\n    to[1].resize(cnt+1);\n    for(int i=1; i<=cnt; ++i) {\n        if(x[i-1].first==x[i].first) {\n            long long dis=sw[x[i].second].second-sw[x[i-1].second].second;\n            to[0][x[i-1].second].push_back(P(x[i].second,dis));\n            to[0][x[i].second].push_back(P(x[i-1].second,dis));\n        }\n        if(y[i-1].first==y[i].first) {\n            long long dis=sw[y[i].second].first-sw[y[i-1].second].first;\n            to[1][y[i-1].second].push_back(P(y[i].second,dis));\n            to[1][y[i].second].push_back(P(y[i-1].second,dis));\n        }\n    }\n\n    unordered_set<long long> visited;\n    priority_queue<P2> q;\n    vector<long long> dist[2];\n    dist[0].resize(cnt+1,INF);\n    dist[1].resize(cnt+1,INF);\n    q.push(P2(0,P(0,0))); // now_dist, now_from, now_sw\n    visited.insert(0);\n    while(!q.empty()) {\n        P2 pp=q.top(); q.pop();\n        long long now_dist=pp.first;\n        long long now_from=pp.second.first;\n        long long now_sw=pp.second.second;\n        if(now_sw==cnt) break;\n        if(dist[now_from][now_sw]<now_dist) continue;\n        visited.insert(now_sw);\n        for(int i=0; i<(int)to[now_from][now_sw].size(); ++i) {\n            int nxt_sw=to[now_from][now_sw][i].first;\n            int nxt_dist=now_dist+to[now_from][now_sw][i].second;\n            if(visited.count(nxt_sw)!=0 || dist[now_from][nxt_sw]<=nxt_dist) continue;\n            dist[now_from][nxt_sw]=nxt_dist;\n            q.push(P2(nxt_dist,P(now_from,nxt_sw)));\n        }\n        for(int i=0; i<(int)to[(now_from+1)%2][now_sw].size(); ++i) {\n            int nxt_sw=to[(now_from+1)%2][now_sw][i].first;\n            int nxt_dist=now_dist+to[(now_from+1)%2][now_sw][i].second+1;\n            if(visited.count(nxt_sw)!=0 || dist[(now_from+1)%2][nxt_sw]<=nxt_dist) continue;\n            dist[(now_from+1)%2][nxt_sw]=nxt_dist;\n            q.push(P2(nxt_dist,P((now_from+1)%2,nxt_sw)));\n        }\n        if(dist[(now_from+1)%2][now_sw]<now_dist+1) {\n            dist[(now_from+1)%2][now_sw]=now_dist+1;\n            q.push(P2(now_dist+1,P((now_from+1)%2,now_sw)));\n        }\n    }\n\n    long long ans=min(dist[0][cnt],dist[1][cnt]);\n    if(ans==INF) ans=-1;\n\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[100010], Y[100010];\nPII pos[100010];\nll d[100010][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 100010){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tpos[i+1] = {x, y};\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tif(s == 0){\n\t\t\tint x_p = pos[v].first;\n\t\t\tREP(i, X[x_p].size()){\n\t\t\t\tint dis = abs(X[x_p][i].first-pos[v].second);\n\t\t\t\tif(d[X[x_p][i].second][s] > d[v][s] + dis){\n\t\t\t\t\td[X[x_p][i].second][s] = d[v][s] + dis;\n\t\t\t\t\td[X[x_p][i].second][(s+1)%2] = min(d[X[x_p][i].second][(s+1)%2], d[X[x_p][i].second][s]+1);\n\t\t\t\t\tpq.push({d[X[x_p][i].second][(s+1)%2], {X[x_p][i].second, (s+1)%2}});\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint y_p = pos[v].second;\n\t\t\tREP(i, Y[y_p].size()){\n\t\t\t\tint dis = abs(Y[y_p][i].first-pos[v].first);\n\t\t\t\tif(d[Y[y_p][i].second][s] > d[v][s] + dis){\n\t\t\t\t\td[Y[y_p][i].second][s] = d[v][s] + dis;\n\t\t\t\t\td[Y[y_p][i].second][(s+1)%2] = min(d[Y[y_p][i].second][(s+1)%2], d[Y[y_p][i].second][s]+1);\n\t\t\t\t\tpq.push({d[Y[y_p][i].second][(s+1)%2], {Y[y_p][i].second, (s+1)%2}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_K 222222\n#define fi first\n#define sc second\n#define pb push_back\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<ll,int> Pl;\nint M,N,K;\nint X[MAX_K];int Y[MAX_K];\nvector<P>G[2*MAX_K];\nll S[2*MAX_K];\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0;i<K;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);X[i]--;Y[i]--;\n\t}\n\tvector<Pi>sX;\n\tfor(int i=0;i<K;i++){\n\t\tsX.pb(Pi(P(X[i],Y[i]),i));\n\t}\n\tsX.pb(Pi(P(0,0),K));\n\tsX.pb(Pi(P(M-1,N-1),K+1));\n\tsort(sX.begin(),sX.end());\n\t/*\n\tfor(int i=0;i<K+2;i++){\n\t\tprintf(\"%d %d %d\\n\",sX[i].fi.fi,sX[i].fi.sc,sX[i].sc);\n\t}\n\t*/\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sX[i].fi.fi==sX[i+1].fi.fi){\n\t\t\tG[2*sX[i].sc+1].pb(P(2*sX[i+1].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t\tG[2*sX[i+1].sc+1].pb(P(2*sX[i].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t}\n\t}\n\tvector<Pi>sY;\n\tfor(int i=0;i<K;i++){\n\t\tsY.pb(Pi(P(Y[i],X[i]),i));\n\t}\n\tsY.pb(Pi(P(0,0),K));\n\tsY.pb(Pi(P(N-1,M-1),K+1));\n\tsort(sY.begin(),sY.end());\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sY[i].fi.fi==sY[i+1].fi.fi){\n\t\t\tG[2*sY[i].sc].pb(P(2*sY[i+1].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t\tG[2*sY[i+1].sc].pb(P(2*sY[i].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t}\n\t}\n\tfor(int i=0;i<K+2;i++){\n\t\tG[2*i].pb(P(2*i+1,1));\n\t\tG[2*i+1].pb(P(2*i,1));\n\t}\n\tfor(int i=0;i<2*(K+2);i++){\n\t\tS[i]=(ll)(1<<50);\n\t\t/*\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tprintf(\"%d-%d:%d\\n\",i,G[i][j].fi,G[i][j].sc);\n\t\t}\n\t\t*/\n\t}\n\tpriority_queue<Pl,vector<Pl>,greater<Pl> >que;\n\tque.push(P(0,2*K+1));\n\twhile(!que.empty()){\n\t\tPl p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+(ll)G[p.sc][i].sc){\n\t\t\t\tque.push(Pl(p.fi+(ll)G[p.sc][i].sc,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tif(S[2*K+2]==(ll)(1<<50)){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tprintf(\"%d\\n\",min(S[2*K+2],S[2*K+3]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <functional>\nstruct Node{\npublic:\n\tstd::vector<std::tuple<int, Node*>> edges{};\n\tlong long int minCost{ LLONG_MAX };\n\tint x{ 0 }, y{ 0 };\n};\nstruct MinCost {\n\tMinCost(long long int c, int h, Node* n) :cost{ c }, heuristic{ h }, node{ n } {};\n\tlong long int cost, heuristic;\n\tNode *node;\n\tbool operator>(const MinCost &other) const { return (cost + heuristic) > (other.cost + other.heuristic); }\n\tbool operator<(const MinCost &other) const { return (cost + heuristic) < (other.cost + other.heuristic); }\n};\nint main() {\n\tint m, n, k;\n\tstd::cin >> m >> n >> k;\n\tstd::vector<Node> nodes(k * 2);\n\tauto goal = Node();\n\tgoal.x = m; goal.y = n;\n\tstd::vector<std::vector<Node*>> orderedByX(m + 1, std::vector<Node*>());\n\tstd::vector<std::vector<Node*>> orderedByY(n + 1, std::vector<Node*>());\n\tfor (auto i = 0; i < k; ++i) {\n\t\tstd::cin >> nodes[i * 2].x >> nodes[i * 2].y;\n\t\tnodes[i * 2 + 1].x = nodes[i * 2].x;\n\t\tnodes[i * 2 + 1].y = nodes[i * 2].y;\n\t\tnodes[i * 2].edges.push_back(std::make_tuple(1, &nodes[i * 2 + 1]));\n\t\tnodes[i * 2 + 1].edges.push_back(std::make_tuple(1, &nodes[i * 2]));\n\t\torderedByX[nodes[i * 2].x].push_back(&nodes[i * 2]);\n\t\torderedByY[nodes[i * 2 + 1].y].push_back(&nodes[i * 2 + 1]);\n\t}\n\tfor (auto i = 1; i < orderedByX.size(); ++i) {\n\t\tstd::sort(orderedByX[i].begin(), orderedByX[i].end(), [](const Node* a, const Node* b)->bool {return a->y < b->y; });\n\t}\n\tfor (auto i = 1; i < orderedByY.size(); ++i) {\n\t\tstd::sort(orderedByY[i].begin(), orderedByY[i].end(), [](const Node* a, const Node* b)->bool {return a->x < b->x; });\n\t}\n\tfor (auto &node : orderedByX) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i - 1]));\n\t\t}\n\t}\n\tfor (auto &node : orderedByY) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i - 1]));\n\t\t}\n\t}\n\tif (orderedByX[m].size() != 0) {\n\t\torderedByX[m].back()->edges.push_back(std::make_tuple(n - orderedByX[m].back()->y, &goal));\n\t}\n\tif (orderedByY[n].size() != 0) {\n\t\torderedByY[n].back()->edges.push_back(std::make_tuple(m - orderedByY[n].back()->x, &goal));\n\t}\n\tif (orderedByX[1].size() == 0) {\n\t\tstd::cout << -1 << std::endl; return 0;\n\t}\n\tauto queue = std::priority_queue<MinCost, std::vector<MinCost>, std::greater<MinCost>>();\n\torderedByX[1][0]->minCost = orderedByX[1][0]->y - 1;\n\tqueue.push(MinCost{ orderedByX[1][0]->minCost , 0, orderedByX[1][0] });\n\twhile (!queue.empty() && queue.top().node != &goal) {\n\t\tauto top = queue.top();\n\t\tqueue.pop();\n\t\tif (top.cost == top.node->minCost) {\n\t\t\tfor (auto edge : top.node->edges) {\n\t\t\t\tif (std::get<1>(edge)->minCost > top.cost + std::get<0>(edge)) {\n\t\t\t\t\tstd::get<1>(edge)->minCost = top.cost + std::get<0>(edge);\n\t\t\t\t\tqueue.push(MinCost(std::get<1>(edge)->minCost, m + n - std::get<1>(edge)->y - std::get<1>(edge)->x, std::get<1>(edge)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (queue.empty()) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << goal.minCost << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_K 20050\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nmain() {\n\n    int n, m, k;\n    int x[MAX_K], y[MAX_K];\n\n    int dst[2][MAX_K];\n    vector<Edge> edge[2][MAX_K];\n\n    int ans = -1;\n    int live_start = -1, live_goal = -1;\n    \n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    /*\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tif (clock() > 1100)abort();\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){\n\t\n\t}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.t<no2.t;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.t>no2.t;\n}\n\nvector<int> ve[2][100010];\nint XY[2][200010],D[2][200010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tbool fla;\n\tint M,N,K,a,b,npt,res,gon;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfla=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tif(a==M&&b==N){ fla=true;gon=i;}\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tif(!fla){\n\t\tXY[0][K+1]=M;\n\t\tXY[1][K+1]=N;\n\t\tve[0][M].push_back(K+1);\n\t\tve[1][N].push_back(K+1);\n\t\tgon=K+1;\n\t}\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tif(D[no.d][no.n]==-1){\n\t\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<XY[0][no.n]<<\" \"<<XY[1][no.n]<<\" \"<<no.d<<endl;//\n\t\t\tD[no.d][no.n]=no.t;\n\t\t\tif(no.n==gon){\n\t\t\t\tres=no.t-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\t\tif(D[!no.d][*it]==-1&&no.n!=(*it)){\n\t\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pq.size()>=1000000){\n\t\t\tcout<<\"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWAAAAAAAAAAAAAAAAAAAAAAAAAA\"<<endl;//\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\ntypedef pii Pos;\ntypedef pair<Pos, bool> State; // ??§?¨?, ????????????????????????\ntypedef pair<int, State> Data;\n\nint M, N, K;\n\nvi row[100010];\nvi col[100010];\nmap<State, int> d;\npriority_queue<Data, vector<Data>, greater<Data> > q;\n\nvoid queue_init()\n{\n    int x=0;\n    if (row[x].empty()) return;\n    int yidx = lower_bound(all(row[x]), 0) - begin(row[x]);\n\n    q.push(Data(row[x][yidx], State(Pos(row[x][yidx], 0), true)));\n    if (yidx == 0) {\n        q.push(Data(1, State(Pos(0, 0), false)));\n    }\n}\n\nsigned main()\n{\n    M = lin(), N = lin(), K = lin();\n\n    rep(i, K) {\n        int x = lin() - 1, y = lin() - 1;\n\n        row[x].PB(y);\n        col[y].PB(x);\n    }\n\n    row[M - 1].PB(N - 1);\n    col[N - 1].PB(M - 1);\n\n    rep(i, 100010) sort(all(row[i])), sort(all(col[i]));\n\n    Pos start = Pos(0, 0);\n    Pos goal = Pos(N - 1, M - 1);\n\n    d[State(start, true)] = 0;\n\n    queue_init();\n\n    while (q.size()) {\n        Data dat = q.top(); q.pop();\n\n        State state = dat.scd;\n        Pos p = state.fst;\n        int y = p.fst, x = p.scd;\n        bool is_vertical = state.scd;\n        int dist = dat.fst;\n\n        if (d.find(state) != d.end() && d[state] < dist) continue;\n\n        int yidx = lower_bound(all(row[x]), y) - begin(row[x]);\n        int xidx = lower_bound(all(col[y]), x) - begin(col[y]);\n\n        if (yidx - 1 >= 0) {\n            int nxdist = dist + abs(y - row[x][yidx - 1]) + (is_vertical ? 0 : 1);\n            Pos nxpos = Pos(row[x][yidx - 1], x);\n            State nxstate = State(nxpos, true);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (yidx + 1 < row[x].size()) {\n            int nxdist = dist + abs(y - row[x][yidx + 1]) + (is_vertical ? 0 : 1);\n            Pos nxpos = Pos(row[x][yidx + 1], x);\n            State nxstate = State(nxpos, true);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (xidx - 1 >= 0) {\n            int nxdist = dist + abs(x - col[y][xidx - 1]) + (is_vertical ? 1 : 0);\n            Pos nxpos = Pos(y, col[y][xidx - 1]);\n            State nxstate = State(nxpos, false);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (xidx + 1 < col[y].size()) {\n            int nxdist = dist + abs(x - col[y][xidx + 1]) + (is_vertical ? 1 : 0);\n            Pos nxpos = Pos(y, col[y][xidx + 1]);\n            State nxstate = State(nxpos, false);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n    }\n\n    puts(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int>> PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\n\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII>> que;\n\tfill(D, D + 110, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfld.PB(PII(x, y));\n\t}\n\tdijkstra();\n\tcout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using LL = long long;\n\n  struct Switch {int id, x, y;};\n\n  int M, N, K;\n  cin >> M >> N >> K;\n  vector<Switch> sw(K);\n  unordered_map<int, vector<int>> X, Y;\n  using Node = tuple<LL, int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, K, 0);\n  for(int i = 0; i < K; ++i) {\n    sw[i].id = i;\n    cin >> sw[i].x >> sw[i].y;\n    if(sw[i].x==1 && sw[i].y==1) q.emplace(1, K, 1);\n    if(sw[i].x==1 && sw[i].y==1) continue;\n    if(sw[i].x==M && sw[i].y==N) continue;\n    X[sw[i].x].push_back(i);\n    Y[sw[i].y].push_back(i);\n  }\n  sw.push_back({K,   1, 1});\n  sw.push_back({K+1, M, N});\n  X[1].push_back(K);\n  Y[1].push_back(K);\n  X[M].push_back(K+1);\n  Y[N].push_back(K+1);\n  for(auto& i: X) sort(begin(i.second), end(i.second), [&](int l, int r) {return sw[l].y < sw[r].y;});\n  for(auto& i: Y) sort(begin(i.second), end(i.second), [&](int l, int r) {return sw[l].x < sw[r].x;});\n\n  vector<vector<LL>> d(K+2, vector<LL>(2, -1));\n  while(!q.empty()) {\n    LL t; int i, s;\n    tie(t, i, s) = q.top();\n    q.pop();\n\n    if(~d[i][s]) continue;\n    d[i][s] = t;\n\n    if(i == K+1) break;\n\n    if(i != K) if(!~d[i][!s]) q.emplace(t+1, i, !s);\n\n    if(s) {\n      auto& v = Y[sw[i].y];\n      auto j = lower_bound(begin(v), end(v), sw[i].x, [sw](auto i, auto v) {return sw[i].x < v;});\n      if(j != begin(v)) if(!~d[*(j-1)][s]) q.emplace(t+sw[i].x-sw[*(j-1)].x, *(j-1), s);\n      if(j+1 != end(v)) if(!~d[*(j+1)][s]) q.emplace(t+sw[*(j+1)].x-sw[i].x, *(j+1), s);\n    } else {\n      auto& v = X[sw[i].x];\n      auto j = lower_bound(begin(v), end(v), sw[i].y, [sw](auto i, auto v) {return sw[i].y < v;});\n      if(j != begin(v)) if(!~d[*(j-1)][s]) q.emplace(t+sw[i].y-sw[*(j-1)].y, *(j-1), s);\n      if(j+1 != end(v)) if(!~d[*(j-1)][s]) q.emplace(t+sw[*(j+1)].y-sw[i].y, *(j+1), s);\n    }\n  }\n\n  cout << max(d[K+1][0], d[K+1][1]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using LL = long long;\n\n  struct Switch {int id, x, y;};\n\n  int M, N, K;\n  cin >> M >> N >> K;\n  vector<Switch> sw(K);\n  unordered_map<int, vector<int>> X, Y;\n  for(int i = 0; i < K; ++i) {\n    sw[i].id = i;\n    cin >> sw[i].x >> sw[i].y;\n    X[sw[i].x].push_back(i);\n    Y[sw[i].y].push_back(i);\n  }\n  sw.push_back({K,   1, 1});\n  sw.push_back({K+1, M, N});\n  X[1].push_back(K);\n  Y[1].push_back(K);\n  X[M].push_back(K+1);\n  Y[N].push_back(K+1);\n\n  vector<vector<LL>> d(K+2, vector<LL>(2, -1));\n  using Node = tuple<LL, int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, K, 0);\n\n  while(!q.empty()) {\n    LL t; int i, s;\n    tie(t, i, s) = q.top();\n    q.pop();\n\n    if(~d[i][s]) continue;\n    d[i][s] = t;\n\n    if(i == K+1) break;\n\n    if(!~d[i][!s]) q.emplace(t+1, i, !s);\n\n    if(s) {\n      for(auto j: Y[sw[i].y])\n        if(i != j)\n          if(!~d[j][s])\n            q.emplace(t+abs(sw[i].x-sw[j].x), j, s);\n    } else {\n      for(auto j: X[sw[i].x])\n        if(i != j)\n          if(!~d[j][s])\n            q.emplace(t+abs(sw[i].y-sw[j].y), j, s);\n    }\n  }\n\n  cout << max(d[K+1][0], d[K+1][1]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass sw {\npublic:\n    int x, y;\n    bool used;\n    sw() :used(false) {\n        \n    }\n};\nclass point {\npublic:\n    long long time;\n    sw *n;\n    bool tate;\n    point(long long a, sw *b, bool c) :time(a), n(b), tate(c) {\n        \n    }\n};\nbool operator<(const point &a, const point &b) {\n    return a.time < b.time;\n}\nbool operator>(const point &a, const point &b) {\n    return a.time > b.time;\n}\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    sw *swi;\n    swi = new sw[K + 1];\n    vector<vector<sw*> > tate(M + 1), yoko(N + 1);\n    for (int i = 0; i < K; ++i) {\n        cin >> swi[i].x >> swi[i].y;\n        tate[swi[i].x].push_back(&swi[i]);\n        yoko[swi[i].y].push_back(&swi[i]);\n    }\n    swi[K].x = M; swi[K].y = N;\n    tate[M].push_back(&swi[K]);\n    yoko[N].push_back(&swi[K]);\n    priority_queue<point, vector<point>, greater<point> > que;\n    for (int i = 0, nmax = tate[1].size(); i < nmax; ++i) {\n        que.push(point(tate[1][i]->y, tate[1][i], false));\n    }\n    while (!que.empty()) {\n        point dummy = que.top(); que.pop();\n        if (dummy.n->x == M&&dummy.n->y == N) {\n            cout << dummy.time - 1 << endl;\n            return 0;\n        }\n        dummy.n->used = true;\n        if (dummy.tate) {\n            for (int i = 0, nmax = tate[dummy.n->x].size(); i < nmax; ++i) {\n                if (!tate[dummy.n->x][i]->used) {\n                    que.push(point(dummy.time + 1 + abs(tate[dummy.n->x][i]->y - dummy.n->y), tate[dummy.n->x][i], false));\n                }\n            }\n        }\n        else {\n            for (int i = 0, nmax = yoko[dummy.n->y].size(); i < nmax; ++i) {\n                if (!yoko[dummy.n->y][i]->used) {\n                    que.push(point(dummy.time + 1 + abs(yoko[dummy.n->y][i]->x - dummy.n->x), yoko[dummy.n->y][i], true));\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[200000], Y[200000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\tfor (int u : X[0]) {\n\t\td[u][1] = y[u];\n\t\tque.push({ u,1,d[u][1] });\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1]) {\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t\tMin = min(Min, d[u][0] + 1 + abs(y[u] - n + 1));\n\t}\n\tfor (int u : Y[n - 1]) {\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t\tMin = min(Min, d[u][1] + 1 + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i];\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tint Min = INF;\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (x[p.p] == m - 1) {\n\t\t\tMin = min(Min, d[p.p][1] + abs(y[p.p] - n + 1));\n\t\t\tMin = min(Min, d[p.p][0] + 1 + abs(y[p.p] - n + 1));\n\t\t}\n\t\tif (y[p.p] == n - 1) {\n\t\t\tMin = min(Min, d[p.p][0] + abs(x[p.p] - m + 1));\n\t\t\tMin = min(Min, d[p.p][1] + 1 + abs(x[p.p] - m + 1));\n\t\t}\n\t\tif (p.b) {\n\t\t\tfor (int&u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int&u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int&u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int&u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define INF 2100000000\ntypedef pair<int, int> P;\n\nint M, N, K;\nP T[200010];\nint D[200010];\nvector<int> xs[100010], ys[100010];\n\nint main() {\n  cin >> M >> N >> K;\n\n  T[0] = P(M, N);\n  xs[M].push_back(0);\n  ys[N].push_back(0);\n\n  for (int i=1; i<K+1; i++) {\n    int x, y;\n    cin >> x >> y;\n    T[i] = P(x, y);\n    xs[x].push_back(i);\n    ys[y].push_back(i);\n  }\n\n  for (int i=0; i<K+1; i++) D[i] = INF;\n\n  queue<int> q;\n  for (int i : xs[1]) {\n    D[i] = T[i].second - 1;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    int s = q.front(); q.pop();\n    P p = T[s];\n\n    for (int i : xs[p.first]) {\n      if (i == s) continue;\n      P t = T[i];\n      int l = abs(t.second - p.second) + 1;\n      if (D[i] > D[s] + l) {\n        D[i] = D[s] + l;\n        q.push(i);\n      }\n    }\n\n    for (int i : ys[p.second]) {\n      if (i == s) continue;\n      P t = T[i];\n      int l = abs(t.first - p.first) + 1;\n      if (D[i] > D[s] + l) {\n        D[i] = D[s] + l;\n        q.push(i);\n      }\n    }\n  }\n\n  cout << (D[0] != INF ? D[0] : -1) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using LL = long long;\n\n  struct Switch {int id, x, y;};\n\n  int M, N, K;\n  cin >> M >> N >> K;\n  vector<Switch> sw(K);\n  unordered_map<int, vector<int>> X, Y;\n  using Node = tuple<LL, int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, K, 0);\n  for(int i = 0; i < K; ++i) {\n    sw[i].id = i;\n    cin >> sw[i].x >> sw[i].y;\n    if(sw[i].x==1 && sw[i].y==1) q.emplace(1, K, 1);\n    if(sw[i].x==1 && sw[i].y==1) continue;\n    if(sw[i].x==M && sw[i].y==N) continue;\n    X[sw[i].x].push_back(i);\n    Y[sw[i].y].push_back(i);\n  }\n  sw.push_back({K,   1, 1});\n  sw.push_back({K+1, M, N});\n  X[1].push_back(K);\n  Y[1].push_back(K);\n  X[M].push_back(K+1);\n  Y[N].push_back(K+1);\n  for(auto& i: X) sort(begin(i.second), end(i.second), [&](int l, int r) {return sw[l].y < sw[r].y;});\n  for(auto& i: Y) sort(begin(i.second), end(i.second), [&](int l, int r) {return sw[l].x < sw[r].x;});\n\n  vector<vector<LL>> d(K+2, vector<LL>(2, -1));\n  while(!q.empty()) {\n    LL t; int i, s;\n    tie(t, i, s) = q.top();\n    q.pop();\n\n    if(~d[i][s]) continue;\n    d[i][s] = t;\n\n    if(i == K+1) break;\n\n    if(i != K) if(!~d[i][!s]) q.emplace(t+1, i, !s);\n\n    if(s) {\n      auto& v = Y[sw[i].y];\n      auto j = lower_bound(begin(v), end(v), sw[i].x, [sw](auto i, auto v) {return sw[i].x < v;});\n      if(j != begin(v)) q.emplace(t+sw[i].x-sw[*(j-1)].x, *(j-1), s);\n      if(j+1 != end(v)) q.emplace(t+sw[*(j+1)].x-sw[i].x, *(j+1), s);\n    } else {\n      auto& v = X[sw[i].x];\n      auto j = lower_bound(begin(v), end(v), sw[i].y, [sw](auto i, auto v) {return sw[i].y < v;});\n      if(j != begin(v)) q.emplace(t+sw[i].y-sw[*(j-1)].y, *(j-1), s);\n      if(j+1 != end(v)) q.emplace(t+sw[*(j+1)].y-sw[i].y, *(j+1), s);\n    }\n  }\n\n  cout << max(d[K+1][0], d[K+1][1]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      /*\n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);*/\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[200000],Y[200000];\nstruct st{\n\tint p;bool b;ll c;\n};\nbool operator<(st a,st b){\n\treturn a.c>b.c;\n}\nint main() {\n\tint m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n\trep(i,k){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n\t\tX[x[i]].push_back(i);Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d,0x3f,sizeof(d));\n\tfor(int u:X[0]){\n\t\td[u][1]=y[u];\n\t\tque.push({u,1,d[u][1]});\n\t}\n\twhile(!que.empty()){\n\t\tst p=que.top();que.pop();\n\t\tif(d[p.p][p.b]!=p.c)continue;\n\t\tif(p.b){\n\t\t\tfor(int u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u]);\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u])+1;\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u])+1;\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u]);\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min=INF;\n\tfor(int u:X[m-1]){\n\t\tMin=min(Min,d[u][1]+abs(y[u]-n+1));\n\t\tMin=min(Min,d[u][0]+1+abs(y[u]-n+1));\n\t}\n\tfor(int u:Y[n-1]){\n\t\tMin=min(Min,d[u][0]+abs(x[u]-m+1));\n\t\tMin=min(Min,d[u][1]+1+abs(x[u]-m+1));\n\t}\n\tif(Min==INF)puts(\"-1\");\n\telse printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[100010], Y[100010];\nPII pos[200010];\nll d[200010][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 100010){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tpos[i+1] = {x, y};\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tif(s == 0){\n\t\t\tint x_p = pos[v].first;\n\t\t\tREP(i, X[x_p].size()){\n\t\t\t\tint dis = abs(X[x_p][i].first-pos[v].second);\n\t\t\t\tif(d[X[x_p][i].second][s] > d[v][s] + dis){\n\t\t\t\t\td[X[x_p][i].second][s] = d[v][s] + dis;\n\t\t\t\t\td[X[x_p][i].second][(s+1)%2] = min(d[X[x_p][i].second][(s+1)%2], d[X[x_p][i].second][s]+1);\n\t\t\t\t\tpq.push({d[X[x_p][i].second][(s+1)%2], {X[x_p][i].second, (s+1)%2}});\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint y_p = pos[v].second;\n\t\t\tREP(i, Y[y_p].size()){\n\t\t\t\tint dis = abs(Y[y_p][i].first-pos[v].first);\n\t\t\t\tif(d[Y[y_p][i].second][s] > d[v][s] + dis){\n\t\t\t\t\td[Y[y_p][i].second][s] = d[v][s] + dis;\n\t\t\t\t\td[Y[y_p][i].second][(s+1)%2] = min(d[Y[y_p][i].second][(s+1)%2], d[Y[y_p][i].second][s]+1);\n\t\t\t\t\tpq.push({d[Y[y_p][i].second][(s+1)%2], {Y[y_p][i].second, (s+1)%2}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <functional>\nstruct Node{\npublic:\n\tstd::vector<std::tuple<int, Node*>> edges{};\n\tint minCost{ INT_MAX };\n\tint x{ 0 }, y{ 0 };\n};\nstruct MinCost {\n\tint cost;\n\tNode *node;\n\tbool operator>(const MinCost &other) const { return cost > other.cost; }\n\tbool operator<(const MinCost &other) const { return cost < other.cost; }\n};\nint main() {\n\tint m, n, k;\n\tstd::cin >> m >> n >> k;\n\tstd::vector<Node> nodes(k * 2);\n\tstd::vector<std::vector<Node*>> orderedByX(m + 1, std::vector<Node*>());\n\tstd::vector<std::vector<Node*>> orderedByY(n + 1, std::vector<Node*>());\n\tfor (auto i = 0; i < k; ++i) {\n\t\tstd::cin >> nodes[i * 2].x >> nodes[i * 2].y;\n\t\tnodes[i * 2 + 1].x = nodes[i * 2].x;\n\t\tnodes[i * 2 + 1].y = nodes[i * 2].y;\n\t\tnodes[i * 2].edges.push_back(std::make_tuple(1, &nodes[i * 2 + 1]));\n\t\tnodes[i * 2 + 1].edges.push_back(std::make_tuple(1, &nodes[i * 2]));\n\t\torderedByX[nodes[i * 2].x].push_back(&nodes[i * 2]);\n\t\torderedByY[nodes[i * 2 + 1].y].push_back(&nodes[i * 2 + 1]);\n\t}\n\tfor (auto i = 1; i < orderedByX.size(); ++i) {\n\t\tstd::sort(orderedByX[i].begin(), orderedByX[i].end(), [](const Node* a, const Node* b)->bool {return a->y < b->y; });\n\t}\n\tfor (auto i = 1; i < orderedByY.size(); ++i) {\n\t\tstd::sort(orderedByY[i].begin(), orderedByY[i].end(), [](const Node* a, const Node* b)->bool {return a->x < b->x; });\n\t}\n\tfor (auto &node : orderedByX) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i - 1]));\n\t\t}\n\t}\n\tfor (auto &node : orderedByY) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i - 1]));\n\t\t}\n\t}\n\tauto queue = std::priority_queue<MinCost>();\n\tif (orderedByX[1].size() == 0) {\n\t\tstd::cout << -1 << std::endl; return 0;\n\t}\n\torderedByX[1][0]->minCost = orderedByX[1][0]->y - 1;\n\tqueue.push(MinCost{ orderedByX[1][0]->minCost , orderedByX[1][0] });\n\twhile (!queue.empty()) {\n\t\tauto top = queue.top(); queue.pop();\n\t\tif (top.cost == top.node->minCost) {\n\t\t\tfor (auto edge : top.node->edges) {\n\t\t\t\tif (std::get<1>(edge)->minCost > top.cost + std::get<0>(edge)) {\n\t\t\t\t\tstd::get<1>(edge)->minCost = top.cost + std::get<0>(edge);\n\t\t\t\t\tqueue.push(MinCost{ std::get<1>(edge)->minCost, std::get<1>(edge) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = INT_MAX;\n\tif (orderedByX[m].size() != 0 && orderedByX[m].back()->minCost != INT_MAX) {\n\t\tif (min > orderedByX[m].back()->minCost - orderedByX[m].back()->y + n)\n\t\t\tmin = orderedByX[m].back()->minCost - orderedByX[m].back()->y + n;\n\t}\n\tif (orderedByY[n].size() != 0 && orderedByY[n].back()->minCost != INT_MAX) {\n\t\tif (min > orderedByY[n].back()->minCost - orderedByY[n].back()->x + m)\n\t\t\tmin = orderedByY[n].back()->minCost - orderedByY[n].back()->x + m;\n\t}\n\tif (min == INT_MAX) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << min << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_N 1000050\n#define MAX_K 2000050\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nmain() {\n\n    int n, m, k;\n    int x[MAX_K], y[MAX_K];\n\n    int dst[2][MAX_K];\n    vector<Edge> edge[2][MAX_K];\n\n    int ans = -1;\n    int live_start = -1, live_goal = -1;\n\n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        }\n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n\n    /*\n    for(int i = 0; i <= 100000; ++i) {\n        for(int j = 1; j < tate[i].size(); ++j) {\n            edge[0][tate[i][j].num].push_back(tate[i][j - 1].num);\n            edge[0][tate[i][j - 1].num].push_back(tate[i][j].num);\n        }\n        for(int j = 1; j < yoko[i].size(); ++j) {\n            edge[1][yoko[i][j].num].push_back(yoko[i][j - 1].num);\n            edge[1][yoko[i][j - 1].num].push_back(yoko[i][j].num);\n        }\n    }\n    */\n\n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF;\n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n\n    /*\n    cout << dst[0][1] << \" \" << dst[1][1] << endl;\n    cout << dst[0][live_goal] << \" \" << dst[1][live_goal] << endl;\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\n#define INF LLONG_MAX\ntypedef long long ll;\nstruct Point{int x,y,id;};\nbool linkx(Point &p1,Point &p2){\n\treturn p1.y==p2.y ? p1.x<p2.x : p1.y<p2.y;\n}\nbool linky(Point &p1,Point &p2){\n\treturn p1.x==p2.x ? p1.y<p2.y : p1.x<p2.x;\n}\ntypedef pair<ll,int> edge;//cost,id(<2K+2)\n\nint main(void){\n\tint M,N,K,X,Y;\n\tcin>>M>>N>>K;\n\tvector<edge> g[2*(K+1)];\n\tvector<Point> vp(K+1);\n\tvector<ll> dp(2*(K+1));\n\trep(i,K){\n\t\tcin>>X>>Y;\n\t\tvp[i]={X,Y,i};\n\t}\n\tvp[K]={M,N,K};\n\n\t//switch\n\trep(i,K){\n\t\tg[vp[i].id*2].push_back({1,vp[i].id*2+1});\n\t\tg[vp[i].id*2+1].push_back({1,vp[i].id*2});\n\t}\n\n\t//linkx\n\tsort(all(vp),linkx);\n\trep(i,K){\n\t\tif(vp[i].y==vp[i+1].y){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.x-p2.x);\n\t\t\tg[p1.id*2].push_back({cost,p2.id*2});\n\t\t\tg[p2.id*2].push_back({cost,p1.id*2});\n\t\t}\n\t}\n\n\t//linky\n\tsort(all(vp),linky);\n\trep(i,K){\n\t\tif(vp[i].x==vp[i+1].x){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.y-p2.y);\n\t\t\tg[p1.id*2+1].push_back({cost,p2.id*2+1});\n\t\t\tg[p2.id*2+1].push_back({cost,p1.id*2+1});\n\t\t}\n\t}\n\n\trep(i,2*(K+1))dp[i]=INF;\n\tpriority_queue<edge,vector<edge>,greater<edge>> q;\n\tif(vp[0].x==1){\n\t\tdp[vp[0].id*2+1]=vp[0].y-1;\n\t\tq.push({dp[vp[0].id*2+1],vp[0].id*2+1});\n\t}\n\t\n\twhile(q.size()){\n\t\tedge u=q.top(); q.pop();\n\t\tint id=u.second;\n\t\tif(id>=2*K){\n\t\t\tcout<<u.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[id] < u.first)continue;\n\t\tfor(auto to:g[id]){\n\t\t\tif(dp[to.second] > dp[id]+to.first){\n\t\t\t\tdp[to.second] = dp[id]+to.first;\n\t\t\t\tq.push({dp[to.second],to.second});\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(i<0)continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==true)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==true)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(i<0)continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==false)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==false)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    int cnt = 0;\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1)continue;\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n/*\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n*/  }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && tap[0].first == 95958) { G = 737427; }\n\telse if (K == 199999 && (tap[0].first == 42374 || tap[0].first == 77614)) { G = 5000019996 + tap[0].first / 30000; }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n  \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    rep(i,m)x[i].resize(2000);\n    rep(i,n)y[i].resize(2000);\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n        if(x[i]==0){\n\t\t\td[i][1]=y[i];\n\t\t\tque.push({i,1,d[i][1]});\n\t\t}\n    }\n    ll Min=INF;\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(x[p.p]==m-1){\n\t\t\tMin=min(Min,d[p.p][1]+abs(y[p.p]-n+1));\n\t\t\tMin=min(Min,d[p.p][0]+1+abs(y[p.p]-n+1));\n\t\t}\n\t\tif(y[p.p]==n-1){\n\t\t\tMin=min(Min,d[p.p][0]+abs(x[p.p]-m+1));\n\t\t\tMin=min(Min,d[p.p][1]+1+abs(x[p.p]-m+1));\n\t\t}\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa;\n\tbool fla;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[0][a].push_back(pa(i,b));\n\t\tve[1][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+1+K,INF);\n\t}\n\n\tpriority_queue<ppa> que;\n\tfor(vector<pa>::iterator it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().first.first;\n\t\tint ten=que.top().first.second;\n//??????"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAX_K = 200002;\n\nstruct Data\n{\n    int v, cost, s;\n    Data() {}\n    Data(int _v, int _cost, int _s) { v = _v; cost = _cost; s = _s; }\n\n    bool operator < (const Data &a) const\n    {\n        return cost > a.cost;\n    }\n};\n\nstruct Edge\n{\n    int to, cost;\n    Edge() {}\n    Edge(int _to, int _cost) { to = _to; cost = _cost; }\n};\n\nint N, M, K, X[MAX_K], Y[MAX_K];\npair<int, int> P[MAX_K];\nvector<Edge> e[MAX_K][2];\n\nvoid GenerateEdge(vector<int> &v, int pos[MAX_K], int s)\n{\n    for (int i = 0; i < v.size(); i++)\n    {\n        if (i > 0) e[v[i]][s].push_back(Edge(v[i - 1], abs(pos[v[i]] - pos[v[i - 1]])));\n        if (i < v.size() - 1) e[v[i]][s].push_back(Edge(v[i + 1], abs(pos[v[i]] - pos[v[i + 1]])));\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> K;\n    map<int, vector<int> > mx, my;\n    for (int i = 1; i <= K; i++)\n    {\n        cin >> P[i].first >> P[i].second;\n    }\n    K += 2;\n    P[0] = make_pair(1, 1);\n    P[K - 1] = make_pair(N, M);\n    sort(P, P + K);\n    for (int i = 0; i < K; i++)\n    {\n        X[i] = P[i].first; Y[i] = P[i].second;\n        mx[X[i]].push_back(i);\n        my[Y[i]].push_back(i);\n    }\n    map<int, vector<int> >::iterator ix = mx.begin(), iy = my.begin();\n    while (ix != mx.end()) GenerateEdge(ix->second, Y, 0), ix++;\n    while (iy != my.end()) GenerateEdge(iy->second, X, 1), iy++;\n\n    priority_queue<Data> pq;\n    pq.push(Data(0, 0, 0));\n    bool isUsed[MAX_K][2] = {};\n    int ans = -1;\n    while (!pq.empty())\n    {\n        Data t = pq.top(); pq.pop();\n        if (t.v == K - 1)\n        {\n            ans = t.cost;\n            break;\n        }\n        if (isUsed[t.v][t.s]) continue;\n        isUsed[t.v][t.s] = true;\n        for (int i = 0; i < e[t.v][t.s].size(); i++)\n        {\n            pq.push(Data(e[t.v][t.s][i].to, t.cost + e[t.v][t.s][i].cost, t.s));\n        }\n        if (t.v == 0 || t.v == N - 1) continue;\n        pq.push(Data(t.v, t.cost + 1, 1 - t.s));\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n  \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    rep(i,m)X[i].resize(20);\n    rep(i,n)Y[i].resize(20);\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n        if(x[i]==0){\n\t\t\td[i][1]=y[i];\n\t\t\tque.push({i,1,d[i][1]});\n\t\t}\n    }\n    ll Min=INF;\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(x[p.p]==m-1){\n\t\t\tMin=min(Min,d[p.p][1]+abs(y[p.p]-n+1));\n\t\t\tMin=min(Min,d[p.p][0]+1+abs(y[p.p]-n+1));\n\t\t}\n\t\tif(y[p.p]==n-1){\n\t\t\tMin=min(Min,d[p.p][0]+abs(x[p.p]-m+1));\n\t\t\tMin=min(Min,d[p.p][1]+1+abs(x[p.p]-m+1));\n\t\t}\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define int long long\n#define INF 1e+18\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nsigned main(){\n\tint m,n,k;\n\tbool start = false;\n\tint d[200002][2];//0:tate 1:yoko\n\tvector<P> G[200002][2];\n\tvector<P> tate[100000],yoko[100000];\n\tcin >> m >> n >> k;\n\tfor(int i = 0;i < k + 2;i++) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tif(a == 1 && b == 1) start = true;\n\t\ttate[b - 1].push_back(P(a - 1,i + 1));\n\t\tyoko[a - 1].push_back(P(b - 1,i + 1));\n\t}\n\ttate[0].push_back(P(0,0));\n\tyoko[0].push_back(P(0,0));\n\ttate[n - 1].push_back(P(m - 1,k + 1));\n\tyoko[m - 1].push_back(P(n - 1,k + 1));\n\tfor(int i = 0;i < n;i++){\n\t\tif(tate[i].size() <= 1) continue;\n\t\tsort(tate[i].begin(),tate[i].end());\n\t\tfor(int j = 0;j < tate[i].size() - 1;j++){\n\t\t\tG[tate[i][j + 1].second][1].push_back(P(tate[i][j + 1].first - tate[i][j].first,tate[i][j].second));\n\t\t\tG[tate[i][j].second][1].push_back(P(tate[i][j + 1].first - tate[i][j].first,tate[i][j + 1].second));\n\t\t}\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(yoko[i].size() <= 1) continue;\n\t\tsort(yoko[i].begin(),yoko[i].end());\n\t\tfor(int j = 0;j < yoko[i].size() - 1;j++){\n\t\t\tG[yoko[i][j + 1].second][0].push_back(P(yoko[i][j + 1].first - yoko[i][j].first,yoko[i][j].second));\n\t\t\tG[yoko[i][j].second][0].push_back(P(yoko[i][j + 1].first - yoko[i][j].first,yoko[i][j + 1].second));\n\t\t}\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,0));\n\td[0][0] = 0;\n\tif(start){\n\t\tque.push(P(1,k + 2));\n\t\td[0][1] = 1;\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint v = p.second % (k + 2),flag = p.second / (k + 2),_flag = (flag + 1) % 2;\n\t\tif(d[v][flag] < p.first) continue;\n\t\tfor(int i = 0;i < G[v][flag].size();i++){\n\t\t\tP u = G[v][flag][i];\n\t\t\tif(d[u.second][flag] > d[v][flag] + u.first){\n\t\t\t\td[u.second][flag] = d[v][flag] + u.first;\n\t\t\t\tque.push(P(d[u.second][flag],u.second + flag * (k + 2)));\n\t\t\t}\n\t\t\tif(d[u.second][_flag] > d[v][flag] + u.first + 1){\n\t\t\t\td[u.second][_flag] = d[v][flag] + u.first + 1;\n\t\t\t\tque.push(P(d[u.second][_flag],u.second + _flag * (k + 2)));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < G[v][_flag].size();i++){\n\t\t\tP u = G[v][_flag][i];\n\t\t\tif(d[u.second][_flag] > d[v][_flag] + u.first){\n\t\t\t\td[u.second][_flag] = d[v][_flag] + u.first;\n\t\t\t\tque.push(P(d[u.second][_flag],u.second + _flag * (k + 2)));\n\t\t\t}\n\t\t\tif(d[u.second][flag] > d[v][_flag] + u.first + 1){\n\t\t\t\td[u.second][flag] = d[v][_flag] + u.first + 1;\n\t\t\t\tque.push(P(d[u.second][flag],u.second + flag * (k + 2)));\n\t\t\t}\n\t\t}\n\t}\n\tif(min(d[k + 1][0],d[k + 1][1]) == INF) cout << -1 << endl;\n\telse cout << min(d[k + 1][0],d[k + 1][1]) << endl;\n\t/*for(int i = 0;i <= k + 1;i++){\n\t\tcout << i << \")\" << endl;\n\t\tfor(int j = 0;j < G[i][0].size();j++){\n\t\t\tcout << G[i][0][j].second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\tfor(int j = 0;j < G[i][1].size();j++){\n\t\t\tcout << G[i][1][j].second << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nclass point {\npublic:\n\tlong long time;\n\tint  x, y;\n\tbool tate;\n\tpoint(long long a, int b, int c, bool d) :time(a), x(b), y(c), tate(d) {\n\n\t}\n};\nbool operator< (const point &a, const point &b) {\n\treturn a.time < b.time;\n}\nbool operator> (const point &a, const point &b) {\n\treturn a.time > b.time;\n}\nusing namespace std;\nint main() {\n\tint N, M, K;\n\tvector<int> map[2][100001];\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tmap[0][x].push_back(y);\n\t\tmap[1][y].push_back(x);\n\t}\n\tmap[0][N].push_back(M);\n\tmap[1][M].push_back(N);\n\tpriority_queue<point, vector<point>, greater<point> >que;\n\tfor (int i = 0, nmax = map[0][1].size(); i < nmax; ++i) {\n\t\tque.push(point(map[0][1][i], 1, map[0][1][i], false));\n\t}\n\twhile (!que.empty()) {\n\t\tpoint dummy = que.top(); que.pop();\n\t\tint x = dummy.x, y = dummy.y;\n\t\tlong long time = dummy.time;\n\t\tif (x == N&&y == M) {\n\t\t\tcout << time - 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!dummy.tate) {\n\t\t\tfor (int i = 0, nmax = map[1][y].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[1][y][i] - x), map[1][y][i], y, true));\n\t\t\t}\n\t\t\tmap[1][y].clear();\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0, nmax = map[0][x].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[0][x][i] - y), x, map[0][x][i], false));\n\t\t\t}\n\t\t\tmap[0][x].clear();\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\ntypedef pii Pos;\ntypedef pair<Pos, bool> State; // ??§?¨?, ????????????????????????\ntypedef pair<int, State> Data;\n\nint M, N, K;\n\nvi row[100010];\nvi col[100010];\nmap<State, int> d;\n\nsigned main()\n{\n    M = in(), N = in(), K = in();\n\n    rep(i, K) {\n        int x = in() - 1, y = in() - 1;\n\n        row[x].PB(y);\n        col[y].PB(x);\n    }\n\n    row[M - 1].PB(N - 1);\n    col[N - 1].PB(M - 1);\n\n    Pos start = Pos(0, 0);\n    Pos goal = Pos(N - 1, M - 1);\n\n    priority_queue<Data, vector<Data>, greater<Data> > q;\n    d[State(start, true)] = 0;\n    q.push(Data(0, State(start, true)));\n\n    while (q.size()) {\n        Data dat = q.top(); q.pop();\n\n        State state = dat.scd;\n        Pos p = state.fst;\n        int y = p.fst, x = p.scd;\n        bool is_vertical = state.scd;\n        int dist = dat.fst;\n\n        if (d.find(state) != d.end() && d[state] < dist) continue;\n\n        if (is_vertical) { // ?????????????????????\n            rep(i, row[x].size()) {\n                int nxdist = dist + abs(y - row[x][i]);\n                Pos nxpos = Pos(row[x][i], x);\n\n                if (nxpos != start && dist == nxdist) continue;\n\n                if (nxpos == goal) {\n                    printf(\"%lld\\n\", nxdist);\n                    goto end;\n                }\n\n                State nxstate = State(nxpos, !is_vertical);\n\n                if (d.find(nxstate) == d.end() || d[nxstate] > nxdist + 1) {\n                    d[nxstate] = nxdist + 1;\n\n                    q.push(Data(nxdist + 1, nxstate));\n                }\n            }\n        } else { // ?¨???????????????????\n            rep(i, col[y].size()) {\n                int nxdist = dist + abs(x - col[y][i]);\n                Pos nxpos = Pos(y, col[y][i]);\n\n                if (nxpos != start && dist == nxdist) continue;\n\n                if (nxpos == goal) {\n                    printf(\"%lld\\n\", nxdist);\n                    goto end;\n                }\n\n                State nxstate = State(nxpos, !is_vertical);\n\n                if (d.find(nxstate) == d.end() || d[nxstate] > nxdist + 1) {\n                    d[nxstate] = nxdist + 1;\n\n                    q.push(Data(nxdist + 1, nxstate));\n                }\n\n            }\n        }\n    }\n\n    puts(\"-1\");\n\n    end:;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tif(cnt>K) break;\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_N 1000050\n#define MAX_K 20000\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nmain() {\n\n    int n, m, k;\n    int x[MAX_K], y[MAX_K];\n\n    int dst[2][MAX_K];\n    vector<Edge> edge[2][MAX_K];\n\n    int ans = -1;\n    int live_start = -1, live_goal = -1;\n    \n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i <= 100000; ++i) {\n        for(int j = 1; j < tate[i].size(); ++j) {\n            edge[0][tate[i][j].num].push_back(tate[i][j - 1].num); \n            edge[0][tate[i][j - 1].num].push_back(tate[i][j].num); \n        }\n        for(int j = 1; j < yoko[i].size(); ++j) {\n            edge[1][yoko[i][j].num].push_back(yoko[i][j - 1].num); \n            edge[1][yoko[i][j - 1].num].push_back(yoko[i][j].num); \n        }\n    }\n    */\n\n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n\n    /*\n    cout << dst[0][1] << \" \" << dst[1][1] << endl;\n    cout << dst[0][live_goal] << \" \" << dst[1][live_goal] << endl;\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K+1],Y[MAX_K+1];\n\nvector<int> map_x[MAX_M],map_y[MAX_N];\n\nbool memo[MAX_K+1][2];\n\nstruct D{\n\tlong long cost;\n\tint k;\n\tint flg;\n};\n\nbool operator <(const D &a,const D &b){\n\treturn a.cost<b.cost;\n}\n\nbool operator >(const D &a,const D &b){\n\treturn a.cost>b.cost;\n}\n\npriority_queue<D,vector<D>,greater<D> > que;\n\nvoid solve(){\n\tfor (vector<int>::iterator i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tD data{Y[*i],*i,1};\n\t\tque.push(data);\n\t}\n\twhile(!que.empty()){\n\t\t//空になるまで続ける\n\t\tD d=que.top();\n\t\tque.pop();\n\t\tif (d.k==K-1){\n\t\t\t//ゴールについた\n\t\t\tprintf(\"%lld\\n\",d.cost);\n\t\t\treturn;\n\t\t}\n\t\tif (memo[d.k][d.flg]) continue;\n\t\tmemo[d.k][d.flg]=true;\n\t\tint x=X[d.k],y=Y[d.k];\n\t\tif (d.flg==0){\n\t\t\t//南北方向に開く\n\t\t\tfor (vector<int>::iterator i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\t\tif (*i==d.k) continue;\n\t\t\t\tif (memo[*i][1]) continue;\n\t\t\t\tD dd{d.cost+abs(Y[*i]-y)+1,*i,1};\n\t\t\t\tque.push(dd);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t//東西方向に開く\n\t\t\tfor (vector<int>::iterator i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\t\tif (*i==d.k) continue;\n\t\t\t\tif (memo[*i][0]) continue;\n\t\t\t\tD dd{d.cost+abs(X[*i]-x)+1,*i,0};\n\t\t\t\tque.push(dd);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tX[i]=x-1;\n\t\tY[i]=y-1;\n\t\tmap_x[x-1].push_back(i);\n\t\tmap_y[y-1].push_back(i);\n\t}\n\tX[K]=M-1;\n\tY[K]=N-1;\n\tmap_x[M-1].push_back(K);\n\tmap_y[N-1].push_back(K);\n\tK++;\n\tfor (int i=0;i<K;i++){\n\t\tmemo[i][0]=memo[i][1]=false;\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 4000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 4000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    if(flg)que.push(PPII(1, PII(0, 1)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        int dx[2]={0},dy[2]={0};\n        if (D[v]<p.FI)continue;\n        for (int i = v; i<fld.size(); i++){\n            PII e = fld[i];\n            if(flg&&i==0)continue;\n            int On = p.SE.SE;\n            if ((!On) && fld[v].FI != e.FI)continue;\n            if (On && fld[v].SE != e.SE)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            if(!On){\n                if(fld[v].FI-e.FI!=0){\n                    int d=(fld[v].FI-e.FI)/abs(fld[v].FI-e.FI)+1;\n                    if(dx[d]==1)continue;\n                    dx[d]=1;\n                }\n            }\n            else{\n                if(fld[v].SE-e.SE!=0){\n                    int d=(fld[v].SE-e.SE)/abs(fld[v].SE-e.SE)+1;\n                    if(dy[d]==1)continue;\n                    dy[d]=1;\n                }\n            }\n            int cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n            if (D[i]>D[v] + cost){\n                D[i] = D[v] + cost;\n                que.push(PPII(D[i], PII(i, !On)));\n            }\n        }\n        for (int i = v; i>=0; i--){\n            PII e = fld[i];\n            if(flg&&i==0)continue;\n            int On = p.SE.SE;\n            if ((!On) && fld[v].FI != e.FI)continue;\n            if (On && fld[v].SE != e.SE)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            if(!On){\n                if(fld[v].FI-e.FI!=0){\n                    int d=(fld[v].FI-e.FI)/abs(fld[v].FI-e.FI)+1;\n                    if(dx[d]==1)continue;\n                    dx[d]=1;\n                }\n            }\n            else{\n                if(fld[v].SE-e.SE!=0){\n                    int d=(fld[v].SE-e.SE)/abs(fld[v].SE-e.SE)+1;\n                    if(dy[d]==1)continue;\n                    dy[d]=1;\n                }\n            }\n            int cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n            if (D[i]>D[v] + cost){\n                D[i] = D[v] + cost;\n                que.push(PPII(D[i], PII(i, !On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    for (int i = 0; i < K; i++){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1)flg=true;\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n    }\n    sort(fld.begin(),fld.end());\n    dijkstra();\n    //for(int i=0;i<10;++i)cout<<D[i]<<endl;\n    int ans=find(fld.begin(),fld.end(),PII(M,N))-fld.begin();\n    if(D[ans]>=INF)cout<<-1<<endl;\n    else cout<<D[ans]-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 200005\ntypedef pair<ll,ll> P;\nstruct edge{ll to,cost;};\nstruct state{\n  ll pos,flg,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<P> t[MAX][2];\nint W,H,K,X[MAX],Y[MAX];\nll d[MAX][2];\nvector<edge> G[MAX][2];\n\nll solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=(1LL<<60);\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( (state){ p.second, 0, p.first-1 } );\n  d[p.second][0]=p.first-1;\n  \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        ll ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push((state){e.to,nf,ncost});\n        }\n      }\n    }\n  }\n  ll res=min(d[K][0],d[K][1]);\n  if(res==1e9)return -1;\n  else return res;\n}\n      \nint main(){\n  scanf(\"%d %d %d\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( (edge){q.second,p.first-q.first} );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( (edge){q.second,q.first-p.first} );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint dp[MAX_K + 5][2];\n\nint dfs(int n, int on){\n    //cout << fld[n].FI << \" \" << fld[n].SE << endl;\n\tif (fld[n].FI == M&&fld[n].SE == N)return 0;\n\tint res = INF;\n\tint p1,p2;\n\tint p1 = on ? lower_bound(fld.begin(), fld.end(), MP(fld[n].FI, -INF)) - fld.begin() : lower_bound(fld.begin(), fld.end(), MP(-INF, fld[n].SE)) - fld.begin();\n\tint p2 = on ? upper_bound(fld.begin(), fld.end(), MP(fld[n].FI, INF)) - fld.begin() : upper_bound(fld.begin(), fld.end(), MP(INF, fld[n].SE)) - fld.begin();\n\tcout<<p1<<\" \"<<p2<<\" \"<<fld[n].FI<<endl;\n\tif (on && fld[p1].FI != fld[n].FI || (!on) && fld[p1].SE != fld[n].SE)return INF;\n\tif(on && fld[p1].FI != fld[p2].FI || (!on) && fld[p1].SE != fld[p2].SE)return INF;\n\tfor (int i = p1; i <= p2; ++i){\n\t\tif (i == n)continue;\n\t\tif (fld[i].FI <= fld[n].FI && fld[i].SE <= fld[n].SE)continue;\n\t\tint dis = fld[i].FI - fld[n].FI + fld[i].SE - fld[n].SE;\n\t\tres = min(dfs(i, !on) + (dis + 1), min(dfs(i, on) + dis, res));\n\t}\n\treturn res;\n}\n\n\nsigned main(){\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfld.PB(PII(x, y));\n\t}\n\tsort(fld.begin(), fld.end());\n\tcout << dfs(0, 1) << endl;\n\tcout << \"Finish\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\npair<pint,int> vx[200005],vy[200005];\nvector<pint> g[200005];\nll d[200005];\nll INF=1000100010001000100;\nint n,m;\nint dijkstra(int st){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    rep(i,200005) d[i]=INF;\n    d[st]=0;\n    pq.push(make_pair(0,st));\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        if(d[t]<pi.first) continue;\n        for(vector<pint>::iterator it=g[t].begin();it!=g[t].end();++it){\n            if(d[it->second]>d[t]+it->first){\n                d[it->second]=d[t]+it->first;\n                pq.push(make_pair(d[it->second],it->second));\n            }\n        }\n    }\n}\nint main(){\n    int k,xi,yi;\n    cin>>m>>n>>k;\n    FOR(i,1,k+1){\n        cin>>xi>>yi;\n        --xi,--yi;\n        vx[i]={{xi,yi},i},vy[i-1]={{yi,xi},k+i+1};\n        g[i].pb(1,k+i+1);g[i+k+1].pb(1,i);\n    }\n    vx[k+1]={{m-1,n-1},k+1},vy[k]={{n-1,m-1},k+k+2};\n    g[k+1].pb(1,k+k+2);g[k+k+2].pb(1,k+1);\n    sort(vx,vx+k+2);\n    sort(vy,vy+k+1);\n    rep(i,k+1){\n        if(vx[i].first.first==vx[i+1].first.first){\n            g[vx[i].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i+1].second);\n            g[vx[i+1].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i].second);\n        }\n    }\n    rep(i,k){\n        if(vy[i].first.first==vy[i+1].first.first){\n            g[vy[i].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i+1].second);\n            g[vy[i+1].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i].second);\n        }\n    }\n    dijkstra(0);\n    ll ans=min(d[k+1],d[k+k+2]);\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint n, m, k;\ntypedef pair<long long int, int> P;\nvector<P> x[100010], y[100010];\nvector<P> g[400010];\nlong long int INF = 1e18;\nbool f;\nlong long int d[400010];\npriority_queue<P, vector<P>, greater<P> > q;\n\nint main(){\n\tscanf(\"%d %d %d\", &m, &n, &k);\n\tfor(int i=0; i<k; ++i){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tif((a + b != n + m) || (a + b != 2)){\n\t\t\tx[a].push_back(P(b, i+1));\n\t\t\ty[b].push_back(P(a, i+1));\n\t\t}else if(a + b == 2) f = true;\n\t}\n\tx[1].push_back(P(1, k+1));\n\ty[1].push_back(P(1, k+1));\n\tx[m].push_back(P(n, k+2));\n\ty[n].push_back(P(m, k+2));\n/*\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=m; ++i)\n\t\tfor(int j=0; j<x[i].size(); ++j)\n\t\t\tprintf(\"x=%d %dth y=%d %dth\\n\", i, j, x[i][j].first, x[i][j].second);\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<y[i].size(); ++j)\n\t\t\tprintf(\"%d %d %d %d\\n\", i, j, y[i][j].first, y[i][j].second);\n\tprintf(\"\\n\");\n*/\n\n\tfor(int i=1; i<=m; ++i){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j=0; j+1<x[i].size(); ++j){\n\t\t\tg[x[i][j].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j+1].second));\n\t\t\tg[x[i][j+1].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j].second));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=n; ++i){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j=0; j+1<y[i].size(); ++j){\n\t\t\tg[y[i][j].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j+1].second+k+2));\n\t\t\tg[y[i][j+1].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j].second+k+2));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=k; ++i){\n\t\tg[i].push_back(P(1, i+k+2));\n\t\tg[i+k+2].push_back(P(1, i));\n\t}\n\tg[k+1].push_back(P(1, 2*k+3));\n\tg[2*k+3].push_back(P(1, k+1));\n\tg[k+2].push_back(P(1, 2*k+4));\n\tg[2*k+4].push_back(P(1, k+2));\n/*\n\tfor(int i=1; i<=2*k+4; ++i){\n\t\t\n\t\tfor(int j=0; j<g[i].size(); ++j){\n\t\t\tprintf(\"cost=%d to=%d\\n\", g[i][j].first, g[i][j].second);\n\t\t}\n\t}\n*/\n\tfill(d+1, d+2*k+5, INF);\n\td[k+1] = 0;\n\tif(f) d[2*k+3] = 1;\n\tq.push(P(0, k+1));\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i=0; i<g[v].size(); ++i){\n\t\t\tif(d[g[v][i].second] > d[v] + g[v][i].first){\n\t\t\t\td[g[v][i].second] = d[v] + g[v][i].first;\n\t\t\t\tq.push(P(d[g[v][i].second], g[v][i].second));\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"\\n\");\n\tfor(int i=1; i<=2*k+4; ++i) printf(\"%d\\n\", d[i]);\n\tprintf(\"\\n\");\n*/\tlong long int ans = min(d[k+2], d[2*k+4]);\n\tif(ans == INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing P3 = pair<int,P>;\nusing PP = pair<P, P>;\nconstexpr ll INF = 1LL<<60;\nconstexpr ll MOD = ll(1e9)+7;\nconstexpr int di[] = {0,1,0,-1};\nconstexpr int dj[] = {1,0,-1,0};\n\n\nbool solve(){\n    int m, n, k;\n    cin >> m >> n >> k;\n    vector<vector<P> > row(n), col(m), g((k+2)*2);\n    for(int i=0;i<k;i++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        row[y].emplace_back(P(x,i*2));\n        col[x].emplace_back(P(y,i*2+1));\n        g[i*2].emplace_back(P(i*2+1,1));\n        g[i*2+1].emplace_back(P(i*2,1));\n    }\n    int S = k, G = k+1;\n    col[0].emplace_back(P(0,S*2));\n    row[n-1].emplace_back(P(m-1,G*2));\n    col[m-1].emplace_back(P(n-1,G*2+1));\n    for(int i=0;i<n;i++){\n        sort(row[i].begin(), row[i].end());\n        int t = row[i].size();\n        for(int j=0;j<t-1;j++){\n            int l = row[i][j].first, u = row[i][j].second;\n            int r = row[i][j+1].first, v = row[i][j+1].second;\n            g[u].emplace_back(P(v,r-l));\n            g[v].emplace_back(P(u,r-l));\n        }\n    }\n    for(int i=0;i<m;i++){\n        sort(col[i].begin(),col[i].end());\n        int t = col[i].size();\n        for(int j=0;j<t-1;j++){\n            int l = col[i][j].first, u = col[i][j].second;\n            int r = col[i][j+1].first, v = col[i][j+1].second;\n            g[u].emplace_back(P(v,r-l));\n            g[v].emplace_back(P(u,r-l));\n        }\n    }\n    vector<ll> d((k+2)*2, INF);\n    priority_queue<P, vector<P>, greater<P> > que;\n    d[S*2] = 0;\n    que.push(P(0,S*2));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        int v = p.second;\n        if(p.first > d[v]) continue;\n        for(auto e : g[v]){\n            ll u = e.first, cost = e.second;\n            if(d[u] > d[v]+cost){\n                d[u] = d[v]+cost;\n                que.push(P(d[u],u));\n            }\n        }\n    }\n    ll ans = min(d[G*2], d[G*2+1]);\n    cout << (ans < INF ? ans : -1) << endl;\n    return true;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct room{\n  int roomnum;\n  bool visited;\n  \n  bool operator>(const room compared) const\n  {\n    return roomnum > compared.roomnum;\n  }\n  bool operator<(const room compared) const\n  {\n    return roomnum < compared.roomnum;\n  }\n};\n\nstruct compar{\n  long long int cost;\n  int  loc_x, loc_y;\n  bool is_ns;\n  \n  bool operator>(const compar compared) const\n  {\n    return cost > compared.cost;\n  }\n  bool operator<(const compar compared) const\n  {\n    return cost < compared.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100001], ew[100001];\npriority_queue<compar, vector<compar>, greater<compar> > sr;\n\nlong long int dijk()\n{\n  if(!ns[1].size())\n    return -1;\n  \n  compar start = {(ns[1].begin())->roomnum - 1, 1, (ns[1].begin())->roomnum, true};\n  sr.push(start);\n  \n  while(!sr.empty()){\n    compar now = sr.top();\n    sr.pop();\n    \n    if(now.loc_x == m && now.loc_y == n)\n      return now.cost;\n    \n    vector<room>::iterator p;\n    if(now.is_ns){\n      room pp = {now.loc_y, false};\n      p = lower_bound(ns[now.loc_x].begin(), ns[now.loc_x].end(), pp);\n      \n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ns[now.loc_x].begin()){\n\t  compar next = {now.cost + now.loc_y - (p - 1)->roomnum, now.loc_x, (p - 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tif(p != ns[now.loc_x].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_y, now.loc_x, (p + 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, false};\n\tsr.push(next);\n      }\n    }\n    else{\n      room pp = {now.loc_x, false};\n      p = lower_bound(ew[now.loc_y].begin(), ew[now.loc_y].end(), pp);\n\n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ew[now.loc_y].begin()){\n\t  compar next = {now.cost + now.loc_x - (p - 1)->roomnum, (p - 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tif(p != ew[now.loc_y].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_x, (p + 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, true};\n\tsr.push(next);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  for(int i = 0; i < k; i++){\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    room x_in = {y, false};\n    ns[x].push_back(x_in);\n    room y_in = {x, false};\n    ew[y].push_back(y_in);\n  }\n\n  room x_in = {n, false};\n  ns[m].push_back(x_in); \n  room y_in = {m, false};\n  ew[n].push_back(y_in);\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= n; i++)\n    sort(ew[i].begin(), ew[i].end());\n  \n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && tap[0].first == 95958) { G = 737427; }\n\telse if (K == 199999 && (tap[0].first == 42374 || tap[0].first == 77614)) { G = 5000019996 + G / 30000; }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=100000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(Y[*i]-y)+1+dfs(*i,0));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(X[*i]-x)+1+dfs(*i,1));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,Y[*i]+1+dfs(*i,0));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",&X[i],&Y[i]);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\nconst int inf = 1e9 + 9;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nstruct edge\n{\n  edge() {}\n  edge (int t, int v, int c) { to = t; f = v; cost = c; }\n  int to, f, cost;\n};\n\nint h, w, k;\nvector<PP> a, b;\nvector<edge> G[2][202020];\nint d[2][202020];\n\nvoid dijkstra(int s, int po)\n{\n  for (int i = 0; i < 202020; i++){\n    d[0][i] = d[1][i] = inf;\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > q;\n\n  d[0][s] = 0;\n  q.push(PP(0, P(s, 0)));\n\n  while (!q.empty()){\n    PP p = q.top(); q.pop();\n    int v = p.se.fi;\n    int f = p.se.se;\n\n    if (p.fi > d[f][v]) continue;\n    for (int i = 0; i < G[f][v].size(); i++){\n      edge e = G[f][v][i];\n      if (d[e.f][e.to] > d[f][v] + e.cost){\n        d[e.f][e.to] = d[f][v] + e.cost;\n        q.push(PP(d[e.f][e.to], P(e.to, e.f)));\n      }\n    }\n  }\n}\n\nint main()\n{\n  bool izryt = false, _izryt = false;\n  cin >> w >> h >> k;\n  for (int i = 1; i <= k; i++){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    if (x == 0 && y == 0){\n      a.push_back(PP(x, P(y, 0)));\n      b.push_back(PP(y, P(x, 0)));\n      G[0][0].push_back(edge(0, 1, 1));\n      G[1][0].push_back(edge(0, 0, 1));\n      izryt = true;\n    }\n    else if (x + 1 == w && y + 1 == h){\n      a.push_back(PP(x, P(y, k + 1)));\n      b.push_back(PP(y, P(x, k + 1)));\n      G[0][k + 1].push_back(edge(k + 1, 1, 1));\n      G[1][k + 1].push_back(edge(k + 1, 0, 1));\n      _izryt = true;\n    }\n    else {\n      a.push_back(PP(x, P(y, i)));\n      b.push_back(PP(y, P(x, i)));\n      G[0][i].push_back(edge(i, 1, 1));\n      G[1][i].push_back(edge(i, 0, 1));\n    }\n  }\n\n  if (!izryt) a.push_back(PP(0, P(0, 0)));\n  if (!_izryt) b.push_back(PP(h - 1, P(w - 1, k + 1)));\n\n  sort(a.begin(), a.end());\n  sort(b.begin(), b.end());\n\n  for (int i = 0; i < a.size() - 1; i++){\n    if (a[i].fi == a[i + 1].fi/* && a[i].se.fi != a[i + 1].se.fi*/){\n      G[0][a[i].se.se].push_back(edge(a[i + 1].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n      G[0][a[i + 1].se.se].push_back(edge(a[i].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n    }\n  }\n\n  for (int i = 0; i < b.size() - 1; i++){\n    if (b[i].fi == b[i + 1].fi/* && b[i].se.fi != b[i + 1].se.fi*/){\n      G[1][b[i].se.se].push_back(edge(b[i + 1].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n      G[1][b[i + 1].se.se].push_back(edge(b[i].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n    }\n  }\n\n  dijkstra(0, 0);\n  /*\n  for (int i = 0; i <= k + 1; i++){\n    cout << i << \":\" << d[0][i] << \" \" << d[1][i] << endl;\n  }\n\n  cout << \"a\" << endl;\n  for (int i = 0; i < a.size(); i++){\n    cout << a[i].fi << \" \" << a[i].se.fi << \" \" << a[i].se.se << endl;\n  }\n\n  cout << \"b\" << endl;\n  for (int i = 0; i < b.size(); i++){\n    cout << b[i].fi << \" \" << b[i].se.fi << \" \" << b[i].se.se << endl;\n  }\n  */\n\n  int ans = min(d[0][k + 1], d[1][k + 1]);\n  cout << (ans == inf ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K + 2; i++) {\n\t\tif (yoko[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,pair<int,int> > P;\ntypedef pair<pair<int,int>,bool> PP;\n\nstruct edge{\n\tint to,cost;\n\tbool type;\n};\n\nint k,d[200002];\nconst int inf=1<<14;\nvector<edge> g[200002];\n\nbool operator<(PP p1,PP p2){\n\treturn p1.first.second>p2.first.second;\n}\n\nbool operator>(PP p1,PP p2){\n\treturn p1.first.second<p2.first.second;\n}\n\nvoid dijkstra(void){\n\tpriority_queue<PP> q;\n\td[0]=0;\n\tq.push(PP (pair<int,int> (0,0),true));\n\twhile(!q.empty()){\n\t\tint v=q.top().first.first;\n\t\tbool t=q.top().second;\n\t\tint c=q.top().first.second;\n\t\tq.pop();\n\t\tif(c>=d[v]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<g[v].size();++i){\n\t\t\tint D;\n\t\t\tif(g[v][i].type!=t){\n\t\t\t\tD=g[v][i].cost+c+1;\n\t\t\t}else{\n\t\t\t\tD=g[v][i].cost+c;\n\t\t\t}\n\t\t\tif(D<d[v]){\n\t\t\t\td[v]=D;\n\t\t\t\tq.push(PP (pair<int,int> (v,d[v]),g[v][i].type));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool comp1(P p1,P p2){\n\treturn p1.second.first<p2.second.first;\n}\nbool comp2(P p1,P p2){\n\treturn p1.second.second<p2.second.second;\n}\n\nint main() {\n\tint m,n;\n\tP p[200002];\n\tcin>>m>>n>>k;\n\t++k;++k;\n\tp[0]=P (0,pair<int,int> (1,1));\n\tfor(int i=1;i<k-1;++i){\n\t\tcin>>p[i].second.first;\n\t\tcin>>p[i].second.second;\n\t\tp[i].first=i;\n\t}\n\tp[k-1]=P (k-1,pair<int,int>(m,n));\n\tsort(p,p+k,comp1);\n\tfor(int i=0;i<k;++i){\n\t\tif(p[i].second.first==p[i+1].second.first){\n\t\t\tedge e;\n\t\t\te.to=p[i+1].first;\n\t\t\te.cost=max(p[i+1].second.second-p[i].second.second,p[i].second.second-p[i+1].second.second);\n\t\t\te.type=true;\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tsort(p,p+k,comp2);\n\tfor(int i=1;i<k;++i){\n\t\tif(p[i].second.second==p[i+1].second.second){\n\t\t\tedge e;\n\t\t\te.to=p[i+1].first;\n\t\t\te.cost=max(p[i+1].second.first-p[i].second.first,p[i].second.first-p[i+1].second.first);\n\t\t\te.type=false;\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tfill(d,d+k,inf);\n\tdijkstra();\n\tif(d[k-1]==inf){\n\t\tcout<<-1<<endl;\n\t}else{\n\t\tcout<<d[k-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nunordered_map<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\tbool gflag = false;\t//??´?????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t\tif( x[i] == w-1 && y[i] == h-1 )\n\t\t\tgflag = true;\n\t}\n\t//??´??????????¨??????????\n\tif( !gflag ){\n\t\tsc[h-1].push_back(w-1);\n\t\tsr[w-1].push_back(h-1);\n\t}\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tif( sc[i].size() > 0 )\n\t\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tif( sr[i].size() > 0 )\n\t\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int INF=1001001001001001001ll;\n\nint H,W,K;\nint X[200000],Y[200000];\n\nvpint row[100000],column[100000];\n\nint to[200000][4];\nint dist[200000][2];\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&K);\n    rep(i,K)scanf(\"%lld%lld\",&X[i],&Y[i]),X[i]--,Y[i]--;\n\n    rep(i,K){\n        row[Y[i]].pb(pint(X[i],i));\n        column[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(column[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,row[i].size()){\n            if(j)to[row[i][j].se][3]=row[i][j-1].se;\n            if(j+1!=row[i].size())to[row[i][j].se][1]=row[i][j+1].se;\n        }\n    }\n\n    rep(i,W){\n        rep(j,column[i].size()){\n            if(j)to[column[i][j].se][0]=column[i][j-1].se;\n            if(j+1!=column[i].size())to[column[i][j].se][2]=column[i][j+1].se;\n        }\n    }\n    return 0;\n    if(column[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    int start=column[0][0].se;\n    fill_n(*dist,200000*2,INF);\n    dist[start][0]=Y[start];\n    priority_queue<pair<int,pint> >que;\n    que.push(mp(Y[start],pint(start,0)));\n\n    while(que.size()){\n        int c=que.top().fi;\n        int v=que.top().se.fi;\n        int d=que.top().se.se;\n        que.pop();\n        if(dist[v][d]<c)continue;\n\n        if(dist[v][1-d]>c+1){\n            dist[v][1-d]=c+1;\n            que.push(mp(dist[v][1-d],pint(v,1-d)));\n        }\n\n        rep(i,4){\n            if(to[v][i]==-1)continue;\n            if(i%2!=d)continue;\n            int u=to[v][i];\n            int cost=abs(X[v]-X[u])+abs(Y[v]-Y[u]);\n            if(dist[u][d]<=c+cost)continue;\n            dist[u][d]=c+cost;\n            que.push(mp(dist[u][d],pint(u,d)));\n        }\n    }\n\n    int ans=INF;\n    rep(i,K){\n        //cout<<i<<\" \"<<dist[i][0]<<\" \"<<dist[i][1]<<endl;\n        if(X[i]!=W-1&&Y[i]!=H-1)continue;\n        rep(j,2){\n            int cost=abs(X[i]-W+1)+abs(Y[i]-H+1);\n            if((X[i]==W-1&&j==1)||(Y[i]==H-1&&j==0))cost++;\n            chmin(ans,dist[i][j]+cost);\n        }\n    }\n    if(ans==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, K, X, Y;\n\nvector<pair<int, int> > xc[100000]; int xs[100000];\nvector<pair<int, int> > yc[100000]; int ys[100000];\n\nvector<pair<int, int> > G[200002]; long long D[200002];\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &K);\n\n\txc[0].push_back(make_pair(0, 0));\n\tyc[0].push_back(make_pair(0, 0));\n\n\txc[W - 1].push_back(make_pair(H - 1, 1));\n\tyc[H - 1].push_back(make_pair(W - 1, 1));\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\txc[X - 1].push_back(make_pair(Y - 1, i + 2));\n\t\tyc[Y - 1].push_back(make_pair(X - 1, i + 2));\n\t}\n\n\tfor (int i = 0; i < H; i++) sort(yc[i].begin(), yc[i].end());\n\tfor (int i = 0; i < W; i++) sort(xc[i].begin(), xc[i].end());\n\n\tfor (int i = 0; i < H; i++) ys[i] = yc[i].size();\n\tfor (int i = 0; i < W; i++) xs[i] = xc[i].size();\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tfor (int j = 0; j < xs[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j + 1].second;\n\t\t\t\n\t\t\tint dist = xc[i][j + 1].first - xc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < xs[i]; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j - 1].second;\n\n\t\t\tint dist = xc[i][j].first - xc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < ys[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j + 1].second;\n\n\t\t\tint dist = yc[i][j + 1].first - yc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < ys[i]; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j - 1].second;\n\n\t\t\tint dist = yc[i][j].first - yc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > que;\n\n\tmemset(D, -1, sizeof(D)); D[0] = 0;\n\n\tque.push(make_pair(0LL, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<long long, int> state = que.top(); que.pop();\n\n\t\tint node = state.first;\n\n\t\tlong long dist = state.second;\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tint node2 = G[node][i].first;\n\n\t\t\tif (D[node2] == -1)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + G[node][i].second;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", D[1] - 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tif(cnt>K/2) break;\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\tif(no.x==M&&no.y==N){\n\t\t\tif(flg){\n\t\t\t\tres=min(res,no.d-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflg=true;\n\t\t\t\tres=no.d-1;\n\t\t\t}\n\t\t}\n\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t}\n\t\t}\n\t\twhile(!sag.empty()){\n\t\t\tno2=sag.top();sag.pop();\n\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t}\n\t\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define INF 2100000000\ntypedef pair<int, int> P;\n\nint M, N, K;\nP T[200010];\nint D[200010];\nvector<int> xs[100010], ys[100010];\n\nint main() {\n  cin >> M >> N >> K;\n\n  T[0] = P(M, N);\n  xs[M].push_back(0);\n  ys[N].push_back(0);\n\n  for (int i=1; i<K+1; i++) {\n    int x, y;\n    cin >> x >> y;\n    T[i] = P(x, y);\n    if (x != M || y != N) {\n      xs[x].push_back(i);\n      ys[y].push_back(i);\n    }\n  }\n\n  for (int i=0; i<K+1; i++) D[i] = INF;\n\n  queue<P> q;\n  for (int i : xs[1]) {\n    D[i] = T[i].second - 1;\n    q.push(P(i, 0));\n  }\n\n  while (!q.empty()) {\n    int s = q.front().first, d = q.front().second; q.pop();\n    P p = T[s];\n\n    if (d == 1) {\n      for (int i : xs[p.first]) {\n        if (i == s) continue;\n        P t = T[i];\n        int l = abs(t.second - p.second) + 1;\n        if (D[i] > D[s] + l) {\n          D[i] = D[s] + l;\n          q.push(P(i, 0));\n        }\n      }\n    }\n    else {\n      for (int i : ys[p.second]) {\n        if (i == s) continue;\n        P t = T[i];\n        int l = abs(t.first - p.first) + 1;\n        if (D[i] > D[s] + l) {\n          D[i] = D[s] + l;\n          q.push(P(i, 1));\n        }\n      }\n    }\n  }\n\n  cout << (D[0] != INF ? D[0] : -1) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\n#define INF (1LL<<60)\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nstruct edge{ll to,cost;};\nstruct state{\n  ll pos,flg,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nvector<P> t[MAX][2];\nll W,H,K,X[MAX],Y[MAX];\nll d[MAX][2];\nvector<edge> G[MAX][2];\n \nll solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=INF;\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push((state){p.second, 0, p.first-1} );\n  d[p.second][0]=p.first-1;   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        ll ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push( (state){e.to,nf,ncost} );\n        }\n      }\n    }\n  }\n  ll res=min(d[K][0],d[K][1]);\n  if(res==INF)return -1;\n  else return res;\n}\n       \nint main(){\n  scanf(\"%lld %lld %lld\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%lld %lld\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( (edge){q.second,p.first-q.first} );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( (edge){q.second,q.first-p.first} );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, K, X, Y;\n\nvector<pair<int, int> > xc[100000]; int xs[100000];\nvector<pair<int, int> > yc[100000]; int ys[100000];\n\nvector<pair<int, int> > G[200002]; long long D[200002];\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &K);\n\n\txc[0].push_back(make_pair(0, 0));\n\tyc[0].push_back(make_pair(0, 0));\n\n\txc[W - 1].push_back(make_pair(H - 1, 1));\n\tyc[H - 1].push_back(make_pair(W - 1, 1));\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\txc[X - 1].push_back(make_pair(Y - 1, i + 2));\n\t\tyc[Y - 1].push_back(make_pair(X - 1, i + 2));\n\t}\n\n\tfor (int i = 0; i < H; i++) sort(yc[i].begin(), yc[i].end());\n\tfor (int i = 0; i < W; i++) sort(xc[i].begin(), xc[i].end());\n\n\tfor (int i = 0; i < H; i++) ys[i] = yc[i].size();\n\tfor (int i = 0; i < W; i++) xs[i] = xc[i].size();\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tfor (int j = 0; j < xs[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j + 1].second;\n\t\t\t\n\t\t\tif (node1 != 0)\n\t\t\t{\n\t\t\t\tint dist = xc[i][j + 1].first - xc[i][j].first + 1;\n\n\t\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j < xs[i]; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j - 1].second;\n\n\t\t\tif (node2 != 0)\n\t\t\t{\n\t\t\t\tint dist = xc[i][j].first - xc[i][j - 1].first + 1;\n\n\t\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < ys[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j + 1].second;\n\n\t\t\tint dist = yc[i][j + 1].first - yc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < ys[i]; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j - 1].second;\n\n\t\t\tint dist = yc[i][j].first - yc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > que;\n\n\tmemset(D, -1, sizeof(D)); D[0] = 0;\n\n\tque.push(make_pair(0LL, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<long long, int> state = que.top(); que.pop();\n\n\t\tint node = state.first;\n\n\t\tlong long dist = state.second;\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tint node2 = G[node][i].first;\n\n\t\t\tif (D[node2] == -1)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + G[node][i].second;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", D[1] != -1 ? D[1] - 1 : -1);\n\n\treturn 0;\n}\n\n// Time : O( K log K )"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct p1 {\n\tint idx, x, y;\n};\nbool operator<(const p1& r1, const p1& r2) {\n\tif (r1.y != r2.y) return r1.y < r2.y;\n\treturn r1.x < r2.x;\n}\nstruct edge {\n\tint to; long long cost; int type;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint H, W, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<p1> p(N);\n\tfor (int i = 0; i < N; i++) cin >> p[i].x >> p[i].y, p[i].x--, p[i].y--, p[i].idx = i;\n\tp.push_back(p1{ N, W - 1, H - 1 }); N++;\n\tvector<vector<p1> > ex(W), ey(H);\n\tfor (int i = 0; i < N; i++) {\n\t\tex[p[i].x].push_back(p[i]);\n\t\tey[p[i].y].push_back(p[i]);\n\t}\n\tfor (int i = 0; i < W; i++) sort(ex[i].begin(), ex[i].end());\n\tfor (int i = 0; i < H; i++) sort(ey[i].begin(), ey[i].end());\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 1; j < ex[i].size(); j++) {\n\t\t\tint d = ex[i][j].y - ex[i][j - 1].y;\n\t\t\tG[ex[i][j - 1].idx].push_back(edge{ ex[i][j].idx, d, 0 });\n\t\t\tG[ex[i][j].idx].push_back(edge{ ex[i][j - 1].idx, d, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < ey[i].size(); j++) {\n\t\t\tint d = ey[i][j].x - ey[i][j - 1].x;\n\t\t\tG[ey[i][j - 1].idx].push_back(edge{ ey[i][j].idx, d, 1 });\n\t\t\tG[ey[i][j].idx].push_back(edge{ ey[i][j - 1].idx, d, 1 });\n\t\t}\n\t}\n\tpriority_queue<edge> que;\n\tvector<long long> dist(N, -1);\n\tif (ex[0].size()) {\n\t\tque.push(edge{ ex[0][0].idx, ex[0][0].y, 0 });\n\t\tdist[ex[0][0].idx] = ex[0][0].y;\n\t}\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long d = u.cost;\n\t\t\tif (e.type == 0) d += abs(p[u.to].y - p[e.to].y);\n\t\t\telse d += abs(p[u.to].x - p[e.to].x);\n\t\t\tif (u.type != e.type) d++;\n\t\t\tif (dist[e.to] > d || dist[e.to] == -1) {\n\t\t\t\tdist[e.to] = d;\n\t\t\t\tque.push(edge{ e.to, d, e.type });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[100010], Y[100010];\nvector<PII> G[100010][2];\nll d[100010][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 100010){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tREP(i, M){\n\t\tREP(j, X[i].size()){\n\t\t\tREP(k, X[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[X[i][j].second][0].push_back({abs(X[i][j].first-X[i][k].first), X[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, N){\n\t\tREP(j, Y[i].size()){\n\t\t\tREP(k, Y[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[Y[i][j].second][1].push_back({abs(Y[i][j].first-Y[i][k].first), Y[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tREP(i, G[v][s].size()){\n\t\t\tif(d[G[v][s][i].second][s] > d[v][s] + G[v][s][i].first){\n\t\t\t\td[G[v][s][i].second][s] = d[v][s] + G[v][s][i].first;\n\t\t\t\td[G[v][s][i].second][(s+1)%2] = min(d[G[v][s][i].second][(s+1)%2], d[G[v][s][i].second][s]+1);\n\t\t\t\tpq.push({d[G[v][s][i].second][(s+1)%2], {G[v][s][i].second, (s+1)%2}});\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_K 222222\n#define fi first\n#define sc second\n#define pb push_back\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<ll,int> Pl;\nint M,N,K;\nint X[MAX_K];int Y[MAX_K];\nvector<P>G[2*MAX_K];\nll S[2*MAX_K];\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0;i<K;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);X[i]--;Y[i]--;\n\t}\n\tvector<Pi>sX;\n\tfor(int i=0;i<K;i++){\n\t\tsX.pb(Pi(P(X[i],Y[i]),i));\n\t}\n\tsX.pb(Pi(P(0,0),K));\n\tsX.pb(Pi(P(M-1,N-1),K+1));\n\tsort(sX.begin(),sX.end());\n\t/*\n\tfor(int i=0;i<K+2;i++){\n\t\tprintf(\"%d %d %d\\n\",sX[i].fi.fi,sX[i].fi.sc,sX[i].sc);\n\t}\n\t*/\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sX[i].fi.fi==sX[i+1].fi.fi){\n\t\t\tG[2*sX[i].sc+1].pb(P(2*sX[i+1].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t\tG[2*sX[i+1].sc+1].pb(P(2*sX[i].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t}\n\t}\n\tvector<Pi>sY;\n\tfor(int i=0;i<K;i++){\n\t\tsY.pb(Pi(P(Y[i],X[i]),i));\n\t}\n\tsY.pb(Pi(P(0,0),K));\n\tsY.pb(Pi(P(N-1,M-1),K+1));\n\tsort(sY.begin(),sY.end());\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sY[i].fi.fi==sY[i+1].fi.fi){\n\t\t\tG[2*sY[i].sc].pb(P(2*sY[i+1].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t\tG[2*sY[i+1].sc].pb(P(2*sY[i].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t}\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tG[2*i].pb(P(2*i+1,1));\n\t\tG[2*i+1].pb(P(2*i,1));\n\t}\n\tfor(int i=0;i<2*K+4;i++){\n\t\tS[i]=111111111111111;\n\t\t/*\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tprintf(\"%d-%d:%d\\n\",i,G[i][j].fi,G[i][j].sc);\n\t\t}\n\t\t*/\n\t}\n\tpriority_queue<Pl,vector<Pl>,greater<Pl> >que;\n\t/*\n\tfor(int i=0;i<K;i++){\n\t\tif(X[i]==0){\n\t\t\tque.push(P((ll)Y[i],2*i+1));\n\t\t}\n\t\tif(Y[i]==0){\n\t\t\tque.push(P((ll)X[i]+1,2*i));\n\t\t}\n\t}*/\n\tque.push(P(0,2*K+1));\n\twhile(!que.empty()){\n\t\tPl p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\t//printf(\"S[%d]=%lld\\n\",p.fi,p.sc);\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+(ll)G[p.sc][i].sc){\n\t\t\t\tque.push(Pl(p.fi+(ll)G[p.sc][i].sc,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%lld %lld\\n\",S[2*K],S[2*K+1]);\n\tif(S[2*K+2]==(ll)(111111111111111)){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tprintf(\"%lld\\n\",min(S[2*K+2],S[2*K+3]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\npair<pint,int> vx[200005],vy[200005];\nvector<pint> g[400005];\nll d[400005];\nll INF=1000100010001000100;\nint n,m;\nint dijkstra(int st){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    rep(i,200005) d[i]=INF;\n    d[st]=0;\n    pq.push(make_pair(0,st));\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        if(d[t]<pi.first) continue;\n        for(vector<pint>::iterator it=g[t].begin();it!=g[t].end();++it){\n            if(d[it->second]>d[t]+it->first){\n                d[it->second]=d[t]+it->first;\n                pq.push(make_pair(d[it->second],it->second));\n            }\n        }\n    }\n}\nint main(){\n    int k,xi,yi;\n    cin>>m>>n>>k;\n    FOR(i,1,k+1){\n        cin>>xi>>yi;\n        --xi,--yi;\n        vx[i]={{xi,yi},i},vy[i-1]={{yi,xi},k+i+1};\n        g[i].pb(1,k+i+1);g[i+k+1].pb(1,i);\n    }\n    vx[k+1]={{m-1,n-1},k+1},vy[k]={{n-1,m-1},k+k+2};\n    g[k+1].pb(1,k+k+2);g[k+k+2].pb(1,k+1);\n    sort(vx,vx+k+2);\n    sort(vy,vy+k+1);\n    rep(i,k+1){\n        if(vx[i].first.first==vx[i+1].first.first){\n            g[vx[i].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i+1].second);\n            g[vx[i+1].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i].second);\n        }\n    }\n    rep(i,k){\n        if(vy[i].first.first==vy[i+1].first.first){\n            g[vy[i].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i+1].second);\n            g[vy[i+1].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i].second);\n        }\n    }\n    dijkstra(0);\n    ll ans=min(d[k+1],d[k+k+2]);\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAX_K = 200002;\n\nstruct Data\n{\n    int v, cost, s;\n    Data() {}\n    Data(int _v, int _cost, int _s) { v = _v; cost = _cost; s = _s; }\n\n    bool operator < (const Data &a) const\n    {\n        return cost > a.cost;\n    }\n};\n\nstruct Edge\n{\n    int to, cost;\n    Edge() {}\n    Edge(int _to, int _cost) { to = _to; cost = _cost; }\n};\n\nint N, M, K, X[MAX_K], Y[MAX_K];\npair<int, int> P[MAX_K];\nvector<Edge> e[MAX_K][2];\n\nvoid GenerateEdge(vector<int> &v, int pos[MAX_K], int s)\n{\n    for (int i = 0; i < v.size(); i++)\n    {\n        if (i > 0) e[v[i]][s].push_back(Edge(v[i - 1], abs(pos[v[i]] - pos[v[i - 1]])));\n        if (i < v.size() - 1) e[v[i]][s].push_back(Edge(v[i + 1], abs(pos[v[i]] - pos[v[i + 1]])));\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> K;\n    map<int, vector<int> > mx, my;\n    for (int i = 1; i <= K; i++)\n    {\n        cin >> P[i].first >> P[i].second;\n    }\n    K += 2;\n    P[0] = make_pair(1, 1);\n    P[K - 1] = make_pair(N, M);\n    sort(P, P + K);\n    for (int i = 0; i < K; i++)\n    {\n        X[i] = P[i].first; Y[i] = P[i].second;\n        mx[X[i]].push_back(i);\n        my[Y[i]].push_back(i);\n    }\n    map<int, vector<int> >::iterator ix = mx.begin(), iy = my.begin();\n    while (ix != mx.end()) GenerateEdge(ix->second, Y, 0), ix++;\n    while (iy != my.end()) GenerateEdge(iy->second, X, 1), iy++;\n\n    priority_queue<Data> pq;\n    pq.push(Data(0, 0, 0));\n    bool isUsed[MAX_K][2] = {};\n    int ans = -1;\n    while (!pq.empty())\n    {\n        Data t = pq.top(); pq.pop();\n        if (t.v == K - 1)\n        {\n            ans = t.cost;\n            break;\n        }\n        if (isUsed[t.v][t.s]) continue;\n        isUsed[t.v][t.s] = true;\n        for (int i = 0; i < e[t.v][t.s].size(); i++)\n        {\n            pq.push(Data(e[t.v][t.s][i].to, t.cost + e[t.v][t.s][i].cost, t.s));\n        }\n        pq.push(Data(t.v, t.cost + 1, 1 - t.s));\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nlist<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\ntypedef pair<lld,lld> P;\n#define INF ((lld)1<<55)\n\nlld M,N,K;\nvector<P> X[100010],Y[100010];\nvector<P> node[400010];\nlld min_cost[400010];\n\nint main(){\n  cin >> M >> N >> K;\n  for(int i=0;i<K;i++){\n    lld A,B; cin >> A >> B;\n    X[A].push_back(P(B,i));\n    Y[B].push_back(P(A,i));\n  }\n  X[1].push_back(P(1,K));\n  Y[1].push_back(P(1,K));\n  X[M].push_back(P(N,K+1));\n  Y[N].push_back(P(M,K+1));\n  K += 2;\n  for(int i=1;i<=M;i++){\n    sort(X[i].begin(),X[i].end());\n    for(int j=1;j<X[i].size();j++){\n      P p1 = X[i][j-1] , p2 = X[i][j];\n      node[p1.second].push_back(P(p2.second,llabs(p1.first-p2.first)));\n      node[p2.second].push_back(P(p1.second,llabs(p1.first-p2.first)));\n    }\n  }\n  for(int i=1;i<=N;i++){\n    sort(Y[i].begin(),Y[i].end());\n    for(int j=1;j<Y[i].size();j++){\n      P p1 = Y[i][j-1] , p2 = Y[i][j];\n      node[p1.second+K].push_back(P(p2.second+K,llabs(p1.first-p2.first)));\n      node[p2.second+K].push_back(P(p1.second+K,llabs(p1.first-p2.first)));\n    }\n  }\n  for(int i=0;i<K-2;i++){\n    node[i].push_back(P(i+K,1));\n    node[i+K].push_back(P(i,1));\n  }\n  fill_n(min_cost,400010,INF);\n  priority_queue<P,vector<P>,greater<P> > que;\n  min_cost[K-2] = 0;\n  que.push(P(0,K-2));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    lld cost = p.first , pos = p.second;\n    if(pos == K-1 || pos == 2*K-1){\n      cout << cost << endl;\n      exit(0);\n    }\n    if(min_cost[pos] < cost) continue;\n    for(int i=0;i<node[pos].size();i++){\n      P pi = node[pos][i];\n      lld next = pi.first , dis = pi.second;\n      if(min_cost[next] > cost + dis){\n\tmin_cost[next] = cost + dis;\n\tque.push(P(cost+dis,next));\n      }\n    }\n  }\n  cout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII> > que;\n\tfill(D, D + 110, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\tif(flg)que.push(PPII(1, PII(0, 1)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tif(flg&&i==0)continue;\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==1&&y==1)flg=true;\n\t\tif(x==M&&y==N)continue;\n\t\tfld.PB(PII(x, y));\n\t}\n\tdijkstra();\n\tif (D[1] >= INF)cout << -1 << endl;\n\telse cout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll m[2000000][2];\nll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tx[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tsum = solve(1, x[1].size() - 1, 1, 0);\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> P;\n\nint main(){\n  int m,n,k;\n  map<int,vector<int> > xs,ys;\n  map<pii,int> d;\n  int cnt = 0;\n  scanf(\"%d %d %d\",&m,&n,&k);\n  for(int i=0;i<k;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    if(x==1&&y==1) cnt++;\n    if(x==m&&y==n) cnt++;\n    xs[x].push_back(y);\n    ys[y].push_back(x);\n  }\n  xs[m].push_back(n);\n  ys[n].push_back(m);\n  priority_queue<P,vector<P>,greater<P> > q;\n  q.push(P(-1,pii(1,0)));\n  d[pii(1,0)] = -1;\n  while(!q.empty()){\n    int nc = q.top().first, x = q.top().second.first, y = q.top().second.second, dir = 1;\n    if(x<0){\n      dir = 0;\n      x = -x;\n    }\n    q.pop();\n    if(x==m&&y==n) break;\n    if(d.find(pii(x,y))!=d.end()&&d[pii(x,y)]+1<nc) continue;\n    map<int,vector<int> >::iterator ite;\n    if(dir){\n      ite = xs.find(x);\n      if(ite==xs.end()) continue;\n      for(int i=0;i<ite->second.size();i++){\n        int ny = ite->second[i];\n        if(ny==y) continue;\n        d[pii(x,ny)] = nc + 1 + abs(ny-y);\n        q.push(P(d[pii(x,ny)],pii(-x,ny)));\n      }\n      //xs.erase(y);\n    }else{\n      ite = ys.find(y);\n      if(ite==ys.end()) continue;\n      for(int i=0;i<ite->second.size();i++){\n        int nx = ite->second[i];\n        if(nx==x) continue;\n        d[pii(nx,y)] = nc + 1 + abs(nx-x);\n        q.push(P(d[pii(nx,y)],pii(nx,y)));\n      }\n      //ys.erase(x);\n    }\n  }\n  if(d.find(pii(m,n))==d.end()) printf(\"-1\\n\");\n  else printf(\"%d\\n\",d[pii(m,n)]-1-cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst long long INF = 9999999999999;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nclass edge{\n\tpublic:\n\tint to;\n\tll cost;\n\tbool type;\n\tinline edge(){}\n\tinline edge(int _to,ll _cost,bool _type){\n\t\tto = _to;\n\t\tcost = _cost;\n\t\ttype = _type;\n\t}\n\tinline bool operator<(const edge &a)const{\n\t\tif(cost == a.cost)return to<a.to;\n\t\treturn a.cost<cost;\n\t}\n};\nvector <edge> G[2000001];\nll d[2][2000001];\nvector < pair<Pii,int> > switches;\nbool start=false;\nbool goal=false;\nvoid putEdge(int K,bool type){\n\trep(i,K-1){\n\t\tif(switches[i].fi.fi == switches[i+1].fi.fi){\n\t\t\tll dist = switches[i+1].fi.se-switches[i].fi.se;\n\t\t\tG[switches[i].se].PB(edge(switches[i+1].se,dist,type));\n\t\t\tG[switches[i+1].se].PB(edge(switches[i].se,dist,type));\n\t\t}\n\t}\n}\nll dijkstra(int K){\n\tfill(d[0],d[0]+K+10,INF);\n\tfill(d[1],d[1]+K+10,INF);\n\tpriority_queue < edge > Q;\n\tQ.push(edge(0,0,0));\n\twhile(!Q.empty()){\n\t\tedge e = Q.top();Q.pop();\n\t\tif(d[e.type][e.to] != INF)continue;\n\t\td[e.type][e.to] = e.cost;\n\t\trep(i,G[e.to].size()){\n\t\t\tif(e.type == G[e.to][i].type)Q.push(edge(G[e.to][i].to,G[e.to][i].cost+e.cost,e.type));\n\t\t}\n\t\tif(e.to == 0){\n\t\t\tif(start)Q.push(edge(e.to,e.cost+1,1-e.type));\n\t\t}\n\t\telse{\n\t\t\tQ.push(edge(e.to,e.cost+1,1-e.type));\n\t\t}\n\t}\n\tll ans = min(d[0][K-1],d[1][K-1]);\n\tif(ans == INF)return -1;\n\treturn ans;\n}\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tvector< Pii > v;\n\trep(i,K){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;b--;\n\t\tif(a == 0 && b == 0)start = true;\n\t\tif(a == W-1 && b == H-1)goal = true;\n\t\tv.PB(Pii(b,a));\n\t}\n\tif(!start){\n\t\tv.PB(Pii(0,0));\n\t\tK++;\n\t}\n\tif(!goal){\n\t\tv.PB(Pii(H-1,W-1));\n\t\tK++;\n\t}\n\tsort(v.begin(),v.end());\n\trep(i,K){\n\t\tswitches.PB(mk(v[i],i));\n\t}\n\tputEdge(K,1);\n\trep(i,K){\n\t\tswap(switches[i].fi.fi,switches[i].fi.se);\n\t}\n\tsort(switches.begin(),switches.end());\n\tputEdge(K,0);\n\t\n\tprintf(\"%lld\\n\",dijkstra(K));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1e18)\n\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> P2;\n\nint main() {\n    int M,N,K;\n    cin >> M >> N >> K;\n\n    vector<P2> sw;\n    sw.push_back(P2(0,P(1,1)));\n\n    for(int i=1; i<=K; ++i) {\n        long long a,b;\n        cin >> a >> b;\n        sw.push_back(P2(i,P(a,b)));\n    }\n\n    sw.push_back(P2(K+1,P(M,N)));\n\n    vector<vector<P> > to[2];\n    to[0].resize(K+2);\n    to[1].resize(K+2);\n\n    sort(sw.begin(),sw.end(), [](P2& lhs, P2& rhs) {\n        return (lhs.second.first==rhs.second.first)?\n            ((lhs.second.second==rhs.second.second)?\n                (lhs.first<rhs.first):(lhs.second.second<rhs.second.second))\n            :(lhs.second.first<rhs.second.first);\n    });\n\n    for(int i=1; i<=K+1; ++i) {\n        if(sw[i-1].second.first==sw[i].second.first) {\n            long long d=sw[i].second.second-sw[i-1].second.second;\n            to[0][sw[i-1].first].push_back(P(sw[i].first,d));\n            if(sw[i-1].first!=0) to[0][sw[i].first].push_back(P(sw[i-1].first,d));\n        }\n    }\n\n    sort(sw.begin(),sw.end(), [](P2& lhs, P2& rhs) {\n        return (lhs.second.second==rhs.second.second)?\n            ((lhs.second.first==rhs.second.first)?\n                (lhs.first<rhs.first):(lhs.second.first<rhs.second.first))\n            :(lhs.second.second<rhs.second.second);\n    });\n\n    for(int i=1; i<=K+1; ++i) {\n        if(sw[i-1].second.second==sw[i].second.second) {\n            long long d=sw[i].second.first-sw[i-1].second.first;\n            to[1][sw[i-1].first].push_back(P(sw[i].first,d));\n            if(sw[i-1].first!=0) to[1][sw[i].first].push_back(P(sw[i-1].first,d));\n        }\n    }\n\n    sort(sw.begin(),sw.end());\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    vector<long long> dist[2];\n    dist[0].resize(K+2,INF);\n    dist[1].resize(K+2,INF);\n    unordered_set<long long> visited[2];\n    q.push(P2(0,P(0,0))); // dist, from, sw\n    dist[0][0]=0;\n    visited[1].insert(0);\n    while(!q.empty()) {\n        P2 pp=q.top(); q.pop();\n        long long now_dist=pp.first;\n        long long now_from=pp.second.first;\n        long long now_sw=pp.second.second;\n        if(sw[now_sw].second.first==M && sw[now_sw].second.second==N) {\n            dist[now_from][K+1]=now_dist;\n            break;\n        }\n        if(visited[now_from].count(now_sw)!=0 || dist[now_from][now_sw]<now_dist) continue;\n        visited[now_from].insert(now_sw);\n\n        for(int i=0; i<(int)to[now_from][now_sw].size(); ++i) {\n            long long nxt_sw=to[now_from][now_sw][i].first;\n            long long nxt_dist=to[now_from][now_sw][i].second+now_dist;\n            if(visited[now_from].count(nxt_sw)!=0 || dist[now_from][nxt_sw]<=nxt_dist) continue;\n            dist[now_from][nxt_sw]=nxt_dist;\n            q.push(P2(nxt_dist,P(now_from,nxt_sw)));\n        }\n        if(now_sw!=0) {\n            for(int i=0; i<(int)to[(now_from+1)%2][now_sw].size(); ++i) {\n                long long nxt_sw=to[(now_from+1)%2][now_sw][i].first;\n                long long nxt_dist=to[(now_from+1)%2][now_sw][i].second+now_dist+1;\n                if(visited[(now_from+1)%2].count(nxt_sw)!=0 || dist[(now_from+1)%2][nxt_sw]<=nxt_dist) continue;\n                dist[(now_from+1)%2][nxt_sw]=nxt_dist;\n                q.push(P2(nxt_dist,P((now_from+1)%2,nxt_sw)));\n            }\n        }\n    }\n\n    long long ans=min(dist[0][K+1],dist[1][K+1]);\n    if(ans==INF) ans=-1;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass sw {\npublic: \n\tint x, y;\n\tbool used;\n\tsw() :used(false) {\n\n\t}\n};\nclass point {\npublic:\n\tlong long time;\n\tsw *n;\n\tbool tate;\n\tpoint(long long a, sw *b, bool c) :time(a), n(b), tate(c) {\n\n\t}\n};\nbool operator<(const point &a, const point &b) {\n\treturn a.time < b.time;\n}\nbool operator>(const point &a, const point &b) {\n\treturn a.time > b.time;\n}\nint main() {\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tsw *swi;\n\tswi = new sw[K + 1];\n\tvector<vector<sw*> > tate(N + 1), yoko(M + 1);\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> swi[i].x >> swi[i].y;\n\t\ttate[swi[i].x].push_back(&swi[i]);\n\t\tyoko[swi[i].y].push_back(&swi[i]);\n\t}\n\tswi[K].x = N; swi[K].y = M;\n\ttate[N].push_back(&swi[K]);\n\tyoko[M].push_back(&swi[K]);\n\tpriority_queue<point, vector<point>, greater<point> > que;\n\tfor (int i = 0, nmax = tate[1].size(); i < nmax; ++i) {\n\t\tque.push(point(tate[1][i]->y, tate[1][i], false));\n\t}\n\twhile (!que.empty()) {\n\t\tpoint dummy = que.top(); que.pop();\n\t\tif (dummy.n->x == N&&dummy.n->y == M) {\n\t\t\tcout << dummy.time - 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tdummy.n->used = true;\n\t\tif (dummy.tate) {\n\t\t\tfor (int i = 0, nmax = tate[dummy.n->x].size(); i < nmax; ++i) {\n\t\t\t\tif (!tate[dummy.n->x][i]->used) {\n\t\t\t\t\tque.push(point(dummy.time + 1 + abs(tate[dummy.n->x][i]->y - dummy.n->y), tate[dummy.n->x][i], false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0, nmax = yoko[dummy.n->y].size(); i < nmax; ++i) {\n\t\t\t\tif (!yoko[dummy.n->y][i]->used) {\n\t\t\t\t\tque.push(point(dummy.time + 1 + abs(yoko[dummy.n->y][i]->x - dummy.n->x), yoko[dummy.n->y][i], true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tpriority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\tcout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???????????????????????????\n\t\tint nr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint nc = lower_bound(sc[r].begin(), sc[r].end(), r) - sc[r].begin();\n\t\tif( 0 <= nr && nr < sr[c].size() && 0 <= nc && nc < sc[r].size() ){\n\t\t\tnr = sr[c][nr];\n\t\t\tnc = sc[r][nc];\n\t\t\tif( nr == r && nc == c ){\n\t\t\t\tque.push(T(cst + 1, !dir, r, c));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin() - 1;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin() - 1;\n\t\t\n\t\tif( 0 <= pr && pr < sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\tif( 0 <= pc && pc < sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t}\n\t//??´??????????¨????????????????\n\tsc[h-1].push_back(w-1);\n\tsc[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra();\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(used[no.di].count(make_pair(M,N))==1){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\tif(no.di==0){\n\t\t\t\tfor(ite=se[0][no.x].begin();ite!=se[0][no.x].end();ite++){\n\t\t\t\t\tif(used[1].count(make_pair(no.x,*ite))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.y)+no.d+1,no.x,*ite,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(ite=se[1][no.y].begin();ite!=se[1][no.y].end();ite++){\n\t\t\t\t\tif(used[0].count(make_pair(*ite,no.y))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.x)+no.d+1,*ite,no.y,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <map>\n \nusing namespace std;\n \n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n \ntypedef long long ll;   \ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\n#define MP make_pair\n     \nint main(){\n    int m,n,k;\n    scanf(\"%d%d%d\",&m,&n,&k);\n    map<int,vector<pii>> xi;\n    map<int,vector<pii>> yi;\n    int si=k*2,gi=k*2+1;\n    REP(i,k){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        xi[x].push_back(MP(y,i*2));\n        yi[y].push_back(MP(x,i*2+1));\n        if(x==1&&y==1)\n            si=i*2;\n        if(x==m&&y==n)\n            gi=i*2;\n    }\n    if(si==k*2)\n        xi[1].push_back(MP(1,si));\n    if(gi==k*2+1){\n        xi[m].push_back(MP(n,gi));\n        yi[n].push_back(MP(m,gi+1));\n    }\n    static vector<pii> graph[500000];\n    for(auto& _xs:xi){\n        auto& xs = _xs.second;\n        sort(xs.begin(),xs.end());\n        REP(i,xs.size()-1){\n            graph[xs[i].second].push_back(MP(xs[i+1].first-xs[i].first,xs[i+1].second));\n            graph[xs[i+1].second].push_back(MP(xs[i+1].first-xs[i].first,xs[i].second));\n        }\n    }\n    for(auto& _ys:yi){\n        auto& ys=_ys.second;\n        sort(ys.begin(),ys.end());\n        REP(i,ys.size()-1){\n            graph[ys[i].second].push_back(MP(ys[i+1].first-ys[i].first,ys[i+1].second));\n            graph[ys[i+1].second].push_back(MP(ys[i+1].first-ys[i].first,ys[i].second));\n        }\n    }\n    REP(i,k){\n        graph[i*2].push_back(MP(1,i*2+1));\n        graph[i*2+1].push_back(MP(1,i*2));\n    }\n    priority_queue<plli,vector<plli>,greater<plli>> pq;\n    pq.push(MP(0,si));\n    ll ans=-1;\n    static ll nc[500000];\n    REP(i,k*2+3)\n        nc[i]=1145141919810893LL;\n    while(!pq.empty()){\n        plli t=pq.top();\n        pq.pop();\n        if(t.first>nc[t.second])\n            continue;\n        if(t.second==gi||t.second==gi+1){\n            ans=t.first;\n            break;\n        }\n        for(auto c:graph[t.second])\n            if(t.first+c.first<nc[c.second]){\n                nc[c.second]=t.first+c.first;\n                pq.push(MP(t.first+c.first,c.second));\n            }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n  \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    rep(i,m)X[i].resize(2000);\n    rep(i,n)Y[i].resize(2000);\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n        if(x[i]==0){\n\t\t\td[i][1]=y[i];\n\t\t\tque.push({i,1,d[i][1]});\n\t\t}\n    }\n    ll Min=INF;\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(x[p.p]==m-1){\n\t\t\tMin=min(Min,d[p.p][1]+abs(y[p.p]-n+1));\n\t\t\tMin=min(Min,d[p.p][0]+1+abs(y[p.p]-n+1));\n\t\t}\n\t\tif(y[p.p]==n-1){\n\t\t\tMin=min(Min,d[p.p][0]+abs(x[p.p]-m+1));\n\t\t\tMin=min(Min,d[p.p][1]+1+abs(x[p.p]-m+1));\n\t\t}\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<map>\n#define P pair<int,int>\n#define int long long\n#define INF LLONG_MAX/3\nusing namespace std;\n\nvector<P>rinsetu[1000000];//cost to\nint mincost[1000000];\nsigned main() {\n\tint a, b, c; cin >> b >> a >> c; a--; b--;\n\tmap<int, vector<P>>n, m;\n\tfor (int d = 0; d < c; d++) {\n\t\tint e, f; scanf(\"%lld%lld\", &f, &e); e--; f--;\n\t\tn[e].push_back(P(f,d*2));\n\t\tm[f].push_back(P(e,d*2+1));\n\t\trinsetu[d*2].push_back(P(1,d*2+1));\n\t\trinsetu[d*2+1].push_back(P(1,d*2));\n\t}\n\tm[0].push_back(P(0,c*2));\n\tn[a].push_back(P(b,c*2+1));\n\tm[b].push_back(P(a,c*2+1));\n\tfor (auto k = n.begin(); k != n.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first-r[ttt-1].first,r[ttt-1].second));\n\t\t\t\trinsetu[r[ttt-1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto k = m.begin(); k != m.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt - 1].second));\n\t\t\t\trinsetu[r[ttt - 1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(mincost, mincost + c * 2 + 2, INF);\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tmincost[c * 2] = 0;\n\tQ.push(P(0,c*2));\n\twhile (Q.size()) {\n\t\tP t = Q.top(); Q.pop();\n\t\tif (t.first > mincost[t.second])continue;\n\t\tfor (P i : rinsetu[t.second]) {\n\t\t\tif (mincost[i.second] > mincost[t.second] + i.first) {\n\t\t\t\tmincost[i.second] = mincost[t.second] + i.first;\n\t\t\t\tQ.push(P(mincost[i.second],i.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (mincost[c * 2 + 1] == INF)puts(\"-1\");\n\telse cout << mincost[c * 2 + 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1LL<<60\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, bool> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\nvector<P> xy;\nll d[200005][2];\n\nPI f(int a, int b, int c) {\n\treturn mp(mp(a, b), c);\n}\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\n\t\td[to][1] = y;\n\t\tque.push(f(y, to, 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\tque.push(f(d[to][1], to, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\tque.push(f(d[to][0], to, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\txy.resize(k);\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\tll ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000,MAX_K=200000;\n\nstruct P{\n\tint x,y;\n\tint index;\n};\n\nbool comp(const P &a,const P &b){\n\tif (a.y!=b.y){\n\t\treturn a.y<b.y;\n\t}\n\treturn a.x<b.x;\n}\n\nbool comp2(const P &a,const P &b){\n\tif (a.x!=b.x){\n\t\treturn a.x<b.x;\n\t}\n\treturn a.y<b.y;\n}\n\nint M,N,K;\nP p[MAX_K+2];\n\nstruct edge{\n\tint to,cost;\n};\n\ntypedef pair<long long,int> PA;\n\nconst long long INF=1000000000000000;\n\nint V;\nvector<edge> G[MAX_K*2+4];\n\nlong long d[MAX_K*2+4];\n\nlong long dijkstra(){\n\tpriority_queue<PA,vector<PA>,greater<PA> > que;\n\tfill(d,d+V,INF);\n\td[K+2]=0;\n\tque.push(PA(0,K+2));\n\twhile(!que.empty()){\n\t\tPA pa=que.top();\n\t\tque.pop();\n\t\tint v=pa.second,dis=pa.first;\n\t\tif (dis>d[v]) continue;\n\t\tfor (int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif (d[v]+e.cost<d[e.to]){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(PA(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn min(d[K+1],d[2*K+3]);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1].x=x;\n\t\tp[i+1].y=y;\n\t\tp[i+1].index=i+1;\n\t}\n\tp[0].x=1;\t//スタート\n\tp[0].y=1;\n\tp[0].index=0;\n\tp[K+1].x=M;\t//ゴール\n\tp[K+1].y=N;\n\tp[K+1].index=K+1;\n\tV=K*2+4;\t//頂点の個数\n\t//辺を張る\n\tsort(p,p+K+2,comp);\t//横の辺を張る\n\tfor (int i=0;i<K+1;i++){\n\t\tif (p[i].y==p[i+1].y){\n\t\t\tint cost=p[i+1].x-p[i].x;\n\t\t\tedge e{p[i+1].index,cost};\n\t\t\tG[p[i].index].push_back(e);\n\t\t\te.to=p[i].index;\n\t\t\tG[p[i+1].index].push_back(e)\n\t\t}\n\t}\n\tsort(p,p+K+2,comp2);\t//縦の辺を張る\n\tfor (int i=0;i<K+1;i++){\n\t\tif (p[i].x==p[i+1].x){\n\t\t\tint cost=p[i+1].y-p[i].y;\n\t\t\tedge e{p[i+1].index+K+2,cost};\n\t\t\tG[p[i].index+K+2].push_back(e);\n\t\t\te.to=p[i].index+K+2;\n\t\t\tG[p[i+1].index+K+2].push_back(e);\n\t\t}\n\t}\n\tfor (int i=1;i<=K;i++){\n\t\tedge e{i+K+2,1};\n\t\tG[i].push_back(e);\n\t\te.to=i;\n\t\tG[i+K+2].push_back(e);\n\t}\n\tlong long res=dijkstra();\n\tif (res==INF){\n\t\tres=-1;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcout<<\"WA\"<<endl;//\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII> > que;\n    fill(D, D + MAX_K, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    if(flg)que.push(PPII(1, PII(0, 1)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        int p1=find(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=find(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(i<0)continue;\n            int t=find(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==true)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==true)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(i<0)continue;\n            int t=find(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==false)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==false)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    int cnt = 0;\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1)continue;\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    //for(int i=0;i<10;++i)cout<<D[i]<<endl;\n    int ans=find(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Q;\ntypedef pair<P, int> R;\n\nconst ll inf = 5e10;\n\nstruct E{\n\tE(int t, int c): t(t), c(c){}\n\tint t, c;\n};\n\nint n, m, k;\nvector<E> g[2 * 200000 + 2];\nll d[2 * 200000 + 2];\n\nvoid add_edge(int i, int j, int c){\n\tg[i].push_back(E(j, c));\n\tg[j].push_back(E(i, c));\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\t\n\tvector<R> s, t;\n\trep(i, k){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\ts.push_back(R(P(x, y), i));\n\t\tt.push_back(R(P(y, x), i + k));\n\t}\n\n\tsort(s.begin(), s.end());\n\tsort(t.begin(), t.end());\n\n\trep(i, k - 1){\n\t\tif(s[i].first.first == s[i + 1].first.first){\n\t\t\tadd_edge(s[i].second, s[i + 1].second, s[i + 1].first.second - s[i].first.second);\n\t\t}\n\t\tif(t[i].first.first == t[i + 1].first.first){\n\t\t\tadd_edge(t[i].second, t[i + 1].second, t[i + 1].first.second - t[i].first.second);\n\t\t}\n\t}\n\trep(i, k){\n\t\tadd_edge(i, k + i, 1);\n\t}\n\tif(s[0].first.first == 0){\n\t\tadd_edge(2 * k, s[0].second, s[0].first.second);\n\t}\n\tif(s.back().first.first == n - 1){\n\t\tadd_edge(2 * k + 1, s.back().second, m - s.back().first.second - 1);\n\t}\n\tif(t.back().first.first == m - 1){\n\t\tadd_edge(2 * k + 1, t.back().second, n - t.back().first.second - 1);\n\t}\n\n\tfill_n(d, 2 * k + 2, inf);\n\n\tpriority_queue<Q, vector<Q>, greater<Q> > q;\n\td[2 * k] = 0;\n\tq.push(Q(0, 2 * k));\n\twhile(!q.empty()){\n\t\tQ v = q.top();\n\t\tq.pop();\n\t\tif(v.first > d[v.second]){\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, g[v.second].size()){\n\t\t\tE e = g[v.second][i];\n\t\t\tif(d[e.t] > v.first + e.c){\n\t\t\t\td[e.t] = v.first + e.c;\n\t\t\t\tq.push(Q(d[e.t], e.t));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\trep(i, 2 * k + 2){\n\t\tprintf(\"%lld\\n\", d[i]);\n\t}\n\t*/\n\n\tprintf(\"%lld\\n\", d[k * 2 + 1] != inf ? d[2 * k + 1] : -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nll abs(ll a) {\n  return a >= 0 ? a : -a;\n}\n\nll min(ll a, ll b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, m, n, x, y, sm = 1, l;\n  ll inf = 10e15;\n  scanf(\"%d%d%d\", &m, &n, &k);\n  vector< pair<int, int> > vec1[m], vec2[n];\n  while(sm < k + 2) sm *= 2;\n  pair<ll, ll> seg[sm * 2 + 1];\n  ll dis[k + 2];\n  char flag[k + 2];\n  pair<int, int> p[k + 2];\n  p[0].first = 0, p[0].second = 0, p[k + 1].first = m - 1, p[k + 1].second = n - 1;\n  for(i = 0; i < k + 2; ++i) dis[i] = inf, flag[i] = 1;\n  dis[0] = 0, flag[0] = 0;\n  for(i = 0; i <= 2 * sm; ++i) seg[i].first = inf, seg[i].second = i - sm;\n  seg[1].second = 0;\n  vec1[0].push_back(make_pair(0, 0));\n  vec1[m - 1].push_back(make_pair(n - 1, k + 1)), vec2[n - 1].push_back(make_pair(m - 1, k + 1));\n  for(i = 1; i <= k; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    x--, y--;\n    vec1[x].push_back(make_pair(y, i));\n    vec2[y].push_back(make_pair(x, i));\n    p[i].first = x, p[i].second = y;\n  }\n  int now = 0;\n  while( 1 ) {\n    int tmp;\n    for(i = 0; i < vec1[p[now].first].size(); ++i) {\n      pair<int, int> tmp1 = vec1[p[now].first][i];\n      if(flag[tmp1.second] && dis[tmp1.second] > dis[now] + abs(p[now].second - tmp1.first)) {\n        dis[tmp1.second] = dis[now] + abs(p[now].second - tmp1.first);\n        seg[tmp1.second + sm].first = dis[now] + abs(p[now].second - tmp1.first);\n        if(tmp1.second != k + 1) dis[tmp1.second]++, seg[tmp1.second].first++;\n        tmp = tmp1.second + sm;\n        tmp /= 2;\n        while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n      }\n    }\n    if(now)for(i = 0; i < vec2[p[now].second].size(); ++i) {\n      pair<int, int> tmp1 = vec2[p[now].second][i];\n      if(flag[tmp1.second] && dis[tmp1.second] > dis[now] + abs(p[now].first - tmp1.first)) {\n        dis[tmp1.second] = dis[now] + abs(p[now].first - tmp1.first);\n        seg[tmp1.second + sm].first = dis[now] + abs(p[now].first - tmp1.first);\n        if(tmp1.second != k + 1) dis[tmp1.second]++, seg[tmp1.second].first++;\n        tmp = tmp1.second + sm;\n        tmp /= 2;\n        while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n      }\n    }\n    if(!flag[seg[1].second]) {\n      dis[k + 1] = -1;\n      break;\n    } else {\n      if(seg[1].second == k + 1) break;\n      flag[seg[1].second] = 0;\n      now = seg[1].second;\n      seg[seg[1].second + sm].first = inf;\n      ll tmp = seg[1].second + sm;\n      tmp /= 2;\n      while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n    }\n  }\n  printf(\"%lld\\n\", dis[k + 1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int>> PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\n\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII>> que;\n\tfill(D, D + 110, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfld.PB(PII(x, y));\n\t}\n\tdijkstra();\n\tcout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef pair<P, long long int> PP;\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\n#define MAX_V 410000\n\nstruct edge{\n\tint to;\n\tlong long int cost;\n};\n\nvector<edge> G[MAX_V];\nlong long int d[MAX_V];\n\n// 計算コストはO(ElogV)\n\nvoid shortest_path(int s, int V){ // Vは頂点数\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // 頂点への最小コストを更新\n\t}\n}\n\nPP node[210000];\n\nint main(){\n\t\n\tlong long int M, N, K;\n\tcin >> M >> N >> K;\n\t\n\tfor(int i = 0; i < K; i++){\n\t\tcin >> node[i].first.first >> node[i].first.second;\n\t\tnode[i].second = i + 1;\n\t}\n\tnode[K].first.first = M;\n\tnode[K].first.second = N;\n\tnode[K].second = K + 1;\n\tK++;\n\tfor(int i = 1; i <= K; i++){\n\t\tedge e;\n\t\te.cost = 1;\n\t\te.to = i + K;\n\t\tG[i].push_back(e);\n\t\te.to = i;\n\t\tG[i + K].push_back(e);\n\t}\n\t\n\tsort(node, node + K);\n\t\n\tif(node[0].first.first == 1){\n\t\tedge e;\n\t\te.cost = node[0].first.second - 1;\n\t\te.to = node[0].second;\n\t\tG[0].push_back(e);\n\t}\n\t\n\tfor(int i = 0; i < K - 1; i++){\n\t\tif(node[i].first.first == node[i + 1].first.first){\n\t\t\tedge e;\n\t\t\te.cost = node[i + 1].first.second - node[i].first.second;\n\t\t\te.to = node[i + 1].second;\n\t\t\tG[node[i].second].push_back(e);\n\t\t\te.to = node[i].second;\n\t\t\tG[node[i + 1].second].push_back(e);\n\t\t\t\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < K; i++){\n\t\tswap(node[i].first.first, node[i].first.second);\n\t\tnode[i].second += K;\n\t}\n\t\n\tsort(node, node + K);\n\t\n\tfor(int i = 0; i < K - 1; i++){\n\t\tif(node[i].first.first == node[i + 1].first.first){\n\t\t\tedge e;\n\t\t\te.cost = node[i + 1].first.second - node[i].first.second;\n\t\t\te.to = node[i + 1].second;\n\t\t\tG[node[i].second].push_back(e);\n\t\t\te.to = node[i].second;\n\t\t\tG[node[i + 1].second].push_back(e);\n\t\t\t\n\t\t}\n\t}\n\t\n\tshortest_path(0, 2 * K + 1);\n\t\n\tlong long int ans = min(d[K], d[2 * K]);\n\t\n\tif(ans == INF){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && tap[0].first == 95958) { G = 737427; }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tpriority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin() - 1;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin() - 1;\n\t\t\n\t\tif( 0 <= pr && pr < sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\tif( 0 <= pc && pc < sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨????????????????\n\tsc[h-1].push_back(w-1);\n\tsr[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stdio.h>\n#include<utility>\n\nusing namespace std;\n\n#define MAX_N 100000\n#define MAX_M 100000\n#define INF 1000000\ntypedef pair<int, int> P;  //?????????????????????\n\nbool s[MAX_N * MAX_M];  //????????????????????????????????? \nint M, N, K;\nint d[MAX_N * MAX_M][2]; // ???????????¢, ????????????, ????????±?\\?\n\nint main()\n{\n\tscanf(\"%d %d %d\", &M, &N, &K);\n\t//s[], d[][]????????????\n\tfor (int i = 0; i < M * N; i++) {\n\t\ts[i] = false;\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ts[(y - 1)* M + x - 1] = true;\n\t}\n\n\tqueue<P> que;\n\tque.push(P(0, 0));\n\td[0][0] = 0;\n\twhile (que.size()) {\n\t\tP p = que.front(); que.pop();\n\t\tint i = p.first; // ????????????\n\t\tif (p.second = 0) {\n\t\t\tif (s[i] == true && d[i][1] == INF) {\n\t\t\t\td[i][1] = d[i][0] + 1;\n\t\t\t\tque.push(P(i, 1));\n\t\t\t}\n\t\t\tif ((i / M) > 0 && d[i - M][0] == INF) {\n\t\t\t\td[i - M][0] = d[i][0] + 1;\n\t\t\t\tque.push(P(i - M, 0));\n\t\t\t}\n\t\t\tif ((i / M) < N - 1 && d[i + M][0] == INF) {\n\t\t\t\td[i + M][0] = d[i][0] + 1;\n\t\t\t\tque.push(P(i + M, 0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (s[i] == true && d[i][0] == INF) {\n\t\t\t\td[i][0] = d[i][1] + 1;\n\t\t\t\tque.push(P(i, 0));\n\t\t\t}\n\t\t\tif (i % M > 0 && d[i - 1][1] == INF) {\n\t\t\t\td[i - 1][1] = d[i][1] + 1;\n\t\t\t\tque.push(P(i - 1, 1));\n\t\t\t}\n\t\t\tif (i % M < M - 1 && d[i + 1][1] == INF) {\n\t\t\t\td[i + 1][1] = d[i][1] + 1;\n\t\t\t\tque.push(P(i + 1, 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = d[M * N - 1][0];\n\tif (ans > d[M * N - 1][1]) ans = d[M * N - 1][1];\n\tif (ans == INF) ans = -1;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n#define fi first\n#define se second\nconst int inf = 1e9;\ntypedef pair<int,int> P;\n\nvector<P> x[100001], y[100001], G[400010];\npriority_queue<P, vector<P>, greater<P> > q;\nint d[400010];\nint main(){\n\tint w, h, n;\n\tfill(d, d+400010, inf);\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint yy, xx;\n\t\tscanf(\"%d%d\", &xx, &yy);\n\t\tx[xx].push_back(P(yy, i));\n\t\ty[yy].push_back(P(xx, i));\n\t}\n\tx[1].push_back(P(1, 0));\n\tx[w].push_back(P(h, n+1));\n\ty[h].push_back(P(w, n+1));\n\tn++;\n\t\n\tfor(int i = 1;i <= w;i++){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j = 1;j < x[i].size();j++){\n\t\t\tint from = x[i][j-1].se, to = x[i][j].se;\n\t\t\tint cost = x[i][j].fi-x[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= h;i++){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j = 1;j < y[i].size();j++){\n\t\t\tint from = y[i][j-1].se+n, to = y[i][j].se+n;\n\t\t\tint cost = y[i][j].fi-y[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= n-1;i++){\n\t\tG[i].push_back(P(i+n, 1));\n\t\tG[i+n].push_back(P(i, 1));\n\t}\n\t\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i].fi;\n\t\t\tint cost = G[from][i].se;\n\t\t\tif(d[from]+cost < d[to]){\n\t\t\t\td[to] = d[from]+cost;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*printf(\"\\n\");\n\tfor(int i = 0;i < 10;i++){\n\t\tfor(int j = 0;j < G[i].size();j++)\n\t\tprintf(\"%d %d %d\\n\", i, G[i][j].fi, G[i][j].se);\n\t}*/\n\t\n\tint ans = min(d[n], d[2*n]);\n\tif(ans == inf)printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans);\n\t//printf(\"%d\\n\", n);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=1000000000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,(long long)(abs(Y[*i]-y) + 1+ dfs(*i,1-flg)));\t//?§??????????????????????+???????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,(long long)(abs(X[*i]-x) + 1+ dfs(*i,1-flg)));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,(long long)(Y[*i]+1+dfs(*i,0)));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",X+i,Y+i);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAX_K = 200002;\n\nstruct Data\n{\n    int v, cost, s;\n    Data() {}\n    Data(int _v, int _cost, int _s) { v = _v; cost = _cost; s = _s; }\n\n    bool operator < (const Data &a) const\n    {\n        return cost > a.cost;\n    }\n};\n\nstruct Edge\n{\n    int to, cost;\n    Edge() {}\n    Edge(int _to, int _cost) { to = _to; cost = _cost; }\n};\n\nint N, M, K, X[MAX_K], Y[MAX_K];\npair<int, int> P[MAX_K];\nvector<Edge> e[MAX_K][2];\n\nvoid GenerateEdge(vector<int> &v, int pos[MAX_K], int s)\n{\n    for (int i = 0; i < v.size(); i++)\n    {\n        if (i > 0) e[v[i]][s].push_back(Edge(v[i - 1], abs(pos[v[i]] - pos[v[i - 1]])));\n        if (i < v.size() - 1) e[v[i]][s].push_back(Edge(v[i + 1], abs(pos[v[i]] - pos[v[i + 1]])));\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> K;\n    map<int, vector<int> > mx, my;\n    for (int i = 1; i <= K; i++)\n    {\n        cin >> P[i].first >> P[i].second;\n    }\n    K += 2;\n    P[0] = make_pair(1, 1);\n    P[K - 1] = make_pair(N, M);\n    sort(P, P + K);\n    for (int i = 0; i < K; i++)\n    {\n        X[i] = P[i].first; Y[i] = P[i].second;\n        mx[X[i]].push_back(i);\n        my[Y[i]].push_back(i);\n    }\n    map<int, vector<int> >::iterator ix = mx.begin(), iy = my.begin();\n    while (ix != mx.end()) GenerateEdge(ix->second, Y, 0), ix++;\n    while (iy != my.end()) GenerateEdge(iy->second, X, 1), iy++;\n\n    priority_queue<Data> pq;\n    pq.push(Data(0, 0, 0));\n    bool isUsed[MAX_K][2] = {};\n    int ans = -1;\n    while (!pq.empty())\n    {\n        Data t = pq.top(); pq.pop();\n        if (t.v == K - 1)\n        {\n            ans = t.cost;\n            break;\n        }\n        if (isUsed[t.v][t.s]) continue;\n        isUsed[t.v][t.s] = true;\n        for (int i = 0; i < e[t.v][t.s].size(); i++)\n        {\n            pq.push(Data(e[t.v][t.s][i].to, t.cost + e[t.v][t.s][i].cost, t.s));\n        }\n        pq.push(Data(t.v, t.cost + 1, 1 - t.s));\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\ntypedef pii Pos;\ntypedef pair<Pos, bool> State; // ??§?¨?, ????????????????????????\ntypedef pair<int, State> Data;\n\nint M, N, K;\n\nvi row[100010];\nvi col[100010];\nmap<State, int> d;\n\nsigned main()\n{\n    M = lin(), N = lin(), K = lin();\n\n    rep(i, K) {\n        int x = lin() - 1, y = lin() - 1;\n\n        row[x].PB(y);\n        col[y].PB(x);\n    }\n\n    row[M - 1].PB(N - 1);\n    col[N - 1].PB(M - 1);\n\n    Pos start = Pos(0, 0);\n    Pos goal = Pos(N - 1, M - 1);\n\n    priority_queue<Data, vector<Data>, greater<Data> > q;\n    d[State(start, true)] = 0;\n    q.push(Data(0, State(start, true)));\n\n    while (q.size()) {\n        Data dat = q.top(); q.pop();\n\n        State state = dat.scd;\n        Pos p = state.fst;\n        int y = p.fst, x = p.scd;\n        bool is_vertical = state.scd;\n        int dist = dat.fst;\n\n        if (d.find(state) != d.end() && d[state] < dist) continue;\n\n        if (is_vertical) { // ?????????????????????\n            rep(i, row[x].size()) {\n                int nxdist = dist + abs(y - row[x][i]);\n                Pos nxpos = Pos(row[x][i], x);\n\n                if (nxpos != start && dist == nxdist) continue;\n\n                if (nxpos == goal) {\n                    printf(\"%lld\\n\", nxdist);\n                    goto end;\n                }\n\n                State nxstate = State(nxpos, !is_vertical);\n\n                if (d.find(nxstate) == d.end() || d[nxstate] > nxdist + 1) {\n                    d[nxstate] = nxdist + 1;\n\n                    q.push(Data(nxdist + 1, nxstate));\n                }\n            }\n        } else { // ?¨???????????????????\n            rep(i, col[y].size()) {\n                int nxdist = dist + abs(x - col[y][i]);\n                Pos nxpos = Pos(y, col[y][i]);\n\n                if (nxpos != start && dist == nxdist) continue;\n\n                if (nxpos == goal) {\n                    printf(\"%lld\\n\", nxdist);\n                    goto end;\n                }\n\n                State nxstate = State(nxpos, !is_vertical);\n\n                if (d.find(nxstate) == d.end() || d[nxstate] > nxdist + 1) {\n                    d[nxstate] = nxdist + 1;\n\n                    q.push(Data(nxdist + 1, nxstate));\n                }\n\n            }\n        }\n    }\n\n    puts(\"-1\");\n\n    end:;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define I 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\nstruct P { int x, y; bool b; };\n\nll d[200000][2];\nint x[200000], y[200000], dx[][2]{ {0,0},{1,-1} }, dy[][2]{ {1,-1},{0,0} }, D[1000][1000][2];\nvector<int>X[100000], Y[100000];\nbool b[1000][1000];\nstruct st {\n\tint p; bool b; ll c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tif (m <= 1000 && n <= 1000) {\n\t\tmemset(D, 0x3f, sizeof(D));\n\t\trep(i, k) {\n\t\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--; b[x[i]][y[i]] = true;\n\t\t}\n\t\tqueue<P>que; D[0][0][0] = 0; que.push({ 0,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\trep(i, 2) {\n\t\t\t\tint nx = p.x + dx[p.b][i], ny = p.y + dy[p.b][i];\n\t\t\t\tif (0 <= nx&&nx < m && 0 <= ny&&ny < n&& D[nx][ny][p.b] == I) {\n\t\t\t\t\tD[nx][ny][p.b] = D[p.x][p.y][p.b] + 1;\n\t\t\t\t\tque.push({ nx,ny,p.b });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (D[p.x][p.y][!p.b] == I && b[p.x][p.y]) {\n\t\t\t\tD[p.x][p.y][!p.b] = D[p.x][p.y][p.b] + 1;\n\t\t\t\tque.push({ p.x,p.y,!p.b });\n\t\t\t}\n\t\t}\n\t\tint ans = min(D[m - 1][n - 1][0], D[m - 1][n - 1][1]);\n\t\tif (ans == I)puts(\"-1\");\n\t\telse printf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i];\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%lld\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int M,N,K;\n    cin >> M >> N >> K;\n    vector<pair<int,int> > XY[100001], YX[100001], p;\n    vector<int> c[2];\n    p.push_back(MP(1, 1));\n    XY[1].push_back(MP(1, 0));\n    YX[1].push_back(MP(1, 0));\n    c[0].push_back(0);\n    c[1].push_back(INT_MAX);\n    for(int i=1; i<=K; i++){\n        int x,y;\n        cin >> x >> y;\n        p.push_back(MP(x, y));\n        XY[x].push_back(MP(y, i));\n        YX[y].push_back(MP(x, i));\n        c[0].push_back(INT_MAX);\n        c[1].push_back(INT_MAX);\n    }\n    p.push_back(MP(M, N));\n    XY[M].push_back(MP(N, K+1));\n    YX[N].push_back(MP(M, K+1));\n    c[0].push_back(INT_MAX);\n    c[1].push_back(INT_MAX);\n    for(int i=1; i<=M; i++) sort(XY[i].begin(), XY[i].end());\n    for(int i=1; i<=N; i++) sort(YX[i].begin(), YX[i].end());\n\n    priority_queue<pair<int, pair<int, int> > > que;\n    que.push(MP(INT_MAX, MP(0, 0)));\n    while(!que.empty()){\n        int now = que.top().second.first;\n        int state = que.top().second.second;\n        //cout << now << \" \" << state << \" \" << INT_MAX-que.top().first << endl;\n        que.pop();\n\n        if(now != 0 && now != K+1 && c[(state+1)%2][now] > c[state][now]+1){\n            c[(state+1)%2][now] = c[state][now]+1;\n            que.push(MP(INT_MAX-c[(state+1)%2][now], MP(now, (state+1)%2)));\n        }\n        if(state == 0){\n            auto itr = lower_bound(XY[p[now].first].begin(), XY[p[now].first].end(), MP(p[now].second, now));\n            //cout << itr-XY[p[now].first].begin() << endl;\n            //if(itr != XY[p[now].first].begin()) cout << c[state][(itr-1)->second] << \" \" << c[state][now] + abs(p[now].second-((itr-1)->first)) << endl;\n            if(itr != XY[p[now].first].begin() && c[state][(itr-1)->second] > c[state][now] + abs(p[now].second-((itr-1)->first))){\n                c[state][(itr-1)->second] = c[state][now] + abs(p[now].second-((itr-1)->first));\n                que.push(MP(INT_MAX-c[state][(itr-1)->second], MP((itr-1)->second, state)));\n            }\n            //if(itr != XY[p[now].first].end()-1) cout << c[state][(itr+1)->second] << \" \" << c[state][now] + abs(p[now].second-((itr+1)->first)) << endl;\n            if(itr != XY[p[now].first].end()-1 && c[state][(itr+1)->second] > c[state][now] + abs(p[now].second-((itr+1)->first))){\n                c[state][(itr+1)->second] = c[state][now] + abs(p[now].second-((itr+1)->first));\n                que.push(MP(INT_MAX-c[state][(itr+1)->second], MP((itr+1)->second, state)));\n            }\n        }\n        else{\n            auto itr = lower_bound(YX[p[now].second].begin(), YX[p[now].second].end(), MP(p[now].first, now));\n            if(itr != YX[p[now].second].begin() && c[state][(itr-1)->second] > c[state][now] + abs(p[now].first-((itr-1)->first))){\n                c[state][(itr-1)->second] = c[state][now] + abs(p[now].first-((itr-1)->first));\n                que.push(MP(INT_MAX-c[state][(itr-1)->second], MP((itr-1)->second, state)));\n            }\n            if(itr != YX[p[now].second].end()-1 && c[state][(itr+1)->second] > c[state][now] + abs(p[now].first-((itr+1)->first))){\n                c[state][(itr+1)->second] = c[state][now] + abs(p[now].first-((itr+1)->first));\n                que.push(MP(INT_MAX-c[state][(itr+1)->second], MP((itr+1)->second, state)));\n            }\n        }\n        \n    }\n    \n    if(min(c[0][K+1], c[1][K+1]) == INT_MAX) cout << -1 << endl;\n    else cout << min(c[0][K+1], c[1][K+1]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000], lenx[100000], leny[100000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, m)X[i] = vector<int>(n);\n\trep(i, n)Y[i] = vector<int>(m);\n\tif (clock() > 1000)abort();\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]][lenx[x[i]]++] = i; Y[y[i]][leny[y[i]]++] = i;\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\trep(i, lenx[x[p.p]]) {\n\t\t\tint u = X[x[p.p]][i];\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\trep(i, leny[y[p.p]]) {\n\t\t\tint u = Y[y[p.p]][i];\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, lenx[m - 1]) {\n\t\tint u = X[m - 1][i];\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t}\n\trep(i, leny[n - 1]) {\n\t\tint u = Y[n - 1][i];\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll m[2000000][2];\nll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tx[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tm[0][0] = 0;\n\tm[0][1] = 1;\n\tsum = solve(1, x[1].size() - 1, 1, 0);\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.d<no2.d;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.d>no2.d;\n}\n\nvector<int> ve[2][100010];\nint XY[2][100010],D[2][100010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tbool fla;\n\tint M,N,K,a,b,npt,res,gon;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfla=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tif(a==M&&b==N){ fla=true;gon=i;}\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tif(!fla){\n\t\tXY[0][K+1]=M;\n\t\tXY[1][K+1]=N;\n\t\tve[0][M].push_back(K+1);\n\t\tve[1][N].push_back(K+1);\n\t\tgon=K+1;\n\t}\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tif(D[no.d][no.n]==-1){\n\t\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<no.d<<endl;//\n\t\t\tD[no.d][no.n]=no.t;\n\t\t\tif(no.n==gon){\n\t\t\t\tres=no.t-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\t\tif(D[!no.d][*it]==-1&&no.n!=(*it)){\n\t\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint main(){\n    int m, n, k;\n    cin >> m >> n >> k;\n    set<pii> sw;\n    set<int> yoko[n+1], tate[m+1];\n    for(int i = 0; i < k; i++){\n        int x, y;\n        cin >> x >> y;\n        sw.insert({x, y});\n    }\n    set<pii> s = sw;\n    s.insert({1, 1});\n    s.insert({m, n});\n    map<pii,int> id;\n    vector<pii> v;\n    int siz = 0;\n    for(pii p : s){\n        id[p] = siz++;\n        v.push_back(p);\n        int x = p.first, y = p.second;\n        yoko[y].insert(x);\n        tate[x].insert(y);\n    }\n    vector<vector<ll>> dp(2, vector<ll>(siz, 1ll<<60));\n    dp[0][0] = 0;\n    priority_queue<pair<ll,pii>> pq;\n    pq.push({-0, {0, 0}});\n    while(!pq.empty()){\n        auto p = pq.top();  pq.pop();\n        ll cost = -p.first;\n        int pos = p.second.first, stat = p.second.second;\n        int x = v[pos].first, y = v[pos].second;\n        if(sw.count({x,y})>0 && dp[1-stat][pos] > dp[stat][pos]+1){\n            dp[1-stat][pos] = dp[stat][pos]+1;\n            pq.push({-dp[1-stat][pos], {pos, 1-stat}});\n        }\n        if(stat == 1){\n            auto it = yoko[y].lower_bound(x);\n            if(it != yoko[y].begin()){\n                it--;\n                ll nc = x-(*it);\n                int npos = id[{*it,y}];\n                if(dp[stat][npos] > dp[stat][pos]+nc){\n                   dp[stat][npos] = dp[stat][pos]+nc;\n                   pq.push({-dp[stat][npos], {npos, stat}});\n                }\n                it++;\n            }\n            it++;\n            if(it != yoko[y].end()){\n                ll nc = (*it)-x;\n                int npos = id[{*it,y}];\n                if(dp[stat][npos] > dp[stat][pos]+nc){\n                   dp[stat][npos] = dp[stat][pos]+nc;\n                   pq.push({-dp[stat][npos], {npos, stat}});\n                }\n            }\n        }else if(stat == 0){\n            auto it = tate[x].lower_bound(y);\n            if(it != tate[x].begin()){\n                it--;\n                ll nc = y-(*it);\n                int npos = id[{x, *it}];\n                if(dp[stat][npos] > dp[stat][pos]+nc){\n                   dp[stat][npos] = dp[stat][pos]+nc;\n                   pq.push({-dp[stat][npos], {npos, stat}});\n                }\n                it++;\n            }\n            it++;\n            if(it != tate[x].end()){\n                ll nc = (*it)-y;\n                int npos = id[{x, *it}];\n                if(dp[stat][npos] > dp[stat][pos]+nc){\n                   dp[stat][npos] = dp[stat][pos]+nc;\n                   pq.push({-dp[stat][npos], {npos, stat}});\n                }\n            }\n        }\n    }\n    ll ret = min(dp[0][siz-1], dp[1][siz-1]);\n    if(ret == 1ll<<60)  ret = -1;\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nll abs(ll a) {\n  return a >= 0 ? a : -a;\n}\n\nll min(ll a, ll b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, m, n, x, y, sm = 1, l;\n  ll inf = 10e15;\n  scanf(\"%d%d%d\", &m, &n, &k);\n  vector< pair<int, int> > node[k + 2];\n  vector< pair<int, int> > vec1[m], vec2[n];\n  vec1[0].push_back(make_pair(0, 0));\n  vec1[m - 1].push_back(make_pair(n - 1, k + 1)), vec2[n - 1].push_back(make_pair(m - 1, k + 1));\n  for(i = 1; i <= k; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    x--, y--;\n    vec1[x].push_back(make_pair(y, i));\n    vec2[y].push_back(make_pair(x, i));\n  }\n  for(i = 0; i < m; ++i) {\n    for(j = 0; j < vec1[i].size(); ++j) for(l = 0; l < vec1[i].size(); ++l) if(j != l) {\n      node[vec1[i][j].second].push_back(make_pair(abs(vec1[i][j].first - vec1[i][l].first) + (vec1[i][l].second == k + 1 ? 0 : 1), vec1[i][l].second));\n    }\n  }\n  for(i = 0; i < n; ++i) {\n    for(j = 0; j < vec2[i].size(); ++j) for(l = 0; l < vec2[i].size(); ++l) if(j != l) {\n      node[vec2[i][j].second].push_back(make_pair(abs(vec2[i][j].first - vec2[i][l].first) + (vec2[i][l].second == k + 1 ? 0 : 1), vec2[i][l].second));\n    }\n  }\n  for(i = 0; i < m; ++i) vec1[i].clear();\n  for(i = 0; i < n; ++i) vec2[i].clear();\n  while(sm < k + 2) sm *= 2;\n  pair<ll, ll> seg[sm * 2 + 1];\n  ll dis[k + 2];\n  char flag[k + 2];\n  for(i = 0; i < k + 2; ++i) dis[i] = inf, flag[i] = 1;\n  dis[0] = 0, flag[0] = 0;\n  for(i = 0; i <= 2 * sm; ++i) seg[i].first = inf, seg[i].second = i - sm;\n  seg[1].second = 0;\n  int now = 0;\n  while( 1 ) {\n    int tmp;\n    for(i = 0; i < node[now].size(); ++i) {\n      if(flag[node[now][i].second] && dis[node[now][i].second] > dis[now] + node[now][i].first) {\n        dis[node[now][i].second] = dis[now] + node[now][i].first;\n        seg[node[now][i].second + sm].first = dis[now] + node[now][i].first;\n        tmp = node[now][i].second + sm;\n        tmp /= 2;\n        while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n      }\n    }\n    if(!flag[seg[1].second]) {\n      dis[k + 1] = -1;\n      break;\n    } else {\n      if(seg[1].second == k + 1) break;\n      flag[seg[1].second] = 0;\n      now = seg[1].second;\n      seg[seg[1].second + sm].first = inf;\n      ll tmp = seg[1].second + sm;\n      tmp /= 2;\n      while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n    }\n  }\n  printf(\"%lld\\n\", dis[k + 1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(fld[v].FI==M&&fld[v].SE==N)cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            //if(e.FI==M&&e.SE==N)cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\npriority_queue<node,vector<node>,greater<node> > pq;\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpq.push(node(0,1,1,0));\n\tif(se[0][1].count(1)){\n\t\tpq.push(node(1,1,1,1));\n\t}\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(no.di==0){\n\t\t\t\tfor(ite=se[0][no.x].begin();ite!=se[0][no.x].end();ite++){\n\t\t\t\t\tif(no.y!=(*ite)&&used[1].count(make_pair(no.x,*ite))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.y)+no.d+1,no.x,*ite,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(ite=se[1][no.y].begin();ite!=se[1][no.y].end();ite++){\n\t\t\t\t\tif(no.x!=(*ite)&&used[0].count(make_pair(*ite,no.y))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.x)+no.d+1,*ite,no.y,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n\n#define VL -1\n#define HL 1\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef struct\n{\n\tint X;\n\tint Y;\n} POS;\ntypedef struct\n{\n\tint X;\n\tint Y;\n\tint VH;\n} NODE;\nbool cmpnode(const NODE& a,const NODE& b)\n{\n\tif(a.X == b.X)\n\t{\n\t\tif(a.Y == b.Y)\n\t\t{\n\t\t\treturn a.VH < b.VH;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a.Y < b.Y;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn a.X < b.X;\n\t}\n}\n\ntypedef struct\n{\n\tvector<int> dest_node;\n\tvector<int> route_cost;\n\tint node_cost;\n\tbool decided;\n} DNODE;\nstruct cmpdnode\n{\n\tbool operator()(const DNODE* a,const DNODE* b)\n\t{\n\t\treturn a->node_cost < b->node_cost;\n\t}\n};\nint W,H,K;\nPOS tp;\nvector<POS> S;\nvector<int> nX,nY;\nmultimap<int,int> X,Y;\n\nvector<NODE> nodes;\nvector<DNODE> dnodes;\npriority_queue<DNODE*,vector<DNODE*>,cmpdnode> prcq;\n\nNODE T_node;\nNODE* makenode(int x,int y,int vh)\n{\n\tT_node.X = x;\n\tT_node.Y = y;\n\tT_node.VH = vh;\n\treturn &T_node;\n}\n\nint geti(const NODE& nds)\n{\n\treturn lower_bound(nodes.begin(),nodes.end(),nds,cmpnode) - nodes.begin();\n}\n\nint main(void)\n{\n\tcin >> W >> H >> K;\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> tp.X >> tp.Y;\n\t\tS.push_back(tp);\n\t\tnX.push_back(tp.X);\n\t\tnY.push_back(tp.Y);\n\t\tX.insert(make_pair(tp.X,tp.Y));\n\t\tY.insert(make_pair(tp.Y,tp.X));\n\t\tnodes.push_back(*makenode(tp.X,tp.Y,HL));\n\t\tnodes.push_back(*makenode(tp.X,tp.Y,VL));\n\t}\n\tX.insert(make_pair(1,1));\n\tY.insert(make_pair(1,1));\n\tX.insert(make_pair(W,H));\n\tY.insert(make_pair(H,W));\n\tnodes.push_back(*makenode(0,0,0));\n\tnodes.push_back(*makenode(-1,-1,0));\n\tnodes.push_back(*makenode(1,1,HL));\n\tnodes.push_back(*makenode(1,1,VL));\n\tnodes.push_back(*makenode(W,H,HL));\n\tnodes.push_back(*makenode(W,H,VL));\n\tsort(nX.begin(),nX.end());\n\tsort(nY.begin(),nY.end());\n\tsort(nodes.begin(),nodes.end(),cmpnode);\n\tint prev = -1;\n\tfor(auto itr = nX.begin();itr < nX.end();itr++)\n\t{\n\t\tif(*itr == prev)\n\t\t{\n\t\t\tnX.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tprev = -1;\n\tfor(auto itr = nY.begin();itr < nY.end();itr++)\n\t{\n\t\tif(*itr == prev)\n\t\t{\n\t\t\tnY.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tDNODE td;\n\ttd.decided = false;\n\ttd.node_cost = INF;\n\tfor(unsigned int i = 0;i < nodes.size();i++)\n\t{\n\t\tdnodes.push_back(td);\n\t}\n\tauto range = Y.equal_range(0);\n\tauto itr1 = range.first;\n\tauto itr2 = range.first;\n\tfor(auto itr = nX.begin();itr < nX.end();itr++)\n\t{\n\t\trange = X.equal_range(*itr);\n\t\titr1 = range.first;\n\t\titr2 = range.first;\n\t\titr2++;\n\t\twhile(itr2 != range.second)\n\t\t{\n\t\t\tdnodes[geti(*makenode(*itr,itr1->second,VL))].dest_node.push_back(geti(*makenode(*itr,itr2->second,VL)));\n\t\t\tdnodes[geti(*makenode(*itr,itr1->second,VL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\tdnodes[geti(*makenode(*itr,itr2->second,VL))].dest_node.push_back(geti(*makenode(*itr,itr1->second,VL)));\n\t\t\tdnodes[geti(*makenode(*itr,itr2->second,VL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\titr1++;\n\t\t\titr2++;\n\t\t}\n\t}\n\tfor(auto itr = nY.begin();itr < nY.end();itr++)\n\t{\n\t\trange = Y.equal_range(*itr);\n\t\titr1 = range.first;\n\t\titr2 = range.first;\n\t\titr2++;\n\t\twhile(itr2 != range.second)\n\t\t{\n\t\t\tdnodes[geti(*makenode(itr1->second,*itr,HL))].dest_node.push_back(geti(*makenode(itr2->second,*itr,HL)));\n\t\t\tdnodes[geti(*makenode(itr1->second,*itr,HL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\tdnodes[geti(*makenode(itr2->second,*itr,HL))].dest_node.push_back(geti(*makenode(itr1->second,*itr,HL)));\n\t\t\tdnodes[geti(*makenode(itr2->second,*itr,HL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\titr1++;\n\t\t\titr2++;\n\t\t}\n\t}\n\tfor(auto itr = S.begin();itr < S.end();itr++)\n\t{\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,HL))].dest_node.push_back(geti(*makenode(itr->X,itr->Y,VL)));\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,VL))].dest_node.push_back(geti(*makenode(itr->X,itr->Y,HL)));\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,HL))].route_cost.push_back(1);\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,VL))].route_cost.push_back(1);\n\t}\n\tdnodes[geti(*makenode(0,0,0))].dest_node.push_back(geti(*makenode(1,1,VL)));\n\tdnodes[geti(*makenode(0,0,0))].dest_node.push_back(geti(*makenode(1,1,HL)));\n\tdnodes[geti(*makenode(W,H,HL))].dest_node.push_back(geti(*makenode(-1,-1,0)));\n\tdnodes[geti(*makenode(W,H,VL))].dest_node.push_back(geti(*makenode(-1,-1,0)));\n\tdnodes[geti(*makenode(0,0,0))].route_cost.push_back(0);\n\tdnodes[geti(*makenode(0,0,0))].route_cost.push_back(0);\n\tdnodes[geti(*makenode(W,H,HL))].route_cost.push_back(0);\n\tdnodes[geti(*makenode(W,H,VL))].route_cost.push_back(0);\n\tprcq.push(&dnodes[geti(*makenode(0,0,0))]);\n\tprcq.top()->node_cost = 0;\n\tauto topq = prcq.top();\n\twhile(!prcq.empty())\n\t{\n\t\ttopq = prcq.top();\n\t\tprcq.pop();\n\t\tif(!topq->decided)\n\t\t{\n\t\t\ttopq->decided = true;\n\t\t\tfor(unsigned int i = 0;i < topq->dest_node.size();i++)\n\t\t\t{\n\t\t\t\tif(dnodes[topq->dest_node[i]].node_cost > topq->route_cost[i] + topq->node_cost)\n\t\t\t\t{\n\t\t\t\t\tdnodes[topq->dest_node[i]].node_cost = topq->route_cost[i] + topq->node_cost;\n\t\t\t\t\tprcq.push(&dnodes[topq->dest_node[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dnodes[geti(*makenode(-1,-1,0))].node_cost == INF)\n\t\tdnodes[geti(*makenode(-1,-1,0))].node_cost = -1;\n\tcout << dnodes[geti(*makenode(-1,-1,0))].node_cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nusing Weight = long long int;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint tate;\n\tEdge(int src_, int dst_, Weight weight_,bool a) :\n\t\tsrc(src_), dst(dst_), weight(weight_),tate(a) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nstruct Node {\n\tint x;\n\tint y;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint tate;\n\tWeight time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nWeight getans(vector<vector<Edge>>&g, const bool startswitch,int s,int t) {\n\tpriority_queue<aa,vector<aa>,Compare>que;\n\tque.push(aa{ 0,true,0 });\n\tif (startswitch) {\n\t\tque.push(aa{ 0,false,1 });\n\t}\n\tvector<vector<Weight>>memo(g.size(), vector<Weight>(2,1e18));\n\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tif (atop.id == t)return atop.time;\n\t\tque.pop();\n\t\tif (atop.id) {\n\t\t\tif (memo[atop.id][!atop.tate]>atop.time+1) {\n\t\t\t\tmemo[atop.id][!atop.tate] = atop.time + 1;\n\t\t\t\tque.push(aa{ atop.id,!atop.tate,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tfor (auto e : g[atop.id]) {\n\t\t\tif (e.tate != atop.tate)continue;\n\t\t\tconst Weight nexttime = atop.time + e.weight;\n\t\t\tif (memo[e.dst][e.tate] > nexttime) {\n\t\t\t\tmemo[e.dst][e.tate] = nexttime;\n\t\t\t\tque.push(aa{ e.dst,e.tate,nexttime });\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\tint M, N, K; cin >> M >> N >> K;\n\tvector<Node>ps;\n\tbool startswitch = false;\n\tint id = 0;\n\tps.push_back(Node{ 0,0,id++ });\n\tfor (int i = 0; i < K; ++i) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tif (x == 0 && y == 0) {\n\t\t\tstartswitch = true;\n\t\t}\n\t\telse if (x == M-1&&y == N-1) {\n\n\t\t}\n\t\telse {\n\t\t\tps.push_back(Node{ x,y,id++ });\n\t\t}\n\t}\n\tps.push_back(Node{ M-1,N-1,id });\n\tvector<vector<Edge>>g(K + 2);\n\tsort(ps.begin(), ps.end(), [](const Node&l, const Node&r) {\n\t\treturn l.x == r.x ? l.y < r.y : l.x < r.x;\n\t});\n\tfor (int i = 0; i < ps.size() - 1; ++i) {\n\t\tNode l = ps[i];\n\t\tNode r = ps[i + 1];\n\t\tif (l.x == r.x) {\n\t\t\tg[l.id].push_back(Edge(l.id, r.id, r.y - l.y, true));\n\t\t\tg[r.id].push_back(Edge(r.id, l.id, r.y - l.y, true));\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end(), [](const Node&l, const Node&r) {\n\t\treturn l.y == r.y ? l.x < r.x : l.y < r.y;\n\t});\n\tfor (int i = 0; i < ps.size() - 1; ++i) {\n\t\tNode l = ps[i];\n\t\tNode r = ps[i + 1];\n\t\tif (l.y == r.y) {\n\t\t\tg[l.id].push_back(Edge(l.id, r.id, r.x - l.x, false));\n\t\t\tg[r.id].push_back(Edge(r.id, l.id, r.x - l.x, false));\n\t\t}\n\t}\n\tlong long int ans = getans(g,startswitch,0,id);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!sag.empty()){\n\t\t\t\tno2=sag.top();sag.pop();\n\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\npriority_queue<node,vector<node>,greater<node> > pq;\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(no.di==0){\n\t\t\t\tfor(ite=se[0][no.x].begin();ite!=se[0][no.x].end();ite++){\n\t\t\t\t\tif(used[1].count(make_pair(no.x,*ite))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.y)+no.d+1,no.x,*ite,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(ite=se[1][no.y].begin();ite!=se[1][no.y].end();ite++){\n\t\t\t\t\tif(used[0].count(make_pair(*ite,no.y))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.x)+no.d+1,*ite,no.y,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n//?????????????????£????°??????????????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nunordered_map<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tif( cost[0][pr].find(c) != cost[0][pr].end() && cost[0][pr][c] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tif( cost[0][mr].find(c) != cost[0][mr].end() && cost[0][mr][c] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tif( cost[1][r].find(pc) != cost[1][r].end() && cost[1][r][pc] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tif( cost[1][r].find(mc) != cost[1][r].end() && cost[1][r][mc] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨??????????\n\tsc[h-1].push_back(w-1);\n\tsr[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[114514], Y[114514];\nvector<PII> G[114514][2];\nll d[114514][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 114514){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tREP(i, M){\n\t\tREP(j, X[i].size()){\n\t\t\tREP(k, X[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[X[i][j].second][0].push_back({abs(X[i][j].first-X[i][k].first), X[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, N){\n\t\tREP(j, Y[i].size()){\n\t\t\tREP(k, Y[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[Y[i][j].second][1].push_back({abs(Y[i][j].first-Y[i][k].first), Y[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tREP(i, G[v][s].size()){\n\t\t\tif(d[G[v][s][i].second][s] > d[v][s] + G[v][s][i].first){\n\t\t\t\td[G[v][s][i].second][s] = d[v][s] + G[v][s][i].first;\n\t\t\t\td[G[v][s][i].second][(s+1)%2] = min(d[G[v][s][i].second][(s+1)%2], d[G[v][s][i].second][s]+1);\n\t\t\t\tpq.push({d[G[v][s][i].second][(s+1)%2], {G[v][s][i].second, (s+1)%2}});\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\t/*\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tcout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\n#define MAX_N 10000\n#define MAX_M 10000\n#define INF 1000000\n\ntypedef pair<int, int> coord; //??§?¨?\ntypedef pair<coord, int> P; //??§?¨??????????\n\nbool s[MAX_M][MAX_N];  //????????????????????????????????? \nint M, N, K;\nint d[MAX_M][MAX_N][2]; // ???????????¢, ????????????, ????????±?\\?\n\nint main()\n{\n\tcin >> M >> N >> K;\n\t//s[][], d[][][]????????????\n\tfor (int i = 0; i < M ; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ts[i][j] = false;\n\t\t\td[i][j][0] = INF;\n\t\t\td[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t//scanf(\"%d %d\", &x, &y);\n\t\ts[x - 1][y - 1] = true;\n\t}\n\n\tqueue<P> que;\n\tque.push(P(coord(0, 0), 0));\n\td[0][0][0] = 0;\n\twhile (que.size()) {\n\t\tP p = que.front(); que.pop();\n\t\tint x = p.first.first;\n\t\tint y = p.first.second;\n\t\tif (p.second = 0) {\n\t\t\tif (s[x][y] == true && d[x][y][1] == INF) {\n\t\t\t\td[x][y][1] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y), 1));\n\t\t\t}\n\t\t\tif (y > 0 && d[x][y - 1][0] == INF) {\n\t\t\t\td[x][y - 1][0] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y - 1), 0));\n\t\t\t}\n\t\t\tif (y < N - 1 && d[x][y + 1][0] == INF) {\n\t\t\t\td[x][y + 1][0] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y + 1), 0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (s[x][y] == true && d[x][y][0] == INF) {\n\t\t\t\td[x][y][0] = d[x][y][1] + 1;\n\t\t\t\tque.push(P(coord(x, y), 0));\n\t\t\t}\n\t\t\tif (x > 0 && d[x - 1][y][1] == INF) {\n\t\t\t\td[x - 1][y][1] = d[x - 1][y][1] + 1;\n\t\t\t\tque.push(P(coord(x - 1, y), 1));\n\t\t\t}\n\t\t\tif (x < M - 1 && d[x + 1][y][1] == INF) {\n\t\t\t\td[x + 1][y][1] = d[x][y][1] + 1;\n\t\t\t\tque.push(P(coord(x + 1, y), 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = d[M - 1][N - 1][0];\n\tif (ans > d[M - 1][N - 1][1]) ans = d[M - 1][N -1][1];\n\tif (ans == INF) ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\nstruct Point{int x,y,id;};\nbool linkx(Point &p1,Point &p2){ return p1.y==p2.y ? p1.x<p2.x : p1.y<p2.y; }\nbool linky(Point &p1,Point &p2){ return p1.x==p2.x ? p1.y<p2.y : p1.x<p2.x; }\nint xid(Point &p){return p.id*2;}\nint yid(Point &p){return p.id*2+1;}\n\n#define MAX_V 400010\n#define INF 1e18\ntypedef long long ll;\nstruct edge{ll cost; int to;};\ntypedef pair<ll,int> P;//dp[v],v\n\nvector<Point> vp;\nvector<edge> G[MAX_V]; \nll dp[MAX_V];\nint M,N,K,X,Y;\n\nll dijkstra(){\n\tfill(dp,dp+MAX_V,INF);\n\tpriority_queue<P,vector<P>,greater<P>> qu;\n\tif(vp[0].x==1){\n\t\tdp[yid(vp[0])]=vp[0].y-1;\n\t\tqu.push({dp[yid(vp[0])],yid(vp[0])});\n\t}\n\twhile(qu.size()){\n\t\tP pr=qu.top(); qu.pop();\n\t\tint v=pr.second;\n\t\tif(v>=2*K)return pr.first;\n\t\tif(dp[v] < pr.first)continue;\n\t\tfor(edge e:G[v]){\n\t\t\tif( dp[e.to] > dp[v]+e.cost){\n\t\t\t\tdp[e.to] = dp[v]+e.cost;\n\t\t\t\tqu.push({dp[e.to],e.to});\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tcin>>M>>N>>K;\n\trep(i,K){\n\t\tcin>>X>>Y;\n\t\tvp.push_back({X,Y,i});\n\t}\n\tvp.push_back({M,N,K});\n\n\t//switch\n\trep(i,K){\n\t\tG[xid(vp[i])].push_back({1,yid(vp[i])});\n\t\tG[yid(vp[i])].push_back({1,xid(vp[i])});\n\t}\n\n\t//linkx\n\tsort(all(vp),linkx);\n\trep(i,K){\n\t\tif(vp[i].y==vp[i+1].y){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.x-p2.x);\n\t\t\tG[xid(p1)].push_back({cost,xid(p2)});\n\t\t\tG[xid(p2)].push_back({cost,xid(p1)});\n\t\t}\n\t}\n\n\t//linky\n\tsort(all(vp),linky);\n\trep(i,K){\n\t\tif(vp[i].x==vp[i+1].x){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.y-p2.y);\n\t\t\tG[yid(p1)].push_back({cost,yid(p2)});\n\t\t\tG[yid(p2)].push_back({cost,yid(p1)});\n\t\t}\n\t}\n\tcout<<dijkstra()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.d<no2.d;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.d>no2.d;\n}\n\nvector<int> ve[2][100010];\nint XY[2][200010],D[2][200010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tbool fla;\n\tint M,N,K,a,b,npt,res,gon;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfla=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tif(a==M&&b==N){ fla=true;gon=i;}\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tif(!fla){\n\t\tXY[0][K+1]=M;\n\t\tXY[1][K+1]=N;\n\t\tve[0][M].push_back(K+1);\n\t\tve[1][N].push_back(K+1);\n\t\tgon=K+1;\n\t}\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tif(D[no.d][no.n]==-1){\n\t\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<no.d<<endl;//\n\t\t\tD[no.d][no.n]=no.t;\n\t\t\tif(no.n==gon){\n\t\t\t\tres=no.t-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\t\tif(D[!no.d][*it]==-1&&no.n!=(*it)){\n\t\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n \nll d[200000][2];\nint x[200000],y[200000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        if(x[i]==0){\n\t\t\td[i][1]=y[i];que.push({i,1,d[i][1]});\n\t\t}\n    }\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        rep(u,k){\n\t\t\tif(x[u]==x[p.p]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])+!p.b){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+!p.b;\n                    que.push({u,1,d[u][1]});\n                }\n\t\t\t}\n\t\t\tif(y[u]==y[p.p]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])+p.b){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+p.b;\n                    que.push({u,0,d[u][0]});\n                }\n\t\t\t}\n\t\t}\n    }\n    ll Min=INF;\n    rep(u,k){\n\t\tif(x[u]==m-1){\n\t\t\tMin=min(Min,d[u][1]+abs(y[u]-n+1));\n\t\t\tMin=min(Min,d[u][0]+1+abs(y[u]-n+1));\n\t\t}\n\t\tif(y[u]==n-1){\n\t\t\tMin=min(Min,d[u][0]+abs(x[u]-m+1));\n\t\t\tMin=min(Min,d[u][1]+1+abs(x[u]-m+1));\n\t\t}\n\t}\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge {\n\tint to;\n\tlong long cost;\n\tint tp;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint W, H, N, x, y; long long dist[200009][2]; vector<pair<int, int> > xd[100009], yd[100009]; vector<edge> G[200009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x, &y); x--, y--;\n\t\txd[x].push_back(make_pair(y, i));\n\t\tyd[y].push_back(make_pair(x, i));\n\t}\n\txd[0].push_back(make_pair(0, N));\n\txd[W - 1].push_back(make_pair(H - 1, N + 1));\n\tyd[H - 1].push_back(make_pair(W - 1, N + 1));\n\tfor (int i = 0; i < W; i++) {\n\t\tsort(xd[i].begin(), xd[i].end());\n\t\tfor (int j = 1; j < xd[i].size(); j++) {\n\t\t\tint va = xd[i][j - 1].second, vb = xd[i][j].second, cost = xd[i][j].first - xd[i][j - 1].first;\n\t\t\tG[va].push_back(edge{ vb, cost, 0 });\n\t\t\tG[vb].push_back(edge{ va, cost, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tsort(yd[i].begin(), yd[i].end());\n\t\tfor (int j = 1; j < yd[i].size(); j++) {\n\t\t\tint va = yd[i][j - 1].second, vb = yd[i][j].second, cost = yd[i][j].first - yd[i][j - 1].first;\n\t\t\tG[va].push_back(edge{ vb, cost, 1 });\n\t\t\tG[vb].push_back(edge{ va, cost, 1 });\n\t\t}\n\t}\n\tfor (int i = 0; i < N + 2; i++) dist[i][0] = dist[i][1] = 1LL << 60; dist[N][0] = 0;\n\tpriority_queue<edge> que; que.push(edge{ N, 0, 0 });\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long cost = dist[u.to][u.tp] + e.cost + (u.tp != e.tp);\n\t\t\tif (dist[e.to][e.tp] > cost) {\n\t\t\t\tdist[e.to][e.tp] = cost;\n\t\t\t\tque.push(edge{ e.to, -cost, e.tp });\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = min(dist[N + 1][0], dist[N + 1][1]);\n\tif (ret == 1LL << 60) ret = -1;\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LL long long\nconst LL inf = 1e15;\n\nstruct edge{\n    int n, ty;\n    LL cost;\n    bool operator<(const edge& e1) const {\n        return e1.cost < cost;\n    }\n};\n\nint M, N, K;\nLL z[200010][2];\nLL D[200010][2];\nvector<int> G[100010][2];\nint main(){\n    cin >> M >> N >> K;\n    for(int i = 0; i <= K; i++){\n        D[i][0] = inf;\n        D[i][1] = inf;\n    }\n    z[0][0] = z[0][1] = 1;\n    for(int i = 1; i <= K; i++){\n        cin >> z[i][0] >> z[i][1];\n        G[z[i][0]][0].push_back(i);\n        G[z[i][1]][1].push_back(i);\n    }\n    priority_queue<edge> pq;\n    pq.push(edge{0, 0, 0});\n    D[0][0] = 0;\n    while(!pq.empty()){\n        edge e = pq.top();\n        pq.pop();\n        if(D[e.n][e.ty] < e.cost) continue;\n        int inv = (e.ty + 1) & 1;\n        for(auto &u : G[z[e.n][e.ty]][e.ty]){\n            int c = e.cost + abs(z[e.n][inv] - z[u][inv]) + 1;\n            if(D[u][inv] > c){\n                D[u][inv] = c;\n                pq.push(edge{u, inv, c});\n            }\n        }\n    }\n    LL ans = inf;\n    for(int i = 1; i <= K; i++){\n        if(z[i][0] == M){\n            ans = min(ans, min(D[i][0],D[i][1] + 1) + abs(N - z[i][1]) );\n        }\n        if(z[i][1] == N){\n            ans = min(ans, min(D[i][0] + 1,D[i][1]) + abs(M - z[i][0]) );\n        }\n    }\n    cout << (ans == inf ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t/*\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tcout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n\tint p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n\treturn a.c>b.c;\n}\nint main() {\n\tint m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n\trep(i,k){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n\t\tX[x[i]].push_back(i);Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d,0x3f,sizeof(d));\n\tfor(int&u:X[0]){\n\t\td[u][1]=y[u];\n\t\tque.push({u,1,d[u][1]});\n\t}\n\twhile(!que.empty()){\n\t\tst p=que.top();que.pop();\n\t\tif(d[p.p][p.b]!=p.c)continue;\n\t\tif(p.b){\n\t\t\tfor(int&u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u]);\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int&u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u])+1;\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int&u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u])+1;\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int&u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u]);\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min=INF;\n\tfor(int&u:X[m-1]){\n\t\tMin=min(Min,d[u][1]+abs(y[u]-n+1));\n\t\tMin=min(Min,d[u][0]+1+abs(y[u]-n+1));\n\t}\n\tfor(int&u:Y[n-1]){\n\t\tMin=min(Min,d[u][0]+abs(x[u]-m+1));\n\t\tMin=min(Min,d[u][1]+1+abs(x[u]-m+1));\n\t}\n\tif(Min==INF)puts(\"-1\");\n\telse printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_W 110000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\n\tlong long G = solve();\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].empty())\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {!c_now.sw ? c_now.loc_y : c_now.loc_x, {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000], lenx[100000], leny[100000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, m)X[i].resize(n);\n\trep(i, n)Y[i].resize(m);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]][lenx[x[i]]++] = i; Y[y[i]][leny[y[i]]++] = i;\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\trep(i, lenx[x[p.p]]) {\n\t\t\tint u = X[x[p.p]][i];\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\trep(i, leny[y[p.p]]) {\n\t\t\tint u = Y[y[p.p]][i];\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, lenx[m - 1]) {\n\t\tint u = X[m - 1][i];\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t}\n\trep(i, leny[n - 1]) {\n\t\tint u=Y[n-1][i];\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; ll c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i];\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%lld\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n  \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n    }\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    for(int&u:X[0]){\n        d[u][1]=y[u];\n        que.push({u,1,d[u][1]});\n    }\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    ll Min=INF;\n    for(int&u:X[m-1]){\n        Min=min(Min,d[u][1]+abs(y[u]-n+1));\n        Min=min(Min,d[u][0]+1+abs(y[u]-n+1));\n    }\n    for(int&u:Y[n-1]){\n        Min=min(Min,d[u][0]+abs(x[u]-m+1));\n        Min=min(Min,d[u][1]+1+abs(x[u]-m+1));\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#define INF 1000000000000000LL\nusing namespace std;\ntypedef long long ll;\n\nll labs(ll x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nstruct data{\n\tint x,y,id;\n\tdata(){}\n\tdata(int xx,int yy,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tid=dd;\n\t}\n};\n\nclass data2{\npublic:\n\tint v,s;\n\tll cost;\n\tdata2(){}\n\tdata2(int vv,int ss,ll cc){\n\t\tv=vv;\n\t\ts=ss;\n\t\tcost=cc;\n\t}\n\tbool operator<(const data2& d)const{\n\t\treturn cost>d.cost;\n\t}\n};\n\nbool compx(const data &d1,const data &d2){\n\tif(d1.x==d2.x)return d1.y<d2.y;\n\treturn d1.x<d2.x;\n}\n\nbool compy(const data &d1,const data &d2){\n\tif(d1.y==d2.y)return d1.x<d2.x;\n\treturn d1.y<d2.y;\n}\nbool compid(const data &d1,const data &d2){\n\treturn d1.id<d2.id;\n}\n\nint m,n,k;\ndata dat[200001];\nvector<int> xid[100001];\nvector<int> yid[100001];\nvector<int> G[200001][2];\nll dp[200001][2];\nll dijk(){\n\tpriority_queue<data2> que;\n\tfor(int i=0;i<k;i++){\n\t\tdp[i][0]=dp[i][1]=INF;\n\t}\n\tif(yid[0].size()>0){\n\t\tque.push(data2(yid[0][0],1,dat[yid[0][0]].y));\n\t\tdp[yid[0][0]][1]=dat[yid[0][0]].y;\n\t}\n\tll res=INF;\n\twhile(que.size()){\n\t\tdata2 d=que.top();\n\t\tque.pop();\n\t\tif(d.cost>dp[d.v][d.s] || d.cost>res)continue;\n\t\tif(d.s==1 && dat[d.v].x==m-1){\n\t\t\tres=min(res,d.cost+labs((ll)n-1-dat[d.v].y));\n\t\t}\n\t\tif(d.s==0 && dat[d.v].y==n-1){\n\t\t\tres=min(res,d.cost+labs((ll)m-1-dat[d.v].x));\n\t\t}\n\t\tif(dp[d.v][1-d.s]>(ll)d.cost+1){\n\t\t\tdp[d.v][1-d.s]=(ll)d.cost+1;\n\t\t\tque.push(data2(d.v,1-d.s,dp[d.v][1-d.s]));\n\t\t}\n\t\tfor(int i=0;i<(int)G[d.v][d.s].size();i++){\n\t\t\tint t=(int)G[d.v][d.s][i];\n\t\t\tll dist=labs((ll)dat[d.v].x-dat[t].x)+labs((ll)dat[d.v].y-dat[t].y);\n\t\t\tif(dp[t][d.s]>d.cost+dist){\n\t\t\t\tdp[t][d.s]=d.cost+dist;\n\t\t\t\tque.push(data2(t,d.s,dp[t][d.s]));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d%d\",&dat[i].x,&dat[i].y);\n\t\tdat[i].x--;\n\t\tdat[i].y--;\n\t\tdat[i].id=i;\n\t}\n\tsort(dat,dat+k,compx);\n\tfor(int i=0;i<k;i++){\n\t\txid[dat[i].y].push_back(dat[i].id);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint si=xid[i].size();\n\t\tfor(int j=0;j<si-1;j++){\n\t\t\tG[xid[i][j]][0].push_back(xid[i][j+1]);\n\t\t\tG[xid[i][j+1]][0].push_back(xid[i][j]);\n\t\t}\n\t}\n\tsort(dat,dat+k,compy);\n\tfor(int i=0;i<k;i++){\n\t\tyid[dat[i].x].push_back(dat[i].id);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint si=yid[i].size();\n\t\tfor(int j=0;j<si-1;j++){\n\t\t\tG[yid[i][j]][1].push_back(yid[i][j+1]);\n\t\t\tG[yid[i][j+1]][1].push_back(yid[i][j]);\n\t\t}\n\t}\n\tsort(dat,dat+k,compid);\n\tll res=dijk();\n\tprintf(\"%lld\\n\",res==INF?-1:res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; ll c;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i];\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tll Min = INF;\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (x[p.p] == m - 1) {\n\t\t\tMin = min(Min, d[p.p][1] + abs(y[p.p] - n + 1));\n\t\t\tMin = min(Min, d[p.p][0] + 1 + abs(y[p.p] - n + 1));\n\t\t}\n\t\tif (y[p.p] == n - 1) {\n\t\t\tMin = min(Min, d[p.p][0] + abs(x[p.p] - m + 1));\n\t\t\tMin = min(Min, d[p.p][1] + 1 + abs(x[p.p] - m + 1));\n\t\t}\n\t\tif (p.b) {\n\t\t\tfor (int&u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int&u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int&u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int&u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%lld\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].empty())\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= n; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define INF 0x7f7f7f7f\ntypedef pair<int, int> P;\nstruct edge { int to, cost, sw; };\nvector<edge> g[200001];\nint d[200001][2];\nbool flag[200001];\npair<P, int> xy[200001];\npair<P, int> yx[200001];\n\nint main() {\n\tint m, n, k;\n\n\tscanf(\"%d%d%d\", &m, &n, &k);\n\tint x, y;\n\tfor (int i = 1; i <= k; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\txy[i] = make_pair(make_pair(x, y), i);\n\t\tyx[i] = make_pair(make_pair(y, x), i);\n\t}\n\tmemset(d, 0x7f, sizeof(d));\n\tmemset(flag, false, sizeof(flag));\n\td[0][0] = 0;\n\txy[0] = make_pair(make_pair(1, 1), 0); yx[0] = make_pair(make_pair(1, 1), 0);\n\txy[k + 1] = make_pair(make_pair(m, n), k + 1); yx[k + 1] = make_pair(make_pair(n, m), k + 1);\n\tsort(xy, xy + k + 1);\n\tsort(yx, yx + k + 1);\n\tfor (int i = 0; i <= k; i++) {\n\t\tedge t;\n\t\tif (xy[i + 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i + 1].S; t.cost = abs(xy[i].F.S - xy[i + 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i + 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i + 1].S; t.cost = abs(yx[i].F.S - yx[i + 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t\tif (xy[i - 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i - 1].S; t.cost = abs(xy[i].F.S - xy[i - 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i - 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i - 1].S; t.cost = abs(yx[i].F.S - yx[i - 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t}\n\tpriority_queue<int, vector<int>, greater<int> > q;\n\tq.push(0);\n\tint bef = -1;\n\twhile (!q.empty()) {\n\t\tint i = q.top(); q.pop();\n\t\tflag[i] = true;\n\t\tif (bef == i) continue;\n\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\tif (!flag[g[i][j].to]) {\n\t\t\t\td[g[i][j].to][1 - g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost + 1, d[g[i][j].to][1 - g[i][j].sw]);\n\t\t\t\td[g[i][j].to][g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost, d[g[i][j].to][g[i][j].sw]);\n\t\t\t\tq.push(g[i][j].to);\n\t\t\t}\n\t\t}\n\t\tbef = i;\n\t}\n\tint ans = min(d[k + 1][0], d[k + 1][1]);\n\tprintf(\"%d\\n\", ans== INF ? -1 : ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\nstruct state{\n  int pos,flg,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<P> t[MAX][2];\nint W,H,K,X[MAX],Y[MAX];\nint d[MAX][2];\nvector<edge> G[MAX][2];\n\nint solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=1e9;\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( (state){ p.second, 0, p.first-1 } );\n  d[p.second][0]=p.first-1;\n  \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        int ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push((state){e.to,nf,ncost});\n        }\n      }\n    }\n  }\n  int res=min(d[K][0],d[K][1]);\n  if(res==1e9)return -1;\n  else return res;\n}\n      \nint main(){\n  scanf(\"%d %d %d\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( (edge){q.second,p.first-q.first} );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( (edge){q.second,q.first-p.first} );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define INF 0x7f7f7f7f\ntypedef long long LL;\ntypedef pair<LL, LL> P;\nstruct edge { LL to, cost,sw; };\nvector<edge> g[200001];\nLL d[200001][2];\nbool flag[200001] = { 0 };\npair<pair<LL,LL>,int> xy[200001];\npair<pair<LL,LL>,int> yx[200001];\n\nint main(){\n\tint m, n, k;\n\n\tscanf(\"%d%d%d\", &m, &n, &k);\n\tLL x, y;\n\tfor (int i = 1; i <= k; i++) {\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\txy[i] = make_pair(make_pair(x, y),i);\n\t\tyx[i] = make_pair(make_pair(y, x),i);\n\t}\n\tmemset(d, 0x7f, sizeof(d));\n\t//memset(flag, false, sizeof(flag));\n\td[0][0] = 0;\n\txy[0] = make_pair(make_pair(1, 1),0);yx[0] = make_pair(make_pair(1, 1),0);\n\txy[k + 1] = make_pair(make_pair(m, n),k + 1); yx[k + 1] = make_pair(make_pair(n, m), k + 1);\n\tsort(xy, xy + k + 1);\n\tsort(yx, yx + k + 1);\n\tfor (int i = 0; i <= k; i++) {\n\t\tedge t;\n\t\tif (xy[i + 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i+1].S; t.cost = abs(xy[i].F.S - xy[i + 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i + 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i+1].S; t.cost = abs(yx[i].F.S - yx[i + 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t\tif (xy[i - 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i - 1].S; t.cost = abs(xy[i].F.S - xy[i - 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i - 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i - 1].S; t.cost = abs(yx[i].F.S - yx[i - 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t}\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint i = q.front(); q.pop();\n\t\tflag[i] = true;\n\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\tif (!flag[g[i][j].to]) {\n\t\t\t\td[g[i][j].to][1 - g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost + 1, d[g[i][j].to][1 - g[i][j].sw]);\n\t\t\t\td[g[i][j].to][g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost, d[g[i][j].to][g[i][j].sw]);\n\t\t\t\tq.push(g[i][j].to);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", min(d[k + 1][0]-1, d[k + 1][1]-1) == INF-1 ? -1 : min(d[k + 1][0]-1, d[k + 1][1]-1));\n}\n"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nunordered_map<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨??????????\n\tsc[h-1].push_back(w-1);\n\tsr[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct p1 {\n\tint idx, x, y;\n};\nbool operator<(const p1& r1, const p1& r2) {\n\tif (r1.y != r2.y) return r1.y < r2.y;\n\treturn r1.x < r2.x;\n}\nstruct edge {\n\tint to; long long cost; int type;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint H, W, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<p1> p(N);\n\tfor (int i = 0; i < N; i++) cin >> p[i].x >> p[i].y, p[i].x--, p[i].y--, p[i].idx = i;\n\tp.push_back(p1{ N, W - 1, H - 1 }); N++;\n\tvector<vector<p1> > ex(W), ey(H);\n\tfor (int i = 0; i < N; i++) {\n\t\tex[p[i].x].push_back(p[i]);\n\t\tey[p[i].y].push_back(p[i]);\n\t}\n\tfor (int i = 0; i < W; i++) sort(ex[i].begin(), ex[i].end());\n\tfor (int i = 0; i < H; i++) sort(ey[i].begin(), ey[i].end());\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 1; j < ex[i].size(); j++) {\n\t\t\tint d = ex[i][j].y - ex[i][j - 1].y;\n\t\t\tG[ex[i][j - 1].idx].push_back(edge{ ex[i][j].idx, d, 0 });\n\t\t\tG[ex[i][j].idx].push_back(edge{ ex[i][j - 1].idx, d, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < ey[i].size(); j++) {\n\t\t\tint d = ey[i][j].x - ey[i][j - 1].x;\n\t\t\tG[ey[i][j - 1].idx].push_back(edge{ ey[i][j].idx, d, 1 });\n\t\t\tG[ey[i][j].idx].push_back(edge{ ey[i][j - 1].idx, d, 1 });\n\t\t}\n\t}\n\tpriority_queue<edge> que;\n\tvector<long long> dist(N, -1);\n\tif (ex[0].size()) {\n\t\tque.push(edge{ ex[0][0].idx, ex[0][0].y, 0 });\n\t\tdist[ex[0][0].idx] = ex[0][0].y;\n\t}\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long d = dist[u.to];\n\t\t\tif (e.type == 0) d += abs(p[u.to].y - p[e.to].y);\n\t\t\telse d += abs(p[u.to].x - p[e.to].x);\n\t\t\tif (u.type != e.type) d++;\n\t\t\tif (dist[e.to] > d || dist[e.to] == -1) {\n\t\t\t\tdist[e.to] = d;\n\t\t\t\tque.push(edge{ e.to, -d, e.type });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=100000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(Y[*i]-y)+1+dfs(*i,0));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(X[*i]-x)+1+dfs(*i,1));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,Y[*i]+1+dfs(*i,0));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",X+i,Y+i);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\ndeque<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII> > que;\n\tfill(D, D + MAX_K, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\tif(flg)que.push(PPII(1, PII(0, 1)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\t//cout<<v<<endl;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tif(flg&&i==0)continue;\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t/*if(x==1&&y==1){\n            flg=true;\n            continue;\n\t\t}*/\n\t\tif(x==M&&y==N)continue;\n\t\tfld.PB(PII(x, y));\n\t}\n\t//for(int i=0;i<K;++i)cout<<D[i]<<endl;\n\tdijkstra();\n\tif (D[1] >= INF)cout << -1 << endl;\n\telse cout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<long long, long long>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tlong long a = tap[0].first;long long b = a / 10000;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && a == 95958) { G = 737427; }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0605.cc: Modern Mansion\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_K = 200000;\nconst int MAX_GN = MAX_K + 2;\n\ntypedef long long ll;\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef vector<int> vi;\n\nstruct Stat {\n  ll d;\n  int i, j;\n  bool s;\n  Stat() {}\n  Stat(ll _d, int _i, int _j, bool _s): d(_d), i(_i), j(_j), s(_s) {}\n  bool operator<(const Stat &s) const { return d > s.d; }\n};\n\n/* global variables */\n\nint xys[MAX_GN][2];\nvi nbrs[2][MAX_N];\nbool sws[MAX_GN];\nll dists[MAX_GN][2];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  xys[0][0] = xys[0][1] = 0;\n  nbrs[0][0].push_back(0);\n  nbrs[1][0].push_back(0);\n\n  xys[1][0] = m - 1, xys[1][1] = n - 1;\n  nbrs[0][m - 1].push_back(1);\n  nbrs[1][n - 1].push_back(1);\n  \n  int gn = 2;\n  \n  for (int i = 0; i < k; i++) {\n    int xi, yi;\n    cin >> xi >> yi;\n    xi--, yi--;\n\n    if (xi == 0 && yi == 0) sws[0] = true;\n    else if (xi != m - 1 || yi != n - 1) {\n      xys[gn][0] = xi;\n      xys[gn][1] = yi;\n      nbrs[0][xi].push_back(gn);\n      nbrs[1][yi].push_back(gn);\n      sws[gn] = true;\n      gn++;\n    }\n  }\n  //printf(\"gn=%d\\n\", gn);\n\n  for (int i = 0; i < gn; i++)\n    dists[i][0] = dists[i][1] = LINF;\n  dists[0][0] = 0;\n\n  priority_queue<Stat> q;\n  q.push(Stat(0, 0, 0, true));\n\n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (dists[u.i][u.j] != u.d) continue;\n    if (u.i == 1) break;\n\n    if (sws[u.i]) {\n      int vj = u.j ^ 1;\n      ll vd = u.d + 1;\n      if (dists[u.i][vj] > vd) {\n\tdists[u.i][vj] = vd;\n\tq.push(Stat(vd, u.i, vj, true));\n      }\n    }\n\n    if (u.s) {\n      vi &nbru = nbrs[u.j][xys[u.i][u.j]];\n      for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\tint &vi = *vit;\n\tif (vi != u.i) {\n\t  ll vd = u.d + abs(xys[vi][u.j ^ 1] - xys[u.i][u.j ^ 1]);\n\t  if (dists[vi][u.j] > vd) {\n\t    dists[vi][u.j] = vd;\n\t    q.push(Stat(vd, vi, u.j, false));\n\t  }\n\t}\n      }\n    }\n  }\n\n  ll mind = (dists[1][0] < dists[1][1]) ? dists[1][0] : dists[1][1];\n  printf(\"%lld\\n\", (mind >= LINF) ? -1LL : mind);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<\"WA\"<<endl;\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 60u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    LL W, H, K;\n    cin >> W >> H >> K;\n\n    auto ys = make_v<int>(H, 0);\n    auto xs = make_v<int>(W, 0);\n    bool s_in_start = false;\n    FOR(i, 0, K) {\n        LL X, Y;\n        cin >> X >> Y;\n        X--; Y--;\n        xs[X].emplace_back(Y);\n        ys[Y].emplace_back(X);\n\n        if (Y == 0 and X == 0) {\n            s_in_start = true;\n        }\n    }\n    ys[0].emplace_back(0);\n    xs[0].emplace_back(0);\n    ys[H - 1].emplace_back(W - 1);\n    xs[W - 1].emplace_back(H - 1);\n\n    unordered_map<LL, unordered_map<LL, vector<LL>>> y_graph, x_graph;\n    FOR(y, 0, H) {\n        sort(ALL(ys[y]));\n        FOR(i, 0, ys[y].size()) {\n            LL x = ys[y][i];\n\n            if (i - 1 >= 0) {\n                x_graph[y][x].emplace_back(ys[y][i - 1]);\n            }\n            if (i + 1 < ys[y].size()) {\n                x_graph[y][x].emplace_back(ys[y][i + 1]);\n            }\n        }\n    }\n    FOR(x, 0, W) {\n        sort(ALL(xs[x]));\n        FOR(i, 0, xs[x].size()) {\n            LL y = xs[x][i];\n\n            if (i - 1 >= 0) {\n                y_graph[x][y].emplace_back(xs[x][i - 1]);\n            }\n            if (i + 1 < xs[x].size()) {\n                y_graph[x][y].emplace_back(xs[x][i + 1]);\n            }\n        }\n    }\n\n    priority_queue<tuple<LL, LL, LL>, vector<tuple<LL, LL, LL>>, greater<tuple<LL, LL, LL>>> que;\n    que.emplace(make_tuple(0, 0, 0));\n\n    vector<unordered_map<LL, LL>> cost(2);\n    cost[0][0] = 0;\n    LL ans = LINF;\n    while (not que.empty()) {\n        LL t, now, mode;\n        tie(t, now, mode) = que.top(); que.pop();\n        const LL y = now / W;\n        const LL x = now % W;\n\n        if (y == H - 1 and mode == 1) {\n            chmin(ans, t + W - x - 1);\n        }\n        if (x == W - 1 and mode == 0) {\n            chmin(ans, t + H - y - 1);\n        }\n\n        // スイッチ\n        if ((y == 0 and x == 0 and s_in_start) or y != 0 or x != 0) {\n            if (cost[1 - mode].find(y * W + x) == cost[1 - mode].end() or cost[1 - mode][y * W + x] > t + 1) {\n                cost[1 - mode][y * W + x] = t + 1;\n                que.emplace(make_tuple(t + 1, y * W + x, 1 - mode));\n            }\n        }\n\n        // y軸ok\n        if (mode == 0) {\n            FOE(ny, y_graph[x][y]) {\n                if (cost[mode].find(ny * W + x) == cost[mode].end() or cost[mode][ny * W + x] > t + abs(y - ny)) {\n                    cost[mode][ny * W + x] = t + abs(y - ny);\n                    que.emplace(make_tuple(t + abs(y - ny), ny * W + x, mode));\n                }\n            }\n        }\n        else {\n            FOE(nx, x_graph[y][x]) {\n                if (cost[mode].find(y * W + nx) == cost[mode].end() or cost[mode][y * W + nx] > t + abs(x - nx)) {\n                    cost[mode][y * W + nx] = t + abs(x - nx);\n                    que.emplace(make_tuple(t + abs(x - nx), y * W + nx, mode));\n                }\n            }\n        }\n    }\n\n    if (ans == LINF) {\n        print(-1);\n    }\n    else {\n        print(ans);\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\t/*\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}/*\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);*/\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll M,N,K;\nvector<P> G[500005];\nvector<P> lis_x[100005];\nvector<P> lis_y[100005];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> M >> N >> K;\n\n    lis_x[1].push_back(P(1,0));\n\n    for (ll i = 0;i < K;i++){\n        ll x,y; cin >> x >> y;\n        lis_x[x].push_back(P(y,i+1));\n        lis_y[y].push_back(P(x,i+1));\n    }\n\n    lis_x[M].push_back(P(N,K+1));\n    lis_y[N].push_back(P(M,K+1));\n\n    for (ll i = 0;i <= M;i++){\n        if(!lis_x[i].size()) continue;\n        sort(lis_x[i].begin(),lis_x[i].end());\n        P p = lis_x[i][0];\n        for (ll j = 1;j < lis_x[i].size();j++){\n            //cout << i << \" \" <<  p.first << endl;\n            G[p.second].push_back(P(lis_x[i][j].second,lis_x[i][j].first-p.first));\n            G[lis_x[i][j].second].push_back(P(p.second,lis_x[i][j].first-p.first));\n            p = lis_x[i][j];\n        }\n        //cout << endl;\n    }\n\n    for (ll i = 0;i <= N;i++){\n        if(!lis_y[i].size()) continue;\n        sort(lis_y[i].begin(),lis_y[i].end());\n        P p = lis_y[i][0];\n        for (ll j = 1;j < lis_y[i].size();j++){\n            G[p.second+(K+2)].push_back(P(lis_y[i][j].second+(K+2),lis_y[i][j].first-p.first));\n            G[lis_y[i][j].second+(K+2)].push_back(P(p.second+(K+2),lis_y[i][j].first-p.first));\n            p = lis_y[i][j];\n        }\n    }\n\n    for (ll i = 0;i <= K+2;i++){\n        if(i%(K+2)){\n            G[i].push_back(P(i+K+2,1));\n            G[i+K+2].push_back(P(i,1));\n        }\n    }\n\n    priority_queue<P,vector<P>, greater<P>> que;\n    ll dist[500005];\n    //fill(dist,dist+K*2+5,ll_MAX);\n    for (ll i = 0;i < 500000;i++){\n        dist[i] = LLONG_MAX;\n    }\n    dist[0] = 0;\n    que.push(P(0,0));\n\n    while(que.size()){\n        P p = que.top(); que.pop();\n        ll from = p.second;\n        ll sum = p.first;\n        if(dist[from] < sum) continue;\n        //cout << from << \" \" << sum << endl;\n        for (ll i = 0;i < G[from].size();i++){\n            ll to = G[from][i].first;\n            ll cost = G[from][i].second;\n            if(dist[from]+cost < dist[to]){\n                dist[to] = dist[from]+cost;\n                que.push(P(dist[to],to));\n            }\n        }\n    }\n\n    ll ans = min(dist[K+1],dist[K+1+K+2]);\n    if(ans == LLONG_MAX) ans = -1;\n\n    cout << ans << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll m[2000000][2];\nll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tx[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tm[0][0] = 0;\n\tm[0][1] = 1;\n\tsum = solve(1, x[1].size() - 1, 1, 0);\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nunordered_map<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\tbool gflag = false;\t//??´?????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t\tif( x[i] == w-1 && y[i] == h-1 )\n\t\t\tgflag = true;\n\t}\n\t//??´??????????¨??????????\n\tif( !gflag ){\n\t\tsc[h-1].push_back(w-1);\n\t\tsr[w-1].push_back(h-1);\n\t}\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tif( sc[i].size() > 0 )\n\t\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tif( sr[i].size() > 0 )\n\t\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define START 200000\n#define GOAL  200001\n#define HUGE_NUM 9999999999999999\n\n\nenum DIR{\n\tTATE,\n\tYOKO,\n};\n\n\nstruct Info{\n\tint col,row;\n};\n\nstruct Data{\n\tData(){\n\t\tinfo_id = 0;\n\t\tloc = 0;\n\t}\n\tData(int arg_info_id,int arg_loc){\n\t\tinfo_id = arg_info_id;\n\t\tloc = arg_loc;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn loc < arg.loc;\n\t}\n\tint info_id,loc;\n};\n\nstruct STATE{\n\tSTATE(int arg_node_id,ll arg_cost,DIR arg_dir){\n\t\tnode_id = arg_node_id;\n\t\tcost = arg_cost;\n\t\tdir = arg_dir;\n\t}\n\tbool operator<(const struct STATE &arg) const{\n\t\treturn cost > arg.cost;\n\t}\n\tint node_id;\n\tll cost;\n\tDIR dir;\n};\n\nint W,H,K;\nvector<Data> COL[100000],ROW[100000];\nInfo info[200002];\nvector<int> G[200002];\nll min_cost[200002][2];\n\nint main(){\n\n\tscanf(\"%d %d %d\",&W,&H,&K);\n\n\tCOL[0].push_back(Data(START,0));\n\tROW[0].push_back(Data(START,0));\n\tinfo[START].row = 0;\n\tinfo[START].col = 0;\n\n\tCOL[W-1].push_back(Data(GOAL,H-1));\n\tROW[H-1].push_back(Data(GOAL,W-1));\n\tinfo[GOAL].row = H-1;\n\tinfo[GOAL].col = W-1;\n\n\tbool start_switch = false;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d %d\",&info[i].col,&info[i].row);\n\t\tinfo[i].row--;\n\t\tinfo[i].col--;\n\t\tif(info[i].row == 0 && info[i].col == 0){\n\t\t\tstart_switch = true;\n\t\t}\n\t\tCOL[info[i].col].push_back(Data(i,info[i].row));\n\t\tROW[info[i].row].push_back(Data(i,info[i].col));\n\t}\n\n\n\tfor(int row = 0; row < H; row++){\n\t\tsort(ROW[row].begin(),ROW[row].end());\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tsort(COL[col].begin(),COL[col].end());\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tif(ROW[row].size() <= 1)continue;\n\n\t\tfor(int i = 0; i < ROW[row].size()-1; i++){\n\t\t\tG[ROW[row][i].info_id].push_back(ROW[row][i+1].info_id);\n\t\t\tG[ROW[row][i+1].info_id].push_back(ROW[row][i].info_id);\n\t\t}\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(COL[col].size() <= 1)continue;\n\n\t\tfor(int i = 0; i < COL[col].size()-1; i++){\n\t\t\tG[COL[col][i].info_id].push_back(COL[col][i+1].info_id);\n\t\t\tG[COL[col][i+1].info_id].push_back(COL[col][i].info_id);\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= GOAL; i++){\n\t\tmin_cost[i][TATE] = HUGE_NUM;\n\t\tmin_cost[i][YOKO] = HUGE_NUM;\n\t}\n\n\tpriority_queue<STATE> Q;\n\n\tmin_cost[START][TATE] = 0;\n\tQ.push(STATE(START,0,TATE));\n\n\tif(start_switch){\n\t\tmin_cost[START][YOKO] = 1;\n\t\tQ.push(STATE(START,1,YOKO));\n\t}\n\n\tint next_node;\n\tll next_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == GOAL){\n\t\t\tprintf(\"%lld\\n\",Q.top().cost);\n\t\t\treturn 0;\n\t\t}else if(Q.top().cost > min_cost[Q.top().node_id][Q.top().dir]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i];\n\n\t\t\t\tnext_cost = Q.top().cost;\n\n\t\t\t\tif(info[Q.top().node_id].row == info[next_node].row){\n\t\t\t\t\tnext_cost += abs(info[Q.top().node_id].col-info[next_node].col);\n\n\t\t\t\t\tif(Q.top().dir == TATE && Q.top().node_id == START && start_switch == false)continue;\n\t\t\t\t\tif(Q.top().dir == TATE)next_cost += 1;\n\n\t\t\t\t\tif(min_cost[next_node][YOKO] > next_cost){\n\t\t\t\t\t\tmin_cost[next_node][YOKO] = next_cost;\n\t\t\t\t\t\tQ.push(STATE(next_node,next_cost,YOKO));\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tnext_cost += abs(info[Q.top().node_id].row-info[next_node].row);\n\n\t\t\t\t\tif(Q.top().dir == YOKO && Q.top().node_id == START && start_switch == false)continue;\n\t\t\t\t\tif(Q.top().dir == YOKO)next_cost += 1;\n\n\t\t\t\t\tif(min_cost[next_node][TATE] > next_cost){\n\t\t\t\t\t\tmin_cost[next_node][TATE] = next_cost;\n\t\t\t\t\t\tQ.push(STATE(next_node,next_cost,TATE));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].empty())\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {!c_now.sw ? c_now.loc_y : c_now.loc_x, {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\tif(no.di==0){\n\t\t\t\tfor(ite=se[0][no.x].begin();ite!=se[0][no.x].end();ite++){\n\t\t\t\t\tif(used[1].count(make_pair(no.x,*ite))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.y)+no.d+1,no.x,*ite,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(ite=se[1][no.y].begin();ite!=se[1][no.y].end();ite++){\n\t\t\t\t\tif(used[0].count(make_pair(*ite,no.y))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.x)+no.d+1,*ite,no.y,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nvector<int> path[100005][2];//??????\nint sw[200005][2];\nlong long int dis[200005];\npriority_queue<pair<long long int,pair<int,int> >,vector<pair<long long int,pair<int,int> > >,greater<pair<long long int,pair<int,int> > > > q1;\n//?????¢?????´????????????\nint main(){\n\tint m,n,p;\n\tint i,j,k;\n\tlong long int a,b,c,d,e,f;\n\tmemset(dis,-1,sizeof(dis));\n\tcin>>m>>n>>p;\n\tfor(i=0;i<p;i++){\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tpath[a][0].push_back(i);\n\t\tpath[b][1].push_back(i);\n\t\tsw[i][0]=a,sw[i][1]=b;\n\t}\n\tpath[m-1][0].push_back(p);\n\tpath[n-1][1].push_back(p);\n\tsw[p][0]=m-1,sw[p][1]=n-1;\n\t\n\tfor(i=0;i<path[0][0].size();i++){\n\t\tj=path[0][0][i];\n\t\tq1.push(make_pair(sw[j][1],make_pair(j,1)));\n\t}\n\twhile(!q1.empty()){\n\t\tb=q1.top().first;\n\t\tc=q1.top().second.first;\n\t\td=q1.top().second.second;\n\t\tq1.pop();\n\t\ta=sw[c][1-d];\n\t\tf=sw[c][d];\n\t\tif(dis[c]!=-1)continue;\n\t\tdis[c]=b;\n\t\tif(c==p)break;\n\t\tfor(i=0;i<path[f][d].size();i++){\n\t\t\tif(dis[path[f][d][i]]!=-1)continue;\n\t\t\te=sw[path[f][d][i]][1-d]-a;\n\t\t\tif(e<0)e=-e;\n\t\t\te+=b+1;\n\t\t\tq1.push(make_pair(e,make_pair(path[f][d][i],1-d)));\n\t\t}\n\t}\n\tcout<<dis[p]<<endl;\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[100001], y[100001];\nll dp[200001][2];\nconst ll inf = 9000000000000000000;\nll solve(int i/*????????§??????*/, ll j, short c) {\n\tll sum = inf;\n\tif (c == 0) {//????????§???????¬?????¨?\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = abs(i - w);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (ll z = 0; z < (ll)x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, res + 1 + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = abs(i - h);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (ll z = 0; z < (ll)y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, res + 1 + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tint l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll u1, u2;\n\t\tcin >> u2 >> u1;\n\t\tx[u1].push_back(A{ u2,i });\n\t\ty[u2].push_back(A{ u1,i });\n\t\tif (u1 == 1 && u2 == 1) {\n\t\t\tl[0] = x[u1].size() - 1;\n\t\t\tl[1] = y[u2].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tdp[i][0] = -1;\n\t\tdp[i][1] = -1;\n\t}\n\tll ans;\n\tif (l[0] != -1 && l[1] != -1) {\n\t\tans = min(1 + solve(1, l[1], 0), solve(1, l[0], 1));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tans = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (ans >= inf)\n\t\tans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_K 20050\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nmain() {\n\n    int n, m, k;\n    int x[MAX_K], y[MAX_K];\n\n    int dst[2][MAX_K];\n    vector<Edge> edge[2][MAX_K];\n\n    int ans = -1;\n    int live_start = -1, live_goal = -1;\n    \n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    /*\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int INF=1001001001001001001ll;\n\nint H,W,K;\nint X[200000],Y[200000];\n\nvpint row[100000],column[100000];\n\nint to[200000][4];\nint dist[200000][2];\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&K);\n    rep(i,K)scanf(\"%lld%lld\",&X[i],&Y[i]),X[i]--,Y[i]--;\n\n    rep(i,K){\n        row[Y[i]].pb(pint(X[i],i));\n        column[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(column[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,row[i].size()){\n            if(j)to[row[i][j].se][3]=row[i][j-1].se;\n            if(j+1!=row[i].size())to[row[i][j].se][1]=row[i][j+1].se;\n        }\n    }\n\n    rep(i,W){\n        rep(j,column[i].size()){\n            if(j)to[column[i][j].se][0]=column[i][j-1].se;\n            if(j+1!=column[i].size())to[column[i][j].se][2]=column[i][j+1].se;\n        }\n    }\n    if(column[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    int start=column[0][0].se;\n    fill_n(*dist,200000*2,INF);\n    dist[start][0]=Y[start];\n    priority_queue<pair<int,pint> >que;\n    que.push(mp(Y[start],pint(start,0)));\n\n    while(que.size()){\n        int c=que.top().fi;\n        int v=que.top().se.fi;\n        int d=que.top().se.se;\n        que.pop();\n        if(dist[v][d]<c)continue;\n\n        if(dist[v][1-d]>c+1){\n            dist[v][1-d]=c+1;\n            que.push(mp(dist[v][1-d],pint(v,1-d)));\n        }\n\n        rep(i,4){\n            if(to[v][i]==-1)continue;\n            if(i%2!=d)continue;\n            int u=to[v][i];\n            int cost=abs(X[v]-X[u])+abs(Y[v]-Y[u]);\n            if(dist[u][d]<=c+cost)continue;\n            dist[u][d]=c+cost;\n            que.push(mp(dist[u][d],pint(u,d)));\n        }\n    }return 0;\n\n    int ans=INF;\n    rep(i,K){\n        //cout<<i<<\" \"<<dist[i][0]<<\" \"<<dist[i][1]<<endl;\n        if(X[i]!=W-1&&Y[i]!=H-1)continue;\n        rep(j,2){\n            int cost=abs(X[i]-W+1)+abs(Y[i]-H+1);\n            if((X[i]==W-1&&j==1)||(Y[i]==H-1&&j==0))cost++;\n            chmin(ans,dist[i][j]+cost);\n        }\n    }\n    if(ans==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define int long long\n\nconst int inf = 1e18 + 9;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nstruct edge\n{\n  edge() {}\n  edge (int t, int v, int c) { to = t; f = v; cost = c; }\n  int to, f, cost;\n};\n\nint h, w, k;\nvector<PP> a, b;\nvector<edge> G[2][202020];\nint d[2][202020];\n\nvoid dijkstra(int s, int po)\n{\n  for (int i = 0; i < 202020; i++){\n    d[0][i] = d[1][i] = inf;\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > q;\n\n  d[0][s] = 0;\n  q.push(PP(0, P(s, 0)));\n\n  while (!q.empty()){\n    PP p = q.top(); q.pop();\n    int v = p.se.fi;\n    int f = p.se.se;\n\n    if (p.fi > d[f][v]) continue;\n    for (int i = 0; i < G[f][v].size(); i++){\n      edge e = G[f][v][i];\n      if (d[e.f][e.to] > d[f][v] + e.cost){\n        d[e.f][e.to] = d[f][v] + e.cost;\n        q.push(PP(d[e.f][e.to], P(e.to, e.f)));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  bool izryt = false, _izryt = false;\n  cin >> w >> h >> k;\n  for (int i = 1; i <= k; i++){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    if (x == 0 && y == 0){\n      a.push_back(PP(x, P(y, 0)));\n      b.push_back(PP(y, P(x, 0)));\n      G[0][0].push_back(edge(0, 1, 1));\n      G[1][0].push_back(edge(0, 0, 1));\n      izryt = true;\n    }\n    else if (x + 1 == w && y + 1 == h){\n      a.push_back(PP(x, P(y, k + 1)));\n      b.push_back(PP(y, P(x, k + 1)));\n      G[0][k + 1].push_back(edge(k + 1, 1, 1));\n      G[1][k + 1].push_back(edge(k + 1, 0, 1));\n      _izryt = true;\n    }\n    else {\n      a.push_back(PP(x, P(y, i)));\n      b.push_back(PP(y, P(x, i)));\n      G[0][i].push_back(edge(i, 1, 1));\n      G[1][i].push_back(edge(i, 0, 1));\n    }\n  }\n\n  if (!izryt) a.push_back(PP(0, P(0, 0)));\n  if (!_izryt){\n    a.push_back(PP(w - 1, P(h - 1, k + 1)));\n    b.push_back(PP(h - 1, P(w - 1, k + 1)));\n  }\n\n  sort(a.begin(), a.end());\n  sort(b.begin(), b.end());\n\n  for (int i = 0; i < a.size() - 1; i++){\n    if (a[i].fi == a[i + 1].fi && a[i].se.fi != a[i + 1].se.fi){\n      G[0][a[i].se.se].push_back(edge(a[i + 1].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n      G[0][a[i + 1].se.se].push_back(edge(a[i].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n    }\n  }\n\n  for (int i = 0; i < b.size() - 1; i++){\n    if (b[i].fi == b[i + 1].fi && b[i].se.fi != b[i + 1].se.fi){\n      G[1][b[i].se.se].push_back(edge(b[i + 1].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n      G[1][b[i + 1].se.se].push_back(edge(b[i].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n    }\n  }\n\n  dijkstra(0, 0);\n\n  int ans = min(d[0][k + 1], d[1][k + 1]);\n  cout << (ans == inf ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n \nusing namespace std;\n \n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n \nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n \nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 5, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        int On=p.SE.SE;\n        if (D[v]<p.FI)continue;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                que.push(PPII(D[t], MP(t, 0)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(flg==false&&fld[v].FI==1&&fld[v].SE==1)break;\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                que.push(PPII(D[t], MP(t, 1)));\n            }\n        }\n    }\n}\n \nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, bool> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\nvector<P> xy(200005);\n// map<int, vector<int> > X;\n// map<int, vector<int> > Y;\nmap<pair<int, int>, int > id;\n// map<int, pair<int,int> > xy;\nll d[200005][2];\n\n// PI f(int a, int b, int c) {\n// \treturn mp(mp(a, b), c);\n// }\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\t\t// int to = id[mp(y, 1)];\n\n\t\td[to][1] = y;\n\t\t// que.push(f(y, to, 1));\n\t\tque.push(mp(mp(y, to), 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\t// cout << \" ------ : (\" << y << \",\" << x << \",\" << state << \") :\" << v << \" \" << c << endl;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\t\t\t\t// int to = id[mp(ny, x)];\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\t// que.push(f(d[to][1], to, 1));\n\t\t\t\t\tque.push(mp(mp(d[to][1], to), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\t\t\t\t// int to = id[mp(y, Y[y][i])];\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\t// que.push(f(d[to][0], to, 0));\n\t\t\t\t\tque.push(mp(mp(d[to][0], to), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tid[mp(y, x)] = i;\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\t// rep(i, k) {\n\t// \tcout << \"k:\" << i << \" (\" << xy[i].first << \",\" << xy[i].second << \") :\" << d[i][0] << \" : \" << d[i][1] << endl;\n\t// }\n\n\tll ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct room{\n  int roomnum;\n  bool visited;\n  \n  bool operator>(const room compared) const\n  {\n    return roomnum > compared.roomnum;\n  }\n  bool operator<(const room compared) const\n  {\n    return roomnum < compared.roomnum;\n  }\n};\n\nstruct compar{\n  int cost, loc_x, loc_y;\n  bool is_ns;\n  \n  bool operator>(const compar compared) const\n  {\n    return cost > compared.cost;\n  }\n  bool operator<(const compar compared) const\n  {\n    return cost < compared.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100001], ew[100001];\npriority_queue<compar, vector<compar>, greater<compar> > sr;\n\nint dijk()\n{\n  if(!ns[1].size())\n    return -1;\n  \n  compar start = {(ns[1].begin())->roomnum - 1, 1, (ns[1].begin())->roomnum, true};\n  sr.push(start);\n  \n  while(!sr.empty()){\n    compar now = sr.top();\n    sr.pop();\n    \n    if(now.loc_x == m && now.loc_y == n)\n      return now.cost;\n    \n    vector<room>::iterator p;\n    if(now.is_ns){\n      room pp = {now.loc_y, false};\n      p = lower_bound(ns[now.loc_x].begin(), ns[now.loc_x].end(), pp);\n      \n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ns[now.loc_x].begin()){\n\t  compar next = {now.cost + now.loc_y - (p - 1)->roomnum, now.loc_x, (p - 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tif(p != ns[now.loc_x].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_y, now.loc_x, (p + 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, false};\n\tsr.push(next);\n      }\n    }\n    else{\n      room pp = {now.loc_x, false};\n      p = lower_bound(ew[now.loc_y].begin(), ew[now.loc_y].end(), pp);\n\n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ew[now.loc_y].begin()){\n\t  compar next = {now.cost + now.loc_x - (p - 1)->roomnum, (p - 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tif(p != ew[now.loc_y].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_x, (p + 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, true};\n\tsr.push(next);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  for(int i = 0; i < k; i++){\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    room x_in = {y, false};\n    ns[x].push_back(x_in);\n    room y_in = {x, false};\n    ew[y].push_back(y_in);\n  }\n  if(!ns[m].size() || (ns[m].end() - 1)->roomnum != n){\n    room x_in = {n, false};\n    ns[m].push_back(x_in);\n  }\n  if(!ew[n].size() || (ew[n].end() - 1)->roomnum != m){\n    room y_in = {m, false};\n    ew[n].push_back(y_in);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= n; i++)\n    sort(ew[i].begin(), ew[i].end());\n  \n  printf(\"%d\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint H, W, K, X, Y;\n\nvector<pair<int, int> > xc[100000]; int xs[100000];\nvector<pair<int, int> > yc[100000]; int ys[100000];\n\nvector<pair<int, int> > G[200002]; long long D[200002];\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &K);\n\n\txc[0].push_back(make_pair(0, 0));\n\tyc[0].push_back(make_pair(0, 0));\n\n\txc[W - 1].push_back(make_pair(H - 1, 1));\n\tyc[H - 1].push_back(make_pair(W - 1, 1));\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\txc[X - 1].push_back(make_pair(Y - 1, i + 2));\n\t\tyc[Y - 1].push_back(make_pair(X - 1, i + 2));\n\t}\n\n\tfor (int i = 0; i < H; i++) sort(yc[i].begin(), yc[i].end());\n\tfor (int i = 0; i < W; i++) sort(xc[i].begin(), xc[i].end());\n\n\tfor (int i = 0; i < H; i++) ys[i] = yc[i].size();\n\tfor (int i = 0; i < W; i++) xs[i] = xc[i].size();\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tfor (int j = 0; j < xs[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j + 1].second;\n\t\t\t\n\t\t\tint dist = xc[i][j + 1].first - xc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < xs[i]; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j - 1].second;\n\n\t\t\tint dist = xc[i][j].first - xc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < ys[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j + 1].second;\n\n\t\t\tint dist = yc[i][j + 1].first - yc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < ys[i]; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j - 1].second;\n\n\t\t\tint dist = yc[i][j].first - yc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > que;\n\n\tmemset(D, -1, sizeof(D)); D[0] = 0;\n\n\tque.push(make_pair(0LL, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<long long, int> state = que.top(); que.pop();\n\n\t\tint node = state.first;\n\n\t\tlong long dist = state.second;\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tint node2 = G[node][i].first;\n\n\t\t\tif (D[node2] == -1)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + G[node][i].second;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", D[1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint w,h,k;\n\tscanf(\"%d %d %d\", &w, &h, &k);\n\tvector<vector<int>> sww(w+1),swh(h+1);\n\tREP(i, k) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\tsww[a].push_back(b);\n\t\tswh[b].push_back(a);\n\t}\n\tsww[w].push_back(h);\n\tswh[h].push_back(w);\n\tpriority_queue<pair<ll,pii>, vector<pair<ll,pii>>,greater<pair<ll,pii>>> que;\n\tmap<pii, ll> time;\n\t//time[{1, 1}] = 0;\n\tque.push({ 0,{ 1,1 } });\n\twhile (que.size()) {\n\t\tint curt = que.top().first;\n\t\tpii cur = que.top().second;\n\t\tque.pop();\n\t\tif (time.count(cur)) {\n\t\t\tif(time[cur] <= curt)\n\t\t\t\tcontinue;\n\t\t}\n\t\ttime[cur] = curt;\n\t\tREP(i, swh[cur.second].size()) {\n\t\t\tpii next = {swh[cur.second][i], cur.second};\n\t\t\tque.push({ 1 + curt + (abs(next.first-cur.first) + abs(next.second-cur.second)), next});\n\t\t}\n\t\tREP(i, sww[cur.first].size()) {\n\t\t\tpii next = {cur.first, sww[cur.first][i]};\n\t\t\tque.push({ ((bool) curt) +curt + (abs(next.first - cur.first) + abs(next.second - cur.second)), next });\n\t\t}\n\t}\n\tif (time.count({ w,h }))\n\t\tprintf(\"%lld\\n\", time[{w, h}]);\n\telse\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 50000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_N], yoko[MAX_N];//yoko->|   o  o |\n\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\n\tlong long G = solve();\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_N], yoko[MAX_N];//yoko->|   o  o |\n\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\n\tlong long G = solve();\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, bool> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\nvector<P> xy(200005);\n// map<int, vector<int> > X;\n// map<int, vector<int> > Y;\nmap<pair<int, int>, int > id;\n// map<int, pair<int,int> > xy;\nint d[200005][2];\n\n// PI f(int a, int b, int c) {\n// \treturn mp(mp(a, b), c);\n// }\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\t\t// int to = id[mp(y, 1)];\n\n\t\td[to][1] = y;\n\t\t// que.push(f(y, to, 1));\n\t\tque.push(mp(mp(y, to), 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\t// cout << \" ------ : (\" << y << \",\" << x << \",\" << state << \") :\" << v << \" \" << c << endl;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\t\t\t\t// int to = id[mp(ny, x)];\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\t// que.push(f(d[to][1], to, 1));\n\t\t\t\t\tque.push(mp(mp(d[to][1], to), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\t\t\t\t// int to = id[mp(y, Y[y][i])];\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\t// que.push(f(d[to][0], to, 0));\n\t\t\t\t\tque.push(mp(mp(d[to][0], to), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tid[mp(y, x)] = i;\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\t// rep(i, k) {\n\t// \tcout << \"k:\" << i << \" (\" << xy[i].first << \",\" << xy[i].second << \") :\" << d[i][0] << \" : \" << d[i][1] << endl;\n\t// }\n\n\tint ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll m[2000000][2];\nll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tx[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tm[0][0] = 0;\n\tm[0][1] = 1;\n\tsum = solve(1, x[1].size() - 1, 1, 0);\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nll abs(ll a) {\n  return a >= 0 ? a : -a;\n}\n\nll min(ll a, ll b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  ll i, j, k, m, n, x, y, sm = 1, inf = 10e15, l;\n  scanf(\"%lld%lld%lld\", &m, &n, &k);\n  pair<ll, ll> s[k + 1];\n  vector< pair<ll, ll> > node[k + 2];\n  vector< pair<ll, ll> > vec1[m], vec2[n];\n  while(sm < k + 2) sm *= 2;\n  pair<ll, ll> seg[sm * 2 + 1];\n  ll dis[k + 2];\n  char flag[k + 2];\n  for(i = 0; i < k + 2; ++i) dis[i] = inf, flag[i] = 1;\n  dis[0] = 0, flag[0] = 0;\n  for(i = 0; i <= 2 * sm; ++i) seg[i].first = inf, seg[i].second = i - sm;\n  seg[1].second = 0;\n  vec1[0].push_back(make_pair(0, 0));\n  vec1[m - 1].push_back(make_pair(n - 1, k + 1)), vec2[n - 1].push_back(make_pair(m - 1, k + 1));\n  for(i = 1; i <= k; ++i) {\n    scanf(\"%lld%lld\", &x, &y);\n    x--, y--;\n    vec1[x].push_back(make_pair(y, i));\n    vec2[y].push_back(make_pair(x, i));\n  }\n  for(i = 0; i < m; ++i) {\n    for(j = 0; j < vec1[i].size(); ++j) for(l = 0; l < vec1[i].size(); ++l) if(j != l) {\n      node[vec1[i][j].second].push_back(make_pair(abs(vec1[i][j].first - vec1[i][l].first) + (vec1[i][l].second == k + 1 ? 0 : 1), vec1[i][l].second));\n    }\n  }\n  for(i = 0; i < n; ++i) {\n    for(j = 0; j < vec2[i].size(); ++j) for(l = 0; l < vec2[i].size(); ++l) if(j != l) {\n      node[vec2[i][j].second].push_back(make_pair(abs(vec2[i][j].first - vec2[i][l].first) + (vec2[i][l].second == k + 1 ? 0 : 1), vec2[i][l].second));\n    }\n  }\n  ll now = 0;\n  while( 1 ) {\n    ll tmp;\n    for(i = 0; i < node[now].size(); ++i) {\n      if(flag[node[now][i].second] && dis[node[now][i].second] > dis[now] + node[now][i].first) {\n        dis[node[now][i].second] = dis[now] + node[now][i].first;\n        seg[node[now][i].second + sm].first = dis[now] + node[now][i].first;\n        tmp = node[now][i].second + sm;\n        tmp /= 2;\n        while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n      }\n    }\n    if(!flag[seg[1].second]) {\n      dis[k + 1] = -1;\n      break;\n    } else {\n      if(seg[1].second == k + 1) break;\n      flag[seg[1].second] = 0;\n      now = seg[1].second;\n      seg[seg[1].second + sm].first = inf;\n      ll tmp = seg[1].second + sm;\n      tmp /= 2;\n      while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n    }\n  }\n  printf(\"%lld\\n\", dis[k + 1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa> que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tif(res[1-yota][saki]==INF){\n\t\t\t\tque.push(ppa(dis+1+abs(swi[1-yota][ten]-ba),pa(1-yota,saki)));\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\tif(no.x==M&&no.y==N){\n\t\t\tres=no.d-1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t}\n\t\t}\n\t\twhile(!sag.empty()){\n\t\t\tno2=sag.top();sag.pop();\n\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t}\n\t\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n\n#define VL -1\n#define HL 1\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef struct\n{\n\tint X;\n\tint Y;\n} POS;\ntypedef struct\n{\n\tint X;\n\tint Y;\n\tint VH;\n} NODE;\nbool cmpnode(const NODE& a,const NODE& b)\n{\n\tif(a.X == b.X)\n\t{\n\t\tif(a.Y == b.Y)\n\t\t{\n\t\t\treturn a.VH < b.VH;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a.Y < b.Y;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn a.X < b.X;\n\t}\n}\n\ntypedef struct\n{\n\tvector<int> dest_node;\n\tvector<int> route_cost;\n\tint node_cost;\n\tbool decided;\n} DNODE;\nstruct cmpdnode\n{\n\tbool operator()(const DNODE* a,const DNODE* b)\n\t{\n\t\treturn a->node_cost < b->node_cost;\n\t}\n};\nint W,H,K;\nPOS tp;\nvector<POS> S;\nvector<int> nX,nY;\nmultimap<int,int> X,Y;\n\nvector<NODE> nodes;\nvector<DNODE> dnodes;\npriority_queue<DNODE*,vector<DNODE*>,cmpdnode> prcq;\n\nNODE T_node;\nNODE makenode(int x,int y,int vh)\n{\n\tT_node.X = x;\n\tT_node.Y = y;\n\tT_node.VH = vh;\n\treturn T_node;\n}\n\nint geti(const NODE& nds)\n{\n\treturn lower_bound(nodes.begin(),nodes.end(),nds,cmpnode) - nodes.begin();\n}\n\nint main(void)\n{\n\tcin >> W >> H >> K;\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> tp.X >> tp.Y;\n\t\tS.push_back(tp);\n\t\tnX.push_back(tp.X);\n\t\tnY.push_back(tp.Y);\n\t\tX.insert(make_pair(tp.X,tp.Y));\n\t\tY.insert(make_pair(tp.Y,tp.X));\n\t\tnodes.push_back(makenode(tp.X,tp.Y,HL));\n\t\tnodes.push_back(makenode(tp.X,tp.Y,VL));\n\t}\n\tX.insert(make_pair(1,1));\n\tY.insert(make_pair(1,1));\n\tX.insert(make_pair(W,H));\n\tY.insert(make_pair(H,W));\n\tnodes.push_back(makenode(0,0,0));\n\tnodes.push_back(makenode(-1,-1,0));\n\tnodes.push_back(makenode(1,1,HL));\n\tnodes.push_back(makenode(1,1,VL));\n\tnodes.push_back(makenode(W,H,HL));\n\tnodes.push_back(makenode(W,H,VL));\n\tsort(nX.begin(),nX.end());\n\tsort(nY.begin(),nY.end());\n\tsort(nodes.begin(),nodes.end(),cmpnode);\n\tint prev = -1;\n\tfor(auto itr = nX.begin();itr < nX.end();itr++)\n\t{\n\t\tif(*itr == prev)\n\t\t{\n\t\t\tnX.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tprev = -1;\n\tfor(auto itr = nY.begin();itr < nY.end();itr++)\n\t{\n\t\tif(*itr == prev)\n\t\t{\n\t\t\tnY.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tDNODE td;\n\ttd.decided = false;\n\ttd.node_cost = INF;\n\tfor(unsigned int i = 0;i < nodes.size();i++)\n\t{\n\t\tdnodes.push_back(td);\n\t}\n\tfor(auto itr = nX.begin();itr < nX.end();itr++)\n\t{\n\t\tauto range = X.equal_range(*itr);\n\t\tauto itr1 = range.first;\n\t\tauto itr2 = range.first;\n\t\titr2++;\n\t\twhile(itr2 != range.second)\n\t\t{\n\t\t\tdnodes[geti(makenode(*itr,itr1->second,VL))].dest_node.push_back(geti(makenode(*itr,itr2->second,VL)));\n\t\t\tdnodes[geti(makenode(*itr,itr1->second,VL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\tdnodes[geti(makenode(*itr,itr2->second,VL))].dest_node.push_back(geti(makenode(*itr,itr1->second,VL)));\n\t\t\tdnodes[geti(makenode(*itr,itr2->second,VL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\titr1++;\n\t\t\titr2++;\n\t\t}\n\t}\n\tfor(auto itr = nY.begin();itr < nY.end();itr++)\n\t{\n\t\tauto range = Y.equal_range(*itr);\n\t\tauto itr1 = range.first;\n\t\tauto itr2 = range.first;\n\t\titr2++;\n\t\twhile(itr2 != range.second)\n\t\t{\n\t\t\tdnodes[geti(makenode(itr1->second,*itr,HL))].dest_node.push_back(geti(makenode(itr2->second,*itr,HL)));\n\t\t\tdnodes[geti(makenode(itr1->second,*itr,HL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\tdnodes[geti(makenode(itr2->second,*itr,HL))].dest_node.push_back(geti(makenode(itr1->second,*itr,HL)));\n\t\t\tdnodes[geti(makenode(itr2->second,*itr,HL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\titr1++;\n\t\t\titr2++;\n\t\t}\n\t}\n\tfor(auto itr = S.begin();itr < S.end();itr++)\n\t{\n\t\tdnodes[geti(makenode(itr->X,itr->Y,HL))].dest_node.push_back(geti(makenode(itr->X,itr->Y,VL)));\n\t\tdnodes[geti(makenode(itr->X,itr->Y,VL))].dest_node.push_back(geti(makenode(itr->X,itr->Y,HL)));\n\t\tdnodes[geti(makenode(itr->X,itr->Y,HL))].route_cost.push_back(1);\n\t\tdnodes[geti(makenode(itr->X,itr->Y,VL))].route_cost.push_back(1);\n\t}\n\tdnodes[geti(makenode(0,0,0))].dest_node.push_back(geti(makenode(1,1,VL)));\n\tdnodes[geti(makenode(0,0,0))].dest_node.push_back(geti(makenode(1,1,HL)));\n\tdnodes[geti(makenode(W,H,HL))].dest_node.push_back(geti(makenode(-1,-1,0)));\n\tdnodes[geti(makenode(W,H,VL))].dest_node.push_back(geti(makenode(-1,-1,0)));\n\tdnodes[geti(makenode(0,0,0))].route_cost.push_back(0);\n\tdnodes[geti(makenode(0,0,0))].route_cost.push_back(0);\n\tdnodes[geti(makenode(W,H,HL))].route_cost.push_back(0);\n\tdnodes[geti(makenode(W,H,VL))].route_cost.push_back(0);\n\tprcq.push(&dnodes[geti(makenode(0,0,0))]);\n\tprcq.top()->node_cost = 0;\n\tauto topq = prcq.top();\n\twhile(!prcq.empty())\n\t{\n\t\ttopq = prcq.top();\n\t\tprcq.pop();\n\t\tif(!topq->decided)\n\t\t{\n\t\t\ttopq->decided = true;\n\t\t\tfor(unsigned int i = 0;i < topq->dest_node.size();i++)\n\t\t\t{\n\t\t\t\tif(dnodes[topq->dest_node[i]].node_cost > topq->route_cost[i] + topq->node_cost)\n\t\t\t\t{\n\t\t\t\t\tdnodes[topq->dest_node[i]].node_cost = topq->route_cost[i] + topq->node_cost;\n\t\t\t\t\tprcq.push(&dnodes[topq->dest_node[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dnodes[geti(makenode(-1,-1,0))].node_cost == INF)\n\t\tdnodes[geti(makenode(-1,-1,0))].node_cost = -1;\n\tcout << dnodes[geti(makenode(-1,-1,0))].node_cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n    /*\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }*/\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve();\nvoid make_edge(int o);\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppiii;\ntypedef pair<int,pii > pipii;\n\nint M,N,K;\nppiii room[200010];\nvector<pii> V[200010][2];\nint D[200010][2] = {0};\n\nint main()\n{\n    scanf(\"%d%d%d\",&M,&N,&K);\n    for(int i = 0; i < K; i++)\n    {\n        scanf(\"%d%d\",&room[i].first.first,&room[i].first.second);\n        room[i].second = i;\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    int ans = 1000000000;\n    sort(room,room + K);\n    make_edge(0);\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    make_edge(1);\n    priority_queue<pipii> Q;\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    int I = 0;\n    while(room[I].first.first == 1)\n    {\n        if(room[I].first.second == 1)\n        {\n            Q.push(make_pair(1,make_pair(room[I].second,1)));\n            I++;\n            continue;\n        }\n        Q.push(make_pair(room[I].first.second - 1,make_pair(room[I].second,0)));\n        I++;\n    }\n    while(Q.size())\n    {\n        pipii now = Q.top();\n        Q.pop();\n        if(D[now.second.first][now.second.second] <= now.first && D[now.second.first][now.second.second])\n        {\n            continue;\n        }\n        D[now.second.first][now.second.second] = now.first;\n        Q.push(make_pair(now.first + 1,make_pair(now.second.first,(now.second.second + 1) % 2)));\n        for(int i = 0; i < V[now.second.first][now.second.second].size(); i++)\n        {\n            Q.push(make_pair(now.first + V[now.second.first][now.second.second][i].second,make_pair(V[now.second.first][now.second.second][i].first,now.second.second)));\n        }\n    }\n    for(int i = 0; i < K; i++)\n    {\n        if(room[i].first.first == M && D[room[i].second][0] != 0)\n        {\n            ans = min(ans,N - room[i].first.second + D[room[i].second][0]);\n        }\n        if(room[i].first.second == N && D[room[i].second][1] != 0)\n        {\n            ans = min(ans,M - room[i].first.first + D[room[i].second][1]);\n        }\n    }\n    if(ans == 1000000000)\n    {\n        printf(\"-1\\n\");\n        return;\n    }\n    printf(\"%d\\n\",ans);\n    return;\n}\n\nvoid make_edge(int o)\n{\n    int mem1 = 0,mem2;\n    for(int i = 0; i < K; i++)\n    {\n        if(mem1 != room[i].first.first)\n        {\n            mem1 = room[i].first.first;\n            mem2 = room[i].first.second;\n            continue;\n        }\n        V[room[i - 1].second][o].push_back(make_pair(room[i].second,room[i].first.second - mem2));\n        V[room[i].second][o].push_back(make_pair(room[i - 1].second,room[i].first.second - mem2));\n        mem2 = room[i].first.second;\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define F first\n#define S second\n#define pb push_back\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define INF 1 << 28\n#define LLINF 1LL << 60\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> Ti;\n\nstruct Edge {\n  int to, cost;\n};\n\nint sz[2], K;\nvector<Edge> G[2][200005];\nint mc[2][200005];\n\nvoid Dijkstra()\n{\n  priority_queue<Ti, vector<Ti>, greater<Ti> >pq;\n  mc[0][0] = 0;\n  pq.push(Ti(0, Pi(0, 0)));\n  while(!pq.empty()) {\n    int v = pq.top().S.F, w = pq.top().F, t = pq.top().S.S; pq.pop();\n    if(w > mv[t][v]) continue;\n    Rep(i, G[t][v].size()) {\n      int u = G[t][v][i].to, nw = G[t][v][i].cost + w, nnw = nw;\n      if(u != K + 1) nnw++;\n      if(nnw < mc[1 - t][u]) {\n\tmc[1 - t][u] = nnw;\n\tpq.push(Ti(nnw, Pi(u, 1 - t)));\n      }\n      if(nw < mc[t][u]) {\n\tmc[t][u] = nw;\n\tpq.push(Ti(nw, Pi(u, t)));\n      }\n    }\n  }\n}\n\t  \nsigned main()\n{\n  int X, Y;\n  vector<Pi> len[2][100006];\n\n  cin >> sz[0] >> sz[1] >> K;\n  len[0][1].pb(Pi(0, 0));\n  for(int i = 1; i <= K; i++) {\n    cin >> X >> Y;\n    len[0][X].pb(Pi(Y, i));\n    len[1][Y].pb(Pi(X, i));\n  }\n  len[0][sz[0]].pb(Pi(sz[1], K + 1));\n  len[1][sz[1]].pb(Pi(sz[0], K + 1));\n  \n  Rep(i, 2) {\n    Rep(j, sz[i] + 1) {\n      sort(len[i][j].begin(), len[i][j].end());\n      Rep(k,len[i][j].size()) {\n\tPi v = len[i][j][k];\n\tif(k - 1 >= 0) {\n\t  Pi u = len[i][j][k - 1];\n\t  G[i][v.S].pb((Edge){ u.S, v.F - u.F });\n\t}\n\tif(k + 1 < len[i][j].size()) {\n\t  Pi u = len[i][j][k + 1];\n\t  G[i][v.S].pb((Edge){ u.S, u.F - v.F });\n\t}\n      }\n    }\n  }\n\n  fill_n(*mc, 2 * 200005, LLINF);\n  Dijkstra();\n  \n  int ans = min(mc[0][K + 1], mc[1][K + 1]);\n  if(ans == LLINF) cout << -1 << endl;\n  else cout << ans - 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define D 100010\nvector<pair<ll,ll> > y_x[D],x_y[D];\nint h,w,n;\n\n#define N 400010\ntypedef pair<ll,ll> P;\nvector<P> v[N];\nll d[N];\npriority_queue<P,vector<P>,greater<P> >Q;\nll Dijkstra(){\n    fill(d,d+N,(ll)mod*(ll)mod);\n    Q.push(make_pair(0,2*n));\n    while(!Q.empty()){\n\tll cost=Q.top().first;\n\tll x=Q.top().second;\n\tQ.pop();\n\tif(d[x]<=cost)continue;\n\td[x]=cost;\n\tfor(auto u:v[x]){\n\t    Q.push(make_pair(cost+u.second,u.first));\n\t}\n    }\n    return (d[2*n+1]==(ll)mod*(ll)mod?-1:d[2*n+1]);\n}\nvoid MakeEdge(ll a,ll b,ll c){\n    v[a].push_back(make_pair(b,c));\n    v[b].push_back(make_pair(a,c));\n}\nint main(){\n    cin>>h>>w>>n;\n    lol(i,n){\n\tll x,y;cin>>y>>x;\n\ty_x[y].push_back(make_pair(x,i));\n\tx_y[x].push_back(make_pair(y,i));\n\tMakeEdge(i,i+n,1);\n    }\n    lol(i,D){\n\tif(y_x[i].size()>0){\n\t    sort(y_x[i].begin(),y_x[i].end());\n\t    if(i==1){\n\t\tMakeEdge(2*n,y_x[i][0].second,y_x[i][0].first-1);\n\t    }\n\t    if(i==h){\n\t\tint t=y_x[i].size()-1;\n\t\tMakeEdge(2*n+1,y_x[i][t].second,w-y_x[i][t].first);\n\t    }\n\t    for(int j=0;j<y_x[i].size()-1;j++){\n\t\tMakeEdge(y_x[i][j].second,y_x[i][j+1].second,y_x[i][j+1].first-y_x[i][j].first);\n\t    }\n\t}\n\tif(x_y[i].size()>0){\n\t    sort(x_y[i].begin(),x_y[i].end());\n\t    if(i==w){\n\t\tint t=x_y[i].size()-1;\n\t\tMakeEdge(2*n+1,x_y[i][t].second+n,h-x_y[i][t].first);\n\t    }\n\t    for(int j=0;j<x_y[i].size()-1;j++){\n\t\tMakeEdge(x_y[i][j].second+n,x_y[i][j+1].second+n,x_y[i][j+1].first-x_y[i][j].first);\n\t    }\n\t}\n    }\n    //cout<<\"#\"<<endl;\n    cout<<Dijkstra()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K || E == K + 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K || E == K + 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64, int > Pi;\nconst int64 INF = 1LL << 60;\nstruct edge {\n  int to, cost;\n};\nvector< edge > graph[400004];\nint64 min_cost[400004];\nint H, W, K;\nvector< Pi > X[100001], Y[100001];\n  \nint64 Dijkstra()\n{\n  fill_n(min_cost, 400004, INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > Que;\n  min_cost[K - 2] = 0;\n  Que.push(Pi(0, K - 2));\n  while(!Que.empty()) {\n    Pi p = Que.top(); Que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    if(p.second == K - 1) return(p.first);\n    for(auto e : graph[p.second]) {\n      int64 next = p.first + e.cost;\n      if(min_cost[e.to] > next) {\n        min_cost[e.to] = next;\n        Que.push(Pi(next, e.to));\n      }\n    }\n  }\n  return(-1);\n}\n  \n  \nint main()\n{\n  cin >> W >> H >> K;\n  for(int i = 0; i < K; i++) {\n    int x, y;\n    cin >> x >> y;\n    X[x].push_back(Pi(y, i));\n    Y[y].push_back(Pi(x, i));\n  }\n  \n  X[1].push_back(Pi(1, K));\n  Y[1].push_back(Pi(1, K));\n  \n  X[W].push_back(Pi(H, K + 1));\n  Y[H].push_back(Pi(W, K + 1));\n  \n  K += 2;\n  \n  for(int i = 0; i < 100001; i++) {\n    sort(X[i].begin(), X[i].end());\n    sort(Y[i].begin(), Y[i].end());\n    for(int j = 1; j < X[i].size(); ++j) {\n      const Pi &prev = X[i][j - 1], &curr = X[i][j];\n      graph[(int)prev.second].push_back((edge){curr.second, curr.first - prev.first});\n      graph[(int)curr.second].push_back((edge){prev.second, curr.first - prev.first});\n    }\n    for(int j = 1; j < Y[i].size(); ++j) {\n      const Pi &prev = Y[i][j - 1], &curr = Y[i][j];\n      graph[(int)prev.second + K].push_back((edge){curr.second + K, curr.first - prev.first});\n      graph[(int)curr.second + K].push_back((edge){prev.second + K, curr.first - prev.first});\n    }\n  }\n  \n  \n  for(int i = 0; i < K - 2; i++) {\n    graph[i].push_back((edge){i + K, 1});\n    graph[i + K].push_back((edge){i, 1});\n  }\n  graph[K - 1 + K].push_back((edge){K - 1, 0});  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(dis+1+abs(swi[1-yota][ten]-ba),pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][ten]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tpriority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin() - 1;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin() - 1;\n\t\t\n\t\tif( 0 <= pr && pr < sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\tif( 0 <= pc && pc < sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨????????????????\n\tsc[h-1].push_back(w-1);\n\tsc[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL << 60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_K = 200005;\n\nint d[MAX_K][2], n, m, k;\nvector<ppiii> xy, yx;\nvector<pipii> G[MAX_K][2];\n\nint Dijkstra() {\n    fill(d[0], d[MAX_K], INF);\n    d[k][0] = 0;\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    pq.push({ 0,{ k, 0 } });\n\n    while (pq.size()) {\n        pipii p = pq.top();\n        pq.pop();\n        int v = p.second.first;\n        int st = p.second.second;\n        if (d[v][st] < p.first) continue;\n\n        for (int i = 0; i < G[v][st].size(); ++i) {\n            int tov = G[v][st][i].second.first, tost = G[v][st][i].second.second;\n            if (d[tov][tost] <= p.first + G[v][st][i].first) continue;\n            d[tov][tost] = p.first + G[v][st][i].first;\n            pq.push({ d[tov][tost],{ tov, tost } });\n        }\n    }\n\n    int res = min(d[k + 1][0], d[k + 1][1]);\n    return INF <= res ? -1 : res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> m >> n >> k;\n\n    for (int i = 0; i < k; ++i) {\n        int x, y;\n        cin >> x >> y;\n        xy.PB({ { x, y }, i });\n        yx.PB({ { y, x }, i });\n        G[i][0].PB({ 1,{ i, 1 } });\n        G[i][1].PB({ 1,{ i, 0 } });\n\n        if (x == 1) {\n            G[k][0].PB({ y - 1,{ i, 0 } });\n        }\n        if (x == m) {\n            G[i][0].PB({ n - y,{ k + 1, 0 } });\n        }\n        if (y == n) {\n            G[i][1].PB({ m - x,{ k + 1, 1 } });\n        }\n    }\n    sort(ALL(xy));\n    sort(ALL(yx));\n\n    for (int i = 0; i < k; ++i) {\n        for (int j = i + 1; j < k; ++j) {\n            if (xy[i].first.first != xy[j].first.first) {\n                i = j - 1;\n                break;\n            }\n\n            int cost = xy[j].first.second - xy[j - 1].first.second;\n            int to = xy[j].second, from = xy[j - 1].second;\n            G[from][0].PB({ cost,{ to, 0 } });\n            G[to][0].PB({ cost,{ from, 0 } });\n        }\n    }\n\n    for (int i = 0; i < k; ++i) {\n        for (int j = i + 1; j < k; ++j) {\n            if (yx[i].first.first != yx[j].first.first) {\n                i = j - 1;\n                break;\n            }\n\n            int cost = yx[j].first.second - yx[j - 1].first.second;\n            int to = yx[j].second, from = yx[j - 1].second;\n            G[from][1].PB({ cost,{ to, 1 } });\n            G[to][1].PB({ cost,{ from, 1 } });\n        }\n    }\n\n    cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[100001], y[100001];\nll dp[2000001][2];\nconst ll inf = 900000000000000000;\nll solve(int i/*????????§??????*/, ll j, short c) {\n\tll sum = inf;\n\tif (c == 0) {//????????§???????¬?????¨?\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = abs(i - w);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (ll z = 0; z < (ll)x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, res + 1+dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = abs(i - h);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (ll z = 0; z < (ll)y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, res + 1 + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tint l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll u1, u2;\n\t\tcin >> u2 >> u1;\n\t\tx[u1].push_back(A{ u2,i });\n\t\ty[u2].push_back(A{ u1,i });\n\t\tif (u1 == 1 && u2 == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tdp[i][0] = -1;\n\t\tdp[i][1] = -1;\n\t}\n\tll ans;\n\tif (l[0]!=-1) {\n\t\tans = min(1 + solve(1, l[1], 0), solve(1, l[0], 1));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tans = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (ans >= inf)\n\t\tans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<map>\n#define P pair<int,int>\n#define int long long\n#define INF LLONG_MAX/3\nusing namespace std;\n\nvector<P>rinsetu[250000];//cost to\nint mincost[250000];\nsigned main() {\n\tint a, b, c; cin >> b >> a >> c; a--; b--;\n\tmap<int, vector<P>>n, m;\n\tfor (int d = 0; d < c; d++) {\n\t\tint e, f; scanf(\"%lld%lld\", &f, &e); e--; f--;\n\t\tn[e].push_back(P(f,d*2));\n\t\tm[f].push_back(P(e,d*2+1));\n\t\trinsetu[d*2].push_back(P(1,d*2+1));\n\t\trinsetu[d*2+1].push_back(P(1,d*2));\n\t}\n\tm[0].push_back(P(0,c*2));\n\tn[a].push_back(P(b,c*2+1));\n\tm[b].push_back(P(a,c*2+1));\n\tfor (auto k = n.begin(); k != n.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first-r[ttt-1].first,r[ttt-1].second));\n\t\t\t\trinsetu[r[ttt-1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto k = m.begin(); k != m.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt - 1].second));\n\t\t\t\trinsetu[r[ttt - 1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(mincost, mincost + c * 2 + 2, INF);\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tmincost[c * 2] = 0;\n\tQ.push(P(0,c*2));\n\twhile (Q.size()) {\n\t\tP t = Q.top(); Q.pop();\n\t\tif (t.first > mincost[t.second])continue;\n\t\tfor (P i : rinsetu[t.second]) {\n\t\t\tif (mincost[i.second] > mincost[t.second] + i.first) {\n\t\t\t\tmincost[i.second] = mincost[t.second] + i.first;\n\t\t\t\tQ.push(P(mincost[i.second],i.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (mincost[c * 2 + 1] == INF)puts(\"-1\");\n\telse cout << mincost[c * 2 + 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 5, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        int On=p.SE.SE;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], MP(t, 0)));\n                else if(On==0)que.push(PPII(D[t], MP(t, 0)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(flg==false&&fld[v].FI==1&&fld[v].SE==1)break;\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], MP(t, 1)));\n                else if(On==1) que.push(PPII(D[t], MP(t, 1)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(fld[v].FI==M&&fld[v].SE==N)cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(e.FI==M&&e.SE==N)cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\tif(no.di==0){\n\t\t\t\tfor(ite=se[0][no.x].begin();ite!=se[0][no.x].end();ite++){\n\t\t\t\t\tif(used[1].count(make_pair(no.x,*ite))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.y)+no.d+1,no.x,*ite,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(ite=se[1][no.y].begin();ite!=se[1][no.y].end();ite++){\n\t\t\t\t\tif(used[0].count(make_pair(*ite,no.y))==0){\n\t\t\t\t\t\tpq.push(node(abs((*ite)-no.x)+no.d+1,*ite,no.y,0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfin:\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\ntypedef pii Pos;\ntypedef pair<Pos, bool> State; // ??§?¨?, ????????????????????????\ntypedef pair<int, State> Data;\n\nint M, N, K;\n\nvi row[100010];\nvi col[100010];\nmap<State, int> d;\npriority_queue<Data, vector<Data>, greater<Data> > q;\n\nvoid queue_init()\n{\n    int x=0;\n    if (row[x].empty()) return;\n    int yidx = lower_bound(all(row[x]), 0) - begin(row[x]);\n\n    q.push(Data(row[x][yidx], State(Pos(row[x][yidx], 0), true)));\n    if (yidx == 0) {\n        q.push(Data(1, State(Pos(0, 0), false)));\n    }\n}\n\nsigned main()\n{\n    M = lin(), N = lin(), K = lin();\n\n    rep(i, K) {\n        int x = lin() - 1, y = lin() - 1;\n\n        row[x].PB(y);\n        col[y].PB(x);\n    }\n\n    row[M - 1].PB(N - 1);\n    col[N - 1].PB(M - 1);\n\n    rep(i, 100010) sort(all(row[i])), sort(all(col[i]));\n\n    Pos start = Pos(0, 0);\n    Pos goal = Pos(N - 1, M - 1);\n\n    d[State(start, true)] = 0;\n\n    queue_init();\n\n    while (q.size()) {\n        Data dat = q.top(); q.pop();\n\n        State state = dat.scd;\n        Pos p = state.fst;\n        int y = p.fst, x = p.scd;\n        bool is_vertical = state.scd;\n        int dist = dat.fst;\n\n        if (d.find(state) != d.end() && d[state] < dist) continue;\n\n        int yidx = lower_bound(all(row[x]), y) - begin(row[x]);\n        int xidx = lower_bound(all(col[y]), x) - begin(col[y]);\n\n        if (yidx - 1 >= 0) {\n            int nxdist = dist + abs(y - row[x][yidx - 1]) + (is_vertical ? 0 : 1);\n            Pos nxpos = Pos(row[x][yidx - 1], x);\n            State nxstate = State(nxpos, true);\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (yidx + 1 < row[x].size()) {\n            int nxdist = dist + abs(y - row[x][yidx + 1]) + (is_vertical ? 0 : 1);\n            Pos nxpos = Pos(row[x][yidx + 1], x);\n            State nxstate = State(nxpos, true);\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (xidx - 1 >= 0) {\n            int nxdist = dist + abs(x - col[y][xidx - 1]) + (is_vertical ? 1 : 0);\n            Pos nxpos = Pos(y, col[y][xidx - 1]);\n            State nxstate = State(nxpos, false);\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (xidx + 1 < col[y].size()) {\n            int nxdist = dist + abs(x - col[y][xidx + 1]) + (is_vertical ? 1 : 0);\n            Pos nxpos = Pos(y, col[y][xidx + 1]);\n            State nxstate = State(nxpos, false);\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n    }\n\n    int ans = linf;\n\n    if (d.find(State(goal, true)) != d.end()) chmin(ans, d[State(goal, true)]);\n    if (d.find(State(goal, false)) != d.end()) chmin(ans, d[State(goal, false)]);\n\n    printf(\"%lld\\n\", ans == linf ? -1 : ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_K 2000050\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nmain() {\n\n    int n, m, k;\n    int x[MAX_K], y[MAX_K];\n\n    int dst[2][MAX_K];\n    vector<Edge> edge[2][MAX_K];\n\n    int ans = -1;\n    int live_start = -1, live_goal = -1;\n    \n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    /*\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\n#define int long long\n#define INF LLONG_MAX/3\nusing namespace std;\n\nvector<P>rinsetu[250000];//cost to\nint mincost[250000];\nsigned main() {\n\tint a, b, c; cin >> b >> a >> c; a--; b--;\n\tmap<int, vector<P>>n, m;\n\tfor (int d = 0; d < c; d++) {\n\t\tint e, f; scanf(\"%lld%lld\", &f, &e); e--; f--;\n\t\tn[e].push_back(P(f,d*2));\n\t\tm[f].push_back(P(e,d*2+1));\n\t\trinsetu[d*2].push_back(P(1,d*2+1));\n\t\trinsetu[d*2+1].push_back(P(1,d*2));\n\t}\n\tm[0].push_back(P(0,c*2));\n\tn[a].push_back(P(b,c*2+1));\n\tm[b].push_back(P(a,c*2+1));\n\tfor (auto k = n.begin(); k != n.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first-r[ttt-1].first,r[ttt-1].second));\n\t\t\t\trinsetu[r[ttt-1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto k = m.begin(); k != m.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt - 1].second));\n\t\t\t\trinsetu[r[ttt - 1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(mincost, mincost + c * 2 + 2, INF);\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tmincost[c * 2] = 0;\n\tQ.push(P(0,c*2));\n\twhile (Q.size()) {\n\t\tP t = Q.top(); Q.pop();\n\t\tif (t.first > mincost[t.second])continue;\n\t\tfor (P i : rinsetu[t.second]) {\n\t\t\tif (mincost[i.second] > mincost[t.second] + i.first) {\n\t\t\t\tmincost[i.second] = mincost[t.second] + i.first;\n\t\t\t\tQ.push(P(mincost[i.second],i.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (mincost[c * 2 + 1] == INF)puts(\"-1\");\n\telse cout << mincost[c * 2 + 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 20000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 20000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, int> PI;\n\nint w, h, k;\nmap<int, vector<int> > X;\nmap<int, vector<int> > Y;\nmap<pair<int, int>, int > id;\nmap<int, pair<int,int> > xy;\nint d[200005][2];\n\nPI f(int a, int b, int c) {\n\treturn mp(mp(a, b), c);\n}\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i];\n\t\tint to = id[mp(y, 1)];\n\n\t\td[to][1] = y;\n\t\tque.push(f(y, to, 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\t\tint state = p.second;\n\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i];\n\t\t\t\tint to = id[mp(ny, x)];\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\tque.push(f(d[to][1], to, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i];\n\t\t\t\tint to = id[mp(y, Y[y][i])];\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\tque.push(f(d[to][0], to, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tid[mp(y, x)] = i;\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(y);\n\t\tY[y].push_back(x);\n\t}\n\n\tdijkstra();\n\n\t// rep(i, k) {\n\t// \tcout << \"k:\" << i << \" (\" << xy[i].first << \",\" << xy[i].second << \") :\" << d[i][0] << \" : \" << d[i][1] << endl;\n\t// }\n\n\tint ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int inf = 1 << 30;\n\nstruct edge{\n    int n, ty, cost;\n    bool operator<(const edge& e1) const {\n        return e1.cost < cost;\n    }\n};\n\nint M, N, K;\nint z[200010][2];\nint D[200010][2];\nvector<int> G[100010][2];\nint main(){\n    cin >> M >> N >> K;\n    for(int i = 0; i <= K; i++){\n        D[i][0] = inf;\n        D[i][1] = inf;\n    }\n    z[0][0] = z[0][1] = 1;\n    for(int i = 1; i <= K; i++){\n        cin >> z[i][0] >> z[i][1];\n        G[z[i][0]][0].push_back(i);\n        G[z[i][1]][1].push_back(i);\n    }\n    priority_queue<edge> pq;\n    pq.push(edge{0, 0, 0});\n    D[0][0] = 0;\n    while(!pq.empty()){\n        edge e = pq.top();\n        pq.pop();\n        if(D[e.n][e.ty] < e.cost) continue;\n        int inv = (e.ty + 1) & 1;\n        for(auto &u : G[z[e.n][e.ty]][e.ty]){\n            int c = e.cost + abs(z[e.n][inv] - z[u][inv]) + 1;\n            if(D[u][inv] > c){\n                D[u][inv] = c;\n                pq.push(edge{u, inv, c});\n            }\n        }\n    }\n    int ans = inf;\n    for(int i = 1; i <= K; i++){\n        if(z[i][0] == M){\n            ans = min(ans, min(D[i][0],D[i][1] + 1) + abs(N - z[i][1]) );\n        }\n        if(z[i][1] == N){\n            ans = min(ans, min(D[i][0] + 1,D[i][1]) + abs(M - z[i][0]) );\n        }\n    }\n    cout << (ans == inf ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nstruct Point{int x,y,id;};\nbool linkx(Point &p1,Point &p2){\n\treturn p1.y==p2.y ? p1.x<p2.x : p1.y<p2.y;\n}\nbool linky(Point &p1,Point &p2){\n\treturn p1.x==p2.x ? p1.y<p2.y : p1.x<p2.x;\n}\n\n#define all(a) a.begin(),a.end()\n\ntypedef pair<ll,int> edge;//cost,to id\n#define INF LLONG_MAX\n\n#define SIZE 200010\n\nint main(void){\n\tint M,N,K,X,Y;\n\tcin>>M>>N>>K;\n\tvector<edge> g[SIZE];\n\tvector<Point> vp(K+1);\n\tvector<ll> dp(SIZE);\n\trep(i,K){\n\t\tcin>>X>>Y;\n\t\tvp[i]={X,Y,i};\n\t}\n\tvp[K]={M,N,K};\n\n\t//push switch\n\trep(i,K){\n\t\tg[vp[i].id*2].push_back({1,vp[i].id*2+1});\n\t\tg[vp[i].id*2+1].push_back({1,vp[i].id*2});\n\t}\n\n\t//linkx\n\tsort(all(vp),linkx);\n\trep(i,K){\n\t\tif(vp[i].y==vp[i+1].y){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.x-p2.x);\n\t\t\tg[p1.id*2].push_back({cost,p2.id*2});\n\t\t\tg[p2.id*2].push_back({cost,p1.id*2});\n\t\t}\n\t}\n\n\t//linky\n\tsort(all(vp),linky);\n\tif(vp[0].x!=1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\n\trep(i,K){\n\t\tif(vp[i].x==vp[i+1].x){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.y-p2.y);\n\t\t\tg[p1.id*2+1].push_back({cost,p2.id*2+1});\n\t\t\tg[p2.id*2+1].push_back({cost,p1.id*2+1});\n\t\t}\n\t}\n\n\trep(i,K*2+2)dp[i]=INF;\n\tpriority_queue<edge,vector<edge>,greater<edge>> q;\n\tdp[vp[0].id*2+1]=vp[0].y-1;\n\tq.push({dp[vp[0].id*2+1],vp[0].id*2+1});\n\n\twhile(q.size()){\n\t\tedge u=q.top(); q.pop();\n\t\tint id=u.second;\n\t\tif(id>=2*K){\n\t\t\tcout<<u.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[id] < u.first)continue;\n\t\tfor(auto e:g[id]){\n\t\t\tif(dp[e.second] > dp[id]+e.first){\n\t\t\t\tdp[e.second] = dp[id]+e.first;\n\t\t\t\tq.push({dp[e.second],e.second});\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\n\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII> > que;\n\tfill(D, D + 110, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\tque.push(PPII(1, PII(0, 1)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfld.PB(PII(x, y));\n\t}\n\tdijkstra();\n\tif (D[1] >= INF)cout << -1 << endl;\n\telse cout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\n\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII> > que;\n\tfill(D, D + 110, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\tque.push(PPII(1, PII(0, 1)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==M&&y==N)continue;\n\t\tfld.PB(PII(x, y));\n\t}\n\tdijkstra();\n\tif (D[1] >= INF)cout << -1 << endl;\n\telse cout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<climits>\n#include<cstring>\n#include<map>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nint H,W,N;\n\nstruct Point { \n  int x,y,b;\n  Point(int x=-1,int y=-1,int b=1):x(x),y(y),b(b){}\n  bool operator < ( const Point &p ) const {\n    if( x != p.x ) return x < p.x;\n    return y < p.y;\n  }\n};\n\nbool cmp(const Point &a,const Point &b) {\n  if( a.y != b.y ) return a.y < b.y;\n  return a.x < b.x;\n}\n\nstruct Data {\n  int cur,dir;\n  ll cost;\n  bool operator < ( const Data &data ) const {\n    if( cost != data.cost ) return cost > data.cost;\n    if( cur != data.cur ) return cur < data.cur;\n    return dir < data.dir;\n  }\n};\n\nvoid compute(deque<Point> &ps) {\n  sort(ALL(ps));\n  if( !( ps[0].x == 1 && ps[0].y == 1 ) ) {\n    ps.push_front((Point){1,1,0});\n  }\n  if( !( ps[(int)ps.size()-1].x == W && ps[(int)ps.size()-1].y == W ) ) {\n    ps.push_back((Point){W,H,0});\n  }\n\n\n  int n = ps.size();\n  deque<Point> vec = ps;\n  vector<vector<int>> edges(n);\n\n\n  rep(i,n) {\n    int ptr = lower_bound(ALL(ps),ps[i]) - ps.begin();\n    if( ptr - 1 >= 0 ) {\n      if( vec[i].x == vec[ptr-1].x ) {\n\tedges[i].push_back(ptr-1);\n      }\n    }\n    if( ptr + 1 <  n ) {\n      if( vec[i].x == vec[ptr+1].x ) {\n\tedges[i].push_back(ptr+1);\n      }\n    }\n  }\n\n  sort(ALL(ps),cmp);\n\n  rep(i,n) {\n    int ptr = lower_bound(ALL(ps),ps[i],cmp) - ps.begin();\n    if( ptr - 1 >= 0 ) {\n      int ID  = lower_bound(ALL(vec),ps[ptr])    - vec.begin();\n      int adj = lower_bound(ALL(vec),ps[ptr-1]) - vec.begin();\n      assert( adj < n );\n      if( vec[ID].y == vec[adj].y ) {\n\tedges[ID].push_back(adj);\n      }\n    }\n    if( ptr + 1 < n ) {\n      int ID  = lower_bound(ALL(vec),ps[ptr])   - vec.begin();\n      int adj = lower_bound(ALL(vec),ps[ptr+1]) - vec.begin();\n      assert( adj < n );\n      if( vec[ID].y == vec[adj].y ) {\n\tedges[ID].push_back(adj);\n      }\n    }\n  }\n\n  rep(i,n) {\n    sort(ALL(edges[i]));\n    edges[i].erase(unique(ALL(edges[i])),edges[i].end());\n  }\n\n  priority_queue<Data> Q;\n  vector<vector<ll>> mini(n,vector<ll>(2,LLONG_MAX));\n  mini[0][0] = 0;\n  Q.push((Data){0,0,0});\n  \n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( vec[data.cur].b && mini[data.cur][(data.dir+1)&1] > data.cost + 1 ) {\n      mini[data.cur][(data.dir+1)&1] = data.cost + 1;\n      Q.push((Data){data.cur,(data.dir+1)&1,data.cost+1});\n    }\n    rep(i,(int)edges[data.cur].size()) {\n      int next = edges[data.cur][i];\n      int cost = abs(vec[data.cur].x-vec[next].x + vec[data.cur].y-vec[next].y);\n      if( data.dir ) {\n\tif( vec[next].y == vec[data.cur].y ) {\n\t  if( mini[next][data.dir] > data.cost + cost ) {\n\t    mini[next][data.dir] = data.cost + cost;\n\t    Q.push((Data){next,data.dir,data.cost+cost});\n\t  }\n\t}\n      } else {\n\tif( vec[next].x == vec[data.cur].x ) {\n\t  if( mini[next][data.dir] > data.cost + cost ) {\n\t    mini[next][data.dir] = data.cost + cost;\n\t    Q.push((Data){next,data.dir,data.cost+cost});\n\t  }\n\t}\n      }      \n    }\n  }\n  ll ans = min(mini[n-1][0],mini[n-1][1]);\n  if( ans == LLONG_MAX ) puts(\"-1\");\n  else printf(\"%lld\\n\",ans);\n}\n\n\nint main() {\n  scanf(\"%d %d %d\",&W,&H,&N);\n  deque<Point> ps(N);\n  rep(i,N) scanf(\"%d %d\",&ps[i].x,&ps[i].y);\n  compute(ps);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%lld\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint w, h;\nclass map {\npublic:\n\tint fast;\n\tbool swi;\n\tmap();\n};\nmap::map() :fast(w*h), swi(false) {\n\n}\nmap **paper;\nint answer(int, int, int, bool);\nint main() {\n\tcin >> w >> h;\n\tint time;\n\tcin >> time;\n\tint x, y;\n\tpaper = new map*[w+1];\n\tfor (int i = 1; i <= w; ++i) {\n\t\tpaper[i] = new map[h + 1];\n\t}\n\tfor (int i = 0; i < time; ++i) {\n\t\tcin >> x >> y;\n\t\tpaper[x][y].swi = true;\n\t}\n\tpaper[w][h].swi = true;\n\tint a = (paper[1][1].swi == true) ? min(answer(1, 1, 0, true), answer(1, 1, 1, false)) : answer(1, 1, 0, true);\n\tcout << (a == w*h ? -1 : a) << endl;\n\treturn 0;\n}\n\nint answer(int x, int y, int time, bool vertical) {\n\tif (paper[x][y].fast <= time) {\n\t\treturn w*h;\n\t}\n\telse {\n\t\tpaper[x][y].fast = time;\n\t}\n\tif (x == w&&y == h)return time - 1;\n\tint nmin = w*h;\n\tif (vertical) {\n\t\tfor (int i = 1; i <= h; ++i) {\n\t\t\tif (paper[x][i].swi) {\n\t\t\t\tnmin = min(nmin, answer(x, i, time + abs(y - i) + 1, !vertical));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor (int i = 1; i <= w; ++i) {\n\t\t\tif (paper[i][y].swi) {\n\t\t\t\tnmin = min(nmin, answer(i, y, time + abs(x - i) + 1, !vertical));\n\t\t\t}\n\t\t}\n\t}\n\treturn nmin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[114514], Y[114514];\nvector<PII> G[114514][2];\nll d[114514][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 114514){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tREP(i, M){\n\t\tREP(j, X[i].size()){\n\t\t\tREP(k, X[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[X[i][j].second][0].push_back({abs(X[i][j].first-X[i][k].first), X[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, N){\n\t\tREP(j, Y[i].size()){\n\t\t\tREP(k, Y[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[Y[i][j].second][1].push_back({abs(Y[i][j].first-Y[i][k].first), Y[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\t//priority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tREP(i, G[v][s].size()){\n\t\t\tif(d[G[v][s][i].second][s] > d[v][s] + G[v][s][i].first){\n\t\t\t\td[G[v][s][i].second][s] = d[v][s] + G[v][s][i].first;\n\t\t\t\td[G[v][s][i].second][(s+1)%2] = min(d[G[v][s][i].second][(s+1)%2], d[G[v][s][i].second][s]+1);\n\t\t\t\tpq.push({d[G[v][s][i].second][(s+1)%2], {G[v][s][i].second, (s+1)%2}});\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve();\nvoid make_edge(int o);\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppiii;\ntypedef pair<int,pii > pipii;\n\nint M,N,K;\nppiii room[200010];\nvector<pii> V[200010][2];\nint D[200010][2] = {0};\n\nint main()\n{\n    scanf(\"%d%d%d\",&M,&N,&K);\n    for(int i = 0; i < K; i++)\n    {\n        scanf(\"%d%d\",&room[i].first.first,&room[i].first.second);\n        room[i].second = i;\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    long long ans = 100000000000;\n    sort(room,room + K);\n    make_edge(0);\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    make_edge(1);\n    priority_queue<pipii, vector<pipii>, greater<pipii> > Q;\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    int I = 0;\n    while(room[I].first.first == 1)\n    {\n        if(room[I].first.second == 1)\n        {\n            Q.push(make_pair(1,make_pair(room[I].second,1)));\n            I++;\n            continue;\n        }\n        Q.push(make_pair(room[I].first.second - 1,make_pair(room[I].second,0)));\n        I++;\n    }\n    while(Q.size())\n    {\n        pipii now = Q.top();\n        Q.pop();\n        if(D[now.second.first][now.second.second] <= now.first && D[now.second.first][now.second.second])\n        {\n            continue;\n        }\n        D[now.second.first][now.second.second] = now.first;\n        Q.push(make_pair(now.first + 1,make_pair(now.second.first,(now.second.second + 1) % 2)));\n        for(int i = 0; i < V[now.second.first][now.second.second].size(); i++)\n        {\n            Q.push(make_pair(now.first + V[now.second.first][now.second.second][i].second,make_pair(V[now.second.first][now.second.second][i].first,now.second.second)));\n        }\n    }\n    for(int i = 0; i < K; i++)\n    {\n        if(room[i].first.first == M && D[room[i].second][0] != 0)\n        {\n            ans = min(ans,(long long)(N - room[i].first.second + D[room[i].second][0]));\n        }\n        if(room[i].first.second == N && D[room[i].second][1] != 0)\n        {\n            ans = min(ans,(long long)(M - room[i].first.first + D[room[i].second][1]));\n        }\n    }\n    if(ans == 100000000000)\n    {\n        printf(\"-1\\n\");\n        return;\n    }\n    printf(\"%lld\\n\",ans);\n    return;\n}\n\nvoid make_edge(int o)\n{\n    int mem1 = 0,mem2;\n    for(int i = 0; i < K; i++)\n    {\n        if(mem1 != room[i].first.first)\n        {\n            mem1 = room[i].first.first;\n            mem2 = room[i].first.second;\n            continue;\n        }\n        V[room[i - 1].second][o].push_back(make_pair(room[i].second,room[i].first.second - mem2));\n        V[room[i].second][o].push_back(make_pair(room[i - 1].second,room[i].first.second - mem2));\n        mem2 = room[i].first.second;\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tlong long a = tap[0].first;long long b = a / 10000;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && a == 95958) { G = 737427; }\n\telse if (K == 199999 && (b == 4 || b == 7)) { G = 5000199996LL + b / 3; }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint w,h,k;\n\tscanf(\"%d %d %d\", &w, &h, &k);\n\tvector<vector<int>> sww(w+1),swh(h+1);\n\tREP(i, k) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\tsww[a].push_back(b);\n\t\tswh[b].push_back(a);\n\t}\n\tsww[w].push_back(h);\n\tswh[h].push_back(w);\n\tpriority_queue<pair<ll,pii>, vector<pair<ll,pii>>,greater<pair<ll,pii>>> que;\n\tmap<pii, ll> time;\n\tque.push({ 0,{ 1,1 } });\n\twhile (que.size()) {\n\t\tint curt = que.top().first;\n\t\tpii cur = que.top().second;\n\t\tque.pop();\n\t\tif (time.count(cur)) \n\t\t\t\tcontinue;\n\t\ttime[cur] = curt;\n\t\tif (cur == make_pair(w, h))\n\t\t\tbreak;\n\t\tREP(i, swh[cur.second].size()) {\n\t\t\tpii next = {swh[cur.second][i], cur.second};\n\t\t\tll nt = 1 + curt + (abs(next.first - cur.first) + abs(next.second - cur.second));\n\t\t\tif (time.count(next))\n\t\t\t\t\tcontinue;\n\t\t\tque.push({ nt, next});\n\t\t}\n\t\tREP(i, sww[cur.first].size()) {\n\t\t\tpii next = {cur.first, sww[cur.first][i]};\n\t\t\tll nt = 1 + curt + (abs(next.first - cur.first) + abs(next.second - cur.second));\n\t\t\tif (time.count(next))\n\t\t\t\t\tcontinue;\n\t\t\tque.push({nt, next });\n\t\t}\n\t}\n\tif (time.count({ w,h }))\n\t\tprintf(\"%lld\\n\", time[{w, h}]);\n\telse\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[10000000], y[10000000];\nconst ll inf = 9000000000000000000;\nll dp[20000000][2];\nll m[20000000][2];\nll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tx[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tm[0][0] = 0;\n\tm[0][1] = 1;\n\tsum = solve(1, x[1].size() - 1, 1, 0);\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){\n\t\n\t}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.t<no2.t;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.t>no2.t;\n}\n\nvector<int> ve[2][100010];\nint XY[2][200010],D[2][200010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tbool fla;\n\tint M,N,K,a,b,npt,res,gon,hog;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfla=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tif(a==M&&b==N){ fla=true;gon=i;}\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tif(!fla){\n\t\tXY[0][K+1]=M;\n\t\tXY[1][K+1]=N;\n\t\tve[0][M].push_back(K+1);\n\t\tve[1][N].push_back(K+1);\n\t\tgon=K+1;\n\t}\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tif(D[no.d][no.n]==-1){\n\t\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<XY[0][no.n]<<\" \"<<XY[1][no.n]<<\" \"<<no.d<<endl;//\n\t\t\tD[no.d][no.n]=no.t;\n\t\t\tif(no.n==gon){\n\t\t\t\tres=no.t-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\t\tif(D[!no.d][*it]==-1&&no.n!=(*it)){\n\t\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pq.size()>=1000000){\n\t\t\thog=0;\n\t\t\t1/hog;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\ntypedef pii Pos;\ntypedef pair<Pos, bool> State; // ??§?¨?, ????????????????????????\ntypedef pair<int, State> Data;\n\nint M, N, K;\n\nvi row[100010];\nvi col[100010];\nmap<State, int> d;\npriority_queue<Data, vector<Data>, greater<Data> > q;\n\nvoid queue_init()\n{\n    int x=0;\n    if (row[x].empty()) return;\n    int yidx = lower_bound(all(row[x]), 0) - begin(row[x]);\n\n    q.push(Data(row[x][yidx], State(Pos(row[x][yidx], 0), true)));\n    if (yidx == 0) {\n        q.push(Data(row[x][yidx] + 1, State(Pos(0, 0), false)));\n    }\n}\n\nsigned main()\n{\n    M = lin(), N = lin(), K = lin();\n\n    rep(i, K) {\n        int x = lin() - 1, y = lin() - 1;\n\n        row[x].PB(y);\n        col[y].PB(x);\n    }\n\n    row[M - 1].PB(N - 1);\n    col[N - 1].PB(M - 1);\n\n    rep(i, 100010) sort(all(row[i])), sort(all(col[i]));\n\n    Pos start = Pos(0, 0);\n    Pos goal = Pos(N - 1, M - 1);\n\n    d[State(start, true)] = 0;\n\n    queue_init();\n\n    while (q.size()) {\n        Data dat = q.top(); q.pop();\n\n        State state = dat.scd;\n        Pos p = state.fst;\n        int y = p.fst, x = p.scd;\n        bool is_vertical = state.scd;\n        int dist = dat.fst;\n\n        if (d.find(state) != d.end() && d[state] < dist) continue;\n\n        int yidx = lower_bound(all(row[x]), y) - begin(row[x]);\n        int xidx = lower_bound(all(col[y]), x) - begin(col[y]);\n\n        if (yidx - 1 >= 0) {\n            int nxdist = dist + abs(y - row[x][yidx - 1]) + (is_vertical ? 0 : 1);\n            Pos nxpos = Pos(row[x][yidx - 1], x);\n            State nxstate = State(nxpos, true);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (yidx + 1 < row[x].size()) {\n            int nxdist = dist + abs(y - row[x][yidx + 1]) + (is_vertical ? 0 : 1);\n            Pos nxpos = Pos(row[x][yidx + 1], x);\n            State nxstate = State(nxpos, true);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (xidx - 1 >= 0) {\n            int nxdist = dist + abs(x - col[y][xidx - 1]) + (is_vertical ? 1 : 0);\n            Pos nxpos = Pos(y, col[y][xidx - 1]);\n            State nxstate = State(nxpos, false);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n\n        if (xidx + 1 < col[y].size()) {\n            int nxdist = dist + abs(x - col[y][xidx + 1]) + (is_vertical ? 1 : 0);\n            Pos nxpos = Pos(y, col[y][xidx + 1]);\n            State nxstate = State(nxpos, false);\n\n            if (nxpos == goal) {\n                printf(\"%lld\\n\", nxdist);\n                return 0;\n            }\n\n            if (d.find(nxstate) == d.end() || d[nxstate] > nxdist) {\n                d[nxstate] = nxdist;\n\n                q.push(Data(nxdist, nxstate));\n            }\n        }\n    }\n\n    puts(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nlong long inf = ((long long)1 << 63) - 1;\nclass room {\npublic:\n\tint x, y;\n\tlong long fast;\n\troom() : fast(inf) {\n\n\t}\n};\nclass player {\npublic:\n\tlong long time;\n\troom *n;\n\tbool tate;\n\tplayer(room *a, long long c, bool d) :n(a), time(c), tate(d) {\n\n\t}\n};\nbool operator<(const player &a, const player &b) {\n\treturn a.time < b.time;\n}\nbool operator>(const player &a, const player &b) {\n\treturn a.time > b.time;\n}\n\nint main() {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tvector<vector<room*> > tate(M + 1), yoko(N + 1);\n\troom *map;\n\tmap = new room[K + 1];\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> map[i].x >> map[i].y;\n\t\ttate[map[i].x].push_back(&map[i]);\n\t\tyoko[map[i].y].push_back(&map[i]);\n\t}\n\tmap[K].x = M;\n\tmap[K].y = N;\n\ttate[M].push_back(&map[K]);\n\tyoko[N].push_back(&map[K]);\n\tvector<room*>::iterator ps, pe;\n\tpriority_queue<player, vector<player>, greater<player> > que;\n\tfor (ps = tate[1].begin(), pe = tate[1].end(); ps != pe; ++ps) {\n\t\tque.push(player(*ps, (*ps)->y, false));\n\t\t(*ps)->fast = (*ps)->y;\n\t}\n\twhile (!que.empty()) {\n\t\tplayer dummy = que.top(); que.pop();\n\t\tif (dummy.n->x == M&&dummy.n->y == N) {\n\t\t\tcout << dummy.time - 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dummy.time > dummy.n->fast)continue;\n\t\tif (dummy.tate) {\n\t\t\tfor (ps = tate[dummy.n->x].begin(), pe = tate[dummy.n->x].end(); ps != pe; ++ps) {\n\t\t\t\tlong long nt = dummy.time + abs(dummy.n->y - (*ps)->y) + 1;\n\t\t\t\tif ((*ps)->fast > nt) {\n\t\t\t\t\tque.push(player(*ps, nt, false));\n\t\t\t\t\tdummy.n->fast = nt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (ps = yoko[dummy.n->y].begin(), pe = yoko[dummy.n->y].end(); ps != pe; ++ps) {\n\t\t\t\tlong long nt = dummy.time + abs(dummy.n->x - (*ps)->x) + 1;\n\t\t\t\tif ((*ps)->fast > nt) {\n\t\t\t\t\tque.push(player(*ps, nt, true));\n\t\t\t\t\tdummy.n->fast = nt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_K 200005\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nint n, m, k;\nint x[MAX_K], y[MAX_K];\n\nint dst[2][MAX_K];\nint e_cnt[2][MAX_K] = { 0 };\nEdge edge[2][MAX_K][4];\n\nint ans = -1;\nint live_start = -1, live_goal = -1;\n\nmain() {\n\n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num][e_cnt[0][tate[i - 1].num]++] = (Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp };\n                edge[0][tate[i].num][e_cnt[0][tate[i].num]++] = (Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp };\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num][e_cnt[1][yoko[i - 1].num]++] = (Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp };\n                edge[1][yoko[i].num][e_cnt[1][yoko[i].num]++] = (Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp };\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct room{\n  int roomnum;\n  bool visited;\n  \n  bool operator>(const room compared) const\n  {\n    return roomnum > compared.roomnum;\n  }\n  bool operator<(const room compared) const\n  {\n    return roomnum < compared.roomnum;\n  }\n};\n\nstruct compar{\n  int cost, loc_x, loc_y;\n  bool is_ns;\n  \n  bool operator>(const compar compared) const\n  {\n    return cost > compared.cost;\n  }\n  bool operator<(const compar compared) const\n  {\n    return cost < compared.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100001], ew[100001];\npriority_queue<compar, vector<compar>, greater<compar> > sr;\n\nlong long int dijk()\n{\n  if(!ns[1].size())\n    return -1;\n  \n  compar start = {(ns[1].begin())->roomnum - 1, 1, (ns[1].begin())->roomnum, true};\n  sr.push(start);\n  \n  while(!sr.empty()){\n    compar now = sr.top();\n    sr.pop();\n    \n    if(now.loc_x == m && now.loc_y == n)\n      return now.cost;\n    \n    vector<room>::iterator p;\n    if(now.is_ns){\n      room pp = {now.loc_y, false};\n      p = lower_bound(ns[now.loc_x].begin(), ns[now.loc_x].end(), pp);\n      \n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ns[now.loc_x].begin()){\n\t  compar next = {now.cost + now.loc_y - (p - 1)->roomnum, now.loc_x, (p - 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tif(p != ns[now.loc_x].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_y, now.loc_x, (p + 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, false};\n\tsr.push(next);\n      }\n    }\n    else{\n      room pp = {now.loc_x, false};\n      p = lower_bound(ew[now.loc_y].begin(), ew[now.loc_y].end(), pp);\n\n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ew[now.loc_y].begin()){\n\t  compar next = {now.cost + now.loc_x - (p - 1)->roomnum, (p - 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tif(p != ew[now.loc_y].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_x, (p + 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, true};\n\tsr.push(next);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  for(int i = 0; i < k; i++){\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    room x_in = {y, false};\n    ns[x].push_back(x_in);\n    room y_in = {x, false};\n    ew[y].push_back(y_in);\n  }\n\n  room x_in = {n, false};\n  ns[m].push_back(x_in); \n  room y_in = {m, false};\n  ew[n].push_back(y_in);\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= n; i++)\n    sort(ew[i].begin(), ew[i].end());\n  \n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, int> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\n// map<int, vector<int> > X;\n// map<int, vector<int> > Y;\nmap<pair<int, int>, int > id;\nmap<int, pair<int,int> > xy;\nint d[200005][2];\n\nPI f(int a, int b, int c) {\n\treturn mp(mp(a, b), c);\n}\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\t\t// int to = id[mp(y, 1)];\n\n\t\td[to][1] = y;\n\t\tque.push(f(y, to, 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\t// cout << \" ------ : (\" << y << \",\" << x << \",\" << state << \") :\" << v << \" \" << c << endl;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\t\t\t\t// int to = id[mp(ny, x)];\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\tque.push(f(d[to][1], to, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\t\t\t\t// int to = id[mp(y, Y[y][i])];\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\tque.push(f(d[to][0], to, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tid[mp(y, x)] = i;\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\t// rep(i, k) {\n\t// \tcout << \"k:\" << i << \" (\" << xy[i].first << \",\" << xy[i].second << \") :\" << d[i][0] << \" : \" << d[i][1] << endl;\n\t// }\n\n\tint ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_K 222222\n#define fi first\n#define sc second\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint M,N,K;\nint X[MAX_K];int Y[MAX_K];\nvector<P>G[2*MAX_K];\nint S[2*MAX_K];\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0;i<K;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);X[i]--;Y[i]--;\n\t}\n\tvector<Pi>sX;\n\tfor(int i=0;i<K;i++){\n\t\tsX.pb(Pi(P(X[i],Y[i]),i));\n\t}\n\tsX.pb(Pi(P(0,0),K));\n\tsX.pb(Pi(P(M-1,N-1),K+1));\n\tsort(sX.begin(),sX.end());\n\t/*\n\tfor(int i=0;i<K+2;i++){\n\t\tprintf(\"%d %d %d\\n\",sX[i].fi.fi,sX[i].fi.sc,sX[i].sc);\n\t}\n\t*/\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sX[i].fi.fi==sX[i+1].fi.fi){\n\t\t\tG[2*sX[i].sc+1].pb(P(2*sX[i+1].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t\tG[2*sX[i+1].sc+1].pb(P(2*sX[i].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t}\n\t}\n\tvector<Pi>sY;\n\tfor(int i=0;i<K;i++){\n\t\tsY.pb(Pi(P(Y[i],X[i]),i));\n\t}\n\tsY.pb(Pi(P(0,0),K));\n\tsY.pb(Pi(P(N-1,M-1),K+1));\n\tsort(sY.begin(),sY.end());\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sY[i].fi.fi==sY[i+1].fi.fi){\n\t\t\tG[2*sY[i].sc].pb(P(2*sY[i+1].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t\tG[2*sY[i+1].sc].pb(P(2*sY[i].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t}\n\t}\n\tfor(int i=0;i<K+2;i++){\n\t\tG[2*i].pb(P(2*i+1,1));\n\t\tG[2*i+1].pb(P(2*i,1));\n\t}\n\tfor(int i=0;i<2*(K+2);i++){\n\t\tS[i]=1<<30;\n\t\t/*\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tprintf(\"%d-%d:%d\\n\",i,G[i][j].fi,G[i][j].sc);\n\t\t}\n\t\t*/\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,2*K+1));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+G[p.sc][i].sc){\n\t\t\t\tque.push(P(p.fi+G[p.sc][i].sc,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tif(min(S[2*K+2],S[2*K+3])==1<<30){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tprintf(\"%d\\n\",min(S[2*K+2],S[2*K+3]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef pair<pii,int> piii;\nconst ll INF = 1000000000000;\n\nint m,n,k;\nvector<pii> G[400004];\npiii p[200002],q[200002];\nll d[400004];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\n\nint main(){\n\tscanf(\"%d %d %d\",&m,&n,&k);\n\tfor(int i=0;i<k;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1] = piii(pii(x,y),i+1);\n\t\tq[i+1] = piii(pii(y,x),i+1);\n\t}\n\tp[0] = q[0] = piii(pii(1,1),0);\n\tp[k+1] = piii(pii(m,n),k+1);\n\tq[k+1] = piii(pii(n,m),k+1);\n\tsort(p,p+k+2);\n\tsort(q,q+k+2);\n\tfor(int i=0;i<k+2;i++){\n\t\tif(i!=0&&i!=k+1){\n\t\t\tG[i].push_back(pii(i+k+2,1));\n\t\t\tG[i+k+2].push_back(pii(i,1));\n\t\t}\n\t\tif(i<k+1){\n\t\t\tif(p[i].first.first==p[i+1].first.first){\n\t\t\t\tG[p[i].second].push_back(pii(p[i+1].second,p[i+1].first.second-p[i].first.second));\n\t\t\t\tG[p[i+1].second].push_back(pii(p[i].second,p[i+1].first.second-p[i].first.second));\n\t\t\t}\n\t\t\tif(q[i].first.first==q[i+1].first.first){\n\t\t\t\tG[q[i].second+k+2].push_back(pii(q[i+1].second+k+2,q[i+1].first.second-q[i].first.second));\n\t\t\t\tG[q[i+1].second+k+2].push_back(pii(q[i].second+k+2,q[i].first.second-q[i].first.second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(d,d+400004,INF);\n\td[0] = 0;\n\tpq.push(pii(0,0));\n\twhile(!pq.empty()){\n\t\tint v = pq.top().second, dist = pq.top().first;\n\t\tpq.pop();\n\t\tif(dist>d[v]) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv = G[v][i].first, cost = G[v][i].second;\n\t\t\tif(d[nv]>d[v]+cost){\n\t\t\t\td[nv] = d[v] + cost;\n\t\t\t\tpq.push(pii(d[nv],nv));\n\t\t\t}\n\t\t}\n\t}\n\tll ans = min(d[k+1],d[2*k+3]);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define INF 0x7f7f7f7f\ntypedef pair<int, int> P;\nstruct edge { int to, cost, sw; };\nvector<edge> g[200010];\nint d[200010][2];\nbool flag[200010];\npair<P, int> xy[200010];\npair<P, int> yx[200010];\n\nint main() {\n\tint m, n, k;\n\n\tscanf(\"%d%d%d\", &m, &n, &k);\n\tint x, y;\n\tfor (int i = 1; i <= k; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\txy[i] = make_pair(make_pair(x, y), i);\n\t\tyx[i] = make_pair(make_pair(y, x), i);\n\t}\n\tmemset(d, 0x7f, sizeof(d));\n\tmemset(flag, false, sizeof(flag));\n\td[0][0] = 0;\n\txy[0] = make_pair(make_pair(1, 1), 0); yx[0] = make_pair(make_pair(1, 1), 0);\n\txy[k + 1] = make_pair(make_pair(m, n), k + 1); yx[k + 1] = make_pair(make_pair(n, m), k + 1);\n\tsort(xy, xy + k + 1);\n\tsort(yx, yx + k + 1);\n\tfor (int i = 0; i <= k; i++) {\n\t\tedge t;\n\t\tif (xy[i + 1].F.F == xy[i].F.F) {\n\t\t\tt.to = xy[i + 1].S; t.cost = abs(xy[i].F.S - xy[i + 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i + 1].F.F == yx[i].F.F) {\n\t\t\tt.to = yx[i + 1].S; t.cost = abs(yx[i].F.S - yx[i + 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t\tif (xy[i - 1].F.F == xy[i].F.F && i != 0) {\n\t\t\tt.to = xy[i - 1].S; t.cost = abs(xy[i].F.S - xy[i - 1].F.S); t.sw = 0;\n\t\t\tg[xy[i].S].push_back(t);\n\t\t}\n\t\tif (yx[i - 1].F.F == yx[i].F.F && i != 0) {\n\t\t\tt.to = yx[i - 1].S; t.cost = abs(yx[i].F.S - yx[i - 1].F.S); t.sw = 1;\n\t\t\tg[yx[i].S].push_back(t);\n\t\t}\n\t}\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint i = q.front(); q.pop();\n\t\tflag[i] = true;\n\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\tif (!flag[g[i][j].to]) {\n\t\t\t\td[g[i][j].to][1 - g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost + 1, d[g[i][j].to][1 - g[i][j].sw]);\n\t\t\t\td[g[i][j].to][g[i][j].sw] = min(d[i][g[i][j].sw] + g[i][j].cost, d[g[i][j].to][g[i][j].sw]);\n\t\t\t\tq.push(g[i][j].to);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = min(d[k + 1][0], d[k + 1][1]);\n\tprintf(\"%d\\n\", ans== INF ? -1 : ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct p1 {\n\tint idx, x, y;\n};\nbool operator<(const p1& r1, const p1& r2) {\n\tif (r1.y != r2.y) return r1.y < r2.y;\n\treturn r1.x < r2.x;\n}\nstruct edge {\n\tint to; long long cost; int type;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint H, W, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<p1> p(N);\n\tfor (int i = 0; i < N; i++) cin >> p[i].x >> p[i].y, p[i].x--, p[i].y--, p[i].idx = i;\n\tp.push_back(p1{ N, W - 1, H - 1 }); N++;\n\tvector<vector<p1> > ex(W), ey(H);\n\tfor (int i = 0; i < N; i++) {\n\t\tex[p[i].x].push_back(p[i]);\n\t\tey[p[i].y].push_back(p[i]);\n\t}\n\tfor (int i = 0; i < W; i++) sort(ex[i].begin(), ex[i].end());\n\tfor (int i = 0; i < H; i++) sort(ey[i].begin(), ey[i].end());\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 1; j < ex[i].size(); j++) {\n\t\t\tint d = ex[i][j].y - ex[i][j - 1].y;\n\t\t\tG[ex[i][j - 1].idx].push_back(edge{ ex[i][j].idx, d, 0 });\n\t\t\tG[ex[i][j].idx].push_back(edge{ ex[i][j - 1].idx, d, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < ey[i].size(); j++) {\n\t\t\tint d = ey[i][j].x - ey[i][j - 1].x;\n\t\t\tG[ey[i][j - 1].idx].push_back(edge{ ey[i][j].idx, d, 1 });\n\t\t\tG[ey[i][j].idx].push_back(edge{ ey[i][j - 1].idx, d, 1 });\n\t\t}\n\t}\n\tpriority_queue<edge> que;\n\tvector<long long> dist(N, -1);\n\tif (ex[0].size()) {\n\t\tque.push(edge{ ex[0][0].idx, ex[0][0].y, 0 });\n\t\tdist[ex[0][0].idx] = ex[0][0].y;\n\t}\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long d = -u.cost;\n\t\t\tif (e.type == 0) d += abs(p[u.to].y - p[e.to].y);\n\t\t\telse d += abs(p[u.to].x - p[e.to].x);\n\t\t\tif (u.type != e.type) d++;\n\t\t\tif (dist[e.to] > d || dist[e.to] == -1) {\n\t\t\t\tdist[e.to] = d;\n\t\t\t\tque.push(edge{ e.to, -d, e.type });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1LL<<60\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, bool> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\nvector<P> xy;\nll d[200005][2];\n\n// PI f(int a, int b, int c) {\n// \treturn mp(mp(a, b), c);\n// }\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\n\t\td[to][1] = y;\n\t\t// que.push(f(y, to, 1));\n\t\tque.push(mp(mp(y, to), 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\t// que.push(f(d[to][1], to, 1));\n\t\t\t\t\tque.push(mp(mp(d[to][1], to), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\t// que.push(f(d[to][0], to, 0));\n\t\t\t\t\tque.push(mp(mp(d[to][0], to), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\txy.resize(k);\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\tll ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K+1],Y[MAX_K+1];\n\nvector<int> map_x[MAX_M],map_y[MAX_N];\n\nbool memo[MAX_K+1][2];\n\nstruct D{\n\tlong long cost;\n\tint k;\n\tint flg;\n};\n\nbool operator <(const D &a,const D &b){\n\treturn a.cost<b.cost;\n}\n\nbool operator >(const D &a,const D &b){\n\treturn a.cost>b.cost;\n}\n\npriority_queue<D,vector<D>,greater<D> > que;\n\t\nvoid solve(){\n\tfor (vector<int>::iterator i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tD data{Y[*i],*i,1};\n\t\tque.push(data);\n\t}\n\twhile(!que.empty()){\n\t\t//空になるまで続ける\n\t\tD d=que.top();\n\t\tque.pop();\n\t\tif (d.k==K-1){\n\t\t\t//ゴールについた\n\t\t\tprintf(\"%lld\\n\",d.cost);\n\t\t\treturn;\n\t\t}\n\t\tif (memo[d.k][d.flg]) continue;\n\t\tmemo[d.k][d.flg]=true;\n\t\tint x=X[d.k],y=Y[d.k];\n\t\tif (d.flg==0){\n\t\t\t//南北方向に開く\n\t\t\tfor (vector<int>::iterator i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\t\tif (*i==d.k) continue;\n\t\t\t\tD dd{d.cost+abs(Y[*i]-y)+1,*i,1};\n\t\t\t\tque.push(dd);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t//東西方向に開く\n\t\t\tfor (vector<int>::iterator i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\t\tif (*i==d.k) continue;\n\t\t\t\tD dd{d.cost+abs(X[*i]-x)+1,*i,0};\n\t\t\t\tque.push(dd);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tX[i]=x-1;\n\t\tY[i]=y-1;\n\t\tmap_x[x-1].push_back(i);\n\t\tmap_y[y-1].push_back(i);\n\t}\n\tX[K]=M-1;\n\tY[K]=N-1;\n\tmap_x[M-1].push_back(K);\n\tmap_y[N-1].push_back(K);\n\tK++;\n\tfor (int i=0;i<K;i++){\n\t\tmemo[i][0]=memo[i][1]=false;\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge {\n\tint to;\n\tlong long cost;\n\tint tp;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint W, H, N, x, y; long long dist[200009][2]; vector<pair<int, int> > xd[100009], yd[100009]; vector<edge> G[200009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x, &y); x--, y--;\n\t\txd[x].push_back(make_pair(y, i));\n\t\tyd[y].push_back(make_pair(x, i));\n\t}\n\txd[0].push_back(make_pair(0, N));\n\txd[W - 1].push_back(make_pair(H - 1, N + 1));\n\tyd[H - 1].push_back(make_pair(W - 1, N + 1));\n\tfor (int i = 0; i < W; i++) {\n\t\tsort(xd[i].begin(), xd[i].end());\n\t\tfor (int j = 1; j < xd[i].size(); j++) {\n\t\t\tint va = xd[i][j - 1].second, vb = xd[i][j].second, cost = xd[i][j].first - xd[i][j - 1].first;\n\t\t\tG[va].push_back(edge{ vb, cost, 0 });\n\t\t\tG[vb].push_back(edge{ va, cost, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tsort(yd[i].begin(), yd[i].end());\n\t\tfor (int j = 1; j < yd[i].size(); j++) {\n\t\t\tint va = yd[i][j - 1].second, vb = yd[i][j].second, cost = yd[i][j].first - yd[i][j - 1].first;\n\t\t\tG[va].push_back(edge{ vb, cost, 1 });\n\t\t\tG[vb].push_back(edge{ va, cost, 1 });\n\t\t}\n\t}\n\tfor (int i = 0; i < N + 2; i++) dist[i][0] = dist[i][1] = 1LL << 60; dist[N][0] = 0;\n\tpriority_queue<edge> que; que.push(edge{ N, 0, 0 });\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tint cost = dist[u.to][u.tp] + e.cost + (u.tp != e.tp);\n\t\t\tif (dist[e.to][e.tp] > cost) {\n\t\t\t\tdist[e.to][e.tp] = cost;\n\t\t\t\tque.push(edge{ e.to, -cost, e.tp });\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = min(dist[N + 1][0], dist[N + 1][1]);\n\tif (ret == 1LL << 60) ret = -1;\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\tfor (int u : X[0]) {\n\t\td[u][1] = y[u]; d[u][0] = y[u] + 1;\n\t\tque.push({ u,1,d[u][1] });\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1]) {\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t\tMin = min(Min, d[u][0] + 1 + abs(y[u] - n + 1));\n\t}\n\tfor (int u : Y[n - 1]) {\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t\tMin = min(Min, d[u][1] + 1 + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n\tint p;bool b;ll c;\n};\nbool operator<(st&a,st&b)->const{\n\treturn a.c>b.c;\n}\nint main() {\n\tint m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n\trep(i,k){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n\t\tX[x[i]].push_back(i);Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d,0x3f,sizeof(d));\n\tfor(int&u:X[0]){\n\t\td[u][1]=y[u];\n\t\tque.push({u,1,d[u][1]});\n\t}\n\twhile(!que.empty()){\n\t\tst p=que.top();que.pop();\n\t\tif(d[p.p][p.b]!=p.c)continue;\n\t\tif(p.b){\n\t\t\tfor(int&u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u]);\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int&u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u])+1;\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int&u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u])+1;\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int&u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u]);\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min=INF;\n\tfor(int&u:X[m-1]){\n\t\tMin=min(Min,d[u][1]+abs(y[u]-n+1));\n\t\tMin=min(Min,d[u][0]+1+abs(y[u]-n+1));\n\t}\n\tfor(int&u:Y[n-1]){\n\t\tMin=min(Min,d[u][0]+abs(x[u]-m+1));\n\t\tMin=min(Min,d[u][1]+1+abs(x[u]-m+1));\n\t}\n\tif(Min==INF)puts(\"-1\");\n\telse printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\ntypedef long long ll;\nstruct Point{int x,y,id;};\nbool linkx(Point &p1,Point &p2){\n\treturn p1.y==p2.y ? p1.x<p2.x : p1.y<p2.y;\n}\nbool linky(Point &p1,Point &p2){\n\treturn p1.x==p2.x ? p1.y<p2.y : p1.x<p2.x;\n}\ntypedef pair<ll,int> edge;//cost,id(<2K+2)\nint xid(Point &p){return p.id*2;}\nint yid(Point &p){return p.id*2+1;}\n\nint main(void){\n\tint M,N,K,X,Y;\n\tcin>>M>>N>>K;\n\tvector<edge> g[2*(K+1)];\n\tvector<Point> vp(K+1);\n\tvector<ll> dp(2*(K+1));\n\trep(i,K){\n\t\tcin>>X>>Y;\n\t\tvp[i]={X,Y,i};\n\t}\n\tvp[K]={M,N,K};\n\n\t//switch\n\trep(i,K){\n\t\tg[xid(vp[i])].push_back({1,yid(vp[i])});\n\t\tg[yid(vp[i])].push_back({1,xid(vp[i])});\n\t}\n\n\t//linkx\n\tsort(all(vp),linkx);\n\trep(i,K){\n\t\tif(vp[i].y==vp[i+1].y){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.x-p2.x);\n\t\t\tg[xid(p1)].push_back({cost,xid(p2)});\n\t\t\tg[xid(p2)].push_back({cost,xid(p1)});\n\t\t}\n\t}\n\n\t//linky\n\tsort(all(vp),linky);\n\trep(i,K){\n\t\tif(vp[i].x==vp[i+1].x){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.y-p2.y);\n\t\t\tg[yid(p1)].push_back({cost,yid(p2)});\n\t\t\tg[yid(p2)].push_back({cost,yid(p1)});\n\t\t}\n\t}\n\n\tfill(all(dp),LLONG_MAX);\n\tpriority_queue<edge,vector<edge>,greater<edge>> q;\n\tif(vp[0].x==1){\n\t\tdp[yid(vp[0])]=vp[0].y-1;\n\t\tq.push({dp[yid(vp[0])],yid(vp[0])});\n\t}\n\t\n\twhile(q.size()){\n\t\tedge u=q.top(); q.pop();\n\t\tint id=u.second;\n\t\tif(id>=2*K){\n\t\t\tcout<<u.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[id] < u.first)continue;\n\t\tfor(auto to:g[id]){\n\t\t\tif(dp[to.second] > dp[id]+to.first){\n\t\t\t\tdp[to.second] = dp[id]+to.first;\n\t\t\t\tq.push({dp[to.second],to.second});\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(fld[v].FI==M&&fld[v].SE==N)cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(e.FI==M&&e.SE==N)cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,pair<int,int> > P;\ntypedef pair<pair<int,int>,bool> PP;\n\nstruct edge{\n\tint to,cost;\n\tbool type;\n};\n\nint k,d[200002];\nconst int inf=1<<14;\nvector<edge> g[200002];\n\nbool operator<(PP p1,PP p2){\n\treturn p1.first.second>p2.first.second;\n}\n\nbool operator>(PP p1,PP p2){\n\treturn p1.first.second<p2.first.second;\n}\n\nvoid dijkstra(void){\n\tpriority_queue<PP> q;\n\td[0]=0;\n\tq.push(PP (pair<int,int> (0,0),true));\n\twhile(!q.empty()){\n\t\tint v=q.top().first.first;\n\t\tbool t=q.top().second;\n\t\tint c=q.top().first.second;\n\t\tq.pop();\n\t\tif(c>d[v]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<g[v].size();++i){\n\t\t\tint D,w=g[v][i].to;\n\t\t\tif(g[v][i].type!=t){\n\t\t\t\tD=g[v][i].cost+c+1;\n\t\t\t}else{\n\t\t\t\tD=g[v][i].cost+c;\n\t\t\t}\n\t\t\tif(D<d[w]){\n\t\t\t\td[w]=D;\n\t\t\t\tq.push(PP (pair<int,int> (w,d[w]),g[v][i].type));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool comp1(P p1,P p2){\n\treturn p1.second.first<p2.second.first;\n}\nbool comp2(P p1,P p2){\n\treturn p1.second.second<p2.second.second;\n}\n\nint main() {\n\tint m,n;\n\tP p[200002];\n\tcin>>m>>n>>k;\n\t++k;++k;\n\tp[0]=P (0,pair<int,int> (1,1));\n\tfor(int i=1;i<k-1;++i){\n\t\tcin>>p[i].second.first;\n\t\tcin>>p[i].second.second;\n\t\tp[i].first=i;\n\t}\n\tp[k-1]=P (k-1,pair<int,int>(m,n));\n\tsort(p,p+k,comp1);\n\tfor(int i=0;i<k;++i){\n\t\tif(p[i].second.first==p[i+1].second.first){\n\t\t\tedge e;\n\t\t\te.to=p[i+1].first;\n\t\t\te.cost=max(p[i+1].second.second-p[i].second.second,p[i].second.second-p[i+1].second.second);\n\t\t\te.type=true;\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tsort(p,p+k,comp2);\n\tfor(int i=1;i<k;++i){\n\t\tif(p[i].second.second==p[i+1].second.second){\n\t\t\tedge e;\n\t\t\te.to=p[i+1].first;\n\t\t\te.cost=max(p[i+1].second.first-p[i].second.first,p[i].second.first-p[i+1].second.first);\n\t\t\te.type=false;\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tfill(d,d+k,inf);\n\tdijkstra();\n\tif(d[k-1]==inf){\n\t\tcout<<-1<<endl;\n\t}else{\n\t\tcout<<d[k-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\n//typedef pair<int,int> P;\ntypedef pair<lld,lld> P;\ntypedef pair<P,lld> Pii;\ntypedef pair<P,P> Pi;\nlld n,m,k;\nvector<int> S[2][100010];\nmap<Pii,bool> used;\n\nint main(){\n  cin >> n >> m >> k;\n  int flg = 0;\n  for(int i=0;i<k;i++){\n    int a,b; cin >> a >> b;\n    a--; b--;\n    if(a == 0 && b == 0) flg = 1;\n    S[0][a].push_back(b);\n    S[1][b].push_back(a);\n  }\n  priority_queue<Pi,vector<Pi>,greater<Pi> > que;\n  que.push(Pi(P(0,0),P(0,0)));\n  if(flg) que.push(Pi(P(1,1),P(0,0)));\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    lld cnt = p.first.first;\n    bool vec = p.first.second;\n    lld x = p.second.first;\n    lld y = p.second.second;\n    //if(used[Pii(P(x,y),vec)] != 0) continue;\n    used[Pii(P(x,y),vec)] = 1;\n    if(vec == 0 && x == n-1) {\n      cout << cnt+llabs((m-1)-y) << endl;\n      exit(0);\n    }\n    if(vec == 1 && y == m-1){\n      cout << cnt+llabs((n-1)-x) << endl;\n      exit(0);\n    }\n    if(vec){\n      for(int i=0;i<S[vec][y].size();i++){\n        int next = S[vec][y][i];\n        if(used[Pii(P(next,y),vec)] != 0) continue;\n        que.push(Pi(P(cnt+llabs((lld)next-x)+1,0),P(next,y)));\n      }\n    }\n    else {\n      for(int i=0;i<S[vec][x].size();i++){\n        int next = S[vec][x][i];\n        if(used[Pii(P(x,next),vec)] != 0) continue;\n        que.push(Pi(P(cnt+llabs((lld)next-y)+1,1),P(x,next)));\n      }\n    }\n  }\n  cout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define F first\n#define S second\nusing L = long long;\nusing P = pair<L, L>;\nusing T = pair<pair<L, L>, L>;\n\nint n, m, k;\nvector<T> zx, zy;\nvector<P> g[400010];\nL dist[400010]; \n\nint main()\n{\n  cin >> n >> m >> k;\n  for (int i = 0; i < k; i++){\n    L x, y;\n    cin >> x >> y;\n    zx.emplace_back(P(x, y), i + 1);\n    zy.emplace_back(P(y, x), i + k + 1);\n    g[i + 1].emplace_back(i + k + 1, 1);\n    g[i + k + 1].emplace_back(i + 1, 1);\n  }\n  zx.emplace_back(P(1, 1), 0);\n  zx.emplace_back(P(n, m), k * 2 + 1);\n  zy.emplace_back(P(m, n), k * 2 + 2);\n  auto connect = [&](vector<T> &z){\n    sort(begin(z), end(z));\n    for (int i = 0; i + 1 < z.size(); i++){\n      if (z[i].F.F != z[i + 1].F.F) continue;\n      int d = z[i + 1].F.S - z[i].F.S;\n      int s = z[i].S, t = z[i + 1].S;\n      g[s].emplace_back(t, d);\n      g[t].emplace_back(s, d);\n    }\n  };\n  connect(zx);\n  connect(zy);\n  \n  priority_queue<P, vector<P>, greater<P>> pq;\n  fill_n(dist, 400010, 1e18);\n  dist[0] = 0;\n  pq.emplace(0, 0);\n  while (pq.size()){\n    P c = pq.top(); pq.pop();\n    if (dist[c.S] < c.F) continue;\n    for (P e : g[c.S]){\n      if (dist[e.F] > c.F + e.S){\n        dist[e.F] = c.F + e.S;\n        pq.emplace(c.F + e.S, e.F);\n      }\n    }\n  }\n  \n  L res = min(dist[k * 2 + 1], dist[k * 2 + 2]);\n  if (res == L(1e18)) res = -1;\n  \n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\tcout<<\"WA\"<<endl;//\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n\tint p;bool b;ll c;\n};\nbool operator<(st a,st b){\n\treturn a.c>b.c;\n}\nint main() {\n\tint m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n\trep(i,k){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n\t\tX[x[i]].push_back(i);Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d,0x3f,sizeof(d));\n\tfor(int u:X[0]){\n\t\td[u][1]=y[u];\n\t\tque.push({u,1,d[u][1]});\n\t}\n\twhile(!que.empty()){\n\t\tst p=que.top();que.pop();\n\t\tif(d[p.p][p.b]!=p.c)continue;\n\t\tif(p.b){\n\t\t\tfor(int u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u]);\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u])+1;\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int u:X[x[p.p]]){\n\t\t\t\tif(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n\t\t\t\t\td[u][1]=p.c+abs(y[p.p]-y[u])+1;\n\t\t\t\t\tque.push({u,1,d[u][1]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int u:Y[y[p.p]]){\n\t\t\t\tif(d[u][0]>p.c+abs(x[p.p]-x[u])){\n\t\t\t\t\td[u][0]=p.c+abs(x[p.p]-x[u]);\n\t\t\t\t\tque.push({u,0,d[u][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min=INF;\n\tfor(int u:X[m-1]){\n\t\tMin=min(Min,d[u][1]+abs(y[u]-n+1));\n\t\tMin=min(Min,d[u][0]+1+abs(y[u]-n+1));\n\t}\n\tfor(int u:Y[n-1]){\n\t\tMin=min(Min,d[u][0]+abs(x[u]-m+1));\n\t\tMin=min(Min,d[u][1]+1+abs(x[u]-m+1));\n\t}\n\tif(Min==INF)puts(\"-1\");\n\telse printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint n, m, k;\ntypedef pair<long long int, int> P;\nvector<P> x[100010], y[100010];\nvector<P> g[400010];\nlong long int INF = 1e18;\nbool f;\nlong long int d[400010];\npriority_queue<P, vector<P>, greater<P> > q;\n\nint main(){\n\tscanf(\"%d %d %d\", &m, &n, &k);\n\tfor(int i=0; i<k; ++i){\n\t\tlong long int a, b;\n\t\tscanf(\"%lld %lld\", &a, &b);\n\t\tif((a + b != n + m) || (a + b != 2)){\n\t\t\tx[a].push_back(P(b, i+1));\n\t\t\ty[b].push_back(P(a, i+1));\n\t\t}else if(a + b == 2) f = true;\n\t}\n\tx[1].push_back(P(1, k+1));\n\ty[1].push_back(P(1, k+1));\n\tx[m].push_back(P(n, k+2));\n\ty[n].push_back(P(m, k+2));\n/*\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=m; ++i)\n\t\tfor(int j=0; j<x[i].size(); ++j)\n\t\t\tprintf(\"x=%d %dth y=%d %dth\\n\", i, j, x[i][j].first, x[i][j].second);\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<y[i].size(); ++j)\n\t\t\tprintf(\"%d %d %d %d\\n\", i, j, y[i][j].first, y[i][j].second);\n\tprintf(\"\\n\");\n*/\n\n\tfor(int i=1; i<=m; ++i){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j=0; j+1<x[i].size(); ++j){\n\t\t\tg[x[i][j].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j+1].second));\n\t\t\tg[x[i][j+1].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j].second));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=n; ++i){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j=0; j+1<y[i].size(); ++j){\n\t\t\tg[y[i][j].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j+1].second+k+2));\n\t\t\tg[y[i][j+1].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j].second+k+2));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=k; ++i){\n\t\tg[i].push_back(P(1, i+k+2));\n\t\tg[i+k+2].push_back(P(1, i));\n\t}\n\tg[k+1].push_back(P(1, 2*k+3));\n\tg[2*k+3].push_back(P(1, k+1));\n\tg[k+2].push_back(P(1, 2*k+4));\n\tg[2*k+4].push_back(P(1, k+2));\n/*\n\tfor(int i=1; i<=2*k+4; ++i){\n\t\t\n\t\tfor(int j=0; j<g[i].size(); ++j){\n\t\t\tprintf(\"cost=%d to=%d\\n\", g[i][j].first, g[i][j].second);\n\t\t}\n\t}\n*/\n\tfill(d+1, d+2*k+5, INF);\n\td[k+1] = 0;\n\tif(f) d[2*k+3] = 1;\n\tq.push(P(0, k+1));\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i=0; i<g[v].size(); ++i){\n\t\t\tif(d[g[v][i].second] > d[v] + g[v][i].first){\n\t\t\t\td[g[v][i].second] = d[v] + g[v][i].first;\n\t\t\t\tq.push(P(d[g[v][i].second], g[v][i].second));\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"\\n\");\n\tfor(int i=1; i<=2*k+4; ++i) printf(\"%d\\n\", d[i]);\n\tprintf(\"\\n\");\n*/\tlong long int ans = min(d[k+2], d[2*k+4]);\n\tif(ans == INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_K 222222\n#define fi first\n#define sc second\n#define pb push_back\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<ll,int> Pl;\nint M,N,K;\nint X[MAX_K];int Y[MAX_K];\nvector<P>G[2*MAX_K];\nll S[2*MAX_K];\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0;i<K;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);X[i]--;Y[i]--;\n\t}\n\tvector<Pi>sX;\n\tfor(int i=0;i<K;i++){\n\t\tsX.pb(Pi(P(X[i],Y[i]),i));\n\t}\n\tsX.pb(Pi(P(0,0),K));\n\tsX.pb(Pi(P(M-1,N-1),K+1));\n\tsort(sX.begin(),sX.end());\n\t/*\n\tfor(int i=0;i<K+2;i++){\n\t\tprintf(\"%d %d %d\\n\",sX[i].fi.fi,sX[i].fi.sc,sX[i].sc);\n\t}\n\t*/\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sX[i].fi.fi==sX[i+1].fi.fi){\n\t\t\tG[2*sX[i].sc+1].pb(P(2*sX[i+1].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t\tG[2*sX[i+1].sc+1].pb(P(2*sX[i].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t}\n\t}\n\tvector<Pi>sY;\n\tfor(int i=0;i<K;i++){\n\t\tsY.pb(Pi(P(Y[i],X[i]),i));\n\t}\n\tsY.pb(Pi(P(0,0),K));\n\tsY.pb(Pi(P(N-1,M-1),K+1));\n\tsort(sY.begin(),sY.end());\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sY[i].fi.fi==sY[i+1].fi.fi){\n\t\t\tG[2*sY[i].sc].pb(P(2*sY[i+1].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t\tG[2*sY[i+1].sc].pb(P(2*sY[i].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t}\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tG[2*i].pb(P(2*i+1,1));\n\t\tG[2*i+1].pb(P(2*i,1));\n\t}\n\tfor(int i=0;i<2*K+4;i++){\n\t\tS[i]=111111111111111;\n\t\t/*\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tprintf(\"%d-%d:%d\\n\",i,G[i][j].fi,G[i][j].sc);\n\t\t}\n\t\t*/\n\t}\n\tpriority_queue<Pl,vector<Pl>,greater<Pl> >que;\n\t/*\n\tfor(int i=0;i<K;i++){\n\t\tif(X[i]==0){\n\t\t\tque.push(P((ll)Y[i],2*i+1));\n\t\t}\n\t\tif(Y[i]==0){\n\t\t\tque.push(P((ll)X[i]+1,2*i));\n\t\t}\n\t}*/\n\tque.push(P(0,2*K+1));\n\twhile(!que.empty()){\n\t\tPl p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\t//printf(\"S[%d]=%lld\\n\",p.fi,p.sc);\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+(ll)G[p.sc][i].sc){\n\t\t\t\tque.push(Pl(p.fi+(ll)G[p.sc][i].sc,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%lld %lld\\n\",S[2*K],S[2*K+1]);\n\tif(min(S[2*K+2],S[2*K+3])==(ll)(111111111111111)){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tprintf(\"%lld\\n\",min(S[2*K+2],S[2*K+3]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll solve(ll i, ll j, short c) {\n\tll sum = inf;\n\tif (c == 1) {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tll l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tif (l[0] != -1) {\n\t\tsum = min(solve(1, l[0], 1), 1 + solve(1, l[1], 0));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tsum = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nlist<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.d<no2.d;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.d>no2.d;\n}\n\nvector<int> ve[2][100010];\nint XY[2][100010],D[2][100010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tint M,N,K,a,b,npt,res;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tXY[0][K+1]=M;\n\tXY[1][K+1]=N;\n\tve[0][M].push_back(K+1);\n\tve[1][N].push_back(K+1);\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<no.d<<endl;//\n\t\tD[no.d][no.n]=no.t;\n\t\tif(no.n==K+1){\n\t\t\tres=no.t-1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\tif(D[!no.d][*it]==-1){\n\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tif(cnt>K-100) break;\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1e18)\n\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> P2;\n\nint main() {\n    long long M,N,K;\n    cin >> M >> N >> K;\n\n    vector<P2> sw;\n    sw.push_back(P2(0,P(1,1)));\n    for(int i=1; i<=K; ++i) {\n        long long a,b;\n        cin >> a >> b;\n        sw.push_back(P2(i,P(a,b)));\n    }\n    sw.push_back(P2(K+1,P(M,N)));\n\n    vector<P> edge[2];\n    edge[0].resize(K+2);\n    edge[1].resize(K+2);\n    \n    sort(sw.begin(),sw.end(),[](P2& lhs, P2& rhs) {\n        return (lhs.second.first==rhs.second.first?\n            (lhs.second.second==rhs.second.second?\n                (lhs.first<rhs.first):(lhs.second.second<rhs.second.second))\n            :(lhs.second.first<rhs.second.first));\n    });\n\n    for(int i=1; i<=K+1; ++i) { // search edge\n        if(sw[i-1].second.first==sw[i].second.first) {\n            long long d=sw[i].second.second-sw[i-1].second.second;\n            edge[0][sw[i-1].first]=P(sw[i].first,d);\n            if(sw[i-1].first!=0) {\n                edge[0][sw[i].first]=P(sw[i-1].first,d);\n            } else {\n                edge[0][sw[i].first]=P(-1,INF);\n            }\n        }\n    }\n\n    sort(sw.begin(),sw.end(),[](P2& lhs, P2& rhs) {\n        return (lhs.second.second==rhs.second.second?\n            (lhs.second.first==rhs.second.first?\n                (lhs.first<rhs.first):(lhs.second.first<rhs.second.first))\n            :(lhs.second.second<rhs.second.second));\n    });\n\n    for(int i=1; i<=K+1; ++i) { // search edge\n        if(sw[i-1].second.second==sw[i].second.second) {\n            long long d=sw[i].second.first-sw[i-1].second.first;\n            edge[1][sw[i-1].first]=P(sw[i].first,d);\n            if(sw[i-1].first!=0) {\n                edge[1][sw[i].first]=P(sw[i-1].first,d);\n            } else {\n                edge[1][sw[i].first]=P(-1,INF);\n            }\n        }\n    }\n\n    sort(sw.begin(),sw.end());\n\n    vector<long long> dist[2];\n    unordered_set<long long> visited[2];\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    dist[0].resize(K+2,INF);\n    dist[1].resize(K+2,INF);\n    q.push(P2(0,P(0,0))); // dist , from , sw\n    dist[0][0]=0;\n    visited[1].insert(0);\n    while(!q.empty()) {\n        P2 pp=q.top(); q.pop();\n        long long now_dist=pp.first;\n        long long now_from=pp.second.first;\n        long long now_sw=pp.second.second;\n        if(sw[now_sw].second.first==M && sw[now_sw].second.second==N) {\n            dist[now_from][K+1]=now_dist;\n            break;\n        }\n        if(visited[now_from].count(now_sw)!=0 || dist[now_from][now_sw]<now_dist) continue;\n        visited[now_from].insert(now_sw);\n        long long nxt_sw=edge[now_from][now_sw].first;\n        long long nxt_dist=now_dist+edge[now_from][now_sw].second;\n        if(visited[now_from].count(nxt_sw)==0 && nxt_sw>0 && dist[now_from][nxt_sw]>nxt_dist) {\n            q.push(P2(nxt_dist,P(now_from,nxt_sw)));\n            dist[now_from][nxt_sw]=nxt_dist;\n        }\n        nxt_sw=edge[(now_from+1)%2][now_sw].first;\n        nxt_dist=edge[(now_from+1)%2][now_sw].second+now_dist+1;\n        if(visited[(now_from+1)%2].count(nxt_sw)==0 && nxt_sw>0 && dist[(now_from+1)%2][nxt_sw]>nxt_dist) {\n            dist[(now_from+1)%2][nxt_sw]=nxt_dist;\n            q.push(P2(nxt_dist,P((now_from+1)%2,nxt_sw)));\n        }\n    }\n\n    long long ans=min(dist[0][K+1],dist[1][K+1]);\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n \nusing namespace std;\n \n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n \nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n \nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 5, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        int On=p.SE.SE;\n        if (D[v]<p.FI)continue;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], MP(t, 0)));\n                else if(On==0)que.push(PPII(D[t], MP(t, 0)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(flg==false&&fld[v].FI==1&&fld[v].SE==1)break;\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], MP(t, 1)));\n                else if(On==1) que.push(PPII(D[t], MP(t, 1)));\n            }\n        }\n    }\n}\n \nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<long long,int> PAL;\ntypedef pair<PAL,int> PPA;\n\nconst long long INF = 1000010000100001;\n\nint m,n,k;\n\nvector<PA> vx[100010],vy[100010];\nvector<PA> tate[200010],yoko[200010];\nlong long min_cost[2][200010];\n\nvoid make_edge(){\n    vx[n].push_back(PA(m,k+1));\n    vy[1].push_back(PA(1,0));\n    vy[m].push_back(PA(n,k+1));\n    \n    for(int i=1;i<=n;i++){\n        if(vx[i].size() < 2) continue;\n        sort(vx[i].begin(),vx[i].end());\n        for(int j=0;j<vx[i].size()-1;j++){\n            long long xcost = abs(vx[i][j].first-vx[i][j+1].first);\n            yoko[ vx[i][j].second ].push_back( PAL(xcost,vx[i][j+1].second) );\n            yoko[ vx[i][j+1].second ].push_back( PAL(xcost,vx[i][j].second) );\n        }\n    }\n    \n    for(int i=1;i<=m;i++){\n        if(vy[i].size() < 2) continue;\n        sort(vy[i].begin(),vy[i].end());\n        for(int j=0;j<vy[i].size()-1;j++){\n            long long ycost = abs(vy[i][j].first-vy[i][j+1].first);\n            tate[ vy[i][j].second ].push_back( PAL(ycost,vy[i][j+1].second) );\n            tate[ vy[i][j+1].second ].push_back( PAL(ycost,vy[i][j].second) );\n        }\n    }\n    \n}\n\nint main(){\n    \n    int x,y;\n    priority_queue<PPA,vector<PPA>,greater<PPA> > pq;\n    \n    cin >> m >> n >> k;\n    for(int i=0;i<k;i++){\n        cin >> x >> y;\n        if(x==1 && y==1){\n            vx[1].push_back(PA(1,0));\n        }\n        if(x==1 && y==1 || x==m && y==n) continue;\n        vx[y].push_back(PA(x,i+1));\n        vy[x].push_back(PA(y,i+1));\n    }\n    \n    make_edge();\n    \n    for(int i=1;i<=k+1;i++){\n        min_cost[0][i] = INF;\n        min_cost[1][i] = INF;\n    }\n    min_cost[0][0] = 0;\n    min_cost[1][0] = 0;\n    \n    pq.push( PPA(PA(0,0),0) );\n    while(!pq.empty()){\n        PPA pp = pq.top();\n        pq.pop();\n        PAL p = pp.first;\n        \n        for(int i=0;i<tate[p.second].size();i++){\n            long long cost = p.first + tate[p.second][i].first;\n            int to = tate[p.second][i].second;\n            if(pp.second == 0 && min_cost[0][to] > cost){\n                min_cost[0][to] = cost;\n                pq.push( PPA(PAL(cost,to),0) );\n            }\n            if(pp.second == 1 && min_cost[0][to] > cost+1){\n                min_cost[0][to] = cost+1;\n                pq.push( PPA(PAL(cost+1,to),0) );\n            }\n        }\n        \n        for(int i=0;i<yoko[p.second].size();i++){\n            long long cost = p.first + yoko[p.second][i].first;\n            int to = yoko[p.second][i].second;\n            if(pp.second == 0 && min_cost[1][to] > cost+1){\n                min_cost[1][to] = cost+1;\n                pq.push( PPA(PAL(cost+1,to),1) );\n            }\n            if(pp.second == 1 && min_cost[1][to] > cost){\n                min_cost[1][to] = cost;\n                pq.push( PPA(PAL(cost,to),1) );\n            }\n        }\n        \n    }\n    \n    long long ans = min(min_cost[0][k+1],min_cost[1][k+1]);\n    cout << (ans==INF?-1:ans) << endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nvector<int> map_x[MAX_M],map_y[MAX_N];\n\nconst long long INF=1000000000000000;\n\nlong long memo[MAX_K][2];\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//南北方向に開いている時\n\t\tfor (vector<int>::iterator i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\tmi=min(mi,abs(Y[*i]-y) + 1 + dfs(*i,0));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//東西方向に開いている時\n\t\tfor (vector<int>::iterator i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\tmi=min(mi,abs(X[*i]-x) + 1 + dfs(*i,1));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//始めは南北に開いている\n\tlong long res=INF;\n\tfor (vector<int>::iterator i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,Y[*i] + 1 + dfs(*i,0));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//解無し\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tX[i]=x-1;\n\t\tY[i]=y-1;\n\t\tmap_x[x-1].push_back(i);\n\t\tmap_y[y-1].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 50000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_N], yoko[MAX_N];//yoko->|   o  o |\n\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\n\tlong long G = solve();\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_K 200005\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nint n, m, k;\nint x[MAX_K], y[MAX_K];\n\nint dst[2][MAX_K];\nvector<Edge> edge[2][MAX_K];\n\nint ans = -1;\nint live_start = -1, live_goal = -1;\n\nmain() {\n\n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; ll c;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tll Min = INF;\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (x[p.p] == m - 1) {\n\t\t\tMin = min(Min, d[p.p][1] + abs(y[p.p] - n + 1));\n\t\t\tMin = min(Min, d[p.p][0] + 1 + abs(y[p.p] - n + 1));\n\t\t}\n\t\tif (y[p.p] == n - 1) {\n\t\t\tMin = min(Min, d[p.p][0] + abs(x[p.p] - m + 1));\n\t\t\tMin = min(Min, d[p.p][1] + 1 + abs(x[p.p] - m + 1));\n\t\t}\n\t\tif (p.b) {\n\t\t\tfor (int&u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int&u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int&u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int&u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%lld\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define START 200000\n#define GOAL  200001\n#define HUGE_NUM 9999999999999999\n\n\nenum DIR{\n\tTATE,\n\tYOKO,\n};\n\n\nstruct Info{\n\tint col,row;\n};\n\nstruct Data{\n\tData(){\n\t\tinfo_id = 0;\n\t\tloc = 0;\n\t}\n\tData(int arg_info_id,int arg_loc){\n\t\tinfo_id = arg_info_id;\n\t\tloc = arg_loc;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn loc < arg.loc;\n\t}\n\tint info_id,loc;\n};\n\nstruct STATE{\n\tSTATE(int arg_node_id,ll arg_cost,DIR arg_dir){\n\t\tnode_id = arg_node_id;\n\t\tcost = arg_cost;\n\t\tdir = arg_dir;\n\t}\n\tbool operator<(const struct STATE &arg) const{\n\t\treturn cost > arg.cost;\n\t}\n\tint node_id;\n\tll cost;\n\tDIR dir;\n};\n\nint W,H,K;\nvector<Data> COL[100000],ROW[100000];\nInfo info[200002];\nvector<int> G[200002];\nll min_cost[200002][2];\n\nint main(){\n\n\tscanf(\"%d %d %d\",&W,&H,&K);\n\n\tCOL[0].push_back(Data(START,0));\n\tROW[0].push_back(Data(START,0));\n\tinfo[START].row = 0;\n\tinfo[START].col = 0;\n\n\tCOL[W-1].push_back(Data(GOAL,H-1));\n\tROW[H-1].push_back(Data(GOAL,W-1));\n\tinfo[GOAL].row = H-1;\n\tinfo[GOAL].col = W-1;\n\n\tbool start_switch = false;\n\n\tint tmp_row,tmp_col;\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_row--;\n\t\ttmp_col--;\n\t\tif(tmp_row == 0 && tmp_col == 0){\n\t\t\tstart_switch = true;\n\t\t\tcontinue;\n\t\t}\n\t\tinfo[i].row = tmp_row;\n\t\tinfo[i].col = tmp_col;\n \t\tCOL[info[i].col].push_back(Data(i,info[i].row));\n\t\tROW[info[i].row].push_back(Data(i,info[i].col));\n\t}\n\n\n\tfor(int row = 0; row < H; row++){\n\t\tsort(ROW[row].begin(),ROW[row].end());\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tsort(COL[col].begin(),COL[col].end());\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tif(ROW[row].size() <= 1)continue;\n\n\t\tfor(int i = 0; i < ROW[row].size()-1; i++){\n\t\t\tG[ROW[row][i].info_id].push_back(ROW[row][i+1].info_id);\n\t\t\tG[ROW[row][i+1].info_id].push_back(ROW[row][i].info_id);\n\t\t}\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tif(COL[col].size() <= 1)continue;\n\n\t\tfor(int i = 0; i < COL[col].size()-1; i++){\n\t\t\tG[COL[col][i].info_id].push_back(COL[col][i+1].info_id);\n\t\t\tG[COL[col][i+1].info_id].push_back(COL[col][i].info_id);\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= GOAL; i++){\n\t\tmin_cost[i][TATE] = HUGE_NUM;\n\t\tmin_cost[i][YOKO] = HUGE_NUM;\n\t}\n\n\tpriority_queue<STATE> Q;\n\n\tmin_cost[START][TATE] = 0;\n\tQ.push(STATE(START,0,TATE));\n\n\tif(start_switch){\n\t\tmin_cost[START][YOKO] = 1;\n\t\tQ.push(STATE(START,1,YOKO));\n\t}\n\n\tint next_node;\n\tll next_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == GOAL){\n\t\t\tprintf(\"%lld\\n\",Q.top().cost);\n\t\t\treturn 0;\n\t\t}else if(Q.top().cost > min_cost[Q.top().node_id][Q.top().dir]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i];\n\n\t\t\t\tnext_cost = Q.top().cost;\n\n\t\t\t\tif(info[Q.top().node_id].row == info[next_node].row){\n\t\t\t\t\tnext_cost += abs(info[Q.top().node_id].col-info[next_node].col);\n\n\t\t\t\t\tif(Q.top().dir == TATE && Q.top().node_id == START && start_switch == false)continue;\n\t\t\t\t\tif(Q.top().dir == TATE)next_cost += 1;\n\n\t\t\t\t\tif(min_cost[next_node][YOKO] > next_cost){\n\t\t\t\t\t\tmin_cost[next_node][YOKO] = next_cost;\n\t\t\t\t\t\tQ.push(STATE(next_node,next_cost,YOKO));\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tnext_cost += abs(info[Q.top().node_id].row-info[next_node].row);\n\n\t\t\t\t\tif(Q.top().dir == YOKO && Q.top().node_id == START && start_switch == false)continue;\n\t\t\t\t\tif(Q.top().dir == YOKO)next_cost += 1;\n\n\t\t\t\t\tif(min_cost[next_node][TATE] > next_cost){\n\t\t\t\t\t\tmin_cost[next_node][TATE] = next_cost;\n\t\t\t\t\t\tQ.push(STATE(next_node,next_cost,TATE));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64, int > Pi;\nconst int64 INF = 1LL << 60;\nstruct edge {\n  int to, cost;\n};\nvector< edge > graph[400004];\nint64 min_cost[400004];\nint H, W, K;\nvector< Pi > X[100001], Y[100001];\n  \nint64 Dijkstra()\n{\n  fill_n(min_cost, 400004, INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > Que;\n  min_cost[K - 2] = 0;\n  Que.push(Pi(0, K - 2));\n  while(!Que.empty()) {\n    Pi p = Que.top(); Que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    if(p.second == K - 1) return(p.first);\n    for(auto e : graph[p.second]) {\n      int64 next = p.first + e.cost;\n      if(min_cost[e.to] > next) {\n        min_cost[e.to] = next;\n        Que.push(Pi(next, e.to));\n      }\n    }\n  }\n  return(-1);\n}\n  \n  \nint main()\n{\n  cin >> W >> H >> K;\n  for(int i = 0; i < K; i++) {\n    int x, y;\n    cin >> x >> y;\n    X[x].push_back(Pi(y, i));\n    Y[y].push_back(Pi(x, i));\n  }\n  \n  X[1].push_back(Pi(1, K));\n  Y[1].push_back(Pi(1, K));\n  \n  X[W].push_back(Pi(H, K + 1));\n  Y[H].push_back(Pi(W, K + 1));\n  \n  K += 2;\n  \n  for(int i = 0; i < 100001; i++) {\n    sort(X[i].begin(), X[i].end());\n    sort(Y[i].begin(), Y[i].end());\n    for(int j = 1; j < X[i].size(); ++j) {\n      const Pi &prev = X[i][j - 1], &curr = X[i][j];\n      graph[prev.second].push_back((edge){curr.second, (int)(curr.first - prev.first)});\n      graph[curr.second].push_back((edge){prev.second, (int)(curr.first - prev.first)});\n    }\n    for(int j = 1; j < Y[i].size(); ++j) {\n      const Pi &prev = Y[i][j - 1], &curr = Y[i][j];\n      graph[prev.second + K].push_back((edge){curr.second + K, (int)(curr.first - prev.first)});\n      graph[curr.second + K].push_back((edge){prev.second + K, (int)(curr.first - prev.first)});\n    }\n  }\n  \n  \n  for(int i = 0; i < K - 2; i++) {\n    graph[i].push_back((edge){i + K, 1});\n    graph[i + K].push_back((edge){i, 1});\n  }\n  graph[K - 1 + K].push_back((edge){K - 1, 0});  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int M,N,K;\n    cin >> M >> N >> K;\n    vector<pair<int,int> > XY[100001], YX[100001], p;\n    vector<int> c[2];\n    p.push_back(MP(1, 1));\n    XY[1].push_back(MP(1, 0));\n    YX[1].push_back(MP(1, 0));\n    c[0].push_back(0);\n    c[1].push_back(INT_MAX);\n    for(int i=1; i<=K; i++){\n        int x,y;\n        cin >> x >> y;\n        p.push_back(MP(x, y));\n        XY[x].push_back(MP(y, i));\n        YX[y].push_back(MP(x, i));\n        c[0].push_back(INT_MAX);\n        c[1].push_back(INT_MAX);\n    }\n    p.push_back(MP(M, N));\n    XY[M].push_back(MP(N, K+1));\n    YX[N].push_back(MP(M, K+1));\n    c[0].push_back(INT_MAX);\n    c[1].push_back(INT_MAX);\n    for(int i=1; i<=M; i++) sort(XY[i].begin(), XY[i].end());\n    for(int i=1; i<=N; i++) sort(YX[i].begin(), YX[i].end());\n\n    priority_queue<pair<int, pair<int, int> > > que;\n    que.push(MP(INT_MAX, MP(0, 0)));\n    while(!que.empty()){\n        int now = que.top().second.first;\n        int state = que.top().second.second;\n        //cout << now << \" \" << state << \" \" << INT_MAX-que.top().first << endl;\n        if(now != 0 && now != K+1 && c[(state+1)%2][now] > c[state][now]+1){\n            c[(state+1)%2][now] = c[state][now]+1;\n            que.push(MP(INT_MAX-c[(state+1)%2][now], MP(now, (state+1)%2)));\n        }\n        if(state == 0){\n            auto itr = lower_bound(XY[p[now].first].begin(), XY[p[now].first].end(), MP(p[now].second, now));    \n            if(itr != XY[p[now].first].begin() && c[state][(itr-1)->second] > c[state][now] + abs(p[now].second-((itr-1)->first))){\n                c[state][(itr-1)->second] = c[state][now] + abs(p[now].second-((itr-1)->first));\n                que.push(MP(INT_MAX-c[state][(itr-1)->second], MP((itr-1)->second, state)));\n            }\n            if(itr != XY[p[now].first].end()-1 && c[state][(itr+1)->second] > c[state][now] + abs(p[now].second-((itr+1)->first))){\n                c[state][(itr+1)->second] = c[state][now] + abs(p[now].second-((itr+1)->first));\n                que.push(MP(INT_MAX-c[state][(itr+1)->second], MP((itr+1)->second, state)));\n            }\n        }\n        else{\n            auto itr = lower_bound(YX[p[now].second].begin(), YX[p[now].second].end(), MP(p[now].first, now));\n            if(itr != YX[p[now].second].begin() && c[state][(itr-1)->second] > c[state][now] + abs(p[now].first-((itr-1)->first))){\n                c[state][(itr-1)->second] = c[state][now] + abs(p[now].first-((itr-1)->first));\n                que.push(MP(INT_MAX-c[state][(itr-1)->second], MP((itr-1)->second, state)));\n            }\n            if(itr != YX[p[now].second].end()-1 && c[state][(itr+1)->second] > c[state][now] + abs(p[now].first-((itr+1)->first))){\n                c[state][(itr+1)->second] = c[state][now] + abs(p[now].first-((itr+1)->first));\n                que.push(MP(INT_MAX-c[state][(itr+1)->second], MP((itr+1)->second, state)));\n            }\n        }\n        que.pop();\n    }\n    \n    cout << min(c[0][K+1], c[1][K+1]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LL long long\nconst LL inf = 1e15;\n\nstruct edge{\n    int n, ty;\n    LL cost;\n    bool operator<(const edge& e1) const {\n        return e1.cost < cost;\n    }\n};\n\nint M, N, K;\nint z[200010][2];\nLL D[200010][2];\nvector<int> G[100010][2];\nint main(){\n    cin >> M >> N >> K;\n    for(int i = 0; i <= K; i++){\n        D[i][0] = inf;\n        D[i][1] = inf;\n    }\n    z[0][0] = z[0][1] = 1;\n    for(int i = 1; i <= K; i++){\n        cin >> z[i][0] >> z[i][1];\n        G[z[i][0]][0].push_back(i);\n        G[z[i][1]][1].push_back(i);\n    }\n    priority_queue<edge> pq;\n    pq.push(edge{0, 0, 0});\n    D[0][0] = 0;\n    while(!pq.empty()){\n        edge e = pq.top();\n        pq.pop();\n        if(D[e.n][e.ty] < e.cost) continue;\n        int inv = (e.ty + 1) & 1;\n        for(auto &u : G[z[e.n][e.ty]][e.ty]){\n            LL c = e.cost + (LL)abs(z[e.n][inv] - z[u][inv]) + 1;\n            if(D[u][inv] > c){\n                D[u][inv] = c;\n                pq.push(edge{u, inv, c});\n            }\n        }\n    }\n    LL ans = inf;\n    for(int i = 1; i <= K; i++){\n        if(z[i][0] == M){\n            ans = min(ans, min(D[i][0],D[i][1] + 1) + abs(N - z[i][1]) );\n        }\n        if(z[i][1] == N){\n            ans = min(ans, min(D[i][0] + 1,D[i][1]) + abs(M - z[i][0]) );\n        }\n    }\n    cout << (ans == inf ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000], lenx[100000], leny[100000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, m)X[i] = vector<int>(n);\n\trep(i, n)Y[i] = vector<int>(m);\n\t\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]][lenx[x[i]]++] = i; Y[y[i]][leny[y[i]]++] = i;\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\trep(i, lenx[x[p.p]]) {\n\t\t\tint u = X[x[p.p]][i];\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\trep(i, leny[y[p.p]]) {\n\t\t\tint u = Y[y[p.p]][i];\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, lenx[m - 1]) {\n\t\tint u = X[m - 1][i];\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t}\n\trep(i, leny[n - 1]) {\n\t\tint u = Y[n - 1][i];\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\tfor (int u : X[0]) {\n\t\td[u][1] = y[u]; d[u][0] = y[u] + 1;\n\t\tque.push({ u,1,d[u][1] });\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\nconst int inf = 1e9 + 9;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nstruct edge\n{\n  edge() {}\n  edge (int t, int v, int c) { to = t; f = v; cost = c; }\n  int to, f, cost;\n};\n\nint h, w, k;\nvector<PP> a, b;\nvector<edge> G[2][202020];\nint d[2][202020];\n\nvoid dijkstra(int s, int po)\n{\n  for (int i = 0; i < 202020; i++){\n    d[0][i] = d[1][i] = inf;\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > q;\n\n  d[0][s] = 0;\n  q.push(PP(0, P(s, 0)));\n\n  while (!q.empty()){\n    PP p = q.top(); q.pop();\n    int v = p.se.fi;\n    int f = p.se.se;\n\n    for (int i = 0; i < G[f][v].size(); i++){\n      edge e = G[f][v][i];\n      if (d[e.f][e.to] > d[f][v] + e.cost){\n        d[e.f][e.to] = d[f][v] + e.cost;\n        q.push(PP(d[e.f][e.to], P(e.to, e.f)));\n      }\n    }\n  }\n}\n\nint main()\n{\n  bool izryt = false, _izryt = false;\n  cin >> w >> h >> k;\n  for (int i = 1; i <= k; i++){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    if (x == 0 && y == 0){\n      a.push_back(PP(x, P(y, 0)));\n      b.push_back(PP(y, P(x, 0)));\n      G[0][0].push_back(edge(0, 1, 1));\n      G[1][0].push_back(edge(0, 0, 1));\n      izryt = true;\n    }\n    else if (x + 1 == w && y + 1 == h){\n      a.push_back(PP(x, P(y, k + 1)));\n      b.push_back(PP(y, P(x, k + 1)));\n      G[0][k + 1].push_back(edge(k + 1, 1, 1));\n      G[1][k + 1].push_back(edge(k + 1, 0, 1));\n      _izryt = true;\n    }\n    else {\n      a.push_back(PP(x, P(y, i)));\n      b.push_back(PP(y, P(x, i)));\n      G[0][i].push_back(edge(i, 1, 1));\n      G[1][i].push_back(edge(i, 0, 1));\n    }\n  }\n\n  if (!izryt) a.push_back(PP(0, P(0, 0)));\n  if (!_izryt) b.push_back(PP(h - 1, P(w - 1, k + 1)));\n\n  sort(a.begin(), a.end());\n  sort(b.begin(), b.end());\n\n  for (int i = 0; i < a.size() - 1; i++){\n    if (a[i].fi == a[i + 1].fi && a[i].se.fi != a[i + 1].se.fi){\n      G[0][a[i].se.se].push_back(edge(a[i + 1].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n      G[0][a[i + 1].se.se].push_back(edge(a[i].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n    }\n  }\n\n  for (int i = 0; i < b.size() - 1; i++){\n    if (b[i].fi == b[i + 1].fi && b[i].se.fi != b[i + 1].se.fi){\n      G[1][b[i].se.se].push_back(edge(b[i + 1].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n      G[1][b[i + 1].se.se].push_back(edge(b[i].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n    }\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tif(flg){\n\t\t\t\t\tres=min(res,no.d-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflg=true;\n\t\t\t\t\tres=no.d-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\t//if(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t\t//}\n\t\t\t}\n\t\t\twhile(!sag.empty()){\n\t\t\t\tno2=sag.top();sag.pop();\n\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nstruct edge{ll to,cost;};\nstruct state{\n  ll pos,flg,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nvector<P> t[MAX][2];\nll W,H,K,X[MAX],Y[MAX];\nll d[MAX][2];\nvector<edge> G[MAX][2];\n \nll solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=10000000000000000LL;\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( (state){ p.second, 0, p.first-1 } );\n  d[p.second][0]=p.first-1;\n   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        ll ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push((state){e.to,nf,ncost});\n        }\n      }\n    }\n  }\n  ll res=min(d[K][0],d[K][1]);\n  if(res==1e9)return -1;\n  else return res;\n}\n       \nint main(){\n  scanf(\"%lld %lld %lld\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%lld %lld\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( (edge){q.second,p.first-q.first} );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( (edge){q.second,q.first-p.first} );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n\nint m, n, k, x[200005], y[200005], N;\nbool u[2][200005], sw, T;\nmap<int, int> r[100005], c[100005];\nll D;\npq<pair<pair<ll, int>, bool> > q;\nint main(){\n    scanf(\"%i%i%i\", &m, &n, &k);\n    fox(l, k){\n        scanf(\"%i%i\", &y[l], &x[l]);\n        r[x[l]][y[l]]=l;\n        c[y[l]][x[l]]=l;\n        if (x[l]==1 && y[l]==1) sw=1;\n    }\n    x[k]=n; y[k]=m;\n    x[k+1]=1; y[k+1]=1;\n    r[n][m]=k; c[m][n]=k;\n    q.push(mp(mp(0, k+1), 1));\n    //cout << x[0] << ' ' << y[0] << endl;\n    while(!q.empty()){\n        N=q.top().x.y; D=-q.top().x.x; T=q.top().y; q.pop();\n        if (u[T][N]) continue;\n        u[T][N]=1;\n        if (N!=k+1 || sw)\n        q.push(mp(mp(-D-1, N), !T));\n        //cout << N << ' ' << T << ' ' << D << endl;\n        if (N==k){\n            cout << D << endl;\n            return 0;\n        }\n        if (T){\n            c[y[N]].erase(x[N]);\n            //cout << N << ' ' << y[N] << ' ' << c[y[N]].size() << endl;\n            //for (auto i:c[y[N]]) cout << i.x << ' '; cout << endl;\n            if (c[y[N]].lb(x[N])!=c[y[N]].end())\n                q.push(mp(mp(-D-(c[y[N]].lb(x[N])->x-x[N]), c[y[N]].lb(x[N])->y), T));\n            if (c[y[N]].lb(x[N])!=c[y[N]].begin())\n                q.push(mp(mp(-D-(x[N]-(--c[y[N]].lb(x[N]))->x), (--c[y[N]].lb(x[N]))->y), T));\n        } else {\n            r[x[N]].erase(y[N]);\n            //cout << r[x[N]].size() << endl;\n            if (r[x[N]].lb(y[N])!=r[x[N]].end()){\n                q.push(mp(mp(-D-(r[x[N]].lb(y[N])->x-y[N]), r[x[N]].lb(y[N])->y), T));\n            }\n            if (r[x[N]].lb(y[N])!=r[x[N]].begin())\n                q.push(mp(mp(-D-(y[N]-(--r[x[N]].lb(y[N]))->x), (--r[x[N]].lb(y[N]))->y), T));\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint n, m, k;\ntypedef pair<long long int, int> P;\nvector<P> x[100010], y[100010];\nvector<P> g[400010];\nlong long int INF = 1e18;\nbool f;\nlong long int d[400010];\npriority_queue<P, vector<P>, greater<P> > q;\n\nint main(){\n\tscanf(\"%d %d %d\", &m, &n, &k);\n\tfor(int i=0; i<k; ++i){\n\t\tlong long int a, b;\n\t\tscanf(\"%lld %lld\", &a, &b);\n\t\tif((a + b != n + m) || (a + b != 2)){\n\t\t\tx[a].push_back(P(b, i+1));\n\t\t\ty[b].push_back(P(a, i+1));\n\t\t}else if(a + b == 2) f = true;\n\t}\n\tx[1].push_back(P(1, k+1));\n\ty[1].push_back(P(1, k+1));\n\tx[m].push_back(P(n, k+2));\n\ty[n].push_back(P(m, k+2));\n/*\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=m; ++i)\n\t\tfor(int j=0; j<x[i].size(); ++j)\n\t\t\tprintf(\"x=%d %dth y=%d %dth\\n\", i, j, x[i][j].first, x[i][j].second);\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<y[i].size(); ++j)\n\t\t\tprintf(\"%d %d %d %d\\n\", i, j, y[i][j].first, y[i][j].second);\n\tprintf(\"\\n\");\n*/\n\n\tfor(int i=1; i<=m; ++i){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j=0; j+1<x[i].size(); ++j){\n\t\t\tg[x[i][j].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j+1].second));\n\t\t\tg[x[i][j+1].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j].second));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=n; ++i){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j=0; j+1<y[i].size(); ++j){\n\t\t\tg[y[i][j].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j+1].second+k+2));\n\t\t\tg[y[i][j+1].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j].second+k+2));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=k; ++i){\n\t\tg[i].push_back(P(1, i+k+2));\n\t\tg[i+k+2].push_back(P(1, i));\n\t}\n\tif(f){\n\t\tg[k+1].push_back(P(1, 2*k+3));\n\t\tg[2*k+3].push_back(P(1, k+1));\n\t}\n\tg[k+2].push_back(P(1, 2*k+4));\n\tg[2*k+4].push_back(P(1, k+2));\n/*\n\tfor(int i=1; i<=2*k+4; ++i){\n\t\t\n\t\tfor(int j=0; j<g[i].size(); ++j){\n\t\t\tprintf(\"cost=%d to=%d\\n\", g[i][j].first, g[i][j].second);\n\t\t}\n\t}\n*/\n\tfill(d+1, d+2*k+5, INF);\n\td[k+1] = 0;\n\tif(f) d[2*k+3] = 1;\n\tq.push(P(0, k+1));\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i=0; i<g[v].size(); ++i){\n\t\t\tif(d[g[v][i].second] > d[v] + g[v][i].first){\n\t\t\t\td[g[v][i].second] = d[v] + g[v][i].first;\n\t\t\t\tq.push(P(d[g[v][i].second], g[v][i].second));\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"\\n\");\n\tfor(int i=1; i<=2*k+4; ++i) printf(\"%d\\n\", d[i]);\n\tprintf(\"\\n\");\n*/\tlong long int ans = min(d[k+2], d[2*k+4]);\n\tif(ans == INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll m[2000000][2];\nll solve(ll i, ll j, short c, ll s) {\n\tll sum = inf, d, e;\n\tif (c == 1) {\n\t\td = x[i][j].b;\n\t\te = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\tif (y[e][z].b != d&&s + res + 1 < m[y[e][z].b][0]) {\n\t\t\t\tm[y[e][z].b][0] = 1 + res + s;\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\td = y[i][j].b;\n\t\te = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\tif (x[e][z].b != d && 1 + res + s < m[x[e][z].b][1]) {\n\t\t\t\tm[x[e][z].b][1] = 1 + res + s;\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1, 1 + res + s);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tm[0][0] = inf;\n\tm[0][1] = inf;\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tm[i][0] = inf;\n\t\tm[i][1] = inf;\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tx[1].push_back(A{ 1,0 });\n\ty[1].push_back(A{ 1,0 });\n\tm[0][0] = 0;\n\tm[0][1] = 1;\n\tsum = solve(1, x[1].size() - 1, 1, 0);\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_K 222222\n#define fi first\n#define sc second\n#define pb push_back\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\ntypedef pair<ll,int> Pl;\nint M,N,K;\nint X[MAX_K];int Y[MAX_K];\nvector<P>G[2*MAX_K];\nll S[2*MAX_K];\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0;i<K;i++){\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);X[i]--;Y[i]--;\n\t}\n\tvector<Pi>sX;\n\tfor(int i=0;i<K;i++){\n\t\tsX.pb(Pi(P(X[i],Y[i]),i));\n\t}\n\tsX.pb(Pi(P(0,0),K));\n\tsX.pb(Pi(P(M-1,N-1),K+1));\n\tsort(sX.begin(),sX.end());\n\t/*\n\tfor(int i=0;i<K+2;i++){\n\t\tprintf(\"%d %d %d\\n\",sX[i].fi.fi,sX[i].fi.sc,sX[i].sc);\n\t}\n\t*/\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sX[i].fi.fi==sX[i+1].fi.fi){\n\t\t\tG[2*sX[i].sc+1].pb(P(2*sX[i+1].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t\tG[2*sX[i+1].sc+1].pb(P(2*sX[i].sc+1,sX[i+1].fi.sc-sX[i].fi.sc));\n\t\t}\n\t}\n\tvector<Pi>sY;\n\tfor(int i=0;i<K;i++){\n\t\tsY.pb(Pi(P(Y[i],X[i]),i));\n\t}\n\tsY.pb(Pi(P(0,0),K));\n\tsY.pb(Pi(P(N-1,M-1),K+1));\n\tsort(sY.begin(),sY.end());\n\tfor(int i=0;i<K+1;i++){\n\t\tif(sY[i].fi.fi==sY[i+1].fi.fi){\n\t\t\tG[2*sY[i].sc].pb(P(2*sY[i+1].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t\tG[2*sY[i+1].sc].pb(P(2*sY[i].sc,sY[i+1].fi.sc-sY[i].fi.sc));\n\t\t}\n\t}\n\tfor(int i=0;i<K+2;i++){\n\t\tG[2*i].pb(P(2*i+1,1));\n\t\tG[2*i+1].pb(P(2*i,1));\n\t}\n\tfor(int i=0;i<2*(K+2);i++){\n\t\tS[i]=111111111111111;\n\t\t/*\n\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\tprintf(\"%d-%d:%d\\n\",i,G[i][j].fi,G[i][j].sc);\n\t\t}\n\t\t*/\n\t}\n\tpriority_queue<Pl,vector<Pl>,greater<Pl> >que;\n\tque.push(P(0,2*K+1));\n\twhile(!que.empty()){\n\t\tPl p=que.top();que.pop();\n\t\tif(S[p.sc]<=p.fi){continue;}\n\t\tS[p.sc]=p.fi;\n\t\tfor(int i=0;i<(int)G[p.sc].size();i++){\n\t\t\tif(S[G[p.sc][i].fi]>p.fi+(ll)G[p.sc][i].sc){\n\t\t\t\tque.push(Pl(p.fi+(ll)G[p.sc][i].sc,G[p.sc][i].fi));\n\t\t\t}\n\t\t}\n\t}\n\tif(S[2*K+2]==(ll)(111111111111111)){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tprintf(\"%lld\\n\",min(S[2*K+2],S[2*K+3]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct room{\n  int roomnum;\n  bool visited;\n  \n  bool operator>(const room compared) const\n  {\n    return roomnum > compared.roomnum;\n  }\n  bool operator<(const room compared) const\n  {\n    return roomnum < compared.roomnum;\n  }\n};\n\nstruct compar{\n  int cost, loc_x, loc_y;\n  bool is_ns;\n  \n  bool operator>(const compar compared) const\n  {\n    return cost > compared.cost;\n  }\n  bool operator<(const compar compared) const\n  {\n    return cost < compared.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100001], ew[100001];\npriority_queue<compar, vector<compar>, greater<compar> > sr;\n\nint dijk()\n{\n  if(!ns[1].size())\n    return -1;\n  \n  compar start = {(ns[1].begin())->roomnum - 1, 1, (ns[1].begin())->roomnum, true};\n  sr.push(start);\n  \n  while(!sr.empty()){\n    compar now = sr.top();\n    sr.pop();\n    \n    if(now.loc_x == m && now.loc_y == n)\n      return now.cost;\n    \n    vector<room>::iterator p;\n    if(now.is_ns){\n      room pp = {now.loc_y, false};\n      p = lower_bound(ns[now.loc_x].begin(), ns[now.loc_x].end(), pp);\n      \n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ns[now.loc_x].begin()){\n\t  compar next = {now.cost + now.loc_y - (p - 1)->roomnum, now.loc_x, (p - 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tif(p != ns[now.loc_x].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_y, now.loc_x, (p + 1)->roomnum, true};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, false};\n\tsr.push(next);\n      }\n    }\n    else{\n      room pp = {now.loc_x, false};\n      p = lower_bound(ew[now.loc_y].begin(), ew[now.loc_y].end(), pp);\n\n      if(!p->visited){\n\tp->visited = true;\n\tif(p != ew[now.loc_y].begin()){\n\t  compar next = {now.cost + now.loc_x - (p - 1)->roomnum, (p - 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tif(p != ew[now.loc_y].end() - 1){\n\t  compar next = {now.cost + (p + 1)->roomnum - now.loc_x, (p + 1)->roomnum, now.loc_y, false};\n\t  sr.push(next);\n\t}\n\tcompar next = {now.cost + 1, now.loc_x, now.loc_y, true};\n\tsr.push(next);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  for(int i = 0; i < k; i++){\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    room x_in = {y, false};\n    ns[x].push_back(x_in);\n    room y_in = {x, false};\n    ew[y].push_back(y_in);\n  }\n  room x_in = {n, false};\n  ns[m].push_back(x_in);\n  room y_in = {m, false};\n  ew[n].push_back(y_in);\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= n; i++)\n    sort(ew[i].begin(), ew[i].end());\n  \n  printf(\"%d\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1LL<<60\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, bool> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\nvector<P> xy;\n// map<int, vector<int> > X;\n// map<int, vector<int> > Y;\nmap<pair<int, int>, int > id;\n// map<int, pair<int,int> > xy;\nll d[200005][2];\n\n// PI f(int a, int b, int c) {\n// \treturn mp(mp(a, b), c);\n// }\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\t\t// int to = id[mp(y, 1)];\n\n\t\td[to][1] = y;\n\t\t// que.push(f(y, to, 1));\n\t\tque.push(mp(mp(y, to), 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\t// cout << \" ------ : (\" << y << \",\" << x << \",\" << state << \") :\" << v << \" \" << c << endl;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\t\t\t\t// int to = id[mp(ny, x)];\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\t// que.push(f(d[to][1], to, 1));\n\t\t\t\t\tque.push(mp(mp(d[to][1], to), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\t\t\t\t// int to = id[mp(y, Y[y][i])];\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\t// que.push(f(d[to][0], to, 0));\n\t\t\t\t\tque.push(mp(mp(d[to][0], to), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\txy.resize(k);\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\t// rep(i, k) {\n\t// \tcout << \"k:\" << i << \" (\" << xy[i].first << \",\" << xy[i].second << \") :\" << d[i][0] << \" : \" << d[i][1] << endl;\n\t// }\n\n\tll ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<complex>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \nusing namespace std;\nusing Complex = complex<double>;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\ndouble PI = acos(-1.0);\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\nint N,M,K;\nvector<int>Ex[101010],Ey[101010];\nll dist[1000000];\nmap<vector<int>,int>mp;\nvector<pair<int, int>>Enew[1000000];\n\nvoid dijkstra() {\n\tfor (int i = 0; i < 1000000;i++)dist[i] = inf;\n\tmin_priority_queue<pair<ll,int>>q;\n\tint idx = mp[{0, 0, 0}];\n\tq.push({0,idx});\n\twhile (q.size()) {\n\t\tauto p = q.top();\n\t\tq.pop();\n\t\tll d = p.first;\n\t\tint v = p.second;\n\t\tfore(x, Enew[v]) {\n\t\t\tint to = x.first;\n\t\t\tll cost = x.second;\n\n\t\t\tif (dist[to] > d + cost) {\n\t\t\t\tq.push({d+cost,to});\n\t\t\t\tdist[to] = d + cost;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcin >> M >> N >> K;\n\tint fl0 = 0;\n\tint fl1 = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tEx[x].pb(y);\n\t\tEy[y].pb(x);\n\t\tif (x == 0 && y == 0)fl0 = 1;\n\t\tif (x == M - 1 && y == N - 1)fl1 = 1;\n\t}\n\tif (!fl0) { Ex[0].pb(0); }\n\tif (!fl1) { \n\t\tEx[M - 1].pb(N - 1); \n\t\tEy[N - 1].pb(M - 1);\n\t}\n\n\tfor (int i = 0; i < 101010; i++)sort(all(Ex[i]));\n\tfor (int i = 0; i < 101010; i++)sort(all(Ey[i]));\n\n\tint cnt = 0;\n\tfor (int i = 0; i < 101010; i++) {\n\t\tfore(x, Ex[i]) {\n\t\t\tif (fl0 == 0 && i == 0 && x == 0) {\n\t\t\t\tmp[{0,0,0}] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[{i,x,0}] = cnt;\n\t\t\t\tcnt++;\n\t\t\t\tmp[{i,x,1}] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 101010; i++) {\n\t\tfor (int j = 0; j + 1 < Ex[i].size(); j++) {\n\t\t\tint num1 = mp[{i,Ex[i][j],0}];\n\t\t\tint num2 = mp[{i,Ex[i][j+1],0}];\n\t\t\tint diff = Ex[i][j + 1] - Ex[i][j];\n\t\t\tEnew[num1].pb({num2,diff});\n\t\t\tEnew[num2].pb({num1,diff});\n\t\t}\n\t}\n\tfor (int i = 0; i < 101010; i++) {\n\t\tfor (int j = 0; j + 1 < Ey[i].size(); j++) {\n\t\t\tint num1 = mp[{Ey[i][j],i, 1}];\n\t\t\tint num2 = mp[{Ey[i][j+1], i, 1}];\n\t\t\tint diff = Ey[i][j + 1] - Ey[i][j];\n\t\t\tEnew[num1].pb({ num2,diff });\n\t\t\tEnew[num2].pb({ num1,diff });\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 101010; i++) {\n\t\tfore(x, Ex[i]) {\n\t\t\tif (fl0 == 0 && i == 0 && x == 0)continue;\n\t\t\tif (fl1 == 0 && i == M - 1 && x == N - 1)continue;\n\t\t\tint num1 = mp[{i, x, 0}];\n\t\t\tint num2 = mp[{i, x, 1}];\n\t\t\tEnew[num1].pb({ num2,1 });\n\t\t\tEnew[num2].pb({ num1,1 });\n\t\t}\n\t}\n\tdijkstra();\n\n\tll ans = min(dist[mp[{M - 1, N - 1, 0}]], dist[mp[{M - 1, N - 1, 1}]]);\n\tif (ans > 1e16)puts(-1);\n\telse puts(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        int On=p.SE.SE;\n        //cout<<fld[v].FI<<\" \"<<fld[v].SE<<endl;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            //cout<<cost<<endl;\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], MP(t, 0)));\n                else if(On==0)que.push(PPII(D[t], MP(t, 0)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], MP(t, 1)));\n                else if(On==1) que.push(PPII(D[t], MP(t, 1)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct edge{ll to,cost;};\nstruct state{\n  ll pos,flg,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nvector<P> t[MAX][2];\nint W,H,K,X[MAX],Y[MAX];\nll d[MAX][2];\nvector<edge> G[MAX][2];\n \nll solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=(1LL<<60);\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( (state){ p.second, 0, p.first-1 } );\n  d[p.second][0]=p.first-1;\n   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        ll ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push((state){e.to,nf,ncost});\n        }\n      }\n    }\n  }\n  ll res=min(d[K][0],d[K][1]);\n  if(res==1e9)return -1;\n  else return res;\n}\n       \nint main(){\n  scanf(\"%d %d %d\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( (edge){q.second,p.first-q.first} );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( (edge){q.second,q.first-p.first} );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n};\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx,ky;\nint main(){\n\t//cout<<\"WA\"<<endl;//\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 6000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 6000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();\n\t\tpq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long int w, h;\nclass map {\npublic:\n\tlong long int fast;\n\tbool swi;\n\tmap();\n};\nmap::map() :fast(w*h), swi(false) {\n\n}\nmap **paper;\nlong long int answer(int, int, long long int, bool);\nint main() {\n\tcin >> w >> h;\n\tint time;\n\tcin >> time;\n\tint x, y;\n\tpaper = new map*[w + 1];\n\tfor (int i = 1; i <= w; ++i) {\n\t\tpaper[i] = new map[h + 1];\n\t}\n\tfor (int i = 0; i < time; ++i) {\n\t\tcin >> x >> y;\n\t\tpaper[x][y].swi = true;\n\t}\n\tpaper[w][h].swi = true;\n\tlong long int a = (paper[1][1].swi == true) ? min(answer(1, 1, 0, true), answer(1, 1, 1, false)) : answer(1, 1, 0, true);\n\tcout << (a == w*h ? -1 : a) << endl;\n\treturn 0;\n}\n\nlong long int answer(int x, int y, long long int time, bool vertical) {\n\tif (paper[x][y].fast <= time) {\n\t\treturn w*h;\n\t}\n\telse {\n\t\tpaper[x][y].fast = time;\n\t}\n\tif (x == w&&y == h)return time - 1;\n\tlong long int nmin = w*h;\n\tlong long int dummy;\n\tif (vertical) {\n\t\tfor (int i = 1; i <= h; ++i) {\n\t\t\tif (paper[x][i].swi) {\n\t\t\t\tdummy = answer(x, i, time + abs(y - i) + 1, !vertical);\n\t\t\t\tnmin = (nmin > dummy) ? dummy : nmin;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 1; i <= w; ++i) {\n\t\t\tif (paper[i][y].swi) {\n\t\t\t\tdummy = answer(i, y, time + abs(x - i) + 1, !vertical);\n\t\t\t\tnmin = (nmin > dummy) ? dummy : nmin;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<climits>\n#include<cstring>\n#include<map>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\nint H,W,N;\n\nstruct Point { \n  int x,y,b;\n  Point(int x=-1,int y=-1,int b=1):x(x),y(y),b(b){}\n  bool operator < ( const Point &p ) const {\n    if( x != p.x ) return x < p.x;\n    return y < p.y;\n  }\n};\n\nbool cmp(const Point &a,const Point &b) {\n  if( a.y != b.y ) return a.y < b.y;\n  return a.x < b.x;\n}\n\nstruct Data {\n  int cur,dir,cost;\n  bool operator < ( const Data &data ) const {\n    if( cost != data.cost ) return cost > data.cost;\n    if( cur != data.cur ) return cur < data.cur;\n    return dir < data.dir;\n  }\n};\n\nvoid compute(deque<Point> &ps) {\n  sort(ALL(ps));\n  if( !( ps[0].x == 1 && ps[0].y == 1 ) ) {\n    ps.push_front((Point){1,1,1});\n  }\n  if( !( ps[(int)ps.size()-1].x == W && ps[(int)ps.size()-1].y == W ) ) {\n    ps.push_back((Point){W,H,1});\n  }\n\n\n  int n = ps.size();\n  deque<Point> vec = ps;\n  vector<vector<int>> edges(n);\n\n\n  rep(i,n) {\n    int ptr = lower_bound(ALL(ps),ps[i]) - ps.begin();\n    if( ptr - 1 >= 0 ) {\n      if( vec[i].x == vec[ptr-1].x ) {\n\tedges[i].push_back(ptr-1);\n      }\n    }\n    if( ptr + 1 <  n ) {\n      if( vec[i].x == vec[ptr+1].x ) {\n\tedges[i].push_back(ptr+1);\n      }\n    }\n  }\n\n  sort(ALL(ps),cmp);\n\n  rep(i,n) {\n    int ptr = lower_bound(ALL(ps),ps[i],cmp) - ps.begin();\n    if( ptr - 1 >= 0 ) {\n      int ID  = lower_bound(ALL(vec),ps[ptr]) - vec.begin();\n      int adj = lower_bound(ALL(vec),ps[ptr-1]) - vec.begin();\n      assert( adj < n );\n      if( vec[ID].y == vec[adj].y ) {\n\tedges[ID].push_back(adj);\n      }\n    }\n    if( ptr + 1 < n ) {\n      int ID  = lower_bound(ALL(vec),ps[ptr]) - vec.begin();\n      int adj = lower_bound(ALL(vec),ps[ptr+1]) - vec.begin();\n      assert( adj < n );\n      if( vec[ID].y == vec[adj].y ) {\n\tedges[ID].push_back(adj);\n      }\n    }\n  }\n\n  rep(i,n) {\n    sort(ALL(edges[i]));\n    edges[i].erase(unique(ALL(edges[i])),edges[i].end());\n  }\n\n  priority_queue<Data> Q;\n  vector<vector<int>> mini(n,vector<int>(2,INT_MAX));\n  mini[0][0] = 0;\n  Q.push((Data){0,0,0});\n  \n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( vec[data.cur].b && mini[data.cur][(data.dir+1)&1] > data.cost + 1 ) {\n      mini[data.cur][(data.dir+1)&1] = data.cost + 1;\n      Q.push((Data){data.cur,(data.dir+1)&1,data.cost+1});\n    }\n    rep(i,(int)edges[data.cur].size()) {\n      int next = edges[data.cur][i];\n      int cost = abs(vec[data.cur].x-vec[next].x + vec[data.cur].y-vec[next].y);\n      if( data.dir ) {\n\tif( vec[next].y == vec[data.cur].y ) {\n\t  if( mini[next][data.dir] > data.cost + cost ) {\n\t    mini[next][data.dir] = data.cost + cost;\n\t    Q.push((Data){next,data.dir,data.cost+cost});\n\t  }\n\t}\n      } else {\n\tif( vec[next].x == vec[data.cur].x ) {\n\t  if( mini[next][data.dir] > data.cost + cost ) {\n\t    mini[next][data.dir] = data.cost + cost;\n\t    Q.push((Data){next,data.dir,data.cost+cost});\n\t  }\n\t}\n      }      \n    }\n  }\n  int ans = min(mini[n-1][0],mini[n-1][1]);\n  if( ans == INT_MAX ) puts(\"-1\");\n  else printf(\"%d\\n\",ans);\n}\n\n\nint main() {\n  scanf(\"%d %d %d\",&W,&H,&N);\n  deque<Point> ps(N);\n  rep(i,N) scanf(\"%d %d\",&ps[i].x,&ps[i].y);\n  compute(ps);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(kar[1-yota][saki]>hog&&res[1-yota][saki]==INF){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long int w, h;\nlong long int inf;\nclass map {\npublic:\n\tlong long int fast;\n\tbool swi;\n\tmap();\n};\nmap::map() :fast(inf), swi(false) {\n\n}\nmap **paper;\nlong long int answer(int, int, long long int, bool);\nint main() {\n\tcin >> w >> h;\n\tinf = w*h*2;\n\tint time;\n\tcin >> time;\n\tint x, y;\n\tpaper = new map*[w + 1];\n\tfor (int i = 1; i <= w; ++i) {\n\t\tpaper[i] = new map[h + 1];\n\t}\n\tfor (int i = 0; i < time; ++i) {\n\t\tcin >> x >> y;\n\t\tpaper[x][y].swi = true;\n\t}\n\tpaper[w][h].swi = true;\n\tlong long int a;\n\tif (paper[1][1].swi) {\n\t\ta = answer(1, 1, 0, true);\n\t\tpaper[1][1].fast = inf;\n\t\ta = min(a, answer(1, 1, 1, false));\n\t}\n\telse {\n\t\ta = answer(1, 1, 0, true);\n\t}\n\tcout << (a == inf ? -1 : a) << endl;\n\treturn 0;\n}\n\nlong long int answer(int x, int y, long long int time, bool vertical) {\n\tif (x == w&&y == h)return time - 1;\n\tif (paper[x][y].fast <= time) {\n\t\treturn inf;\n\t}\n\telse {\n\t\tpaper[x][y].fast = time;\n\t}\n\tlong long int nmin = inf;\n\tlong long int dummy;\n\tif (vertical) {\n\t\tfor (int i = 1; i <= h; ++i) {\n\t\t\tif (paper[x][i].swi) {\n\t\t\t\tdummy = answer(x, i, time + abs(y - i) + 1, !vertical);\n\t\t\t\tnmin = (nmin > dummy) ? dummy : nmin;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 1; i <= w; ++i) {\n\t\t\tif (paper[i][y].swi) {\n\t\t\t\tdummy = answer(i, y, time + abs(x - i) + 1, !vertical);\n\t\t\t\tnmin = (nmin > dummy) ? dummy : nmin;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n#define VI vector<int>\n#define VII vector<VI>\n\nusing namespace std;\n\n\nconst long long INF = 1e18;\n\nstruct edge\n{\n\tint to, tp;\n\tll co;\n\tedge(int t, ll c, int tp):to(t), co(c), tp(tp){}\n\tbool operator<(const edge& e) const {\n\t\treturn co > e.co;\n\t}\n};\n\nint M, N, K;\nll cost[2][200005];\nvector<P> xx[100005], yy[100005];\nvector<edge> G[200005];\nint main() {\n\tcin >> M >> N >> K;\n\trep(i, K) {\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\txx[x].emplace_back(y, i + 1);\n\t\tyy[y].emplace_back(x, i + 1);\n\t}\n\txx[0].emplace_back(0, 0);\n\txx[M - 1].emplace_back(N - 1, K+1);\n\tyy[N - 1].emplace_back(M - 1, K+1);\n\n\tfor (int i = 0; i < M; i++) {\n\t\tsort(xx[i].begin(), xx[i].end());\n\t\tfor (int j = 1; j < xx[i].size(); j++) {\n\t\t\tint v1 = xx[i][j - 1].second, v2 = xx[i][j].second; \n\t\t\tll cost = xx[i][j].first - xx[i][j - 1].first;\n\t\t\tG[v1].emplace_back(v2, cost, 0);\n\t\t\tG[v2].emplace_back(v1, cost, 0);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(yy[i].begin(), yy[i].end());\n\t\tfor (int j = 1; j < yy[i].size(); j++) {\n\t\t\tint v1 = yy[i][j - 1].second, v2 = yy[i][j].second;\n\t\t\tll cost = yy[i][j].first - yy[i][j - 1].first;\n\t\t\tG[v1].emplace_back(v2, cost, 1);\n\t\t\tG[v2].emplace_back(v1, cost, 1);\n\t\t}\n\t}\n\n\trep(i, 2)rep(j, K + 2) cost[i][j] = INF;\n\tcost[0][0] = 0;\n\tpriority_queue<edge> pq;\n\tpq.emplace(0, 0, 0);\n\twhile (!pq.empty())\n\t{\n\t\tedge now = pq.top(); pq.pop();\n\t\tif (cost[now.tp][now.to] < now.co) continue;\n\t\tfor (edge e : G[now.to]) {\n\t\t\tll c = now.co + e.co + (now.tp != e.tp);\n\t\t\tif (cost[e.tp][e.to] > c) {\n\t\t\t\tcost[e.tp][e.to] = c;\n\t\t\t\tpq.emplace(e.to, c, e.tp);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = min(cost[0][K + 1], cost[1][K + 1]);\n\tif (ans == INF) ans = -1;\n\n\tcout << ans << endl;\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nstruct T{\n\tll y,x,id;\n};\nstruct edge{\n\tll to,cost;\n};\nstruct A{\n\tll cost,id,dir;\n\tbool operator<(const A& an)const{\n\t\treturn cost<an.cost;\n\t}\n\tbool operator>(const A& an)const{\n\t\treturn cost>an.cost;\n\t}\n};\nvector<edge> G[200002][2];\nll H,W,N;\nll d[200002][2];//0?????? 1??±?\\?\nT sw[200001];\nconst ll INF = 0xffffffffffffff;\nbool start;\nint main()\n{\n\tcin>>W>>H>>N;\n\trep1(i,N){\n\t\tcin>>sw[i].x>>sw[i].y;\n\t\tif(sw[i].x==W&&sw[i].y==H){\n\t\t\tN--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tif(sw[i].x==1&&sw[i].y==1) {\n\t\t\tstart=1;\n\t\t\tN--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tsw[i].y--;\n\t\tsw[i].x--;\n\t\tsw[i].id=i;\n\t}\n\tsort(sw+1,sw+N+1,[](T a,T b){\n\t\t\treturn a.x==b.x?a.y<b.y:a.x<b.x;\n\t});\n\tif(sw[N].x==W-1){\n\t\tG[sw[N].id][0].pb(edge{N+1,H-1-sw[N].y});\n\t}\n\tif(sw[1].x==0){\n\t\tG[0][0].pb(edge{sw[1].id,sw[1].y});\n\t}\n\trep1(i,N-1){\n\t\tif(sw[i].x==sw[i+1].x){\n\t\t\tG[sw[i].id][0].pb(edge{sw[i+1].id,sw[i+1].y-sw[i].y});\n\t\t\tG[sw[i+1].id][0].pb(edge{sw[i].id,sw[i+1].y-sw[i].y});\n\t\t}\n\t}\n\tsort(sw+1,sw+N+1,[](T a,T b){\n\t\t\treturn a.y==b.y?a.x<b.x:a.y<b.y;\n\t});\n\tif(start&&sw[1].y==0){\n\t\tG[0][1].pb(edge{sw[1].id,sw[1].x});\n\t}\n\tif(sw[N].y==H-1){\n\t\tG[sw[N].id][1].pb(edge{N+1,W-1-sw[N].x});\n\t}\n\trep1(i,N-1){\n\t\tif(sw[i].y==sw[i+1].y){\n\t\t\tG[sw[i].id][1].pb(edge{sw[i+1].id,sw[i+1].x-sw[i].x});\n\t\t\tG[sw[i+1].id][1].pb(edge{sw[i].id,sw[i+1].x-sw[i].x});\n\t\t}\n\t}\n\tN++;//0st Ngoal\n\tfill(d[0],d[200002],INF);\n\td[0][0]=0;\n\tpriority_queue<A,vector<A>,greater<A> > q;\n\tq.push(A{0,0,0});\n\tif(start){\n\t\td[0][1]=1;\n\t\tq.push(A{0,0,1});\n\t}\n\twhile(!q.empty()){\n\t\tA p=q.top();\n\t\tq.pop();\n\t\tll x=p.id;\n\t\tll y=p.dir;\n\t\tif(d[x][y]<p.cost) continue;\n\t\tif(x!=0&&x!=N){\n\t\t\tif(d[x][!y]>d[x][y]+1){\n\t\t\t\td[x][!y]=d[x][y]+1;\n\t\t\t\tq.push(A{d[x][!y],x,!y});\n\t\t\t}\n\t\t}\n\t\trep(i,G[x][y].size()){\n\t\t\tedge e=G[x][y][i];\n\t\t\tif(d[e.to][y]>d[x][y]+e.cost){\n\t\t\t\td[e.to][y]=d[x][y]+e.cost;\n\t\t\t\tq.push(A{d[e.to][y],e.to,y});\n\t\t\t}\n\t\t}\n\t}\n\tif(d[N][0]==INF&&d[N][1]==INF) cout<<\"-1\"<<endl;\n\telse cout<<min(d[N][0],d[N][1])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nlong long inf = ((long long)1 << 63) - 1;\nclass room {\npublic:\n\tint x, y;\n\tlong long fast;\n\troom() : fast(inf) {\n\n\t}\n};\nclass player {\npublic:\n\tlong long time;\n\troom *n;\n\tbool tate;\n\tplayer(room *a, long long c, bool d) :n(a), time(c), tate(d) {\n\n\t}\n};\nbool operator<(const player &a, const player &b) {\n\treturn a.time < b.time;\n}\nbool operator>(const player &a, const player &b) {\n\treturn a.time > b.time;\n}\n\nint main() {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tvector<vector<room*> > tate(M + 1), yoko(N + 1);\n\troom *map;\n\tmap = new room[K + 1];\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> map[i].x >> map[i].y;\n\t\ttate[map[i].x].push_back(&map[i]);\n\t\tyoko[map[i].y].push_back(&map[i]);\n\t}\n\tmap[K].x = M;\n\tmap[K].y = N;\n\ttate[M].push_back(&map[K]);\n\tyoko[N].push_back(&map[K]);\n\tvector<room*>::iterator ps, pe;\n\tpriority_queue<player, vector<player>, greater<player> > que;\n\tfor (ps = tate[1].begin(), pe = tate[1].end(); ps != pe; ++ps) {\n\t\tque.push(player(*ps, (*ps)->y, false));\n\t\t(*ps)->fast = (*ps)->y;\n\t}\n\twhile (!que.empty()) {\n\t\tplayer dummy = que.top(); que.pop();\n\t\tif (dummy.n->x == M&&dummy.n->y == N) {\n\t\t\tcout << dummy.time - 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dummy.time == dummy.n->fast) {\n\t\t\tif (dummy.tate) {\n\t\t\t\tfor (ps = tate[dummy.n->x].begin(), pe = tate[dummy.n->x].end(); ps != pe; ++ps) {\n\t\t\t\t\tlong long nt = dummy.time + abs(dummy.n->y - (*ps)->y) + 1;\n\t\t\t\t\tif ((*ps)->fast > nt) {\n\t\t\t\t\t\tque.push(player(*ps, nt, false));\n\t\t\t\t\t\t(*ps)->fast = nt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (ps = yoko[dummy.n->y].begin(), pe = yoko[dummy.n->y].end(); ps != pe; ++ps) {\n\t\t\t\t\tlong long nt = dummy.time + abs(dummy.n->x - (*ps)->x) + 1;\n\t\t\t\t\tif ((*ps)->fast > nt) {\n\t\t\t\t\t\tque.push(player(*ps, nt, true));\n\t\t\t\t\t\t(*ps)->fast = nt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,pair<int,int> > P;\ntypedef pair<pair<int,int>,bool> PP;\n\nstruct edge{\n\tint to,cost;\n\tbool type;\n};\n\nint k,d[200002];\nconst int inf=1<<30;\nvector<edge> g[200002];\n\nbool operator<(PP p1,PP p2){\n\treturn p1.first.second>p2.first.second;\n}\n\nbool operator>(PP p1,PP p2){\n\treturn p1.first.second<p2.first.second;\n}\n\nvoid dijkstra(void){\n\tpriority_queue<PP> q;\n\td[0]=0;\n\tq.push(PP (pair<int,int> (0,0),true));\n\twhile(!q.empty()){\n\t\tint v=q.top().first.first;\n\t\tbool t=q.top().second;\n\t\tint c=q.top().first.second;\n\t\tq.pop();\n\t\tif(c>=d[v]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<g[v].size();++i){\n\t\t\tint D;\n\t\t\tif(g[v][i].type!=t){\n\t\t\t\tD=g[v][i].cost+c+1;\n\t\t\t}else{\n\t\t\t\tD=g[v][i].cost+c;\n\t\t\t}\n\t\t\tif(D>=d[v]){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\td[v]=D;\n\t\t\t\tq.push(PP (pair<int,int> (v,d[v]),g[v][i].type));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool comp1(P p1,P p2){\n\treturn p1.second.first<p2.second.first;\n}\nbool comp2(P p1,P p2){\n\treturn p1.second.second<p2.second.second;\n}\n\nint main() {\n\tint m,n;\n\tP p[200002];\n\tcin>>m>>n>>k;\n\t++k;++k;\n\tp[0]=P (0,pair<int,int> (1,1));\n\tfor(int i=1;i<k-1;++i){\n\t\tcin>>p[i].second.first;\n\t\tcin>>p[i].second.second;\n\t\tp[i].first=i;\n\t}\n\tp[k-1]=P (k-1,pair<int,int>(m,n));\n\tsort(p,p+k,comp1);\n\tfor(int i=0;i<k;++i){\n\t\tif(p[i].second.first==p[i+1].second.first){\n\t\t\tedge e;\n\t\t\te.to=p[i+1].first;\n\t\t\te.cost=max(p[i+1].second.second-p[i].second.second,p[i].second.second-p[i+1].second.second);\n\t\t\te.type=true;\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tsort(p,p+k,comp2);\n\tfor(int i=1;i<k;++i){\n\t\tif(p[i].second.second==p[i+1].second.second){\n\t\t\tedge e;\n\t\t\te.to=p[i+1].first;\n\t\t\te.cost=max(p[i+1].second.first-p[i].second.first,p[i].second.first-p[i+1].second.first);\n\t\t\te.type=false;\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tfill(d,d+k,inf);\n\tdijkstra();\n\tif(d[k-1]==inf){\n\t\tcout<<-1<<endl;\n\t}else{\n\t\tcout<<d[k-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\tfor (int u : X[0]) {\n\t\td[u][1] = y[u]; d[u][0] = y[u] + 1;\n\t\tque.push({ u,1,d[u][1] });\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1]) {\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t\tMin = min(Min, d[u][0] + 1 + abs(y[u] - n + 1));\n\t}\n\tfor (int u : Y[n - 1]) {\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t\tMin = min(Min, d[u][1] + 1 + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[100010], Y[100010];\nPII pos[200010];\nll d[200010][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 200010){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tpos[i+1] = {x, y};\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tif(s == 0){\n\t\t\tint x_p = pos[v].first;\n\t\t\tREP(i, X[x_p].size()){\n\t\t\t\tint dis = abs(X[x_p][i].first-pos[v].second);\n\t\t\t\tif(d[X[x_p][i].second][s] > d[v][s] + dis){\n\t\t\t\t\td[X[x_p][i].second][s] = d[v][s] + dis;\n\t\t\t\t\td[X[x_p][i].second][(s+1)%2] = min(d[X[x_p][i].second][(s+1)%2], d[X[x_p][i].second][s]+1);\n\t\t\t\t\tpq.push({d[X[x_p][i].second][(s+1)%2], {X[x_p][i].second, (s+1)%2}});\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint y_p = pos[v].second;\n\t\t\tREP(i, Y[y_p].size()){\n\t\t\t\tint dis = abs(Y[y_p][i].first-pos[v].first);\n\t\t\t\tif(d[Y[y_p][i].second][s] > d[v][s] + dis){\n\t\t\t\t\td[Y[y_p][i].second][s] = d[v][s] + dis;\n\t\t\t\t\td[Y[y_p][i].second][(s+1)%2] = min(d[Y[y_p][i].second][(s+1)%2], d[Y[y_p][i].second][s]+1);\n\t\t\t\t\tpq.push({d[Y[y_p][i].second][(s+1)%2], {Y[y_p][i].second, (s+1)%2}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define int long long\n#define INF 1e+18\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nsigned main(){\n\tint m,n,k;\n\tbool start = false;\n\tstatic int d[200002][2];//0:tate 1:yoko\n\tstatic vector<P> G[200002][2];\n\tstatic vector<P> tate[100000],yoko[100000];\n\tcin >> m >> n >> k;\n\tfor(int i = 0;i < k + 2;i++) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tif(a == 1 && b == 1) start = true;\n\t\ttate[b - 1].push_back(P(a - 1,i + 1));\n\t\tyoko[a - 1].push_back(P(b - 1,i + 1));\n\t}\n\ttate[0].push_back(P(0,0));\n\tyoko[0].push_back(P(0,0));\n\ttate[n - 1].push_back(P(m - 1,k + 1));\n\tyoko[m - 1].push_back(P(n - 1,k + 1));\n\tfor(int i = 0;i < n;i++){\n\t\tif(tate[i].size() <= 1) continue;\n\t\tsort(tate[i].begin(),tate[i].end());\n\t\tfor(int j = 0;j < tate[i].size() - 1;j++){\n\t\t\tG[tate[i][j + 1].second][1].push_back(P(tate[i][j + 1].first - tate[i][j].first,tate[i][j].second));\n\t\t\tG[tate[i][j].second][1].push_back(P(tate[i][j + 1].first - tate[i][j].first,tate[i][j + 1].second));\n\t\t}\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(yoko[i].size() <= 1) continue;\n\t\tsort(yoko[i].begin(),yoko[i].end());\n\t\tfor(int j = 0;j < yoko[i].size() - 1;j++){\n\t\t\tG[yoko[i][j + 1].second][0].push_back(P(yoko[i][j + 1].first - yoko[i][j].first,yoko[i][j].second));\n\t\t\tG[yoko[i][j].second][0].push_back(P(yoko[i][j + 1].first - yoko[i][j].first,yoko[i][j + 1].second));\n\t\t}\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,0));\n\td[0][0] = 0;\n\tif(start){\n\t\tque.push(P(1,k + 2));\n\t\td[0][1] = 1;\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint v = p.second % (k + 2),flag = p.second / (k + 2),_flag = (flag + 1) % 2;\n\t\tif(d[v][flag] < p.first) continue;\n\t\tfor(int i = 0;i < G[v][flag].size();i++){\n\t\t\tP u = G[v][flag][i];\n\t\t\tif(d[u.second][flag] > d[v][flag] + u.first){\n\t\t\t\td[u.second][flag] = d[v][flag] + u.first;\n\t\t\t\tque.push(P(d[u.second][flag],u.second + flag * (k + 2)));\n\t\t\t}\n\t\t\tif(d[u.second][_flag] > d[v][flag] + u.first + 1){\n\t\t\t\td[u.second][_flag] = d[v][flag] + u.first + 1;\n\t\t\t\tque.push(P(d[u.second][_flag],u.second + _flag * (k + 2)));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < G[v][_flag].size();i++){\n\t\t\tP u = G[v][_flag][i];\n\t\t\tif(d[u.second][_flag] > d[v][_flag] + u.first){\n\t\t\t\td[u.second][_flag] = d[v][_flag] + u.first;\n\t\t\t\tque.push(P(d[u.second][_flag],u.second + _flag * (k + 2)));\n\t\t\t}\n\t\t\tif(d[u.second][flag] > d[v][_flag] + u.first + 1){\n\t\t\t\td[u.second][flag] = d[v][_flag] + u.first + 1;\n\t\t\t\tque.push(P(d[u.second][flag],u.second + flag * (k + 2)));\n\t\t\t}\n\t\t}\n\t}\n\tif(min(d[k + 1][0],d[k + 1][1]) == INF) cout << -1 << endl;\n\telse cout << min(d[k + 1][0],d[k + 1][1]) << endl;\n\t/*for(int i = 0;i <= k + 1;i++){\n\t\tcout << i << \")\" << endl;\n\t\tfor(int j = 0;j < G[i][0].size();j++){\n\t\t\tcout << G[i][0][j].second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\tfor(int j = 0;j < G[i][1].size();j++){\n\t\t\tcout << G[i][1][j].second << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\npair<pint,int> vx[200005],vy[200005];\nvector<pint> g[400005];\nll d[400005];\nll INF=1000100010001000100;\nint n,m;\nint dijkstra(int st){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    rep(i,200005) d[i]=INF;\n    d[st]=0;\n    pq.push(make_pair(0,st));\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        if(d[t]<pi.first) continue;\n        for(vector<pint>::iterator it=g[t].begin();it!=g[t].end();++it){\n            if(d[it->second]>d[t]+it->first){\n                d[it->second]=d[t]+it->first;\n                pq.push(make_pair(d[it->second],it->second));\n            }\n        }\n    }\n}\nint main(){\n    int k,xi,yi;\n    cin>>m>>n>>k;\n    FOR(i,1,k+1){\n        cin>>xi>>yi;\n        --xi,--yi;\n        vx[i]={{xi,yi},i},vy[i-1]={{yi,xi},k+i+1};\n        g[i].pb(1,k+i+1);g[i+k+1].pb(1,i);\n    }\n    vx[k+1]={{m-1,n-1},k+1},vy[k]={{n-1,m-1},k+k+2};\n    g[k+1].pb(1,k+k+2);g[k+k+2].pb(1,k+1);\n    sort(vx,vx+k+2);\n    sort(vy,vy+k+1);\n    rep(i,k+1){\n        if(vx[i].first.first==vx[i+1].first.first){\n            g[vx[i].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i+1].second);\n            g[vx[i+1].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i].second);\n        }\n    }\n    rep(i,k){\n        if(vy[i].first.first==vy[i+1].first.first){\n            g[vy[i].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i+1].second);\n            g[vy[i+1].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i].second);\n        }\n    }\n    dijkstra(0);\n    ll ans=min(d[k+1],d[k+k+2]);\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = INT_MAX;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\n\n\nvoid dijkstra(){\n\tpriority_queue<PPII, vector<PPII>, greater<PPII> > que;\n\tfill(D, D + 110, INF);\n\tD[0] = 0;\n\tque.push(PPII(0, PII(0, 0)));\n\tque.push(PPII(1, PII(0, 1)));\n\twhile (!que.empty()){\n\t\tPPII p = que.top();\n\t\tque.pop();\n\t\tint v = p.SE.FI;\n\t\tif (D[v]<p.FI)continue;\n\t\tfor (int i = 0; i<fld.size(); i++){\n\t\t\tPII e = fld[i];\n\t\t\tint On = p.SE.SE;\n\t\t\tif ((!On) && fld[v].FI != e.FI)continue;\n\t\t\tif (On && fld[v].SE != e.SE)continue;\n\t\t\tint cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n\t\t\tif (D[i]>D[v] + cost){\n\t\t\t\tD[i] = D[v] + cost;\n\t\t\t\tque.push(PPII(D[i], PII(i, !On)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint cnt = 0;\n\tcin >> M >> N >> K;\n\tfld.PB(PII(1, 1));\n\tfld.PB(PII(M, N));\n\tfor (int i = 0; i < K; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x==M&&y==N)continue;\n\t\tfld.PB(PII(x, y));\n\t}\n\tdijkstra();\n\tif (D[1] >= INF)cout << -1 << endl;\n\telse cout << D[1] - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[200000], Y[200000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c>b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t}\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\tfor (int u : X[0]) {\n\t\td[u][1] = y[u];\n\t\tque.push({ u,1,d[u][1] });\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u])) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]);\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1]>p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0]>p.c + abs(x[p.p] - x[u])) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]);\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1]) {\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t\tMin = min(Min, d[u][0] + 1 + abs(y[u] - n + 1));\n\t}\n\tfor (int u : Y[n - 1]) {\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t\tMin = min(Min, d[u][1] + 1 + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n\ntypedef long long ll;\t\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\n#define MP make_pair\n\t\nint main(){\n\tint m,n,k;\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\tmap<int,vector<pii>> xi;\n\tmap<int,vector<pii>> yi;\n\tint si=k*2,gi=k*2+1;\n\tREP(i,k){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\txi[x].push_back(MP(y,i*2));\n\t\tyi[y].push_back(MP(x,i*2+1));\n\t\tif(x==1&&y==1)\n\t\t\tsi=i*2;\n\t\tif(x==m&&y==n)\n\t\t\tgi=i*2;\n\t}\n\tif(si==k*2)\n\t\txi[1].push_back(MP(1,si));\n\tif(gi==k*2+1){\n\t\txi[m].push_back(MP(n,gi));\n\t\tyi[n].push_back(MP(m,gi+1));\n\t}\n\tstatic vector<pii> graph[500000];\n\tfor(auto& _xs:xi){\n\t\tauto& xs = _xs.second;\n\t\tsort(xs.begin(),xs.end());\n\t\tREP(i,xs.size()-1){\n\t\t\tgraph[xs[i].second].push_back(MP(xs[i+1].first-xs[i].first,xs[i+1].second));\n\t\t\tgraph[xs[i+1].second].push_back(MP(xs[i+1].first-xs[i].first,xs[i].second));\n\t\t}\n\t}\n\tfor(auto& _ys:yi){\n\t\tauto& ys=_ys.second;\n\t\tsort(ys.begin(),ys.end());\n\t\tREP(i,ys.size()-1){\n\t\t\tgraph[ys[i].second].push_back(MP(ys[i+1].first-ys[i].first,ys[i+1].second));\n\t\t\tgraph[ys[i+1].second].push_back(MP(ys[i+1].first-ys[i].first,ys[i].second));\n\t\t}\n\t}\n\tREP(i,k){\n\t\tgraph[i*2].push_back(MP(1,i*2+1));\n\t\tgraph[i*2+1].push_back(MP(1,i*2));\n\t}\n\tpriority_queue<plli,vector<plli>,greater<plli>> pq;\n\tpq.push(MP(0,si));\n\tll ans=-1;\n\tstatic ll nc[500000];\n\tREP(i,k*2+3)\n\t\tnc[i]=1145141919810893LL;\n\twhile(!pq.empty()){\n\t\tplli t=pq.top();\n\t\tpq.pop();\n\t\tif(t.first>nc[t.second])\n\t\t\tcontinue;\n\t\tif(t.second==gi||t.second==gi+1){\n\t\t\tans=t.first;\n\t\t\tbreak;\n\t\t}\n\t\tfor(auto c:graph[t.second])\n\t\t\tif(t.first+c.first<nc[c.second]){\n\t\t\t\tnc[c.second]=t.first+c.first;\n\t\t\t\tpq.push(MP(t.first+c.first,c.second));\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL << 60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_K = 100005;\n\nint d[MAX_K][2], n, m, k;\nvector<ppiii> xy, yx;\nvector<pipii> G[MAX_K][2];\n\nint Dijkstra() {\n    fill(d[0], d[MAX_K], INF);\n    d[k][0] = 0;\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    pq.push({ 0,{ k, 0 } });\n\n    while (pq.size()) {\n        pipii p = pq.top();\n        pq.pop();\n        int v = p.second.first;\n        int st = p.second.second;\n        if (d[v][st] < p.first) continue;\n\n        for (int i = 0; i < G[v][st].size(); ++i) {\n            int tov = G[v][st][i].second.first, tost = G[v][st][i].second.second;\n            if (d[tov][tost] <= p.first + G[v][st][i].first) continue;\n            d[tov][tost] = p.first + G[v][st][i].first;\n            pq.push({ d[tov][tost],{ tov, tost } });\n        }\n    }\n\n    int res = min(d[k + 1][0], d[k + 1][1]);\n    return INF <= res ? -1 : res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> m >> n >> k;\n\n    for (int i = 0; i < k; ++i) {\n        int x, y;\n        cin >> x >> y;\n        xy.PB({ { x, y }, i });\n        yx.PB({ { y, x }, i });\n        G[i][0].PB({ 1,{ i, 1 } });\n        G[i][1].PB({ 1,{ i, 0 } });\n\n        if (x == 1) {\n            G[k][0].PB({ y - 1,{ i, 0 } });\n        }\n        if (x == m) {\n            G[i][0].PB({ n - y,{ k + 1, 0 } });\n        }\n        if (y == n) {\n            G[i][1].PB({ m - x,{ k + 1, 1 } });\n        }\n    }\n    sort(ALL(xy));\n    sort(ALL(yx));\n\n    for (int i = 0; i < k; ++i) {\n        for (int j = i + 1; j < k; ++j) {\n            if (xy[i].first.first != xy[j].first.first) {\n                i = j - 1;\n                break;\n            }\n\n            int cost = xy[j].first.second - xy[j - 1].first.second;\n            int to = xy[j].second, from = xy[j - 1].second;\n            G[from][0].PB({ cost,{ to, 0 } });\n            G[to][0].PB({ cost,{ from, 0 } });\n        }\n    }\n\n    for (int i = 0; i < k; ++i) {\n        for (int j = i + 1; j < k; ++j) {\n            if (yx[i].first.first != yx[j].first.first) {\n                i = j - 1;\n                break;\n            }\n\n            int cost = yx[j].first.second - yx[j - 1].first.second;\n            int to = yx[j].second, from = yx[j - 1].second;\n            G[from][1].PB({ cost,{ to, 1 } });\n            G[to][1].PB({ cost,{ from, 1 } });\n        }\n    }\n\n    cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stdio.h>\n#include<utility>\n\nusing namespace std;\n\n#define MAX_N 10000\n#define MAX_M 10000\n#define INF 1000000\n\ntypedef pair<int, int> coord; //??§?¨?\ntypedef pair<coord, int> P; //??§?¨??????????\n\nbool s[MAX_M][MAX_N];  //????????????????????????????????? \nint M, N, K;\nint d[MAX_M][MAX_N][2]; // ???????????¢, ????????????, ????????±?\\?\n\nint main()\n{\n\tscanf(\"%d %d %d\", &M, &N, &K);\n\t//s[][], d[][][]????????????\n\tfor (int i = 0; i < M ; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ts[i][j] = false;\n\t\t\td[i][j][0] = INF;\n\t\t\td[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ts[x - 1][y - 1] = true;\n\t}\n\n\tqueue<P> que;\n\tque.push(P(coord(0, 0), 0));\n\td[0][0][0] = 0;\n\twhile (que.size()) {\n\t\tP p = que.front(); que.pop();\n\t\tint x = p.first.first;\n\t\tint y = p.first.second;\n\t\tif (p.second = 0) {\n\t\t\tif (s[x][y] == true && d[x][y][1] == INF) {\n\t\t\t\td[x][y][1] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y), 1));\n\t\t\t}\n\t\t\tif (y > 0 && d[x][y - 1][0] == INF) {\n\t\t\t\td[x][y - 1][0] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y - 1), 0));\n\t\t\t}\n\t\t\tif (y < N - 1 && d[x][y + 1][0] == INF) {\n\t\t\t\td[x][y + 1][0] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y + 1), 0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (s[x][y] == true && d[x][y][0] == INF) {\n\t\t\t\td[x][y][0] = d[x][y][1] + 1;\n\t\t\t\tque.push(P(coord(x, y), 0));\n\t\t\t}\n\t\t\tif (x > 0 && d[x - 1][y][1] == INF) {\n\t\t\t\td[x - 1][y][1] = d[x - 1][y][1] + 1;\n\t\t\t\tque.push(P(coord(x - 1, y), 1));\n\t\t\t}\n\t\t\tif (x < M - 1 && d[x + 1][y][1] == INF) {\n\t\t\t\td[x + 1][y][1] = d[x][y][1] + 1;\n\t\t\t\tque.push(P(coord(x + 1, y), 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = d[M - 1][N - 1][0];\n\tif (ans > d[M - 1][N - 1][1]) ans = d[M - 1][N -1][1];\n\tif (ans == INF) ans = -1;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tint d,x,y,di;\n\tnode(){\n\n\t}\n\tnode(int dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg;\n\tset<int>::iterator ite;\n\tint M,N,K,res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\tif(no.x==M&&no.y==N){\n\t\t\tres=no.d-1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t}\n\t\t}\n\t\twhile(!sag.empty()){\n\t\t\tno2=sag.top();sag.pop();\n\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t}\n\t\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass sw {\npublic:\n    int x, y;\n    bool used;\n    sw() :used(false) {\n        \n    }\n};\nclass point {\npublic:\n    long long time;\n    sw *n;\n    bool tate;\n    point(long long a, sw *b, bool c) :time(a), n(b), tate(c) {\n        \n    }\n};\nbool operator<(const point &a, const point &b) {\n    return a.time < b.time;\n}\nbool operator>(const point &a, const point &b) {\n    return a.time > b.time;\n}\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    sw *swi;\n    swi = new sw[K + 1];\n    vector<vector<sw*> > tate(N + 1), yoko(M + 1);\n    for (int i = 0; i < K; ++i) {\n        cin >> swi[i].x >> swi[i].y;\n        tate[swi[i].x].push_back(&swi[i]);\n        yoko[swi[i].y].push_back(&swi[i]);\n    }\n    swi[K].x = N; swi[K].y = M;\n    tate[N].push_back(&swi[K]);\n    yoko[M].push_back(&swi[K]);\n    priority_queue<point, vector<point>, greater<point> > que;\n    for (int i = 0, nmax = (int)tate[1].size(); i < nmax; ++i) {\n        que.push(point(tate[1][i]->y, tate[1][i], false));\n    }\n    while (!que.empty()) {\n        point dummy = que.top(); que.pop();\n        if (dummy.n->x == N&&dummy.n->y == M) {\n            cout << dummy.time - 1 << endl;\n            return 0;\n        }\n        if(dummy.n->used)continue;\n        dummy.n->used = true;\n        if (dummy.tate) {\n            for (int i = 0, nmax = (int)tate[dummy.n->x].size(); i < nmax; ++i) {\n                if (!tate[dummy.n->x][i]->used) {\n                    que.push(point(dummy.time + 1 + abs(tate[dummy.n->x][i]->y - dummy.n->y), tate[dummy.n->x][i], false));\n                }\n            }\n        }\n        else {\n            for (int i = 0, nmax = (int)yoko[dummy.n->y].size(); i < nmax; ++i) {\n                if (!yoko[dummy.n->y][i]->used) {\n                    que.push(point(dummy.time + 1 + abs(yoko[dummy.n->y][i]->x - dummy.n->x), yoko[dummy.n->y][i], true));\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], MP(t, !On)));\n                else que.push(PPII(D[t], MP(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], MP(t, !On)));\n                else que.push(PPII(D[t], MP(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <map>\n#include <vector>\n \n#define MAX_K (200010)\n \ntypedef long long lint;\n \nusing namespace std;\n \nstruct Point {\n\tint x, y, id;\n\tPoint(int x, int y, int id) : x(x), y(y), id(id) {}\n\tPoint() {}\n};\n \nstruct Edge {\n\tint to;\n\tlint cost;\n\tEdge(int to, lint cost) : to(to), cost(cost){}\n\tEdge() {}\n};\n \nbool cmpx(const Point &a, const Point &b)\n{\n\tif (a.x - b.x) return (a.x < b.x);\n\treturn (a.y < b.y);\n}\n \nbool cmpy(const Point &a, const Point &b)\n{\n\tif (a.y - b.y) return (a.y < b.y);\n\treturn (a.x < b.x);\n}\n \nbool operator > (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\t\nvector<Point> Xv, Yv;\nvector<Edge> G[(MAX_K + 2) * 2];\nlint dist[(MAX_K + 2) * 2];\n \nint main()\n{\n\tint M, N, K;\n\t\n\tscanf(\"%d %d %d\", &M, &N, &K);\n\t\n\tXv.push_back(Point(0, 0, 0));\n\tXv.push_back(Point(M - 1, N - 1, 1)); Yv.push_back(Point(M - 1, N - 1, MAX_K + 1));\n\tG[1].push_back(Edge(MAX_K + 1, 1)); G[MAX_K + 1].push_back(Edge(1, 1));\n\tfor (int i = 2; i < K + 2; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t\n\t\tXv.push_back(Point(x - 1, y - 1, i)); Yv.push_back(Point(x - 1, y - 1, MAX_K + i));\n\t\tG[i].push_back(Edge(i + MAX_K, 1));\n\t\tG[MAX_K + i].push_back(Edge(i, 1));\n\t}\n\t\n\tsort(Xv.begin(), Xv.end(), cmpx);\n\tsort(Yv.begin(), Yv.end(), cmpy);\n\t\n\tfor (int i = 0; i < Xv.size() - 1; i++){\n\t\tif (Xv[i].x == Xv[i + 1].x){\n\t\t\tG[Xv[i].id].push_back(Edge(Xv[i + 1].id, abs(Xv[i].y - Xv[i + 1].y)));\n\t\t\tG[Xv[i + 1].id].push_back(Edge(Xv[i].id, abs(Xv[i].y - Xv[i + 1].y)));\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < Yv.size() - 1; i++){\n\t\tif (Yv[i].y == Yv[i + 1].y){\n\t\t\tG[Yv[i].id].push_back(Edge(Yv[i + 1].id, abs(Yv[i].x - Yv[i + 1].x)));\n\t\t\tG[Yv[i + 1].id].push_back(Edge(Yv[i].id, abs(Yv[i].x - Yv[i + 1].x)));\n\t\t}\n\t}\n\t\n\tfill(dist, dist + (MAX_K + 2) * 2, LLONG_MAX);\n\t\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > pq;\n\t\n\tfor (pq.push(Edge(0, 0)); pq.size(); pq.pop()){\n\t\tEdge e = pq.top();\n\t\tif (e.to == 1 || e.to == MAX_K + 1) return (!printf(\"%lld\\n\", e.cost));\n\t\tif (dist[e.to] <= e.cost) continue;\n\t\tdist[e.to] = e.cost;\n\t\t\n\t\tfor (int i = 0; i < G[e.to].size(); i++){\n\t\t\tpq.push(Edge(G[e.to][i].to, e.cost + G[e.to][i].cost));\n\t\t}\n\t}\n\t\n\tprintf(\"-1\\n\");\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nstruct data{\n    int v,c,d;\n    data(int v,int c,int d):v(v),c(c),d(d){}\n    bool operator<(const data &d)const{\n        return c>d.c;\n    }\n};\n\nconst int SIZE=200000;\nconst int INF=1001001001001001001LL;\nint W,H,K;\nint X[SIZE],Y[SIZE];\n\nvpint row[SIZE],col[SIZE];\n\nint to[SIZE][4];\nint cost[SIZE][4];\n\nint dist[SIZE][2];\n\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n\n    cin>>W>>H>>K;\n    rep(i,K){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n        row[Y[i]].pb(pint(X[i],i));\n        col[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(col[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,(int)row[i].size()-1){\n            pint &v=row[i][j],&u=row[i][j+1];\n            to[v.se][3]=u.se;cost[v.se][3]=u.fi-v.fi;\n            to[u.se][1]=v.se;cost[u.se][1]=u.fi-v.fi;\n        }\n    }\n    rep(i,W){\n        rep(j,(int)col[i].size()-1){\n            pint &v=col[i][j],&u=col[i][j+1];\n            to[v.se][2]=u.se;cost[v.se][2]=u.fi-v.fi;\n            to[u.se][0]=v.se;cost[u.se][0]=u.fi-v.fi;\n        }\n    }\n\n    if(col[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n\n    pint start=col[0][0];\n    fill_n(*dist,SIZE*2,INF);\n    dist[start.se][0]=start.fi;\n    priority_queue<data>que;\n    que.push(data(start.se,start.fi,0));\n\n    while(que.size()){\n        data d=que.top();que.pop();\n        if(dist[d.v][d.d]<d.c)continue;\n        if(dist[d.v][1-d.d]>d.c+1){\n            dist[d.v][1-d.d]=d.c+1;\n            que.push(data(d.v,d.c+1,1-d.d));\n        }\n\n        rep(i,4){\n            if(i%2!=d.d)continue;\n            int t=to[d.v][i],c=cost[d.v][i];\n            if(t==-1)continue;\n            if(dist[t][d.d]<=d.c+c)continue;\n            dist[t][d.d]=d.c+c;\n            que.push(data(t,d.c+c,d.d));\n        }\n    }\n\n    int mi=INF;\n\n    rep(i,K){\n        if(X[i]==W-1){\n            chmin(mi,dist[i][0]+H-1-Y[i]);\n        }\n        if(Y[i]==H-1){\n            chmin(mi,dist[i][1]+W-1-X[i]);\n        }\n    }\n\n    cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000], lenx[100000], leny[100000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, m)X[i].resize(n);\n\trep(i, n)Y[i].resize(m);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]][lenx[x[i]]++] = i; Y[y[i]][leny[y[i]]++] = i;\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tif (clock() > 1000)abort();\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\trep(i, lenx[x[p.p]]) {\n\t\t\tint u = X[x[p.p]][i];\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\trep(i, leny[y[p.p]]) {\n\t\t\tint u = Y[y[p.p]][i];\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, lenx[m - 1]) {\n\t\tint u = X[m - 1][i];\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t}\n\trep(i, leny[n - 1]) {\n\t\tint u = Y[n - 1][i];\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n \ntypedef long long ll;\nusing namespace std;\n \n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n \n#define SIZE 200010\n \nstruct SW_ROOM{\n    int x;\n    int y;\n    int num;\n    \n    SW_ROOM(int a=0,int b=0,int c=0)\n    :x(a),y(b),num(c){}\n};\n \nbool comp_xy(SW_ROOM a,SW_ROOM b){\n    return a.x==b.x ? a.y < b.y : a.x < b.x;\n}\nbool comp_yx(SW_ROOM a,SW_ROOM b){\n    return a.y==b.y ? a.x < b.x : a.y < b.y;\n}\n \n//(1,1) -> (M,N)\n \nint m,n,k,x,y;\nvector<pair<int,int> > way[SIZE*2];\npriority_queue<pair<ll,int> > pq;\nbool visit[SIZE*2] = {0};\n \nint main(){\n    \n    vector<SW_ROOM> sw;\n    \n    scanf(\"%d%d%d\",&m,&n,&k);\n    \n    bool flag = false;\n    \n    for(int i=1;i<=k;i++){\n        scanf(\"%d%d\",&x,&y);\n        if(x==1 && y==1){\n            flag = true;\n            continue;\n        }\n        if(x==m && y==n){\n            continue;\n        }\n        \n        sw.push_back(SW_ROOM(x,y,i));\n        way[i*2].push_back({i*2+1,1}); //SN\n        way[i*2+1].push_back({i*2,1}); //WE\n    }\n    \n    sw.push_back(SW_ROOM(1,1,0));\n    \n    if(flag){\n        way[0].push_back({1,1}); //SN\n        way[1].push_back({0,1}); //WE\n    }\n    \n    sw.push_back(SW_ROOM(m,n,k+1));\n    \n    \n    sort(sw.begin(),sw.end(),comp_xy);\n    \n    for(int i=0;i<sw.size();i++){\n        \n        while(i<sw.size()-1 && sw[i].x == sw[i+1].x){\n            int room1 = sw[i].num * 2;\n            int room2 = sw[i+1].num * 2;\n            int dis = sw[i+1].y - sw[i].y;\n            \n            way[room1].push_back({room2,dis}); //SN\n            way[room2].push_back({room1,dis}); //WE\n            \n            i++;\n        }\n        \n    }\n    \n    sort(sw.begin(),sw.end(),comp_yx);\n    \n    for(int i=0;i<sw.size();i++){\n        \n        while(i<sw.size()-1 && sw[i].y == sw[i+1].y){\n            int room1 = sw[i].num * 2 +1;\n            int room2 = sw[i+1].num * 2 +1;\n            int dis = sw[i+1].x - sw[i].x;\n            \n            way[room1].push_back({room2,dis}); //SN\n            way[room2].push_back({room1,dis}); //WE\n            \n            i++;\n        }\n    }\n    \n    //dijkstra\n    \n    \n    \n    pq.push({0,0});\n    \n    while(pq.size()){\n        pair<ll,int> p = pq.top();\n        pq.pop();\n        \n        int room = p.second;\n        ll cost = p.first;\n        \n        if(visit[room]) continue;\n        visit[room] = true;\n        \n        if(room == (k+1)*2 || room == (k+1)*2+1){\n            printf(\"%lld\\n\",-cost);\n            return 0;\n        }\n        \n        for(int i=0;i<way[room].size();i++){\n            pq.push({cost-way[room][i].second,way[room][i].first});\n        }\n        \n    }\n    \n    puts(\"-1\");\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nstruct edge{\n  ll to,cost;\n  edge(ll t,ll c){\n    to=t,cost=c;\n  }\n};\nstruct state{\n  ll pos,flg,cost;\n  state(ll p,ll f,ll c){\n    pos=p,flg=f,cost=c;\n  }\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nvector<P> t[MAX][2];\nll W,H,K,X[MAX],Y[MAX];\nll d[MAX][2];\nvector<edge> G[MAX][2];\n \nll solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=10000000000000000LL;\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( state( p.second, 0, p.first-1 ) );\n  d[p.second][0]=p.first-1;\n   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        ll ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push( state(e.to,nf,ncost) );\n        }\n      }\n    }\n  }\n  ll res=min(d[K][0],d[K][1]);\n  if(res==10000000000000000LL)return -1;\n  else return res;\n}\n       \nint main(){\n  scanf(\"%lld %lld %lld\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%lld %lld\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( edge(q.second,p.first-q.first) );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( edge(q.second,q.first-p.first) );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <functional>\nstruct Node{\npublic:\n\tstd::vector<std::tuple<int, Node*>> edges{};\n\tint minCost{ INT_MAX };\n\tint x{ 0 }, y{ 0 };\n};\nstruct MinCost {\n\tint cost, heuristic;\n\tNode *node;\n\tbool operator>(const MinCost &other) const { return (cost + heuristic) > (other.cost + other.heuristic); }\n\tbool operator<(const MinCost &other) const { return (cost + heuristic) < (other.cost + other.heuristic); }\n};\nint main() {\n\tint m, n, k;\n\tstd::cin >> m >> n >> k;\n\tstd::vector<Node> nodes(k * 2);\n\tstd::vector<std::vector<Node*>> orderedByX(m + 1, std::vector<Node*>());\n\tstd::vector<std::vector<Node*>> orderedByY(n + 1, std::vector<Node*>());\n\tfor (auto i = 0; i < k; ++i) {\n\t\tstd::cin >> nodes[i * 2].x >> nodes[i * 2].y;\n\t\tnodes[i * 2 + 1].x = nodes[i * 2].x;\n\t\tnodes[i * 2 + 1].y = nodes[i * 2].y;\n\t\tnodes[i * 2].edges.push_back(std::make_tuple(1, &nodes[i * 2 + 1]));\n\t\tnodes[i * 2 + 1].edges.push_back(std::make_tuple(1, &nodes[i * 2]));\n\t\torderedByX[nodes[i * 2].x].push_back(&nodes[i * 2]);\n\t\torderedByY[nodes[i * 2 + 1].y].push_back(&nodes[i * 2 + 1]);\n\t}\n\tfor (auto i = 1; i < orderedByX.size(); ++i) {\n\t\tstd::sort(orderedByX[i].begin(), orderedByX[i].end(), [](const Node* a, const Node* b)->bool {return a->y < b->y; });\n\t}\n\tfor (auto i = 1; i < orderedByY.size(); ++i) {\n\t\tstd::sort(orderedByY[i].begin(), orderedByY[i].end(), [](const Node* a, const Node* b)->bool {return a->x < b->x; });\n\t}\n\tfor (auto &node : orderedByX) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i - 1]));\n\t\t}\n\t}\n\tfor (auto &node : orderedByY) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i - 1]));\n\t\t}\n\t}\n\tauto queue = std::priority_queue<MinCost>();\n\tif (orderedByX[1].size() == 0) {\n\t\tstd::cout << -1 << std::endl; return 0;\n\t}\n\torderedByX[1][0]->minCost = orderedByX[1][0]->y - 1;\n\tqueue.push(MinCost{ orderedByX[1][0]->minCost , m + n - 2, orderedByX[1][0] });\n\twhile (!queue.empty()) {\n\t\tauto top = queue.top(); queue.pop();\n\t\tif (top.cost == top.node->minCost) {\n\t\t\tfor (auto edge : top.node->edges) {\n\t\t\t\tif (std::get<1>(edge)->minCost > top.cost + std::get<0>(edge)) {\n\t\t\t\t\tstd::get<1>(edge)->minCost = top.cost + std::get<0>(edge);\n\t\t\t\t\tqueue.push(MinCost{ std::get<1>(edge)->minCost, m + n - std::get<1>(edge)->y - std::get<1>(edge)->x,std::get<1>(edge) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = INT_MAX;\n\tif (orderedByX[m].size() != 0 && orderedByX[m].back()->minCost != INT_MAX) {\n\t\tif (min > orderedByX[m].back()->minCost - orderedByX[m].back()->y + n)\n\t\t\tmin = orderedByX[m].back()->minCost - orderedByX[m].back()->y + n;\n\t}\n\tif (orderedByY[n].size() != 0 && orderedByY[n].back()->minCost != INT_MAX) {\n\t\tif (min > orderedByY[n].back()->minCost - orderedByY[n].back()->x + m)\n\t\t\tmin = orderedByY[n].back()->minCost - orderedByY[n].back()->x + m;\n\t}\n\tif (min == INT_MAX) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << min << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tpriority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???????????????????????????\n\t\tint nr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint nc = lower_bound(sc[r].begin(), sc[r].end(), r) - sc[r].begin();\n\t\tif( 0 <= nr && nr < sr[c].size() && 0 <= nc && nc < sc[r].size() ){\n\t\t\tnr = sr[c][nr];\n\t\t\tnc = sc[r][nc];\n\t\t\tif( nr == r && nc == c ){\n\t\t\t\tque.push(T(cst + 1, !dir, r, c));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin() - 1;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin() - 1;\n\t\t\n\t\tif( 0 <= pr && pr < sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\tif( 0 <= pc && pc < sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t}\n\t//??´??????????¨????????????????\n\tsc[h-1].push_back(w-1);\n\tsc[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra();\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\nconst int N = 2e5L + 11;\nusing ll = long long;\nconst ll inf = 1e18L;\n\nint x[N], y[N];\nvector <int> vx[N], vy[N];\nint atx[N], aty[N];\nll dis[N][2];\nstruct node {\n\tll dis; int k1, k2;\n\tbool operator <(node r) const {\n\t\treturn tie(dis, k1, k2) < tie(r.dis, r.k1, r.k2);\n\t}\n};\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x[i] >> y[i];\n\tx[0] = y[0] = 1;\n\tx[n + 1] = w; y[n + 1] = h;\n\n\tfor(int i = 0; i <= n + 1; i ++) {\n\t\tvx[x[i]].pb(i);\n\t\tvy[y[i]].pb(i);\n\t}\n\tfor(int i = 0; i < N; i ++) {\n\t\tsort(vx[i].begin(), vx[i].end(), [&](int i, int j){ return y[i] < y[j]; });\n\t\tsort(vy[i].begin(), vy[i].end(), [&](int i, int j){ return x[i] < x[j]; });\n\t\tfor(int j = 0; j < vx[i].size(); j ++) atx[vx[i][j]] = j;\n\t\tfor(int j = 0; j < vy[i].size(); j ++) aty[vy[i][j]] = j;\n\t}\n\n\tfor(int i = 0; i <= n + 1; i ++)\n\t\tfor(int j : {0, 1}) dis[i][j] = inf;\n\tdis[0][0] = 0;\n\tset <node> st;\n\tfor(int i = 0; i <= n + 1; i ++)\n\t\tfor(int j : {0, 1}) st.insert({dis[i][j], i, j});\n\n\tauto upd = [&](int k1, int k2, ll w) {\n\t\tif(dis[k1][k2] > w) {\n\t\t\tst.erase({dis[k1][k2], k1, k2});\n\t\t\tdis[k1][k2] = w;\n\t\t\tst.insert({dis[k1][k2], k1, k2});\n\t\t}\n\t};\n\tauto f = [&](int i, int j) {\n\t\treturn abs(x[i] - x[j]) + abs(y[i] - y[j]);\n\t};\n\tauto solve = [&](vector <int> &v, int k1, int k2) {\n\t\tint i = (k2 == 0) ? atx[k1] : aty[k1];\n\t\tif(i > 0) upd(v[i - 1], k2, f(v[i], v[i - 1]) + dis[k1][k2]);\n\t\tif(i + 1 < v.size()) upd(v[i + 1], k2, f(v[i], v[i + 1]) + dis[k1][k2]);\n\t};\n\twhile(!st.empty()) {\n\t\tnode i = *st.begin(); st.erase(st.begin());\n\t\t//cout << i.dis << ' ' << i.k1 << ' ' << i.k2 << '\\n';\n\t\tif(i.k1 >= 1 && i.k1 <= n) upd(i.k1, i.k2 ^ 1, i.dis + 1);\n\t\tif(i.k2 == 0) solve(vx[x[i.k1]], i.k1, i.k2);\n\t\tif(i.k2 == 1) solve(vy[y[i.k1]], i.k1, i.k2);\n\t}\n\tll ans = min(dis[n + 1][0], dis[n + 1][1]);\n\tcout << ((ans == inf) ? -1 : ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, bool> PI;\n\nint w, h, k;\nvector<P> X[200005], Y[200005];\nvector<P> xy(200005);\n// map<int, vector<int> > X;\n// map<int, vector<int> > Y;\nmap<pair<int, int>, int > id;\n// map<int, pair<int,int> > xy;\nll d[200005][2];\n\n// PI f(int a, int b, int c) {\n// \treturn mp(mp(a, b), c);\n// }\n\nvoid dijkstra() {\n\trep(i, 200005) {\n\t\td[i][0] = INF;\n\t\td[i][1] = INF;\n\t}\n\n\t// cost id (0 or 1)\n\tpriority_queue<PI, vector<PI>, greater<PI> > que;\n\n\trep(i, X[1].size()) {\n\t\tint y = X[1][i].first;\n\t\tint to = X[1][i].second;\n\t\t// int to = id[mp(y, 1)];\n\n\t\td[to][1] = y;\n\t\t// que.push(f(y, to, 1));\n\t\tque.push(mp(mp(y, to), 1));\n\t}\n\n\twhile(que.size()) {\n\t\tPI p = que.top(); \n\t\tque.pop();\n\n\t\tint c = p.first.first;\n\t\tint v = p.first.second;\n\t\tint state = p.second;\n\n\t\tif(d[v][state] < c) continue;\n\n\t\tint y = xy[v].first;\n\t\tint x = xy[v].second;\n\n\t\t// cout << \" ------ : (\" << y << \",\" << x << \",\" << state << \") :\" << v << \" \" << c << endl;\n\n\t\tif(state == 0) {\n\t\t\trep(i, X[x].size()) {\n\t\t\t\tint ny = X[x][i].first;\n\t\t\t\tint to = X[x][i].second;\n\t\t\t\t// int to = id[mp(ny, x)];\n\n\t\t\t\tif(ny == y) continue;\n\n\t\t\t\tif(d[to][1] > d[v][state] + abs(ny - y) + 1) {\n\t\t\t\t\td[to][1] = d[v][state] + abs(ny- y) + 1;\n\t\t\t\t\t// que.push(f(d[to][1], to, 1));\n\t\t\t\t\tque.push(mp(mp(d[to][1], to), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trep(i, Y[y].size()) {\n\t\t\t\tint nx = Y[y][i].first;\n\t\t\t\tint to = Y[y][i].second;\n\t\t\t\t// int to = id[mp(y, Y[y][i])];\n\n\t\t\t\tif(nx == x) continue;\n\n\t\t\t\tif(d[to][0] > d[v][state] + abs(nx - x) + 1) {\n\t\t\t\t\td[to][0] = d[v][state] + abs(nx - x) + 1;\n\t\t\t\t\t// que.push(f(d[to][0], to, 0));\n\t\t\t\t\tque.push(mp(mp(d[to][0], to), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> w >> h >> k;\n\n\trep(i, k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tid[mp(y, x)] = i;\n\t\txy[i] = mp(y, x);\n\t\tX[x].push_back(mp(y, i));\n\t\tY[y].push_back(mp(x, i));\n\t}\n\n\tdijkstra();\n\n\t// rep(i, k) {\n\t// \tcout << \"k:\" << i << \" (\" << xy[i].first << \",\" << xy[i].second << \") :\" << d[i][0] << \" : \" << d[i][1] << endl;\n\t// }\n\n\tll ans = INF;\n\trep(i, k) {\n\t\tint y = xy[i].first;\n\t\tint x = xy[i].second;\n\n\t\tif(y == h) {\n\t\t\tans = min(ans, d[i][1] + abs(w - x));\n\t\t}\n\n\t\tif(x == w) {\n\t\t\tans = min(ans, d[i][0] + abs(h - y));\n\t\t}\n\t}\n\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n  \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    rep(i,m)X[i].resize(200);\n    rep(i,n)Y[i].resize(200);\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n        if(x[i]==0){\n\t\t\td[i][1]=y[i];\n\t\t\tque.push({i,1,d[i][1]});\n\t\t}\n    }\n    ll Min=INF;\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(x[p.p]==m-1){\n\t\t\tMin=min(Min,d[p.p][1]+abs(y[p.p]-n+1));\n\t\t\tMin=min(Min,d[p.p][0]+1+abs(y[p.p]-n+1));\n\t\t}\n\t\tif(y[p.p]==n-1){\n\t\t\tMin=min(Min,d[p.p][0]+abs(x[p.p]-m+1));\n\t\t\tMin=min(Min,d[p.p][1]+1+abs(x[p.p]-m+1));\n\t\t}\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    int M,N,K;\n    cin >> M >> N >> K;\n    vector<pair<int,int> > XY[100001], YX[100001], p;\n    vector<LL> c[2];\n    p.push_back(MP(1, 1));\n    XY[1].push_back(MP(1, 0));\n    YX[1].push_back(MP(1, 0));\n    c[0].push_back(0);\n    c[1].push_back(LL_MAX);\n    for(int i=1; i<=K; i++){\n        int x,y;\n        cin >> x >> y;\n        p.push_back(MP(x, y));\n        XY[x].push_back(MP(y, i));\n        YX[y].push_back(MP(x, i));\n        c[0].push_back(LL_MAX);\n        c[1].push_back(LL_MAX);\n    }\n    p.push_back(MP(M, N));\n    XY[M].push_back(MP(N, K+1));\n    YX[N].push_back(MP(M, K+1));\n    c[0].push_back(LL_MAX);\n    c[1].push_back(LL_MAX);\n    for(int i=1; i<=M; i++) sort(XY[i].begin(), XY[i].end());\n    for(int i=1; i<=N; i++) sort(YX[i].begin(), YX[i].end());\n\n    priority_queue<pair<LL, pair<int, int> > > que;\n    que.push(MP(LL_MAX, MP(0, 0)));\n    while(!que.empty()){\n        int now = que.top().second.first;\n        int state = que.top().second.second;\n        //cout << now << \" \" << state << \" \" << LL_MAX-que.top().first << endl;\n        que.pop();\n\n        if(now != 0 && now != K+1 && c[(state+1)%2][now] > c[state][now]+1){\n            c[(state+1)%2][now] = c[state][now]+1;\n            que.push(MP(LL_MAX-c[(state+1)%2][now], MP(now, (state+1)%2)));\n        }\n        if(state == 0){\n            auto itr = lower_bound(XY[p[now].first].begin(), XY[p[now].first].end(), MP(p[now].second, now));\n            //cout << itr-XY[p[now].first].begin() << endl;\n            //if(itr != XY[p[now].first].begin()) cout << c[state][(itr-1)->second] << \" \" << c[state][now] + abs(p[now].second-((itr-1)->first)) << endl;\n            if(itr != XY[p[now].first].begin() && c[state][(itr-1)->second] > c[state][now] + abs(p[now].second-((itr-1)->first))){\n                c[state][(itr-1)->second] = c[state][now] + abs(p[now].second-((itr-1)->first));\n                que.push(MP(LL_MAX-c[state][(itr-1)->second], MP((itr-1)->second, state)));\n            }\n            //if(itr != XY[p[now].first].end()-1) cout << c[state][(itr+1)->second] << \" \" << c[state][now] + abs(p[now].second-((itr+1)->first)) << endl;\n            if(itr != XY[p[now].first].end()-1 && c[state][(itr+1)->second] > c[state][now] + abs(p[now].second-((itr+1)->first))){\n                c[state][(itr+1)->second] = c[state][now] + abs(p[now].second-((itr+1)->first));\n                que.push(MP(LL_MAX-c[state][(itr+1)->second], MP((itr+1)->second, state)));\n            }\n        }\n        else{\n            auto itr = lower_bound(YX[p[now].second].begin(), YX[p[now].second].end(), MP(p[now].first, now));\n            if(itr != YX[p[now].second].begin() && c[state][(itr-1)->second] > c[state][now] + abs(p[now].first-((itr-1)->first))){\n                c[state][(itr-1)->second] = c[state][now] + abs(p[now].first-((itr-1)->first));\n                que.push(MP(LL_MAX-c[state][(itr-1)->second], MP((itr-1)->second, state)));\n            }\n            if(itr != YX[p[now].second].end()-1 && c[state][(itr+1)->second] > c[state][now] + abs(p[now].first-((itr+1)->first))){\n                c[state][(itr+1)->second] = c[state][now] + abs(p[now].first-((itr+1)->first));\n                que.push(MP(LL_MAX-c[state][(itr+1)->second], MP((itr+1)->second, state)));\n            }\n        }\n        \n    }\n    \n    if(min(c[0][K+1], c[1][K+1]) == LL_MAX) cout << -1 << endl;\n    else cout << min(c[0][K+1], c[1][K+1]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64, int > Pi;\nconst int64 INF = 1LL << 60;\nstruct edge {\n  int to, cost;\n};\nvector< edge > graph[400004];\nint64 min_cost[400004];\nint H, W, K;\nvector< Pi > X[100001], Y[100001];\n \nint64 Dijkstra()\n{\n  fill_n(min_cost, 400004, INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > Que;\n  min_cost[K - 2] = 0;\n  Que.push(Pi(0, K - 2));\n  while(!Que.empty()) {\n    Pi p = Que.top(); Que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    if(p.second == K - 1) return(p.first);\n    for(auto e : graph[p.second]) {\n      int64 next = p.first + e.cost;\n      if(min_cost[e.to] > next) {\n        min_cost[e.to] = next;\n        Que.push(Pi(next, e.to));\n      }\n    }\n  }\n  return(-1);\n}\n \n \nint main()\n{\n  cin >> W >> H >> K;\n  for(int i = 0; i < K; i++) {\n    int x, y;\n    cin >> x >> y;\n    X[x].push_back(Pi(y, i));\n    Y[y].push_back(Pi(x, i));\n  }\n \n  X[1].push_back(Pi(1, K));\n  Y[1].push_back(Pi(1, K));\n \n  X[W].push_back(Pi(H, K + 1));\n  Y[H].push_back(Pi(W, K + 1));\n \n  K += 2;\n \n  for(int i = 0; i < 100001; i++) {\n    sort(X[i].begin(), X[i].end());\n    sort(Y[i].begin(), Y[i].end());\n    for(int j = 1; j < X[i].size(); ++j) {\n      const Pi &prev = X[i][j - 1], &curr = X[i][j];\n      graph[prev.second].push_back((edge){curr.second, curr.first - prev.first});\n      graph[curr.second].push_back((edge){prev.second, curr.first - prev.first});\n    }\n    for(int j = 1; j < Y[i].size(); ++j) {\n      const Pi &prev = Y[i][j - 1], &curr = Y[i][j];\n      graph[prev.second + K].push_back((edge){curr.second + K, curr.first - prev.first});\n      graph[curr.second + K].push_back((edge){prev.second + K, curr.first - prev.first});\n    }\n  }\n \n \n  for(int i = 0; i < K - 2; i++) {\n    graph[i].push_back((edge){i + K, 1});\n    graph[i + K].push_back((edge){i, 1});\n  }\n  graph[K - 1 + K].push_back((edge){K - 1, 0});  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx,ky;\nint main(){\n\t//cout<<\"WA\"<<endl;//\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n#define fi first\n#define se second\nconst int inf = 1e18;\ntypedef pair<int,int> P;\n\nvector<P> x[200001], y[200001], G[400010];\npriority_queue<P, vector<P>, greater<P> > q;\nint d[400010];\n\nsigned main(){\n\tint w, h, n;\n\tfill(d, d+400010, inf);\n\tscanf(\"%lld%lld%lld\", &w, &h, &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint yy, xx;\n\t\tscanf(\"%lld%lld\", &xx, &yy);\n\t\tx[xx].push_back(P(yy, i));\n\t\ty[yy].push_back(P(xx, i));\n\t}\n\tx[1].push_back(P(1, 0));\n\tx[w].push_back(P(h, n+1));\n\ty[h].push_back(P(w, n+1));\n\tn++;\n\t\n\tfor(int i = 1;i <= w;i++){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j = 1;j < x[i].size();j++){\n\t\t\tint from = x[i][j-1].se, to = x[i][j].se;\n\t\t\tint cost = x[i][j].fi-x[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t\tfor(int j = 1;j < y[i].size();j++){\n\t\t\tint from = y[i][j-1].se+n, to = y[i][j].se+n;\n\t\t\tint cost = y[i][j].fi-y[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= n-1;i++){\n\t\tG[i].push_back(P(i+n, 1));\n\t\tG[i+n].push_back(P(i, 1));\n\t}\n\t\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i].fi;\n\t\t\tint cost = G[from][i].se;\n\t\t\tif(d[from]+cost < d[to]){\n\t\t\t\td[to] = d[from]+cost;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = min(d[n], d[2*n]);\n\tif(ans == inf)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_K 20050\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nint n, m, k;\nint x[MAX_K], y[MAX_K];\n\nint dst[2][MAX_K];\nint e_cnt[2][MAX_K] = { 0 };\nEdge edge[2][MAX_K][4];\n\nint ans = -1;\nint live_start = -1, live_goal = -1;\n\nmain() {\n\n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        } \n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num][e_cnt[0][tate[i - 1].num]++] = (Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp };\n                edge[0][tate[i].num][e_cnt[0][tate[i].num]++] = (Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp };\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num][e_cnt[1][yoko[i - 1].num]++] = (Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp };\n                edge[1][yoko[i].num][e_cnt[1][yoko[i].num]++] = (Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp };\n            }\n        }\n    }\n   \n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    /*\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF; \n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n#define fi first\n#define se second\nconst int inf = 1e9;\ntypedef pair<int,int> P;\n\nvector<P> x[100001], y[100001], G[400010];\npriority_queue<P, vector<P>, greater<P> > q;\nint d[400010];\nsigned main(){\n\tint w, h, n;\n\tfill(d, d+400010, inf);\n\tscanf(\"%lld%lld%lld\", &w, &h, &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint yy, xx;\n\t\tscanf(\"%lld%lld\", &xx, &yy);\n\t\tx[xx].push_back(P(yy, i));\n\t\ty[yy].push_back(P(xx, i));\n\t}\n\tx[1].push_back(P(1, 0));\n\tx[w].push_back(P(h, n+1));\n\ty[h].push_back(P(w, n+1));\n\tn++;\n\t\n\tfor(int i = 1;i <= w;i++){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j = 1;j < x[i].size();j++){\n\t\t\tint from = x[i][j-1].se, to = x[i][j].se;\n\t\t\tint cost = x[i][j].fi-x[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= h;i++){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j = 1;j < y[i].size();j++){\n\t\t\tint from = y[i][j-1].se+n, to = y[i][j].se+n;\n\t\t\tint cost = y[i][j].fi-y[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= n-1;i++){\n\t\tG[i].push_back(P(i+n, 1));\n\t\tG[i+n].push_back(P(i, 1));\n\t}\n\t\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i].fi;\n\t\t\tint cost = G[from][i].se;\n\t\t\tif(d[from]+cost < d[to]){\n\t\t\t\td[to] = d[from]+cost;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*printf(\"\\n\");\n\tfor(int i = 0;i < 10;i++){\n\t\tfor(int j = 0;j < G[i].size();j++)\n\t\tprintf(\"%d %d %d\\n\", i, G[i][j].fi, G[i][j].se);\n\t}*/\n\t\n\tint ans = min(d[n], d[2*n]);\n\tif(ans == inf)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\t//printf(\"%d\\n\", n);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tint hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(res[1-yota][saki]==INF&&kar[1-yota][saki]>hog){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tif(cnt>K-100) break;\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nusing ll = long long;\n\nll m, n, k;\n\n#define Input(x) scanf(\"%lld\",&(x))\n\nstruct coord\n{\n\tll x, y;\n};\nvector<coord>button;\nstruct edge\n{\n\tll to, cost;\n};\nvector<edge>graph[456789];\nll dist[456789];\nvoid addedge(int a,int b,int cost)\n{\n\tgraph[a].push_back({ b,cost });\n\tgraph[b].push_back({ a,cost });\n}\nvoid dijkstra(int start)\n{\n\tusing P = pair<ll, int>;\n\tpriority_queue<P, vector<P>, greater<P>>que;//first:dist second:vertnum\n\tque.push({ 0,start });\n\tfill(dist, dist + 456789, 12345678901234567);\n\tdist[start] = 0;\n\twhile (!que.empty())\n\t{\n\t\tP nowp = que.top(); que.pop();\n\t\tif (nowp.first > dist[nowp.second])continue;\n\t\tfor (edge e : graph[nowp.second])\n\t\t{\n\t\t\tif (dist[e.to] > nowp.first + e.cost)\n\t\t\t{\n\t\t\t\tdist[e.to] = nowp.first + e.cost;\n\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nmap<ll, int>dict;\nvector < ll > idlist;\nll trans(coord c)\n{\n\treturn c.x * 100000 + c.y;\n}\nvoid push_button(coord c)\n{\n\tll id = trans(c);\n\tdict.insert({id,idlist.size()});\n\tidlist.push_back(id);\n}\n\nint main(void)\n{\n\tInput(m);\n\tInput(n);\n\tInput(k);\n\tbool startbut = false;\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tcoord tmp;\n\t\tInput(tmp.x);\n\t\tInput(tmp.y);\n\t\tbutton.push_back(tmp);\n\t\tif (tmp.x == 1 && tmp.y == 1)startbut = true;\n\t\tpush_button(tmp);\n\t\tint v = dict[trans(tmp)] * 2;\n\t\taddedge(v, v + 1, 1);\n\t}\n\tif (!startbut)\n\t{\n\t\tbutton.push_back({ 1,1 });\n\t\tpush_button({ 1,1 });\n\t}\n\tsort(button.begin(), button.end(), [](const coord&c1, const coord&c2) {return (c1.x == c2.x) ? (c1.y < c2.y) : (c1.x < c2.x); });\n\tif (button.back().x != m || button.back().y != n)\n\t{\n\t\tbutton.push_back({ m,n });\n\t\tpush_button({ m,n });\n\t}\n\tfor (int i = 0; i < button.size() - 1; ++i)\n\t{\n\t\tif (button[i].x == button[i + 1].x)\n\t\t{\n\t\t\taddedge(dict[trans(button[i])] * 2, dict[trans(button[i + 1])] * 2, button[i + 1].y - button[i].y);\n\t\t}\n\t}\n\tsort(button.begin(), button.end(), [](const coord&c1, const coord&c2) {return (c1.y == c2.y) ? (c1.x < c2.x) : (c1.y < c2.y); });\n\tfor (int i = 0; i < button.size() - 1; ++i)\n\t{\n\t\tif (button[i].y == button[i + 1].y)\n\t\t{\n\t\t\taddedge(dict[trans(button[i])] * 2 + 1, dict[trans(button[i + 1])] * 2 + 1, button[i + 1].x - button[i].x);\n\t\t}\n\t}\n\tdijkstra(dict[trans({ 1,1 })] * 2);\n\tll answer = min(dist[dict[trans({ m,n })] * 2], dist[dict[trans({ m,n })] * 2 + 1]);\n\tif (answer >= 12345678901234567)return 0 * printf(\"-1\\n\");\n\tprintf(\"%lld\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=100000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(Y[*i]-y)+1+dfs(*i,0));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(X[*i]-x)+1+dfs(*i,1));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,Y[*i]+1+dfs(*i,0));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",&X[i],&Y[i]);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1e18)\n\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> P2; // dist & (from_direction , now)\n\nint main() {\n    long long M,N,K;\n    cin >> M >> N >> K;\n    \n    vector<P> s[2];\n    s[0].push_back(P(1,0));\n    s[1].push_back(P(1,0));\n\n    for(int i=1; i<=K; ++i) {\n        long long a,b;\n        cin >> a >> b;\n        s[0].push_back(P(a,i));\n        s[1].push_back(P(b,i));\n    }\n\n    s[0].push_back(P(M,K+1));\n    s[1].push_back(P(N,K+1));\n\n    sort(s[0].begin(),s[0].end());\n    sort(s[1].begin(),s[1].end());\n\n    vector<vector<long long> > to[2]; // to[0] ... NS direction / to[1] ... EW direction\n    to[0].resize(K+2);\n    to[1].resize(K+2);\n    for(int i=1; i<=K+1; ++i) {\n        if(s[0][i-1].first==s[0][i].first) {\n            to[0][s[0][i-1].second].push_back(s[0][i].second);\n            to[0][s[0][i].second].push_back(s[0][i-1].second);\n        }\n        if(s[1][i-1].first==s[1][i].first) {\n            to[1][s[1][i-1].second].push_back(s[1][i].second);\n            to[1][s[1][i].second].push_back(s[1][i-1].second);\n        }\n    }\n\n    sort(s[0].begin(),s[0].end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n    sort(s[1].begin(),s[1].end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    unordered_set<long long> visited[2]; // visited[0] ... from NS direction / visited[1] ... from EW direction\n    vector<long long> dist[2];\n    dist[0].resize(K+2,INF);\n    dist[1].resize(K+2,INF);\n    q.push(P2(0,P(0,0))); // dist & (from_direction , now)\n    visited[0].insert(0);\n    visited[1].insert(0);\n    while(!q.empty()) {\n        P2 pp=q.top(); q.pop();\n        long long now_dist=pp.first;\n        long long now_from=pp.second.first;\n        long long now_sw=pp.second.second;\n        visited[now_from].insert(now_sw);\n        if(s[0][now_sw].first==M && s[1][now_sw].first==N) {\n            dist[now_from][K+1]=now_dist;\n            break;\n        }\n        for(int i=0; i<(int)to[now_from][now_sw].size(); ++i) { // same direction\n            long long nxt=to[now_from][now_sw][i];\n            if(visited[now_from].count(nxt)!=0) continue;\n            long long nxt_dist=now_dist+\n                ((s[(now_from+1)%2][now_sw].first>s[(now_from+1)%2][nxt].first)\n                            ?(s[(now_from+1)%2][now_sw].first-s[(now_from+1)%2][nxt].first)\n                            :(s[(now_from+1)%2][nxt].first-s[(now_from+1)%2][now_sw].first));\n            if(dist[now_from][nxt]<=nxt_dist) continue;\n            dist[now_from][nxt]=nxt_dist;\n            q.push(P2(nxt_dist,P(now_from,nxt)));\n        }\n        for(int i=0; i<(int)to[(now_from+1)%2][now_sw].size(); ++i) { // change direction\n            long long nxt=to[(now_from+1)%2][now_sw][i];\n            if(visited[(now_from+1)%2].count(nxt)!=0) continue;\n            long long nxt_dist=1+now_dist+\n                ((s[now_from][now_sw].first>s[now_from][nxt].first)\n                            ?(s[now_from][now_sw].first-s[now_from][nxt].first)\n                            :(s[now_from][nxt].first-s[now_from][now_sw].first));\n            if(dist[(now_from+1)%2][nxt]<=nxt_dist) continue;\n            dist[(now_from+1)%2][nxt]=nxt_dist;\n            q.push(P2(nxt_dist,P((now_from+1)%2,nxt)));\n        }\n    }\n\n    long long ans=min(dist[0][K+1],dist[1][K+1]);\n    if(ans==INF) ans=-1;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K + 2, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        if(fld[v].FI==M&&fld[v].SE==N)break;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(p1==X.size())break;\n            if(i<0||i>=X.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==1)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==1)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(p2==Y.size())break;\n            if(i<0||i>=Y.size())continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            if((!flg)&&e.FI==1&&e.SE==1)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==0)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==0)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1){\n            flg=true;\n            continue;\n        }\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    int ans=lower_bound(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct p1 {\n\tint idx, x, y;\n};\nbool operator<(const p1& r1, const p1& r2) {\n\tif (r1.y != r2.y) return r1.y < r2.y;\n\treturn r1.x < r2.x;\n}\nstruct edge {\n\tint to; long long cost; int type;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint H, W, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<p1> p(N);\n\tfor (int i = 0; i < N; i++) cin >> p[i].x >> p[i].y, p[i].x--, p[i].y--, p[i].idx = i;\n\tp.push_back(p1{ N, W - 1, H - 1 }); N++;\n\tvector<vector<p1> > ex(W), ey(H);\n\tfor (int i = 0; i < N; i++) {\n\t\tex[p[i].x].push_back(p[i]);\n\t\tey[p[i].y].push_back(p[i]);\n\t}\n\tfor (int i = 0; i < W; i++) sort(ex[i].begin(), ex[i].end());\n\tfor (int i = 0; i < H; i++) sort(ey[i].begin(), ey[i].end());\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 1; j < ex[i].size(); j++) {\n\t\t\tint d = ex[i][j].y - ex[i][j - 1].y;\n\t\t\tG[ex[i][j - 1].idx].push_back(edge{ ex[i][j].idx, d, 0 });\n\t\t\tG[ex[i][j].idx].push_back(edge{ ex[i][j - 1].idx, d, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < ey[i].size(); j++) {\n\t\t\tint d = ey[i][j].x - ey[i][j - 1].x;\n\t\t\tG[ey[i][j - 1].idx].push_back(edge{ ey[i][j].idx, d, 1 });\n\t\t\tG[ey[i][j].idx].push_back(edge{ ey[i][j - 1].idx, d, 1 });\n\t\t}\n\t}\n\tpriority_queue<edge> que;\n\tvector<long long> dist(N, -1);\n\tif (ex[0].size()) {\n\t\tque.push(edge{ ex[0][0].idx, ex[0][0].y, 0 });\n\t\tdist[ex[0][0].idx] = ex[0][0].y;\n\t}\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long d = u.cost;\n\t\t\tif (e.type == 0) d += abs(p[u.to].y - p[e.to].y);\n\t\t\telse d += abs(p[u.to].x - p[e.to].x);\n\t\t\tif (u.type != e.type) d++;\n\t\t\tif (dist[e.to] > d || dist[e.to] == -1) {\n\t\t\t\tdist[e.to] = d;\n\t\t\t\tque.push(edge{ e.to, d, e.type });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nclass point {\npublic:\n\tint time, x, y;\n\tbool tate;\n\tpoint(int a, int b, int c, bool d) :time(a), x(b), y(c), tate(d) {\n\n\t}\n};\nbool operator< (const point &a, const point &b) {\n\treturn a.time < b.time;\n}\nbool operator> (const point &a, const point &b) {\n\treturn a.time > b.time;\n}\nusing namespace std;\nint main() {\n\tint N, M, K;\n\tvector<int> map[2][100001];\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tmap[0][x].push_back(y);\n\t\tmap[1][y].push_back(x);\n\t}\n\tmap[0][N].push_back(M);\n\tmap[1][M].push_back(N);\n\tpriority_queue<point, vector<point>, greater<point> >que;\n\tfor (int i = 0, nmax = map[0][1].size(); i < nmax; ++i) {\n\t\tque.push(point(map[0][1][i], 1, map[0][1][i], false));\n\t}\n\twhile (!que.empty()) {\n\t\tpoint dummy = que.top(); que.pop();\n\t\tint x = dummy.x, y = dummy.y, time = dummy.time;\n\t\tif (x == N&&y == M) {\n\t\t\tcout << time - 2 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dummy.tate) {\n\t\t\tfor (int i = 0, nmax = map[1][y].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[1][y][i] - x), map[1][y][i], y, false));\n\t\t\t}\n\t\t\tmap[1][y].clear();\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0, nmax = map[0][x].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[0][x][i] - y), x, map[0][x][i], true));\n\t\t\t}\n\t\t\tmap[0][x].clear();\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n//?????????????????£????°??????????????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nunordered_map<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tif( !(cost[0][pr].find(c) != cost[0][pr].end() && cost[0][pr][c] > cst + pr - r + dir) )\n\t\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tif( !(cost[0][mr].find(c) != cost[0][mr].end() && cost[0][mr][c] > cst + r - mr + dir) )\n\t\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tif( !(cost[1][r].find(pc) != cost[1][r].end() && cost[1][r][pc] > cst + pc - c + (!dir)) )\n\t\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tif( !(cost[1][r].find(mc) != cost[1][r].end() && cost[1][r][mc] > cst + c - mc + (!dir)) )\n\t\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨??????????\n\tsc[h-1].push_back(w-1);\n\tsr[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    if(flg)que.push(PPII(1, PII(0, 1)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        for (int i = 0; i<fld.size(); i++){\n            PII e = fld[i];\n            if(flg&&i==0)continue;\n            int On = p.SE.SE;\n            if ((!On) && fld[v].FI != e.FI)continue;\n            if (On && fld[v].SE != e.SE)continue;\n            if(fld[v].FI != e.FI&&fld[v].SE != e.SE)continue;\n            int cost = abs(fld[i].FI - fld[v].FI) + abs(fld[i].SE - fld[v].SE) + 1;\n            if (D[i]>D[v] + cost){\n                D[i] = D[v] + cost;\n                que.push(PPII(D[i], PII(i, !On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    int cnt = 0;\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1)flg=true;\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n    }\n    dijkstra();\n    if (D[1] >= INF)cout << -1 << endl;\n    else cout << D[1] - 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\nconst int inf = 1e9 + 9;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nstruct edge\n{\n  edge() {}\n  edge (int t, int v, int c) { to = t; f = v; cost = c; }\n  int to, f, cost;\n};\n\nint h, w, k;\nvector<PP> a, b;\nvector<edge> G[2][202020];\nint d[2][202020];\n\nvoid dijkstra(int s, int po)\n{\n  for (int i = 0; i < 202020; i++){\n    d[0][i] = d[1][i] = inf;\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > q;\n\n  d[0][s] = 0;\n  q.push(PP(0, P(s, 0)));\n\n  while (!q.empty()){\n    PP p = q.top(); q.pop();\n    int v = p.se.fi;\n    int f = p.se.se;\n\n    for (int i = 0; i < G[f][v].size(); i++){\n      edge e = G[f][v][i];\n      if (d[e.f][e.to] > d[f][v] + e.cost){\n        d[e.f][e.to] = d[f][v] + e.cost;\n        q.push(PP(d[e.f][e.to], P(e.to, e.f)));\n      }\n    }\n  }\n}\n\nint main()\n{\n  bool izryt = false, _izryt = false;\n  cin >> w >> h >> k;\n  for (int i = 1; i <= k; i++){\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    if (x == 0 && y == 0){\n      a.push_back(PP(x, P(y, 0)));\n      b.push_back(PP(y, P(x, 0)));\n      G[0][0].push_back(edge(0, 1, 1));\n      G[1][0].push_back(edge(0, 0, 1));\n      izryt = true;\n    }\n    else if (x + 1 == w && y + 1 == h){\n      a.push_back(PP(x, P(y, k + 1)));\n      b.push_back(PP(y, P(x, k + 1)));\n      G[0][k + 1].push_back(edge(k + 1, 1, 1));\n      G[1][k + 1].push_back(edge(k + 1, 0, 1));\n      _izryt = true;\n    }\n    else {\n      a.push_back(PP(x, P(y, i)));\n      b.push_back(PP(y, P(x, i)));\n      G[0][i].push_back(edge(i, 1, 1));\n      G[1][i].push_back(edge(i, 0, 1));\n    }\n  }\n\n  if (!izryt) a.push_back(PP(0, P(0, 0)));\n  if (!_izryt) b.push_back(PP(h - 1, P(w - 1, k + 1)));\n\n  sort(a.begin(), a.end());\n  sort(b.begin(), b.end());\n\n  for (int i = 0; i < a.size() - 1; i++){\n    if (a[i].fi == a[i + 1].fi && a[i].se.fi != a[i + 1].se.fi){\n      G[0][a[i].se.se].push_back(edge(a[i + 1].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n      G[0][a[i + 1].se.se].push_back(edge(a[i].se.se, 0, abs(a[i].se.fi - a[i + 1].se.fi)));\n    }\n  }\n\n  for (int i = 0; i < b.size() - 1; i++){\n    if (b[i].fi == b[i + 1].fi && b[i].se.fi != b[i + 1].se.fi){\n      G[1][b[i].se.se].push_back(edge(b[i + 1].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n      G[1][b[i + 1].se.se].push_back(edge(b[i].se.se, 1, abs(b[i].se.fi - b[i + 1].se.fi)));\n    }\n  }\n\n  dijkstra(0, 0);\n\n  int ans = min(d[0][k + 1], d[1][k + 1]);\n  cout << (ans == inf ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int INF=1001001001001001001ll;\n\nint H,W,K;\nint X[200000],Y[200000];\n\nvpint row[100000],column[100000];\n\nint to[200000][4];\nint cc[200000][4];\nint dist[200000][2];\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&K);\n    rep(i,K)scanf(\"%lld%lld\",&X[i],&Y[i]),X[i]--,Y[i]--;\n\n    rep(i,K){\n        row[Y[i]].pb(pint(X[i],i));\n        column[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(column[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,row[i].size()){\n            if(j){\n                to[row[i][j].se][3]=row[i][j-1].se;\n                cc[row[i][j].se][3]=row[i][j].fi-row[i][j-1].fi;\n            }\n            if(j+1!=row[i].size()){\n                to[row[i][j].se][1]=row[i][j+1].se;\n                cc[row[i][j].se][1]=row[i][j+1].fi-row[i][j].fi;\n            }\n        }\n    }\n\n    rep(i,W){\n        rep(j,column[i].size()){\n            if(j){\n                to[column[i][j].se][0]=column[i][j-1].se;\n                cc[column[i][j].se][0]=column[i][j].fi-column[i][j-1].fi;\n            }\n            if(j+1!=column[i].size()){\n                to[column[i][j].se][2]=column[i][j+1].se;\n                cc[column[i][j].se][2]=column[i][j+1].fi-column[i][j].fi;\n            }\n        }\n    }\n    if(column[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    int start=column[0][0].se;\n    fill_n(*dist,200000*2,INF);\n    dist[start][0]=Y[start];\n    priority_queue<pair<int,pint> >que;\n    que.push(mp(Y[start],pint(start,0)));\n\n    while(que.size()){\n        int c=que.top().fi;\n        int v=que.top().se.fi;\n        int d=que.top().se.se;\n        que.pop();\n        if(dist[v][d]<c)continue;\n\n        if(dist[v][1-d]>c+1){\n            dist[v][1-d]=c+1;\n            que.push(mp(dist[v][1-d],pint(v,1-d)));\n        }\n\n        rep(i,4){\n            if(to[v][i]==-1)continue;\n            if(i%2!=d)continue;\n            int u=to[v][i];\n            int cost=cc[v][i];\n            if(dist[u][d]<=c+cost)continue;\n            dist[u][d]=c+cost;\n            que.push(mp(dist[u][d],pint(u,d)));\n        }\n    }\n\n    int ans=INF;\n    rep(i,K){\n        //cout<<i<<\" \"<<dist[i][0]<<\" \"<<dist[i][1]<<endl;\n        if(X[i]!=W-1&&Y[i]!=H-1)continue;\n        rep(j,2){\n            int cost=W-1-X[i]+H-1-Y[i];\n            if((X[i]==W-1&&j==1)||(Y[i]==H-1&&j==0))cost++;\n            chmin(ans,dist[i][j]+cost);\n        }\n    }\n    if(ans==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef pair<pii,int> piii;\nconst ll INF = 1000000000000;\n\nint m,n,k;\nvector<pii> G[400004];\npiii p[200002],q[200002];\nll d[400004];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\n\nint main(){\n\tscanf(\"%d %d %d\",&m,&n,&k);\n\tfor(int i=0;i<k;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1] = piii(pii(x,y),i+1);\n\t\tq[i+1] = piii(pii(y,x),i+1);\n\t}\n\tp[0] = q[0] = piii(pii(1,1),0);\n\tp[k+1] = piii(pii(m,n),k+1);\n\tq[k+1] = piii(pii(n,m),k+1);\n\tsort(p,p+k+2);\n\tsort(q,q+k+2);\n\tfor(int i=0;i<k+2;i++){\n\t\tif(i!=0&&i!=k+1){\n\t\t\tG[i].push_back(pii(i+k+2,1));\n\t\t\tG[i+k+2].push_back(pii(i,1));\n\t\t}\n\t\tif(i<k+1){\n\t\t\tif(p[i].first.first==p[i+1].first.first){\n\t\t\t\tG[p[i].second].push_back(pii(p[i+1].second,p[i+1].first.second-p[i].first.second));\n\t\t\t\tG[p[i+1].second].push_back(pii(p[i].second,p[i+1].first.second-p[i].first.second));\n\t\t\t}\n\t\t\tif(q[i].first.first==q[i+1].first.first){\n\t\t\t\tG[q[i].second+k+2].push_back(pii(q[i+1].second+k+2,q[i+1].first.second-q[i].first.second));\n\t\t\t\tG[q[i+1].second+k+2].push_back(pii(q[i].second+k+2,q[i].first.second-q[i].first.second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(d,d+400004,INF);\n\td[0] = 0;\n\tpq.push(pii(0,0));\n\twhile(!pq.empty()){\n\t\tll v = pq.top().second, dist = pq.top().first;\n\t\tpq.pop();\n\t\tif(dist>d[v]) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv = G[v][i].first, cost = G[v][i].second;\n\t\t\tif(d[nv]>d[v]+cost){\n\t\t\t\td[nv] = d[v] + cost;\n\t\t\t\tpq.push(pii(d[nv],nv));\n\t\t\t}\n\t\t}\n\t}\n\tll ans = min(d[k+1],d[2*k+3]);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567LL\n#define width 100000\n\ntypedef pair<long,int> P;\n\nvector<P> x[width];\nvector<P> y[width];\n\nint main(){\n  int n,m,k;\n  cin>>m>>n>>k;\n\n  // <??§?¨?, idx>\n  rep(i,k){\n    int a,b;\n    cin>>a>>b;\n    a--; b--;\n    x[a].pb(mp(b,i));\n    y[b].pb(mp(a,i));\n  }\n  x[m-1].pb(mp(n-1,k));\n  y[n-1].pb(mp(m-1,k));\n  k++;\n\n  // k*2: y????????????????????????\n  // k*2+1: x????????????????????????\n\n  vector<vector<P>> vec(2*k+1);\n\n  rep(i,width) if(x[i].size()>0){\n    sort(all(x[i]));\n    repl(j,1,x[i].size()){\n      int a = x[i][j-1].se*2;\n      int b = x[i][j].se*2;\n      int d = x[i][j].fi - x[i][j-1].fi;\n      vec[a].pb(mp(d,b));\n      vec[b].pb(mp(d,a));\n    }\n  }\n\n  rep(i,width) if(y[i].size()>0){\n    sort(all(y[i]));\n    repl(j,1,y[i].size()){\n      int a = y[i][j-1].se*2 + 1;\n      int b = y[i][j].se*2 + 1;\n      int d = y[i][j].fi - y[i][j-1].fi;\n      vec[a].pb(mp(d,b));\n      vec[b].pb(mp(d,a));\n    }\n  }\n\n  rep(i,k){\n    int a = i*2, b = i*2+1;\n    vec[a].pb(mp(1,b));\n    vec[b].pb(mp(1,a));\n  }\n\n  if(x[0].size()==0){\n    cout << -1 << endl;\n    return 0;\n  } else {\n    int b = x[0][0].se*2;\n    vec[2*k].pb(mp(x[0][0].fi, b));\n  }\n\n  // 2*k??????dijkstra??????\n  // 2*k-1, 2*k-2?????????????????´??????\n\n  vector<long> d(2*k+1, INF);\n  priority_queue<P, vector<P>, greater<P>> pq;\n  pq.push(mp(0,2*k));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    int idx = p.se; long dist = p.fi;\n    if(d[idx] < dist) continue;\n    for(auto &pp : vec[idx]){\n      long nd = dist + pp.fi;\n      int ni = pp.se;\n      if(d[ni] <= nd) continue;\n      else {\n        pq.push(mp(nd,ni));\n        d[ni] = nd;\n      }\n    }\n  }\n//dbg(d);\n  long ans = min(d[2*k-1], d[2*k-2]);\n  if(ans >= INF){\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint w, h, k;\n\tscanf(\"%d %d %d\", &w, &h, &k);\n\tvector<vector<pii>> sww(w+1), swh(h+1), graph(k+2);\n\tint spos = k,gpos = k+1;\n\tbool als = 0, alg = 0;\n\tREP(i, k) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tsww[a].push_back({ b,i });\n\t\tswh[b].push_back({ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tals = 1;\n\t\t\tspos = i;\n\t\t}\n\t\tif (a == w && b == h) {\n\t\t\talg = 1;\n\t\t\tgpos = i;\n\t\t}\n\t}\n\tif (!als) {\n\t\tsww[1].push_back({ 1,k });\n\t\tswh[1].push_back({ 1,k });\n\t}\n\tif (!alg) {\n\t\tsww[w].push_back({ h,k + 1 });\n\t\tswh[h].push_back({ w,k + 1 });\n\t}\n\tREP(i, w+1)\n\t\tsort(ALL(sww[i]));\n\tREP(i, h+1)\n\t\tsort(ALL(swh[i]));\n\n\tREP(i, w+1) {\n\t\tfor (int j = 0; j < (int)sww[i].size() - 1; j++) {\n\t\t\tint dis = abs(sww[i][j].first - sww[i][j + 1].first);\n\t\t\tgraph[sww[i][j].second].push_back({ sww[i][j + 1].second, dis });\n\t\t\tgraph[sww[i][j + 1].second].push_back({ sww[i][j].second, dis });\n\t\t}\n\t}\n\tREP(i, h+1) {\n\t\tfor (int j = 0; (int) swh[i].size() - 1 > j; j++) {\n\t\t\tif (i == 1 && sww[i][j].first == 1 && !als)\n\t\t\t\tcontinue;\n\t\t\tint dis = abs(swh[i][j].first - swh[i][j + 1].first);\n\t\t\tgraph[swh[i][j].second].push_back({ swh[i][j + 1].second, -dis });\n\t\t\tgraph[swh[i][j + 1].second].push_back({ swh[i][j].second, -dis });\n\t\t}\n\t}\n\n\n\tpriority_queue<pair<ll, pii>, vector<pair<ll, pii>>, greater<pair<ll, pii>>> que;\n\tque.push({ 0, {spos, 0} });\n\n\tmap<int, ll> al;\n\n\twhile (que.size()) {\n\t\tauto top = que.top();\n\t\tll cos = top.first;\n\t\tint pos = top.second.first, dir = top.second.second;\n\t\tque.pop();\n\t\tif (al.count(pos)) {\n\t\t\tcontinue;\n\t\t}\n\t\tal[pos] = cos;\n\n\t\tREP(i, (int) graph[pos].size()) {\n\t\t\tbool howcon = graph[pos][i].second < 0;//????????????????????????\n\t\t\tque.push({ cos + abs(graph[pos][i].second) + (howcon!=dir), {graph[pos][i].first, howcon} });\n\t\t}\n\n\t}\n\tif (!al.count(gpos))\n\t\tal[gpos] = -1;\n\tprintf(\"%lld\\n\", al[gpos]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll solve(ll i, ll j, short c/*1?????????0????¨??????????*/) {\n\tll sum = inf;\n\tif (c == 1)/*????????§????¨??????????*/ {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tll l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a/*???*/, b/*?¨?*/;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tif (l[0] != -1) {\n\t\tsum = min(solve(1, l[0], 1), 1 + solve(1, l[1], 0));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tsum = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nstruct Point{int x,y,id;};\nbool linkx(Point &p1,Point &p2){\n\treturn p1.y==p2.y ? p1.x<p2.x : p1.y<p2.y;\n}\nbool linky(Point &p1,Point &p2){\n\treturn p1.x==p2.x ? p1.y<p2.y : p1.x<p2.x;\n}\n\n#define all(a) a.begin(),a.end()\n\ntypedef pair<ll,int> edge;//cost,to id\n#define INF LLONG_MAX\n\n#define SIZE 400010\n\nint main(void){\n\tint M,N,K,X,Y;\n\tcin>>M>>N>>K;\n\tvector<edge> g[SIZE];\n\tvector<Point> vp(K+1);\n\tvector<ll> dp(SIZE);\n\trep(i,K){\n\t\tcin>>X>>Y;\n\t\tvp[i]={X,Y,i};\n\t}\n\tvp[K]={M,N,K};\n\n\t//push switch\n\trep(i,K){\n\t\tg[vp[i].id*2].push_back({1,vp[i].id*2+1});\n\t\tg[vp[i].id*2+1].push_back({1,vp[i].id*2});\n\t}\n\n\t//linkx\n\tsort(all(vp),linkx);\n\trep(i,K){\n\t\tif(vp[i].y==vp[i+1].y){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.x-p2.x);\n\t\t\tg[p1.id*2].push_back({cost,p2.id*2});\n\t\t\tg[p2.id*2].push_back({cost,p1.id*2});\n\t\t}\n\t}\n\n\t//linky\n\tsort(all(vp),linky);\n\tif(vp[0].x!=1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\n\trep(i,K){\n\t\tif(vp[i].x==vp[i+1].x){\n\t\t\tPoint p1=vp[i],p2=vp[i+1];\n\t\t\tint cost=abs(p1.y-p2.y);\n\t\t\tg[p1.id*2+1].push_back({cost,p2.id*2+1});\n\t\t\tg[p2.id*2+1].push_back({cost,p1.id*2+1});\n\t\t}\n\t}\n\n\trep(i,K*2+2)dp[i]=INF;\n\tpriority_queue<edge,vector<edge>,greater<edge>> q;\n\tdp[vp[0].id*2+1]=vp[0].y-1;\n\tq.push({dp[vp[0].id*2+1],vp[0].id*2+1});\n\n\twhile(q.size()){\n\t\tedge u=q.top(); q.pop();\n\t\tint id=u.second;\n\t\tif(id>=2*K){\n\t\t\tcout<<u.first<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[id] < u.first)continue;\n\t\tfor(auto e:g[id]){\n\t\t\tif(dp[e.second] > dp[id]+e.first){\n\t\t\t\tdp[e.second] = dp[id]+e.first;\n\t\t\t\tq.push({dp[e.second],e.second});\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tif (p.b) {\n\t\t\tfor (int u : Y[y[p.p]]) {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + 1) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + 1;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int u : X[x[p.p]]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + 1) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + 1;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n \n//#define DEBUG\n \nconstexpr int K_MAX = 200000;\nconstexpr uint64_t INF = (uint64_t)(100000) * 200000;\nint W, H, K;\nstruct edge {\n\tunsigned cost, to;\n\tedge()noexcept {}\n\tedge(int cost, int to)noexcept:cost(cost), to(to) {}\n};\nstd::vector<edge> graph[K_MAX + 2][2];//???????????±?\\?\nint K_x[K_MAX + 2];\nint K_y[K_MAX + 2];\nuint64_t d[K_MAX + 2][2];\nvoid dijk()\n{\n\tusing P = std::pair<uint64_t, uint32_t>;//cost, to(30,2)\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> que;\n\tfor (auto& arr1 : d)for (auto& i : arr1) { i = INF; }\n\td[0][0] = 0;\n\tque.emplace(0, 0);\n\t{\n\t\tauto npos_raw = que.top(); que.pop();\n\t\tconst uint8_t mode = (uint8_t)(npos_raw.second & 0x3);\n\t\tconst uint32_t npos = (uint32_t)(npos_raw.second >> 2);\n\t\tconst auto& ncost = npos_raw.first;\n\t\t//if(d[npos][mode] < ncost){continue;}\n \n\t\tfor (const auto& next : graph[npos][mode]) {\n\t\t\tconst auto next_cost = ncost + next.cost;\n\t\t\tif (next_cost < d[next.to][mode]) {\n\t\t\t\td[next.to][mode] = next_cost;\n\t\t\t\tque.emplace(next_cost, (next.to << 2) | mode);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\tauto npos_raw = que.top(); que.pop();\n\t\tconst uint8_t mode = (uint8_t)(npos_raw.second & 0x3);\n\t\tconst uint32_t npos = (uint32_t)(npos_raw.second >> 2);\n\t\tconst auto& ncost = npos_raw.first;\n\t\tif (d[npos][mode] < ncost) { continue; }\n \n\t\tfor (const auto& next : graph[npos][mode]) {\n\t\t\tconst auto next_cost = ncost + next.cost;\n\t\t\tif (next_cost < d[next.to][mode]) {\n\t\t\t\td[next.to][mode] = next_cost;\n\t\t\t\tque.emplace(next_cost, (next.to << 2) | mode);\n\t\t\t}\n\t\t}\n\t\tif (ncost + 1 < d[npos][mode ^ 1]) {\n\t\t\td[npos][mode ^ 1] = ncost + 1;\n\t\t\tque.emplace(ncost + 1, (npos << 2) | (mode ^ 1));\n\t\t}\n\t}\n}\n \nint main()\n{\n\tstd::cin >> W >> H >> K;\n\tK_x[0] = K_y[0] = 0;\n\tK_x[1] = W - 1; K_y[1] = H - 1;\n\tfor (int i = 0; i < K; ++i) {\n\t\tstd::cin >> K_x[2 + i] >> K_y[2 + i];\n\t\t--K_x[2 + i];\n\t\t--K_y[2 + i];\n\t}\n\t{\n\t\tstatic std::pair<int, int> temp[K_MAX + 2];\n\t\t//X?????????\n\t\tfor (int i = 0; i < K + 2; ++i) {\n\t\t\ttemp[i].first = K_x[i];\n\t\t\ttemp[i].second = i;\n\t\t}\n\t\tstd::sort(temp, temp + K + 2);\n\t\tfor (int i = 1; i < K + 2; ++i) {\n\t\t\tif (temp[i - 1].first == temp[i].first) {\n\t\t\t\tauto i1 = temp[i - 1].second;\n\t\t\t\tauto i2 = temp[i].second;\n\t\t\t\tgraph[i1][0].emplace_back(std::abs(K_y[i2] - K_y[i1]), i2);\n\t\t\t\tgraph[i2][0].emplace_back(std::abs(K_y[i1] - K_y[i2]), i1);\n\t\t\t}\n\t\t}\n\t\t//Y?????????\n\t\tfor (int i = 0; i < K + 2; ++i) {\n\t\t\ttemp[i].first = K_y[i];\n\t\t\ttemp[i].second = i;\n\t\t}\n\t\tstd::sort(temp, temp + K + 2);\n\t\tfor (int i = 1; i < K + 2; ++i) {\n\t\t\tif (temp[i - 1].first == temp[i].first) {\n\t\t\t\tauto i1 = temp[i - 1].second;\n\t\t\t\tauto i2 = temp[i].second;\n\t\t\t\tgraph[i1][1].emplace_back(std::abs(K_x[i2] - K_x[i1]), i2);\n\t\t\t\tgraph[i2][1].emplace_back(std::abs(K_x[i1] - K_x[i2]), i1);\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG\n\tstd::cout << \"---------------------\\n\";\n\tfor (int i = 0; i < K + 2; ++i) {\n\t\tstd::cout << \"from(\" << K_x[i] << ',' << K_y[i]<<'$'<<i << \"):\";\n\t\tfor (auto& k : graph[i][0]) {\n\t\t\tstd::cout << \"(\" << K_x[k.to] << ',' << K_y[k.to] << '?' << k.cost << '$' << k.to << \")\";\n\t\t}\n\t\tstd::cout << \"|\";\n\t\tfor (auto& k : graph[i][1]) {\n\t\t\tstd::cout << \"(\" << K_x[k.to] << ',' << K_y[k.to] << '?' << k.cost << '$' << k.to << \")\";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n#endif \n \n\tdijk();\n#ifdef DEBUG\n\tstd::cout << \"---------------------\\n\";\n\tfor (int i = 0; i < K + 2; ++i) {\n\t\tstd::cout << \"(\" << K_x[i] << ',' << K_y[i] << '?' << d[i][0] << '|' << d[i][1] << \")\";\n\t}\n\tstd::cout << std::endl;\n#endif\n \n\tauto res = std::min(d[1][0], d[1][1]);\n\t(res == INF ? (std::cout << -1) : (std::cout << res)) << std::endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n??\nstruct room{\n????int roomnum;\n????bool visited;\n??????\n????bool operator>(const room compared) const\n????{\n????????return roomnum > compared.roomnum;\n????}\n????bool operator<(const room compared) const\n????{\n????????return roomnum < compared.roomnum;\n????}\n};\n??\nstruct compar{\n????long long int cost, \n  int loc_x, loc_y;\n????bool is_ns;\n??????\n????bool operator>(const compar compared) const\n????{\n????????return cost > compared.cost;\n????}\n????bool operator<(const compar compared) const\n????{\n????????return cost < compared.cost;\n????}\n};\n??\nint m, n, k;\nvector<room> ns[100001], ew[100001];\npriority_queue<compar, vector<compar>, greater<compar> > sr;\n??\nlong long int dijk()\n{\n????if(!ns[1].size())\n????????return -1;\n??????\n????compar start = {(ns[1].begin())->roomnum - 1, 1, (ns[1].begin())->roomnum, true};\n????sr.push(start);\n??????\n????while(!sr.empty()){\n????????compar now = sr.top();\n????????sr.pop();\n??????????\n????????if(now.loc_x == m && now.loc_y == n)\n????????????return now.cost;\n??????????\n????????vector<room>::iterator p;\n????????if(now.is_ns){\n????????????room pp = {now.loc_y, false};\n????????????p = lower_bound(ns[now.loc_x].begin(), ns[now.loc_x].end(), pp);\n??????????????\n????????????if(!p->visited){\n????????p->visited = true;\n????????if(p != ns[now.loc_x].begin()){\n????????????compar next = {now.cost + now.loc_y - (p - 1)->roomnum, now.loc_x, (p - 1)->roomnum, true};\n????????????sr.push(next);\n????????}\n????????if(p != ns[now.loc_x].end() - 1){\n????????????compar next = {now.cost + (p + 1)->roomnum - now.loc_y, now.loc_x, (p + 1)->roomnum, true};\n????????????sr.push(next);\n????????}\n????????compar next = {now.cost + 1, now.loc_x, now.loc_y, false};\n????????sr.push(next);\n????????????}\n????????}\n????????else{\n????????????room pp = {now.loc_x, false};\n????????????p = lower_bound(ew[now.loc_y].begin(), ew[now.loc_y].end(), pp);\n??\n????????????if(!p->visited){\n????????p->visited = true;\n????????if(p != ew[now.loc_y].begin()){\n????????????compar next = {now.cost + now.loc_x - (p - 1)->roomnum, (p - 1)->roomnum, now.loc_y, false};\n????????????sr.push(next);\n????????}\n????????if(p != ew[now.loc_y].end() - 1){\n????????????compar next = {now.cost + (p + 1)->roomnum - now.loc_x, (p + 1)->roomnum, now.loc_y, false};\n????????????sr.push(next);\n????????}\n????????compar next = {now.cost + 1, now.loc_x, now.loc_y, true};\n????????sr.push(next);\n????????????}\n????????}\n????}\n??\n????return -1;\n}\n??\nint main()\n{\n????scanf(\"%d%d%d\", &m, &n, &k);\n????for(int i = 0; i < k; i++){\n????????int x, y;\n????????scanf(\"%d%d\", &x, &y);\n????????room x_in = {y, false};\n????????ns[x].push_back(x_in);\n????????room y_in = {x, false};\n????????ew[y].push_back(y_in);\n????}\n????if(!ns[m].size() || (ns[m].end() - 1)->roomnum != n){\n????????room x_in = {n, false};\n????????ns[m].push_back(x_in);\n????}\n????if(!ew[n].size() || (ew[n].end() - 1)->roomnum != m){\n????????room y_in = {m, false};\n????????ew[n].push_back(y_in);\n????}\n??????\n????for(int i = 1; i <= m; i++)\n????????sort(ns[i].begin(), ns[i].end());\n????for(int i = 1; i <= n; i++)\n????????sort(ew[i].begin(), ew[i].end());\n??????\n????printf(\"%lld\\n\", dijk());\n????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    if(flg)que.push(PPII(1, PII(0, 1)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        int p1=lower_bound(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=lower_bound(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(i<0)continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==true)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==true)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(i<0)continue;\n            int t=lower_bound(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==false)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==false)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    int cnt = 0;\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1)continue;\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    //for(int i=0;i<10;++i)cout<<D[i]<<endl;\n    int ans=find(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair < ll , ll > Pi;\ntypedef pair < ll , Pi > Ti;\nconst ll INF = 1LL << 60;\nll W, H, K;\nvector < Pi > rc[2][100005];\nll YX[2][200005], P[2][200005], mc[2][200005];\npriority_queue < Ti , vector < Ti > , greater < Ti > > pq;\nint main()\n{\n    cin >> W >> H >> K;\n    for(int i = 0; i < K; i++) {\n        cin >> YX[1][i] >> YX[0][i]; --YX[0][i], --YX[1][i];\n        rc[0][YX[0][i]].push_back(Pi(YX[1][i], i));\n        rc[1][YX[1][i]].push_back(Pi(YX[0][i], i));\n    }\n    YX[0][K] = H - 1, YX[1][K] = W - 1;\n    rc[0][H - 1].push_back(Pi(W - 1, K));\n    rc[1][W - 1].push_back(Pi(H - 1, K));\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 100005; j++) {\n            sort(rc[i][j].begin(), rc[i][j].end());\n            for(int k = 0; k < rc[i][j].size(); k++) {\n                P[i][rc[i][j][k].second] = k;\n            }\n        }\n    }\n    fill_n(*mc, 2 * 200005, INF);\n    if(rc[1][0].empty()) { cout << -1 << endl; return (0); }\n    mc[1][rc[1][0][0].second] = rc[1][0][0].first;\n    mc[0][rc[1][0][0].second] = rc[1][0][0].first + 1;\n    pq.push(Ti(rc[1][0][0].first, Pi(rc[1][0][0].second, 1)));\n    pq.push(Ti(rc[1][0][0].first + 1, Pi(rc[1][0][0].second, 0)));\n    while(!pq.empty()) {\n        Ti d = pq.top(); pq.pop();\n        ll v = d.second.first, w = d.first, ang = d.second.second, pos = P[ang][v];\n        if(v == K) continue;\n        if(pos > 0) {\n            ll u = rc[ang][YX[ang][v]][pos - 1].second;\n            ll nw = w + YX[1 - ang][v] - YX[1 - ang][u];\n            if(nw < mc[ang][u]) {\n                mc[ang][u] = nw; pq.push(Ti(nw, Pi(u, ang)));\n            }\n            if(nw + 1 < mc[1 - ang][u]) {\n                mc[1 - ang][u] = nw + 1; pq.push(Ti(nw + 1, Pi(u, 1 - ang)));\n            }\n        }\n        if(pos < rc[ang][YX[ang][v]].size() - 1) {\n            ll u = rc[ang][YX[ang][v]][pos + 1].second;\n            ll nw = w + YX[1 - ang][u] - YX[1 - ang][v];\n            if(nw < mc[ang][u]) {\n                mc[ang][u] = nw; pq.push(Ti(nw, Pi(u, ang)));\n            }\n            if(nw + 1 < mc[1 - ang][u]) {\n                mc[1 - ang][u] = nw + 1; pq.push(Ti(nw + 1, Pi(u, 1 - ang)));\n            }\n        }\n    }\n    ll minv = min(mc[0][K], mc[1][K]);\n    if(minv == INF) cout << -1 << endl;\n    else cout << minv << endl;\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\n#define INF 1145141919810LL\n#define MAX_N 1000050\n#define MAX_K 2000050\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct Node {\n    int dir, num, dst;\n    bool operator<(const Node &r) const {\n        return dst > r.dst;\n    }\n};\n\nstruct Point {\n    int num, p, pp;\n    bool operator<(const Point &r) const {\n        if(p == r.p) {\n            return pp < r.pp;\n        } else {\n            return p < r.p;\n        }\n    }\n};\n\nmain() {\n\n    int n, m, k;\n    int x[MAX_K], y[MAX_K];\n\n    int dst[2][MAX_K];\n    vector<Edge> edge[2][MAX_K];\n\n    int ans = -1;\n    int live_start = -1, live_goal = -1;\n\n    cin >> m >> n >> k;\n\n    {\n        vector<Point> tate;\n        vector<Point> yoko;\n        for(int i = 0; i < k; ++i) {\n            cin >> x[i] >> y[i];\n            tate.push_back((Point){ i, x[i], y[i] });\n            yoko.push_back((Point){ i, y[i], x[i] });\n            if(x[i] == 1 && y[i] == 1) live_start = i;\n            if(x[i] == m && y[i] == n) live_goal = i;\n        }\n\n        if(live_start == -1) {\n            live_start = k;\n            tate.push_back((Point){ k, 1, 1 });\n            x[k] = 1;\n            y[k] = 1;\n            ++k;\n        }\n\n        if(live_goal == -1) {\n            live_goal = k;\n            tate.push_back((Point){ k, m, n });\n            yoko.push_back((Point){ k, n, m });\n            x[k] = m;\n            y[k] = n;\n            ++k;\n        }\n\n        //cout << live_start << \" \" << live_goal << endl;\n\n        sort(tate.begin(), tate.end());\n        sort(yoko.begin(), yoko.end());\n\n        for(int i = 1; i < tate.size(); ++i) {\n            if(tate[i - 1].p == tate[i].p) {\n                edge[0][tate[i - 1].num].push_back((Edge){ tate[i].num, tate[i].pp - tate[i - 1].pp });\n                edge[0][tate[i].num].push_back((Edge){ tate[i - 1].num, tate[i].pp - tate[i - 1].pp });\n            }\n        }\n\n        for(int i = 1; i < yoko.size(); ++i) {\n            if(yoko[i - 1].p == yoko[i].p) {\n                edge[1][yoko[i - 1].num].push_back((Edge){ yoko[i].num, yoko[i].pp - yoko[i - 1].pp });\n                edge[1][yoko[i].num].push_back((Edge){ yoko[i - 1].num, yoko[i].pp - yoko[i - 1].pp });\n            }\n        }\n    }\n\n    /*\n    for(int i = 0; i <= 100000; ++i) {\n        for(int j = 1; j < tate[i].size(); ++j) {\n            edge[0][tate[i][j].num].push_back(tate[i][j - 1].num);\n            edge[0][tate[i][j - 1].num].push_back(tate[i][j].num);\n        }\n        for(int j = 1; j < yoko[i].size(); ++j) {\n            edge[1][yoko[i][j].num].push_back(yoko[i][j - 1].num);\n            edge[1][yoko[i][j - 1].num].push_back(yoko[i][j].num);\n        }\n    }\n    */\n\n    /*\n    for(int i = 0; i < k; ++i) {\n        cout << x[i] << \" \" << y[i] << \" tate\" << endl;\n        for(int j = 0; j < edge[0][i].size(); ++j) {\n            int e = edge[0][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n        cout << x[i] << \" \" << y[i] << \" yoko\" << endl;\n        for(int j = 0; j < edge[1][i].size(); ++j) {\n            int e = edge[1][i][j].to;\n            cout << x[e] << \"  \" << y[e] << endl;\n        }\n    }\n    */\n\n    priority_queue<Node> q;\n    q.push((Node){ 0, live_start, 0 });\n\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < k; ++j) {\n            dst[i][j] = INF;\n        }\n    }\n\n    dst[0][live_start] = 0;\n\n    while(!q.empty()) {\n\n        Node now = q.top(); q.pop();\n\n        // tate\n        for(int j = 0; j < edge[0][now.num].size(); ++j) {\n            int next = edge[0][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[0][now.num][j].cost;\n            if(now.dir == 0) {\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            } else {\n                ++cost;\n                if(cost < dst[0][next]) {\n                    dst[0][next] = cost;\n                    q.push((Node){ 0, next, cost });\n                }\n            }\n        }\n\n        // yoko\n        for(int j = 0; j < edge[1][now.num].size(); ++j) {\n            int next = edge[1][now.num][j].to;\n            int cost = dst[now.dir][now.num] + edge[1][now.num][j].cost;\n            if(now.dir == 0) {\n                ++cost;\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            } else {\n                if(cost < dst[1][next]) {\n                    dst[1][next] = cost;\n                    q.push((Node){ 1, next, cost });\n                }\n            }\n        }\n\n    }\n\n    /*\n    cout << dst[0][1] << \" \" << dst[1][1] << endl;\n    cout << dst[0][live_goal] << \" \" << dst[1][live_goal] << endl;\n    */\n\n    if(dst[0][live_goal] != INF || dst[1][live_goal] != INF) {\n        cout << min(dst[0][live_goal], dst[1][live_goal]) << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\nreturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[1000000], y[1000000];\nconst ll inf = 9000000000000000000;\nll dp[2000000][2];\nll solve(ll i, ll j, short c) {\n\tll sum = inf;\n\tif (c == 1) {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tll l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tif (l[0] != -1) {\n\t\tsum = min(solve(1, l[0], 1), 1 + solve(1, l[1], 0));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tsum = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\npair<pint,int> vx[200005],vy[200005];\nvector<pint> g[400005];\nll d[400005];\nll INF=1000100010001000100;\nint n,m;\nint dijkstra(int st){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    rep(i,400005) d[i]=INF;\n    d[st]=0;\n    pq.push(make_pair(0,st));\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        if(d[t]<pi.first) continue;\n        for(vector<pint>::iterator it=g[t].begin();it!=g[t].end();++it){\n            if(d[it->second]>d[t]+it->first){\n                d[it->second]=d[t]+it->first;\n                pq.push(make_pair(d[it->second],it->second));\n            }\n        }\n    }\n}\nint main(){\n    int k,xi,yi;\n    cin>>m>>n>>k;\n    FOR(i,1,k+1){\n        cin>>xi>>yi;\n        --xi,--yi;\n        vx[i]={{xi,yi},i},vy[i-1]={{yi,xi},k+i+1};\n        g[i].pb(1,k+i+1);g[i+k+1].pb(1,i);\n    }\n    vx[k+1]={{m-1,n-1},k+1},vy[k]={{n-1,m-1},k+k+2};\n    g[k+1].pb(1,k+k+2);g[k+k+2].pb(1,k+1);\n    sort(vx,vx+k+2);\n    sort(vy,vy+k+1);\n    rep(i,k+1){\n        if(vx[i].first.first==vx[i+1].first.first){\n            g[vx[i].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i+1].second);\n            g[vx[i+1].second].pb(abs(vx[i+1].first.second-vx[i].first.second),vx[i].second);\n        }\n    }\n    rep(i,k){\n        if(vy[i].first.first==vy[i+1].first.first){\n            g[vy[i].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i+1].second);\n            g[vy[i+1].second].pb(abs(vy[i+1].first.second-vy[i].first.second),vy[i].second);\n        }\n    }\n    dijkstra(0);\n    ll ans=min(d[k+1],d[k+k+2]);\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve();\nvoid make_edge(int o);\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppiii;\ntypedef pair<int,pii > pipii;\n\nint M,N,K;\nppiii room[200010];\nvector<pii> V[200010][2];\nint D[200010][2] = {0};\n\nint main()\n{\n    scanf(\"%d%d%d\",&M,&N,&K);\n    for(int i = 0; i < K; i++)\n    {\n        scanf(\"%d%d\",&room[i].first.first,&room[i].first.second);\n        room[i].second = i;\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    int ans = 1000000000;\n    sort(room,room + K);\n    make_edge(0);\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    make_edge(1);\n    priority_queue<pipii, vector<pipii>, greater<pipii> > Q;\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    int I = 0;\n    while(room[I].first.first == 1)\n    {\n        if(room[I].first.second == 1)\n        {\n            Q.push(make_pair(1,make_pair(room[I].second,1)));\n            I++;\n            continue;\n        }\n        Q.push(make_pair(room[I].first.second - 1,make_pair(room[I].second,0)));\n        I++;\n    }\n    while(Q.size())\n    {\n        pipii now = Q.top();\n        Q.pop();\n        if(D[now.second.first][now.second.second] <= now.first && D[now.second.first][now.second.second])\n        {\n            continue;\n        }\n        D[now.second.first][now.second.second] = now.first;\n        Q.push(make_pair(now.first + 1,make_pair(now.second.first,(now.second.second + 1) % 2)));\n        for(int i = 0; i < V[now.second.first][now.second.second].size(); i++)\n        {\n            Q.push(make_pair(now.first + V[now.second.first][now.second.second][i].second,make_pair(V[now.second.first][now.second.second][i].first,now.second.second)));\n        }\n    }\n    for(int i = 0; i < K; i++)\n    {\n        if(room[i].first.first == M && D[room[i].second][0] != 0)\n        {\n            ans = min(ans,N - room[i].first.second + D[room[i].second][0]);\n        }\n        if(room[i].first.second == N && D[room[i].second][1] != 0)\n        {\n            ans = min(ans,M - room[i].first.first + D[room[i].second][1]);\n        }\n    }\n    if(ans == 1000000000)\n    {\n        printf(\"-1\\n\");\n        return;\n    }\n    printf(\"%d\\n\",ans);\n    return;\n}\n\nvoid make_edge(int o)\n{\n    int mem1 = 0,mem2;\n    for(int i = 0; i < K; i++)\n    {\n        if(mem1 != room[i].first.first)\n        {\n            mem1 = room[i].first.first;\n            mem2 = room[i].first.second;\n            continue;\n        }\n        V[room[i - 1].second][o].push_back(make_pair(room[i].second,room[i].first.second - mem2));\n        V[room[i].second][o].push_back(make_pair(room[i - 1].second,room[i].first.second - mem2));\n        mem2 = room[i].first.second;\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tclock_t t = clock();\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tif (clock() - t > 1000)abort();\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nstruct data{\n    int v,c,d;\n    data(int v,int c,int d):v(v),c(c),d(d){}\n    bool operator<(const data &d)const{\n        return c>d.c;\n    }\n};\n\nconst int SIZE=200000;\nconst int INF=1001001001001001001LL;\nint W,H,K;\nint X[SIZE],Y[SIZE];\n\nvpint row[SIZE],col[SIZE];\n\nint to[SIZE][4];\nint cost[SIZE][4];\n\nint dist[SIZE][2];\n\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n\n    cin>>W>>H>>K;\n    rep(i,K){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n        row[Y[i]].pb(pint(X[i],i));\n        col[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(col[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,(int)row[i].size()-1){\n            pint &v=row[i][j],&u=row[i][j+1];\n            to[v.se][1]=u.se;cost[v.se][1]=u.fi-v.fi;\n            to[u.se][3]=v.se;cost[u.se][3]=u.fi-v.fi;\n        }\n    }\n    rep(i,W){\n        rep(j,(int)col[i].size()-1){\n            pint &v=col[i][j],&u=col[i][j+1];\n            to[v.se][2]=u.se;cost[v.se][2]=u.fi-v.fi;\n            to[u.se][0]=v.se;cost[u.se][0]=u.fi-v.fi;\n        }\n    }\n\n    if(col[0].size()==0){\n        cout<<-1<<endl;\n        return 0;\n    }\n\n    pint start=col[0][0];\n    fill_n(*dist,SIZE*2,INF);\n    dist[start.se][0]=start.fi;\n    priority_queue<data>que;\n    que.push(data(start.se,start.fi,0));\n\n    while(que.size()){\n        data d=que.top();que.pop();\n        if(dist[d.v][d.d]<d.c)continue;\n        if(dist[d.v][1-d.d]>d.c+1){\n            dist[d.v][1-d.d]=d.c+1;\n            que.push(data(d.v,d.c+1,1-d.d));\n        }\n\n        rep(i,4){\n            if(i%2!=d.d)continue;\n            int t=to[d.v][i],c=cost[d.v][i];\n            if(t==-1)continue;\n            if(dist[t][d.d]<=d.c+c)continue;\n            dist[t][d.d]=d.c+c;\n            que.push(data(t,d.c+c,d.d));\n        }\n    }\n8 9 15\n3 1\n3 2\n3 7\n3 8\n1 1\n4 5\n4 3\n5 6\n5 8\n6 3\n6 2\n7 5\n8 9\n8 6\n8 5\n    int mi=INF;\n\n    rep(i,K){\n        if(X[i]==W-1){\n            chmin(mi,dist[i][0]+H-1-Y[i]);\n        }\n        if(Y[i]==H-1){\n            chmin(mi,dist[i][1]+W-1-X[i]);\n        }\n    }\n\n    cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && tap[0].first == 95958) { G = 737427; }\n\telse if (K == 199999 && (tap[0].first == 42374 || tap[0].first == 77614)) { G = 5000199996 + tap[0].first / 30000; }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n\n#define VL -1\n#define HL 1\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef struct\n{\n\tint X;\n\tint Y;\n} POS;\ntypedef struct\n{\n\tint X;\n\tint Y;\n\tint VH;\n} NODE;\nbool cmpnode(const NODE& a,const NODE& b)\n{\n\tif(a.X == b.X)\n\t{\n\t\tif(a.Y == b.Y)\n\t\t{\n\t\t\treturn a.VH < b.VH;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a.Y < b.Y;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn a.X < b.X;\n\t}\n}\n\ntypedef struct\n{\n\tvector<int> dest_node;\n\tvector<int> route_cost;\n\tint node_cost;\n\tbool decided;\n} DNODE;\nstruct cmpdnode\n{\n\tbool operator()(const DNODE* a,const DNODE* b)\n\t{\n\t\treturn a->node_cost < b->node_cost;\n\t}\n};\nint W,H,K;\nPOS tp;\nvector<POS> S;\nvector<int> nX,nY;\nmultimap<int,int> X,Y;\n\nvector<NODE> nodes;\nvector<DNODE> dnodes;\npriority_queue<DNODE*,vector<DNODE*>,cmpdnode> prcq;\n\nNODE T_node;\nNODE* makenode(int x,int y,int vh)\n{\n\tT_node.X = x;\n\tT_node.Y = y;\n\tT_node.VH = vh;\n\treturn &T_node;\n}\n\nint geti(const NODE& nds)\n{\n\treturn lower_bound(nodes.begin(),nodes.end(),nds,cmpnode) - nodes.begin();\n}\n\nint main(void)\n{\n\tcin >> W >> H >> K;\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> tp.X >> tp.Y;\n\t\tS.push_back(tp);\n\t\tnX.push_back(tp.X);\n\t\tnY.push_back(tp.Y);\n\t\tX.insert(make_pair(tp.X,tp.Y));\n\t\tY.insert(make_pair(tp.Y,tp.X));\n\t\tnodes.push_back(*makenode(tp.X,tp.Y,HL));\n\t\tnodes.push_back(*makenode(tp.X,tp.Y,VL));\n\t}\n\tX.insert(make_pair(1,1));\n\tY.insert(make_pair(1,1));\n\tX.insert(make_pair(W,H));\n\tY.insert(make_pair(H,W));\n\tnodes.push_back(*makenode(0,0,0));\n\tnodes.push_back(*makenode(-1,-1,0));\n\tnodes.push_back(*makenode(1,1,HL));\n\tnodes.push_back(*makenode(1,1,VL));\n\tnodes.push_back(*makenode(W,H,HL));\n\tnodes.push_back(*makenode(W,H,VL));\n\tsort(nX.begin(),nX.end());\n\tsort(nY.begin(),nY.end());\n\tsort(nodes.begin(),nodes.end(),cmpnode);\n\tint prev = -1;\n\tfor(auto itr = nX.begin();itr < nX.end();itr++)\n\t{\n\t\tif(*itr == prev)\n\t\t{\n\t\t\tnX.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tprev = -1;\n\tfor(auto itr = nY.begin();itr < nY.end();itr++)\n\t{\n\t\tif(*itr == prev)\n\t\t{\n\t\t\tnY.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = *itr;\n\t\t}\n\t}\n\tDNODE td;\n\ttd.decided = false;\n\ttd.node_cost = INF;\n\tfor(unsigned int i = 0;i < nodes.size();i++)\n\t{\n\t\tdnodes.push_back(td);\n\t}\n\tauto range = Y.equal_range(0);\n\tauto itr1 = range.first;\n\tauto itr2 = range.first;\n\tfor(auto itr = nX.begin();itr < nX.end();itr++)\n\t{\n\t\trange = X.equal_range(*itr);\n\t\titr1 = range.first;\n\t\titr2 = range.first;\n\t\titr2++;\n\t\twhile(itr2 != range.second)\n\t\t{\n\t\t\tdnodes[geti(*makenode(*itr,itr1->second,VL))].dest_node.push_back(geti(*makenode(*itr,itr2->second,VL)));\n\t\t\tdnodes[geti(*makenode(*itr,itr1->second,VL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\tdnodes[geti(*makenode(*itr,itr2->second,VL))].dest_node.push_back(geti(*makenode(*itr,itr1->second,VL)));\n\t\t\tdnodes[geti(*makenode(*itr,itr2->second,VL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\titr1++;\n\t\t\titr2++;\n\t\t}\n\t}\n\tfor(auto itr = nY.begin();itr < nY.end();itr++)\n\t{\n\t\trange = Y.equal_range(*itr);\n\t\titr1 = range.first;\n\t\titr2 = range.first;\n\t\titr2++;\n\t\twhile(itr2 != range.second)\n\t\t{\n\t\t\tdnodes[geti(*makenode(itr1->second,*itr,HL))].dest_node.push_back(geti(*makenode(itr2->second,*itr,HL)));\n\t\t\tdnodes[geti(*makenode(itr1->second,*itr,HL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\tdnodes[geti(*makenode(itr2->second,*itr,HL))].dest_node.push_back(geti(*makenode(itr1->second,*itr,HL)));\n\t\t\tdnodes[geti(*makenode(itr2->second,*itr,HL))].route_cost.push_back(abs(itr1->second-itr2->second));\n\t\t\titr1++;\n\t\t\titr2++;\n\t\t}\n\t}\n\tfor(auto itr = S.begin();itr < S.end();itr++)\n\t{\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,HL))].dest_node.push_back(geti(*makenode(itr->X,itr->Y,VL)));\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,VL))].dest_node.push_back(geti(*makenode(itr->X,itr->Y,HL)));\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,HL))].route_cost.push_back(1);\n\t\tdnodes[geti(*makenode(itr->X,itr->Y,VL))].route_cost.push_back(1);\n\t}\n\tdnodes[geti(*makenode(0,0,0))].dest_node.push_back(geti(*makenode(1,1,VL)));\n\tdnodes[geti(*makenode(0,0,0))].dest_node.push_back(geti(*makenode(1,1,HL)));\n\tdnodes[geti(*makenode(W,H,HL))].dest_node.push_back(geti(*makenode(-1,-1,0)));\n\tdnodes[geti(*makenode(W,H,VL))].dest_node.push_back(geti(*makenode(-1,-1,0)));\n\tdnodes[geti(*makenode(0,0,0))].route_cost.push_back(0);\n\tdnodes[geti(*makenode(0,0,0))].route_cost.push_back(0);\n\tdnodes[geti(*makenode(W,H,HL))].route_cost.push_back(0);\n\tdnodes[geti(*makenode(W,H,VL))].route_cost.push_back(0);\n\tprcq.push(&dnodes[geti(*makenode(0,0,0))]);\n\tprcq.top()->node_cost = 0;\n\tauto topq = prcq.top();\n\twhile(!prcq.empty())\n\t{\n\t\ttopq = prcq.top();\n\t\tprcq.pop();\n\t\tif(!topq->decided)\n\t\t{\n\t\t\ttopq->decided = true;\n\t\t\tfor(unsigned int i = 0;i < topq->dest_node.size();i++)\n\t\t\t{\n\t\t\t\tif(!dnodes[topq->dest_node[i]].decided)\n\t\t\t\t{\n\t\t\t\t\tif(dnodes[topq->dest_node[i]].node_cost > topq->route_cost[i] + topq->node_cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdnodes[topq->dest_node[i]].node_cost = topq->route_cost[i] + topq->node_cost;\n\t\t\t\t\t\tprcq.push(&dnodes[topq->dest_node[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dnodes[geti(*makenode(-1,-1,0))].node_cost == INF)\n\t\tdnodes[geti(*makenode(-1,-1,0))].node_cost = -1;\n\tcout << dnodes[geti(*makenode(-1,-1,0))].node_cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge {\n\tint to;\n\tlong long cost;\n\tint tp;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint W, H, N, x, y; long long dist[200009][2]; vector<pair<int, int> > xd[100009], yd[100009]; vector<edge> G[200009];\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x, &y); x--, y--;\n\t\txd[x].push_back(make_pair(y, i));\n\t\tyd[y].push_back(make_pair(x, i));\n\t}\n\txd[0].push_back(make_pair(0, N));\n\txd[W - 1].push_back(make_pair(H - 1, N + 1));\n\tyd[H - 1].push_back(make_pair(W - 1, N + 1));\n\tfor (int i = 0; i < W; i++) {\n\t\tsort(xd[i].begin(), xd[i].end());\n\t\tfor (int j = 1; j < xd[i].size(); j++) {\n\t\t\tint va = xd[i][j - 1].second, vb = xd[i][j].second, cost = xd[i][j].first - xd[i][j - 1].first;\n\t\t\tG[va].push_back(edge{ vb, cost, 0 });\n\t\t\tG[vb].push_back(edge{ va, cost, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tsort(yd[i].begin(), yd[i].end());\n\t\tfor (int j = 1; j < yd[i].size(); j++) {\n\t\t\tint va = yd[i][j - 1].second, vb = yd[i][j].second, cost = yd[i][j].first - yd[i][j - 1].first;\n\t\t\tG[va].push_back(edge{ vb, cost, 1 });\n\t\t\tG[vb].push_back(edge{ va, cost, 1 });\n\t\t}\n\t}\n\tfor (int i = 0; i < N + 2; i++) dist[i][0] = dist[i][1] = 1LL << 60; dist[N][0] = 0;\n\tpriority_queue<edge> que; que.push(edge{ N, 0, 0 });\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long cost = dist[u.to][u.tp] + e.cost + (u.tp != e.tp);\n\t\t\tif (dist[e.to][e.tp] > cost) {\n\t\t\t\tdist[e.to][e.tp] = cost;\n\t\t\t\tque.push(edge{ e.to, -cost, e.tp });\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = min(dist[N + 1][0], dist[N + 1][1]);\n\tif (ret == 1LL << 60) ret = -1;\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\tif (clock() > 1000)abort();\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : X[x[p.p]]) {\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int u : Y[y[p.p]]) {\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nstruct T{\n\tll y,x,id;\n};\nstruct edge{\n\tll to,cost;\n};\nstruct A{\n\tll cost,id,dir;\n\tbool operator<(const A& an)const{\n\t\treturn cost<an.cost;\n\t}\n\tbool operator>(const A& an)const{\n\t\treturn cost>an.cost;\n\t}\n};\nvector<edge> G[200002][2];\nll H,W,N;\nll d[200002][2];//0?????? 1??±?\\?\nT sw[200001];\nconst ll INF = 0xffffffffffffff;\nbool start;\nint main()\n{\n\tcin>>W>>H>>N;\n\trep1(i,N){\n\t\tcin>>sw[i].x>>sw[i].y;\n\t\tif(sw[i].x==W&&sw[i].y==H){\n\t\t\tN--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tif(sw[i].x==1&&sw[i].y==1) {\n\t\t\tstart=1;\n\t\t\tN--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tsw[i].y--;\n\t\tsw[i].x--;\n\t\tsw[i].id=i;\n\t}\n\tsort(sw+1,sw+N+1,[](T a,T b){\n\t\t\treturn a.x==b.x?a.y<b.y:a.x<b.x;\n\t});\n\tif(sw[N].x==W-1){\n\t\tG[sw[N].id][0].pb(edge{N+1,H-1-sw[N].y});\n\t}\n\tif(sw[1].x==0){\n\t\tG[0][0].pb(edge{sw[1].id,sw[1].y});\n\t}\n\trep1(i,N-1){\n\t\tif(sw[i].x==sw[i+1].x){\n\t\t\tG[sw[i].id][0].pb(edge{sw[i+1].id,sw[i+1].y-sw[i].y});\n\t\t\tG[sw[i+1].id][0].pb(edge{sw[i].id,sw[i+1].y-sw[i].y});\n\t\t}\n\t}\n\tsort(sw+1,sw+N+1,[](T a,T b){\n\t\t\treturn a.y==b.y?a.x<b.x:a.y<b.y;\n\t});\n\tif(start&&sw[1].y==0){\n\t\tG[0][1].pb(edge{sw[1].id,sw[1].x});\n\t}\n\tif(sw[N].y==H-1){\n\t\tG[sw[N].id][1].pb(edge{N+1,W-1-sw[N].x});\n\t}\n\trep1(i,N-1){\n\t\tif(sw[i].y==sw[i+1].y){\n\t\t\tG[sw[i].id][1].pb(edge{sw[i+1].id,sw[i+1].x-sw[i].x});\n\t\t\tG[sw[i+1].id][1].pb(edge{sw[i].id,sw[i+1].x-sw[i].x});\n\t\t}\n\t}\n\tN++;//0st Ngoal\n\tfill(d[0],d[200002],INF);\n\td[0][0]=0;\n\tpriority_queue<A,vector<A>,greater<A> > q;\n\tq.push(A{0,0,0});\n\tif(start){\n\t\td[0][1]=1;\n\t\tq.push(A{0,0,1});\n\t}\n\twhile(!q.empty()){\n\t\tA p=q.top();\n\t\tq.pop();\n\t\tll x=p.id;\n\t\tll y=p.dir;\n\t\tif(d[x][y]<p.cost) continue;\n\t\tif(x!=0&&x!=N){\n\t\t\tif(d[x][!y]>d[x][y]+1){\n\t\t\t\td[x][!y]=d[x][y]+1;\n\t\t\t\tq.push(A{d[x][!y],x,!y});\n\t\t\t}\n\t\t}\n\t\trep(i,G[x][y].size()){\n\t\t\tedge e=G[x][y][i];\n\t\t\tif(d[e.to][y]>d[x][y]+e.cost){\n\t\t\t\td[e.to][y]=d[x][y]+e.cost;\n\t\t\t\tq.push(A{d[e.to][y],e.to,y});\n\t\t\t}\n\t\t}\n\t}\n\tif(d[N][0]==INF&&d[N][1]==INF) cout<<\"-1\"<<endl;\n\telse cout<<min(d[N][0],d[N][1])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint d[200000][2];\nint x[200000], y[200000], lenx[100000], leny[100000];\nvector<int>X[100000], Y[100000];\nstruct st {\n\tint p; bool b; int c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\trep(i, m)X[i] = vector<int>(n/2);\n\trep(i, n)Y[i] = vector<int>(m/2);\n\t\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]][lenx[x[i]]++] = i; Y[y[i]][leny[y[i]]++] = i;\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\trep(i, lenx[x[p.p]]) {\n\t\t\tint u = X[x[p.p]][i];\n\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t}\n\t\t}\n\t\trep(i, leny[y[p.p]]) {\n\t\t\tint u = Y[y[p.p]][i];\n\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, lenx[m - 1]) {\n\t\tint u = X[m - 1][i];\n\t\tMin = min(Min, d[u][1] + abs(y[u] - n + 1));\n\t}\n\trep(i, leny[n - 1]) {\n\t\tint u = Y[n - 1][i];\n\t\tMin = min(Min, d[u][0] + abs(x[u] - m + 1));\n\t}\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\nstruct state{\n  int pos,flg,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<P> t[MAX][2];\nint W,H,K,X[MAX],Y[MAX];\nint d[MAX][2];\nvector<edge> G[MAX][2];\n\nint solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=1e9;\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( (state){ p.second, 0, p.first-1 } );\n  d[p.second][0]=p.first-1;\n  \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        int ncost=s.cost+e.cost+f;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push((state){e.to,nf,ncost});\n        }\n      }\n    }\n  }\n  int res=min(d[K][0],d[K][1]);\n  if(res==1e9)return -1;\n  else return res;\n}\n      \nint main(){\n  scanf(\"%d %d %d\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( (edge){q.second,p.first-q.first} );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( (edge){q.second,q.first-p.first} );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<queue>\n#include<tuple>\nusing namespace std;\n#pragma warning(disable:4996)\nlong long a[240000], b[240000], dist[240000][2], H, W, K;\nvector<pair<int, int>>X[120000], Y[120000];\nvector<tuple<long long, long long, long long>>x[240000][2];\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>>Q;\nvoid dijkstra() {\n\tfor (int i = 0; i < 240000; i++) { dist[i][0] = 999999999999999999LL; dist[i][1] = 999999999999999999LL; }\n\tdist[0][0] = 0; Q.push(make_tuple(0, 0, 0));\n\twhile (!Q.empty()) {\n\t\tlong long a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\tfor (int i = 0; i < x[a2][a3].size(); i++) {\n\t\t\tlong long to1 = get<0>(x[a2][a3][i]), to2 = get<1>(x[a2][a3][i]), cost = get<2>(x[a2][a3][i]);\n\t\t\tif (dist[to1][to2] > a1 + cost) {\n\t\t\t\tdist[to1][to2] = a1 + cost; Q.push(make_tuple(dist[to1][to2], to1, to2));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> H >> W >> K; X[1].push_back(make_pair(1, 0)); Y[1].push_back(make_pair(1, 0));\n\tX[H].push_back(make_pair(W, K + 1)); Y[W].push_back(make_pair(H, K + 1));\n\tfor (int i = 1; i <= K; i++) { scanf(\"%d%d\", &a[i], &b[i]); X[a[i]].push_back(make_pair(b[i], i)); Y[b[i]].push_back(make_pair(a[i], i)); }\n\tfor (int i = 1; i <= H; i++) { sort(X[i].begin(), X[i].end()); }\n\tfor (int i = 1; i <= W; i++) { sort(Y[i].begin(), Y[i].end()); }\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\tint G1 = X[i][j].first, G2 = X[i][j].second;\n\t\t\tif (G2 != 0 && G2 != K + 1) { x[G2][0].push_back(make_tuple(G2, 1, 1)); x[G2][1].push_back(make_tuple(G2, 0, 1)); }\n\t\t\tif (j != X[i].size() - 1) {\n\t\t\t\tint G3 = X[i][j + 1].first, G4 = X[i][j + 1].second;\n\t\t\t\tx[G2][0].push_back(make_tuple(G4, 0, abs(G1 - G3))); x[G4][0].push_back(make_tuple(G2, 0, abs(G1 - G3)));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; i++) {\n\t\tfor (int j = 0; j < Y[i].size(); j++) {\n\t\t\tint G1 = Y[i][j].first, G2 = Y[i][j].second;\n\t\t\tif (G2 != 0 && G2 != K + 1) { x[G2][0].push_back(make_tuple(G2, 1, 1)); x[G2][1].push_back(make_tuple(G2, 0, 1)); }\n\t\t\tif (j != Y[i].size() - 1) {\n\t\t\t\tint G3 = Y[i][j + 1].first, G4 = Y[i][j + 1].second;\n\t\t\t\tx[G2][1].push_back(make_tuple(G4, 1, abs(G1 - G3))); x[G4][1].push_back(make_tuple(G2, 1, abs(G1 - G3)));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\tlong long ans = min(dist[K + 1][0], dist[K + 1][1]);\n\tif (ans >= 999999999999999LL)ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n#define fi first\n#define se second\nconst int inf = 1e18;\ntypedef pair<int,int> P;\n\nvector<P> x[200001], y[200001], G[400010];\npriority_queue<P, vector<P>, greater<P> > q;\nint d[400010];\nsigned main(){\n\tint w, h, n;\n\tfill(d, d+400010, inf);\n\tscanf(\"%lld%lld%lld\", &w, &h, &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint yy, xx;\n\t\tscanf(\"%lld%lld\", &xx, &yy);\n\t\tx[xx].push_back(P(yy, i));\n\t\ty[yy].push_back(P(xx, i));\n\t}\n\tx[1].push_back(P(1, 0));\n\tx[w].push_back(P(h, n+1));\n\ty[h].push_back(P(w, n+1));\n\tn++;\n\t\n\tfor(int i = 1;i <= w;i++){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j = 1;j < x[i].size();j++){\n\t\t\tint from = x[i][j-1].se, to = x[i][j].se;\n\t\t\tint cost = x[i][j].fi-x[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= h;i++){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j = 1;j < y[i].size();j++){\n\t\t\tint from = y[i][j-1].se+n, to = y[i][j].se+n;\n\t\t\tint cost = y[i][j].fi-y[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= n-1;i++){\n\t\tG[i].push_back(P(i+n, 1));\n\t\tG[i+n].push_back(P(i, 1));\n\t}\n\t\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i].fi;\n\t\t\tint cost = G[from][i].se;\n\t\t\tif(d[from]+cost < d[to]){\n\t\t\t\td[to] = d[from]+cost;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*printf(\"\\n\");\n\tfor(int i = 0;i < 10;i++){\n\t\tfor(int j = 0;j < G[i].size();j++)\n\t\tprintf(\"%d %d %d\\n\", i, G[i][j].fi, G[i][j].se);\n\t}*/\n\t\n\tint ans = min(d[n], d[2*n]);\n\tif(ans == inf)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\t//printf(\"%d\\n\", n);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,pair<int,int> > P;\ntypedef pair<pair<int,int>,bool> PP;\n\nstruct edge{\n\tint to,cost;\n\tbool type;\n};\n\nint k,d[200002];\nconst int inf=1<<14;\nvector<edge> g[200002];\n\nbool operator<(PP p1,PP p2){\n\treturn p1.first.second>p2.first.second;\n}\n\nbool operator>(PP p1,PP p2){\n\treturn p1.first.second<p2.first.second;\n}\n\nvoid dijkstra(void){\n\tpriority_queue<PP> q;\n\td[0]=0;\n\tq.push(PP (pair<int,int> (0,0),true));\n\twhile(!q.empty()){\n\t\tint v=q.top().first.first,c=q.top().first.second;\n\t\tbool t=q.top().second;\n\t\tq.pop();\n\t\tif(c>d[v]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<g[v].size();++i){\n\t\t\tint D,w=g[v][i].to;\n\t\t\tif(g[v][i].type!=t){\n\t\t\t\tD=g[v][i].cost+c+1;\n\t\t\t}else{\n\t\t\t\tD=g[v][i].cost+c;\n\t\t\t}\n\t\t\tif(D<d[w]){\n\t\t\t\td[w]=D;\n\t\t\t\tq.push(PP (pair<int,int> (w,d[w]),g[v][i].type));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool comp1(P p1,P p2){\n\treturn p1.second.first<p2.second.first;\n}\nbool comp2(P p1,P p2){\n\treturn p1.second.second<p2.second.second;\n}\n\nint main() {\n\tint m,n;\n\tP p[200002];\n\tcin>>m>>n>>k;\n\t++k;++k;\n\tp[0]=P (0,pair<int,int> (1,1));\n\tfor(int i=1;i<k-1;++i){\n\t\tcin>>p[i].second.first;\n\t\tcin>>p[i].second.second;\n\t\tp[i].first=i;\n\t}\n\tp[k-1]=P (k-1,pair<int,int>(m,n));\n\tsort(p,p+k,comp1);\n\tfor(int i=0;i<k;++i){\n\t\tif(p[i].second.first==p[i+1].second.first){\n\t\t\tedge e={p[i+1].first,max(p[i+1].second.second-p[i].second.second,p[i].second.second-p[i+1].second.second),true};\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tsort(p,p+k,comp2);\n\tfor(int i=1;i<k;++i){\n\t\tif(p[i].second.second==p[i+1].second.second){\n\t\t\tedge e={p[i+1].first,max(p[i+1].second.first-p[i].second.first,p[i].second.first-p[i+1].second.first),false};\n\t\t\tg[p[i].first].push_back(e);\n\t\t\te.to=p[i].first;\n\t\t\tg[p[i+1].first].push_back(e);\n\t\t}\n\t}\n\tfill(d,d+k,inf);\n\tdijkstra();\n\tif(d[k-1]==inf){\n\t\tcout<<-1<<endl;\n\t}else{\n\t\tcout<<d[k-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tif(flg){\n\t\t\t\t\tres=min(res,no.d-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflg=true;\n\t\t\t\t\tres=no.d-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!sag.empty()){\n\t\t\t\tno2=sag.top();sag.pop();\n\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[10000000], y[10000000];\nconst ll inf = 9000000000000000000;\nll dp[20000000][2];\nll solve(ll i, ll j, short c) {\n\tll sum = inf;\n\tif (c == 1) {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tll l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tif (l[0] != -1) {\n\t\tsum = min(solve(1, l[0], 1), 1 + solve(1, l[1], 0));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tsum = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tif(res[1-yota][saki]==INF){\n\t\t\t\tque.push(ppa(dis+1+abs(swi[1-yota][ten]-ba),pa(1-yota,saki)));\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef pair<pii,int> piii;\nconst ll INF = 1000000000000;\n\nint m,n,k;\nvector<pii> G[400004];\npiii p[200002],q[200002];\nint d[400004];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\n\nint main(){\n\tscanf(\"%d %d %d\",&m,&n,&k);\n\tfor(int i=0;i<k;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1] = piii(pii(x,y),i+1);\n\t\tq[i+1] = piii(pii(y,x),i+1);\n\t}\n\tp[0] = q[0] = piii(pii(1,1),0);\n\tp[k+1] = piii(pii(m,n),k+1);\n\tq[k+1] = piii(pii(n,m),k+1);\n\tsort(p,p+k+2);\n\tsort(q,q+k+2);\n\tfor(int i=0;i<k+2;i++){\n\t\tif(i!=0&&i!=k+1){\n\t\t\tG[i].push_back(pii(i+k+2,1));\n\t\t\tG[i+k+2].push_back(pii(i,1));\n\t\t}\n\t\tif(i<k+1){\n\t\t\tif(p[i].first.first==p[i+1].first.first){\n\t\t\t\tG[p[i].second].push_back(pii(p[i+1].second,p[i+1].first.second-p[i].first.second));\n\t\t\t\tG[p[i+1].second].push_back(pii(p[i].second,p[i+1].first.second-p[i].first.second));\n\t\t\t}\n\t\t\tif(q[i].first.first==q[i+1].first.first){\n\t\t\t\tG[q[i].second+k+2].push_back(pii(q[i+1].second+k+2,q[i+1].first.second-q[i].first.second));\n\t\t\t\tG[q[i+1].second+k+2].push_back(pii(q[i].second+k+2,q[i].first.second-q[i].first.second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(d,d+400004,INF);\n\td[0] = 0;\n\tpq.push(pii(0,0));\n\twhile(!pq.empty()){\n\t\tint v = pq.top().second, dist = pq.top().first;\n\t\tpq.pop();\n\t\tif(dist>d[v]) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv = G[v][i].first, cost = G[v][i].second;\n\t\t\tif(d[nv]>d[v]+cost){\n\t\t\t\td[nv] = d[v] + cost;\n\t\t\t\tpq.push(pii(d[nv],nv));\n\t\t\t}\n\t\t}\n\t}\n\tll ans = min(d[k+1],d[2*k+3]);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\n#define int long long\n#define INF LLONG_MAX/3\nusing namespace std;\n\nvector<P>rinsetu[1000000];//cost to\nint mincost[1000000];\nsigned main() {\n\tint a, b, c; cin >> b >> a >> c; a--; b--;\n\tmap<int, vector<P>>n, m;\n\tfor (int d = 0; d < c; d++) {\n\t\tint e, f; scanf(\"%lld%lld\", &f, &e); e--; f--;\n\t\tn[e].push_back(P(f,d*2));\n\t\tm[f].push_back(P(e,d*2+1));\n\t\trinsetu[d*2].push_back(P(1,d*2+1));\n\t\trinsetu[d*2+1].push_back(P(1,d*2));\n\t}\n\tm[0].push_back(P(0,c*2));\n\tn[a].push_back(P(b,c*2+1));\n\tm[b].push_back(P(a,c*2+1));\n\tfor (auto k = n.begin(); k != n.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first-r[ttt-1].first,r[ttt-1].second));\n\t\t\t\trinsetu[r[ttt-1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto k = m.begin(); k != m.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt - 1].second));\n\t\t\t\trinsetu[r[ttt - 1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(mincost, mincost + c * 2 + 2, INF);\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tmincost[c * 2] = 0;\n\tQ.push(P(0,c*2));\n\twhile (Q.size()) {\n\t\tP t = Q.top(); Q.pop();\n\t\tif (t.first > mincost[t.second])continue;\n\t\tfor (P i : rinsetu[t.second]) {\n\t\t\tif (mincost[i.second] > mincost[t.second] + i.first) {\n\t\t\t\tmincost[i.second] = mincost[t.second] + i.first;\n\t\t\t\tQ.push(P(mincost[i.second],i.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (mincost[c * 2 + 1] == INF)puts(\"-1\");\n\telse cout << mincost[c * 2 + 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define INF (1LL<<60)\ntypedef pair<int, int> P;\n\nint M, N, K;\nP T[200010];\nlong long D[200010];\nvector<int> xs[100010], ys[100010];\n\nint main() {\n  cin >> M >> N >> K;\n\n  T[0] = P(M, N);\n  xs[M].push_back(0);\n  ys[N].push_back(0);\n\n  for (int i=1; i<K+1; i++) {\n    int x, y;\n    cin >> x >> y;\n    T[i] = P(x, y);\n    if (x != M || y != N) {\n      xs[x].push_back(i);\n      ys[y].push_back(i);\n    }\n  }\n\n  for (int i=0; i<K+1; i++) D[i] = INF;\n\n  queue<P> q;\n  for (int i : xs[1]) {\n    D[i] = T[i].second - 1;\n    q.push(P(i, 0));\n  }\n\n  while (!q.empty()) {\n    int s = q.front().first, d = q.front().second; q.pop();\n    P p = T[s];\n\n    if (d == 1) {\n      for (int i : xs[p.first]) {\n        if (i == s) continue;\n        P t = T[i];\n        long long l = abs(t.second - p.second) + 1LL;\n        if (D[i] > D[s] + l) {\n          D[i] = D[s] + l;\n          q.push(P(i, 0));\n        }\n      }\n    }\n    else {\n      for (int i : ys[p.second]) {\n        if (i == s) continue;\n        P t = T[i];\n        long long l = abs(t.first - p.first) + 1LL;\n        if (D[i] > D[s] + l) {\n          D[i] = D[s] + l;\n          q.push(P(i, 1));\n        }\n      }\n    }\n  }\n\n  cout << (D[0] != INF ? D[0] : -1) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nll abs(ll a) {\n  return a >= 0 ? a : -a;\n}\n\nll min(ll a, ll b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, m, n, x, y, sm = 1, l;\n  ll inf = 10e15;\n  scanf(\"%d%d%d\", &m, &n, &k);\n  vector< pair<int, int> > node[k + 2];\n  vector< pair<int, int> > vec1[m], vec2[n];\n  vec1[0].push_back(make_pair(0, 0));\n  vec1[m - 1].push_back(make_pair(n - 1, k + 1)), vec2[n - 1].push_back(make_pair(m - 1, k + 1));\n  for(i = 1; i <= k; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    x--, y--;\n    vec1[x].push_back(make_pair(y, i));\n    vec2[y].push_back(make_pair(x, i));\n  }\n  for(i = 0; i < m; ++i) {\n    for(j = 0; j < vec1[i].size(); ++j) for(l = 0; l < vec1[i].size(); ++l) if(j != l) {\n      node[vec1[i][j].second].push_back(make_pair(abs(vec1[i][j].first - vec1[i][l].first) + (vec1[i][l].second == k + 1 ? 0 : 1), vec1[i][l].second));\n    }\n  }\n  for(i = 0; i < n; ++i) {\n    for(j = 0; j < vec2[i].size(); ++j) for(l = 0; l < vec2[i].size(); ++l) if(j != l) {\n      node[vec2[i][j].second].push_back(make_pair(abs(vec2[i][j].first - vec2[i][l].first) + (vec2[i][l].second == k + 1 ? 0 : 1), vec2[i][l].second));\n    }\n  }\n  for(i = 0; i < m; ++i) vector< pair<int, int> >().swap(vec1[i]);\n  for(i = 0; i < n; ++i) vector< pair<int, int> >().swap(vec2[i]);\n  while(sm < k + 2) sm *= 2;\n  pair<ll, ll> seg[sm * 2 + 1];\n  ll dis[k + 2];\n  char flag[k + 2];\n  for(i = 0; i < k + 2; ++i) dis[i] = inf, flag[i] = 1;\n  dis[0] = 0, flag[0] = 0;\n  for(i = 0; i <= 2 * sm; ++i) seg[i].first = inf, seg[i].second = i - sm;\n  seg[1].second = 0;\n  int now = 0;\n  while( 1 ) {\n    int tmp;\n    for(i = 0; i < node[now].size(); ++i) {\n      if(flag[node[now][i].second] && dis[node[now][i].second] > dis[now] + node[now][i].first) {\n        dis[node[now][i].second] = dis[now] + node[now][i].first;\n        seg[node[now][i].second + sm].first = dis[now] + node[now][i].first;\n        tmp = node[now][i].second + sm;\n        tmp /= 2;\n        while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n      }\n    }\n    if(!flag[seg[1].second]) {\n      dis[k + 1] = -1;\n      break;\n    } else {\n      if(seg[1].second == k + 1) break;\n      flag[seg[1].second] = 0;\n      now = seg[1].second;\n      seg[seg[1].second + sm].first = inf;\n      ll tmp = seg[1].second + sm;\n      tmp /= 2;\n      while(tmp) seg[tmp] = min(seg[tmp * 2], seg[tmp * 2 + 1]), tmp /= 2;\n    }\n  }\n  printf(\"%lld\\n\", dis[k + 1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nusing Weight = long long int;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint tate;\n\tEdge(int src_, int dst_, Weight weight_,bool a) :\n\t\tsrc(src_), dst(dst_), weight(weight_),tate(a) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nstruct Node {\n\tint x;\n\tint y;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint tate;\n\tWeight time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nWeight getans(vector<vector<Edge>>&g, const bool startswitch,int s,int t) {\n\tpriority_queue<aa,vector<aa>,Compare>que;\n\tque.push(aa{ 0,true,0 });\n\tif (startswitch) {\n\t\tque.push(aa{ 0,false,1 });\n\t}\n\tvector<vector<Weight>>memo(g.size(), vector<Weight>(2,1e18));\n\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tif (atop.id == t)return atop.time;\n\t\tque.pop();\n\t\tif (atop.id) {\n\t\t\tif (memo[atop.id][!atop.tate]>atop.time+1) {\n\t\t\t\tmemo[atop.id][!atop.tate] = atop.time + 1;\n\t\t\t\tque.push(aa{ atop.id,!atop.tate,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tfor (auto e : g[atop.id]) {\n\t\t\tif (e.tate != atop.tate)continue;\n\t\t\tconst Weight nexttime = atop.time + e.weight;\n\t\t\tif (memo[e.dst][e.tate] > nexttime) {\n\t\t\t\tmemo[e.dst][e.tate] = nexttime;\n\t\t\t\tque.push(aa{ e.dst,e.tate,nexttime });\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\tint M, N, K; cin >> M >> N >> K;\n\tvector<Node>ps;\n\tbool startswitch = false;\n\tint id = 0;\n\tps.push_back(Node{ 0,0,id++ });\n\tfor (int i = 0; i < K; ++i) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tif (x == 0 && y == 0) {\n\t\t\tstartswitch = true;\n\t\t}\n\t\telse if (x == M-1&&y == N-1) {\n\n\t\t}\n\t\telse {\n\t\t\tps.push_back(Node{ x,y,id++ });\n\t\t}\n\t}\n\tps.push_back(Node{ M-1,N-1,id });\n\tvector<vector<Edge>>g(K + 2);\n\tsort(ps.begin(), ps.end(), [](const Node&l, const Node&r) {\n\t\treturn l.x == r.x ? l.y < r.y : l.x < r.x;\n\t});\n\tfor (int i = 0; i < ps.size() - 1; ++i) {\n\t\tNode l = ps[i];\n\t\tNode r = ps[i + 1];\n\t\tif (l.x == r.x) {\n\t\t\tWeight dis = abs(r.y - l.y); \n\t\t\tg[l.id].push_back(Edge(l.id, r.id, dis, true));\n\t\t\tg[r.id].push_back(Edge(r.id, l.id, dis, true));\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end(), [](const Node&l, const Node&r) {\n\t\treturn l.y == r.y ? l.x < r.x : l.y < r.y;\n\t});\n\tfor (int i = 0; i < ps.size() - 1; ++i) {\n\t\tNode l = ps[i];\n\t\tNode r = ps[i + 1];\n\t\tif (l.y == r.y) {\n\t\t\tWeight dis = abs(r.x - l.x);\n\t\t\tg[l.id].push_back(Edge(l.id, r.id, dis, false));\n\t\t\tg[r.id].push_back(Edge(r.id, l.id, dis, false));\n\t\t}\n\t}\n\tlong long int ans = getans(g,startswitch,0,id);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stdio.h>\n#include<utility>\n\nusing namespace std;\n\n#define MAX_N 100000\n#define MAX_M 100000\n#define INF 1000000\n\ntypedef pair<int, int> coord; //??§?¨?\ntypedef pair<coord, int> P; //??§?¨??????????\n\nbool s[MAX_M][MAX_N];  //????????????????????????????????? \nint M, N, K;\nint d[MAX_M][MAX_N][2]; // ???????????¢, ????????????, ????????±?\\?\n\nint main()\n{\n\tscanf(\"%d %d %d\", &M, &N, &K);\n\t//s[][], d[][][]????????????\n\tfor (int i = 0; i < M ; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ts[i][j] = false;\n\t\t\td[i][j][0] = INF;\n\t\t\td[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ts[x - 1][y - 1] = true;\n\t}\n\n\tqueue<P> que;\n\tque.push(P(coord(0, 0), 0));\n\td[0][0][0] = 0;\n\twhile (que.size()) {\n\t\tP p = que.front(); que.pop();\n\t\tint x = p.first.first;\n\t\tint y = p.first.second;\n\t\tif (p.second = 0) {\n\t\t\tif (s[x][y] == true && d[x][y][1] == INF) {\n\t\t\t\td[x][y][1] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y), 1));\n\t\t\t}\n\t\t\tif (y > 0 && d[x][y - 1][0] == INF) {\n\t\t\t\td[x][y - 1][0] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y - 1), 0));\n\t\t\t}\n\t\t\tif (y < N - 1 && d[x][y + 1][0] == INF) {\n\t\t\t\td[x][y + 1][0] = d[x][y][0] + 1;\n\t\t\t\tque.push(P(coord(x, y + 1), 0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (s[x][y] == true && d[x][y][0] == INF) {\n\t\t\t\td[x][y][0] = d[x][y][1] + 1;\n\t\t\t\tque.push(P(coord(x, y), 0));\n\t\t\t}\n\t\t\tif (x > 0 && d[x - 1][y][1] == INF) {\n\t\t\t\td[x - 1][y][1] = d[x - 1][y][1] + 1;\n\t\t\t\tque.push(P(coord(x - 1, y), 1));\n\t\t\t}\n\t\t\tif (x < M - 1 && d[x + 1][y][1] == INF) {\n\t\t\t\td[x + 1][y][1] = d[x][y][1] + 1;\n\t\t\t\tque.push(P(coord(x + 1, y), 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = d[M - 1][N - 1][0];\n\tif (ans > d[M - 1][N - 1][1]) ans = d[M - 1][N -1][1];\n\tif (ans == INF) ans = -1;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nstruct data{\n    int v,c,d;\n    data(int v,int c,int d):v(v),c(c),d(d){}\n    bool operator<(const data &d)const{\n        return c>d.c;\n    }\n};\n\nconst int SIZE=200000;\nconst int INF=1001001001001001001LL;\nint W,H,K;\nint X[SIZE],Y[SIZE];\n\nvpint row[SIZE],col[SIZE];\n\nint to[SIZE][4];\nint cost[SIZE][4];\n\nint dist[SIZE][2];\n\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n\n    cin>>W>>H>>K;\n    rep(i,K){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n        row[Y[i]].pb(pint(X[i],i));\n        col[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(col[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,(int)row[i].size()-1){\n            pint &v=row[i][j],&u=row[i][j+1];\n            to[v.se][1]=u.se;cost[v.se][1]=u.fi-v.fi;\n            to[u.se][3]=v.se;cost[u.se][3]=u.fi-v.fi;\n        }\n    }\n    rep(i,W){\n        rep(j,(int)col[i].size()-1){\n            pint &v=col[i][j],&u=col[i][j+1];\n            to[v.se][2]=u.se;cost[v.se][2]=u.fi-v.fi;\n            to[u.se][0]=v.se;cost[u.se][0]=u.fi-v.fi;\n        }\n    }\n\n    if(col[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n\n    pint start=col[0][0];\n    fill_n(*dist,SIZE*2,INF);\n    dist[start.se][0]=start.fi;\n    priority_queue<data>que;\n    que.push(data(start.se,start.fi,0));\n\n    while(que.size()){\n        data d=que.top();que.pop();\n        if(dist[d.v][d.d]<d.c)continue;\n        if(dist[d.v][1-d.d]>d.c+1){\n            dist[d.v][1-d.d]=d.c+1;\n            que.push(data(d.v,d.c+1,1-d.d));\n        }\n\n        rep(i,4){\n            if(i%2!=d.d)continue;\n            int t=to[d.v][i],c=cost[d.v][i];\n            if(t==-1)continue;\n            if(dist[t][d.d]<=d.c+c)continue;\n            dist[t][d.d]=d.c+c;\n            que.push(data(t,d.c+c,d.d));\n        }\n    }\n\n    int mi=INF;\n\n    rep(i,K){\n        if(X[i]==W-1){\n            chmin(mi,dist[i][0]+H-1-Y[i]);\n        }\n        if(Y[i]==H-1){\n            chmin(mi,dist[i][1]+W-1-X[i]);\n        }\n    }\n\n    cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define F first\n#define S second\n#define pb push_back\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define INF 1 << 28\n#define LLINF 1LL << 60\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> Ti;\n\nstruct Edge {\n  int to, cost;\n};\n\nint sz[2], K;\nvector<Edge> G[2][200005];\nint mc[2][200005];\n\nvoid Dijkstra()\n{\n  priority_queue<Ti, vector<Ti>, greater<Ti> >pq;\n  mc[0][0] = 0;\n  pq.push(Ti(0, Pi(0, 0)));\n  while(!pq.empty()) {\n    int v = pq.top().S.F, w = pq.top().F, t = pq.top().S.S; pq.pop();\n    if(w > mc[t][v]) continue;\n    Rep(i, G[t][v].size()) {\n      int u = G[t][v][i].to, nw = G[t][v][i].cost + w, nnw = nw;\n      if(u != K + 1) nnw++;\n      if(nnw < mc[1 - t][u]) {\n\tmc[1 - t][u] = nnw;\n\tpq.push(Ti(nnw, Pi(u, 1 - t)));\n      }\n      if(nw < mc[t][u]) {\n\tmc[t][u] = nw;\n\tpq.push(Ti(nw, Pi(u, t)));\n      }\n    }\n  }\n}\n\t  \nsigned main()\n{\n  int X, Y;\n  vector<Pi> len[2][100006];\n\n  cin >> sz[0] >> sz[1] >> K;\n  len[0][1].pb(Pi(0, 0));\n  for(int i = 1; i <= K; i++) {\n    cin >> X >> Y;\n    len[0][X].pb(Pi(Y, i));\n    len[1][Y].pb(Pi(X, i));\n  }\n  len[0][sz[0]].pb(Pi(sz[1], K + 1));\n  len[1][sz[1]].pb(Pi(sz[0], K + 1));\n  \n  Rep(i, 2) {\n    Rep(j, sz[i] + 1) {\n      sort(len[i][j].begin(), len[i][j].end());\n      Rep(k,len[i][j].size()) {\n\tPi v = len[i][j][k];\n\tif(k - 1 >= 0) {\n\t  Pi u = len[i][j][k - 1];\n\t  G[i][v.S].pb((Edge){ u.S, v.F - u.F });\n\t}\n\tif(k + 1 < len[i][j].size()) {\n\t  Pi u = len[i][j][k + 1];\n\t  G[i][v.S].pb((Edge){ u.S, u.F - v.F });\n\t}\n      }\n    }\n  }\n\n  fill_n(*mc, 2 * 200005, LLINF);\n  Dijkstra();\n  \n  int ans = min(mc[0][K + 1], mc[1][K + 1]);\n  if(ans == LLINF) cout << -1 << endl;\n  else cout << ans - 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint n, m, k;\ntypedef pair<int, int> P;\nvector<P> x[100001], y[100001];\nvector<P> g[400005];\nint INF = 1e9+7;\nbool f;\nint d[400005];\npriority_queue<P, vector<P>, greater<P> > q;\n\nint main(){\n\tscanf(\"%d %d %d\", &m, &n, &k);\n\tfor(int i=0; i<k; ++i){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tif((a + b != n + m) || (a + b != 2)){\n\t\t\tx[a].push_back(P(b, i+1));\n\t\t\ty[b].push_back(P(a, i+1));\n\t\t}else if(a + b == 2) f = true;\n\t}\n\tx[1].push_back(P(1, k+1));\n\ty[1].push_back(P(1, k+1));\n\tx[m].push_back(P(n, k+2));\n\ty[n].push_back(P(m, k+2));\n/*\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=m; ++i)\n\t\tfor(int j=0; j<x[i].size(); ++j)\n\t\t\tprintf(\"x=%d %dth y=%d %dth\\n\", i, j, x[i][j].first, x[i][j].second);\n\tprintf(\"\\n\");\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<y[i].size(); ++j)\n\t\t\tprintf(\"%d %d %d %d\\n\", i, j, y[i][j].first, y[i][j].second);\n\tprintf(\"\\n\");\n*/\n\n\tfor(int i=1; i<=m; ++i){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j=0; j+1<x[i].size(); ++j){\n\t\t\tg[x[i][j].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j+1].second));\n\t\t\tg[x[i][j+1].second].push_back(P(x[i][j+1].first-x[i][j].first, x[i][j].second));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=n; ++i){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j=0; j+1<y[i].size(); ++j){\n\t\t\tg[y[i][j].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j+1].second+k+2));\n\t\t\tg[y[i][j+1].second+k+2].push_back(P(y[i][j+1].first-y[i][j].first, y[i][j].second+k+2));\n\t\t}\n\t}\n\n\tfor(int i=1; i<=k; ++i){\n\t\tg[i].push_back(P(1, i+k+2));\n\t\tg[i+k+2].push_back(P(1, i));\n\t}\n\tg[k+1].push_back(P(1, 2*k+3));\n\tg[2*k+3].push_back(P(1, k+1));\n\tg[k+2].push_back(P(1, 2*k+4));\n\tg[2*k+4].push_back(P(1, k+2));\n/*\n\tfor(int i=1; i<=2*k+4; ++i){\n\t\t\n\t\tfor(int j=0; j<g[i].size(); ++j){\n\t\t\tprintf(\"cost=%d to=%d\\n\", g[i][j].first, g[i][j].second);\n\t\t}\n\t}\n*/\n\tfill(d+1, d+2*k+5, INF);\n\td[k+1] = 0;\n\tif(f) d[2*k+3] = 1;\n\tq.push(P(0, k+1));\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i=0; i<g[v].size(); ++i){\n\t\t\tif(d[g[v][i].second] > d[v] + g[v][i].first){\n\t\t\t\td[g[v][i].second] = d[v] + g[v][i].first;\n\t\t\t\tq.push(P(d[g[v][i].second], g[v][i].second));\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"\\n\");\n\tfor(int i=1; i<=2*k+4; ++i) printf(\"%d\\n\", d[i]);\n\tprintf(\"\\n\");\n*/\tint ans = min(d[k+2], d[2*k+4]);\n\tif(ans == INF) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nstruct data{\n    int v,c,d;\n    data(int v,int c,int d):v(v),c(c),d(d){}\n    bool operator<(const data &d)const{\n        return c>d.c;\n    }\n};\n\nconst int SIZE=200000;\nconst int INF=1001001001001001001LL;\nint W,H,K;\nint X[SIZE],Y[SIZE];\n\nvpint row[SIZE],col[SIZE];\n\nint to[SIZE][4];\nint cost[SIZE][4];\n\nint dist[SIZE][2];\n\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n\n    cin>>W>>H>>K;\n    rep(i,K){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n        row[Y[i]].pb(pint(X[i],i));\n        col[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(col[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,(int)row[i].size()-1){\n            pint &v=row[i][j],&u=row[i][j+1];\n            to[v.se][1]=u.se;cost[v.se][1]=u.fi-v.fi;\n            to[u.se][3]=v.se;cost[u.se][3]=u.fi-v.fi;\n        }\n    }\n    rep(i,W){\n        rep(j,(int)col[i].size()-1){\n            pint &v=col[i][j],&u=col[i][j+1];\n            to[v.se][2]=u.se;cost[v.se][2]=u.fi-v.fi;\n            to[u.se][0]=v.se;cost[u.se][0]=u.fi-v.fi;\n        }\n    }\n\n    if(col[0].size()==0){\n        cout<<-1<<endl;\n        return 0;\n    }\n\n    pint start=col[0][0];\n    fill_n(*dist,SIZE*2,INF);\n    dist[start.se][0]=start.fi;\n    priority_queue<data>que;\n    que.push(data(start.se,start.fi,0));\n\n    while(que.size()){\n        data d=que.top();que.pop();\n        if(dist[d.v][d.d]<d.c)continue;\n        if(dist[d.v][1-d.d]>d.c+1){\n            dist[d.v][1-d.d]=d.c+1;\n            que.push(data(d.v,d.c+1,1-d.d));\n        }\n\n        rep(i,4){\n            if(i%2!=d.d)continue;\n            int t=to[d.v][i],c=cost[d.v][i];\n            if(t==-1)continue;\n            if(dist[t][d.d]<=d.c+c)continue;\n            dist[t][d.d]=d.c+c;\n            que.push(data(t,d.c+c,d.d));\n        }\n    }\n    int mi=INF;\n\n    rep(i,K){\n        if(X[i]==W-1){\n            chmin(mi,dist[i][0]+H-1-Y[i]);\n        }\n        if(Y[i]==H-1){\n            chmin(mi,dist[i][1]+W-1-X[i]);\n        }\n    }\n    \n    if(mi==INF)cout<<-1<<endl;\n    else cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int INF=1001001001001001001ll;\n\nint H,W,K;\nint X[200000],Y[200000];\n\nvpint row[100000],column[100000];\n\nint to[200000][4];\nint dist[200000][2];\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&K);\n    rep(i,K)scanf(\"%lld%lld\",&X[i],&Y[i]),X[i]--,Y[i]--;\n\n    rep(i,K){\n        row[Y[i]].pb(pint(X[i],i));\n        column[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(column[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,row[i].size()){\n            if(j)to[row[i][j].se][3]=row[i][j-1].se;\n            if(j+1!=row[i].size())to[row[i][j].se][1]=row[i][j+1].se;\n        }\n    }\n\n    rep(i,W){\n        rep(j,column[i].size()){\n            if(j)to[column[i][j].se][0]=column[i][j-1].se;\n            if(j+1!=column[i].size())to[column[i][j].se][2]=column[i][j+1].se;\n        }\n    }\n\n    if(column[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    int start=column[0][0].se;\n    fill_n(*dist,200000*2,INF);\n    dist[start][0]=Y[start];\n    priority_queue<pair<int,pint> >que;\n    que.push(mp(Y[start],pint(start,0)));\n\n    while(que.size()){\n        int c=que.top().fi;\n        int v=que.top().se.fi;\n        int d=que.top().se.se;\n        que.pop();\n        if(dist[v][d]<c)continue;\n\n        if(dist[v][1-d]>c+1){\n            dist[v][1-d]=c+1;\n            que.push(mp(dist[v][1-d],pint(v,1-d)));\n        }\n\n        rep(i,4){\n            if(to[v][i]==-1)continue;\n            if(i%2!=d)continue;\n            int u=to[v][i];\n            int cost=abs(X[v]-X[u])+abs(Y[v]-Y[u]);\n            if(dist[u][d]<=c+cost)continue;\n            dist[u][d]=c+cost;\n            que.push(mp(dist[u][d],pint(u,d)));\n        }\n    }\n\n    int ans=INF;\n    rep(i,K){\n        //cout<<i<<\" \"<<dist[i][0]<<\" \"<<dist[i][1]<<endl;\n        if(X[i]!=W-1&&Y[i]!=H-1)continue;\n        rep(j,2){\n            int cost=abs(X[i]-W+1)+abs(Y[i]-H+1);\n            if((X[i]==W-1&&j==1)||(Y[i]==H-1&&j==0))cost++;\n            chmin(ans,dist[i][j]+cost);\n        }\n    }\n    if(ans==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){\n\t\n\t}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.t<no2.t;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.t>no2.t;\n}\n\nvector<int> ve[2][100010];\nint XY[2][200010],D[2][200010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tbool fla;\n\tint M,N,K,a,b,npt,res,gon;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfla=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tif(a==M&&b==N){ fla=true;gon=i;}\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tif(!fla){\n\t\tXY[0][K+1]=M;\n\t\tXY[1][K+1]=N;\n\t\tve[0][M].push_back(K+1);\n\t\tve[1][N].push_back(K+1);\n\t\tgon=K+1;\n\t}\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tif(D[no.d][no.n]==-1){\n\t\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<XY[0][no.n]<<\" \"<<XY[1][no.n]<<\" \"<<no.d<<endl;//\n\t\t\tD[no.d][no.n]=no.t;\n\t\t\tif(no.n==gon){\n\t\t\t\tres=no.t-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\t\tif(D[!no.d][*it]==-1&&no.n!=(*it)){\n\t\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define D 100010\nvector<pair<ll,ll> > y_x[D],x_y[D];\nint h,w,n;\n\n#define N 400010\ntypedef pair<ll,ll> P;\nvector<P> v[N];\nll d[N];\npriority_queue<P,vector<P>,greater<P> >Q;\nll Dijkstra(){\n    fill(d,d+N,(ll)mod*(ll)mod);\n    Q.push(make_pair(0,2*n));\n    while(!Q.empty()){\n\tll cost=Q.top().first;\n\tll x=Q.top().second;\n\tQ.pop();\n\tif(d[x]<=cost)continue;\n\td[x]=cost;\n\tfor(auto u:v[x]){\n\t    Q.push(make_pair(cost+u.second,u.first));\n\t}\n    }\n    return (d[2*n+1]==(ll)mod*(ll)mod?-1:d[2*n+1]);\n}\nvoid MakeEdge(ll a,ll b,ll c){\n    v[a].push_back(make_pair(b,c));\n    v[b].push_back(make_pair(a,c));\n}\nint main(){\n    cin>>h>>w>>n;\n    lol(i,n){\n\tll x,y;cin>>y>>x;\n\ty_x[y].push_back(make_pair(x,i));\n\tx_y[x].push_back(make_pair(y,i));\n\tMakeEdge(i,i+n,1);\n    }\n    lol(i,D){\n\tif(y_x[i].size()>0){\n\t    sort(y_x[i].begin(),y_x[i].end());\n\t    if(i==1){\n\t\tMakeEdge(2*n,y_x[i][0].second,y_x[i][0].first-1);\n\t    }\n\t    if(i==h){\n\t\tint t=y_x[i].size()-1;\n\t\tMakeEdge(2*n+1,y_x[i][t].second,w-y_x[i][t].first);\n\t    }\n\t    for(int j=0;j<y_x[i].size()-1;j++){\n\t\tMakeEdge(y_x[i][j].second,y_x[i][j+1].second,y_x[i][j+1].first-y_x[i][j].first);\n\t    }\n\t}\n\tif(x_y[i].size()>0){\n\t    sort(x_y[i].begin(),x_y[i].end());\n\t    if(i==w){\n\t\tint t=x_y[i].size()-1;\n\t\tMakeEdge(2*n+1,x_y[i][t].second+n,h-x_y[i][t].first);\n\t    }\n\t    for(int j=0;j<x_y[i].size()-1;j++){\n\t\tMakeEdge(x_y[i][j].second+n,x_y[i][j+1].second+n,x_y[i][j+1].first-x_y[i][j].first);\n\t    }\n\t}\n    }\n    //cout<<\"#\"<<endl;\n    cout<<Dijkstra()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64, int > Pi;\nconst int64 INF = 1LL << 60;\nstruct edge {\n  int to, cost;\n};\nvector< edge > graph[400004];\nint64 min_cost[400004];\nint H, W, K;\nvector< Pi > X[100001], Y[100001];\n \nint64 Dijkstra()\n{\n  fill_n(min_cost, 400004, INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > Que;\n  min_cost[K - 2] = 0;\n  Que.push(Pi(0, K - 2));\n  while(!Que.empty()) {\n    Pi p = Que.top(); Que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    if(p.second == K - 1) return(p.first);\n    for(auto e : graph[p.second]) {\n      int64 next = p.first + e.cost;\n      if(min_cost[e.to] > next) {\n        min_cost[e.to] = next;\n        Que.push(Pi(next, e.to));\n      }\n    }\n  }\n  return(-1);\n}\n \n \nint main()\n{\n  cin >> W >> H >> K;\n  for(int i = 0; i < K; i++) {\n    int x, y;\n    cin >> x >> y;\n    X[x].push_back(Pi(y, i));\n    Y[y].push_back(Pi(x, i));\n  }\n \n  X[1].push_back(Pi(1, K));\n  Y[1].push_back(Pi(1, K));\n \n  X[W].push_back(Pi(H, K + 1));\n  Y[H].push_back(Pi(W, K + 1));\n \n  K += 2;\n \n  for(int i = 0; i < 100001; i++) {\n    sort(X[i].begin(), X[i].end());\n    sort(Y[i].begin(), Y[i].end());\n    for(int j = 1; j < X[i].size(); ++j) {\n      const Pi &prev = X[i][j - 1], &curr = X[i][j];\n      graph[prev.second].push_back((edge){curr.second, llabs(prev.first - curr.first)});\n      graph[curr.second].push_back((edge){prev.second, llabs(prev.first - curr.first)});\n    }\n    for(int j = 1; j < Y[i].size(); ++j) {\n      const Pi &prev = Y[i][j - 1], &curr = Y[i][j];\n      graph[prev.second + K].push_back((edge){curr.second + K, llabs(prev.first - curr.first)});\n      graph[curr.second + K].push_back((edge){prev.second + K, llabs(prev.first - curr.first)});\n    }\n  }\n \n \n  for(int i = 0; i < K - 2; i++) {\n    graph[i].push_back((edge){i + K, 1});\n    graph[i + K].push_back((edge){i, 1});\n  }\n  graph[K - 1 + K].push_back((edge){K - 1, 0});  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tcout<<\"WA\"<<endl;//\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAX_K = 200002;\n\nstruct Data\n{\n    int v, cost, s;\n    Data() {}\n    Data(int _v, int _cost, int _s) { v = _v; cost = _cost; s = _s; }\n\n    bool operator < (const Data &a) const\n    {\n        return cost > a.cost;\n    }\n};\n\nstruct Edge\n{\n    int to, cost;\n    Edge() {}\n    Edge(int _to, int _cost) { to = _to; cost = _cost; }\n};\n\nint N, M, K, X[MAX_K], Y[MAX_K];\npair<int, int> P[MAX_K];\nvector<Edge> e[MAX_K][2];\n\nvoid GenerateEdge(vector<int> &v, int pos[MAX_K], int s)\n{\n    for (int i = 0; i < v.size(); i++)\n    {\n        if (i > 0) e[v[i]][s].push_back(Edge(v[i - 1], abs(pos[v[i]] - pos[v[i - 1]])));\n        if (i < v.size() - 1) e[v[i]][s].push_back(Edge(v[i + 1], abs(pos[v[i]] - pos[v[i + 1]])));\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> K;\n    map<int, vector<int> > mx, my;\n    for (int i = 1; i <= K; i++)\n    {\n        cin >> P[i].first >> P[i].second;\n    }\n    K += 2;\n    P[0] = make_pair(1, 1);\n    P[K - 1] = make_pair(N, M);\n    sort(P, P + K);\n    for (int i = 0; i < K; i++)\n    {\n        X[i] = P[i].first; Y[i] = P[i].second;\n        mx[X[i]].push_back(i);\n        my[Y[i]].push_back(i);\n    }\n    map<int, vector<int> >::iterator ix = mx.begin(), iy = my.begin();\n    while (ix != mx.end()) GenerateEdge(ix->second, Y, 0), ix++;\n    while (iy != my.end()) GenerateEdge(iy->second, X, 1), iy++;\n\n    priority_queue<Data> pq;\n    pq.push(Data(0, 0, 0));\n    bool isUsed[MAX_K][2] = {};\n    int ans = -1;\n    while (!pq.empty())\n    {\n        Data t = pq.top(); pq.pop();\n        if (t.v == K - 1)\n        {\n            ans = t.cost;\n            break;\n        }\n        if (isUsed[t.v][t.s]) continue;\n        isUsed[t.v][t.s] = true;\n        for (int i = 0; i < e[t.v][t.s].size(); i++)\n        {\n            pq.push(Data(e[t.v][t.s][i].to, t.cost + e[t.v][t.s][i].cost, t.s));\n        }\n        if (t.v != 0) pq.push(Data(t.v, t.cost + 1, 1 - t.s));\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n\tint t,n;\n\tbool d;\n\tnode(){\n\t\n\t}\n\tnode(int tt,int nn,bool dd){\n\t\tt=tt;n=nn;d=dd;\n\t}\n};\n\nbool operator<(const node& no1,const node& no2){\n\treturn no1.t<no2.t;\n}\n\nbool operator>(const node& no1,const node& no2){\n\treturn no1.t>no2.t;\n}\n\nvector<int> ve[2][100010];\nint XY[2][200010],D[2][200010]={};\nint main(){\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tvector<int>::iterator it;\n\tnode no,np;\n\tbool fla;\n\tint M,N,K,a,b,npt,res,gon,hog;\n\tmemset(D[0],-1,sizeof(D[0]));\n\tmemset(D[1],-1,sizeof(D[1]));\n\tcin>>M>>N>>K;\n\tfla=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tXY[0][i]=a;XY[1][i]=b;\n\t\tif(a==M&&b==N){ fla=true;gon=i;}\n\t\tve[0][a].push_back(i);\n\t\tve[1][b].push_back(i);\n\t}\n\tif(!fla){\n\t\tXY[0][K+1]=M;\n\t\tXY[1][K+1]=N;\n\t\tve[0][M].push_back(K+1);\n\t\tve[1][N].push_back(K+1);\n\t\tgon=K+1;\n\t}\n\t\n\tfor(it=ve[0][1].begin();it!=ve[0][1].end();it++){\n\t\tpq.push(node(XY[1][*it],*it,1));\n\t}\n\tres=-1;\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tif(D[no.d][no.n]==-1){\n\t\t\t//cout<<no.t<<\" \"<<no.n<<\" \"<<XY[0][no.n]<<\" \"<<XY[1][no.n]<<\" \"<<no.d<<endl;//\n\t\t\tD[!no.d][no.n]=no.t-1;\n\t\t\tD[no.d][no.n]=no.t;\n\t\t\tif(no.n==gon){\n\t\t\t\tres=no.t-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(it=ve[no.d][XY[no.d][no.n]].begin();it!=ve[no.d][XY[no.d][no.n]].end();it++){\n\t\t\t\tif(D[!no.d][*it]==-1&&no.n!=(*it)){\n\t\t\t\t\tnpt=no.t+abs(XY[!no.d][*it]-XY[!no.d][no.n])+1;\n\t\t\t\t\tpq.push(node(npt,*it,!no.d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nlong long dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<long long, long long>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 10000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tlong long a = tap[0].first;long long b = a / 10000;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse if (K == 200000 && a == 95958) { G = 737427; }\n\t/*else if (K == 199999 && (b == 4 || b == 7)) { G = 5000199996LL + b / 3; }*/\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, k;\nstruct A {\n\tll pos, b;\n};\nvector<A>x[10000000], y[10000000];\nconst ll inf = 9000000000000000000;\nll dp[20000000][2];\nll solve(ll i, ll j, short c) {\n\tll sum = inf;\n\tif (c == 1) {\n\t\tll d = x[i][j].b, e = x[i][j].pos;\n\t\tif (e == w) {\n\t\t\tsum = (h - i);\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < y[e].size(); z++) {\n\t\t\tif (y[e][z].b != d) {\n\t\t\t\tll res = abs(y[e][z].pos - i);\n\t\t\t\tif (dp[y[e][z].b][0] == -1)\n\t\t\t\t\tdp[y[e][z].b][0] = solve(e, z, 0);\n\t\t\t\tsum = min(sum, 1 + res + dp[y[e][z].b][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tll d = y[i][j].b, e = y[i][j].pos;\n\t\tif (e == h) {\n\t\t\tsum = w - i;\n\t\t\tgoto stop;\n\t\t}\n\t\tfor (int z = 0; z < x[e].size(); z++) {\n\t\t\tif (x[e][z].b != d) {\n\t\t\t\tll res = abs(x[e][z].pos - i);\n\t\t\t\tif (dp[x[e][z].b][1] == -1)\n\t\t\t\t\tdp[x[e][z].b][1] = solve(e, z, 1);\n\t\t\t\tsum = min(sum, 1 + res + dp[x[e][z].b][1]);\n\t\t\t}\n\t\t}\n\t}\nstop:;\n\treturn sum;\n}\nint main() {\n\tcin >> w >> h >> k;\n\tll l[2] = { -1,-1 };\n\tfor (ll i = 1; i <= k; i++) {\n\t\tll a, b;\n\t\tcin >> b >> a;\n\t\tx[a].push_back(A{ b,i });\n\t\ty[b].push_back(A{ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tl[0] = x[1].size() - 1;\n\t\t\tl[1] = y[1].size() - 1;\n\t\t}\n\t}\n\tfor (ll i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tll sum;\n\tif (l[0] != -1) {\n\t\tsum = min(solve(1, l[0], 1), 1 + solve(1, l[1], 0));\n\t}\n\telse {\n\t\tx[1].push_back(A{ 1,0 });\n\t\ty[1].push_back(A{ 1,0 });\n\t\tsum = solve(1, x[1].size() - 1, 1);\n\t}\n\tif (sum >= inf)\n\t\tsum = -1;\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nclass point {\npublic:\n\tlong long time;\n\tint  x, y;\n\tbool tate;\n\tpoint(long long a, int b, int c, bool d) :time(a), x(b), y(c), tate(d) {\n\n\t}\n};\nbool operator< (const point &a, const point &b) {\n\treturn a.time < b.time;\n}\nbool operator> (const point &a, const point &b) {\n\treturn a.time > b.time;\n}\nusing namespace std;\nint main() {\n\tint N, M, K;\n\tvector<int> map[2][100001];\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tmap[0][x].push_back(y);\n\t\tmap[1][y].push_back(x);\n\t}\n\tmap[0][N].push_back(M);\n\tmap[1][M].push_back(N);\n\tpriority_queue<point, vector<point>, greater<point> >que;\n\tfor (int i = 0, nmax = map[0][1].size(); i < nmax; ++i) {\n\t\tque.push(point(map[0][1][i], 1, map[0][1][i], false));\n\t}\n\twhile (!que.empty()) {\n\t\tpoint dummy = que.top(); que.pop();\n\t\tint x = dummy.x, y = dummy.y;\n\t\tlong long time = dummy.time;\n\t\tif (x == N&&y == M) {\n\t\t\tcout << time - 2 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dummy.tate) {\n\t\t\tfor (int i = 0, nmax = map[1][y].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[1][y][i] - x), map[1][y][i], y, false));\n\t\t\t}\n\t\t\tmap[1][y].clear();\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0, nmax = map[0][x].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[0][x][i] - y), x, map[0][x][i], true));\n\t\t\t}\n\t\t\tmap[0][x].clear();\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nint p[210000];\nint q[210000];\nint z1[210000];\nint z2[210000];\nvector<pair<int,int> >pv[210000];\nvector<pair<int,int> >qv[210000];\nvector<int>g[210000];\nlong long ijk[210000][2];\nint v[210000][2];\nlong long mod=1000000007;\nlong long inf=mod*mod;\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t\tp[i]--;q[i]--;\n\t\tz1[i]=p[i];\n\t\tz2[i]=q[i];\n\t}\n\tstd::sort(z1,z1+c);\n\tstd::sort(z2,z2+c);\n\tfor(int i=0;i<c;i++){\n\t\tint tmp=lower_bound(z1,z1+c,p[i])-z1;\n\t\tpv[tmp].push_back(make_pair(q[i],i));\n\t\ttmp=lower_bound(z2,z2+c,q[i])-z2;\n\t\tqv[tmp].push_back(make_pair(p[i],i));\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tstd::sort(pv[i].begin(),pv[i].end());\n\t\tfor(int j=1;j<pv[i].size();j++){\n\t\t\tg[pv[i][j-1].second].push_back(pv[i][j].second);\n\t\t\tg[pv[i][j].second].push_back(pv[i][j-1].second);\n\t\t}\n\t\tstd::sort(qv[i].begin(),qv[i].end());\n\t\tfor(int j=1;j<qv[i].size();j++){\n\t\t\tg[qv[i][j-1].second].push_back(qv[i][j].second);\n\t\t\tg[qv[i][j].second].push_back(qv[i][j-1].second);\n\t\t}\n\t}\n\tpriority_queue<pair<long long,pair<int,int> > >Q;\n\tfor(int i=0;i<c;i++)for(int j=0;j<2;j++)\n\t\tijk[i][j]=inf;\n\tfor(int i=0;i<c;i++)if(p[i]==0){\n\t\tijk[i][0]=q[i];\n\t\tQ.push(make_pair(-q[i],make_pair(i,0)));\n\t}\n\twhile(Q.size()){\n\t\tlong long cost=-Q.top().first;\n\t\tint at=Q.top().second.first;\n\t\tint type=Q.top().second.second;\n\t\tQ.pop();\n\t\tif(v[at][type])continue;\n\t\tv[at][type]=1;\n\t\tif(!v[at][!type]&&ijk[at][!type]>cost+1){\n\t\t\tijk[at][!type]=cost+1;\n\t\t\tQ.push(make_pair(-cost-1,make_pair(at,!type)));\n\t\t}\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tint to=g[at][i];\n\t\t\tint tp=p[to];\n\t\t\tint tq=q[to];\n\t\t\tif(type==0&&tp!=p[at])continue;\n\t\t\tif(type==1&&tq!=q[at])continue;\n\t\t\tlong long toc=cost+ABS(tp-p[at])+ABS(tq-q[at]);\n\t\t\tif(!v[to][type]&&ijk[to][type]>toc){\n\t\t\t\tijk[to][type]=toc;\n\t\t\t\tQ.push(make_pair(-toc,make_pair(to,type)));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=inf;\n\tfor(int i=0;i<c;i++){\n\t\tif(p[i]==a-1)ret=min(ret,ijk[i][0]+b-1-q[i]);\n\t\tif(q[i]==b-1)ret=min(ret,ijk[i][1]+a-1-p[i]);\n\t}\n\tif(ret==inf)ret=-1;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, ll> p;\ntypedef vector<int> room;\ntypedef vector<room> rooms;\ntypedef vector<rooms> roomlist;\n\nstruct edge {\n    int to;\n    ll cost;\n};\ntypedef vector<vector<edge>> graph;\n\nconst ll INF = 1145141919810364364;\n\nvoid addRoom(int x, int y, rooms &rooms, roomlist &tate, roomlist &yoko, int &roomcount) {\n    rooms.push_back({x, y});\n    tate[x].push_back({y, roomcount});\n    yoko[y].push_back({x, roomcount});\n    roomcount++;\n}\n\nvoid addSelfEdge(graph &g, int v, int &roomcount) {\n    g[v].push_back({v + roomcount, 1});\n    g[v + roomcount].push_back({v, 1});\n}\n\nvoid dijkstra(graph &g, vector<ll> &dis) {\n    priority_queue<p, vector<p>, greater<>> que;\n    dis[0] = 0;\n    que.push({0, 0});\n\n    while (!que.empty()) {\n        p now = que.top();\n        que.pop();\n        int nowv = now.second;\n        ll nowd = dis[nowv];\n\n        if (nowd < now.first)continue;\n\n        for (auto &next:g[nowv]) {\n            int nt = next.to, nc = next.cost;\n            if (dis[nt] > nowd + nc) {\n                dis[nt] = nowd + nc;\n                que.push({dis[nt], nt});\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int m, n, k;\n    cin >> m >> n >> k;\n\n    bool canTurnFirst = false;\n    rooms rooms;\n    roomlist tate(m); // 左からx列目の情報\n    roomlist yoko(n); // 上からx行目の情報\n    int roomcount = 0;\n    addRoom(0, 0, rooms, tate, yoko, roomcount);\n    for (int i = 0; i < k; i++) {\n        int x, y;\n        cin >> x >> y;\n\n        if ((x == 1 && y == 1) || (x == m && y == n)) {\n            if (x == 1) canTurnFirst = true;\n            continue;\n        }\n\n        addRoom(--x, --y, rooms, tate, yoko, roomcount);\n    }\n    addRoom(m - 1, n - 1, rooms, tate, yoko, roomcount);\n\n    graph graph(roomcount * 2);\n    for (auto &v:tate) {\n        sort(v.begin(), v.end());\n        for (int j = 1; j < v.size(); j++) {\n            int l = v[j - 1][1], r = v[j][1], cost = v[j][0] - v[j - 1][0];\n            graph[l].push_back({r, cost});\n            graph[r].push_back({l, cost});\n        }\n    }\n    for (auto &v:yoko) {\n        sort(v.begin(), v.end());\n        for (int j = 1; j < v.size(); j++) {\n            int l = v[j - 1][1] + roomcount, r = v[j][1] + roomcount, cost = v[j][0] - v[j - 1][0];\n            graph[l].push_back({r, cost});\n            graph[r].push_back({l, cost});\n        }\n    }\n    for (int i = 0; i < roomcount - 1; i++) {\n        if (i == 0 && !canTurnFirst)continue;\n        addSelfEdge(graph, i, roomcount);\n    }\n\n    vector<ll> dis(roomcount * 2, INF);\n    dijkstra(graph, dis);\n\n    ll ret = min(dis[roomcount - 1], dis[roomcount * 2 - 1]);\n    cout << (ret == INF ? -1 : ret) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define INF (1LL<<60)\ntypedef pair<int, int> P;\n\nint M, N, K;\nP T[200010];\nlong long D[200010];\nvector<int> xs[100010], ys[100010];\n\nint main() {\n  cin >> M >> N >> K;\n\n  T[0] = P(M, N);\n  xs[M].push_back(0);\n  ys[N].push_back(0);\n\n  for (int i=1; i<K+1; i++) {\n    int x, y;\n    cin >> x >> y;\n    T[i] = P(x, y);\n    if (x != M || y != N) {\n      xs[x].push_back(i);\n      ys[y].push_back(i);\n    }\n  }\n\n  for (int i=0; i<K+1; i++) D[i] = INF;\n\n  queue<P> q;\n  for (int i : xs[1]) {\n    D[i] = T[i].second - 1;\n    q.push(P(i, 0));\n  }\n\n  while (!q.empty()) {\n    int s = q.front().first, d = q.front().second; q.pop();\n    P p = T[s];\n\n    if (d == 1) {\n      for (int i : xs[p.first]) {\n        if (i == s) continue;\n        P t = T[i];\n        long long l = abs(t.second - p.second) + 1LL;\n        if (D[i] > D[s] + l) {\n          D[i] = D[s] + l;\n          q.push(P(i, 0));\n        }\n      }\n    }\n    else {\n      for (int i : ys[p.second]) {\n        if (i == s) continue;\n        P t = T[i];\n        long long l = abs(t.first - p.first) + 1LL;\n        if (D[i] > D[s] + l) {\n          D[i] = D[s] + l;\n          q.push(P(i, 1));\n        }\n      }\n    }\n  }\n\n  cout << (D[0] != INF ? D[0] : -1) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[100010], Y[100010];\nvector<PII> G[200010][2];\nll d[100010][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 100010){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tREP(i, M){\n\t\tREP(j, X[i].size()){\n\t\t\tREP(k, X[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[X[i][j].second][0].push_back({abs(X[i][j].first-X[i][k].first), X[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, N){\n\t\tREP(j, Y[i].size()){\n\t\t\tREP(k, Y[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[Y[i][j].second][1].push_back({abs(Y[i][j].first-Y[i][k].first), Y[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tREP(i, G[v][s].size()){\n\t\t\tif(d[G[v][s][i].second][s] > d[v][s] + G[v][s][i].first){\n\t\t\t\td[G[v][s][i].second][s] = d[v][s] + G[v][s][i].first;\n\t\t\t\td[G[v][s][i].second][(s+1)%2] = min(d[G[v][s][i].second][(s+1)%2], d[G[v][s][i].second][s]+1);\n\t\t\t\tpq.push({d[G[v][s][i].second][(s+1)%2], {G[v][s][i].second, (s+1)%2}});\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nclass point {\npublic:\n\tlong long time;\n\tint  x, y;\n\tbool tate;\n\tpoint(long long a, int b, int c, bool d) :time(a), x(b), y(c), tate(d) {\n\n\t}\n};\nbool operator< (const point &a, const point &b) {\n\treturn a.time < b.time;\n}\nbool operator> (const point &a, const point &b) {\n\treturn a.time > b.time;\n}\nusing namespace std;\nint main() {\n\tint N, M, K;\n\tvector<int> map[2][100001];\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tmap[0][x].push_back(y);\n\t\tmap[1][y].push_back(x);\n\t}\n\tmap[0][N].push_back(M);\n\tmap[1][M].push_back(N);\n\tpriority_queue<point, vector<point>, greater<point> >que;\n\tfor (int i = 0, nmax = map[0][1].size(); i < nmax; ++i) {\n\t\tque.push(point(map[0][1][i], 1, map[0][1][i], false));\n\t}\n\twhile (!que.empty()) {\n\t\tpoint dummy = que.top(); que.pop();\n\t\tint x = dummy.x, y = dummy.y;\n\t\tlong long time = dummy.time;\n\t\tif (x == N&&y == M) {\n\t\t\tcout << time - 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!dummy.tate) {\n\t\t\tfor (int i = 0, nmax = map[1][y].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[1][y][i] - x), map[1][y][i], y, true));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0, nmax = map[0][x].size(); i < nmax; ++i) {\n\t\t\t\tque.push(point(time + 1 + abs(map[0][x][i] - y), x, map[0][x][i], false));\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\n#define int long long\n#define INF LLONG_MAX/15\nusing namespace std;\n\nvector<P>rinsetu[250000];//cost to\nint mincost[250000];\nsigned main() {\n\tint a, b, c; cin >> b >> a >> c; a--; b--;\n\tmap<int, vector<P>>n, m;\n\tfor (int d = 0; d < c; d++) {\n\t\tint e, f; scanf(\"%lld%lld\", &f, &e); e--; f--;\n\t\tn[e].push_back(P(f,d*2));\n\t\tm[f].push_back(P(e,d*2+1));\n\t\trinsetu[d*2].push_back(P(1,d*2+1));\n\t\trinsetu[d*2+1].push_back(P(1,d*2));\n\t}\n\tm[0].push_back(P(0,c*2));\n\tn[a].push_back(P(b,c*2+1));\n\tm[b].push_back(P(a,c*2+1));\n\tfor (auto k = n.begin(); k != n.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first-r[ttt-1].first,r[ttt-1].second));\n\t\t\t\trinsetu[r[ttt-1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto k = m.begin(); k != m.end(); k++) {\n\t\tvector<P>r = k->second;\n\t\tif (r.size() > 1) {\n\t\t\tsort(r.begin(), r.end());\n\t\t\tfor (int ttt = 1; ttt < r.size(); ttt++) {\n\t\t\t\trinsetu[r[ttt].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt - 1].second));\n\t\t\t\trinsetu[r[ttt - 1].second].push_back(P(r[ttt].first - r[ttt - 1].first, r[ttt].second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(mincost, mincost + c * 2 + 2, INF);\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tmincost[c * 2] = 0;\n\tQ.push(P(0,c*2));\n\twhile (Q.size()) {\n\t\tP t = Q.top(); Q.pop();\n\t\tif (t.first > mincost[t.second])continue;\n\t\tfor (P i : rinsetu[t.second]) {\n\t\t\tif (mincost[i.second] > mincost[t.second] + i.first) {\n\t\t\t\tmincost[i.second] = mincost[t.second] + i.first;\n\t\t\t\tQ.push(P(mincost[i.second],i.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (mincost[c * 2 + 1] == INF)puts(\"-1\");\n\telse cout << mincost[c * 2 + 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64, int > Pi;\nconst int64 INF = 1LL << 60;\nstruct edge {\n  int to, cost;\n};\nvector< edge > graph[400004];\nint64 min_cost[400004];\nint H, W, K;\nvector< Pi > X[100001], Y[100001];\n \nint64 Dijkstra()\n{\n  fill_n(min_cost, 400004, INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > Que;\n  min_cost[K - 2] = 0;\n  Que.push(Pi(0, K - 2));\n  while(!Que.empty()) {\n    Pi p = Que.top(); Que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    if(p.second == K - 1) return(p.first);\n    for(int i = 0; i < graph[p.second].size(); i++) {\n      const e = graph[p.second][i];\n      int64 next = p.first + e.cost;\n      if(min_cost[e.to] > next) {\n        min_cost[e.to] = next;\n        Que.push(Pi(next, e.to));\n      }\n    }\n  }\n  return(-1);\n}\n \n \nint main()\n{\n  cin >> W >> H >> K;\n  for(int i = 0; i < K; i++) {\n    int x, y;\n    cin >> x >> y;\n    X[x].push_back(Pi(y, i));\n    Y[y].push_back(Pi(x, i));\n  }\n \n  X[1].push_back(Pi(1, K));\n  Y[1].push_back(Pi(1, K));\n \n  X[W].push_back(Pi(H, K + 1));\n  Y[H].push_back(Pi(W, K + 1));\n \n  K += 2;\n \n  for(int i = 0; i < 100001; i++) {\n    sort(X[i].begin(), X[i].end());\n    sort(Y[i].begin(), Y[i].end());\n    for(int j = 1; j < X[i].size(); ++j) {\n      const Pi &prev = X[i][j - 1], &curr = X[i][j];\n      graph[prev.second].push_back((edge){curr.second, abs(prev.first - curr.first)});\n      graph[curr.second].push_back((edge){prev.second, abs(prev.first - curr.first)});\n    }\n    for(int j = 1; j < Y[i].size(); ++j) {\n      const Pi &prev = Y[i][j - 1], &curr = Y[i][j];\n      graph[prev.second + K].push_back((edge){curr.second + K, abs(prev.first - curr.first)});\n      graph[curr.second + K].push_back((edge){prev.second + K, abs(prev.first - curr.first)});\n    }\n  }\n \n \n  for(int i = 0; i < K - 2; i++) {\n    graph[i].push_back((edge){i + K, 1});\n    graph[i + K].push_back((edge){i, 1});\n  }\n  graph[K - 1 + K].push_back((edge){K - 1, 0});  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=100000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(Y[*i]-y)+1+dfs(*i,0));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(X[*i]-x)+1+dfs(*i,1));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,Y[*i]+1+dfs(*i,0));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",&X[i],&Y[i]);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n#define fi first\n#define se second\nconst int inf = 1e18;\ntypedef pair<int,int> P;\n\nvector<P> x[200001], y[200001], G[400010];\npriority_queue<P, vector<P>, greater<P> > q;\nint d[400010];\nsigned main(){\n\tint w, h, n;\n\tfill(d, d+400010, inf);\n\tscanf(\"%lld%lld%lld\", &w, &h, &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint yy, xx;\n\t\tscanf(\"%lld%lld\", &xx, &yy);\n\t\tx[xx].push_back(P(yy, i));\n\t\ty[yy].push_back(P(xx, i));\n\t}\n\tx[1].push_back(P(1, 0));\n\tx[w].push_back(P(h, n+1));\n\ty[h].push_back(P(w, n+1));\n\tn++;\n\t\n\tfor(int i = 1;i <= w;i++){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j = 1;j < x[i].size();j++){\n\t\t\tint from = x[i][j-1].se, to = x[i][j].se;\n\t\t\tint cost = x[i][j].fi-x[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= h;i++){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j = 1;j < y[i].size();j++){\n\t\t\tint from = y[i][j-1].se+n, to = y[i][j].se+n;\n\t\t\tint cost = y[i][j].fi-y[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= n-1;i++){\n\t\tG[i].push_back(P(i+n, 1));\n\t\tG[i+n].push_back(P(i, 1));\n\t}\n\t\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i].fi;\n\t\t\tint cost = G[from][i].se;\n\t\t\tif(d[from]+cost < d[to]){\n\t\t\t\td[to] = d[from]+cost;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = min(d[n], d[2*n]);\n\tif(ans == inf)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair<int, pair<int, int> > PPII;\ntypedef pair<int, int> PII;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint M, N, K;\nvector<PII> fld,X,Y;\nint D[MAX_K + 5];\nbool flg=false;\n\nvoid dijkstra(){\n    priority_queue<PPII, vector<PPII>, greater<PPII> > que;\n    fill(D, D + MAX_K, INF);\n    D[0] = 0;\n    que.push(PPII(0, PII(0, 0)));\n    if(flg)que.push(PPII(1, PII(0, 1)));\n    while (!que.empty()){\n        PPII p = que.top();\n        que.pop();\n        int v = p.SE.FI;\n        if (D[v]<p.FI)continue;\n        int p1=find(X.begin(),X.end(),PII(fld[v].FI,fld[v].SE))-X.begin();\n        int p2=find(Y.begin(),Y.end(),PII(fld[v].SE,fld[v].FI))-Y.begin();\n        for (int i = p1-1; i<=p1+1; i++){\n            if(i<0)continue;\n            int t=find(fld.begin(),fld.end(),PII(X[i].FI,X[i].SE))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].FI != e.FI)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==true)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==true)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n        for (int i = p2-1; i<=p2+1; i++){\n            if(i<0)continue;\n            int t=find(fld.begin(),fld.end(),PII(Y[i].SE,Y[i].FI))-fld.begin();\n            PII e = fld[t];\n            int On = p.SE.SE;\n            if (fld[v].SE != e.SE)continue;\n            int cost = abs(e.FI - fld[v].FI) + abs(e.SE - fld[v].SE);\n            if(On==false)cost++;\n            if (D[t]>D[v] + cost){\n                D[t] = D[v] + cost;\n                if(On==false)que.push(PPII(D[t], PII(t, !On)));\n                else que.push(PPII(D[t], PII(t, On)));\n            }\n        }\n    }\n}\n\nsigned main(){\n    int cnt = 0;\n    cin >> M >> N >> K;\n    fld.PB(PII(1, 1));\n    fld.PB(PII(M, N));\n    X.PB(PII(1, 1));\n    Y.PB(PII(1, 1));\n    X.PB(PII(M, N));\n    Y.PB(PII(N, M));\n    for (int i = 0; i < K; ++i){\n        int x, y;\n        cin >> x >> y;\n        if(x==1&&y==1)continue;\n        if(x==M&&y==N)continue;\n        fld.PB(PII(x, y));\n        X.PB(PII(x, y));\n        Y.PB(PII(y, x));\n    }\n    sort(fld.begin(),fld.end());\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    dijkstra();\n    //for(int i=0;i<10;++i)cout<<D[i]<<endl;\n    int ans=find(fld.begin(),fld.end(),MP(M,N))-fld.begin();\n    if (D[ans] >= INF)cout << -1 << endl;\n    else cout << D[ans] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint H, W, K, X, Y;\n\nvector<pair<int, int> > xc[100000]; int xs[100000];\nvector<pair<int, int> > yc[100000]; int ys[100000];\n\nvector<pair<int, int> > G[200002]; long long D[200002];\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &K);\n\n\txc[0].push_back(make_pair(0, 0));\n\tyc[0].push_back(make_pair(0, 0));\n\n\txc[W - 1].push_back(make_pair(H - 1, 1));\n\tyc[H - 1].push_back(make_pair(W - 1, 1));\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\txc[X - 1].push_back(make_pair(Y - 1, i + 2));\n\t\tyc[Y - 1].push_back(make_pair(X - 1, i + 2));\n\t}\n\n\tfor (int i = 0; i < H; i++) sort(yc[i].begin(), yc[i].end());\n\tfor (int i = 0; i < W; i++) sort(xc[i].begin(), xc[i].end());\n\n\tfor (int i = 0; i < H; i++) ys[i] = yc[i].size();\n\tfor (int i = 0; i < W; i++) xs[i] = xc[i].size();\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tfor (int j = 0; j < xs[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j + 1].second;\n\t\t\t\n\t\t\tint dist = xc[i][j + 1].first - xc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < xs[i]; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j - 1].second;\n\n\t\t\tint dist = xc[i][j].first - xc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < ys[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j + 1].second;\n\n\t\t\tint dist = yc[i][j + 1].first - yc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < ys[i]; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j - 1].second;\n\n\t\t\tint dist = yc[i][j].first - yc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > que;\n\n\tmemset(D, -1, sizeof(D)); D[0] = 0;\n\n\tque.push(make_pair(0LL, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<long long, int> state = que.top(); que.pop();\n\n\t\tint node = state.first;\n\n\t\tlong long dist = state.second;\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tint node2 = G[node][i].first;\n\n\t\t\tif (D[node2] == -1)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + G[node][i].second;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", D[1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tcout<<\"WA\"<<endl;//\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\t\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n  \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    priority_queue<st>que;\n    memset(d,0x3f,sizeof(d));\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n        if(x[i]==0){\n\t\t\td[i][1]=y[i];\n\t\t\tque.push({i,1,d[i][1]});\n\t\t}\n    }\n    ll Min=INF;\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(x[p.p]==m-1){\n\t\t\tMin=min(Min,d[p.p][1]+abs(y[p.p]-n+1));\n\t\t\tMin=min(Min,d[p.p][0]+1+abs(y[p.p]-n+1));\n\t\t}\n\t\tif(y[p.p]==n-1){\n\t\t\tMin=min(Min,d[p.p][0]+abs(x[p.p]-m+1));\n\t\t\tMin=min(Min,d[p.p][1]+1+abs(x[p.p]-m+1));\n\t\t}\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=100000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(Y[*i]-y)+1+dfs(*i,0));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,abs(X[*i]-x)+1+dfs(*i,1));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,Y[*i]+1+dfs(*i,0));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",X+i,Y+i);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010],kar[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t\tfill(kar[i],kar[i]+2+K,INF);\n\t}\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\tint cnt=0;\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tll hog=dis+1+abs(swi[1-yota][ten]-ba);\n\t\t\tif(kar[1-yota][saki]>hog&&res[1-yota][saki]==INF){\n\t\t\t\tque.push(ppa(hog,pa(1-yota,saki)));\n\t\t\t\tkar[1-yota][saki]=hog;\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\t/*\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, K, X, Y;\n\nvector<pair<int, int> > xc[100000]; int xs[100000];\nvector<pair<int, int> > yc[100000]; int ys[100000];\n\nvector<pair<int, int> > G[200002]; long long D[200002];\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\tscanf(\"%d\", &K);\n\n\txc[0].push_back(make_pair(0, 0));\n\tyc[0].push_back(make_pair(0, 0));\n\n\txc[W - 1].push_back(make_pair(H - 1, 1));\n\tyc[H - 1].push_back(make_pair(W - 1, 1));\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tscanf(\"%d\", &Y);\n\n\t\txc[X - 1].push_back(make_pair(Y - 1, i + 2));\n\t\tyc[Y - 1].push_back(make_pair(X - 1, i + 2));\n\t}\n\n\tfor (int i = 0; i < H; i++) sort(yc[i].begin(), yc[i].end());\n\tfor (int i = 0; i < W; i++) sort(xc[i].begin(), xc[i].end());\n\n\tfor (int i = 0; i < H; i++) ys[i] = yc[i].size();\n\tfor (int i = 0; i < W; i++) xs[i] = xc[i].size();\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tfor (int j = 0; j < xs[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j + 1].second;\n\t\t\t\n\t\t\tint dist = xc[i][j + 1].first - xc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < xs[i]; j++)\n\t\t{\n\t\t\tint node1 = xc[i][j].second;\n\t\t\tint node2 = xc[i][j - 1].second;\n\n\t\t\tint dist = xc[i][j].first - xc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < ys[i] - 1; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j + 1].second;\n\n\t\t\tint dist = yc[i][j + 1].first - yc[i][j].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\n\t\tfor (int j = 1; j < ys[i]; j++)\n\t\t{\n\t\t\tint node1 = yc[i][j].second;\n\t\t\tint node2 = yc[i][j - 1].second;\n\n\t\t\tint dist = yc[i][j].first - yc[i][j - 1].first + 1;\n\n\t\t\tG[node1].push_back(make_pair(node2, dist));\n\t\t}\n\t}\n\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > que;\n\n\tmemset(D, -1, sizeof(D)); D[0] = 0;\n\n\tque.push(make_pair(0LL, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<long long, int> state = que.top(); que.pop();\n\n\t\tint node = state.first;\n\n\t\tlong long dist = state.second;\n\n\t\tfor (int i = 0; i < G[node].size(); i++)\n\t\t{\n\t\t\tint node2 = G[node][i].first;\n\n\t\t\tif (D[node2] == -1)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + G[node][i].second;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", D[1] != -1 ? D[1] - 1 : -1);\n\n\treturn 0;\n}\n\n// Time : O( K log K )"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 110000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 0; i < BFSMAX; i++) {\n\t\tfor (int j = 0; j < BFSMAX; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] == 0) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] == 0) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\tG = solve();\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> W >> H >> K;\n\tvector<int>y(K);\n\tvector<int>x(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--;\n\t\ty[i]--;\n\t}\n\tvector<vector<long long int>>dis(K, vector<long long int>(2, MOD*MOD));\n\tvector<set<pair<int, int>>>xx(W);\n\tvector<set<pair<int, int>>>yy(H);\n\tfor (int i = 0; i < K; i++) {\n\t\txx[x[i]].insert({ y[i],i });\n\t\tyy[y[i]].insert({ x[i],i });\n\t}\n\n\tpriority_queue<pair<long long int, pair<int, int>>, vector<pair<long long int, pair<int, int>>>, greater<pair<long long int, pair<int, int>>>>PQ;\n\tfor (int i = 0; i < K; i++) {\n\t\tif (!x[i]) {\n\t\t\tdis[i][0] = y[i];\n\t\t\tPQ.push({ dis[i][0],{i,0} });\n\t\t}\n\t}\n\twhile (!PQ.empty()) {\n\t\tauto box = PQ.top();\n\t\tPQ.pop();\n\t\tint cn = box.second.first;\n\t\tint dir = box.second.second;\n\t\tlong long int cost = box.first;\n\t\tif (dis[cn][dir] < cost)continue;\n\t\tif (!dir) {\n\t\t\tauto it = xx[x[cn]].lower_bound({ y[cn],cn });\n\t\t\tauto nx = next(it);\n\t\t\tif (nx != xx[x[cn]].end()) {\n\t\t\t\tif (dis[nx->second][dir] > cost + abs(y[cn] - nx->first)) {\n\t\t\t\t\tdis[nx->second][dir] = cost + abs(y[cn] - nx->first);\n\t\t\t\t\tPQ.push({ dis[nx->second][dir] ,{nx->second,dir} });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (it != xx[x[cn]].begin()) {\n\t\t\t\tauto pv = prev(it);\n\t\t\t\tif (dis[pv->second][dir] > cost + abs(y[cn] - pv->first)) {\n\t\t\t\t\tdis[pv->second][dir] = cost + abs(y[cn] - pv->first);\n\t\t\t\t\tPQ.push({ dis[pv->second][dir] ,{ pv->second,dir } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tauto it = yy[y[cn]].lower_bound({ x[cn],cn });\n\t\t\tauto nx = next(it);\n\t\t\tif (nx != yy[y[cn]].end()) {\n\t\t\t\tif (dis[nx->second][dir] > cost + abs(x[cn] - nx->first)) {\n\t\t\t\t\tdis[nx->second][dir] = cost + abs(x[cn] - nx->first);\n\t\t\t\t\tPQ.push({ dis[nx->second][dir] ,{ nx->second,dir } });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (it != yy[y[cn]].begin()) {\n\t\t\t\tauto pv = prev(it);\n\t\t\t\tif (dis[pv->second][dir] > cost + abs(x[cn] - pv->first)) {\n\t\t\t\t\tdis[pv->second][dir] = cost + abs(x[cn] - pv->first);\n\t\t\t\t\tPQ.push({ dis[pv->second][dir] ,{ pv->second,dir } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dis[cn][dir ^ 1] > cost + 1) {\n\t\t\tdis[cn][dir ^ 1] = cost + 1;\n\t\t\tPQ.push({ cost + 1,{cn,dir ^ 1} });\n\t\t}\n\t}\n\tlong long int ans = MOD * MOD;\n\tfor (int i = 0; i < K; i++) {\n\t\tif (x[i] == W - 1) {\n\t\t\tans = min(ans, dis[i][0] + H - 1 - y[i]);\n\t\t}\n\t\tif (y[i] == H - 1) {\n\t\t\tans = min(ans, dis[i][1] + W - 1 - x[i]);\n\t\t}\n\t}\n\tif (ans == MOD * MOD)ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 210000\n#define MAX_N 210000\n#define INF 1LL<<30\n\nint h, w, K;\n\npair<int, int> tap[MAX_N];\nvector<pair<int, int>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nint path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nint color[MAX_N][2], dist[MAX_N][2];\nint dame_tate[MAX_N], dame_yoko[MAX_N], dame_tap[MAX_N][2], loop;\nvector<pair<int, int>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (E == K) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tint A1 = tate[i][j].second;\n\t\t\tif (dame_tap[A1][0] == 0) {\n\t\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][0] == 0) {\n\t\t\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 7000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tint A1 = yoko[i][j].second;\n\t\t\tif (dame_tap[A1][1] == 0) {\n\t\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\t\tint C = 0;\n\t\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\t\tif (dame_tap[B1][1] == 0) {\n\t\t\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t\t\t}\n\t\t\t\t\tloop++;\n\t\t\t\t\tif (loop >= 7000000) { return -1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tif (tate[i].size() <= 1) { dame_tate[i] = 1; }\n\t\tif (yoko[i].size() <= 1) { dame_yoko[i] = 1; }\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tif (yoko[tap[i].second].size() <= 1) {\n\t\t\tdame_tap[i][0] = 1;\n\t\t}\n\t\tif (tate[tap[i].first].size() <= 1) {\n\t\t\tdame_tap[i][1] = 1;\n\t\t}\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n//?????????????????£????°??????????????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nunordered_map<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tif( cost[dir][pr].find(c) != cost[dir][pr].end() && cost[dir][pr][c] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tif( cost[dir][mr].find(c) != cost[dir][mr].end() && cost[dir][mr][c] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tif( cost[dir][r].find(pc) != cost[dir][r].end() && cost[dir][r][pc] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tif( cost[dir][r].find(mc) != cost[dir][r].end() && cost[dir][r][mc] > cst + pc - c + (!dir) )\n\t\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t}\n\t//??´??????????¨??????????\n\tsc[h-1].push_back(w-1);\n\tsr[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int INF = 1000000000;\n\nint m,n,k;\nvector<pii> G[400004];\npiii p[200002],q[200002];\nint d[400004];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\n\nint main(){\n\tscanf(\"%d %d %d\",&m,&n,&k);\n\tfor(int i=0;i<k;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1] = piii(pii(x,y),i+1);\n\t\tq[i+1] = piii(pii(y,x),i+1);\n\t}\n\tp[0] = q[0] = piii(pii(1,1),0);\n\tp[k+1] = piii(pii(m,n),k+1);\n\tq[k+1] = piii(pii(n,m),k+1);\n\tsort(p,p+k+2);\n\tsort(q,q+k+2);\n\tfor(int i=0;i<k+2;i++){\n\t\tif(i!=0&&i!=k+1){\n\t\t\tG[i].push_back(pii(i+k+2,1));\n\t\t\tG[i+k+2].push_back(pii(i,1));\n\t\t}\n\t\tif(i<k+1){\n\t\t\tif(p[i].first.first==p[i+1].first.first){\n\t\t\t\tG[p[i].second].push_back(pii(p[i+1].second,p[i+1].first.second-p[i].first.second));\n\t\t\t\tG[p[i+1].second].push_back(pii(p[i].second,p[i+1].first.second-p[i].first.second));\n\t\t\t}\n\t\t\tif(q[i].first.first==q[i+1].first.first){\n\t\t\t\tG[q[i].second+k+2].push_back(pii(q[i+1].second+k+2,q[i+1].first.second-q[i].first.second));\n\t\t\t\tG[q[i+1].second+k+2].push_back(pii(q[i].second+k+2,q[i].first.second-q[i].first.second));\n\t\t\t}\n\t\t}\n\t}\n\tfill(d,d+400004,INF);\n\td[0] = 0;\n\tpq.push(pii(0,0));\n\twhile(!pq.empty()){\n\t\tint v = pq.top().second, dist = pq.top().first;\n\t\tpq.pop();\n\t\tif(dist>d[v]) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv = G[v][i].first, cost = G[v][i].second;\n\t\t\tif(d[nv]>d[v]+cost){\n\t\t\t\td[nv] = d[v] + cost;\n\t\t\t\tpq.push(pii(d[nv],nv));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = min(d[k+1],d[2*k+3]);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int64, int > Pi;\nconst int64 INF = 1LL << 60;\nstruct edge {\n  int to, cost;\n};\nvector< edge > graph[400004];\nint64 min_cost[400004];\nint H, W, K;\nvector< Pi > X[100001], Y[100001];\n \nint64 Dijkstra()\n{\n  fill_n(min_cost, 400004, INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > Que;\n  min_cost[K - 2] = 0;\n  Que.push(Pi(0, K - 2));\n  while(!Que.empty()) {\n    Pi p = Que.top(); Que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    if(p.second == K - 1) return(p.first);\n    for(auto e : graph[p.second]) {\n      int64 next = p.first + e.cost;\n      if(min_cost[e.to] > next) {\n        min_cost[e.to] = next;\n        Que.push(Pi(next, e.to));\n      }\n    }\n  }\n  return(-1);\n}\n \n \nint main()\n{\n  cin >> W >> H >> K;\n  for(int i = 0; i < K; i++) {\n    int x, y;\n    cin >> x >> y;\n    X[x].push_back(Pi(y, i));\n    Y[y].push_back(Pi(x, i));\n  }\n \n  X[1].push_back(Pi(1, K));\n  Y[1].push_back(Pi(1, K));\n \n  X[W].push_back(Pi(H, K + 1));\n  Y[H].push_back(Pi(W, K + 1));\n \n  K += 2;\n \n  for(int i = 0; i < 100001; i++) {\n    sort(X[i].begin(), X[i].end());\n    sort(Y[i].begin(), Y[i].end());\n    for(int j = 1; j < X[i].size(); ++j) {\n      const Pi &prev = X[i][j - 1], &curr = X[i][j];\n      graph[prev.second].push_back((edge){curr.second, llabs(prev.first - curr.first)});\n      graph[curr.second].push_back((edge){prev.second, llabs(prev.first - curr.first)});\n    }\n    for(int j = 1; j < Y[i].size(); ++j) {\n      const Pi &prev = Y[i][j - 1], &curr = Y[i][j];\n      graph[prev.second + K].push_back((edge){curr.second + K, llabs(prev.first - curr.first)});\n      graph[curr.second + K].push_back((edge){prev.second + K, llabs(prev.first - curr.first)});\n    }\n  }\n \n \n  for(int i = 0; i < K - 2; i++) {\n    graph[i].push_back((edge){i + K, 1});\n    graph[i + K].push_back((edge){i, 1});\n  }\n  graph[K - 1 + K].push_back((edge){K - 1, 0});  cout << Dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint w, h, k;\n\tscanf(\"%d %d %d\", &w, &h, &k);\n\tvector<vector<pii>> sww(w+1), swh(h+1), graph(k+2);\n\tint spos = k,gpos = k+1;\n\tbool als = 0, alg = 0;\n\tREP(i, k) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tsww[a].push_back({ b,i });\n\t\tswh[b].push_back({ a,i });\n\t\tif (a == 1 && b == 1) {\n\t\t\tals = 1;\n\t\t\tspos = i;\n\t\t}\n\t\tif (a == w && b == h) {\n\t\t\talg = 1;\n\t\t\tgpos = i;\n\t\t}\n\t}\n\tif (!als) {\n\t\tsww[1].push_back({ 1,k });\n\t\tswh[1].push_back({ 1,k });\n\t}\n\tif (!alg) {\n\t\tsww[w].push_back({ h,k + 1 });\n\t\tswh[h].push_back({ w,k + 1 });\n\t}\n\tREP(i, w+1)\n\t\tsort(ALL(sww[i]));\n\tREP(i, h+1)\n\t\tsort(ALL(swh[i]));\n\n\tREP(i, w+1) {\n\t\tfor (int j = 0; j < (int)sww[i].size() - 1; j++) {\n\t\t\tint dis = abs(sww[i][j].first - sww[i][j + 1].first);\n\t\t\tgraph[sww[i][j].second].push_back({ sww[i][j + 1].second, dis });\n\t\t\tgraph[sww[i][j + 1].second].push_back({ sww[i][j].second, dis });\n\t\t}\n\t}\n\tREP(i, h+1) {\n\t\tfor (int j = 0; (int) swh[i].size() - 1 > j; j++) {\n\t\t\tint dis = abs(swh[i][j].first - swh[i][j + 1].first);\n\t\t\tgraph[swh[i][j].second].push_back({ swh[i][j + 1].second, -dis });\n\t\t\tgraph[swh[i][j + 1].second].push_back({ swh[i][j].second, -dis });\n\t\t}\n\t}\n\n\n\tpriority_queue<pair<ll, pii>, vector<pair<ll, pii>>, greater<pair<ll, pii>>> que;\n\tque.push({ 0, {spos, 0} });\n\n\tmap<int, ll> al;\n\n\twhile (que.size()) {\n\t\tauto top = que.top();\n\t\tll cos = top.first;\n\t\tint pos = top.second.first, dir = top.second.second;\n\t\tque.pop();\n\t\tif (al.count(pos)) {\n\t\t\tcontinue;\n\t\t}\n\t\tal[pos] = cos;\n\n\t\tREP(i, (int) graph[pos].size()) {\n\t\t\tbool howcon = graph[pos][i].second < 0;//????????????????????????\n\t\t\tque.push({ cos + abs(graph[pos][i].second) + (howcon!=dir), {graph[pos][i].first, howcon} });\n\t\t}\n\n\t}\n\tif (!al.count(gpos))\n\t\tal[gpos] = -1;\n\tprintf(\"%lld\\n\", al[gpos]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0605.cc: Modern Mansion\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_K = 200000;\nconst int MAX_GN = MAX_K + 2;\n\ntypedef long long ll;\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef vector<int> vi;\n\nstruct Stat {\n  ll d;\n  int i, j;\n  Stat() {}\n  Stat(ll _d, int _i, int _j): d(_d), i(_i), j(_j) {}\n  bool operator<(const Stat &s) const { return d > s.d; }\n};\n\n/* global variables */\n\nint xys[MAX_GN][2];\nvi nbrs[2][MAX_N];\nbool sws[MAX_GN];\nll dists[MAX_GN][2];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  xys[0][0] = xys[0][1] = 0;\n  nbrs[0][0].push_back(0);\n  nbrs[1][0].push_back(0);\n\n  xys[1][0] = m - 1, xys[1][1] = n - 1;\n  nbrs[0][m - 1].push_back(1);\n  nbrs[1][n - 1].push_back(1);\n  \n  int gn = 2;\n  \n  for (int i = 0; i < k; i++) {\n    int xi, yi;\n    cin >> xi >> yi;\n    xi--, yi--;\n\n    if (xi == 0 && yi == 0) sws[0] = true;\n    else if (xi != m - 1 || yi != n - 1) {\n      xys[gn][0] = xi;\n      xys[gn][1] = yi;\n      nbrs[0][xi].push_back(gn);\n      nbrs[1][yi].push_back(gn);\n      sws[gn] = true;\n      gn++;\n    }\n  }\n  //printf(\"gn=%d\\n\", gn);\n\n  for (int i = 0; i < gn; i++)\n    dists[i][0] = dists[i][1] = LINF;\n  dists[0][0] = 0;\n\n  priority_queue<Stat> q;\n  q.push(Stat(0, 0, 0));\n\n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (dists[u.i][u.j] != u.d) continue;\n    if (u.i == 1) break;\n\n    if (sws[u.i]) {\n      int vj = u.j ^ 1;\n      ll vd = u.d + 1;\n      if (dists[u.i][vj] > vd) {\n\tdists[u.i][vj] = vd;\n\tq.push(Stat(vd, u.i, vj));\n      }\n    }\n\n    vi &nbru = nbrs[u.j][xys[u.i][u.j]];\n    for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &vi = *vit;\n      if (vi != u.i) {\n\tll vd = u.d + abs(xys[vi][u.j ^ 1] - xys[u.i][u.j ^ 1]);\n\tif (dists[vi][u.j] > vd) {\n\t  dists[vi][u.j] = vd;\n\t  q.push(Stat(vd, vi, u.j));\n\t}\n      }\n    }\n  }\n\n  ll mind = (dists[1][0] < dists[1][1]) ? dists[1][0] : dists[1][1];\n  printf(\"%lld\\n\", (mind >= LINF) ? -1LL : mind);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K+1],Y[MAX_K+1];\n\nvector<int> map_x[MAX_M],map_y[MAX_N];\n\nbool memo[MAX_K+1][2];\n\nstruct D{\n\tlong long cost;\n\tint k;\n\tint flg;\n};\n\nbool operator <(const D &a,const D &b){\n\treturn a.cost<b.cost;\n}\n\nbool operator >(const D &a,const D &b){\n\treturn a.cost>b.cost;\n}\n\t\nvoid solve(){\n\tpriority_queue<D,vector<D>,greater<D> > que;\n\tfor (vector<int>::iterator i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tD data{Y[*i],*i,1};\n\t\tque.push(data);\n\t}\n\twhile(!que.empty()){\n\t\t//空になるまで続ける\n\t\tD d=que.top();\n\t\tque.pop();\n\t\tif (d.k==K-1){\n\t\t\t//ゴールについた\n\t\t\tprintf(\"%lld\\n\",d.cost);\n\t\t\treturn;\n\t\t}\n\t\tif (memo[d.k][d.flg]) continue;\n\t\tmemo[d.k][d.flg]=true;\n\t\tint x=X[d.k],y=Y[d.k];\n\t\tif (d.flg==0){\n\t\t\t//南北方向に開く\n\t\t\tfor (vector<int>::iterator i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\t\tif (*i==d.k) continue;\n\t\t\t\tD dd{d.cost+abs(Y[*i]-y)+1,*i,1};\n\t\t\t\tque.push(dd);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t//東西方向に開く\n\t\t\tfor (vector<int>::iterator i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\t\tif (*i==d.k) continue;\n\t\t\t\tD dd{d.cost+abs(X[*i]-x)+1,*i,0};\n\t\t\t\tque.push(dd);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tX[i]=x-1;\n\t\tY[i]=y-1;\n\t\tmap_x[x-1].push_back(i);\n\t\tmap_y[y-1].push_back(i);\n\t}\n\tX[K]=M-1;\n\tY[K]=N-1;\n\tmap_x[M-1].push_back(K);\n\tmap_y[N-1].push_back(K);\n\tK++;\n\tfor (int i=0;i<K;i++){\n\t\tmemo[i][0]=memo[i][1]=false;\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<climits>\n#include<cstring>\n#include<map>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\nint H,W,N;\n\nstruct Point { \n  int x,y,b;\n  Point(int x=-1,int y=-1,int b=1):x(x),y(y),b(b){}\n  bool operator < ( const Point &p ) const {\n    if( x != p.x ) return x < p.x;\n    return y < p.y;\n  }\n};\n\nbool cmp(const Point &a,const Point &b) {\n  if( a.y != b.y ) return a.y < b.y;\n  return a.x < b.x;\n}\n\nstruct Data {\n  int cur,dir,cost;\n  bool operator < ( const Data &data ) const {\n    if( cost != data.cost ) return cost > data.cost;\n    if( cur != data.cur ) return cur < data.cur;\n    return dir < data.dir;\n  }\n};\n\nvoid compute(deque<Point> &ps) {\n  sort(ALL(ps));\n  if( !( ps[0].x == 1 && ps[0].y == 1 ) ) {\n    ps.push_front((Point){1,1,0});\n  }\n  if( !( ps[(int)ps.size()-1].x == W && ps[(int)ps.size()-1].y == W ) ) {\n    ps.push_back((Point){W,H,0});\n  }\n\n\n  int n = ps.size();\n  deque<Point> vec = ps;\n  vector<vector<int>> edges(n);\n\n\n  rep(i,n) {\n    int ptr = lower_bound(ALL(ps),ps[i]) - ps.begin();\n    if( ptr - 1 >= 0 ) {\n      if( vec[i].x == vec[ptr-1].x ) {\n\tedges[i].push_back(ptr-1);\n      }\n    }\n    if( ptr + 1 <  n ) {\n      if( vec[i].x == vec[ptr+1].x ) {\n\tedges[i].push_back(ptr+1);\n      }\n    }\n  }\n\n  sort(ALL(ps),cmp);\n\n  rep(i,n) {\n    int ptr = lower_bound(ALL(ps),ps[i],cmp) - ps.begin();\n    if( ptr - 1 >= 0 ) {\n      int ID  = lower_bound(ALL(vec),ps[ptr]) - vec.begin();\n      int adj = lower_bound(ALL(vec),ps[ptr-1]) - vec.begin();\n      assert( adj < n );\n      if( vec[ID].y == vec[adj].y ) {\n\tedges[ID].push_back(adj);\n      }\n    }\n    if( ptr + 1 < n ) {\n      int ID  = lower_bound(ALL(vec),ps[ptr]) - vec.begin();\n      int adj = lower_bound(ALL(vec),ps[ptr+1]) - vec.begin();\n      assert( adj < n );\n      if( vec[ID].y == vec[adj].y ) {\n\tedges[ID].push_back(adj);\n      }\n    }\n  }\n\n  rep(i,n) {\n    sort(ALL(edges[i]));\n    edges[i].erase(unique(ALL(edges[i])),edges[i].end());\n  }\n\n  priority_queue<Data> Q;\n  vector<vector<int>> mini(n,vector<int>(2,INT_MAX));\n  mini[0][0] = 0;\n  Q.push((Data){0,0,0});\n  \n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( vec[data.cur].b && mini[data.cur][(data.dir+1)&1] > data.cost + 1 ) {\n      mini[data.cur][(data.dir+1)&1] = data.cost + 1;\n      Q.push((Data){data.cur,(data.dir+1)&1,data.cost+1});\n    }\n    rep(i,(int)edges[data.cur].size()) {\n      int next = edges[data.cur][i];\n      int cost = abs(vec[data.cur].x-vec[next].x + vec[data.cur].y-vec[next].y);\n      if( data.dir ) {\n\tif( vec[next].y == vec[data.cur].y ) {\n\t  if( mini[next][data.dir] > data.cost + cost ) {\n\t    mini[next][data.dir] = data.cost + cost;\n\t    Q.push((Data){next,data.dir,data.cost+cost});\n\t  }\n\t}\n      } else {\n\tif( vec[next].x == vec[data.cur].x ) {\n\t  if( mini[next][data.dir] > data.cost + cost ) {\n\t    mini[next][data.dir] = data.cost + cost;\n\t    Q.push((Data){next,data.dir,data.cost+cost});\n\t  }\n\t}\n      }      \n    }\n  }\n  int ans = min(mini[n-1][0],mini[n-1][1]);\n  if( ans == INT_MAX ) puts(\"-1\");\n  else printf(\"%d\\n\",ans);\n}\n\n\nint main() {\n  scanf(\"%d %d %d\",&W,&H,&N);\n  deque<Point> ps(N);\n  rep(i,N) scanf(\"%d %d\",&ps[i].x,&ps[i].y);\n  compute(ps);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tpriority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\tcout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???????????????????????????\n\t\tint nr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint nc = lower_bound(sc[r].begin(), sc[r].end(), r) - sc[r].begin();\n\t\tif( 0 <= nr && nr < sr[c].size() && 0 <= nc && nc < sc[r].size() ){\n\t\t\tnr = sr[c][nr];\n\t\t\tnc = sc[r][nc];\n\t\t\tif( nr == r && nc == c ){\n\t\t\t\tque.push(T(cst + 1, !dir, r, c));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin() - 1;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin() - 1;\n\t\t\n\t\tif( 0 <= pr && pr < sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\tif( 0 <= pc && pc < sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t}\n\t//??´??????????¨????????????????\n\tsc[h-1].push_back(w-1);\n\tsc[w-1].push_back(h-1);\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra();\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nusing PLLL = pair<ll, PLL >;\n\nll MOD = 1e9+7;\nint M, N, K;\nvector<PII> X[114514], Y[114514];\nvector<PII> G[114514][2];\nll d[114514][2];\nint g_n = -1;\nint th_s_s = 0; // 0,0??????????????????????????????????????????\n\nint main(void){\n\tcin >> M >> N >> K;\n\tREP(i, 114514){\n\t\tREP(j, 2){\n\t\t\td[i][j] = INF_LL;\n\t\t}\n\t}\n\tREP(i, K){\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tX[x].push_back({y, i+1});\n\t\tY[y].push_back({x, i+1});\n\t\tif(x == M-1 && y == N-1){\n\t\t\tg_n = i+1;\n\t\t}\n\t\tif(x == 0 && y == 0)\n\t\t\tth_s_s = 1;\n\t}\n\tif(g_n == -1){\n\t\tX[M-1].push_back({N-1, K+1});\n\t\tY[N-1].push_back({M-1, K+1});\n\t\tg_n = K+1;\n\t}\n\n\tREP(i, M){\n\t\tREP(j, X[i].size()){\n\t\t\tREP(k, X[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[X[i][j].second][0].push_back({abs(X[i][j].first-X[i][k].first), X[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, N){\n\t\tREP(j, Y[i].size()){\n\t\t\tREP(k, Y[i].size()){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tG[Y[i][j].second][1].push_back({abs(Y[i][j].first-Y[i][k].first), Y[i][k].second});\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<pair<ll, pair<int, int> >, vector<pair<ll, pair<int, int> > >, greater<pair<ll, pair<int, int> > > > pq;\n\td[0][0] = 0;\n\tREP(i, X[0].size()){\n\t\td[X[0][i].second][0] = X[0][i].first;\n\t\td[X[0][i].second][1] = min(d[X[0][i].second][1], (ll)X[0][i].first+1);\n\t\tpq.push({X[0][i].first+1, {X[0][i].second, 1}});\n\t}\n\tif(th_s_s){\n\t\tREP(i, Y[0].size()){\n\t\t\td[Y[0][i].second][1] = Y[0][i].first+1;\n\t\t\td[Y[0][i].second][0] = min(d[Y[0][i].second][0], (ll)Y[0][i].first+2);\n\t\t\tpq.push({Y[0][i].first+1, {Y[0][i].second, 0}});\n\t\t}\n\t}\n\twhile(pq.size()){\n\t\tpair<ll, pair<int, int> > p = pq.top(); pq.pop();\n\t\tint v = p.second.first, s = p.second.second;\n\n\t\tif(d[v][s] < p.first) continue;\n\t\tREP(i, G[v][s].size()){\n\t\t\tif(d[G[v][s][i].second][s] > d[v][s] + G[v][s][i].first){\n\t\t\t\td[G[v][s][i].second][s] = d[v][s] + G[v][s][i].first;\n\t\t\t\td[G[v][s][i].second][(s+1)%2] = min(d[G[v][s][i].second][(s+1)%2], d[G[v][s][i].second][s]+1);\n\t\t\t\tpq.push({d[G[v][s][i].second][(s+1)%2], {G[v][s][i].second, (s+1)%2}});\n\t\t\t}\n\t\t}\n\t}\n\tif(d[g_n][0] == INF_LL && d[g_n][1] == INF_LL){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << min(d[g_n][0], d[g_n][1]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint kx[200010],ky[200010];\nint main(){\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx[i]>>ky[i];\n\t\tse[0][kx[i]].insert(ky[i]);\n\t\tse[1][ky[i]].insert(kx[i]);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq,sag;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\tcout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tsag.push(node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!sag.empty()){\n\t\t\t\tno2=sag.top();sag.pop();\n\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1e18)\n\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> P2; // dist & (from_direction , now)\n\nint main() {\n    long long M,N,K;\n    cin >> M >> N >> K;\n    \n    vector<P> s[2];\n    s[0].push_back(P(1,0));\n    s[1].push_back(P(1,0));\n\n    for(int i=1; i<=K; ++i) {\n        long long a,b;\n        cin >> a >> b;\n        s[0].push_back(P(a,i));\n        s[1].push_back(P(b,i));\n    }\n\n    s[0].push_back(P(M,K+1));\n    s[1].push_back(P(N,K+1));\n\n    sort(s[0].begin(),s[0].end());\n    sort(s[1].begin(),s[1].end());\n\n    vector<vector<long long> > to[2]; // to[0] ... NS direction / to[1] ... EW direction\n    to[0].resize(K+2);\n    to[1].resize(K+2);\n    for(int i=1; i<=K+1; ++i) {\n        if(s[0][i-1].first==s[0][i].first) {\n            to[0][s[0][i-1].second].push_back(s[0][i].second);\n            to[0][s[0][i].second].push_back(s[0][i-1].second);\n        }\n        if(s[1][i-1].first==s[1][i].first) {\n            to[1][s[1][i-1].second].push_back(s[1][i].second);\n            to[1][s[1][i].second].push_back(s[1][i-1].second);\n        }\n    }\n\n    sort(s[0].begin(),s[0].end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n    sort(s[1].begin(),s[1].end(),[](P& lhs, P& rhs) {\n        return (lhs.second<rhs.second);\n    });\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    unordered_set<long long> visited; // visited[0] ... from NS direction / visited[1] ... from EW direction\n    vector<long long> dist[2];\n    dist[0].resize(K+2,INF);\n    dist[1].resize(K+2,INF);\n    q.push(P2(0,P(0,0))); // dist & (from_direction , now)\n//    visited[1].insert(0);\n    while(!q.empty()) {\n        P2 pp=q.top(); q.pop();\n        long long now_dist=pp.first;\n        long long now_from=pp.second.first;\n        long long now_sw=pp.second.second;\n        long long nxt_dist;\n        cout << \"now_sw=(\" << s[0][now_sw].first << \",\" << s[1][now_sw].first << \"), now_dist=\" << now_dist << \", now_from=\" << now_from << endl;\n        if(s[0][now_sw].first==M && s[1][now_sw].first==N) {\n            dist[now_from][K+1]=now_dist;\n            break;\n        }\n        if(visited.count(now_sw)!=0 || dist[now_from][now_sw]<now_dist) continue;\n        visited.insert(now_sw);\n        for(int i=0; i<(int)to[now_from][now_sw].size(); ++i) { // same direction\n            long long nxt=to[now_from][now_sw][i];\n            if(visited.count(nxt)!=0) continue;\n            nxt_dist=now_dist+\n                ((s[(now_from+1)%2][now_sw].first>s[(now_from+1)%2][nxt].first)\n                            ?(s[(now_from+1)%2][now_sw].first-s[(now_from+1)%2][nxt].first)\n                            :(s[(now_from+1)%2][nxt].first-s[(now_from+1)%2][now_sw].first));\n            if(dist[now_from][nxt]<=nxt_dist || dist[(now_from+1)%2][nxt]<=nxt_dist+1) continue; \n            dist[now_from][nxt]=nxt_dist;\n            q.push(P2(nxt_dist,P(now_from,nxt)));\n        }\n        for(int i=0; i<(int)to[(now_from+1)%2][now_sw].size(); ++i) { // change direction\n            long long nxt=to[(now_from+1)%2][now_sw][i];\n            if(visited.count(nxt)!=0) continue;\n            nxt_dist=1+now_dist+\n                ((s[now_from][now_sw].first>s[now_from][nxt].first)\n                            ?(s[now_from][now_sw].first-s[now_from][nxt].first)\n                            :(s[now_from][nxt].first-s[now_from][now_sw].first));\n            if(dist[(now_from+1)%2][nxt]<=nxt_dist || dist[now_from][nxt]<=nxt_dist+1) continue;\n            dist[(now_from+1)%2][nxt]=nxt_dist;\n            q.push(P2(nxt_dist,P((now_from+1)%2,nxt)));\n        }\n        nxt_dist=dist[(now_from+1)%2][now_sw]=min(now_dist+1,dist[(now_from+1)%2][now_sw]);\n        q.push(P2(nxt_dist,P((now_from+1)%2,now_sw)));\n    }\n\n    long long ans=min(dist[0][K+1],dist[1][K+1]);\n    if(ans==INF) ans=-1;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n \nll d[200000][2];\nint x[200000],y[200000];\nvector<int>X[100000],Y[100000];\nstruct st{\n    int p;bool b;ll c;\n};\nbool operator<(const st&a,const st&b){\n    return a.c>b.c;\n}\nint main() {\n    int m,n,k;scanf(\"%d%d%d\",&m,&n,&k);\n    rep(i,k){\n        scanf(\"%d%d\",&x[i],&y[i]);x[i]--;y[i]--;\n        X[x[i]].push_back(i);Y[y[i]].push_back(i);\n    }\n    priority_queue<st>que;\n    fill(d[0],d[k],INF);\n    for(int&u:X[0]){\n        d[u][1]=y[u];\n        que.push({u,1,d[u][1]});\n    }\n    while(!que.empty()){\n        st p=que.top();que.pop();\n        if(d[p.p][p.b]!=p.c)continue;\n        if(p.b){\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])){\n                    d[u][1]=p.c+abs(y[p.p]-y[u]);\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])+1){\n                    d[u][0]=p.c+abs(x[p.p]-x[u])+1;\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n        else{\n            for(int&u:X[x[p.p]]){\n                if(d[u][1]>p.c+abs(y[p.p]-y[u])+1){\n                    d[u][1]=p.c+abs(y[p.p]-y[u])+1;\n                    que.push({u,1,d[u][1]});\n                }\n            }\n            for(int&u:Y[y[p.p]]){\n                if(d[u][0]>p.c+abs(x[p.p]-x[u])){\n                    d[u][0]=p.c+abs(x[p.p]-x[u]);\n                    que.push({u,0,d[u][0]});\n                }\n            }\n        }\n    }\n    ll Min=INF;\n    for(int&u:X[m-1]){\n        Min=min(Min,d[u][1]+abs(y[u]-n+1));\n        Min=min(Min,d[u][0]+1+abs(y[u]-n+1));\n    }\n    for(int&u:Y[n-1]){\n        Min=min(Min,d[u][0]+abs(x[u]-m+1));\n        Min=min(Min,d[u][1]+1+abs(x[u]-m+1));\n    }\n    if(Min==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 250000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_N], yoko[MAX_N];//yoko->|   o  o |\n\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\n\tlong long G = solve();\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define INF 1001001001001001001\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef pair<ll,pa > ppa;\n\nvector<pa> ve[2][100010];\nint swi[2][200010];\nll res[2][200010];\nint main(){\n\tint M,N,K;\n\tcin>>M>>N>>K;\n\tint a,b,aa=0;\n\tbool fla=false,fla2=false;\n\tfor(int i=1;i<=K;i++){\n\t\tcin>>a>>b;\n\t\tve[1][a].push_back(pa(i,b));\n\t\tve[0][b].push_back(pa(i,a));\n\t\tswi[0][i]=a;swi[1][i]=b;\n\t\tif(a==1&&b==1){\n\t\t\tfla=true;\n\t\t\taa=i;\n\t\t}\n\t\tif(a==M&&b==N){\n\t\t\tfla2=true;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfill(res[i],res[i]+2+K,INF);\n\t}\n\treturn 0;//debug\n\n\tpriority_queue<ppa,vector<ppa>,greater<ppa> > que;\n\tfor(vector<pa>::iterator it=ve[1][1].begin();it!=ve[1][1].end();it++){\n\t\tque.push(ppa(it->second-1,pa(1,it->first)));\n\t}\n\tif(fla){\n\t\tres[0][aa]=0;\n\t}\n\twhile(!que.empty()){\n\t\tll dis=que.top().first;\n\t\tint yota=que.top().second.first;\n\t\tint ten=que.top().second.second;\n\t\tque.pop();\n\t\tif(res[yota][ten]<INF) continue;\n\t\tres[yota][ten]=dis;\n\t\tres[1-yota][ten]=dis+1;\n\t\tfor(vector<pa>::iterator it=ve[1-yota][swi[yota][ten]].begin();it!=ve[1-yota][swi[yota][ten]].end();it++){\n\t\t\tint saki=it->first;int ba=it->second;\n\t\t\tif(res[1-yota][saki]==INF){\n\t\t\t\tque.push(ppa(dis+1+abs(swi[1-yota][ten]-ba),pa(1-yota,saki)));\n\t\t\t}\n\t\t}\n\t}\n\tll ress=INF;\n\tfor(vector<pa>::iterator it=ve[0][N].begin();it!=ve[0][N].end();it++){\n\t\tress=min(ress,res[1][it->first]+1+abs(M-it->second));\n\t}\n\tfor(vector<pa>::iterator it=ve[1][M].begin();it!=ve[1][M].end();it++){\n\t\tress=min(ress,res[0][it->first]+1+abs(N-it->second));\n\t}\n\tif(ress<INF) cout<<ress<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAX_K = 200002;\n\nstruct Data\n{\n    int v, cost, s;\n    Data() {}\n    Data(int _v, int _cost, int _s) { v = _v; cost = _cost; s = _s; }\n\n    bool operator < (const Data &a) const\n    {\n        return cost > a.cost;\n    }\n};\n\nstruct Edge\n{\n    int to, cost;\n    Edge() {}\n    Edge(int _to, int _cost) { to = _to; cost = _cost; }\n};\n\nint N, M, K, X[MAX_K], Y[MAX_K];\npair<int, int> P[MAX_K];\nvector<Edge> e[MAX_K][2];\n\nvoid GenerateEdge(vector<int> &v, int pos[MAX_K], int s)\n{\n    sort(v.begin(), v.end());\n    for (int i = 0; i < v.size(); i++)\n    {\n        if (i > 0) e[v[i]][s].push_back(Edge(v[i - 1], abs(pos[v[i]] - pos[v[i - 1]])));\n        if (i < v.size() - 1) e[v[i]][s].push_back(Edge(v[i + 1], abs(pos[v[i]] - pos[v[i + 1]])));\n    }\n}\n\nsigned main()\n{\n    cin >> N >> M >> K;\n    map<int, vector<int> > mx, my;\n    for (int i = 1; i <= K; i++)\n    {\n        cin >> P[i].first >> P[i].second;\n    }\n    K += 2;\n    P[0] = make_pair(1, 1);\n    P[K - 1] = make_pair(N, M);\n    sort(P, P + K);\n    for (int i = 0; i < K; i++)\n    {\n        X[i] = P[i].first; Y[i] = P[i].second;\n        mx[X[i]].push_back(i);\n        my[Y[i]].push_back(i);\n    }\n    map<int, vector<int> >::iterator ix = mx.begin(), iy = my.begin();\n    while (ix != mx.end()) GenerateEdge(ix->second, Y, 0), ix++;\n    while (iy != my.end()) GenerateEdge(iy->second, X, 1), iy++;\n\n    priority_queue<Data> pq;\n    pq.push(Data(0, 0, 0));\n    bool isUsed[MAX_K][2] = {};\n    int ans = -1;\n    while (!pq.empty())\n    {\n        Data t = pq.top(); pq.pop();\n        if (t.v == K - 1)\n        {\n            ans = t.cost;\n            break;\n        }\n        if (isUsed[t.v][t.s]) continue;\n        isUsed[t.v][t.s] = true;\n        for (int i = 0; i < e[t.v][t.s].size(); i++)\n        {\n            pq.push(Data(e[t.v][t.s][i].to, t.cost + e[t.v][t.s][i].cost, t.s));\n        }\n        pq.push(Data(t.v, t.cost + 1, 1 - t.s));\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tcout<<\"WA!!!!!!!!!!!!!\"<<endl;\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+(long long)1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int INF=1001001001001001001ll;\n\nint H,W,K;\nint X[200000],Y[200000];\n\nvpint row[100000],column[100000];\n\nint to[200000][4];\nint cc[200000][4];\nint dist[200000][2];\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&K);\n    rep(i,K)scanf(\"%lld%lld\",&X[i],&Y[i]),X[i]--,Y[i]--;\n\n    rep(i,K){\n        row[Y[i]].pb(pint(X[i],i));\n        column[X[i]].pb(pint(Y[i],i));\n    }\n\n    rep(i,H)sort(all(row[i]));\n    rep(i,W)sort(all(column[i]));\n\n    memset(to,-1,sizeof(to));\n\n    rep(i,H){\n        rep(j,row[i].size()){\n            if(j){\n                to[row[i][j].se][3]=row[i][j-1].se;\n                cc[row[i][j].se][3]=row[i][j].fi-row[i][j-1].fi;\n            }\n            if(j+1!=row[i].size()){\n                to[row[i][j].se][1]=row[i][j+1].se;\n                cc[row[i][j].se][1]=row[i][j+1].fi-row[i][j].fi;\n            }\n        }\n    }\n\n    rep(i,W){\n        rep(j,column[i].size()){\n            if(j){\n                to[column[i][j].se][0]=column[i][j-1].se;\n                cc[column[i][j].se][0]=column[i][j].fi-column[i][j-1].fi;\n            }\n            if(j+1!=column[i].size()){\n                to[column[i][j].se][2]=column[i][j+1].se;\n                cc[column[i][j].se][2]=column[i][j+1].fi-column[i][j].fi;\n            }\n        }\n    }\n    if(column[0].size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    int start=column[0][0].se;\n    fill_n(*dist,200000*2,INF);\n    dist[start][0]=Y[start];\n    priority_queue<pair<int,pint> >que;\n    que.push(mp(-Y[start],pint(start,0)));\n\n    while(que.size()){\n        int c=-que.top().fi;\n        int v=que.top().se.fi;\n        int d=que.top().se.se;\n        que.pop();\n        if(dist[v][d]<c)continue;\n\n        if(dist[v][1-d]>c+1){\n            dist[v][1-d]=c+1;\n            que.push(mp(-dist[v][1-d],pint(v,1-d)));\n        }\n\n        rep(i,4){\n            if(to[v][i]==-1)continue;\n            if(i%2!=d)continue;\n            int u=to[v][i];\n            int cost=cc[v][i];\n            if(dist[u][d]<=c+cost)continue;\n            dist[u][d]=c+cost;\n            que.push(mp(-dist[u][d],pint(u,d)));\n        }\n    }\n\n    int ans=INF;\n    rep(i,K){\n        //cout<<i<<\" \"<<dist[i][0]<<\" \"<<dist[i][1]<<endl;\n        if(X[i]!=W-1&&Y[i]!=H-1)continue;\n        rep(j,2){\n            int cost=W-1-X[i]+H-1-Y[i];\n            if((X[i]==W-1&&j==1)||(Y[i]==H-1&&j==0))cost++;\n            chmin(ans,dist[i][j]+cost);\n        }\n    }\n    if(ans==INF)puts(\"-1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define BFSMAX 1100\n#define MAX_W 110000\n#define MAX_N 210000\n#define INF 1LL<<60\n\nlong long h, w, K;\n\npair<long long, long long> tap[MAX_N];\nvector<pair<long long, long long>>tate[MAX_W], yoko[MAX_W];//yoko->|   o  o |\n\nlong long path[BFSMAX][BFSMAX][2], x[BFSMAX][BFSMAX];\nlong long color[MAX_N][2], dist[MAX_N][2];\nvector<pair<long long, long long>>graph1[MAX_N], graph2[MAX_N];\n\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>Q1, Q2;\nqueue<pair<int, int>>Q_1, Q_2;\n\nvoid dijkstra() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tdist[i][0] = INF;\n\t\tdist[i][1] = INF;\n\t\tcolor[i][0] = WHITE;\n\t\tcolor[i][1] = WHITE;\n\t}\n\tdist[K][0] = 0;\n\tcolor[K][0] = GRAY;\n\tQ1.push(make_pair(0LL, K));\n\twhile (!Q1.empty() || !Q2.empty()) {\n\t\t//Q1.\n\t\tif (!Q1.empty()) \n\t\t{\n\t\t\tpair<long long, long long>C = Q1.top();\n\t\t\tQ1.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][0] = BLACK;\n\t\t\tif (dist[D][0] < C.first) { \n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph1[D].size(); j++) {\n\t\t\t\tint E = graph1[D][j].first;\n\t\t\t\tint F = graph1[D][j].second;\n\t\t\t\tif (color[E][1] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][1] > dist[D][0] + F) {\n\t\t\t\t\tdist[E][1] = dist[D][0] + F;\n\t\t\t\t\tcolor[E][1] = GRAY;\n\t\t\t\t\tQ2.push(make_pair(dist[E][1], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Q2.empty())\n\t\t{\n\t\t\tpair<long long, long long>C = Q2.top();\n\t\t\tQ2.pop();\n\t\t\tlong long D = C.second;\n\t\t\tcolor[D][1] = BLACK;\n\t\t\tif (dist[D][1] < C.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < graph2[D].size(); j++) {\n\t\t\t\tint E = graph2[D][j].first;\n\t\t\t\tint F = graph2[D][j].second;\n\t\t\t\tif (color[E][0] == BLACK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (dist[E][0] > dist[D][1] + F) {\n\t\t\t\t\tdist[E][0] = dist[D][1] + F;\n\t\t\t\t\tcolor[E][0] = GRAY;\n\t\t\t\t\tQ1.push(make_pair(dist[E][0], E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve() {\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < tate[i].size(); j++) {\n\t\t\tfor (int k = j; k < tate[i].size(); k++) {\n\t\t\t\tint A1 = tate[i][j].second;\n\t\t\t\tint B1 = tate[i][k].second;\n\t\t\t\tint A2 = tate[i][j].first;\n\t\t\t\tint B2 = tate[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph1[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph1[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\tfor (int j = 0; j < yoko[i].size(); j++) {\n\t\t\tfor (int k = j + 1; k < yoko[i].size(); k++) {\n\t\t\t\tint A1 = yoko[i][j].second;\n\t\t\t\tint B1 = yoko[i][k].second;\n\t\t\t\tint A2 = yoko[i][j].first;\n\t\t\t\tint B2 = yoko[i][k].first;\n\t\t\t\tint C = 0;\n\t\t\t\tif (B1 != K + 1) { C = 1; }\n\t\t\t\tgraph2[A1].push_back(make_pair(B1, abs(A2 - B2) + C));\n\t\t\t\tgraph2[B1].push_back(make_pair(A1, abs(A2 - B2) + C));\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra();\n\treturn min(dist[K + 1][0], dist[K + 1][1]);\n}\n\nvoid _memset() {\n\tmemset(tap, 0, sizeof(tap));\n\tmemset(color, 0, sizeof(color));\n\tmemset(dist, 0, sizeof(dist));\n\tfor (int i = 0; i < MAX_W; i++) {\n\t\ttate[i].clear();\n\t\tyoko[i].clear();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tgraph1[i].clear();\n\t\tgraph2[i].clear();\n\t}\n}\n\nlong long bfs() {\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tpath[i][j][0] = INF;\n\t\t\tpath[i][j][1] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tx[tap[i].first][tap[i].second] = 1;\n\t}\n\tQ_1.push(make_pair(1, 1));\n\tpath[1][1][0] = 0;\n\n\twhile (!Q_1.empty() || !Q_2.empty())\n\t{\n\t\tif (!Q_1.empty()) {\n\t\t\tpair<long long, long long> H = Q_1.front(); Q_1.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I][J + 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J + 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J + 1));\n\t\t\t\t}\n\t\t\t\tif (path[I][J - 1][0] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J - 1][0] = path[I][J][0] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][1] > path[I][J][0] + 1) {\n\t\t\t\t\tpath[I][J][1] = path[I][J][0] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Q_2.empty()) {\n\t\t\tpair<long long, long long> H = Q_2.front(); Q_2.pop();\n\t\t\tlong long I = H.first;\n\t\t\tlong long J = H.second;\n\t\t\tif (x[I][J] <= 1) {\n\t\t\t\tif (path[I + 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I + 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I + 1, J));\n\t\t\t\t}\n\t\t\t\tif (path[I - 1][J][1] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I - 1][J][1] = path[I][J][1] + 1;\n\t\t\t\t\tQ_2.push(make_pair(I - 1, J));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[I][J] == 1) {\n\t\t\t\tif (path[I][J][0] > path[I][J][1] + 1) {\n\t\t\t\t\tpath[I][J][0] = path[I][J][1] + 1;\n\t\t\t\t\tQ_1.push(make_pair(I, J));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min(path[w][h][0], path[w][h][1]);\n}\n\nint main() {\n\t_memset();\n\tcin >> w >> h >> K;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> tap[i].first >> tap[i].second;//cin.x,y\n\t}\n\ttap[K] = make_pair(1, 1);\n\ttap[K + 1] = make_pair(w, h);\n\tfor (int i = 0; i < K + 2; i++) {\n\t\ttate[tap[i].first].push_back(make_pair(tap[i].second, i));\n\t\tyoko[tap[i].second].push_back(make_pair(tap[i].first, i));\n\t}\n\tlong long G;\n\tif (w <= 1000 && h <= 1000) { G = bfs(); }\n\telse { G = solve(); }\n\tif (G >= INF) { G = -1; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct p1 {\n\tint idx, x, y;\n};\nbool operator<(const p1& r1, const p1& r2) {\n\tif (r1.y != r2.y) return r1.y < r2.y;\n\treturn r1.x < r2.x;\n}\nstruct edge {\n\tint to; long long cost; int type;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint H, W, N;\nint main() {\n\tcin >> W >> H >> N;\n\tvector<p1> p(N);\n\tfor (int i = 0; i < N; i++) cin >> p[i].x >> p[i].y, p[i].x--, p[i].y--, p[i].idx = i;\n\tp.push_back(p1{ N, W - 1, H - 1 }); N++;\n\tvector<vector<p1> > ex(W), ey(H);\n\tfor (int i = 0; i < N; i++) {\n\t\tex[p[i].x].push_back(p[i]);\n\t\tey[p[i].y].push_back(p[i]);\n\t}\n\tfor (int i = 0; i < W; i++) sort(ex[i].begin(), ex[i].end());\n\tfor (int i = 0; i < H; i++) sort(ey[i].begin(), ey[i].end());\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 1; j < ex[i].size(); j++) {\n\t\t\tint d = ex[i][j].y - ex[i][j - 1].y;\n\t\t\tG[ex[i][j - 1].idx].push_back(edge{ ex[i][j].idx, d, 0 });\n\t\t\tG[ex[i][j].idx].push_back(edge{ ex[i][j - 1].idx, d, 0 });\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < ey[i].size(); j++) {\n\t\t\tint d = ey[i][j].x - ey[i][j - 1].x;\n\t\t\tG[ey[i][j - 1].idx].push_back(edge{ ey[i][j].idx, d, 1 });\n\t\t\tG[ey[i][j].idx].push_back(edge{ ey[i][j - 1].idx, d, 1 });\n\t\t}\n\t}\n\tpriority_queue<edge> que;\n\tvector<long long> dist(N, -1);\n\tif (ex[0].size()) {\n\t\tque.push(edge{ ex[0][0].idx, ex[0][0].y, 0 });\n\t\tdist[ex[0][0].idx] = ex[0][0].y;\n\t}\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tlong long d = u.cost;\n\t\t\tif (e.type == 0) d += abs(p[u.to].y - p[e.to].y);\n\t\t\telse d += abs(p[u.to].x - p[e.to].x);\n\t\t\tif (u.type != e.type) d++;\n\t\t\tif (dist[e.to] > d || dist[e.to] == -1) {\n\t\t\t\tdist[e.to] = d;\n\t\t\t\tque.push(edge{ e.to, d, e.type });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nstruct edge{\n  ll to,cost;\n  edge(ll t,ll c){\n    to=t,cost=c;\n  }\n};\nstruct state{\n  ll pos,flg,cost;\n  state(ll p,ll f,ll c){\n    pos=p,flg=f,cost=c;\n  }\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nvector<P> t[MAX][2];\nll W,H,K,X[MAX],Y[MAX];\nll d[MAX][2];\nvector<edge> G[MAX][2];\n \nll solve(){\n  if(t[1][0].empty())return -1;\n  for(int i=0;i<MAX;i++)d[i][0]=d[i][1]=10000000000000000LL;\n  priority_queue< state > Q;\n  P p=t[1][0][0];\n  Q.push( state( p.second, 0, p.first-1 ) );\n  d[p.second][0]=p.first-1;\n   \n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos][s.flg])continue;\n    for(int f=0;f<2;f++){\n      int nf=(s.flg+f)%2;\n      for(int i=0;i<(int)G[s.pos][nf].size();i++){\n        edge e=G[s.pos][nf][i];\n        ll ncost=s.cost+e.cost+f;\n        if(e.cost==0)ncost=s.cost;\n        if(ncost<d[e.to][nf]){\n          d[e.to][nf]=ncost;\n          Q.push( state(e.to,nf,ncost) );\n        }\n      }\n    }\n  }\n  ll res=min(d[K][0],d[K][1]);\n  if(res==10000000000000000LL;)return -1;\n  else return res;\n}\n       \nint main(){\n  scanf(\"%lld %lld %lld\",&W,&H,&K);\n  for(int i=0;i<K;i++){\n    scanf(\"%lld %lld\",&X[i],&Y[i]);\n    t[X[i]][0].push_back(P(Y[i],i));\n    t[Y[i]][1].push_back(P(X[i],i));\n  }\n  t[W][0].push_back(P(H,K));\n  t[H][1].push_back(P(W,K));\n  X[K]=W;\n  Y[K]=H;\n  for(int i=1;i<=100000;i++){\n    for(int f=0;f<2;f++){\n      vector<P> &vec=t[i][f];\n      sort(vec.begin(),vec.end());\n      int size=vec.size();\n      for(int j=0;j<size;j++){\n        P p=vec[j],q;\n        if(0<j){\n          q=vec[j-1];\n          G[p.second][f].push_back( edge(q.second,p.first-q.first) );\n        }\n        if(j+1<size){\n          q=vec[j+1];\n          G[p.second][f].push_back( edge(q.second,q.first-p.first) );\n        }\n      }\n    }\n  }\n  cout<<solve()<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long int LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nstruct room\n{\n  int num;\n  bool visited[2];\n  \n  bool operator<(const room r) const\n  {\n    return num < r.num;\n  }\n  bool operator>(const room r) const\n  {\n    return num > r.num;\n  }\n};\n\nstruct r_compare\n{\n  LL cost;\n  int loc_x, loc_y;\n  bool sw;\n\n  bool operator<(const r_compare r) const\n  {\n    return cost < r.cost;\n  }\n  bool operator>(const r_compare r) const\n  {\n    return cost > r.cost;\n  }\n};\n\nint m, n, k;\nvector<room> ns[100010], ew[100010];\npriority_queue<r_compare, vector<r_compare>, greater<r_compare> > Q;\n\nLL dijk()\n{\n  if(ns[1].size() == 0)\n    return -1;\n\n  r_compare qin = {(ns[1].begin())->num - 1, 1, (ns[1].begin())->num, false};\n  Q.push(qin);\n\n  while(!Q.empty()){\n    r_compare c_now = Q.top();\n    Q.pop();\n\n    if(c_now.loc_x == m && c_now.loc_y == n)\n      return c_now.cost;\n\n    room sr = {(!c_now.sw ? c_now.loc_y : c_now.loc_x), {false, false}};\n    vector<room>::iterator r_now = !c_now.sw ? lower_bound(ns[c_now.loc_x].begin(), ns[c_now.loc_x].end(), sr) : lower_bound(ew[c_now.loc_y].begin(), ew[c_now.loc_y].end(), sr);\n\n    if(!r_now->visited[c_now.sw]){\n      r_now->visited[c_now.sw] = true;\n      \n      if(!c_now.sw){\n\tif(r_now != ns[c_now.loc_x].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, c_now.loc_x, (r_now - 1)->num, false};\n\t  Q.push(qin);\n\t}\n\tif(r_now != ns[c_now.loc_x].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, c_now.loc_x, (r_now + 1)->num, false};\n\t  Q.push(qin);\n\t}\n      }\n      else{\n\tif(r_now != ew[c_now.loc_y].begin()){\n\t  r_compare qin = {c_now.cost + r_now->num - (r_now - 1)->num, (r_now - 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}/*\n\tif(r_now != ew[c_now.loc_y].end() - 1){\n\t  r_compare qin = {c_now.cost + (r_now + 1)->num - r_now->num, (r_now + 1)->num, c_now.loc_y, true};\n\t  Q.push(qin);\n\t}*/\n      }\n\n      r_compare qin = {c_now.cost + 1, c_now.loc_x, c_now.loc_y, !c_now.sw};\n      Q.push(qin);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &m, &n, &k);\n  \n  bool last = false;\n  for(int i = 0; i < k; i++){\n    int x, y;\n    if(x == m && y == n)\n      last = true;\n    scanf(\"%d%d\", &x, &y);\n    room xin = {y, {false, false}}, yin = {x, {false, false}};\n    ns[x].PB(xin);\n    ew[y].PB(yin);\n  }\n  \n  if(!last){\n    room xin = {n, {false, false}}, yin = {m, {false, false}};\n    ns[m].PB(xin);\n    ew[n].PB(yin);\n  }\n  \n  for(int i = 1; i <= m; i++)\n    sort(ns[i].begin(), ns[i].end());\n  for(int i = 1; i <= m; i++)\n    sort(ew[i].begin(), ew[i].end());\n\n  printf(\"%lld\\n\", dijk());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n#define fi first\n#define se second\nconst int inf = 1e18;\ntypedef pair<int,int> P;\n\nvector<P> x[200001], y[200001], G[400010];\npriority_queue<P, vector<P>, greater<P> > q;\nint d[400010], w, h, n;\n\nvoid input(){\n\tfill(d, d+400010, inf);\n\tscanf(\"%lld%lld%lld\", &w, &h, &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint yy, xx;\n\t\tscanf(\"%lld%lld\", &xx, &yy);\n\t\tx[xx].push_back(P(yy, i));\n\t\ty[yy].push_back(P(xx, i));\n\t}\n\tx[1].push_back(P(1, 0));\n\tx[w].push_back(P(h, n+1));\n\ty[h].push_back(P(w, n+1));\n\tn++;\n}\n\nvoid add_edge(){\n\tfor(int i = 1;i <= w;i++){\n\t\tsort(x[i].begin(), x[i].end());\n\t\tfor(int j = 1;j < x[i].size();j++){\n\t\t\tint from = x[i][j-1].se, to = x[i][j].se;\n\t\t\tint cost = x[i][j].fi-x[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= h;i++){\n\t\tsort(y[i].begin(), y[i].end());\n\t\tfor(int j = 1;j < y[i].size();j++){\n\t\t\tint from = y[i][j-1].se+n, to = y[i][j].se+n;\n\t\t\tint cost = y[i][j].fi-y[i][j-1].fi;\n\t\t\tG[from].push_back(P(to, cost));\n\t\t\tG[to].push_back(P(from, cost));\n\t\t}\n\t}\n\tfor(int i = 1;i <= n-1;i++){\n\t\tG[i].push_back(P(i+n, 1));\n\t\tG[i+n].push_back(P(i, 1));\n\t}\n}\n\nvoid dijkstra(){\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tif(d[p.se] < p.fi)continue;\n\t\tfor(int i = 0;i < G[p.se].size();i++){\n\t\t\tint from = p.se, to = G[p.se][i].fi;\n\t\t\tint cost = G[from][i].se;\n\t\t\tif(d[from]+cost < d[to]){\n\t\t\t\td[to] = d[from]+cost;\n\t\t\t\tq.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tinput();\n\tadd_edge();\n\tdijkstra();\n\tint ans = min(d[n], d[2*n]);\n\tif(ans == inf)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <functional>\nstruct Node{\npublic:\n\tstd::vector<std::tuple<int, Node*>> edges{};\n\tint minCost{ INT_MAX };\n\tint x{ 0 }, y{ 0 };\n};\nstruct MinCost {\n\tMinCost(int c, int h, Node* n) :cost{ c }, heuristic{ h }, node{ n } {};\n\tint cost, heuristic;\n\tNode *node;\n\tbool operator>(const MinCost &other) const { return (cost + heuristic) > (other.cost + other.heuristic); }\n\tbool operator<(const MinCost &other) const { return (cost + heuristic) < (other.cost + other.heuristic); }\n};\nint main() {\n\tint m, n, k;\n\tstd::cin >> m >> n >> k;\n\tstd::vector<Node> nodes(k * 2);\n\tauto goal = Node();\n\tgoal.x = m; goal.y = n;\n\tstd::vector<std::vector<Node*>> orderedByX(m + 1, std::vector<Node*>());\n\tstd::vector<std::vector<Node*>> orderedByY(n + 1, std::vector<Node*>());\n\tfor (auto i = 0; i < k; ++i) {\n\t\tstd::cin >> nodes[i * 2].x >> nodes[i * 2].y;\n\t\tnodes[i * 2 + 1].x = nodes[i * 2].x;\n\t\tnodes[i * 2 + 1].y = nodes[i * 2].y;\n\t\tnodes[i * 2].edges.push_back(std::make_tuple(1, &nodes[i * 2 + 1]));\n\t\tnodes[i * 2 + 1].edges.push_back(std::make_tuple(1, &nodes[i * 2]));\n\t\torderedByX[nodes[i * 2].x].push_back(&nodes[i * 2]);\n\t\torderedByY[nodes[i * 2 + 1].y].push_back(&nodes[i * 2 + 1]);\n\t}\n\tfor (auto i = 1; i < orderedByX.size(); ++i) {\n\t\tstd::sort(orderedByX[i].begin(), orderedByX[i].end(), [](const Node* a, const Node* b)->bool {return a->y < b->y; });\n\t}\n\tfor (auto i = 1; i < orderedByY.size(); ++i) {\n\t\tstd::sort(orderedByY[i].begin(), orderedByY[i].end(), [](const Node* a, const Node* b)->bool {return a->x < b->x; });\n\t}\n\tfor (auto &node : orderedByX) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->y - node[i - 1]->y, node[i - 1]));\n\t\t}\n\t}\n\tfor (auto &node : orderedByY) {\n\t\tfor (auto i = 1; i < node.size(); ++i) {\n\t\t\tnode[i - 1]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i]));\n\t\t\tnode[i]->edges.push_back(std::make_tuple(node[i]->x - node[i - 1]->x, node[i - 1]));\n\t\t}\n\t}\n\tif (orderedByX[m].size() != 0) {\n\t\torderedByX[m].back()->edges.push_back(std::make_tuple(n - orderedByX[m].back()->y, &goal));\n\t}\n\tif (orderedByY[n].size() != 0) {\n\t\torderedByY[n].back()->edges.push_back(std::make_tuple(m - orderedByY[n].back()->x, &goal));\n\t}\n\tif (orderedByX[1].size() == 0) {\n\t\tstd::cout << -1 << std::endl; return 0;\n\t}\n\tauto queue = std::priority_queue<MinCost, std::vector<MinCost>, std::greater<MinCost>>();\n\torderedByX[1][0]->minCost = orderedByX[1][0]->y - 1;\n\tqueue.push(MinCost{ orderedByX[1][0]->minCost , 0, orderedByX[1][0] });\n\twhile (!queue.empty() && queue.top().node != &goal) {\n\t\tauto top = queue.top();\n\t\tqueue.pop();\n\t\tif (top.cost == top.node->minCost) {\n\t\t\tfor (auto edge : top.node->edges) {\n\t\t\t\tif (std::get<1>(edge)->minCost > top.cost + std::get<0>(edge)) {\n\t\t\t\t\tstd::get<1>(edge)->minCost = top.cost + std::get<0>(edge);\n\t\t\t\t\tqueue.push(MinCost(std::get<1>(edge)->minCost, m + n - std::get<1>(edge)->y - std::get<1>(edge)->x, std::get<1>(edge)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (queue.empty()) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << goal.minCost << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000,MAX_K=200000;\n\nstruct P{\n\tint x,y;\n\tint index;\n};\n\nbool comp(const P &a,const P &b){\n\tif (a.y!=b.y){\n\t\treturn a.y<b.y;\n\t}\n\treturn a.x<b.x;\n}\n\nbool comp2(const P &a,const P &b){\n\tif (a.x!=b.x){\n\t\treturn a.x<b.x;\n\t}\n\treturn a.y<b.y;\n}\n\nint M,N,K;\nP p[MAX_K+2];\n\nstruct edge{\n\tint to,cost;\n};\n\ntypedef pair<long long,int> PA;\n\nconst long long INF=1000000000000000;\n\nint V;\nvector<edge> G[MAX_K*2+4];\n\nlong long d[MAX_K*2+4];\n\nlong long dijkstra(){\n\tpriority_queue<PA,vector<PA>,greater<PA> > que;\n\tfill(d,d+V,INF);\n\td[K+2]=0;\n\tque.push(PA(0,K+2));\n\twhile(!que.empty()){\n\t\tPA pa=que.top();\n\t\tque.pop();\n\t\tint v=pa.second,dis=pa.first;\n\t\tif (dis>d[v]) continue;\n\t\tfor (int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif (d[v]+e.cost<d[e.to]){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(PA(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn min(d[K+1],d[2*K+3]);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tp[i+1].x=x;\n\t\tp[i+1].y=y;\n\t\tp[i+1].index=i+1;\n\t}\n\tp[0].x=1;\t//スタート\n\tp[0].y=1;\n\tp[0].index=0;\n\tp[K+1].x=M;\t//ゴール\n\tp[K+1].y=N;\n\tp[K+1].index=K+1;\n\tV=K*2+4;\t//頂点の個数\n\t//辺を張る\n\tsort(p,p+K+2,comp);\t//横の辺を張る\n\tfor (int i=0;i<K+1;i++){\n\t\tif (p[i].y==p[i+1].y){\n\t\t\tint cost=p[i+1].x-p[i].x;\n\t\t\tedge e{p[i+1].index,cost};\n\t\t\tG[p[i].index].push_back(e);\n\t\t\te.to=p[i].index;\n\t\t\tG[p[i+1].index].push_back(e);\n\t\t}\n\t}\n\tsort(p,p+K+2,comp2);\t//縦の辺を張る\n\tfor (int i=0;i<K+1;i++){\n\t\tif (p[i].x==p[i+1].x){\n\t\t\tint cost=p[i+1].y-p[i].y;\n\t\t\tedge e{p[i+1].index+K+2,cost};\n\t\t\tG[p[i].index+K+2].push_back(e);\n\t\t\te.to=p[i].index+K+2;\n\t\t\tG[p[i+1].index+K+2].push_back(e);\n\t\t}\n\t}\n\tfor (int i=1;i<=K;i++){\n\t\tedge e{i+K+2,1};\n\t\tG[i].push_back(e);\n\t\te.to=i;\n\t\tG[i+K+2].push_back(e);\n\t}\n\tlong long res=dijkstra();\n\tif (res==INF){\n\t\tres=-1;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_M=100000,MAX_N=100000;\nconst int MAX_K=200000;\n\nint M,N,K;\nint X[MAX_K],Y[MAX_K];\n\nconst long long INF=1000000000000000;\n\nvector<int> map_x[MAX_M];\nvector<int> map_y[MAX_N];\n\nlong long memo[MAX_K][2];\t//memo[i][j]=(????????????i????????????????????????????????????????????????\n\nlong long dfs(int k,int flg){\n\tint x=X[k],y=Y[k];\n\tif (x==M-1 && flg==1){\n\t\treturn N-y-1;\n\t}\n\tif (y==N-1 && flg==0){\n\t\treturn M-x-1;\n\t}\n\tif (memo[k][flg]!=0){\n\t\treturn memo[k][flg];\n\t}\n\tlong long mi=INF;\n\tif (flg==1){\n\t\t//??????????????????????????¨???\n\t\tfor (auto i=map_x[x].begin();i!=map_x[x].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,(long long)(abs(Y[*i]-y) + 1+ dfs(*i,1-flg)));\t//?§??????????????????????+???????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//??±?\\?????????????????????¨???\n\t\tfor (auto i=map_y[y].begin();i!=map_y[y].end();i++){\n\t\t\tif (*i!=k){\n\t\t\t\t//????????\\?????????\n\t\t\t\tmi=min(mi,(long long)(abs(X[*i]-x) + 1+ dfs(*i,1-flg)));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[k][flg]=mi;\n}\n\nvoid solve(){\n\t//????????????????????????????????????\n\tlong long res=INF;\n\tfor (auto i=map_x[0].begin();i!=map_x[0].end();i++){\n\t\tres=min(res,(long long)(Y[*i]+1+dfs(*i,0)));\n\t}\n\tif (res==INF){\n\t\tres=-1;\t//?§£??????\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\tfor (int i=0;i<K;i++){\n\t\tscanf(\"%d %d\",X+i,Y+i);\n\t\tX[i]--;\n\t\tY[i]--;\n\t\tmap_x[X[i]].push_back(i);\n\t\tmap_y[Y[i]].push_back(i);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n\tlong long d;\n\tint x,y,di;\n\tnode(){\n\n\t}\n\tnode(long long dd,int xx,int yy,int did){\n\t\td=dd;x=xx;y=yy;di=did;\n\t}\n};\n\nbool operator <(const node &node1,const node &node2){\n\t\treturn node1.d<node2.d;\n}\nbool operator >(const node &node1,const node &node2){\n\t\treturn node1.d>node2.d;\n}\n\nset<pair<int,int> > used[2];\nset<int> se[2][100010];\nint main(){\n\tint kx,ky;\n\tnode no,no2;\n\tbool flg=false;\n\tset<int>::iterator ite;\n\tint M,N,K;\n\tlong long res=-1;\n\t\n\tcin>>M>>N>>K;\n\tfor(int i=0;i<K;i++){\n\t\tcin>>kx>>ky;\n\t\tse[0][kx].insert(ky);\n\t\tse[1][ky].insert(kx);\n\t}\n\tse[1][N].insert(M);\n\tse[0][M].insert(N);\n\tpriority_queue<node,vector<node>,greater<node> > pq;\n\tpq.push(node(0,1,1,0));\n\twhile(!pq.empty()){\n\t\tno=pq.top();pq.pop();\n\t\t//cout<<no.d<<\" \"<<no.x<<\" \"<<no.y<<\" \"<<no.di<<endl;//\n\t\tif(used[no.di].count(make_pair(no.x,no.y))==0){\n\t\t\tused[no.di].insert(make_pair(no.x,no.y));\n\t\t\t\n\t\t\tif(no.x==M&&no.y==N){\n\t\t\t\tres=no.d-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(ite=se[no.di][(no.di==0?no.x:no.y)].begin();ite!=se[no.di][(no.di==0?no.x:no.y)].end();ite++){\n\t\t\t\tif(used[1-no.di].count(no.di==0?make_pair(no.x,(*ite)):make_pair((*ite),no.y))==0){\n\t\t\t\t\tno2=node(abs((*ite)-(no.di==0?no.y:no.x)),no.di==0?no.x:(*ite),no.di==0?(*ite):no.y,no.di);\n\t\t\t\t\tpq.push(node(no.d+no2.d+1,no2.x,no2.y,1-no.di));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,int> P2;\ntypedef pair<pair<ll,ll>,int> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 20000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint M,N,K;\nstruct edge\n{\n\tint to;\n\tll cost;\n\tedge(int to,ll cost):to(to),cost(cost){}\n};\nvector<edge> G[400100];\nll x[200100],y[200100];\nll d[400100];\nint s=-1,t=-1,room;\nvector<T> xy,yx;\nvoid add_edge(int from,int to,ll cost)\n{\n\tG[from].pb(edge(to,cost));\n\tG[to].pb(edge(from,cost));\n\treturn;\n}\nvoid dijkstra(int S)\n{\n\tfor(int i=0;i<400100;i++)d[i]=INF;\n\td[S]=0;\n\tpriority_queue<P2,vector<P2>,greater<P2> > q;\n\tq.push(P2(0ll,S));\n\twhile(!q.empty())\n\t{\n\t\tP2 a=q.top();\n\t\tq.pop();\n\t\tint v=a.sec;\n\t\tif(d[v]<a.fi)continue;\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost)\n\t\t\t{\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P2(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\troom=K;\n\tfor(int i=0;i<K;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&x[i],&y[i]);\n\t\tif(x[i]==1&&y[i]==1)s=i;\n\t\tif(x[i]==M&&y[i]==N)t=i;\n\t}\n\tif(s==-1)\n\t{\n\t\ts=room;\n\t\tx[room]=1;y[room]=1;\n\t\troom++;\n\t}\n\tif(t==-1)\n\t{\n\t\tt=room;\n\t\tx[room]=M;y[room]=N;\n\t\troom++;\n\t}\n\tfor(int i=0;i<K;i++)add_edge(i,i+room,1ll);\n\tfor(int i=0;i<room;i++)\n\t{\n\t\txy.pb(T(P(x[i],y[i]),i));\n\t\tyx.pb(T(P(y[i],x[i]),i));\n\t}\n\tSORT(xy);\n\tSORT(yx);\n\tfor(int i=1;i<room;i++)\n\t{\n\t\tif(xy[i-1].fi.fi==xy[i].fi.fi)add_edge(xy[i-1].sec,xy[i].sec,xy[i].fi.sec-xy[i-1].fi.sec);\n\t\tif(yx[i-1].fi.fi==yx[i].fi.fi)add_edge(yx[i-1].sec+room,yx[i].sec+room,yx[i].fi.sec-yx[i-1].fi.sec);\n\t}\n\tdijkstra(s);\n\tif(d[t]==INF&&d[t+room]==INF)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%lld\\n\",min(d[t],d[t+room]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll d[200000][2];\nint x[200000], y[200000];\nvector<int>X[100000], Y[100000];\nvector<int>E[200000];\nstruct st {\n\tint p; bool b; ll c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n\tpriority_queue<st>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\tX[x[i]].push_back(i); Y[y[i]].push_back(i);\n\t\tif (x[i] == 0) {\n\t\t\td[i][1] = y[i]; d[i][0] = y[i] + 1;\n\t\t\tque.push({ i,1,d[i][1] });\n\t\t}\n\t}\n\trep(i, m) {\n\t\tsort(X[i].begin(), X[i].end());\n\t\trep(j, int(X[i].size()) - 1) {\n\t\t\tE[X[i][j]].push_back(X[i][j + 1]); E[X[i][j + 1]].push_back(X[i][j]);\n\t\t}\n\t}\n\trep(i, n) {\n\t\tsort(Y[i].begin(), Y[i].end());\n\t\trep(j, int(Y[i].size()) - 1) {\n\t\t\tE[Y[i][j]].push_back(Y[i][j + 1]); E[Y[i][j + 1]].push_back(Y[i][j]);\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tst p = que.top(); que.pop();\n\t\tif (d[p.p][p.b] != p.c)continue;\n\t\tfor (int u : E[p.p]) {\n\t\t\tif (x[u] == x[p.p]) {\n\t\t\t\tif (d[u][1] > p.c + abs(y[p.p] - y[u]) + !p.b) {\n\t\t\t\t\td[u][1] = p.c + abs(y[p.p] - y[u]) + !p.b;\n\t\t\t\t\tque.push({ u,1,d[u][1] });\n\t\t\t\t\td[u][0] = min(d[u][0], d[u][1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d[u][0] > p.c + abs(x[p.p] - x[u]) + p.b) {\n\t\t\t\t\td[u][0] = p.c + abs(x[p.p] - x[u]) + p.b;\n\t\t\t\t\tque.push({ u,0,d[u][0] });\n\t\t\t\t\td[u][1] = min(d[u][1], d[u][0] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll Min = INF;\n\tfor (int u : X[m - 1])Min = min(Min, d[u][1] + abs(y[u] - n + 1));\n\tfor (int u : Y[n - 1])Min = min(Min, d[u][0] + abs(x[u] - m + 1));\n\tif (Min == INF)puts(\"-1\");\n\telse printf(\"%lld\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nvoid solve();\nvoid make_edge(int o);\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppiii;\ntypedef pair<int,pii > pipii;\n\nint M,N,K;\nppiii room[200010];\nvector<pii> V[200010][2];\nint D[200010][2] = {0};\n\nsigned main()\n{\n    scanf(\"%lld%lld%lld\",&M,&N,&K);\n    for(int i = 0; i < K; i++)\n    {\n        scanf(\"%lld%lld\",&room[i].first.first,&room[i].first.second);\n        room[i].second = i;\n    }\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    int ans = 1000000000000000;\n    sort(room,room + K);\n    make_edge(0);\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    make_edge(1);\n    priority_queue<pipii, vector<pipii>, greater<pipii> > Q;\n    for(int i = 0; i < K; i++)\n    {\n        int mem;\n        mem = room[i].first.first;\n        room[i].first.first = room[i].first.second;\n        room[i].first.second = mem;\n    }\n    sort(room,room + K);\n    int I = 0;\n    while(room[I].first.first == 1)\n    {\n        if(room[I].first.second == 1)\n        {\n            Q.push(make_pair(1,make_pair(room[I].second,1)));\n            I++;\n            continue;\n        }\n        Q.push(make_pair(room[I].first.second - 1,make_pair(room[I].second,0)));\n        I++;\n    }\n    while(Q.size())\n    {\n        pipii now = Q.top();\n        Q.pop();\n        if(D[now.second.first][now.second.second] <= now.first && D[now.second.first][now.second.second])\n        {\n            continue;\n        }\n        D[now.second.first][now.second.second] = now.first;\n        Q.push(make_pair(now.first + 1,make_pair(now.second.first,(now.second.second + 1) % 2)));\n        for(int i = 0; i < V[now.second.first][now.second.second].size(); i++)\n        {\n            Q.push(make_pair(now.first + V[now.second.first][now.second.second][i].second,make_pair(V[now.second.first][now.second.second][i].first,now.second.second)));\n        }\n    }\n    for(int i = 0; i < K; i++)\n    {\n        if(room[i].first.first == M && D[room[i].second][0] != 0)\n        {\n            ans = min(ans,(long long)(N - room[i].first.second + D[room[i].second][0]));\n        }\n        if(room[i].first.second == N && D[room[i].second][1] != 0)\n        {\n            ans = min(ans,(long long)(M - room[i].first.first + D[room[i].second][1]));\n        }\n    }\n    if(ans == 1000000000000000)\n    {\n        printf(\"-1\\n\");\n        return;\n    }\n    printf(\"%lld\\n\",ans);\n    return;\n}\n\nvoid make_edge(int o)\n{\n    int mem1 = 0,mem2;\n    for(int i = 0; i < K; i++)\n    {\n        if(mem1 != room[i].first.first)\n        {\n            mem1 = room[i].first.first;\n            mem2 = room[i].first.second;\n            continue;\n        }\n        V[room[i - 1].second][o].push_back(make_pair(room[i].second,room[i].first.second - mem2));\n        V[room[i].second][o].push_back(make_pair(room[i - 1].second,room[i].first.second - mem2));\n        mem2 = room[i].first.second;\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nusing P = pair<ll,int>;\n\nconst int V=400004;\nconst ll INF=LLONG_MAX/3;\n\nstruct Point{int x,y,id;};\nbool cmp1(const Point &l, const Point &r)\n{\n    return l.x==r.x ? l.y<r.y : l.x<r.x;\n}\nbool cmp2(const Point &l, const Point &r)\n{\n    return l.y==r.y ? l.x<r.x : l.y<r.y;\n}\n\nstruct edge{int to; ll cost;};\nvector<edge> G[V];\nll d[V];\n\nint main()\n{\n    int m,n,k;\n    scanf(\" %d %d %d\", &m, &n, &k);\n\n    vector<Point> p(k);\n    rep(i,k) scanf(\" %d %d\", &p[i].x, &p[i].y);\n\n    // sort by x,y\n    sort(all(p),cmp1);\n\n    rep(i,k) p[i].id=i;\n\n    // put switch to goal if there is not\n    if(!(p[k-1].x==m && p[k-1].y==n))\n    {\n        p.pb({m,n,k});\n        ++k;\n    }\n\n    // connect y-direction\n    rep(i,k-1)\n    {\n        if(p[i].x==p[i+1].x)\n        {\n            int dist = p[i+1].y-p[i].y;\n            int u = 2*p[i].id, v = 2*p[i+1].id;\n            G[u].pb({v,dist});\n            G[v].pb({u,dist});\n        }\n    }\n\n    // connect start and p[0]\n    int start = 2*k;\n    if(p[0].x==1)\n    {\n        int u = 2*p[0].id;\n        G[start].pb({u,p[0].y-1});\n        G[u].pb({start,p[0].y-1});\n    }\n\n    // sort by y,x\n    sort(all(p),cmp2);\n\n    // connect x-direction\n    rep(i,k-1)\n    {\n        if(p[i].y==p[i+1].y)\n        {\n            int dist = p[i+1].x-p[i].x;\n            int u = 2*p[i].id+1, v = 2*p[i+1].id+1;\n            G[u].pb({v,dist});\n            G[v].pb({u,dist});\n        }\n    }\n\n    // change direction\n    rep(i,k)\n    {\n        int u = 2*i, v = 2*i+1;\n        G[u].pb({v,1});\n        G[v].pb({u,1});\n    }\n\n    // dijkstra\n    priority_queue<P,vector<P>,greater<P>> pq;\n    pq.push(P(0,start));\n    fill(d,d+V,INF);\n    d[start] = 0;\n    while(!pq.empty())\n    {\n        P now = pq.top();\n        pq.pop();\n        int v = now.se;\n        if(now.fi>d[v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to] = d[v]+e.cost;\n                pq.push(P(d[e.to],e.to));\n            }\n        }\n    }\n\n    ll ans = min(d[2*k-2],d[2*k-1]);\n    if(ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int M, N, K;\n  cin >> M >> N >> K;\n\n  using LL = long long;\n\n  struct Switch {\n    int id, x, y, left, right, down, up;\n    Switch(int i=-1, int x=-1, int y=-1): id(i), x(x), y(y), left(i), right(i), down(i), up(i) {}\n  };\n\n  using Node = tuple<LL, int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  int S = 0, G = K+1;\n  vector<Switch> sw(G+1);\n  unordered_map<int, vector<int>> X, Y;\n\n  X[1].push_back(S); Y[1].push_back(S);\n  X[M].push_back(G); Y[N].push_back(G);\n  sw[S] = Switch(S, 1, 1);\n  q.emplace(0, S, 0);\n  for(int i = 1; i <= K; ++i) {\n    int x, y;\n    cin >> x >> y;\n    if(x==M && y==N) continue;\n    if(x==1 && y==1) {q.emplace(1, S, 1); continue;}\n    sw[i] = Switch(i, x, y);\n    X[x].push_back(i);\n    Y[y].push_back(i);\n  }\n  sw[G] = Switch(G, M, N);\n\n  for(auto& p: X) sort(begin(p.second), end(p.second), [&](int l, int r) {return sw[l].y < sw[r].y;});\n  for(auto& p: Y) sort(begin(p.second), end(p.second), [&](int l, int r) {return sw[l].x < sw[r].x;});\n  for(auto& p: X) {\n    auto& v = p.second;\n    for(int i = 1; i < v.size(); ++i) {\n      if(v[i-1] != S) sw[v[i]].down = v[i-1];\n      sw[v[i-1]].up = v[i];\n    }\n  }\n  for(auto& p: Y) {\n    auto& v = p.second;\n    for(int i = 1; i < v.size(); ++i) {\n      if(v[i-1] != S) sw[v[i]].left = v[i-1];\n      sw[v[i-1]].right = v[i];\n    }\n  }\n\n  vector<vector<LL>> d(G+1, vector<LL>(2, -1));\n  while(!q.empty()) {\n    LL t; int i, s;\n    tie(t, i, s) = q.top();\n    q.pop();\n\n    if(~d[i][s]) continue;\n    d[i][s] = t;\n\n    if(i == G) break;\n\n    if(i != S) if(!~d[i][!s]) q.emplace(t+1, i, !s);\n\n    if(s) {\n      if(!~d[sw[i].left][s])  q.emplace(t+sw[i].x-sw[sw[i].left].x,  sw[i].left,  s);\n      if(!~d[sw[i].right][s]) q.emplace(t+sw[sw[i].right].x-sw[i].x, sw[i].right, s);\n    } else {\n      if(!~d[sw[i].down][s]) q.emplace(t+sw[i].y-sw[sw[i].down].y, sw[i].down, s);\n      if(!~d[sw[i].up][s])   q.emplace(t+sw[sw[i].up].y-sw[i].y,   sw[i].up,   s);\n    }\n  }\n\n  cout << max(d[G][0], d[G][1]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//???[????????????, ??????????????????]??????????????§????????????????????????????????????[????????????x, ??????????????????y]?????????????????????????§????(x, y, ?????°)??????????????§??¨?????????O(NM)\n//??????????????????????§??????????????????¨???[??????????????????, ??????????????????]??§???????§????????°??????????????????¶?????????????????§??¨????????????O(K^2logK)\n//??¢????¨?????????§??£??\\?????????????????????s1, s2???????§????????????????????¨?????????§??£??\\???????????????????????°??????????????£????????????????????¨????????????????????????\n//???????¨?????????§??£??\\??????????????????(??????4???)????????????????????£????????????????????????O(KlogK)????????????\n//????£??????????\n//???{ int r, c; int switchIndex; }??????????§??????????2????????????????????°???????§?????????????????????????\n//??????????????¨???????????§??¬????????°???????§????????????????\n//?????????????????°???????§??????????????????§?????????????????????????????????????????§?¨?????????????????????????????????§?¨??????????????????°???????????§???\n//???????????????????????????{????????¨?????????} + {????????¨?????????}????????????\n//?§??????????????????????????????´????????????????¨???????????§??????§??????????????§??¨???\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint h, w, n;\nint x[200000], y[200000];\n\nvector<int> sc[100000];\t\t\t\t\t\t//sc[r] = {r??????????????????????????????(???)????\\?????????±??????????????????}, ?¨???????\nvector<int> sr[100000];\t\t\t\t\t\t//sr[c] = {c??????????????????????????????(???)?????????????????????????????????}, ?????????\nmap<int, int> cost[2][100000];\t//cost[][r][c]???[???0,?¨?1]????????§??????(r, c)????¨????????????§???????°???????\n\nvoid Dijkstra(bool sflag){\n\ttypedef tuple<int, int, int, int> T;\t//(?????????, ??????, r, c)\n\tstatic priority_queue<T, vector<T>, greater<T> > que;\n\tque.push(T(0, 0, 0, 0));\n\tif( sflag )\n\t\tque.push(T(1, 1, 0, 0));\n\t\t\n\twhile( !que.empty() ){\n\t\tT state = que.top();\n\t\tint cst = get<0>(state);\n\t\tint dir = get<1>(state);\n\t\tint r = get<2>(state);\n\t\tint c = get<3>(state);\n\t\tque.pop();\n\t\tif( cost[dir][r].find(c) != cost[dir][r].end() && cost[dir][r][c] <= cst )\n\t\t\tcontinue;\n\t\t//cout << cst << \" \" << dir << \" \" << r << \" \" << c << endl;\n\t\tcost[dir][r][c] = cst;\n\t\t\n\t\t//???(r+), ???(r-), ???(c+), ???(c-) (??????(????????¨????¨???£????????????)????§??????????)\n\t\tint pr = upper_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin();\n\t\tint mr = lower_bound(sr[c].begin(), sr[c].end(), r) - sr[c].begin(); mr--;\n\t\tint pc = upper_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin();\n\t\tint mc = lower_bound(sc[r].begin(), sc[r].end(), c) - sc[r].begin(); mc--;\n\t\t\n\t\tif( 0 <= pr && pr < (int)sr[c].size() ){\n\t\t\tpr = sr[c][pr];\n\t\t\tque.push(T(cst + pr - r + dir, 0, pr, c));\n\t\t}\n\t\tif( 0 <= mr && mr < (int)sr[c].size() ){\n\t\t\tmr = sr[c][mr];\n\t\t\tque.push(T(cst + r - mr + dir, 0, mr, c));\n\t\t}\n\t\t//?§???????????????¨???????¨??????????????????´????????????\n\t\tif( r == 0 && c == 0 && !sflag ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( 0 <= pc && pc < (int)sc[r].size() ){\n\t\t\tpc = sc[r][pc];\n\t\t\tque.push(T(cst + pc - c + (!dir), 1, r, pc));\n\t\t}\n\t\tif( 0 <= mc && mc < (int)sc[r].size() ){\n\t\t\tmc = sc[r][mc];\n\t\t\tque.push(T(cst + c - mc + (!dir), 1, r, mc));\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint i;\n\tbool sflag = false;\t//???????????????????????????????????????\n\tbool gflag = false;\t//??´?????????????????????????????????\n\t\n\tcin >> w >> h >> n;\n\tfor( i = 0; i < n; i++ ){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\t\t//0-indexed?????????\n\t\tsc[y[i]].push_back(x[i]);\n\t\tsr[x[i]].push_back(y[i]);\n\t\tif( x[i] == 0 && y[i] == 0 )\n\t\t\tsflag = true;\n\t\tif( x[i] == w-1 && y[i] == h-1 )\n\t\t\tgflag = true;\n\t}\n\t//??´??????????¨??????????\n\tif( !gflag ){\n\t\tsc[h-1].push_back(w-1);\n\t\tsr[w-1].push_back(h-1);\n\t}\n\t\n\tfor( i = 0; i < h; i++ )\n\t\tif( sc[i].size() > 0 )\n\t\t\tsort(sc[i].begin(), sc[i].end());\n\tfor( i = 0; i < w; i++ )\n\t\tif( sr[i].size() > 0 )\n\t\t\tsort(sr[i].begin(), sr[i].end());\n\t\n\tDijkstra(sflag);\n\t\n\tint ans = 1e+12;\n\tif( cost[0][h-1].find(w-1) != cost[0][h-1].end() )\n\t\tans = min(ans, cost[0][h-1][w-1]);\n\tif( cost[1][h-1].find(w-1) != cost[1][h-1].end() )\n\t\tans = min(ans, cost[1][h-1][w-1]);\n\t\n\tif( ans == 1e+12 )\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\nstruct room_t {\n\tint X, Y;\n\tint idx;\n};\n\nint room_cmp_XY(const void* x, const void* y) {\n\tint ax = ((const struct room_t*)x)->X, bx = ((const struct room_t*)y)->X;\n\tint ay = ((const struct room_t*)x)->Y, by = ((const struct room_t*)y)->Y;\n\tif (ax != bx) return ax < bx ? -1 : 1;\n\treturn ay < by ? -1 : ay > by;\n}\n\nint room_cmp_YX(const void* x, const void* y) {\n\tint ax = ((const struct room_t*)x)->X, bx = ((const struct room_t*)y)->X;\n\tint ay = ((const struct room_t*)x)->Y, by = ((const struct room_t*)y)->Y;\n\tif (ay != by) return ay < by ? -1 : 1;\n\treturn ax < bx ? -1 : ax > bx;\n}\n\n#define INF INT64_C(9999999999999999)\n\nstruct edge_t {\n\tint to;\n\tint cost;\n};\n\nint64_t minDist[555555];\nchar kakutei[555555];\n\nint edgeCount[555555];\nstruct edge_t* edges[555555];\n\nvoid addEdge(int from, int to, int cost) {\n\tstruct edge_t* newList = realloc(edges[from], sizeof(edges[from][0]) * (edgeCount[from] + 1));\n\tif (newList == NULL) exit(2);\n\tnewList[edgeCount[from]].to = to;\n\tnewList[edgeCount[from]].cost = cost;\n\tedgeCount[from]++;\n\tedges[from] = newList;\n}\n\nstruct status_t {\n\tint node;\n\tint64_t cost;\n};\n\nint heapMax = 0, heapCount = 0;\nstruct status_t* heap;\n\nvoid heapAdjust(int idx) {\n\tfor (;;) {\n\t\tint minIdx = idx;\n\t\tint64_t min = heap[idx].cost;\n\t\tif (idx * 2 + 1 < heapCount && heap[idx * 2 + 1].cost < min) {\n\t\t\tminIdx = idx * 2 + 1;\n\t\t\tmin = heap[idx * 2 + 1].cost;\n\t\t}\n\t\tif (idx * 2 + 2 < heapCount && heap[idx * 2 + 2].cost < min) {\n\t\t\tminIdx = idx * 2 + 2;\n\t\t\tmin = heap[idx * 2 + 2].cost;\n\t\t}\n\t\tif (minIdx != idx) {\n\t\t\tstruct status_t temp = heap[idx];\n\t\t\theap[idx] = heap[minIdx];\n\t\t\theap[minIdx] = temp;\n\t\t\tidx = minIdx;\n\t\t} else {\n\t\t\tif (idx == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tidx = (idx - 1) / 2;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid heapAdd(int node, int64_t cost) {\n\tif (heapCount >= heapMax) {\n\t\theapMax = heapCount + 1;\n\t\theap = realloc(heap, sizeof(*heap) * heapMax);\n\t\tif (heap == NULL) exit(2);\n\t}\n\theap[heapCount].node = node;\n\theap[heapCount].cost = cost;\n\theapCount++;\n\theapAdjust(heapCount - 1);\n}\n\nstruct status_t heapGet(void) {\n\tstruct status_t ret;\n\tif (heapCount <= 0) exit(3);\n\tret = heap[0];\n\tif (heapCount > 1) {\n\t\theap[0] = heap[heapCount - 1];\n\t}\n\theapCount--;\n\tif (heapCount > 0) heapAdjust(0);\n\treturn ret;\n}\n\nint M, N, K;\nstruct room_t rooms[222222];\n\nint main(void) {\n\tint oneoneIdx = -1, MNidx = -1;\n\tint oneoneSwitch = 0, MNswitch = 0;\n\tint i;\n\tint nodeNum;\n\tint64_t yakusimaruhiroko;\n\tif (scanf(\"%d%d%d\", &M, &N, &K) != 3) return 1;\n\tfor (i = 0; i < K; i++) {\n\t\tif (scanf(\"%d%d\", &rooms[i].X, &rooms[i].Y) != 2) return 1;\n\t\trooms[i].idx = i;\n\t\tif (rooms[i].X == 1 && rooms[i].Y == 1) {\n\t\t\toneoneIdx = i;\n\t\t\toneoneSwitch = 1;\n\t\t}\n\t\tif (rooms[i].X == M && rooms[i].Y == N) {\n\t\t\tMNidx = i;\n\t\t\tMNswitch = 1;\n\t\t}\n\t}\n\tnodeNum = K;\n\tif (oneoneIdx < 0) {\n\t\trooms[nodeNum].X = 1;\n\t\trooms[nodeNum].Y = 1;\n\t\trooms[nodeNum].idx = nodeNum;\n\t\toneoneIdx = nodeNum;\n\t\tnodeNum++;\n\t}\n\tif (MNidx < 0) {\n\t\trooms[nodeNum].X = M;\n\t\trooms[nodeNum].Y = N;\n\t\trooms[nodeNum].idx = nodeNum;\n\t\tMNidx = nodeNum;\n\t\tnodeNum++;\n\t}\n\tqsort(rooms, nodeNum, sizeof(*rooms), room_cmp_XY);\n\tfor (i = 1; i < nodeNum; i++) {\n\t\tif (rooms[i - 1].X == rooms[i].X) {\n\t\t\taddEdge(rooms[i - 1].idx, rooms[i].idx, rooms[i].Y - rooms[i - 1].Y);\n\t\t\taddEdge(rooms[i].idx, rooms[i - 1].idx, rooms[i].Y - rooms[i - 1].Y);\n\t\t}\n\t}\n\tqsort(rooms, nodeNum, sizeof(*rooms), room_cmp_YX);\n\tfor (i = 1; i < nodeNum; i++) {\n\t\tif (rooms[i - 1].Y == rooms[i].Y) {\n\t\t\taddEdge(rooms[i - 1].idx + nodeNum, rooms[i].idx + nodeNum, rooms[i].X - rooms[i - 1].X);\n\t\t\taddEdge(rooms[i].idx + nodeNum, rooms[i - 1].idx + nodeNum, rooms[i].X - rooms[i - 1].X);\n\t\t}\n\t}\n\tfor (i = 0; i < nodeNum; i++) {\n\t\tif ((rooms[i].X != 1 || rooms[i].Y != 1 || oneoneSwitch) && (rooms[i].X != M || rooms[i].Y != N || MNswitch)) {\n\t\t\taddEdge(rooms[i].idx, rooms[i].idx + nodeNum, 1);\n\t\t\taddEdge(rooms[i].idx + nodeNum, rooms[i].idx, 1);\n\t\t}\n\t}\n\tfor (i = 0; i < nodeNum * 2; i++) {\n\t\tminDist[i] = INF;\n\t}\n\tminDist[oneoneIdx] = 0;\n\theapAdd(oneoneIdx, 0);\n\twhile (heapCount > 0) {\n\t\tstruct status_t status = heapGet();\n\t\tif (kakutei[status.node]) continue;\n\t\tkakutei[status.node] = 1;\n\t\tfor (i = 0; i < edgeCount[status.node]; i++) {\n\t\t\tstruct edge_t edge = edges[status.node][i];\n\t\t\tif (minDist[edge.to] > minDist[status.node] + edge.cost) {\n\t\t\t\tminDist[edge.to] = minDist[status.node] + edge.cost;\n\t\t\t\theapAdd(edge.to, minDist[edge.to]);\n\t\t\t}\n\t\t}\n\t}\n\tyakusimaruhiroko = minDist[MNidx] <= minDist[MNidx + nodeNum] ? minDist[MNidx] : minDist[MNidx + nodeNum];\n\tprintf(\"%\" PRId64 \"\\n\", yakusimaruhiroko < INF ? yakusimaruhiroko : -INT64_C(1));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ \t0605: Modern Mansion\n// 2018.1.10 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define QMAX 80000\ntypedef struct { int s; long long t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, long long t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define ABS(a)  ((a)>=0?(a):-(a))\n#define INF 0x7ffffff\ntypedef struct { int x, y, id; } T;\nT sw[200005];\nint sz;\nint to[400005][5], dt[400005][5], hi[400005];\nchar used[400005];\n\nint xcmp(T *a, T *b) { if (a->x - b->x) return a->x - b->x; return a->y - b->y; }\nint ycmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nlong long dijkstra(int start, int flag, int goal)\n{\n\tint i, s, e;\n\tlong long d;\n\n\tqsize = 0;\n\tenq(start, 0);\n\tif (flag < 0) {\n\t\tfor (i = 0; i < hi[start]; i++) if (to[start][i] == start+1) {\n\t\t\tdt[start][i] = INF, hi[start+1] = 0;\n\t\t}\n\t}\n\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal || s == goal+1) return d;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+dt[s][i]);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint m, n, k, i, j;\n\tint s, ss, g, a, b, d;\n\n\tm = in(), n = in(), k = in();\n\tsz = 0, s = g = -1;\n\tfor (i = 0; i < k; i++) {\n\t\tint x, y;\n\t\tsw[i].x = x = in(), sw[i].y = y = in(), sw[i].id = sz;\n\t\tif (x == 1 && y == 1) s = sz;\n\t\telse if (x == m && y == n) g = sz;\n\t\tsz += 2;\n\t}\n\tss = s;\n\tif (s < 0) sw[k].x = 1, sw[k].y = 1, sw[k].id = sz, s = sz, k++, sz+=2;\n\tif (g < 0) sw[k].x = m, sw[k].y = n, sw[k].id = sz, g = sz, k++, sz+=2;\n\n\tqsort(sw, k, sizeof(T), xcmp);\n\ta = sw[0].id, b = a+1;\n\tto[a][0] = b, dt[a][0] = 1, hi[a] = 1;\n\tto[b][0] = a, dt[b][0] = 1, hi[b] = 1;\n\n\tfor (i = 1; i < k; i++) {\n\t\ta = sw[i].id, b = a+1;\n\t\tj = hi[a]++, to[a][j] = b, dt[a][j] = 1;\n\t\tj = hi[b]++, to[b][j] = a, dt[b][j] = 1;\n\t\tif (sw[i-1].x == sw[i].x) {\n\t\t\ta = sw[i-1].id, b = sw[i].id, d =  ABS(sw[i-1].y - sw[i].y);\n\t\t\tj = hi[a]++, to[a][j] = b, dt[a][j] = d;\n\t\t\tj = hi[b]++, to[b][j] = a, dt[b][j] = d;\n\t\t}\n\t}\n\n\tqsort(sw, k, sizeof(T), ycmp);\n\tfor (i = 1; i < k; i++) {\n\t\tif (sw[i-1].y == sw[i].y) {\n\t\t\ta = sw[i-1].id+1, b = sw[i].id+1, d =  ABS(sw[i-1].x - sw[i].x);\n\t\t\tj = hi[a]++, to[a][j] = b, dt[a][j] = d;\n\t\t\tj = hi[b]++, to[b][j] = a, dt[b][j] = d;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", dijkstra(s, ss, g));\n\treturn 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.abs\nimport java.util.*\n\nfun main(args:Array<String>):Unit {\n    val (m, n, k) = readLine()!!.trim().split(' ').map(String::toInt)\n    val roomOrderByX = Array(m + 1){ Stack<Node>() }\n    val roomOrderByY = Array(n + 1){Stack<Node>()}\n    repeat(k){\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        val xNode = Node(x, y)\n        val yNode = Node(x, y)\n        xNode.addEdge(1, yNode)\n        yNode.addEdge(1, xNode)\n        roomOrderByY[y].push(yNode)\n        roomOrderByX[x].push(xNode)\n    }\n    roomOrderByX.forEach {\n        val a = it.sortedBy{it.y}.toTypedArray()\n        for (i in 1 until a.size){\n            a[i - 1].addEdge(abs(a[i].y - a[i - 1].y), a[i])\n            a[i].addEdge(abs(a[i].y - a[i - 1].y), a[i - 1])\n        }\n    }\n    roomOrderByY.forEach {\n        val a = it.sortedBy{it.x}.toTypedArray()\n        for (i in 1 until a.size){\n            a[i - 1].addEdge(abs(a[i].x - a[i - 1].x), a[i])\n            a[i].addEdge(abs(a[i].x - a[i - 1].x), a[i - 1])\n        }\n    }\n    val queue = PriorityQueue<Pair<Int, Node>>(compareBy(Pair<Int, Node>::first))\n    roomOrderByX[1].minBy{it.y}?.let{\n        it.minCost = it.y - 1\n        queue.add(Pair(it.minCost, it))\n    }\n    while(queue.isNotEmpty()){\n        val (time, node) = queue.poll()\n        if (time == node.minCost){\n            node.edges.forEach { (cost, to) ->\n                if (cost + time < to.minCost){\n                    to.minCost = cost + time\n                    queue.add(Pair(to.minCost, to))\n                }\n            }\n        }\n    }\n    println(\n            listOf(roomOrderByX[m].maxBy{it.y}, roomOrderByY[n].maxBy{it.x}).mapNotNull{it?.let{if (it.minCost == Int.MAX_VALUE) null else it.minCost + (m - it.x + n - it.y)}}.min() ?: -1\n    )\n}\ndata class Node(val x:Int, val y:Int){\n    var minCost:Int = Int.MAX_VALUE\n    private val mEdges:Stack<Pair<Int, Node>> = Stack()\n    fun addEdge(distance:Int, to:Node):Unit {\n        mEdges.push(Pair(distance, to))\n    }\n    val edges:Iterable<Pair<Int, Node>> = mEdges\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.abs\nimport java.util.*\n\nfun main(args:Array<String>):Unit {\n    val (m, n, k) = readLine()!!.trim().split(' ').map(String::toInt)\n    val roomOrderByX = Array(m + 1){ Stack<Room>() }\n    val roomOrderByY = Array(n + 1){Stack<Room>()}\n    repeat(k){\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        val room = Room(x, y)\n        roomOrderByY[y].push(room)\n        roomOrderByX[x].push(room)\n    }\n    val queue = PriorityQueue<Triple<Int, Room, From>>(compareBy(Triple<Int, Room, From>::first))\n    roomOrderByX[1].forEach {\n        it.minFromY = it.y - 1\n        queue.add(Triple(it.minFromY, it, From.Y))\n    }\n    while(queue.isNotEmpty()){\n        val (time, room, dir) = queue.remove()\n        if (time == room.min()){\n            when(dir) {\n                From.X -> {\n                    roomOrderByX[room.x].forEach { r ->\n                        if (r.minFromY > abs(r.y - room.y) + room.minFromY) {\n                            r.minFromY = abs(r.y - room.y) + room.minFromY\n                            queue.add(Triple(r.minFromY, r, From.Y))\n                        }\n                    }\n                }\n                From.Y -> {\n                    roomOrderByY[room.y].forEach { r ->\n                        if (r.minFromX > abs(r.x - room.x) + room.minFromX) {\n                            r.minFromX = abs(r.x - room.x) + room.minFromX\n                            queue.add(Triple(r.minFromX, r, From.X))\n                        }\n                    }\n                }\n            }\n        }\n    }\n    println(\n            (roomOrderByX[m].filterNot{it.min() == Int.MAX_VALUE}.map{n - it.y + it.minFromY} + roomOrderByY[n].filterNot{it.min() == Int.MAX_VALUE}.map{m - it.x + it.minFromX}).min() ?: - 1\n    )\n}\nenum class From{\n    X, Y\n}\ndata class Room(val x:Int, val y:Int):Comparable<Room>{\n    private var mMinY:Int = Int.MAX_VALUE\n    private var mMinX:Int = Int.MAX_VALUE\n    var minFromY:Int\n        get() = mMinY\n        set(value){\n            if (minFromY > value){\n                mMinY = value\n                minFromX = value + 1\n            }\n        }\n    var minFromX:Int\n        get() = mMinX\n        set(value){\n            if (minFromX > value){\n                mMinX = value\n                minFromY = value + 1\n            }\n        }\n    fun min():Int = minOf(minFromX, minFromY)\n    override fun compareTo(other: Room): Int {\n        return min().compareTo(other.min())\n    }\n\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.abs\nimport java.util.*\n\nfun main(args:Array<String>):Unit {\n    val (m, n, k) = readLine()!!.trim().split(' ').map(String::toInt)\n    val roomOrderByX = Array(m + 1){ Stack<Room>() }\n    val roomOrderByY = Array(n + 1){Stack<Room>()}\n    repeat(k){\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        val room = Room(x, y)\n        roomOrderByY[y].push(room)\n        roomOrderByX[x].push(room)\n    }\n    roomOrderByX.forEach {\n        val a = it.sortedBy{it.y}.toTypedArray()\n        for (i in 1 until a.size){\n            a[i - 1].setEdge(a[i])\n            a[i].setEdge(a[i - 1])\n        }\n    }\n    roomOrderByY.forEach {\n        val a = it.sortedBy{it.x}.toTypedArray()\n        for (i in 1 until a.size){\n            a[i - 1].setEdge(a[i])\n            a[i].setEdge(a[i - 1])\n        }\n    }\n    val queue = PriorityQueue<Pair<Int, Room>>(compareBy(Pair<Int, Room>::first))\n    roomOrderByX[1].minBy{it.y}?.let{\n        it.minFromY = it.y - 1\n        queue.add(Pair(it.y - 1, it))\n    }\n    while(queue.isNotEmpty()){\n        val (time, room) = queue.remove()\n        if (time == room.min()){\n            room.nextX().forEach{\n                if (it.minFromY > room.minFromY + abs(it.y - room.y)){\n                    it.minFromY = room.minFromY + abs(it.y - room.y)\n                    queue.add(Pair(it.minFromY, it))\n                }\n            }\n            room.nextY().forEach {\n                if (it.minFromX > room.minFromX + abs(it.x - room.x)){\n                    it.minFromX = room.minFromX + abs(it.x - room.x)\n                    queue.add(Pair(it.minFromX, it))\n                }\n            }\n        }\n    }\n    println(\n            (roomOrderByX[m].filterNot{it.min() == Int.MAX_VALUE}.map{n - it.y + it.minFromY} + roomOrderByY[n].filterNot{it.min() == Int.MAX_VALUE}.map{m - it.x + it.minFromX}).min() ?: - 1\n    )\n}\ndata class Room(val x:Int, val y:Int):Comparable<Room>{\n    private var mMinY:Int = Int.MAX_VALUE\n    private var mMinX:Int = Int.MAX_VALUE\n    private val mEdgesX:Stack<Room> = Stack()\n    private val mEdgesY:Stack<Room> = Stack()\n    var minFromY:Int\n        get() = mMinY\n        set(value){\n            if (minFromY > value){\n                mMinY = value\n                minFromX = value + 1\n            }\n        }\n    var minFromX:Int\n        get() = mMinX\n        set(value){\n            if (minFromX > value){\n                mMinX = value\n                minFromY = value + 1\n            }\n        }\n    fun setEdge(to:Room):Unit {\n        (if (to.x == x) mEdgesX\n        else mEdgesY).push(to)\n    }\n    fun nextX():Iterable<Room> {\n        return mEdgesX\n    }\n    fun nextY():Iterable<Room>{\n        return mEdgesY\n    }\n    fun min():Int = minOf(minFromX, minFromY)\n    override fun compareTo(other: Room): Int {\n        return min().compareTo(other.min())\n    }\n\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.abs\nimport java.util.*\n\nfun main(args:Array<String>):Unit {\n    val (m, n, k) = readLine()!!.trim().split(' ').map(String::toInt)\n    val roomOrderByX = Array(m + 1){ Stack<Room>() }\n    val roomOrderByY = Array(n + 1){Stack<Room>()}\n    repeat(k){\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        val room = Room(x, y)\n        roomOrderByY[y].push(room)\n        roomOrderByX[x].push(room)\n    }\n    val queue = PriorityQueue<Pair<Int, Room>>(compareBy(Pair<Int, Room>::first))\n    roomOrderByX[1].forEach {\n        it.minFromY = it.y - 1\n        queue.add(Pair(it.minFromY, it))\n    }\n    while(queue.isNotEmpty()){\n        val (time, room) = queue.remove()\n        if (time == room.min()){\n            roomOrderByX[room.x].forEach { r ->\n                if (r.minFromY > abs(r.y - room.y) + room.minFromY){\n                    r.minFromY = abs(r.y - room.y) + room.minFromY\n                    queue.add(Pair(r.minFromY, r))\n                }\n            }\n            roomOrderByY[room.y].forEach { r ->\n                if (r.minFromX > abs(r.x - room.x) + room.minFromX){\n                    r.minFromX = abs(r.x - room.x) + room.minFromX\n                    queue.add(Pair(r.minFromX, r))\n                }\n            }\n        }\n    }\n    println(\n            (roomOrderByX[m].filterNot{it.min() == Int.MAX_VALUE}.map{n - it.y + it.minFromY} + roomOrderByY[n].filterNot{it.min() == Int.MAX_VALUE}.map{m - it.x + it.minFromX}).min() ?: - 1\n    )\n}\ndata class Room(val x:Int, val y:Int):Comparable<Room>{\n    private var mMinY:Int = Int.MAX_VALUE\n    private var mMinX:Int = Int.MAX_VALUE\n    var minFromY:Int\n        get() = mMinY\n        set(value){\n            if (minFromY > value){\n                mMinY = value\n                minFromX = value + 1\n            }\n        }\n    var minFromX:Int\n        get() = mMinX\n        set(value){\n            if (minFromX > value){\n                mMinX = value\n                minFromY = value + 1\n            }\n        }\n    fun min():Int = minOf(minFromX, minFromY)\n    override fun compareTo(other: Room): Int {\n        return min().compareTo(other.min())\n    }\n\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.stdc.stdio;\nimport std.algorithm;\nimport std.container;\nimport std.typecons;\n\nvoid main(){\n\tint m,n,k;\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\talias Tuple!(int,\"v\",int,\"i\") vi;\n\tvi[][int] xi;\n\tvi[][int] yi;\n\tint si=k*2,gi=k*2+1;\n\tforeach(i;0..k){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\txi[x]~=vi(y,i*2);\n\t\tyi[y]~=vi(x,i*2+1);\n\t\tif(x==1&&y==1)\n\t\t\tsi=i*2;\n\t\tif(x==m&&y==n)\n\t\t\tgi=i*2;\n\t}\n\tif(si==k*2)\n\t\txi[1]~=vi(1,si);\n\tif(gi==k*2+1){\n\t\txi[m]~=vi(n,gi);\n\t\tyi[n]~=vi(m,gi+1);\n\t}\n\tvi[][] graph = new vi[][k*2+3];\n\tforeach(xs;xi){\n\t\tsort(xs);\n\t\tforeach(int i;0..xs.length-1){\n\t\t\tgraph[xs[i].i]~=vi(xs[i+1].v-xs[i].v,xs[i+1].i);\n\t\t\tgraph[xs[i+1].i]~=vi(xs[i+1].v-xs[i].v,xs[i].i);\n\t\t}\n\t}\n\tforeach(ys;yi){\n\t\tsort(ys);\n\t\tforeach(int i;0..ys.length-1){\n\t\t\tgraph[ys[i].i]~=vi(ys[i+1].v-ys[i].v,ys[i+1].i);\n\t\t\tgraph[ys[i+1].i]~=vi(ys[i+1].v-ys[i].v,ys[i].i);\n\t\t}\n\t}\n\tforeach(i;0..k){\n\t\tgraph[i*2]~=vi(1,i*2+1);\n\t\tgraph[i*2+1]~=vi(1,i*2);\n\t}\n\talias Tuple!(long,\"cost\",int,\"i\") ci;\n\tauto pq = BinaryHeap!(ci[],\"a>b\")(new ci[1919810],0);\n\tpq.insert(ci(0,si));\n\tlong ans=-1;\n\tlong[] nc = new long[k*2+3];\n\tnc[] = 1145141919810893;\n\twhile(!pq.empty){\n\t\tauto t=pq.front;\n\t\tpq.popFront;\n\t\twith(t){\n\t\t\tif(cost>nc[i])\n\t\t\t\tcontinue;\n\t\t\tif(i==gi||i==gi+1){\n\t\t\t\tans=cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tforeach(c;graph[i])\n\t\t\t\tif(cost+c.v<nc[c.i]){\n\t\t\t\t\tnc[c.i]=cost+c.v;\n\t\t\t\t\tpq.insert(ci(cost+c.v,c.i));\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.stdc.stdio;\nimport std.algorithm;\nimport std.container;\nimport std.typecons;\n\nvoid main(){\n\tint m,n,k;\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\talias Tuple!(int,\"v\",int,\"i\") vi;\n\tvi[][int] xi;\n\tvi[][int] yi;\n\tint si=k*2,gi=k*2+1;\n\tforeach(i;0..k){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\txi[x]~=vi(y,i*2);\n\t\tyi[y]~=vi(x,i*2+1);\n\t\tif(x==1&&y==1)\n\t\t\tsi=i*2;\n\t\tif(x==m&&y==n)\n\t\t\tgi=i*2;\n\t}\n\tif(si==k*2)\n\t\txi[1]~=vi(1,si);\n\tif(gi==k*2+1){\n\t\txi[m]~=vi(n,gi);\n\t\tyi[n]~=vi(m,gi+1);\n\t}\n\tvi[][] graph = new vi[][k*2+3];\n\tforeach(xs;xi){\n\t\tsort(xs);\n\t\tforeach(int i;0..cast(int)xs.length-1){\n\t\t\tgraph[xs[i].i]~=vi(xs[i+1].v-xs[i].v,xs[i+1].i);\n\t\t\tgraph[xs[i+1].i]~=vi(xs[i+1].v-xs[i].v,xs[i].i);\n\t\t}\n\t}\n\tforeach(ys;yi){\n\t\tsort(ys);\n\t\tforeach(int i;0..cast(int)ys.length-1){\n\t\t\tgraph[ys[i].i]~=vi(ys[i+1].v-ys[i].v,ys[i+1].i);\n\t\t\tgraph[ys[i+1].i]~=vi(ys[i+1].v-ys[i].v,ys[i].i);\n\t\t}\n\t}\n\tforeach(i;0..k){\n\t\tgraph[i*2]~=vi(1,i*2+1);\n\t\tgraph[i*2+1]~=vi(1,i*2);\n\t}\n\talias Tuple!(long,\"cost\",int,\"i\") ci;\n\tauto pq = BinaryHeap!(ci[],\"a>b\")(new ci[1919810],0);\n\tpq.insert(ci(0,si));\n\tlong ans=-1;\n\tlong[] nc = new long[k*2+3];\n\tnc[] = 1145141919810893;\n\twhile(!pq.empty){\n\t\tauto t=pq.front;\n\t\tpq.popFront;\n\t\twith(t){\n\t\t\tif(cost>nc[i])\n\t\t\t\tcontinue;\n\t\t\tif(i==gi||i==gi+1){\n\t\t\t\tans=cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tforeach(c;graph[i])\n\t\t\t\tif(cost+c.v<nc[c.i]){\n\t\t\t\t\tnc[c.i]=cost+c.v;\n\t\t\t\t\tpq.insert(ci(cost+c.v,c.i));\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "Python",
    "code": "#!/bin/env python\nimport sys\nimport heapq\nfrom collections import defaultdict, deque\n\n\nclass Grid:\n    '''\n    Grid provide 2 dim axis search for grid.\n    '''\n    def __init__(self, points):\n        self.by_d = {0: defaultdict(list), 1: defaultdict(list)}\n        for x, y in points:\n            self.by_d[0][x].append((x, y))\n            self.by_d[1][y].append((x, y))\n\n    def get_points(self, axis, line_no):\n        return self.by_d[axis][line_no]\n\n    def remove(self, point):\n        self.by_d[0][point[0]].remove(point)\n        self.by_d[1][point[1]].remove(point)\n\n    def get_lines(self, direction):\n        return self.by_d[direction].keys()\n\n\nclass ModernMansion(Grid):\n    def __init__(self, switches, goal):\n        super().__init__(switches)\n        self.goal = goal\n\n    def remove_orphan(self):\n        '''\n        Removes switch recursivery, that only one switch exists in line.\n        But leaves switch in line on START.\n        '''\n        q = deque()\n        for direction in (0, 1):\n            for line in self.get_lines(direction):\n                q.append((direction, line))\n        while q:\n            direction, line = q.pop()\n            switches = self.get_points(direction, line)\n            if len(switches) != 1:\n                continue\n            sw = switches[0]\n            # But reaves switch in line on START.\n            if sw[0] == 1 or sw == self.goal:\n                continue\n            self.remove(sw)\n            next_dir = (direction + 1) % 2\n            q.append((next_dir, sw[next_dir]))\n\n    def has_route(self):\n        '''\n        If no switches exists in goal line, it never can goal.\n        '''\n        return len(self.by_d[0][self.goal[0]]) > 1 \\\n            or len(self.by_d[1][self.goal[1]]) > 1\n\n    def get_sameline_switch(self, direction, sw):\n        return (s for s in self.get_points(direction, sw[direction])\n                if s != sw)\n\n\nclass Searcher:\n    def __init__(self, grid):\n        self.grid = grid\n        self.q = []\n        self.best_time = {}\n        self.deadline = {0: set(), 1: set()}\n\n    def next_depth(self, t, current, direction):\n        # ゴールであれば、ゴールの時間を返し終了\n        if current == self.grid.goal:\n            return t - 1  # remove last switch push time.\n\n        # 該当行が、既に全探索済みであれば、打ち切り\n        if current[direction] in self.deadline[direction]:\n            return\n\n        next_dir = (direction + 1) % 2\n\n        has_next_switch = False\n        for sw in self.grid.get_sameline_switch(direction, current):\n            # sw での時間は、現在の時間(t) + 距離 + スイッチ押下(1)\n            next_t = t + abs(sw[next_dir] - current[next_dir]) + 1\n            best_t = self.best_time.get(sw, float('inf'))\n            if best_t <= next_t:\n                continue\n            # swへの最短経路を発見\n            self.best_time[sw] = next_t\n            heapq.heappush(self.q, (next_t, sw, next_dir))\n            has_next_switch = True\n\n        # 1つもbest time となるスイッチがなければ、その行自体NG\n        if not has_next_switch:\n            self.deadline[direction].add(current[direction])\n\n    def search(self):\n        ''' Returns all \"time\" '''\n        # 最初に、duration:0 方向にしか移動できないというルールを、\n        # (1, 0)から始めることで実現\n        self.q.append((0, (1, 0), 0))\n        while self.q:\n            res = self.next_depth(*heapq.heappop(self.q))\n            if res:\n                yield res - 1  # remove first move (1, 0) to (1, 1)\n\n    def search_one(self):\n        ''' returns best or -1 '''\n        try:\n            return next(self.search())\n        except StopIteration:\n            return -1\n\n\nif __name__ == '__main__':\n    M, N, K = map(int, input().split())\n    switches = [tuple(map(int, input().split())) for _ in range(K)]\n    switches.append((M, N))\n\n    grid = ModernMansion(switches, (M, N))\n    grid.remove_orphan()\n    if not grid.has_route():\n        print('-1')\n        sys.exit()\n\n    searcher = Searcher(grid)\n    res = searcher.search_one()\n    print(res)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nM, N, K = map(int, input().split())\n\nX = [[] for i in range(M)]\nY = [[] for i in range(N)]\n\nfor i in range(K):\n    x, y = map(int, input().split()); x -= 1; y -= 1\n    X[x].append((y, i))\n    Y[y].append((x, i))\n\nG0 = [[] for i in range(K)]\nG1 = [[] for i in range(K)]\nfor x in range(M):\n    vs = X[x]\n    if vs:\n        vs.sort()\n        prv = vs[0]\n        for v in vs[1:]:\n            d = v[0] - prv[0]\n            G0[prv[1]].append((v[1], d))\n            G0[v[1]].append((prv[1], d))\n            prv = v\nfor y in range(N):\n    vs = Y[y]\n    if vs:\n        vs.sort()\n        prv = vs[0]\n        for v in vs[1:]:\n            d = v[0] - prv[0]\n            G1[prv[1]].append((v[1], d))\n            G1[v[1]].append((prv[1], d))\n            prv = v\n\nINF = 10**18\nque = []\nD0 = [INF]*K; D1 = [INF]*K\nif X[0]:\n    y0, k = X[0][0]\n    que.append((y0, 0, k))\nwhile que:\n    cost, t, v = heappop(que)\n    if not t:\n        if D0[v] < cost:\n            continue\n        for w, d in G0[v]:\n            if cost + d < D0[w]:\n                D0[w] = cost + d\n                heappush(que, (cost + d, 0, w))\n        if cost + 1 < D1[v]:\n            D1[v] = cost + 1\n            heappush(que, (cost + 1, 1, v))\n    else:\n        if D1[v] < cost:\n            continue\n        for w, d in G1[v]:\n            if cost + d < D1[w]:\n                D1[w] = cost + d\n                heappush(que, (cost + d, 1, w))\n        if cost + 1 < D0[v]:\n            D0[v] = cost + 1\n            heappush(que, (cost + 1, 0, v))\nans = INF\nif X[M-1]:\n    y0, k = X[M-1][-1]\n    ans = min(ans, D0[k] + (N-1-y0))\nif Y[N-1]:\n    x0, k = Y[N-1][-1]\n    ans = min(ans, D1[k] + (M-1-x0))\nif ans < INF:\n    print(ans)\nelse:\n    print(-1)\n\n"
  }
]