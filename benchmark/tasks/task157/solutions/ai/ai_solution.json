[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n    int time;\n    bool switch_pressed;\n} State;\n\ntypedef struct {\n    State queue[MAX_SIZE * MAX_SIZE * 2];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = q->rear = 0;\n}\n\nbool isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue *q, State s) {\n    q->queue[q->rear++] = s;\n}\n\nState dequeue(Queue *q) {\n    return q->queue[q->front++];\n}\n\nint minTime(int M, int N) {\n    if (M == 1 && N == 1) return 0;\n\n    bool visited[MAX_SIZE][MAX_SIZE][2];\n    for (int i = 0; i < MAX_SIZE; i++) {\n        for (int j = 0; j < MAX_SIZE; j++) {\n            visited[i][j][0] = false;\n            visited[i][j][1] = false;\n        }\n    }\n\n    Queue q;\n    initQueue(&q);\n    State start = {1, 1, 0, false};\n    enqueue(&q, start);\n    visited[1][1][0] = true;\n\n    while (!isEmpty(&q)) {\n        State current = dequeue(&q);\n\n        if (current.x == M && current.y == N) {\n            return current.time;\n        }\n\n        // Directions: north, south, east, west\n        int dx[] = {0, 0, 1, -1};\n        int dy[] = {1, -1, 0, 0};\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n\n            if (nx < 1 || nx > M || ny < 1 || ny > N) continue;\n\n            bool is_north_south = (i == 0 || i == 1);\n            bool door_open;\n            if (is_north_south) {\n                door_open = !current.switch_pressed;\n            } else {\n                door_open = current.switch_pressed;\n            }\n\n            if (door_open) {\n                State next = {nx, ny, current.time + 1, current.switch_pressed};\n                if (!visited[nx][ny][next.switch_pressed]) {\n                    visited[nx][ny][next.switch_pressed] = true;\n                    enqueue(&q, next);\n                }\n            }\n        }\n\n        // Press switch\n        State next = {current.x, current.y, current.time + 1, !current.switch_pressed};\n        if (!visited[current.x][current.y][next.switch_pressed]) {\n            visited[current.x][current.y][next.switch_pressed] = true;\n            enqueue(&q, next);\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int M, N;\n    scanf(\"%d %d\", &M, &N);\n    int result = minTime(M, N);\n    if (result == -1) {\n        printf(\"impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MansionTraversal {\n    public static int minimumTimeToReach(int M, int N) {\n        boolean[][] eastWestDoors = new boolean[M + 1][N + 1];\n        boolean[][] northSouthDoors = new boolean[M + 1][N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            northSouthDoors[1][i] = true;\n        }\n        \n        boolean[][] visited = new boolean[M + 1][N + 1];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{1, 1, 0});\n        visited[1][1] = true;\n        \n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], time = current[2];\n            \n            if (x == M && y == N) {\n                return time;\n            }\n            \n            for (int[] dir : directions) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                \n                if (newX >= 1 && newX <= M && newY >= 1 && newY <= N && !visited[newX][newY]) {\n                    if (dir[0] == 0) {  // Horizontal movement\n                        if (eastWestDoors[Math.min(x, newX)][y]) {\n                            queue.offer(new int[]{newX, newY, time + 1});\n                            visited[newX][newY] = true;\n                        }\n                    } else {  // Vertical movement\n                        if (northSouthDoors[x][Math.min(y, newY)]) {\n                            queue.offer(new int[]{newX, newY, time + 1});\n                            visited[newX][newY] = true;\n                        }\n                    }\n                }\n            }\n            \n            // Toggle doors\n            for (int i = 1; i <= M; i++) {\n                for (int j = 1; j <= N; j++) {\n                    eastWestDoors[i][j] = !eastWestDoors[i][j];\n                    northSouthDoors[i][j] = !northSouthDoors[i][j];\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int M = scanner.nextInt();\n        int N = scanner.nextInt();\n        \n        int result = minimumTimeToReach(M, N);\n        \n        if (result == -1) {\n            System.out.println(\"Impossible\");\n        } else {\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:51:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <tuple>\n\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n\n    vector<vector<int>> dist(M + 1, vector<int>(N + 1, INT_MAX));\n    vector<vector<bool>> visited(M + 1, vector<bool>(N + 1, false));\n    priority_queue<tuple<int, int, int, bool>, vector<tuple<int, int, int, bool>>, greater<tuple<int, int, int, bool>>> pq;\n\n    dist[1][1] = 0;\n    pq.push({0, 1, 1, false});\n\n    while (!pq.empty()) {\n        auto [time, x, y, switched] = pq.top();\n        pq.pop();\n\n        if (x == M && y == N) {\n            cout << time << endl;\n            return 0;\n        }\n\n        if (visited[x][y]) continue;\n        visited[x][y] = true;\n\n        // Move without pressing switch\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx < 1 || nx > M || ny < 1 || ny > N) continue;\n\n            bool isEastWest = (i == 0 || i == 1);\n            bool isOpen = (isEastWest) ? switched : !switched;\n\n            if (isOpen) {\n                if (time + 1 < dist[nx][ny]) {\n                    dist[nx][ny] = time + 1;\n                    pq.push({time + 1, nx, ny, switched});\n                }\n            }\n        }\n\n        // Press switch (takes 1 minute)\n        int new_time = time + 1;\n        if (new_time < dist[x][y]) {\n            dist[x][y] = new_time;\n            pq.push({new_time, x, y, !switched});\n        }\n    }\n\n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_ROOMS 100\n\ntypedef struct {\n    int x, y, time;\n} State;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint solve(int M, int N) {\n    bool visited[MAX_ROOMS][MAX_ROOMS][2][2] = {false};\n    State queue[MAX_ROOMS * MAX_ROOMS * 4];\n    int front = 0, rear = 0;\n\n    queue[rear++] = (State){1, 1, 0};\n    visited[1][1][0][0] = true;\n\n    while (front < rear) {\n        State current = queue[front++];\n        \n        if (current.x == M && current.y == N) \n            return current.time;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            \n            if (nx < 1 || nx > M || ny < 1 || ny > N) \n                continue;\n\n            bool isEastWest = (dx[i] != 0);\n            bool doorOpen = (isEastWest ? !current.time : current.time);\n\n            if (doorOpen && !visited[nx][ny][current.time][isEastWest]) {\n                queue[rear++] = (State){nx, ny, current.time};\n                visited[nx][ny][current.time][isEastWest] = true;\n            }\n\n            if (!visited[nx][ny][!current.time][isEastWest]) {\n                queue[rear++] = (State){nx, ny, !current.time};\n                visited[nx][ny][!current.time][isEastWest] = true;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int M, N;\n    scanf(\"%d %d\", &M, &N);\n    \n    int result = solve(M, N);\n    \n    if (result == -1) \n        printf(\"Impossible\\n\");\n    else \n        printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int x, y, time;\n    vector<vector<bool>> horizontalDoors;\n    vector<vector<bool>> verticalDoors;\n    \n    State(int _x, int _y, int _time, \n          const vector<vector<bool>>& _horizontalDoors, \n          const vector<vector<bool>>& _verticalDoors) \n        : x(_x), y(_y), time(_time), \n          horizontalDoors(_horizontalDoors), \n          verticalDoors(_verticalDoors) {}\n};\n\nint minimumTimeToReach(int M, int N) {\n    vector<vector<bool>> horizontalDoors(M+1, vector<bool>(N+1, false));\n    vector<vector<bool>> verticalDoors(M+1, vector<bool>(N+1, true));\n    \n    queue<State> q;\n    q.push(State(1, 1, 0, horizontalDoors, verticalDoors));\n    \n    vector<vector<vector<vector<bool>>>> visited(\n        M+1, vector<vector<vector<bool>>>(\n            N+1, vector<vector<bool>>(\n                2, vector<bool>(2, false))));\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (current.x == M && current.y == N) {\n            return current.time;\n        }\n        \n        if (visited[current.x][current.y]\n            [current.horizontalDoors[current.x][current.y]]\n            [current.verticalDoors[current.x][current.y]]) {\n            continue;\n        }\n        \n        visited[current.x][current.y]\n               [current.horizontalDoors[current.x][current.y]]\n               [current.verticalDoors[current.x][current.y]] = true;\n        \n        // Switch\n        State switchState = current;\n        for (int i = 1; i <= M; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                switchState.horizontalDoors[i][j] = !switchState.horizontalDoors[i][j];\n                switchState.verticalDoors[i][j] = !switchState.verticalDoors[i][j];\n            }\n        }\n        switchState.time++;\n        q.push(switchState);\n        \n        // Move directions\n        vector<pair<int,int>> directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n        \n        for (auto [dx, dy] : directions) {\n            int nx = current.x + dx;\n            int ny = current.y + dy;\n            \n            if (nx < 1 || nx > M || ny < 1 || ny > N) continue;\n            \n            bool canMove = false;\n            if (dx == 1 && !current.horizontalDoors[nx-1][ny]) canMove = true;\n            if (dx == -1 && !current.horizontalDoors[nx][ny]) canMove = true;\n            if (dy == 1 && !current.verticalDoors[nx][ny-1]) canMove = true;\n            if (dy == -1 && !current.verticalDoors[nx][ny]) canMove = true;\n            \n            if (canMove) {\n                State nextState = current;\n                nextState.x = nx;\n                nextState.y = ny;\n                nextState.time++;\n                q.push(nextState);\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n    \n    int result = minimumTimeToReach(M, N);\n    \n    if (result == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Room {\n    int x, y, time, switchPressed;\n\n    public Room(int x, int y, int time, int switchPressed) {\n        this.x = x;\n        this.y = y;\n        this.time = time;\n        this.switchPressed = switchPressed;\n    }\n}\n\npublic class MansionEscape {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int M = scanner.nextInt();\n        int N = scanner.nextInt();\n\n        int[][][] dist = new int[M + 1][N + 1][2];\n        for (int i = 0; i <= M; i++) {\n            for (int j = 0; j <= N; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n\n        PriorityQueue<Room> pq = new PriorityQueue<>(Comparator.comparingInt(r -> r.time));\n        pq.add(new Room(1, 1, 0, 0));\n        dist[1][1][0] = 0;\n\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        while (!pq.isEmpty()) {\n            Room current = pq.poll();\n            int x = current.x;\n            int y = current.y;\n            int time = current.time;\n            int switchPressed = current.switchPressed;\n\n            if (x == M && y == N) {\n                System.out.println(time);\n                return;\n            }\n\n            if (time > dist[x][y][switchPressed]) {\n                continue;\n            }\n\n            // Press switch\n            int newSwitchPressed = 1 - switchPressed;\n            int newTime = time + 1;\n            if (newTime < dist[x][y][newSwitchPressed]) {\n                dist[x][y][newSwitchPressed] = newTime;\n                pq.add(new Room(x, y, newTime, newSwitchPressed));\n            }\n\n            // Move\n            for (int[] dir : dirs) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 1 && nx <= M && ny >= 1 && ny <= N) {\n                    boolean isEastWest = dir[0] != 0;\n                    boolean isOpen;\n                    if (isEastWest) {\n                        isOpen = (switchPressed == 1);\n                    } else {\n                        isOpen = (switchPressed == 0);\n                    }\n                    if (isOpen) {\n                        newTime = time + 1;\n                        if (newTime < dist[nx][ny][switchPressed]) {\n                            dist[nx][ny][switchPressed] = newTime;\n                            pq.add(new Room(nx, ny, newTime, switchPressed));\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(\"Impossible\");\n    }\n}",
    "timestamp": "2025-08-05 18:52:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_time_to_reach(M, N, switches):\n    # Helper functions\n    def within_bounds(x, y):\n        return 0 <= x < M and 0 <= y < N\n\n    def toggle_doors():\n        nonlocal east_west_open\n        east_west_open = not east_west_open\n\n    def get_neighbors(x, y):\n        # Get possible moves\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        neighbors = []\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if within_bounds(nx, ny):\n                if (dx == 0 and north_south_open) or (dy == 0 and east_west_open):\n                    neighbors.append((nx, ny))\n        return neighbors\n\n    # Initialize\n    queue = deque([(0, 0, 0)])  # (x, y, time)\n    visited = set()\n    visited.add((0, 0))\n    east_west_open = False  # Initially all east-west doors are closed\n    north_south_open = True # Initially all north-south doors are open\n\n    # BFS\n    while queue:\n        x, y, time = queue.popleft()\n\n        # Check if we've reached the target room\n        if (x, y) == (M - 1, N - 1):\n            return time\n\n        # Check if there's a switch in the current room\n        if (x, y) in switches:\n            toggle_doors()\n            time += 1\n\n        # Explore neighbors\n        for nx, ny in get_neighbors(x, y):\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, time + 1))\n\n    # If no solution found\n    return \"Impossible\"\n\n# Example usage:\nM = 4\nN = 4\nswitches = {(1, 1), (2, 2)} # Define rooms with switches\nprint(min_time_to_reach(M, N, switches))",
    "timestamp": "2025-08-13 01:14:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MansionTraversal {\n\n    static class State {\n        int x, y, time;\n        boolean doorsMoved;\n\n        State(int x, int y, int time, boolean doorsMoved) {\n            this.x = x;\n            this.y = y;\n            this.time = time;\n            this.doorsMoved = doorsMoved;\n        }\n    }\n\n    public static int minTimeToReach(int M, int N) {\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        Queue<State> queue = new LinkedList<>();\n        boolean[][][][] visited = new boolean[M + 1][N + 1][2][2];\n        queue.offer(new State(1, 1, 0, false));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.x == M && current.y == N) {\n                return current.time;\n            }\n\n            if (visited[current.x][current.y][current.doorsMoved ? 1 : 0][0]) {\n                continue;\n            }\n            visited[current.x][current.y][current.doorsMoved ? 1 : 0][0] = true;\n\n            for (int[] direction : directions) {\n                int newX = current.x + direction[0];\n                int newY = current.y + direction[1];\n                if (newX >= 1 && newX <= M && newY >= 1 && newY <= N) {\n                    if (isPassable(current.x, current.y, newX, newY, current.doorsMoved)) {\n                        queue.offer(new State(newX, newY, current.time + 1, current.doorsMoved));\n                    }\n                }\n            }\n\n            if (!visited[current.x][current.y][current.doorsMoved ? 1 : 0][1]) {\n                queue.offer(new State(current.x, current.y, current.time + 1, !current.doorsMoved));\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean isPassable(int x1, int y1, int x2, int y2, boolean doorsMoved) {\n        if (x1 == x2) { // NS direction\n            return true;\n        }\n        if (y1 == y2) { // EW direction\n            return doorsMoved;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int M = 5; // Example value for M\n        int N = 4; // Example value for N\n        int result = minTimeToReach(M, N);\n        if (result != -1) {\n            System.out.println(\"Minimum time required: \" + result);\n        } else {\n            System.out.println(\"Impossible to reach (M, N)\");\n        }\n    }\n}",
    "timestamp": "2025-08-13 01:14:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX 1000\n#define INF INT_MAX\n\ntypedef struct {\n    int x, y, time, toggles;\n} State;\n\ntypedef struct {\n    State data[MAX * MAX * 2];\n    int front, rear;\n} Queue;\n\nvoid queueInit(Queue* q) {\n    q->front = 0;\n    q->rear = 0;\n}\n\nint isQueueEmpty(Queue* q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue* q, State s) {\n    q->data[q->rear++] = s;\n    q->rear %= MAX * MAX * 2;\n}\n\nState dequeue(Queue* q) {\n    State result = q->data[q->front++];\n    q->front %= MAX * MAX * 2;\n    return result;\n}\n\nint visited[MAX][MAX][2];  // [x][y][toggle state]\n\nint minTimeToReach(int M, int N) {\n    Queue q;\n    queueInit(&q);\n    \n    // Initialize visited array with INF\n    for (int i = 0; i < MAX; ++i)\n        for (int j = 0; j < MAX; ++j)\n            for (int k = 0; k < 2; ++k)\n                visited[i][j][k] = INF;\n    \n    // Start from the center of (1, 1) -> (0, 0) in 0-index\n    State start = {0, 0, 0, 0};\n    enqueue(&q, start);\n    visited[0][0][0] = 0;\n\n    int directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // East, West, South, North\n    \n    while (!isQueueEmpty(&q)) {\n        State cur = dequeue(&q);\n        \n        // If we reached the center of room (M, N)\n        if (cur.x == M - 1 && cur.y == N - 1) {\n            return cur.time;\n        }\n\n        // Try all 4 movement directions\n        for (int i = 0; i < 4; ++i) {\n            int nx = cur.x + directions[i][0];\n            int ny = cur.y + directions[i][1];\n            \n            if (nx >= 0 && nx < M && ny >= 0 && ny < N) {\n                int open = (directions[i][1] != 0) ^ cur.toggles; // 1 if moving between initially open doors\n                if (open && cur.time + 1 < visited[nx][ny][cur.toggles]) {\n                    visited[nx][ny][cur.toggles] = cur.time + 1;\n                    State next = {nx, ny, cur.time + 1, cur.toggles};\n                    enqueue(&q, next);\n                }\n            }\n        }\n        \n        // Toggle doors\n        if (cur.time + 1 < visited[cur.x][cur.y][cur.toggles ^ 1]) {\n            visited[cur.x][cur.y][cur.toggles ^ 1] = cur.time + 1;\n            State nextToggle = {cur.x, cur.y, cur.time + 1, cur.toggles ^ 1};\n            enqueue(&q, nextToggle);\n        }\n    }\n    \n    // If we exit the loop without returning, there is no path to (M-1, N-1)\n    return -1;\n}\n\nint main() {\n    int M, N;\n    scanf(\"%d %d\", &M, &N);\n    \n    int result = minTimeToReach(M, N);\n    \n    if (result == -1) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:15:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_mansion(M, N):\n    # Initial door states: east-west closed, north-south open\n    ew_doors = [[False] * (N+1) for _ in range(M)]\n    ns_doors = [[True] * N for _ in range(M+1)]\n    \n    def toggle_doors():\n        nonlocal ew_doors, ns_doors\n        ew_doors = [[not door for door in row] for row in ew_doors]\n        ns_doors = [[not door for door in row] for row in ns_doors]\n    \n    def is_valid_move(x, y, dx, dy):\n        if dx == 1:  # moving east\n            return x < M-1 and ew_doors[y][x]\n        if dx == -1:  # moving west\n            return x > 0 and ew_doors[y][x-1]\n        if dy == 1:  # moving north\n            return y < N-1 and ns_doors[y+1][x]\n        if dy == -1:  # moving south\n            return y > 0 and ns_doors[y][x]\n    \n    visited = set()\n    queue = deque([(0, 0, 0)])\n    \n    while queue:\n        x, y, time = queue.popleft()\n        \n        if x == M-1 and y == N-1:\n            return time\n        \n        if (x, y, time % 2) in visited:\n            continue\n        visited.add((x, y, time % 2))\n        \n        # Toggle switches\n        if time % 2 == 1:\n            toggle_doors()\n        \n        # Move in 4 directions\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < M and 0 <= ny < N and is_valid_move(x, y, dx, dy):\n                queue.append((nx, ny, time + 1))\n    \n    return \"Impossible\"\n\n# Example usage\nprint(solve_mansion(3, 3))",
    "timestamp": "2025-08-13 01:15:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_time_to_escape(M, N):\n    # Directions: north, south, east, west\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Priority queue: (time, x, y, switch_pressed)\n    heap = []\n    heapq.heappush(heap, (0, 1, 1, False))\n    \n    # Visited dictionary: (x, y, switch_pressed) -> min_time\n    visited = {}\n    visited[(1, 1, False)] = 0\n    \n    while heap:\n        current_time, x, y, pressed = heapq.heappop(heap)\n        \n        if x == M and y == N:\n            return current_time\n        \n        if current_time > visited.get((x, y, pressed), float('inf')):\n            continue\n        \n        # Try moving in all four directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= M and 1 <= ny <= N:\n                # Determine door type: east-west or north-south\n                is_east_west = (dx != 0)\n                door_open = (not pressed) if is_east_west else pressed\n                \n                if door_open:\n                    new_time = current_time + 1\n                    key = (nx, ny, pressed)\n                    if key not in visited or new_time < visited.get(key, float('inf')):\n                        visited[key] = new_time\n                        heapq.heappush(heap, (new_time, nx, ny, pressed))\n        \n        # Try pressing the switch (if current room has a switch)\n        # Assuming all rooms have switches for generality\n        new_pressed = not pressed\n        new_time = current_time + 1\n        key = (x, y, new_pressed)\n        if key not in visited or new_time < visited.get(key, float('inf')):\n            visited[key] = new_time\n            heapq.heappush(heap, (new_time, x, y, new_pressed))\n    \n    return -1\n\n# Example usage:\n# M, N = map(int, input().split())\n# print(min_time_to_escape(M, N))",
    "timestamp": "2025-08-13 01:15:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n\n    vector<vector<bool>> has_switch(M + 1, vector<bool>(N + 1, false));\n    for (int i = 1; i <= M; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            char ch;\n            cin >> ch;\n            if (ch == 'S') {\n                has_switch[i][j] = true;\n            }\n        }\n    }\n\n    vector<vector<vector<vector<int>>>> dist(2, vector<vector<vector<int>>>(M + 1, vector<vector<int>>(N + 1, vector<int>(M + 1, vector<int>(N + 1, INF)))));\n    dist[1][1][1][1] = 0;\n    \n    queue<tuple<int, int, int, int, bool>> q;\n    q.push({1, 1, 1, 1, false});\n    \n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    \n    while (!q.empty()) {\n        auto [x, y, x_end, y_end, toggle] = q.front();\n        q.pop();\n        \n        int curr_dist = dist[toggle][x][y][x_end][y_end];\n        \n        if (x_end == M && y_end == N) {\n            cout << curr_dist << \"\\n\";\n            return 0;\n        }\n        \n        for (int i = 0; i < 4; ++i) {\n            int nx = x_end + dx[i];\n            int ny = y_end + dy[i];\n            \n            if (nx >= 1 && nx <= M && ny >= 1 && ny <= N) {\n                bool can_move = false;\n                \n                if (i % 2 == 0) {\n                    can_move = true;\n                } else {\n                    can_move = !toggle;\n                }\n                \n                if (can_move && curr_dist + 1 < dist[toggle][x][y][nx][ny]) {\n                    dist[toggle][x][y][nx][ny] = curr_dist + 1;\n                    q.push({x, y, nx, ny, toggle});\n                }\n            }\n        }\n        \n        if (has_switch[x_end][y_end]) {\n            int new_toggle = !toggle;\n            if (curr_dist + 1 < dist[new_toggle][x][y][x_end][y_end]) {\n                dist[new_toggle][x][y][x_end][y_end] = curr_dist + 1;\n                q.push({x, y, x_end, y_end, new_toggle});\n            }\n        }\n    }\n    \n    cout << \"-1\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-13 10:59:07"
  }
]