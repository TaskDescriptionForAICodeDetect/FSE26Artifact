[
  {
    "language": "Scala",
    "code": "\nimport scala.annotation.tailrec\nobject Main extends App {\n\n  import scala.io.StdIn._\n\n  solve\n  @tailrec\n  def solve: Unit = {\n    val first = readLine\n    if (first == null) return\n    val (sets, suspects) = parseSet(first.split(' ').toList)\n    implicit val set = sets\n    val expression = readLine.trim match {\n      case Expression(e) ⇒ println(suspects.filter(i ⇒ e(i)).let{\n        case Nil ⇒ \"NULL\"\n        case l ⇒ l.mkString(\" \")\n      })\n      case _ ⇒ ???\n    }\n    solve\n  }\n  @tailrec\n  def parseSet(line: List[String], sets: Map[Char, Int ⇒ Boolean] = Map.empty.withDefault(_ ⇒ _ ⇒ false), factors: List[Int] = Nil): (Char ⇒ Int ⇒ Boolean, List[Int]) = {\n    line match {\n      case \"R\"::_ => (sets, factors.distinct.sorted)\n      case c::_ ⇒ val elements = readLine.trim.split(' ').map(_.toInt).sorted\n        parseSet(readLine.trim.split(' ').toList, sets + (c.head, i ⇒ sortedContains(elements, i)), elements ++: factors)\n      case _ ⇒ ???\n    }\n  }\n\n  object Expression{\n    def unapply(arg: String)(implicit set: Char => Int => Boolean): Option[Int ⇒ Boolean] = {\n      arg.toList match {\n        case s Second Nil ⇒ Some(s)\n        case _ ⇒ ???\n      }\n    }\n  }\n  object First {\n    def unapply(arg: List[Char])(implicit set: Char ⇒ Int ⇒ Boolean): Option[(Int ⇒ Boolean, List[Char])] = {\n      arg match {\n        case '('::(in Second ')'::t) ⇒ Some(in, t)\n        case 'c'::(f First t) ⇒ Some(!f(_), t)\n        case c::t if c.isUpper⇒ Some(set(c), t)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Second{\n    def unapply(arg: List[Char])(implicit set: Char => Int => Boolean): Option[(Int ⇒ Boolean, List[Char])] = {\n      arg match {\n        case f First t ⇒ Some(parseAll(t, f))\n        case _ ⇒ None\n      }\n    }\n    @tailrec\n    private def parseAll(arg: List[Char], left: Int ⇒ Boolean)(implicit set: Char ⇒ Int ⇒ Boolean): (Int ⇒ Boolean, List[Char]) = {\n      arg match {\n        case 'u'::(s First t) ⇒ parseAll(t, i ⇒ left(i) || s(i))\n        case 'i'::(s First t) ⇒ parseAll(t, i ⇒ left(i) && s(i))\n        case 'd'::(s First t) ⇒ parseAll(t, i ⇒ left(i) && !s(i))\n        case 's'::(s First t) ⇒ parseAll(t, i ⇒ left(i) ^ s(i))\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n  def sortedContains(array: Array[Int], target: Int): Boolean = {\n    val i = lowerBound(array, target)\n    if (array.indices.contains(i)) array(i) == target\n    else false\n  }\n  def lowerBound(array: Array[Int], target: Int): Int = {\n    var left = 0\n    var right = array.length\n    while(left < right){\n      val mid = (left + right) / 2\n      if (array(mid) < target){\n        left = mid + 1\n      }else {\n        right = mid\n      }\n    }\n    right\n  }\n\n  implicit class Extension[T](value :T){\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\nusing std::begin;\nusing std::end;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        std::set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        std::set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        std::set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        std::set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        std::set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> V;\nV A[10],U;\nstring S;\n\nV Union(V a,V b){\n  for(int i=0;i<b.size();i++) a.push_back(b[i]);\n  sort(a.begin(),a.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  return a;\n}\n\nV Inter(V a,V b){\n  V res;\n  int n =a.size(),m=b.size();\n  a.push_back(1e9),b.push_back(1e9);\n  int i = 0,j = 0;\n  while(i<n&&j<m){\n    if(a[i]<b[j])i++;\n    else if(a[i]>b[j])j++;\n    else res.push_back(a[i]),i++,j++;\n  }\n  return res;\n}\n\nV Diff(V a,V b){\n  V res;\n  int n = a.size();\n  int m = b.size();\n  b.push_back(1e9);\n  \n  int j =0;\n  for(int i=0;i<n;i++){\n    while(a[i]>b[j])j++;\n    if(a[i]!=b[j]) res.push_back(a[i]);\n  }\n  return res;\n}\n\nV Sdiff(V a,V b){return Union(Diff(a,b),Diff(b,a));}\n\nV Comp(V a){\n  V res;\n  int j = 0;\n  a.push_back(1e9);\n  for(int i=0;i<(int)U.size();i++) {\n    while(a[j] < U[i])j++;\n    if(a[j]!=U[i]) res.push_back(U[i]);\n  }\n  return res;\n}\n\nint p = 0;\nV bnf();\nV getV(){\n  char ch = S[p];\n  V res;\n  if(ch == '(')p++,res = bnf(),p++;\n  else if(isupper(ch))p++,res = A[ch-'A'];\n  else assert(isupper(ch));\n  return res;\n}\n\nV bnf(){\n  V res;\n  while(1){\n    char ch = S[p];\n    if(isupper(ch))p++, res = A[ch-'A'];\n    else if(ch=='(')p++,res = bnf(),p++;\n    else if(ch=='c')p++,res = Comp(getV());\n    else if(ch=='u')p++,res = Union(res,getV());\n    else if(ch=='i')p++,res = Inter(res,getV());\n    else if(ch=='d')p++,res = Diff(res,getV());\n    else if(ch=='s')p++,res = Sdiff(res,getV());\n    else if(p<S.size()&&ch!=')')assert(ch==')');\n    else break;\n  }\n  return res;\n}\n\nint main(){\n\n  while(1){\n    U.clear();\n    while(1){\n      char ch;\n      int n;\n      if(!(cin>>ch>>n))exit(0);\n      if(ch == 'R' && n == 0) break;\n      int idx = ch-'A';\n      A[idx].resize(n);\n      for(int i=0;i<n;i++)cin>>A[idx][i],U.push_back(A[idx][i]);\n      sort(A[idx].begin(),A[idx].end());\n      A[idx].erase(unique(A[idx].begin(),A[idx].end()),A[idx].end());\n    }\n    \n    sort(U.begin(),U.end());\n    U.erase(unique(U.begin(),U.end()),U.end());\n    cin >> S;\n    p = 0;\n    V ans = bnf();\n\n    for(int i=0;i<ans.size();i++){\n      if(i)cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\n\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(ret, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(ret, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(ret, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(ret, term(begin));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        char se;\n        int n;\n\n        while (cin >> se >> n) {\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        if(sets['U'].size() == 0){\n            break;\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  //else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>19) exit(1);\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = dif(sets['U'], v);\n    }\n    else {\n        ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint idx;\nstring str;\nset<int> u;\n\nset<int> calc_union(const set<int>& a, const set<int>& b) {\n\tset<int> res(a);\n\tres.insert(b.begin(), b.end());\n\treturn res;\n}\n\nset<int> calc_intersection(const set<int>& a, const set<int>& b) {\n\tset<int> res;\n\tset<int>::const_iterator it, en = a.end(), en2 = b.end();\n\tfor(it = a.begin(); it != en; ++it)\n\t\tif(b.find(*it) != en2)\n\t\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_difference(const set<int>& a, const set<int>& b) {\n\tset<int> res;\n\tset<int>::const_iterator it, en = a.end(), en2 = b.end();\n\tfor(it = a.begin(); it != en; ++it)\n\t\tif(b.find(*it) == en2)\n\t\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_symmetric_difference(const set<int>& a, const set<int>& b) {\n\treturn calc_union(calc_difference(a, b), calc_difference(b, a));\n}\n\nset<int> complement(const set<int>& a) {\n\treturn calc_difference(u, a);\n}\n\nset<int> s[128];\nset<int> (*func[128])(const set<int>&, const set<int>&);\n\nset<int> expr();\n\nset<int> fact() {\n\tif(str[idx] == '(') {\n\t\t++idx;\n\t\tconst set<int> res = expr();\n\t\t++idx;\n\t\treturn res;\n\t}\n\telse\n\t\treturn s[str[idx++]];\t\n}\n\nset<int> term() {\n\tif(str[idx] == 'c') {\n\t\t++idx;\n\t\treturn complement(fact());\n\t}\n\telse\n\t\treturn fact();\n}\n\nset<int> expr() {\n\tset<int> res = term();\n\twhile(str[idx] == 'u' || str[idx] == 'i' || str[idx] == 'd' || str[idx] == 's') {\n\t\tconst char tmp = str[idx++];\n\t\tres = func[tmp](res, term());\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfunc['u'] = calc_union;\n\tfunc['i'] = calc_intersection;\n\tfunc['d'] = calc_difference;\n\tfunc['s'] = calc_symmetric_difference;\n\n\twhile(true) {\n\t\tu.clear();\n\t\tfor(int i = 'A'; i <= 'E'; ++i)\n\t\t\ts[i].clear();\n\n\t\tchar c;\n\t\tint num;\n\t\twhile(true) {\n\t\t\tif(!(cin >> c >> num))\n\t\t\t\treturn EXIT_SUCCESS;\n\n\t\t\tif(c == 'R')\n\t\t\t\tbreak;\n\n\t\t\twhile(num--) {\n\t\t\t\tint element;\n\t\t\t\tcin >> element;\n\t\t\t\ts[c].insert(element);\n\t\t\t\tu.insert(element);\n\t\t\t}\n\t\t}\n\n\t\tidx = 0;\n\t\tcin >> str;\n\n\t\tconst set<int> ans = expr();\n\t\tset<int>::const_iterator it = ans.begin(), en = ans.end();\n\t\tif(ans.size()) {\n\t\t\twhile(true) {\n\t\t\t\tcout << (*it);\n\t\t\t\tif(++it == en) {\n\t\t\t\t\tcout << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NULL\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>19) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef map<char, set<int> > mapset;\n\nset<int> atom(string &expr, mapset &sets, int &k);\nset<int> block(string &expr, mapset &sets, int &k);\nset<int> unite(set<int> &s1, set<int> &s2);\nset<int> intersection(set<int> &s1, set<int> &s2);\nset<int> difference(set<int> &s1, set<int> &s2);\nset<int> symmetric_difference(set<int> &s1, set<int> &s2);\nset<int> parse(string &expr, mapset &sets, int &k);\nset<int> complement(mapset &sets, set<int> &s1);\n\nvoid print(set<int> s) {\n    cout << \"set: \";\n    for (set<int>::iterator it=s.begin(); it!=s.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n}\n\nset<int> atom(string &expr, mapset &sets, int &k) {\n    set<int> ret(sets[expr[k]]);\n    k ++;\n    return ret;\n}\n\nset<int> block(string &expr, mapset &sets, int &k) {\n    set<int> v;\n    if (expr[k] == '(') {\n        k ++;\n        v = parse(expr, sets, k);\n        k ++;\n        return v;\n    } else if (expr[k] == 'c') {\n        k ++;\n        v = block(expr, sets, k);\n        v = complement(sets, v);\n        return v;\n    } else {\n        v = atom(expr, sets, k);\n        return v;\n    }\n}\n\nset<int> unite(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.insert(*it);\n    }\n    return ret;\n}\n\nset<int> intersection(set<int> &s1, set<int> &s2) {\n    set<int> ret;\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        if (s1.find(*it) != s1.end()) {\n            ret.insert(*it);\n        }\n    }\n    return ret;\n}\n\nset<int> difference(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.erase(*it);\n    }\n    return ret;\n}\n\nset<int> symmetric_difference(set<int> &s1, set<int> &s2) {\n    set<int> dif1 = difference(s1, s2);\n    set<int> dif2 = difference(s2, s1);\n    return unite(dif1, dif2);\n}\n\nset<int> complement(mapset &sets, set<int> &s1) {\n    set<int> U;\n    for (mapset::iterator it=sets.begin(); it!=sets.end(); ++it) {\n        U = unite(U, it->second);\n    }\n    return difference(U, s1);\n}\n\nset<int> parse(string &expr, mapset &sets, int &k) {\n    set<int> v1 = block(expr, sets, k);\n    while (k < (int)expr.size() && expr[k] != ')') {\n        char op = expr[k];\n        k ++;\n        set<int> v2 = block(expr, sets, k);\n        if (op == 'u') {\n            v1 = unite(v1, v2);\n        } else if (op == 'i') {\n            v1 = intersection(v1, v2);\n        } else if (op == 'd') {\n            v1 = difference(v1, v2);\n        } else if (op == 's') {\n            v1 = symmetric_difference(v1, v2);\n        }\n    }\n    return v1;\n}\n\nvoid solve(string &expr, mapset &sets) {\n    int k = 0;\n    set<int> st = parse(expr, sets, k);\n    for (set<int>::iterator it=st.begin(); it!=st.end(); ++it) {\n        cout << (it == st.begin() ? \"\" : \" \") << *it;\n    }\n    cout << endl;\n}\n\nint main() {\n    char c; int k;\n    map<char, set<int> > sets;\n    while (cin >> c >> k) {\n        if (c != 'R') {\n            set<int> st; int t;\n            for (int i=0; i<k; ++i) {\n                cin >> t;\n                st.insert(t);\n            }\n            sets[c] = st;\n        } else {\n            string expr;\n            cin >> expr;\n            solve(expr, sets);\n            sets.clear();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <iterator>\n#include <vector>\nusing namespace std;\n\nconst char *ptr;\nvector<int> var[5], U;\n\nvector<int> parse();\n\nvector<int> factor(){\n\tif(*ptr == '('){\n\t\t++ptr;\n\t\tvector<int> x = parse();\n\t\t++ptr;\n\t\treturn x;\n\t}\n\tif(*ptr == 'c'){\n\t\t++ptr;\n\t\tvector<int> x = factor();\n\t\tvector<int> y;\n\t\tset_difference(U.begin(), U.end(), x.begin(), x.end(), back_inserter(y));\n\t\treturn y;\n\t}\n\treturn var[*ptr++ - 'A'];\n}\n\nvector<int> parse(){\n\tvector<int> tmp, y, x = factor();\n\tback_insert_iterator<vector<int> > it(tmp);\n\n\twhile(1){\n\t\ttmp.clear();\n\t\tif(*ptr == 'u'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_union(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse if(*ptr == 'i'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_intersection(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse if(*ptr == 'd'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_difference(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse if(*ptr == 's'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_symmetric_difference(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\n\t\tx.swap(tmp);\n\t}\n\t\n\treturn x;\n}\n\nint main(){\n\tstring s;\n\tchar ch;\n\tint n;\n\n\twhile(1){\n\t\tfor(int i = 0; i < 5; ++i){\n\t\t\tvar[i].clear();\n\t\t}\n\n\t\twhile(1){\n\t\t\tcin >> ch >> n;\n\t\t\tif(!cin) return 0;\n\t\t\tif(ch == 'R') break;\n\t\t\tvar[ch - 'A'].resize(n);\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tcin >> var[ch - 'A'][i];\n\t\t\t}\n\t\t}\n\n\t\tU.clear();\n\t\tfor(int i = 0; i < 5; ++i){\n\t\t\tsort(var[i].begin(), var[i].end());\n\t\t\tvar[i].erase(unique(var[i].begin(), var[i].end()), var[i].end());\n\t\t\tU.insert(U.end(), var[i].begin(), var[i].end());\n\t\t}\n\t\tsort(U.begin(), U.end());\n\t\tU.erase(unique(U.begin(), U.end()), U.end());\n\n\t\tcin >> s;\n\t\tptr = s.c_str();\n\n\t\tvector<int> ret = parse();\n\t\tif(ret.empty()){\n\t\t\tputs(\"NULL\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\", ret[0]);\n\t\t\tfor(int i = 1; i < ret.size(); ++i){\n\t\t\t\tprintf(\" %d\", ret[i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\"<<endl;\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[5],U;\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0;\n  int l = s.size();\n  set<int> a,b,res;\n\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p && ('a'<=s[i] && s[i]<='z' && s[i]!='c')){\n      a = parse(s.substr(0,i));\n      b = parse(s.substr(i+1,l-i-1));\n      if(s[i] == 'u'){\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = U.begin();ite!=U.end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  } \n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<5;i++)alp[i].clear();\n    while(c != 'R'){\n      int tmp;\n\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m.size()].insert(tmp);\n\tU.insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef set <int> SI;\ntypedef map <string, SI> MSI;\n\nMSI M;\n\nSI getU() {\n    SI res;\n    string S[5] = { \"A\", \"B\", \"C\", \"D\", \"E\" };\n    for ( int i = 0; i < 5; ++ i ) {\n        for ( SI::iterator it_i = M[S[i]].begin(); it_i != M[S[i]].end(); ++ it_i ) {\n            res.insert( *it_i );\n        }\n    }\n    SI st( res.begin(), res.end() );\n    return SI( st.begin(), st.end() );\n}\n\nSI getCU( SI A ) {\n    SI res;\n    SI U = getU();\n    for ( SI::iterator it_i = U.begin(); it_i != U.end(); ++ it_i ) {\n        bool flag = true;\n        for ( SI::iterator it_j = A.begin(); it_j != A.end(); ++ it_j ) {\n            if ( *it_j == *it_i ) flag = false;\n        }\n        if ( flag ) res.insert( *it_i );\n    }\n    return res;\n}\n\nvoid print_vi( SI s ) {\n    if ( s.empty() ) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n    VI v( s.begin(), s.end() );\n    for ( VI::iterator it_i = v.begin(); it_i != v.end(); ++ it_i ) {\n        cout << *it_i;\n        if ( it_i + 1 != v.end() ) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\nbool isOP( char c ) {\n    if ( c == 'u' ) return true;\n    if ( c == 'i' ) return true;\n    if ( c == 'd' ) return true;\n    if ( c == 's' ) return true;\n    return false;\n}\n\nstring toString( char c ) {\n    string res;\n    res += c;\n    return res;\n}\n\nSI getUnion( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    return res;\n}\n\nSI getIntersection( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        for ( SI::iterator it_j = B.begin(); it_j != B.end(); ++ it_j ) {\n            if ( *it_i == *it_j ) res.insert( *it_i );\n        }\n    }\n    return res;\n}\n\nSI getDifference( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.erase( *it_i );\n    }\n    return res;\n}\n\nSI getSymmetricDifference( SI A, SI B ) {\n    return getUnion( getDifference( A, B ), getDifference( B, A ) );\n}\n\nSI solve2( string s, int k ) {\n    int n = s.size();\n\n    SI A, B;\n    string op;\n    // A\n    if ( s[k] == '(' ) {\n        A = solve2( s, k + 1 );\n        for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n        k++;\n    } else {\n        if ( s[k] == 'c' ) {\n            A = getCU( M[toString(s[k+1])] );\n            k += 2;\n        } else {\n            A = M[toString(s[k])];\n            k += 1;\n        }\n    }\n\n    SI res = A;\n    while ( k < n && s[k] != ')' ) {\n        // O\n        op = s[k];\n        k ++;\n        // B\n        if ( s[k] == '(' ) {\n            B = solve2( s, k + 1 );\n            for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n            k++;\n        } else {\n            if ( s[k] == 'c' ) {\n                B = getCU( M[toString(s[k+1])] );\n                k += 2;\n            } else {\n                B = M[toString(s[k])];\n                k += 1;\n            }\n        }\n        if ( op == \"u\" ) {\n            res = getUnion( res, B );\n        } else if ( op == \"i\" ) {\n            res = getIntersection( res, B );\n        } else if ( op == \"d\" ) {\n            res = getDifference( res, B );\n        } else if ( op == \"s\" ) {\n            res = getSymmetricDifference( res, B );\n        }\n    }\n    return res;\n}\n\nvoid solve( string first_name, int first_n ) {\n    M.clear();\n\n    // input\n    for ( int i = 0; i < first_n; ++ i ) {\n        int elm;\n        cin >> elm;\n        M[first_name].insert( elm );\n    }\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        if ( name == \"R\" && n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            int elm;\n            cin >> elm;\n            M[name].insert( elm );\n        }\n    }\n    string exp;\n    cin >> exp;\n    print_vi( solve2( exp, 0 ) );\n}\n\nint main() {\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        solve( name, n );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str.size()==2){\n\t\treturn Complement(sets[str[1]],sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\ntypedef vector<int> Set;\nSet sets[5];\nSet U;\nstring input;\nint index;\n\nvoid Print(const Set& s) {\n  for (int i = 0; i < s.size(); ++i) {\n    if (i != 0) cout << \" \";\n    cout << s[i];\n  }\n  cout << endl;\n}\n\nSet Union(const Set& a, const Set& b) {\n  Set r;\n  set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nSet Intersection(const Set& a, const Set& b) {\n  Set r;\n  set_intersection(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nSet Diff(const Set& a, const Set& b) {\n  Set r;\n  set_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nSet SymDiff(const Set& a, const Set& b) {\n  Set r;\n  set_symmetric_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nstring bin_ops = \"uids\";\nSet Fact();\nSet Exp() {\n  Set val = Fact();\n  while (index < input.size() && bin_ops.find(input[index]) != string::npos) {\n    char op = input[index++];\n    Set b = Fact();\n    switch (op) {\n    case 'u': val = Union(val, b); break;\n    case 'i': val = Intersection(val, b); break;\n    case 'd': val = Diff(val, b); break;\n    case 's': val = SymDiff(val, b); break;\n    }\n  }\n  return val;\n}\n\nSet Fact() {\n  char op = input[index++];\n  Set r;\n  if (op == 'c') {\n    r = Diff(U, Fact());\n  } else if (op == '(') {\n    r = Exp();\n    ++index;\n  } else {\n    r = sets[op - 'A'];\n  }\n  return r;\n}\n\nint main() {\n  char name;\n  int num;\n  while (cin >> name >> num) {\n    for (Set& s : sets) s.clear(); U.clear();\n    do {\n      for (int i = 0; i < num; ++i) {\n\tint v;\n\tcin >> v;\n\tsets[name - 'A'].push_back(v);\n      }\n    } while (cin >> name >> num && name != 'R');\n    for (Set& s : sets) {\n      sort(s.begin(), s.end());\n      U = Union(U, s);\n    }\n    cin >> input;\n    index = 0;\n    Set res = Exp();\n    Print(res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << '\\0' << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nset<int> all;\nmap<char, set<int> > variable;\n\nset<int> operator|(const set<int>& a, const set<int>& b)\n{\n    set<int> ret = a;\n    for(set<int>::iterator it=b.begin(); it!=b.end(); ++it)\n        ret.insert(*it);\n    return ret;\n}\n\nset<int> operator&(const set<int>& a, const set<int>& b)\n{\n    set<int>::iterator it1 = a.begin();\n    set<int>::iterator it2 = b.begin();\n    set<int> ret;\n    while(it1 != a.end() && it2 != b.end()){\n        if(*it1 == *it2){\n            ret.insert(*it1);\n            ++ it1;\n            ++ it2;\n        }else if(*it1 < *it2){\n            ++ it1;\n        }else{\n            ++ it2;\n        }\n    }\n    return ret;\n}\n\nset<int> operator~(const set<int>& a)\n{\n    set<int>::iterator it1 = a.begin();\n    set<int>::iterator it2 = all.begin();\n    set<int> ret;\n    while(it2 != all.end()){\n        if(it1 == a.end() || *it1 != *it2){\n            ret.insert(*it2);\n            ++ it2;\n        }else{\n            ++ it1;\n            ++ it2;\n        }\n    }\n    return ret;\n}\n\nset<int> operator^(const set<int>& a, const set<int>& b)\n{\n    return (a & ~b) | (~a & b);\n}\n\nset<int> solve(string s)\n{\n    int n = s.size();\n    if(n == 1)\n        return variable[s[0]];\n\n    int brackets = 0;\n    for(int i=n-1; i>=0; --i){\n        if(s[i] == '(')\n            ++ brackets;\n        else if(s[i] == ')')\n            -- brackets;\n        else if(brackets == 0 && islower(s[i]) && s[i] != 'c'){\n            set<int> a, b;\n            a = solve(s.substr(0, i));\n            b = solve(s.substr(i+1));\n\n            set<int> ret;\n            if(s[i] == 'u')\n                return a | b;\n            else if(s[i] == 'i')\n                return a & b;\n            else if(s[i] == 'd')\n                return a & ~b;\n            else\n                return a ^ b;\n        }\n    }\n\n    if(s[0] == 'c')\n        return ~solve(s.substr(1));\n\n    return solve(s.substr(1, n-2));\n}\n\nint main()\n{\n    for(;;){\n        all.clear();\n        variable.clear();\n\n        for(;;){\n            char c;\n            int n;\n            if(!(cin >> c >> n))\n                return 0;\n            if(c == 'R')\n                break;\n\n            for(int i=0; i<n; ++i){\n                int a;\n                cin >> a;\n                all.insert(a);\n                variable[c].insert(a);\n            }\n        }\n\n        string s;\n        cin >> s;\n        set<int> ret = solve(s);\n\n        if(ret.size() == 0)\n            cout << \"NULL\" << endl;\n        else{\n            set<int>::iterator it = ret.begin();\n            cout << *it;\n            while(++ it != ret.end())\n                cout << ' ' << *it;\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> A,B,C,D,E,U;//mapを使った方が楽。\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        set_difference(U.begin(), U.end(), v.begin(), v.end(), std::inserter(ret, ret.end()));\n    }\n    else {\n        ret = _set(begin);\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n\n            if (se == 'A') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    A.push_back(input);\n                    u.insert(input);\n                }\n                sort(A.begin(), A.end());\n            } else if (se == 'B') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    B.push_back(input);\n                    u.insert(input);\n                }\n                sort(B.begin(), B.end());\n            } else if (se == 'C') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    C.push_back(input);\n                    u.insert(input);\n                }\n                sort(C.begin(), C.end());\n            } else if (se == 'D') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    D.push_back(input);\n                    u.insert(input);\n                }\n                sort(D.begin(), D.end());\n            } else if (se == 'E') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    E.push_back(input);\n                    u.insert(input);\n                }\n                sort(E.begin(), E.end());\n            }\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nusing S = set<int>;\nS U;\nmap<char, S> m;\n\nstring s;\nint N;\nint c;\n\nS expr();\nS factor();\nS num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \" + s << endl;\n\tfor(int i = 0; i < text.size() + 1 + N; i++){\n\t\tif(i == text.size() + 1 + c) cout << \"*\";\n\t\telse cout << \" \";\n\t}\n\tcout << endl;\n}\n\nS Union(S s1, S s2){\n\tfor(auto v : s2){\n\t\ts1.insert(v);\n\t}\n\treturn s1;\n}\n\nS Intersection(S s1, S s2){\n\tS ret;\n\tfor(auto v : s2){\n\t\tif(s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Diff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS SymDiff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\tfor(auto v : s2){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Comp(S s1){\n\tS ret;\n\tfor(auto v : U){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS expr(){\n\tdebug(\"expr\");\n\tS x = factor();\n\twhile(c < N){\n\t\tif(s[c] == 'u'){\n\t\t\tc++;\n\t\t\tx = Union(x, factor());\n\t\t}\n\t\telse if(s[c] == 'i'){\n\t\t\tc++;\n\t\t\tx = Intersection(x, factor());\n\t\t}\n\t\telse if(s[c] == 'd'){\n\t\t\tc++;\n\t\t\tx = Diff(x, factor());\n\t\t}\n\t\telse if(s[c] == 's'){\n\t\t\tc++;\n\t\t\tx = SymDiff(x, factor());\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nS factor(){\n\tdebug(\"factor\");\n\tbool rev = false;\n\tif(s[c] == 'c'){\n\t\trev = 1;\n\t\tc++;\n\t}\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tS ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\tif(rev) ret = Comp(ret);\n\t\treturn ret;\n\t}\n\tS ret = num();\n\tif(rev) ret = Comp(ret);\n\treturn ret;\n}\n\nS num(){\n\tdebug(\"num\");\n\tS ret = m[s[c]];\n\tc++;\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tm.clear();\n\t\tU.clear();\n\t\tchar name;\n\t\tint n;\n\t\twhile(true){\n\t\t\tif(!(cin >> name >> n)) return 0;\n\t\t\tif(name == 'R') break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tU.insert(a);\n\t\t\t\tm[name].insert(a);\n\t\t\t}\n\t\t}\n\t\tm['U'] = U;\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tS ans = expr();\n\t\tif(ans.size()){\n\t\t\tvector<int> v(ans.begin(), ans.end());\n\t\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\t\tcout << v[i];\n\t\t\t\tif(i != v.size() - 1) cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NULL\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\t//assert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\t//assert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        cin >> num;\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n        printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nusing S = set<int>;\nS U;\nmap<char, S> m;\n\nstring s;\nint N;\nint c;\n\nS expr();\nS factor();\nS num();\n\nvoid debug(string text){\n\t//return;\n\tcout << text + \" \" + s << endl;\n\tfor(int i = 0; i < text.size() + 1 + N; i++){\n\t\tif(i == text.size() + 1 + c) cout << \"*\";\n\t\telse cout << \" \";\n\t}\n\tcout << endl;\n}\n\nS Union(S s1, S s2){\n\tfor(auto v : s2){\n\t\ts1.insert(v);\n\t}\n\treturn s1;\n}\n\nS Intersection(S s1, S s2){\n\tS ret;\n\tfor(auto v : s2){\n\t\tif(s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Diff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS SymDiff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\tfor(auto v : s2){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Comp(S s1){\n\tS ret;\n\tfor(auto v : U){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS expr(){\n\tdebug(\"expr\");\n\tS x = factor();\n\twhile(c < N){\n\t\tif(s[c] == 'u'){\n\t\t\tc++;\n\t\t\tx = Union(x, factor());\n\t\t}\n\t\telse if(s[c] == 'i'){\n\t\t\tc++;\n\t\t\tx = Intersection(x, factor());\n\t\t}\n\t\telse if(s[c] == 'd'){\n\t\t\tc++;\n\t\t\tx = Diff(x, factor());\n\t\t}\n\t\telse if(s[c] == 's'){\n\t\t\tc++;\n\t\t\tx = SymDiff(x, factor());\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nS factor(){\n\tdebug(\"factor\");\n\tbool rev = false;\n\tif(s[c] == 'c'){\n\t\trev = 1;\n\t\tc++;\n\t}\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tS ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\tif(rev) ret = Comp(ret);\n\t\treturn ret;\n\t}\n\tS ret = num();\n\tif(rev) ret = Comp(ret);\n\treturn ret;\n}\n\nS num(){\n\tdebug(\"num\");\n\tS ret = m[s[c]];\n\tc++;\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tm.clear();\n\t\tU.clear();\n\t\tchar name;\n\t\tint n;\n\t\twhile(true){\n\t\t\tif(!(cin >> name >> n)) return 0;\n\t\t\tif(name == 'R') break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tU.insert(a);\n\t\t\t\tm[name].insert(a);\n\t\t\t}\n\t\t}\n\t\tm['U'] = U;\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tS ans = expr();\n\t\tif(ans.size()){\n\t\t\tvector<int> v(ans.begin(), ans.end());\n\t\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\t\tcout << v[i];\n\t\t\t\tif(i != v.size() - 1) cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NULL\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\n//map<char, vector<int> > sets;\nvector<int> sets[256];\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\n//vector<int> parse(const string& e)\n//{\n//\tint p = e.size() - 1;\n//\tfor (int par = 0; p >= 0; --p)\n//\t{\n//\t\tif (e[p] == '(')\n//\t\t\t++par;\n//\t\telse if (e[p] == ')')\n//\t\t\t--par;\n//\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n//\t\t\tbreak;\n//\t}\n//\tif (p < 0)\n//\t{\n//\t\tif (e[0] == 'c')\n//\t\t\treturn calculate('s', sets['U'], parse(e.substr(1)));\n//\t\telse if (e[0] == '(')\n//\t\t\treturn parse(e.substr(1, e.size() - 2));\n//\t\telse\n//\t\t\treturn sets[e[0]];\n//\t}\n//\n//\treturn calculate(e[p], parse(e.substr(0, p)), parse(e.substr(p + 1, e.size() - (p + 1))));\n//}\nstring e;\nvector<int> parse(int a, int b)\n{\n\tint p = b;\n\tfor (int par = 0; p >= a; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < a)\n\t{\n\t\tif (e[a] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(a + 1, b));\n\t\telse if (e[a] == '(')\n\t\t\treturn parse(a + 1, b - 1);\n\t\telse\n\t\t\treturn sets[e[a]];\n\t}\n\n\treturn calculate(e[p], parse(a, p - 1), parse(p + 1, b));\n}\nint main()\n{\n\twhile (!cin.eof())\n\t{\n\t\t//sets.clear();\n\t\trep (i, 256)\n\t\t\tsets[i].clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tcin >> a >> n;\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tcin >> e;\n\t\tvector<int> res = parse(0, e.size() - 1);\n\t\tif (res.empty())\n\t\t\tcout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tcout << res[i];\n\t\t\t\tif (i + 1 < res.size())\n\t\t\t\t\tcout << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef pair<int, vector<int> > Result;\nvector<int> universal;\nvector<int> sets[5];\n\nvoid print_vector(const vector<int>& v)\n{\n  for (int i = 0; i < (int)v.size(); ++i) {\n    if (i != 0) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nResult parse_atom(const string& str, int k);\n\nResult parse_expr(const string& str, int k)\n{\n  Result lhs = parse_atom(str, k);\n  while (islower(str[lhs.first])) {\n    Result rhs = parse_atom(str, lhs.first + 1);\n    vector<int> result;\n    switch (str[lhs.first]) {\n    case 'u':\n      set_union(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'i':\n      set_intersection(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'd':\n      set_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 's':\n      set_symmetric_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    }\n    lhs = make_pair(rhs.first, result);\n  }\n  return lhs;\n}\n\nResult parse_atom(const string& str, int k)\n{\n  if (str[k] == 'c') {\n    Result ret = parse_atom(str, k+1);\n    vector<int> result;\n    set_difference(ALL(universal), ALL(ret.second), back_inserter(result));\n    return make_pair(ret.first, result);\n  } else if (str[k] == '(') {\n    Result ret = parse_expr(str, k+1);\n    return make_pair(ret.first+1, ret.second);\n  } else {\n    return make_pair(k+1, sets[str[k]-'A']);\n  }\n}\n\nint main()\n{\n  for (;;) {\n    char name;\n    int n;\n    universal.clear();\n    for (int i = 0; i < 5; ++i) {\n      sets[i].clear();\n    }\n    for (;;) {\n      if (!(cin >> name >> n)) { return 0; }\n      if (name == 'R') { break; }\n      for (int i = 0; i < n; ++i) {\n        int v; cin >> v;\n        sets[name-'A'].push_back(v);\n        universal.push_back(v);\n      }\n      sort(ALL(sets[name-'A']));\n      unique(ALL(sets[name-'A']));\n    }\n    sort(ALL(universal));\n    unique(ALL(universal));\n    string str; cin >> str;\n    vector<int> ret = parse_expr(str, 0).second;\n    if (ret.empty()) {\n      cout << \"NULL\" << endl;\n    } else {\n      print_vector(ret);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef pair<int, vector<int> > Result;\nvector<int> universal;\nvector<int> sets[5];\n\nvoid print_vector(const vector<int>& v)\n{\n  for (int i = 0; i < (int)v.size(); ++i) {\n    if (i != 0) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nResult parse_atom(const string& str, int k);\n\nResult parse_expr(const string& str, int k)\n{\n  Result lhs = parse_atom(str, k);\n  while (islower(str[lhs.first])) {\n    Result rhs = parse_atom(str, lhs.first + 1);\n    vector<int> result;\n    switch (str[lhs.first]) {\n    case 'u':\n      set_union(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'i':\n      set_intersection(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'd':\n      set_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 's':\n      set_symmetric_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    }\n    lhs = make_pair(rhs.first, result);\n  }\n  return lhs;\n}\n\nResult parse_atom(const string& str, int k)\n{\n  if (str[k] == 'c') {\n    Result ret = parse_atom(str, k+1);\n    vector<int> result;\n    set_difference(ALL(universal), ALL(ret.second), back_inserter(result));\n    return make_pair(ret.first, result);\n  } else if (str[k] == '(') {\n    Result ret = parse_expr(str, k+1);\n    return make_pair(ret.first+1, ret.second);\n  } else {\n    return make_pair(k+1, sets[str[k]-'A']);\n  }\n}\n\nint main()\n{\n  for (;;) {\n    char name;\n    int n;\n    universal.clear();\n    for (int i = 0; i < 5; ++i) {\n      sets[i].clear();\n    }\n    for (;;) {\n      if (!(cin >> name >> n)) { return 0; }\n      if (name == 'R') { break; }\n      for (int i = 0; i < n; ++i) {\n        int v; cin >> v;\n        sets[name-'A'].push_back(v);\n        universal.push_back(v);\n      }\n      sort(ALL(sets[name-'A']));\n      unique(ALL(sets[name-'A']));\n    }\n    sort(ALL(universal));\n    unique(ALL(universal));\n    string str; cin >> str;\n    vector<int> ret = parse_expr(str, 0).second;\n    for (int i = 0; i < (int)ret.size(); ++i) {\n      if (i != 0) cout << \" \";\n      cout << ret[i];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\n \nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\nvoid show(vector<int> ans){\n\tbool r=false;\n        for(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n        if(!r) cout<<\"NULL\";\n        cout<<endl;\n}\nvector<int> U(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]|a2[i]);\n    return ve1;\n}\n \nvector<int> I(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]&a2[i]);\n    return ve1;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]^a2[i]);\n    return ve1;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n     \n    for(int i=0;i<a1.size();i++){\n        int r;\n        if(a1[i]==1 && a2[i]==0) r=1;\n        else r=0;\n        ve1.pb(r);\n    }\n    return ve1;\n}\n \nvector<int> C(vector<int> a1){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(1-a1[i]);\n    return ve1;\n}\nvector<int> shiki();\nvector<int> ka();\nvector<int> han(){\n//  cout<<s[it]<<endl;\n    if(s[it]=='c'){\n    //\tcout<<it<<endl;\n        it++;\n        vector<int> e=ka();\n    //\tshow(C(e));\n        return C(e);\n    }\n    else{\n        it++;\n        return ch[s[it-1]-'A'];\n    }\n}\n \nvector<int> ka(){\n    if(s[it]=='('){\n        it++;\n        vector<int> q=shiki();\n        it++;\n        return q;\n    }\n    else return han();\n     \n}\n \n \n \nvector<int> shiki(){\n    vector<int> r= ka();\n    while(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n        char c=s[it];\n    \t\n        it++;\n        vector<int> r2=ka();\n         \n        if(c=='u') r=U(r,r2);\n        if(c=='s') r=S(r,r2);\n        if(c=='d') r=D(r,r2);\n        if(c=='i') r=I(r,r2);\n    }\n//\tcout<<it<<endl;\n//\tshow(r);\n    return r;\n}\n \nint cnt=0;\nsigned main(){\nchar c;\n    int d;\n    while(1){\n         \n        cnt++;\n      if(cnt>19) break;\n         \n        while(1){\n            cin>>c>>d;\n             \n            if(c=='R') break;\n            for(int i=0;i<d;i++){\n                int r;\n                cin>>r;\n                ve[c-'A'].pb(r);\n            }\n             \n        }\n        set<int> se;\n         \n        for(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n        V.clear();\n        for(auto its=se.begin();its!=se.end();its++){\n            V.pb(*its);\n        }\n         \n        for(int i=0;i<5;i++){\n            for(int j=0;j<V.size();j++){\n            bool b=false;\n            for(int k=0;k<ve[i].size();k++){\n                if(ve[i][k]==V[j]) b=true;\n            }\n            if(b) ch[i].pb(1);\n            else ch[i].pb(0);\n        }\n    //      for(int j=0;j<V.size();j++)cout<<ch[i][j];\n    //      cout<<endl;\n        }\n        it=0;\n        cin>>s;\n        s+=\"*\";\n        vector<int> anss=shiki();\n   // \tcout<<anss.size()<<endl;\n   // \treturn 0;\n    \tshow(anss);\n    //\tcout<<\"s\"<<endl;\n   // \treturn 0;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef map<char, set<int> > mapset;\n\nset<int> atom(string&, mapset&, int&);\nset<int> block(string&, mapset&, int&);\nset<int> unite(set<int>&, set<int>&);\nset<int> intersection(set<int>&, set<int>&);\nset<int> difference(set<int>&, set<int>&);\nset<int> symmetric_difference(set<int>&, set<int>&);\nset<int> parse(string&, mapset&, int&);\nset<int> complement(mapset&, set<int>&);\n\nvoid print(set<int> s) {\n    cout << \"set: \";\n    for (set<int>::iterator it=s.begin(); it!=s.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n}\n\nset<int> atom(string &expr, mapset &sets, int &k) {\n    set<int> ret(sets[expr[k]]);\n    k ++;\n    return ret;\n}\n\nset<int> block(string &expr, mapset &sets, int &k) {\n    set<int> v;\n    if (expr[k] == '(') {\n        k ++;\n        v = parse(expr, sets, k);\n        k ++;\n        return v;\n    } else if (expr[k] == 'c') {\n        k ++;\n        v = block(expr, sets, k);\n        v = complement(sets, v);\n        return v;\n    } else {\n        v = atom(expr, sets, k);\n        return v;\n    }\n}\n\nset<int> unite(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.insert(*it);\n    }\n    return ret;\n}\n\nset<int> intersection(set<int> &s1, set<int> &s2) {\n    set<int> ret;\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        if (s1.find(*it) != s1.end()) {\n            ret.insert(*it);\n        }\n    }\n    return ret;\n}\n\nset<int> difference(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.erase(*it);\n    }\n    return ret;\n}\n\nset<int> symmetric_difference(set<int> &s1, set<int> &s2) {\n    set<int> dif1 = difference(s1, s2);\n    set<int> dif2 = difference(s2, s1);\n    return unite(dif1, dif2);\n}\n\nset<int> complement(mapset &sets, set<int> &s1) {\n    set<int> U;\n    for (mapset::iterator it=sets.begin(); it!=sets.end(); ++it) {\n        U = unite(U, it->second);\n    }\n    return difference(U, s1);\n}\n\nset<int> parse(string &expr, mapset &sets, int &k) {\n    set<int> v1 = block(expr, sets, k);\n    while (k < (int)expr.size() && expr[k] != ')') {\n        char op = expr[k];\n        k ++;\n        set<int> v2 = block(expr, sets, k);\n        if (op == 'u') {\n            v1 = unite(v1, v2);\n        } else if (op == 'i') {\n            v1 = intersection(v1, v2);\n        } else if (op == 'd') {\n            v1 = difference(v1, v2);\n        } else if (op == 's') {\n            v1 = symmetric_difference(v1, v2);\n        }\n    }\n    return v1;\n}\n\nvoid solve(string &expr, mapset &sets) {\n    int k = 0;\n    set<int> st = parse(expr, sets, k);\n    if (st.empty()) {\n        cout << \"NULL\" << endl;\n        return ;\n    }\n    for (set<int>::iterator it=st.begin(); it!=st.end(); ++it) {\n        cout << (it == st.begin() ? \"\" : \" \") << *it;\n    }\n    cout << endl;\n}\n\nint main() {\n    char c; int k;\n    map<char, set<int> > sets;\n    while (cin >> c >> k) {\n        if (c != 'R') {\n            set<int> st; int t;\n            for (int i=0; i<k; ++i) {\n                cin >> t;\n                st.insert(t);\n            }\n            sets[c] = st;\n        } else {\n            string expr;\n            cin >> expr;\n            solve(expr, sets);\n\n            sets.clear();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nVI factor(State&);\nVI term(State&);\n\nmap<char, VI> mp;\nVI all;\n\n// begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n            << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nVI uni(VI a, VI b) {\n\tVI ret;\n\tfor(int i: a) ret.PB(i);\n\tfor(int i: b) ret.PB(i);\n\tsort(ALL(ret));\n\tret.erase(unique(ALL(ret)), ret.end());\n\treturn ret;\n}\n\nVI inter(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: b) {\n\t\tif(tmp.find(i) != tmp.end()) {\n\t\t\tret.PB(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI diff(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: b) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: a) {\n\t\tif(tmp.find(i) == tmp.end()) {\n\t\t\tret.PB(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI symm(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tfor(int i: b) {\n\t\tif(tmp.find(i) != tmp.end()) tmp[i] = 2;\n\t\telse tmp[i] = 1;\n\t}\n\tVI ret;\n\tfor(int i: a) if(tmp[i] == 1) ret.PB(i);\n\tfor(int i: b) if(tmp[i] == 1) ret.PB(i);\n\treturn ret;\n}\n\nVI comp(VI a) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: all) if(tmp.find(i) == tmp.end()) ret.PB(i);\n\treturn ret;\n}\n\nVI expr(State &begin) {\n\t//cout << \"st:\" << *begin << endl;\n\tVI ret = term(begin);\n\twhile(1) {\n\t\t//cout << *begin << endl;\n\t\tif(*begin == 'u') {\n\t\t\tbegin++;\n\t\t\tret = uni(ret, term(begin));\n\t\t} else if(*begin == 'i') {\n\t\t\tbegin++;\n\t\t\tret = inter(ret, term(begin));\n\t\t} else if(*begin == 'd') {\n\t\t\tbegin++;\n\t\t\tret = diff(ret, term(begin));\n\t\t} else if(*begin == 's') {\n\t\t\tbegin++;\n\t\t\tret = symm(ret, term(begin));\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nVI term(State &begin) {\n\tVI ret = factor(begin);\n\twhile(1) {\n\t\t//cout << \"te:\" << *begin << endl;\n\t\tif(*begin == 'c') {\n\t\t\tbegin++;\n\t\t\tret = comp(factor(begin));\n\t\t} else if(isupper(*begin)){\n\t\t\tret = mp[*begin];\n\t\t\tbegin++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tVI ret = expr(begin);\n\t\tconsume(begin, ')');\n\t\treturn ret;\n\t} else if(isupper(*begin)){\n\t\tVI ret = mp[*begin];\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\treturn {};\n}\n\nsigned main(void)\n{\n\tchar name;\n\tint num;\n\twhile(cin >> name >> num) {\n\t\tif(name == 'R' && num == 0) {\n\t\t\tfor(auto i: mp) {\n\t\t\t\tfor(int j: i.second) {\n\t\t\t\t\tall.PB(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(all));\n\t\t\tall.erase(unique(ALL(all)), all.end());\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tState begin = s.begin();\n\t\t\tVI ans = expr(begin);\n\t\t\tsort(ALL(ans));\n\t\t\tREP(i, ans.size()) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif(i != ans.size()-1) cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tmp.erase(ALL(mp));\n\t\t\tall.erase(ALL(all));\n\t\t}\n\t\tREP(i, num) {\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\tmp[name].PB(m);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,const vector<int>& U, int pos);\nP term(const string& str,const vector<int>& U, int pos);\nvector<int> numbers[256];\nvector<int> U;\n\nP factor(const string& str,const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    P r2 = term(str,U,pos+1);\n    if(str[pos] == 'u'){\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str, const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,U,pos+1);\n    return P(r.first,compute_complement(r.second,U));\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    char alphabet[8];\n    int num_of_elements;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < 256; i++){\n      numbers[i].clear();\n    }\n    U.clear();\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\ntypedef vector<int> vec;\n\nvec And(vec &a,vec &b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  int a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>17) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  set<int> value;\n  int p;\n  Result(set<int> v, int p) : value(v), p(p) {}\n};\n\nbool is_operator(char c){\n  string opes = \"uidsc\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nvoid operation(const set<int>& s1, const set<int>& s2, char ope, set<int>& res){\n  if(ope == 'u'){\n    FORIT(it, s1) res.insert(*it);\n    FORIT(it, s2) res.insert(*it);\n  }else if(ope == 'i'){\n    FORIT(it, s1) if(s2.count(*it)) res.insert(*it);\n  }else if(ope == 'd'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n  }else if(ope == 's'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n    FORIT(it, s2) if(!s1.count(*it)) res.insert(*it);\n  }else{\n    assert(false);\n  }\n}\nResult expr(const string& s, int p, map<char, set<int> >& vars);\nResult factor(const string& s, int p, map<char, set<int> >& vars);\nResult expr(const string& s, int p, map<char, set<int> >& vars){\n  Result r = factor(s, p, vars);\n  while(is_operator(s[r.p])){\n    Result r_ = factor(s, r.p + 1, vars);\n    set<int> newset;\n    operation(r.value, r_.value, s[r.p], newset);\n    r.value = newset;\n    r.p = r_.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p, map<char, set<int> >& vars){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1, vars);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(s[p] == 'c'){\n    Result r = factor(s, p + 1, vars);\n    set<int> v;\n    FORIT(it, vars['U'])if(!r.value.count(*it)){\n      v.insert(*it);\n    }\n    r.value = v;\n    return r;\n  }else{\n    assert(vars.count(s[p]));\n    set<int> v = vars[s[p++]];\n    return Result(v, p);\n  }\n}\n\nint main(){\n  while(true){\n    char v; int l;\n    map<char, set<int> > vars;\n    while(cin >> v >> l){\n      if(v == 'R'){\n        break;\n      }\n      set<int> s;\n      REP(i, l) {\n        int t; cin>>t;\n        s.insert(t);\n        vars['U'].insert(t);\n      }\n      vars[v] = s;\n    }\n    if(cin.eof()) return 0;\n    string s;\n    cin >> s;\n    set<int> res = expr(s, 0, vars).value;\n    assert(expr(s, 0, vars).p == s.size());\n    FORIT(it, res){\n      if(it != res.begin()) cout << \" \";\n      cout << *it;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        begin++;\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            if(c == 'R' && n == 0) break;\n            f = true;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n\n        if(not f) break;\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << '\\0' << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p]-'A']),p++;\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<sstream>\nusing namespace std;\n\nstruct Data{\n  set<int>tmp;\n  int i;\n};\n\nchar LIST[6]={'A','B','C','D','E','U'};\n\nset<int> un(set<int>A,set<int>B){\n  set<int>res;\n  set<int>::iterator x;\n  for(x=A.begin();x!=A.end();x++){\n    res.insert(*x);\n  }\n  for(x=B.begin();x!=B.end();x++){\n    res.insert(*x);\n  }\n  return res;\n}\nset<int> in(set<int>A,set<int>B){\n  set<int>res;\n  set<int>::iterator x;\n  for(x=A.begin();x!=A.end();x++){\n    if(B.find(*x)!=B.end())res.insert(*x);\n  }\n  return res;\n}\nset<int> de(set<int>A,set<int>B){\n  set<int>res;\n  set<int>::iterator x;\n  for(x=A.begin();x!=A.end();x++){\n    if(B.find(*x)==B.end())res.insert(*x);\n  }\n  return res;\n}\nset<int> sy(set<int>A,set<int>B){\n  return un(de(A,B),de(B,A));\n}\nset<int> co(set<int>A,set<int>U){\n  set<int>res;\n  set<int>::iterator x;\n  for(x=U.begin();x!=U.end();x++){\n    if(A.find(*x)==A.end())res.insert(*x);\n  }\n  return res;\n}\n\nset<int>solve(map< char,set<int> >sets, string line);\nData equation(map< char,set<int> >sets, string line, int i);\nData term(map< char,set<int> >sets, string line, int i);\n\nset<int>solve(map< char,set<int> >sets, string line){\n  return equation(sets,line,0).tmp;\n}\n\nData equation(map< char,set<int> >sets, string line, int i){\n  Data left=term(sets,line,i);\n  i = left.i;\n  Data res=left;\n  while(1){\n    char op=line[i];\n    if(op!='u'&&op!='i'&&op!='d'&&op!='s')break;\n    i++;\n    Data right=term(sets,line,i);\n    i = right.i;\n    switch (op){\n    case 'u':\n      res.tmp=un(left.tmp, right.tmp);\n      break;\n    case 'i':\n      res.tmp=in(left.tmp, right.tmp);\n      break;\n    case 'd':\n      res.tmp=de(left.tmp, right.tmp);\n      break;\n    case 's':\n      res.tmp=sy(left.tmp, right.tmp);\n      break;\n    }\n    res.i=i;\n  }\n  return res;\n}\n\nData term(map< char,set<int> >sets, string line, int i){\n  Data res;\n  if(line[i]=='c'){\n    int cnt=1;\n    while(line[++i]=='c'){\n      cnt++;\n    }\n    if(cnt&1)res.tmp = co(sets[line[i]], sets['U']);\n    else res.tmp = sets[line[i]];\n    res.i = i+1;\n  }else if(line[i]!='('){\n    res.tmp = sets[line[i]];\n    res.i = i+1;\n  }else{\n    res = equation(sets,line,i+1);\n    res.i++;\n  }\n  return res;\n}\n\nint main()\n{\n  char name;\n  int number;\n  string line;\n\n  map< char,set<int> >sets;\n  set<int>ans;\n  set<int>::iterator x;\n\n  while(cin>>name>>number){\n    getline(cin,line);\n    getline(cin,line);\n    if(name!='R'){\n      stringstream ss(line);\n      int element;\n      while(ss>>element){\n        sets['U'].insert(element);\n        sets[name].insert(element);\n      }\n    }else{\n      ans=solve(sets,line);\n      if(ans.empty()){\n        cout<<\"NULL\"<<endl;\n      }else{\n        for(x=ans.begin();x!=ans.end();x++){\n          if(x!=ans.begin())cout<<\" \";\n          cout<<*x;\n        }\n        cout<<endl;\n      }\n      for(int i=0;i<6;i++)sets[LIST[i]].clear();\n      ans.clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n// 構文解析\nusing State = string::const_iterator;\nclass ParseError{};\n\nmap<char, vector<int>> st;\n\nvoid comp(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n}\n\nvector<int> op_u(vector<int> A, vector<int> B) {\n    vector<int> ret;\n    set_union(A.begin(), A.end(), B.begin(), B.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> op_i(vector<int> A, vector<int> B) {\n    vector<int> ret;\n    set_intersection(A.begin(), A.end(), B.begin(), B.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> op_d(vector<int> A, vector<int> B) {\n    vector<int> ret;\n    set_difference(A.begin(), A.end(), B.begin(), B.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> op_s(vector<int> A, vector<int> B) {\n    vector<int> ret;\n    set_symmetric_difference(A.begin(), A.end(), B.begin(), B.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> op_c(vector<int> A) {\n    vector<int> ret;\n    set_symmetric_difference(st['U'].begin(), st['U'].end(), A.begin(), A.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> term(State &begin);\nvector<int> factor(State &begin);\nvector<int> expression(State &begin);\n\n// 乗算除算の式をパースして，その評価結果を返す\nvector<int> term(State &begin) {\n    if (*begin == 'c') {\n        begin++;\n        return op_c(factor(begin));\n    }\n    else {\n        return factor(begin);\n    }\n}\n\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        vector<int> ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else {\n        return st[*begin++];\n    }\n}\n\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    for (;;) {\n        if (*begin == 'u') {\n            begin++;\n            ret = op_u(ret, term(begin));\n        }\n        else if (*begin == 'i') {\n            begin++;\n            ret = op_i(ret, term(begin));\n        }\n        else if (*begin == 'd') {\n            begin++;\n            ret = op_d(ret, term(begin));\n        }\n        else if (*begin == 's') {\n            begin++;\n            ret = op_s(ret, term(begin));\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    while (true) {\n        st.clear();\n        char ch;\n        int n;\n        bool ok = false;\n        while (cin >> ch >> n) {\n            ok = true;\n            if (ch == 'R' and n == 0) break;\n            int a;\n            rep(i, n) {\n                cin >> a;\n                st['U'].emplace_back(a);\n                st[ch].emplace_back(a);\n            }\n        }\n\n        comp(st['U']);\n        if (!ok) break;\n        for (auto & s : st) comp(s.second);\n\n        cin.ignore();\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        vector<int> ans = expression(begin);\n        if (ans.size() == 0) cout << \"NULL\" << endl;\n        else {\n            rep (i, ans.size()) {\n                if (i) cout << \" \";\n                cout << ans[i];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nvi S[6];\nstring expr;\n\nvi calc(vi a,vi b,char op)\n{\n\tvi ret(a.size()+b.size());\n\tvi::iterator it;\n\tswitch(op)\n\t{\n\tcase 'u':\n\t\tit=set_union(all(a),all(b),ret.begin()); break;\n\tcase 'i':\n\t\tit=set_intersection(all(a),all(b),ret.begin()); break;\n\tcase 'd':\n\t\tit=set_difference(all(a),all(b),ret.begin()); break;\n\tcase 's':\n\t\tit=set_symmetric_difference(all(a),all(b),ret.begin()); break;\n\t}\n\tret.erase(it,ret.end());\n\treturn ret;\n}\n\nvi eval(int s,int t)\n{\n\tint d=0,p=s; char c;\n\tfor(;p<t;p++)\n\t{\n\t\tc=expr[p];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(p==t)\n\t{\n\t\tif(expr[s]=='(')return eval(s+1,t-1);\n\t\tif(expr[s]=='c')return calc(S[5],eval(s+1,t),'d');\n\t\treturn S[expr[s]-'A'];\n\t}\n\treturn calc(eval(s,p),eval(p+1,t),c);\n}\n\nint main()\n{\n\tchar c; int n;\n\twhile(cin>>c>>n)\n\t{\n\t\trep(i,5)S[i].clear();\n\t\tdo\n\t\t{\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tint t; cin>>t;\n\t\t\t\tS[c-'A'].pb(t);\n\t\t\t\tS[5].pb(t);\n\t\t\t}\n\t\t}while(cin>>c>>n,c!='R');\n\t\t\n\t\trep(i,6)\n\t\t\tsort(all(S[i])),S[i].erase(unique(all(S[i])),S[i].end());\n\t\tcin>>expr;\n\t\t\n\t\tvi ans=eval(0,expr.size());\n\t\trp(i,ans)cout<<ans[i]<<(i==ans.size()-1?\"\":\" \");\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[5],U;\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0;\n  int l = s.size();\n  set<int> a,b,res;\n\n  if(!s.size())return res;\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p){\n      if(s[i] == 'u'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = U.begin();ite!=U.end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  }\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n\n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<5;i++)alp[i].clear();\n    U.clear();\n    while(c != 'R'){\n      int tmp;\n\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m[c]].insert(tmp);\n\tU.insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint idx;\nstring s;\nvector<int> u;\nvector<int> v[128];\n\nvector<int> op(char ch,vector<int> a,vector<int> b=vector<int>()){\n\tvector<int> res(502);\n\tvector<int>::iterator it;\n\n\tif(ch == 'u') it = set_union(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'i') it = set_intersection(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'd') it = set_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 's') it = set_symmetric_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'c') it = set_difference(u.begin(),u.end(),a.begin(),a.end(),res.begin());\n\n\tres.resize(it-res.begin());\n\treturn res;\n}\n\nvector<int> solve(void){\n\tbool flg = false;\n\tif(s[idx] == 'c'){\n\t\tflg = true;\n\t\tidx++;\n\t}\n\n\tvector<int> res;\n\tif(s[idx] == '('){\n\t\tidx++;\n\t\tres = solve();\n\t}\n\telse{\n\t\tres = v[s[idx++]];\n\t}\n\n\tif(flg) res = op('c',res);\n\n\twhile(idx < s.length() && s[idx] != ')'){\n\t\tchar ch = s[idx++];\n\n\t\tflg = false;\n\t\tif(s[idx] == 'c'){\n\t\t\tflg = true;\n\t\t\tidx++;\n\t\t}\n\n\t\tvector<int> tmp;\n\t\tif(s[idx] == '('){\n\t\t\tidx++;\n\t\t\ttmp = solve();\n\t\t}\n\t\telse{\n\t\t\ttmp = v[s[idx++]];\n\t\t}\n\n\t\tif(flg) tmp = op('c',tmp);\n\t\tres = op(ch,res,tmp);\n\t}\n\tidx++;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tu.clear();\n\n\t\twhile(1){\n\t\t\tchar name;\n\t\t\tint n;\n\t\t\tif(!(cin>>name>>n)) return 0;\n\t\t\tif(name == 'R') break;\n\n\t\t\tv[name] = vector<int>(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcin>>v[name][i];\n\t\t\t}\n\t\t\tsort(v[name].begin(),v[name].end());\n\t\t\tu = op('u',v[name],u);\n\t\t}\n\n\t\tcin>>s;\n\t\tidx = 0;\n\n\t\tvector<int> ans = solve();\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tcout<<ans[i]<<\" \";\n\t\t}\n\t\tcout<<ans[ans.size()-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n \nusing namespace std;\n\nstring::iterator it;\nmap<char, set<int>> elements;\n\nclass Parse\n{\n  public:     \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n     \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n \n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n     \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n \n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n \n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n \n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n \nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        elements.clear();\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n \n        elements['U'] = U;\n         \n        string str;\n        cin >> str;\n         \n        Parse parse;\n        it = str.begin();\n        set<int> res = parse.expr();\n         \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n\n#define rep(i,n)   for(int i=0;i<n;++i)\n#define all(c)     c.begin(),c.end()\n\nusing namespace std;\ntypedef set<int> iset;\n\nstring src;\nint p;\n\niset U;\nmap<char, iset> sets;\n\niset parse_expr(); // proto\n\nbool end() { return p >= (int)src.length(); }\nchar peek() { return src[p]; }\nvoid succ() { if (!end()) ++p; }\n\niset set_u(const iset &a, const iset &b)\n{\n\tiset c = a;\n\tc.insert(all(b));\n\treturn c;\n}\n\niset set_i(const iset &a, const iset &b)\n{\n\tiset c;\n\tfor (iset::const_iterator it = a.begin(); it != a.end(); ++it)\n\t{\n\t\tif (b.find(*it) != b.end()) c.insert(*it);\n\t}\n\treturn c;\n}\n\niset set_d(const iset &a, const iset &b)\n{\n\tiset c;\n\tfor (iset::const_iterator it = a.begin(); it != a.end(); ++it)\n\t{\n\t\tif (b.find(*it) == b.end()) c.insert(*it);\n\t}\n\treturn c;\n}\n\niset set_s(const iset &a, const iset &b)\n{\n\treturn set_u(set_d(a, b), set_d(b, a));\n}\n\niset set_c(const iset &a)\n{\n\treturn set_d(U, a);\n}\n\niset parse_primary()\n{\n\tiset s;\n\n\tchar c = peek();\n\tswitch (c)\n\t{\n\tcase 'c':\n\t\tsucc();\n\t\ts = set_c(parse_primary());\n\t\tbreak;\n\tcase '(':\n\t\tsucc();\n\t\ts = parse_expr();\n\t\tif (peek() == ')') succ();\n\t\tbreak;\n\tdefault:\n\t\tsucc();\n\t\ts = sets[c];\n\t\tbreak;\n\t}\n\treturn s;\n}\n\nbool is_op()\n{\n\tchar c = peek();\n\treturn c=='u'||c=='i'||c=='d'||c=='s';\n}\n\niset parse_expr()\n{\n\tiset a = parse_primary();\n\n\twhile (!end() && is_op())\n\t{\n\t\tchar op = peek();\n\t\tsucc();\n\n\t\tiset b = parse_primary();\n\t\tswitch (op)\n\t\t{\n\t\tcase 'u':\n\t\t\ta = set_u(a, b);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\ta = set_i(a, b);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\ta = set_d(a, b);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\ta = set_s(a, b);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\niset parse()\n{\n\tp = 0;\n\treturn parse_expr();\n}\n\nint main()\n{\n\twhile(!cin.eof())\n\t{\n\t\tchar name;\n\t\tint N, e;\n\n\t\tU.clear();\n\t\tsets.clear();\n\t\twhile(cin >> name >> N, name != 'R')\n\t\t{\n\t\t\trep(i,N)\n\t\t\t{\n\t\t\t\tcin >> e;\n\t\t\t\tsets[name].insert(e);\n\t\t\t\tU.insert(e);\n\t\t\t}\n\t\t}\n\n\t\tcin >> src;\n\t\tiset s = parse();\n\t\tif (s.empty())\n\t\t{\n\t\t\tcout << \"NULL\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (iset::const_iterator it = s.begin(); it != s.end(); ++it)\n\t\t{\n\t\t\tif (it != s.begin()) cout << \" \";\n\t\t\tcout << *it;\n\t\t}\n\t\tcout << endl;\n\n\t\tcin.ignore();\n\t\tcin.peek();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\nint INF = (1<<24);\n\nvector<int> U;\nmap < int,bool > used;\n\nmap < char , vector<int> > t;\n\nstring str;\nint pos;\n\nbool input();\n\nvector<int> calc(vector<int>,char ch,vector<int>);\n\nvector<int> compute();\nvector<int> get();\n\nint main(){\n  vector<int> ans;\n  while(input()){\n    pos=0;\n    ans=compute();\n    /*\n    for(int i=0;i<(int)t['A'].size();i++){\n      cout<<t['A'][i]<<' ';\n    }\n    cout<<endl;\n    for(int i=0;i<(int)t['B'].size();i++){\n      cout<<t['B'][i]<<' ';\n    }\n    cout<<endl;\n\n    ans=calc(t['A'],'s',t['B']);\n    for(int i=0;i<(int)ans.size();i++){\n      cout<<ans[i]<<' ';\n    }\n    cout<<endl;\n    */\n    \n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    if(ans.size()==0)cout<<\"NULL\";\n    cout<<endl;\n  }\n  return 0;\n}\n\n\nbool input(){\n  int n,a;\n  char ch;\n  U.clear();\n  used.clear();\n  t.clear();\n  while(1){\n    if(cin>>ch){\n    }else{\n      return false; \n    }\n    cin>>n;\n    if(ch=='R'&&n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a;\n\n      if(used[a]==false){U.push_back(a);used[a]=true;}\n\n      t[ch].push_back(a);\n    }\n    sort(t[ch].begin(),t[ch].end());\n  }\n  sort(U.begin(),U.end());\n  t['U']=U;\n  cin>>str;\n  str.push_back('=');\n  return true;\n}\n\nvector<int> calc(vector<int> A,char ch,vector<int> B){\n\n  int a=0,b=0,Asize=A.size(),Bsize=B.size(),nowA,nowB; \n  vector<int> res;\n\n  if(ch=='u'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n\n  }else if(ch=='i'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n\n  }else if(ch=='d'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n    \n  }else if(ch=='s'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n  }\n\n  return res;\n}\n\n\nvector<int> compute(){\n\n  vector<int> res,X;\n  char ch;\n  res=get();\n\n  while(1){\n    ch=str[pos++];\n    if(ch=='='||ch==')')break;\n    X=get();\n    res=calc(res,ch,X);\n  }\n\n  return res;\n}\n\n\nvector<int> get(){\n  \n  assert(str[pos]!=')');\n  assert(str[pos]!='=');\n\n\n  if(str[pos]=='('){\n    pos++;\n    return compute();\n  }else if(str[pos]=='c'){\n    pos++;\n    return calc(U,'d',get());\n  }else{\n    pos++;\n    return t[str[pos-1]];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n#define EACH(it,n) for(S::iterator it = (n).begin(); it != (n).end() ; ++it)\ntypedef set<int> S;\nmap< string , S > data;\n\n\nstring expr;\n\nS uni(S a,S b){\n\tS ans;\n\tEACH(it,a) ans.insert(*it);\n\tEACH(it,b) ans.insert(*it);\n\treturn ans;\n}\nS inter(S a,S b){\n\tS ans;\n\tEACH(it,a) if(b.count(*it))ans.insert(*it);\n\treturn ans;\n}\nS diff(S a,S b){\n\tS ans;\n\tEACH(it,a) if(!b.count(*it))ans.insert(*it);\n\treturn ans;\n} \nS sym(S a,S b){\n\treturn uni(diff(a,b),diff(b,a));\n}\nS comp(S a){\n\tS ans;\n\tEACH(it,data[\"U\"]) if(!a.count(*it)) ans.insert(*it);\n\treturn ans;\n}\n\n\nint pos = 0;\n\nvoid view(S s){\n\tif(s.size()==0) cout << endl;\n\tEACH(it,s){\n\t\tcout << *it;\n\t\tS::iterator it2 = it;\n\t\tit2++;\n\t\tif( it2 == s.end()) cout << endl;\n\t\telse cout << \" \";\n\t}\n}\nset<int> f(int depth){\n\tstring table = \"uids\";\n\tset<int> le,ri;\n\twhile(pos < expr.size()){\n\t\tint jump = 1;\n\t\tif(expr[pos] == ')'){\n\t\t\treturn le;\n\t\t}else if(expr[pos] == '('){\n\t\t\tpos++;\n\t\t\tle = f(depth+1);\n\t\t}else if(expr[pos] == 'c'){\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos+=2;\n\t\t\t\tle = comp(f(depth+1));\n\t\t\t}else{\n\t\t\t\tjump ++;\n\t\t\t\tle = comp(data[string(1,expr[pos+1])]);\n\t\t\t}\n\t\t}else if(~table.find(expr[pos])){\n\t\t\tchar cc = expr[pos];\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos+=2;\n\t\t\t\tri = f(depth+1);\n\t\t\t}else if(expr[pos+1] == 'c'){\n\t\t\t\tif(expr[pos+2] == '('){\n\t\t\t\t\tpos+=3;\n\t\t\t\t\tri = comp(f(depth+1));\n\t\t\t\t}else{\n\t\t\t\t\tjump+=2;\n\t\t\t\t\tri = comp(data[string(1,expr[pos+2])]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tjump++;\n\t\t\t\tri = data[string(1,expr[pos+1])];\n\t\t\t}\n\t\t\tif(cc == 'u') le = uni(le,ri);\n\t\t\tif(cc == 'i') le = inter(le,ri);\n\t\t\tif(cc == 'd') le = diff(le,ri);\n\t\t\tif(cc == 's') le = sym(le,ri);\n\t\t}else{\n\t\t\tle = data[string(1,expr[pos])];\n\t\t}\n\t\tpos += jump;\n\t}\n\treturn le;\n}\nint main(){\n\twhile(1){\n\t\tstring a; int b;\n\t\tif(cin >> a >> b){\n\t\t\tif(a == \"R\" && b == 0){\n\t\t\t\tcin >> expr;\n\t\t\t\twhile(~expr.find(\"cc\")) expr.replace(expr.find(\"cc\"),2,\"\");\n\t\t\t\tpos = 0;\n\t\t\t\tset<int> res = f(0);\n\t\t\t\tview(res);\n\t\t\t\tdata.clear();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0 ; i < b ; i++){\n\t\t\t\t\tint t; cin >> t;\n\t\t\t\t\tdata[a].insert(t);\n\t\t\t\t\tdata[\"U\"].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}else return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  //else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  //else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define rep(i,n) rep2(i,0,n-1)\nusing S=set<int>;\nS U;\nvoid print(S x){for(auto e:x)cout<<e<<\" \";cout<<endl;}\nvoid f(S &a,S b,char c){\n    if(c=='u') {for(auto e:b)a.emplace(e);}\n    else if(c=='i') for(auto it=a.begin();it!=a.end();) if(b.count(*it))it++;else it = a.erase(it);\n    else if(c=='d') for(auto it=a.begin();it!=a.end();) if(b.count(*it))it=a.erase(it);else it++;\n    else if(c=='s') {S t;for(auto e:a)if(!b.count(e))t.emplace(e);for(auto e:b)if(!a.count(e))t.emplace(e);a=t;}\n}\nvoid cmp(S &a){\n    set<int> nxt;for(auto e:U)if(!a.count(e))nxt.emplace(e);a=nxt;\n}\nconst int N=1100000;\nchar s[N];\nS a[300];\nint i;\nS expr();\nS factor();\nS number(){\n    return a[s[i++]];\n}\nS factor(){\n    bool flag=false;\n    if(s[i]=='c')flag=true,i++;\n    S res;\n    if(s[i]=='('){\n        ++i;\n        res=expr();\n        ++i;\n    }\n    else res=number();\n    if(flag)cmp(res);\n    return res;\n}\nset<char> op{'u','i','d','s'};\nS expr(){\n    S res=factor();\n    for(;;){\n        char c=s[i];\n        if(!op.count(c))break;\n        else i++;\n        f(res,factor(),c);\n    }\n    return res;\n}\nmain(){\n    char c;int n;\n    for(;;){\n        U=S();\n        for(;;){\n            cin>>c>>n;\n            if(cin.eof())exit(0);\n            if(c=='R')break;\n            a[c]=S();\n            rep(_,n){int x;cin>>x;a[c].emplace(x);U.emplace(x);}\n        }\n        cin.ignore();\n        string ss;\n        i=0;\n        getline(cin,ss);\n        rep(j,ss.size())s[j]=ss[j];\n        S ans=expr();\n        if(ans.empty())cout<<\"NULL\\n\";\n        else{\n            cout<<*ans.begin();\n            for(auto it=ans.begin();++it!=ans.end();){\n                cout<<\" \"<<*it;\n            }\n            cout<<endl;\n        }\n\n        rep(j,ss.size())s[j]=0;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <string>\n#include <stack>\nusing namespace std;\n\ntemplate <class Set>\nvoid print_set(Set& setA)\n{\n  typename Set::iterator it;\n  int n = 0;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    n++;\n    if (n != setA.size()) printf(\"%d \", *it);\n    else printf(\"%d\", *it);\n  }\n  printf(\"\\n\");\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet union_set(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.insert(*it);\n  }\n  return res;\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet intersection_set(Set& setA, Set& setB)\n{\n  Set res;\n  typename Set::iterator it;\n\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    if (setA.find(*it) != setA.end())\n    {\n      res.insert(*it);\n    }\n  }\n  return res;\n}\n\n\n// ?£???????????¨????\ntemplate <class Set>\nSet complement(Set& setA, Set& U)\n{\n  Set res(U);\n  typename Set::iterator it;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A-B\ntemplate <class Set>\nSet difference(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A . B\ntemplate <class Set>\nSet symmetric_difference(Set& setA, Set& setB)\n{\n  Set s1 = difference(setA, setB);\n  Set s2 = difference(setB, setA);\n  return union_set(s1, s2);\n}\n\nstring rev_polish_notation(string& exp)\n{\n  stack<char> stk;\n  string rexp;\n  string::iterator it;\n\n  for (it = exp.begin(); it != exp.end(); ++it)\n  {\n    if (*it == '(')\n    {\n      stk.push(*it);\n    }\n    else if (*it == ')')\n    {\n      while (stk.top() != '(')\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.pop();                // top???'('???????????????\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      while ((!stk.empty()) && (stk.top() != '('))\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.push(*it);\n    }\n    else if (*it == 'c')\n    {\n      stk.push(*it);\n    }\n    else if ((*it == 'A') || (*it == 'B') || (*it == 'C') || (*it == 'D') || (*it == 'E'))\n    {\n      rexp = rexp + (*it);\n    }\n  }\n\n  while (!stk.empty())\n  {\n    char tkn = stk.top();\n    rexp = rexp + tkn;\n    stk.pop();\n  }\n\n  return rexp;\n}\n\n\ntemplate <class Set>\nSet set_operation(string& exp, Set& A, Set& B, Set& C, Set& D, Set& E, Set& U)\n{\n  Set S;\n  string rexp = rev_polish_notation(exp); // ???????????????????¨????\n  stack<Set> stk;\n\n  string::iterator it;\n  for (it = rexp.begin(); it != rexp.end(); ++it)\n  {\n    if (*it == 'A') { stk.push(A); }\n    else if (*it == 'B') { stk.push(B); }\n    else if (*it == 'C') { stk.push(C); }\n    else if (*it == 'D') { stk.push(D); }\n    else if (*it == 'E') { stk.push(E); }\n    else if (*it == 'c')\n    {\n      Set s = stk.top();\n      stk.pop();\n      stk.push(complement(s, U));\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      Set s1 = stk.top();\n      stk.pop();\n      Set s2 = stk.top();\n      stk.pop();\n      Set ans;\n\n      switch (*it)\n      {\n      case 'u': stk.push(union_set(s1, s2)); break;\n      case 'i': stk.push(intersection_set(s1, s2)); break;\n      case 'd': stk.push(difference(s2, s1)); break; // ????????????????????¨???\n      case 's': stk.push(symmetric_difference(s1, s2)); break;\n      }\n    }\n  }\n  return stk.top();\n}\n\n\nint main() {\n  set<int> A, B, C, D, E, U;\n  char name;\n  int num;\n  int e;\n  string exp;\n\n  while (cin >> name >> num)\n  {\n    switch (name)\n    {\n    case 'A':\n      for (int i=0;i<num;i++) { cin >> e; A.insert(e); U.insert(e); }\n      break;\n    case 'B':\n      for (int i=0;i<num;i++) { cin >> e; B.insert(e); U.insert(e); }\n      break;\n    case 'C':\n      for (int i=0;i<num;i++) { cin >> e; C.insert(e); U.insert(e); }\n      break;\n    case 'D':\n      for (int i=0;i<num;i++) { cin >> e; D.insert(e); U.insert(e); }\n      break;\n    case 'E':\n      for (int i=0;i<num;i++) { cin >> e; E.insert(e); U.insert(e); }\n      break;\n    case 'R':\n      cin >> exp;\n      set<int> res = set_operation(exp, A, B, C, D, E, U);\n      print_set(res);\n      // ??????????????????????¶???????\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      U.clear();\n      break;\n    }\n    if (cin.eof()) break;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>19) break;\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n \nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> elements;\n \n    Parse(string::iterator it, map<char, set<int>> elements){\n        this->it = it;\n        this->elements = elements;\n    }\n     \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n     \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n \n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n     \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n \n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n \n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n \n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n \nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> elements = {};\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n \n        elements['U'] = U;\n         \n        string str;\n        cin >> str;\n         \n        Parse parse(str.begin(), elements);\n        set<int> res = parse.expr();\n         \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\nint INF = (1<<24);\n\nvector<int> U;\nmap < int,bool > used;\n\nmap < char , vector<int> > t;\n\nstring str;\nint pos;\n\nbool input();\n\nvector<int> calc(vector<int>,char ch,vector<int>);\n\nvector<int> compute();\nvector<int> get();\n\nint main(){\n  vector<int> ans;\n  while(input()){\n    pos=0;\n    ans=compute();\n    /*\n    for(int i=0;i<(int)t['A'].size();i++){\n      cout<<t['A'][i]<<' ';\n    }\n    cout<<endl;\n    for(int i=0;i<(int)t['B'].size();i++){\n      cout<<t['B'][i]<<' ';\n    }\n    cout<<endl;\n\n    ans=calc(t['A'],'s',t['B']);\n    for(int i=0;i<(int)ans.size();i++){\n      cout<<ans[i]<<' ';\n    }\n    cout<<endl;\n    */\n    \n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n\nbool input(){\n  int n,a;\n  char ch;\n  U.clear();\n  used.clear();\n  t.clear();\n  while(1){\n    if(cin>>ch){\n    }else{\n      return false; \n    }\n    cin>>n;\n    if(ch=='R'&&n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a;\n\n      if(used[a]==false){U.push_back(a);used[a]=true;}\n\n      t[ch].push_back(a);\n    }\n    sort(t[ch].begin(),t[ch].end());\n  }\n  sort(U.begin(),U.end());\n  t['U']=U;\n  cin>>str;\n  str.push_back('=');\n  return true;\n}\n\nvector<int> calc(vector<int> A,char ch,vector<int> B){\n\n  int a=0,b=0,Asize=A.size(),Bsize=B.size(),nowA,nowB; \n  vector<int> res;\n\n  if(ch=='u'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n\n  }else if(ch=='i'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n\n  }else if(ch=='d'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n    \n  }else if(ch=='s'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n  }\n\n  return res;\n}\n\n\nvector<int> compute(){\n\n  vector<int> res,X;\n  char ch;\n  res=get();\n\n  while(1){\n    ch=str[pos++];\n    if(ch=='='||ch==')')break;\n    X=get();\n    res=calc(res,ch,X);\n  }\n\n  return res;\n}\n\n\nvector<int> get(){\n  \n  assert(str[pos]!=')');\n  assert(str[pos]!='=');\n\n\n  if(str[pos]=='('){\n    pos++;\n    return compute();\n  }else if(str[pos]=='c'){\n    pos++;\n    return calc(U,'d',get());\n  }else{\n    pos++;\n    return t[str[pos-1]];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <string>\n#include <stack>\nusing namespace std;\n\ntemplate <class Set>\nvoid print_set(Set& setA)\n{\n  typename Set::iterator it;\n  int n = 0;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    n++;\n    if (n != setA.size()) printf(\"%d \", *it);\n    else printf(\"%d\\n\", *it);\n  }\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet union_set(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.insert(*it);\n  }\n  return res;\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet intersection_set(Set& setA, Set& setB)\n{\n  Set res;\n  typename Set::iterator it;\n\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    if (setA.find(*it) != setA.end())\n    {\n      res.insert(*it);\n    }\n  }\n  return res;\n}\n\n\n// ?£???????????¨????\ntemplate <class Set>\nSet complement(Set& setA, Set& U)\n{\n  Set res(U);\n  typename Set::iterator it;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A-B\ntemplate <class Set>\nSet difference(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A . B\ntemplate <class Set>\nSet symmetric_difference(Set& setA, Set& setB)\n{\n  Set s1 = difference(setA, setB);\n  Set s2 = difference(setB, setA);\n  return union_set(s1, s2);\n}\n\nstring rev_polish_notation(string& exp)\n{\n  stack<char> stk;\n  string rexp;\n  string::iterator it;\n\n  for (it = exp.begin(); it != exp.end(); ++it)\n  {\n    if (*it == '(')\n    {\n      stk.push(*it);\n    }\n    else if (*it == ')')\n    {\n      while (stk.top() != '(')\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.pop();                // top???'('???????????????\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      while ((!stk.empty()) && (stk.top() != '('))\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.push(*it);\n    }\n    else if (*it == 'c')\n    {\n      stk.push(*it);\n    }\n    else if ((*it == 'A') || (*it == 'B') || (*it == 'C') || (*it == 'D') || (*it == 'E'))\n    {\n      rexp = rexp + (*it);\n    }\n  }\n\n  while (!stk.empty())\n  {\n    char tkn = stk.top();\n    rexp = rexp + tkn;\n    stk.pop();\n  }\n\n  return rexp;\n}\n\n\ntemplate <class Set>\nSet set_operation(string& exp, Set& A, Set& B, Set& C, Set& D, Set& E, Set& U)\n{\n  Set S;\n  string rexp = rev_polish_notation(exp); // ???????????????????¨????\n  stack<Set> stk;\n\n  string::iterator it;\n  for (it = rexp.begin(); it != rexp.end(); ++it)\n  {\n    if (*it == 'A') { stk.push(A); }\n    else if (*it == 'B') { stk.push(B); }\n    else if (*it == 'C') { stk.push(C); }\n    else if (*it == 'D') { stk.push(D); }\n    else if (*it == 'E') { stk.push(E); }\n    else if (*it == 'c')\n    {\n      Set s = stk.top();\n      stk.pop();\n      stk.push(complement(s, U));\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      Set s1 = stk.top();\n      stk.pop();\n      Set s2 = stk.top();\n      stk.pop();\n      Set ans;\n\n      switch (*it)\n      {\n      case 'u': stk.push(union_set(s1, s2)); break;\n      case 'i': stk.push(intersection_set(s1, s2)); break;\n      case 'd': stk.push(difference(s2, s1)); break; // ????????????????????¨???\n      case 's': stk.push(symmetric_difference(s1, s2)); break;\n      }\n    }\n  }\n  return stk.top();\n}\n\n\nint main() {\n  set<int> A, B, C, D, E, U;\n  char name;\n  int num;\n  int e;\n  string exp;\n\n  while (cin >> name >> num)\n  {\n    switch (name)\n    {\n    case 'A':\n      for (int i=0;i<num;i++) { cin >> e; A.insert(e); U.insert(e); }\n      break;\n    case 'B':\n      for (int i=0;i<num;i++) { cin >> e; B.insert(e); U.insert(e); }\n      break;\n    case 'C':\n      for (int i=0;i<num;i++) { cin >> e; C.insert(e); U.insert(e); }\n      break;\n    case 'D':\n      for (int i=0;i<num;i++) { cin >> e; D.insert(e); U.insert(e); }\n      break;\n    case 'E':\n      for (int i=0;i<num;i++) { cin >> e; E.insert(e); U.insert(e); }\n      break;\n    case 'R':\n      cin.ignore();             // ??????????????????????£???°???\n      getline(cin, exp);\n\n      set<int> res = set_operation(exp,A,B,C,D,E,U);\n      print_set(res);\n\n      // ??????????????????????¶???????\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      U.clear();\n      break;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> V;\nV A[10],U;\nstring S;\n\nV Union(V a,V b){\n  for(int i=0;i<(int)b.size();i++) a.push_back(b[i]);\n  sort(a.begin(),a.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  return a;\n}\n\nV Inter(V a,V b){\n  V res;\n  int n =a.size(),m=b.size();\n  /*  a.push_back(1e9),b.push_back(1e9);\n  int i = 0,j = 0;\n  while(i<n||j<m){\n    if(a[i]<b[j])i++;\n    else if(a[i]>b[j])j++;\n    else res.push_back(a[i]),i++,j++;\n    }*/\n\n  for(int i=0;i<n;i++){\n    int flg = 0;\n    for(int j=0;j<m;j++) flg |= a[i] == b[j];\n    if(flg)res.push_back(a[i]);\n  }\n\n  sort(res.begin(),res.end());\n  return res;\n}\n\nV Diff(V a,V b){\n  V res;\n  int n = a.size();\n  int m = b.size();\n  /*b.push_back(1e9);\n  \n  int j =0;\n  for(int i=0;i<n;i++){\n    while(a[i]>b[j])j++;\n    if(a[i]!=b[j]) res.push_back(a[i]);\n  }\n  */\n\n  for(int i=0;i<n;i++){\n    int flg =1;\n    for(int j=0;j<m;j++)flg &=a[i]!=b[j];\n    if(flg)res.push_back(a[i]);\n  }\n  \n  sort(res.begin(),res.end());\n  return res;\n}\n\nV Sdiff(V a,V b){return Union(Diff(a,b),Diff(b,a));}\n\nV Comp(V a){\n  V res;\n  /*  int j = 0;\n  a.push_back(1e9);\n  for(int i=0;i<(int)U.size();i++) {\n    while(a[j] < U[i])j++;\n    if(a[j]!=U[i]) res.push_back(U[i]);\n    }*/\n  \n  for(int i=0;i<U.size();i++){\n    int flg = 1;\n    for(int j=0;j<a.size();j++)flg &= U[i]!=a[j];\n    if(flg) res.push_back(U[i]);\n  }\n  return res;\n}\n\nint p = 0;\nV bnf();\nV getV(){\n  char ch = S[p];\n  V res;\n  if(ch == '(')p++,res = bnf(),p++;\n  else if(isupper(ch))p++,res = A[ch-'A'];\n  else if(ch=='c')p++,res = Comp(getV());\n  else assert(isupper(ch));\n  return res;\n}\n\nV bnf(){\n  V res = getV();\n  while(1){\n    char ch = S[p];\n    if(ch=='(')p++,res = bnf(),p++;\n    else if(ch=='c')p++,res = Comp(getV());\n    else if(ch=='u')p++,res = Union(res,getV());\n    else if(ch=='i')p++,res = Inter(res,getV());\n    else if(ch=='d')p++,res = Diff(res,getV());\n    else if(ch=='s')p++,res = Sdiff(res,getV());\n    else if(p<S.size()&&ch!=')')assert(ch==')');\n    else break;\n  }\n  return res;\n}\n\nint main(){\n\n  while(1){\n    U.clear();\n    while(1){\n      char ch;\n      int n;\n      if(!(cin>>ch>>n))exit(0);\n      if(ch == 'R' && n == 0) break;\n      int idx = ch-'A';\n      A[idx].resize(n);\n      for(int i=0;i<n;i++)cin>>A[idx][i],U.push_back(A[idx][i]);\n      sort(A[idx].begin(),A[idx].end());\n      A[idx].erase(unique(A[idx].begin(),A[idx].end()),A[idx].end());\n    }\n    \n    sort(U.begin(),U.end());\n    U.erase(unique(U.begin(),U.end()),U.end());\n    cin >> S;\n    p = 0;\n    V ans = bnf();\n    \n    for(int i=0;i<ans.size();i++){\n      if(i)cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,const vector<int>& U, int pos);\nP term(const string& str,const vector<int>& U, int pos);\nvector<int> numbers[256];\nvector<int> U;\n\nP factor(const string& str,const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str, const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,U,pos+1);\n    return P(r.first,compute_complement(r.second,U));\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    char alphabet[8];\n    int num_of_elements;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < 256; i++){\n      numbers[i].clear();\n    }\n    U.clear();\n    // if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n#include <string>\n\nusing namespace std;\n\nmap<char, vector<int> > mpp;\nstring str;\nint p;\n\nbool check()\n{\n  return (str[p] == 'u' || str[p] == 'i' || str[p] == 'd' || str[p] == 's');\n}\n\nvector<int> func();\nvector<int> elm()\n{\n  vector<int> res;\n  if(str[p] == '('){\n    ++p;\n    res = func();\n  } else if(str[p] == 'c'){\n    ++p;\n    if(str[p] == '('){\n      ++p;\n      res = func();\n    } else {\n      res = mpp[str[p]];\n    }\n    vector<int> vec(res.size()+mpp['U'].size());\n    vector<int>::iterator it = set_difference(mpp['U'].begin(), mpp['U'].end(), res.begin(), res.end(), vec.begin());\n    vec.resize(it-vec.begin());\n    res = vec;\n  } else {\n    res = mpp[str[p]];\n  }\n  ++p;\n\n  return res;\n}\n\nvector<int> func()\n{\n  char ch;\n  vector<int> res = elm();\n\n  while(p < str.size() && check()){\n    ch = str[p++];\n    vector<int> vec(res.size()+mpp[str[p]].size());\n    vector<int> vec2 = elm();\n    vector<int>::iterator it;\n\n    if(ch == 'u'){\n      it = set_union(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    } else if(ch == 'i'){\n      it = set_intersection(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    } else if(ch == 'd'){\n      it = set_difference(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    } else {\n      it = set_symmetric_difference(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    }\n\n    vec.resize(it-vec.begin());\n    res = vec;\n  }\n\n  return res;\n}\n\nint main()\n{\n  char ch;\n  int n, t;\n  set<int> stt;\n  vector<int> vec;\n\n  while(1){\n    for(int i = 0; i < 5; i++)\n      mpp['A'+i] = vec;\n    while(1){\n      if(!(cin>>ch>>n)) return 0;\n      if(ch == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i){\n\tcin >> t;\n\tvec.push_back(t);\n\tstt.insert(t);\n      }\n      sort(vec.begin(), vec.end());\n      mpp[ch] = vec;\n      vec.clear();\n    }\n    for(set<int>::iterator it = stt.begin(); it != stt.end(); ++it) \n      vec.push_back(*it);\n    mpp['U'] = vec;\n    cin >> str;\n\n    p = 0;\n    vec = func();\n    if(vec.size() > 0){\n      cout << vec[0];\n      for(int i = 1; i < vec.size(); ++i) cout << \" \" << vec[i];\n      cout << endl;\n    } else {\n      cout << \"NULL\" << endl;\n    }\n\n    mpp.clear();\n    stt.clear();\n    vec.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[1000000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 2)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tif(check[A[i]] == false){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 1)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tif(check[U[i]] == false){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tcheck[V[i][k]] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])U.push_back(i);\n\t}\n}\n\n\nint debug = 0;\n\nvector<int> recursive(int left,int right){\n\n\tdebug++;\n\tif(debug >= 10){\n\t\tvector<int> ret;\n\t\tret.push_back(889);\n\t\treturn ret;\n\t}\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t}else{\n\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  //if(S[p]=='(')p++,s=bnf(),p++;\n  //else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  //else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  return factor(str,numbers,U,pos);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(1){\n    if(pos >= str.size()){\n      break;\n    }\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else{\n      break;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = equation(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        cin >> num;\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = equation(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n        printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele){\n        this->ele = ele;\n        it = s.begin();\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement_(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference_(a, b);\n                    break;\n                case 'i':\n                    a = intersection_(a, b);\n                    break;\n                case 's':\n                    a = sym_difference_(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement_(set<int> a)\n    {\n        return difference_(ele['U'], a);\n    }\n    \n    set<int> difference_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference_(set<int> a, set<int> b)\n    {\n        return (union_(difference_(a, b), difference_(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> ele;\n        set<int> U;\n\n        for(char c = 'A' ; c <= 'Z' ; c++){\n            ele[c].clear();\n        }\n        \n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            ele[ch] = st;\n        }while(cin >> ch >> N);\n\n        ele['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.expr();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef pair<int, vector<int> > Result;\nvector<int> universal;\nvector<int> sets[100];\n\nvoid print_vector(const vector<int>& v)\n{\n  for (int i = 0; i < (int)v.size(); ++i) {\n    if (i != 0) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nResult parse_atom(const string& str, int k);\n\nResult parse_expr(const string& str, int k)\n{\n  Result lhs = parse_atom(str, k);\n  while (islower(str[lhs.first])) {\n    Result rhs = parse_atom(str, lhs.first + 1);\n    vector<int> result;\n    switch (str[lhs.first]) {\n    case 'u':\n      set_union(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'i':\n      set_intersection(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'd':\n      set_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 's':\n      set_symmetric_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    }\n    lhs = make_pair(rhs.first, result);\n  }\n  return lhs;\n}\n\nResult parse_atom(const string& str, int k)\n{\n  if (str[k] == 'c') {\n    Result ret = parse_atom(str, k+1);\n    vector<int> result;\n    set_difference(ALL(universal), ALL(ret.second), back_inserter(result));\n    return make_pair(ret.first, result);\n  } else if (str[k] == '(') {\n    Result ret = parse_expr(str, k+1);\n    return make_pair(ret.first+1, ret.second);\n  } else {\n    return make_pair(k+1, sets[str[k]-'A']);\n  }\n}\n\nint main()\n{\n  for (;;) {\n    char name;\n    int n;\n    universal.clear();\n    for (int i = 0; i < 100; ++i) {\n      sets[i].clear();\n    }\n    for (;;) {\n      if (!(cin >> name >> n)) { return 0; }\n      if (name == 'R') { break; }\n      for (int i = 0; i < n; ++i) {\n        int v; cin >> v;\n        sets[name-'A'].push_back(v);\n        universal.push_back(v);\n      }\n      sort(ALL(sets[name-'A']));\n    }\n    sort(ALL(universal));\n    universal.erase(unique(ALL(universal)), universal.end());\n    string str; cin >> str;\n    vector<int> ret = parse_expr(str + \".\", 0).second;\n    if (ret.empty()) {\n      cout << \"NULL\" << endl;\n    } else {\n      print_vector(ret);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint rst(int);\nvector<vector<int> > se;\nvector<set<int> > vse;\nvector<int> u;\nstring st;\nint main(){\n  while(1){\n    \n    se=vector<vector<int> >(5);\n    vse=vector<set<int> >(5);\n    while(1){\n      char ch;\n      int n;\n      cin >> ch >> n;\n      if(cin.eof())return 0;\n      if(ch=='R'&&n==0)break;\n      for(int i=0;i<n;i++){\n\tint num;\n\tcin >> num;\n\tse[ch-'A'].push_back(num);\n\tvse[ch-'A'].insert(num);\n\t//\tuse.insert(se[ch-'A'][i]);\n\tu.push_back(num);\n      }\n    }\n    st=\"\";\n    cin >> st;\n    st+=')';\n    int ans;\n    ans=rst(0);\n    sort(se[ans].begin(),se[ans].end());\n    for(int i=0;i<se[ans].size();i++){\n      if(i)cout << \" \";\n      cout << se[ans][i];\n    }\n    cout << endl;\n  }\n  return 0;\n}\nint rst(int I){\n  int m1=-1,m2=-1;\n  int kc=1;\n  int fu=0;//1u2i3d4s\n  int csw=0;\n  for(int i=I;i<st.size();i++){\n    //cout << fu << \" \"<< i<< endl;\n    if(st[i]=='('){\n      kc++;\n      if(kc==2){\n\t//cout << \"in\" << endl;\n\tm2=rst(i+1);\n      }\n    }\n    else if(st[i]==')'){\n      kc--;\n      if(kc==0){\n\t//cout << \"out\" << endl;\n\treturn m1;\n      }\n    }\n    else if(kc>1)continue;\n    else if(st[i]=='u')fu=1;\n    else if(st[i]=='i')fu=2;\n    else if(st[i]=='d')fu=3;\n    else if(st[i]=='s')fu=4;\n    else if(st[i]=='c')csw=1;\n    else if(st[i]>='A'&&st[i]<='E'){\n      m2=st[i]-'A';\n      if(csw){\n\tcsw=0;\n\tvector<int> b;\n\tset<int> bse;\n\tfor(int i=0;i<u.size();i++){\n\t  if(!vse[m2].count(u[i])){\n\t    b.push_back(u[i]);\n\t    bse.insert(u[i]);\n\t  }\n\t}\n\tse.push_back(b);\n\tvse.push_back(bse);\n\tm2=vse.size()-1;\n      }\n    }\n    if(m1==-1){\n      m1=m2;\n      m2=-1;\n    }\n    else if(m1>=0&&m2>=0){\n      vector<int> bu;\n      set<int> buse;\n      if(fu==1){\n\t//cout << \"f1\"<< endl;\n\tbu=se[m1];\n\tbuse=vse[m1];\n\tfor(int i=0;i<se[m2].size();i++){\n\t  if(!buse.count(se[m2][i]))bu.push_back(se[m2][i]);\n\t  buse.insert(se[m2][i]);\n\t}\n      }\n      else if(fu==2){\n\t//cout << \"f2\"<< endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      }\n      else if(fu==3){\n\t//cout << \"f3\"<< endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(!vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      }\n      else if(fu==4){\n\t//cout << \"fu4\" << endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(!vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      \tfor(int i=0;i<se[m2].size();i++){\n\t  if(!vse[m1].count(se[m2][i])){\n\t    bu.push_back(se[m2][i]);\n\t    buse.insert(se[m2][i]);\n\t  }\n\t}\n      }\n      se.push_back(bu);\n      vse.push_back(buse);\n      m1=vse.size()-1;\n      m2=-1;\n      fu=0;\n    }\n    //    cout << m1 << \" \" << m2 << endl; \n  }\n}\n      \n\t  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nstd::set<int> parse(\n    const std::string &s, size_t &i,\n    const std::map<char, std::set<int>> &sets, const std::set<int> &univ,\n    const std::vector<std::string> &ops={\"uids\"}, size_t preced=0) {\n\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      std::set<int> res=parse(s, ++i, sets, univ, ops, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if (s[i] == 'c') {\n      std::set<int> cmpl=parse(s, ++i, sets, univ, ops, preced);\n      std::set<int> res;\n      for (int x: univ)\n        if (!cmpl.count(x)) res.insert(x);\n      return res;\n    }\n    if (isupper(s[i])) {\n      return sets.at(s[i++]);\n    }\n    assert(false);\n  }\n\n  std::set<int> lhs=parse(s, i, sets, univ, ops, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    std::set<int> rhs=parse(s, ++i, sets, univ, ops, preced+1);\n\n    if (op == 'u') {\n      if (lhs.size() < rhs.size()) lhs.swap(rhs);\n      for (int x: rhs)\n        lhs.insert(x);\n    } else if (op == 'i') {\n      std::set<int> tmp;\n      if (lhs.size() < rhs.size()) lhs.swap(rhs);\n      for (int x: rhs)\n        if (lhs.count(x)) tmp.insert(x);\n      lhs = std::move(tmp);\n    } else if (op == 'd') {\n      std::set<int> tmp;\n      for (int x: lhs)\n        if (!rhs.count(x)) tmp.insert(x);\n      lhs = std::move(tmp);\n    } else if (op == 's') {\n      std::set<int> tmp;\n      for (int x: lhs)\n        if (!rhs.count(x)) tmp.insert(x);\n      for (int x: rhs)\n        if (!lhs.count(x)) tmp.insert(x);\n      lhs = std::move(tmp);\n    }\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  std::map<char, std::set<int>> sets;\n  std::set<int> univ;\n  while (true) {\n    char ch;\n    size_t n;\n    if (scanf(\" %c %zu\", &ch, &n) == EOF) return 1;\n    if (ch == 'R') break;\n    std::set<int> set;\n    for (size_t i=0; i<n; ++i) {\n      int x;\n      scanf(\"%d\", &x);\n      set.emplace(x);\n      univ.emplace(x);\n    }\n    sets[ch] = set;\n  }\n\n  char buf[1<<18];\n  scanf(\"%s\", buf);\n  std::string s=std::move(buf);\n  size_t i=0;\n  std::set<int> res=parse(s, i, sets, univ);\n  if (res.empty()) {\n    printf(\"NULL\\n\");\n    return 0;\n  }\n\n  for (auto it=res.cbegin(); it!=res.cend(); ++it)\n    printf(\"%d%c\", *it, std::next(it)!=res.cend()? ' ':'\\n');\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include <fstream>\n#include <time.h>\n#include <cctype>\n\n\n\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end());\n#define ll long long\n#define pb(a) push_back(a)\n#define m0(x) memset(x,0,sizeof(x))\n#define print(x) cout<<x<<'\\n';\n#define pe(x) cout<<x<<\" \";\n#define lb(v,n) lower_bound(v.begin(), v.end(), n);\n#define ub(v,n) upper_bound(v.begin(), v.end(), n);\n//#define int long long\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\nconst int MAX = 200010;\nint MOD = (ll)1000000000 + 7;\nll INF = 1e17;\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ntypedef pair<ll, int>P;\ntypedef string::const_iterator State;\nclass ParseError {};\nset<int>S[10];\nset<int> expr(State& begin);\nset<int> factor(State& begin);\nset<int> num(State& begin);\nset<int>uni(set<int>X, set<int>Y) {\n\tset<int>res;\n\tfor (auto x : X)res.insert(x);\n\tfor (auto y : Y)res.insert(y);\n\treturn res;\n}\nset<int>inter(set<int>X, set<int>Y) {\n\tset<int>res = X;\n\tfor (auto x : X) {\n\t\tif (Y.find(x) == Y.end()) {\n\t\t\tres.erase(x);\n\t\t}\n\t}\n\treturn res;\n}\nset<int>diff(set<int>X, set<int>Y) {\n\tset<int>res = X;\n\tfor (auto x : X) {\n\t\tif (Y.find(x) != Y.end()) {\n\t\t\tres.erase(x);\n\t\t}\n\t}\n\treturn res;\n}\nset<int> sym(set<int>X, set<int>Y) {\n\tset<int>res;\n\tfor (auto x : X) {\n\t\tif (Y.find(x) == Y.end()) {\n\t\t\tres.insert(x);\n\t\t}\n\t}\n\tfor (auto y : Y) {\n\t\tif (X.find(y) == X.end()) {\n\t\t\tres.insert(y);\n\t\t}\n\t}\n\treturn res;\n}\nset<int>comp(set<int>X, set<int>U) {\n\treturn diff(U, X);\n}\nset<int>U;\n\nset<int>expr(State & begin) {\n\tset<int>ret = factor(begin);\n\twhile (*begin == 'u' || *begin == 'i' || *begin == 'd' || *begin == 's') {\n\t\tif (*begin == 'u') {\n\t\t\tbegin++;\n\t\t\tret = uni(ret, factor(begin));\n\t\t}\n\t\telse if (*begin == 'i') {\n\t\t\tbegin++;\n\t\t\tret = inter(ret, factor(begin));\n\t\t}\n\t\telse if (*begin == 'd') {\n\t\t\tbegin++;\n\t\t\tret = diff(ret, factor(begin));\n\t\t}\n\t\telse if (*begin == 's') {\n\t\t\tbegin++;\n\t\t\tret = sym(ret, factor(begin));\n\t\t}\n\t}\n\treturn ret;\n}\n// 乗算除算の式をパースして、その評価結果を返す。\nset<int> factor(State & begin) {\n\tset<int>ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse if (*begin == 'c') {\n\t\tbegin++;\n\t\tret = comp(factor(begin), U);\n\t\treturn ret;\n\t}\n\telse {\n\t\tret = num(begin);\n\t\treturn ret;\n\t}\n}\n\n\n// 数字の列をパースして、その数を返す。\nset<int> num(State & begin) {\n\tset<int>ret = S[*begin - 'A'];\n\tbegin++;\n\treturn ret;\n}\n\n\nsigned main() {\n\tchar c;\n\twhile (cin >> c) {\n\t\tint n; cin >> n;\n\n\t\tif (c == 'R' && n == 0) {\n\t\t\tstring str; cin >> str;\n\t\t\tstr += '=';\n\t\t\tState begin = str.begin();\n\n\t\t\tset<int>ans = expr(begin);\n\t\t\tif (ans.size() == 0) {\n\t\t\t\tprint(\"NULL\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto itr = ans.begin();\n\t\t\t\twhile (itr != ans.end()) {\n\t\t\t\t\tcout << *itr;\n\t\t\t\t\titr++;\n\t\t\t\t\tif (itr != ans.end()) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tU = {};\n\t\t\tREP(i, 5) {\n\t\t\t\tS[i] = {};\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tREP(i, n) {\n\t\t\tint x; cin >> x;\n\t\t\tS[c - 'A'].insert(x);\n\t\t\tU.insert(x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[2000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tret.push_back(A[i]);\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tret.push_back(B[i]);\n\t}\n\n\tsort(ret.begin(),ret.end());\n\n\tret.erase(unique(ret.begin(),ret.end()),ret.end());\n\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tauto at = MAP.find(B[i]);\n\t\tif(at != MAP.end()){\n\t\t\tret.push_back(B[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tMAP[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tauto at = MAP.find(A[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tMAP[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tauto at = MAP.find(A[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\n\tMAP.clear();\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tauto at = MAP.find(B[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(B[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tauto at = MAP.find(U[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tU.push_back(V[i][k]);\n\t\t}\n\t}\n\tsort(U.begin(),U.end());\n\tU.erase(unique(U.begin(),U.end()),U.end());\n}\n\n\nvector<int> recursive(int left,int right){\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t}else{\n\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n// BNF\n// expr ::= set1 (u set1)* | set1 (i set1)* | set1 (d set1)* | set1 (s set1)*\n// set1 ::= c set1 | set2\n// set2 ::= (expr) | alpha\n\nvector<int> expr();\nvector<int> set1();\nvector<int> set2();\nvector<int> alpha();\n\nint idx;\nchar s[2000];\n\nvector<int> S[5],U;\n\nvector<int> calc_c(const vector<int> &A){\n\tvector<int> B;\n\trep(i,U.size()) if(!binary_search(A.begin(),A.end(),U[i])) B.push_back(U[i]);\n\treturn B;\n}\n\nvector<int> calc_u(const vector<int> &A,const vector<int> &B){\n\tvector<int> C;\n\trep(i,A.size()) C.push_back(A[i]);\n\trep(i,B.size()) C.push_back(B[i]);\n\tsort(C.begin(),C.end());\n\tC.erase(unique(C.begin(),C.end()),C.end());\n\treturn C;\n}\n\nvector<int> calc_i(const vector<int> &A,const vector<int> &B){\n\treturn calc_c(calc_u(calc_c(A),calc_c(B)));\n}\n\nvector<int> calc_d(const vector<int> &A,const vector<int> &B){\n\treturn calc_i(A,calc_c(B));\n}\n\nvector<int> calc_s(const vector<int> &A,const vector<int> &B){\n\treturn calc_u(calc_d(A,B),calc_d(B,A));\n}\n\nvector<int> expr(){\n\tvector<int> A=set1();\n\twhile(s[idx] && s[idx]!=')'){\n\t\tchar op=s[idx++];\n\t\tvector<int> B=set1();\n\n\t\tif     (op=='u') A=calc_u(A,B);\n\t\telse if(op=='i') A=calc_i(A,B);\n\t\telse if(op=='d') A=calc_d(A,B);\n\t\telse             A=calc_s(A,B);\n\t}\n\treturn A;\n}\n\nvector<int> set1(){\n\tif(s[idx]=='c'){\n\t\tidx++;\n\t\treturn calc_c(set1());\n\t}\n\telse return set2();\n}\n\nvector<int> set2(){\n\tvector<int> A;\n\tif(s[idx]=='('){\n\t\tidx++;\n\t\tA=expr();\n\t\tidx++;\n\t}\n\telse A=alpha();\n\treturn A;\n}\n\nvector<int> alpha(){ return S[s[idx++]-'A']; }\n\nint main(){\n\twhile(1){\n\t\tU.clear();\n\t\twhile(1){\n\t\t\tchar c;\n\t\t\tint n;\n\t\t\tif(!~scanf(\" %c%d\",&c,&n)) return 0;\n\t\t\tif(c=='R') break;\n\n\t\t\tS[c-'A'].clear();\n\t\t\trep(i,n){\n\t\t\t\tint e; scanf(\"%d\",&e);\n\t\t\t\tS[c-'A'].push_back(e);\n\t\t\t\tU.push_back(e);\n\t\t\t}\n\t\t\tsort(S[c-'A'].begin(),S[c-'A'].end());\n\t\t}\n\t\tsort(U.begin(),U.end());\n\t\tU.erase(unique(U.begin(),U.end()),U.end());\n\n\t\tscanf(\"%s\",s);\n\t\tidx=0;\n\t\tvector<int> res=expr();\n\n\t\trep(i,res.size()) printf(\"%d%c\",res[i],i<(int)res.size()-1?' ':'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string s;\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele){\n        this->s = s;\n        it = s.begin();\n        this->ele = ele;\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(it != s.end() &&\n              (*it == 'd' ||\n               *it == 'i' ||\n               *it == 's' ||\n               *it == 'u'))\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        return difference(ele['U'], a);\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> ele;\n        set<int> U;\n\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            ele[ch] = st;\n        }while(cin >> ch >> N);\n\n        ele['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.expr();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\n \nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n \nvector<int> U(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n    return ve;\n}\n \nvector<int> I(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n    return ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n    return ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n     \n    for(int i=0;i<a1.size();i++){\n        int r;\n        if(a1[i]==1 && a2[i]==0) r=1;\n        else r=0;\n        ve.pb(r);\n    }\n    return ve;\n}\n \nvector<int> C(vector<int> a1){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n    return ve;\n}\nvector<int> shiki();\nvector<int> han(){\n//  cout<<s[it]<<endl;\n    if(s[it]=='c'){\n        it++;\n        vector<int> e=ka();\n        return C(e);\n    }\n    else{\n        it++;\n        return ch[s[it-1]-'A'];\n    }\n}\n \nvector<int> ka(){\n    if(s[it]=='('){\n        it++;\n        vector<int> q=shiki();\n        it++;\n        return q;\n    }\n    else return han();\n     \n}\n \n \n \nvector<int> shiki(){\n    vector<int> r= ka();\n    while(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n        char c=s[it];\n        it++;\n        vector<int> r2=ka();\n         \n        if(c=='u') r=U(r,r2);\n        if(c=='s') r=S(r,r2);\n        if(c=='d') r=D(r,r2);\n        if(c=='i') r=I(r,r2);\n    }\n    return r;\n}\n \nint cnt=0;\nsigned main(){\nchar c;\n    int d;\n    while(1){\n         \n        cnt++;\n    //  if(cnt>20) break;\n         \n        while(1){\n            cin>>c>>d;\n             \n            if(c=='R') break;\n            for(int i=0;i<d;i++){\n                int r;\n                cin>>r;\n                ve[c-'A'].pb(r);\n            }\n             \n        }\n        set<int> se;\n         \n        for(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n        V.clear();\n        for(auto its=se.begin();its!=se.end();its++){\n            V.pb(*its);\n        }\n         \n        for(int i=0;i<5;i++){\n            for(int j=0;j<V.size();j++){\n            bool b=false;\n            for(int k=0;k<ve[i].size();k++){\n                if(ve[i][k]==V[j]) b=true;\n            }\n            if(b) ch[i].pb(1);\n            else ch[i].pb(0);\n        }\n    //      for(int j=0;j<V.size();j++)cout<<ch[i][j];\n    //      cout<<endl;\n        }\n        it=0;\n        cin>>s;\n        s+=\"*\";\n        vector<int> ans=shiki();\n        bool r=false;\n        for(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n        if(!r) cout<<\"NULL\";\n        cout<<endl;\n         \n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cctype>\nusing namespace std;\ntypedef vector<int>V;\nV a[5],u;\nint x;\nV F(char*s)\n{\n\tvector<V>v;\n\tV m;\n\tv.reserve(x);\n\tm.reserve(u.size());\n\tfor(char*p=s;*p;++p)\n\t{\n\t\tif(isupper(*p))v.push_back(a[*p-'A']);\n\t\telse\n\t\t{\n\t\t\t#define A(L,R) L.begin(),L.end(),R.begin(),R.end(),back_inserter(m)\n\t\t\tm.clear();\n\t\t\tif(*p-'c')\n\t\t\t{\n\t\t\t\tV r(v.back());v.pop_back();\n\t\t\t\tV l(v.back());v.pop_back();\n\t\t\t\tif(*p=='u')set_union(A(l,r));\n\t\t\t\tif(*p=='i')set_intersection(A(l,r));\n\t\t\t\tif(*p=='d')set_difference(A(l,r));\n\t\t\t\tif(*p=='s')set_symmetric_difference(A(l,r));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tV r(v.back());v.pop_back();\n\t\t\t\tset_difference(A(u,r));\n\t\t\t}\n\t\t\tv.push_back(m);\n\t\t}\n\t}\n\treturn v[0];\n}\nvoid I(V&v)\n{\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n}\nint main()\n{\n\tchar*p,c,s[8193];\n\tint n,i,t;\n\tfor(;;)\n\t{\n\t\tfor(x=i=0;i<5;++i)a[i].clear();\n\t\tu.clear();\n\t\tfor(;;)\n\t\t{\n\t\t\tif(scanf(\" %c%d\",&c,&i)<2)return 0;\n\t\t\tif(c=='R')break;\n\t\t\tn=c-'A';\n\t\t\twhile(i--)scanf(\"%d\",&t),a[n].push_back(t);\n\t\t\tI(a[n]);\n\t\t\tu.insert(u.end(),a[n].begin(),a[n].end());\n\t\t}\n\t\tI(u);\n\t\tscanf(\"%s\",s);\n\t\tvector<char>v,u;\n\t\tfor(p=s;*p;++p)\n\t\t{\n\t\t\tc=*p;\n\t\t\tif(isupper(c))\n\t\t\t{\n\t\t\t\t++x;\n\t\t\t\tv.push_back(c);\n\t\t\t\twhile(u.size()&&strchr(\"uidsc\",u.back()))v.push_back(u.back()),u.pop_back();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(c==')')\n\t\t\t\t{\n\t\t\t\t\twhile(u.back()!='(')\n\t\t\t\t\t{\n\t\t\t\t\t\tv.push_back(u.back());\n\t\t\t\t\t\tu.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tu.pop_back();\n\t\t\t\t\twhile(u.size()&&strchr(\"uidsc\",u.back()))v.push_back(u.back()),u.pop_back();\n\t\t\t\t}\n\t\t\t\telse u.push_back(c);\n\t\t\t}\n\t\t}\n\t\twhile(u.size())v.push_back(u.back()),u.pop_back();\n\t\tv.push_back(0);\t\n\t\tV r(F(&v[0]));\n\t\tif(r.empty())puts(\"NULL\");\n\t\telse for(i=0;i<r.size();++i)printf(\"%d%c\",r[i],i+1-r.size()?' ':'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\nusing namespace std;\n\nenum{\n  BINARY_OPERATOR = 0,\n  UNARY_OPERATOR  = 1,\n  VALUE           = 2\n};\n\nstruct Tree{\n  int type;\n\n  // Identifier, Value or Operator\n  string s;\n\n  struct Tree *left;\n  struct Tree *right;\n\n  Tree(int t, const string &v, Tree *l = NULL, Tree *r = NULL)\n    : type(t), s(v), left(l), right(r) {}\n\n  Tree(int t, char v, Tree *l = NULL, Tree *r = NULL)\n    : type(t), left(l), right(r) {\n    stringstream ss; ss << v;\n    s = ss.str();\n  }\n\n  ~Tree(){\n    delete left; delete right;\n  }\n\n  void debug(){\n    cout << \"(\";\n    switch(type){\n    case BINARY_OPERATOR:\n      left->debug();\n      cout << s;\n      right->debug();\n      break;\n    case UNARY_OPERATOR:\n      cout << s;\n      left->debug();\n      break;\n    case VALUE:\n      cout << s;\n      break;\n    }\n    cout << \")\";\n  }\n};\n\nstruct Parser{\n  const string bop1;\n  const string bop2;\n  const string uop;\n\n  Parser(const string &b1 = \"+-\",\n         const string &b2 = \"*/\",\n         const string &u = \"-\")\n    : bop1(b1), bop2(b2), uop(u) {}\n\n  typedef pair<Tree *, const char *> P;\n\n  P parseExpr(const char *p) const{\n    P r = parseTerm(p);\n    while( *r.second != '\\0' && bop1.find(*r.second) != string::npos ){\n      char op   = *r.second;\n      Tree *tmp = r.first;\n      r = parseTerm(r.second + 1);\n      r.first = new Tree(BINARY_OPERATOR, op, tmp, r.first);\n    }\n    return r;\n  }\n\n  P parseTerm(const char *p) const{\n    P r = parseFact(p);\n    while( *r.second != '\\0' && bop2.find(*r.second) != string::npos ){\n      char op   = *r.second;\n      Tree *tmp = r.first;\n      r = parseFact(r.second + 1);\n      r.first = new Tree(BINARY_OPERATOR, op, tmp, r.first);\n    }\n    return r;\n  }\n\n  P parseFact(const char *p) const{\n    if(uop.find(*p) != string::npos){\n      P r = parseFact(p + 1);\n      return P(new Tree(UNARY_OPERATOR, *p, r.first), r.second);\n    }else if(*p == '('){\n      P r = parseExpr(p + 1);\n      if(*r.second != ')') throw make_pair(\"fact1\", p);\n      return P(r.first, r.second + 1);\n    }else{\n      // identifier or value\n      stringstream ss;\n      while(*p != '\\0' &&\n            bop1.find(*p) == string::npos &&\n            bop2.find(*p) == string::npos &&\n            uop.find(*p)  == string::npos &&\n            *p != '(' && *p != ')'){\n        ss << *p++;\n      }\n      if(ss.str().size() == 0) throw make_pair(\"fact2\", p);\n      return P(new Tree(VALUE, ss.str()), p);\n    }\n  }\n\n  Tree *parse(const string &str) const{\n    return parseExpr(str.c_str()).first;\n  }\n};\n\nvoid print(set<int> s){\n  if(s.size()){\n    bool f = false;\n    FOR(it, s){\n      if(f) cout << \" \";\n      else f = true;\n      cout << *it;\n    }\n  }else{\n    cout << \"NULL\";\n  }\n  cout << endl;\n}\n\ntemplate<typename T>\nstruct Evaluater{\n  typedef T result;\n  map<string, set<int> > m;\n  set<int> u;\n\n  Evaluater(map<string, set<int> > _m) : m(_m){\n    FOR(it, m){\n      FOR(it2, it->second){\n        u.insert(*it2);\n      }\n    }\n  }\n\n  // Binary Operator\n  T operator()(const T &lhs, char op, const T &rhs) const{\n    set<int> ret;\n    switch(op){\n    case 'u':\n      ret = lhs;\n      FOR(it, rhs) ret.insert(*it);\n      break;\n    case 'i':\n      FOR(it, lhs){\n        if(rhs.count(*it))\n          ret.insert(*it);\n      }\n      break;\n    case 'd':\n      FOR(it, lhs){\n        if(rhs.count(*it) == 0)\n          ret.insert(*it);\n      }\n      break;\n    case 's':\n      FOR(it, lhs){\n        if(rhs.count(*it) == 0)\n          ret.insert(*it);\n      }\n      FOR(it, rhs){\n        if(lhs.count(*it) == 0)\n          ret.insert(*it);\n      }\n      break;\n    default:\n      throw \"Unknown Binary Operator\";\n    }\n\n    return ret;\n  }\n\n  // Unary Operator\n  T operator()(char op, const T &rhs) const{\n    set<int> ret = u;\n    FOR(it, rhs)\n      ret.erase(*it);\n    return ret;\n  }\n\n  // Value\n  T operator()(const string &str) const{\n    return m.at(str);\n  }\n};\n\ntemplate<typename E>\ntypename E::result eval(Tree *p, const E &e){\n  switch(p->type){\n  case BINARY_OPERATOR:\n    return e(eval(p->left, e), p->s[0], eval(p->right, e));\n  case UNARY_OPERATOR:\n    return e(p->s[0], eval(p->left, e));\n  case VALUE:\n    return e(p->s);\n  default:\n    throw \"Evaluater error\";\n  }\n}\n\n\nint main(){\n  Parser ps(\"uids\", \"\", \"c\");\n  string buff;\n  int n;\n\n  while(cin >> buff >> n){\n    map<string, set<int> > m;\n\n    do{\n      int v;\n      REP(j,n){\n        cin >> v; m[buff].insert(v);\n      }\n      cin >> buff >> n;\n    }while(buff != \"R\");\n\n    cin >> buff;\n\n    Tree *t = ps.parse(buff);\n    set<int> ans = eval(t, Evaluater<set<int> >(m));\n    print(ans);\n\n    delete t;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  set<int> value;\n  int p;\n  Result(set<int> v, int p) : value(v), p(p) {}\n};\n\nbool is_operator(char c){\n  string opes = \"uidsc\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nvoid operation(const set<int>& s1, const set<int>& s2, char ope, set<int>& res){\n  if(ope == 'u'){\n    FORIT(it, s1) res.insert(*it);\n    FORIT(it, s2) res.insert(*it);\n  }else if(ope == 'i'){\n    FORIT(it, s1) if(s2.count(*it)) res.insert(*it);\n  }else if(ope == 'd'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n  }else if(ope == 's'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n    FORIT(it, s2) if(!s1.count(*it)) res.insert(*it);\n  }else{\n    assert(false);\n  }\n}\nResult expr(const string& s, int p, map<char, set<int> >& vars);\nResult factor(const string& s, int p, map<char, set<int> >& vars);\nResult expr(const string& s, int p, map<char, set<int> >& vars){\n  Result r = factor(s, p, vars);\n  while(is_operator(s[r.p])){\n    Result r_ = factor(s, r.p + 1, vars);\n    set<int> newset;\n    operation(r.value, r_.value, s[r.p], newset);\n    r.value = newset;\n    r.p = r_.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p, map<char, set<int> >& vars){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1, vars);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(s[p] == 'c'){\n    Result r = factor(s, p + 1, vars);\n    set<int> v;\n    FORIT(it, vars['U'])if(!r.value.count(*it)){\n      v.insert(*it);\n    }\n    r.value = v;\n    return r;\n  }else{\n    assert(vars.count(s[p]));\n    set<int> v = vars[s[p++]];\n    return Result(v, p);\n  }\n}\n\nint main(){\n  while(true){\n    char v; int l;\n    map<char, set<int> > vars;\n    while(cin >> v >> l){\n      if(v == 'R'){\n        break;\n      }\n      set<int> s;\n      REP(i, l) {\n        int t; cin>>t;\n        s.insert(t);\n        vars['U'].insert(t);\n      }\n      vars[v] = s;\n    }\n    if(cin.eof()) return 0;\n    string s;\n    cin >> s;\n    set<int> res = expr(s, 0, vars).value;\n    assert(expr(s, 0, vars).p == s.size());\n    FORIT(it, res){\n      if(it != res.begin()) cout << \" \";\n      cout << *it;\n    }\n    if(res.empty()) cout << \"NULL\";\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>10000) exit(1);\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nset<int> fnd(set<int> c,set<int> d);\nset<int> fnc(set<int> c);\nset<int> fn(string s);\nset<int> a[5],b;\nset<int> fnu(set<int> c,set<int> d){\n  set<int> e;\n  set<int>::iterator it;\n  for(it=c.begin();it!=c.end();it++)\n    e.insert(*it);\n  for(it=d.begin();it!=d.end();it++)\n    e.insert(*it);\n  return e;\n}\nset<int> fni(set<int> c,set<int> d){\n  set<int> e;\n  set<int>::iterator it;\n  for(it=c.begin();it!=c.end();it++){\n    if(d.count(*it))\n      e.insert(*it);\n  }\n  return e;\n}\nset<int> fns(set<int> c,set<int> d){\n  return fnu(fnd(c,d),fnd(d,c));\n}\nset<int> fnd(set<int> c,set<int> d){\n  return fni(c,fnc(d));\n}\nset<int> fnc(set<int> c){\n  set<int> d;\n  set<int>::iterator it;\n  for(it=b.begin();it!=b.end();it++){\n    if(c.count(*it)==0)\n      d.insert(*it);\n  }\n  return d;\n}\npair<set<int>,int> fm(string s){\n  int j,k,l;\n  if(0){\n  }else if(s[0]=='('){\n    k=1;\n    for(j=1;k;j++){\n      if(0){\n      }else if(s[j]=='('){\n\tk++;\n      }else if(s[j]==')'){\n\tk--;\n      }\n    }\n    return make_pair(fn(s.substr(1,j-2)),j);\n  }else if(s[0]=='c'){\n    for(l=1;s[l]=='c';l++);\n    if(s[l]=='('){\n      k=1;\n      for(j=l+1;k;j++){\n\tif(0){\n\t}else if(s[j]=='('){\n\t  k++;\n\t}else if(s[j]==')'){\n\t  k--;\n\t}\n      }\n      if(l%2)\n\treturn make_pair(fnc(fn(s.substr(l+1,j-l-2))),j);\n      else\n\treturn make_pair(fn(s.substr(l+1,j-l-2)),j);\n    }else{\n      if(l%2)\n\treturn make_pair(fnc(a[s[l]-'A']),l+1);\n      else\n\treturn make_pair(a[s[l]-'A'],l+1);\n    }\n  }else{\n    return make_pair(a[s[0]-'A'],1);\n  }\n}\nset<int> fn(string s){\n  int i;\n  set<int> c;\n  pair<set<int>,int> p=fm(s);\n  c=p.first;\n  int ln=s.length();\n  for(i=p.second;i<ln;i+=p.second){\n    p=fm(s.substr(i+1));\n    if(0){\n    }else if(s[i]=='u'){\n      c=fnu(c,p.first);\n    }else if(s[i]=='i'){\n      c=fni(c,p.first);\n    }else if(s[i]=='d'){\n      c=fnd(c,p.first);\n    }else if(s[i]=='s'){\n      c=fns(c,p.first);\n    }\n  }\n  return c;\n}\nint main(){\n  int i;\n  char s;\n  int n;\n  while(cin>>s>>n){\n    for(i=0;i<5;i++)\n      a[i].clear();\n    b.clear();\n    while(s!='R'){\n      for(i=0;i<n;i++){\n\tint p;\n\tcin>>p;\n\ta[s-'A'].insert(p);\n\tb.insert(p);\n      }\n      cin>>s>>n;\n    }\n    string s;\n    cin>>s;\n    set<int> c=fn(s);\n    if(c.empty()==0){\n      set<int>::iterator it;\n      cout<<*c.begin();\n      for(it=c.begin(),it++;it!=c.end();it++)\n\tcout<<\" \"<<*it;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 501;\n\nchar A[5][MAXN];\nint pos;\nstring line;\n\nvector<char> exp();\nvector<char> fact();\n\nvector<char> exp() {\n  vector<char> res = fact();\n  while(1) {\n    if(line[pos] == 'u') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] || x[i]);\n      }\n    } else if(line[pos] == 'i') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && x[i]);\n      }\n    } else if(line[pos] == 'd') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && !x[i]);\n      }\n    } else if(line[pos] == 's') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = ((res[i] && !x[i]) || (x[i] && !res[i]));\n      }\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nvector<char> fact() {\n  vector<char> res;\n  if(line[pos] == 'c') {\n    ++pos;\n    res = fact();\n    for(int i = 0; i < res.size(); ++i) {\n      res[i] = 1-res[i];\n    }\n  } else if(isupper(line[pos])) {\n    char c = line[pos];\n    ++pos;\n    res = vector<char>(A[c-'A'], A[c-'A']+MAXN);\n  } else if(line[pos] == '(') {\n    ++pos;\n    res = exp();\n    ++pos;\n  }\n  return res;\n}\n\nmap<int,int> id, rid;\nint getId(int n) {\n  if(!id.count(n)) {\n    id[n] = id.size()-1;\n    rid[id[n]] = n;\n  }\n  return id[n];\n}\n\nint main() {\n  while(1) {\n    bool run = true;\n    fill(A[0], A[5], false);\n    id.clear();\n    rid.clear();\n    while(1) {\n      char c;\n      int n;\n      if(!(cin >> c >> n)) {\n\trun = false;\n\tbreak;\n      }\n      if(c == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i) {\n\tint a;\n\tcin >> a;\n\ta = getId(a);\n\tA[c-'A'][a] = true;\n      }\n    }\n    if(!run) break;\n    string s;\n    cin >> s;\n    line = s;\n    pos = 0;\n    vector<char> res = exp();\n    vector<int> ans;\n    for(int i = 0, cnt = 0; i < res.size(); ++i) {\n      if(rid.count(i) && res[i]) {\n\tans.push_back(rid[i]);\n      }\n    }\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < ans.size(); ++i) {\n      if(i) cout << \" \";\n      cout << ans[i];\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>18) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = dif(sets['U'], v);\n    }\n    else {\n        ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\nset<int> U;\nmap<char, set<int> > SET;\n \nset<int> solve(string s) {\n  // cout << s << endl;\n  int nest = 0;\n  set<int> res;\n  REP(i, s.size()) {\n    if (s[i]=='(')\n      nest++;\n    else if (s[i]==')')\n      nest--;\n    else if (nest == 0) {\n      if (s[i]=='u' || s[i]=='i' || s[i]=='d' || s[i]=='s') {\n        set<int> A = solve(s.substr(0, i));\n        set<int> B = solve(s.substr(i+1));\n\n        if (s[i]=='u') {\n          res = A;\n          res.insert(ALL(B));\n        } else if (s[i]=='i') {\n          FOR(it, A) {\n            if (B.find(*it)!=B.end()) {\n              res.insert(*it);\n            }\n          }\n        } else if (s[i]=='d') {\n          FOR(it, A) {\n            if (B.find(*it)==B.end()) {\n              res.insert(*it);\n            }\n          }\n        } else if (s[i]=='s') {\n          FOR(it, A) {\n            if (B.find(*it)==B.end()) {\n              res.insert(*it);\n            }\n          }\n          FOR(it, B) {\n            if (A.find(*it)==A.end()) {\n              res.insert(*it);\n            }\n          }\n        }\n        return res;\n      }\n    }\n  }\n  \n  if (s[0] == '(') {\n    return solve(s.substr(1, s.size()-2));\n  } else if (s[0] == 'c'){\n    set<int> A = solve(s.substr(1));\n    FOR(it, U) {\n      if (A.find(*it) == A.end())\n        res.insert(*it);\n    }\n    return res;\n  }\n  return SET[s[0]];\n}\n\nint main() {\n  char c;\n  int m;\n  while(cin >> c>> m) {\n    U.clear();\n    SET.clear();\n    while(c!='R') {\n      REP(i, m) {\n        int a;\n        cin >> a;\n        SET[c].insert(a);\n        U.insert(a);\n      }\n      cin >> c >> m;\n    }\n    string s;\n    cin >> s;\n\n    set<int> res = solve(s);\n    int hoge = 0;\n    FOR(it, res) {\n      if (hoge)\n        cout << \" \";\n      else hoge = 1;\n      cout << *it;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str[0]=='c'){\n\t\treturn Complement(analysis(str.substr(1)),sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é.\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn set<int>();\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\t\tsets['U'];\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef map<char, set<int> > mapset;\n\nset<int> atom(string&, mapset&, int&);\nset<int> block(string&, mapset&, int&);\nset<int> unite(set<int>&, set<int>&);\nset<int> intersection(set<int>&, set<int>&);\nset<int> difference(set<int>&, set<int>&);\nset<int> symmetric_difference(set<int>&, set<int>&);\nset<int> parse(string&, mapset&, int&);\nset<int> complement(mapset&, set<int>&);\n\nset<int> atom(string &expr, mapset &sets, int &k) {\n    return sets[expr[k++]];\n}\n\nset<int> block(string &expr, mapset &sets, int &k) {\n    if (expr[k] == '(') {\n        k ++;\n        return parse(expr, sets, k++);\n    } else if (expr[k] == 'c') {\n        k ++;\n        return complement(sets, block(expr, sets, k));\n    }\n    return atom(expr, sets, k);\n}\n\nset<int> unite(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.insert(*it);\n    }\n    return ret;\n}\n\nset<int> intersection(set<int> &s1, set<int> &s2) {\n    set<int> ret;\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        if (s1.find(*it) != s1.end()) {\n            ret.insert(*it);\n        }\n    }\n    return ret;\n}\n\nset<int> difference(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.erase(*it);\n    }\n    return ret;\n}\n\nset<int> symmetric_difference(set<int> &s1, set<int> &s2) {\n    return unite(difference(s1, s2), difference(s2, s1));\n}\n\nset<int> complement(mapset &sets, set<int> &s1) {\n    set<int> U;\n    for (mapset::iterator it=sets.begin(); it!=sets.end(); ++it) {\n        U = unite(U, it->second);\n    }\n    return difference(U, s1);\n}\n\nset<int> parse(string &expr, mapset &sets, int &k) {\n    set<int> v1 = block(expr, sets, k);\n    while (k < (int)expr.size() && expr[k] != ')') {\n        char op = expr[k++];\n        set<int> v2 = block(expr, sets, k);\n        if (op == 'u') {\n            v1 = unite(v1, v2);\n        } else if (op == 'i') {\n            v1 = intersection(v1, v2);\n        } else if (op == 'd') {\n            v1 = difference(v1, v2);\n        } else if (op == 's') {\n            v1 = symmetric_difference(v1, v2);\n        }\n    }\n    return v1;\n}\n\nvoid solve(string &expr, mapset &sets) {\n    int k = 0;\n    set<int> st = parse(expr, sets, k);\n    if (st.empty()) {\n        cout << \"NULL\" << endl;\n        return ;\n    }\n    for (set<int>::iterator it=st.begin(); it!=st.end(); ++it) {\n        cout << (it == st.begin() ? \"\" : \" \") << *it;\n    }\n    cout << endl;\n}\n\nint main() {\n    char c; int k;\n    map<char, set<int> > sets;\n    while (cin >> c >> k) {\n        if (c != 'R') {\n            set<int> st; int t;\n            for (int i=0; i<k; ++i) {\n                cin >> t;\n                st.insert(t);\n            }\n            sets[c] = st;\n        } else {\n            string expr;\n            cin >> expr;\n            solve(expr, sets);\n\n            sets.clear();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  set<int> value;\n  int p;\n  Result(set<int> v, int p) : value(v), p(p) {}\n};\n\nbool is_operator(char c){\n  string opes = \"uidsc\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nset<int> operation(set<int>& s1, set<int>& s2, char ope){\n  set<int> res;\n  if(ope == 'u'){\n    FORIT(it, s1) res.insert(*it);\n    FORIT(it, s2) res.insert(*it);\n  }else if(ope == 'i'){\n    FORIT(it, s1) if(s2.count(*it)) res.insert(*it);\n  }else if(ope == 'd'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n  }else if(ope == 's'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n    FORIT(it, s2) if(!s1.count(*it)) res.insert(*it);\n  }else{\n    assert(false);\n  }\n  return res;\n}\nResult expr(const string& s, int p, map<char, set<int> >& vars);\nResult factor(const string& s, int p, map<char, set<int> >& vars);\nResult expr(const string& s, int p, map<char, set<int> >& vars){\n  Result r = factor(s, p, vars);\n  while(is_operator(s[r.p])){\n    Result r_ = factor(s, r.p + 1, vars);\n    r.value = operation(r.value, r_.value, s[r.p]);\n    r.p = r_.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p, map<char, set<int> >& vars){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1, vars);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(s[p] == 'c'){\n    Result r = factor(s, p + 1, vars);\n    set<int> v;\n    FORIT(it, vars['U'])if(!r.value.count(*it)){\n      v.insert(*it);\n    }\n    r.value = v;\n    return r;\n  }else{\n    set<int> v = vars[s[p++]];\n    return Result(v, p);\n  }\n}\n\nint main(){\n  while(true){\n    char v; int l;\n    map<char, set<int> > vars;\n    while(cin >> v >> l){\n      if(v == 'R'){\n        break;\n      }\n      set<int> s;\n      REP(i, l) {\n        int t; cin>>t;\n        s.insert(t);\n        vars['U'].insert(t);\n      }\n      vars[v] = s;\n    }\n    if(cin.eof()) return 0;\n    string s;\n    cin >> s;\n    set<int> res = expr(s, 0, vars).value;\n    FORIT(it, res){\n      if(it != res.begin()) cout << \" \";\n      cout << *it;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            if(c == 'R' && n == 0) break;\n            f = true;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n\n        if(not f) break;\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << '\\0' << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nvi S[6];\nstring expr;\n\nvi calc(vi a,vi b,char op)\n{\n\tvi ret(a.size()+b.size());\n\tvi::iterator it;\n\tswitch(op)\n\t{\n\tcase 'u':\n\t\tit=set_union(all(a),all(b),ret.begin()); break;\n\tcase 'i':\n\t\tit=set_intersection(all(a),all(b),ret.begin()); break;\n\tcase 'd':\n\t\tit=set_difference(all(a),all(b),ret.begin()); break;\n\tcase 's':\n\t\tit=set_symmetric_difference(all(a),all(b),ret.begin()); break;\n\t}\n\tret.erase(it,ret.end());\n\treturn ret;\n}\n\nvi eval(int s,int t)\n{\n\tint d=0,p=t-1; char c;\n\tfor(;p>s;p--)\n\t{\n\t\tc=expr[p];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(p==s)\n\t{\n\t\tif(expr[s]=='(')return eval(s+1,t-1);\n\t\tif(expr[s]=='c')return calc(S[5],eval(s+1,t),'d');\n\t\treturn S[expr[s]-'A'];\n\t}\n\treturn calc(eval(s,p),eval(p+1,t),c);\n}\n\nint main()\n{\n\tchar c; int n;\n\twhile(cin>>c>>n)\n\t{\n\t\trep(i,5)S[i].clear();\n\t\tdo\n\t\t{\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tint t; cin>>t;\n\t\t\t\tS[c-'A'].pb(t);\n\t\t\t\tS[5].pb(t);\n\t\t\t}\n\t\t}while(cin>>c>>n,c!='R');\n\t\t\n\t\trep(i,6)\n\t\t\tsort(all(S[i])),S[i].erase(unique(all(S[i])),S[i].end());\n\t\tcin>>expr;\n\t\t\n\t\tvi ans=eval(0,expr.size());\n\t\trp(i,ans)cout<<ans[i]<<(i==ans.size()-1?\"\\n\":\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n#include <string>\n\nusing namespace std;\n\nmap<char, vector<int> > mpp;\nstring str;\nint p;\n\nbool check()\n{\n  return (str[p] == 'u' || str[p] == 'i' || str[p] == 'd' || str[p] == 's');\n}\n\nvector<int> func();\nvector<int> elm()\n{\n  vector<int> res;\n  if(str[p] == '('){\n    ++p;\n    res = func();\n  } else if(str[p] == 'c'){\n    ++p;\n    if(str[p] == '('){\n      ++p;\n      res = func();\n    } else {\n      res = mpp[str[p]];\n    }\n    vector<int> vec(res.size()+mpp['U'].size());\n    vector<int>::iterator it = set_difference(mpp['U'].begin(), mpp['U'].end(), res.begin(), res.end(), vec.begin());\n    vec.resize(it-vec.begin());\n    res = vec;\n  } else {\n    res = mpp[str[p]];\n  }\n  ++p;\n\n  return res;\n}\n\nvector<int> func()\n{\n  char ch;\n  vector<int> res = elm();\n\n  while(p < str.size() && check()){\n    ch = str[p++];\n    vector<int> vec(res.size()+mpp[str[p]].size());\n    vector<int> vec2 = elm();\n    vector<int>::iterator it;\n\n    if(ch == 'u'){\n      it = set_union(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    } else if(ch == 'i'){\n      it = set_intersection(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    } else if(ch == 'd'){\n      it = set_difference(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    } else {\n      it = set_symmetric_difference(res.begin(), res.end(), vec2.begin(), vec2.end(), vec.begin());\n    }\n\n    vec.resize(it-vec.begin());\n    res = vec;\n  }\n\n  return res;\n}\n\nint main()\n{\n  char ch;\n  int n, t;\n  set<int> stt;\n  vector<int> vec;\n\n  while(1){\n    while(1){\n      if(!(cin>>ch>>n)) return 0;\n      if(ch == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i){\n\tcin >> t;\n\tvec.push_back(t);\n\tstt.insert(t);\n      }\n      sort(vec.begin(), vec.end());\n      mpp[ch] = vec;\n      vec.clear();\n    }\n    for(set<int>::iterator it = stt.begin(); it != stt.end(); ++it) \n      vec.push_back(*it);\n    mpp['U'] = vec;\n    cin >> str;\n\n    p = 0;\n    vec = func();\n    if(vec.size() > 0){\n      cout << vec[0];\n      for(int i = 1; i < vec.size(); ++i) cout << \" \" << vec[i];\n      cout << endl;\n    } else {\n      cout << \"NULL\" << endl;\n    }\n\n    mpp.clear();\n    stt.clear();\n    vec.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n#define EACH(it,n) for(S::iterator it = (n).begin(); it != (n).end() ; ++it)\ntypedef set<int> S;\nmap< string , S > data;\n\n\nstring expr;\n\nS uni(S a,S b){\n\tS ans;\n\tEACH(it,a) ans.insert(*it);\n\tEACH(it,b) ans.insert(*it);\n\treturn ans;\n}\nS inter(S a,S b){\n\tS ans;\n\tEACH(it,a) if(b.count(*it))ans.insert(*it);\n\treturn ans;\n}\nS diff(S a,S b){\n\tS ans;\n\tEACH(it,a) if(!b.count(*it))ans.insert(*it);\n\treturn ans;\n} \nS sym(S a,S b){\n\treturn uni(diff(a,b),diff(b,a));\n}\nS comp(S a){\n\tS ans;\n\tEACH(it,data[\"U\"]) if(!a.count(*it)) ans.insert(*it);\n\treturn ans;\n}\n\n\nint pos = 0;\n\nvoid view(S s){\n\tif(s.size()==0) cout << endl;\n\tEACH(it,s){\n\t\tcout << *it;\n\t\tS::iterator it2 = it;\n\t\tit2++;\n\t\tif( it2 == s.end()) cout << endl;\n\t\telse cout << \" \";\n\t}\n}\nset<int> f(){\n\tstring table = \"uids\";\n\tset<int> le,ri;\n\twhile(pos < expr.size()){\n\t\tint jump = 1;\n\t\tif(expr[pos] == ')'){\n\t\t\treturn le;\n\t\t}else if(expr[pos] == '('){\n\t\t\tpos++;\n\t\t\tle = f();\n\t\t}else if(expr[pos] == 'c'){\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos++;\n\t\t\t\tle = comp(f());\n\t\t\t}else{\n\t\t\t\tjump ++;\n\t\t\t\tle = comp(data[string(1,expr[pos+1])]);\n\t\t\t}\n\t\t}else if(~table.find(expr[pos])){\n\t\t\tchar cc = expr[pos];\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos++;\n\t\t\t\tri = f();\n\t\t\t}else{\n\t\t\t\tjump++;\n\t\t\t\tri = data[string(1,expr[pos+1])];\n\t\t\t}\n\t\t\tif(cc == 'u') le = uni(le,ri);\n\t\t\tif(cc == 'i') le = inter(le,ri);\n\t\t\tif(cc == 'd') le = diff(le,ri);\n\t\t\tif(cc == 's') le = sym(le,ri);\n\t\t}else{\n\t\t\tle = data[string(1,expr[pos])];\n\t\t}\n\t\tpos += jump;\n\t}\n\treturn le;\n}\nint main(){\n\twhile(1){\n\t\tstring a; int b;\n\t\tif(cin >> a >> b){\n\t\t\tif(a == \"R\" && b == 0){\n\t\t\t\tcin >> expr;\n\t\t\t\tpos = 0;\n\t\t\t\tset<int> res = f();\n\t\t\t\tview(res);\n\t\t\t\tdata.clear();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0 ; i < b ; i++){\n\t\t\t\t\tint t; cin >> t;\n\t\t\t\t\tdata[a].insert(t);\n\t\t\t\t\tdata[\"U\"].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}else return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> U;//mapを使った方が楽。\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = dif(U, v);\n    }\n    else {\n        ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    u.insert(input);\n                }\n            }\n        }\n\n        for(pair<char,vector<int>> v : sets){\n            sort(v.second.begin(), v.second.end());\n            cout << v.first << \" : \";\n            for(int num : v.second){\n                cout << num << \" \";\n            }\n            cout << endl;\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[1000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 2)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tif(check[A[i]] == false){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 1)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tif(check[U[i]] == false){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tcheck[V[i][k]] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])U.push_back(i);\n\t}\n}\n\n\nvector<int> recursive(int left,int right){\n\n\t/*printf(\"\\n\\nleft:%d right:%d\\n\",left,right);\n\tfor(int i = left; i <= right; i++){\n\t\tprintf(\"%c\",equation[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\t\t\t//printf(\"???????????????\\n\");\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\t//printf(\"left??±??????()\\n\");\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t\t}*/\n\t\t\t}else{\n\n\t\t\t\t//printf(\"right??±??????()\\n\");\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_right.size(); k++){\n\t\t\t\t\tprintf(\"calc_right[%d]:%d\\n\",k,calc_right[k]);\n\t\t\t\t}*/\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\t//printf(\"?????????:%c\\n\",equation[index]);\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\t/*printf(\"??????:%c\\n\",equation[index]);\n\t\t\tfor(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"??? calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\t//printf(\"%d??¨intersect\\n\",loc[equation[index]-'A']);\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\t/*for(int i = 0; i < U.size(); i++){\n\t\tprintf(\"U[%d]:%d\\n\",i,U[i]);\n\t}*/\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(~scanf(\"%s\",buf)){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\n// <set> ::= A | B | C | D | E\nmap<char, vector<int>> name2set;\n// <op> ::= u | i | d | s\nconst string ops = \"uids\";\n\nvoid unique(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n}\n\nvector<int> set_oparate(vector<int> a, vector<int> b, char op) {\n#define all(v) v.begin(), v.end()\n    vector<int> ret(a.size() + b.size());\n    vector<int>::iterator it;\n    switch (op) {\n    case 'u':\n        it = set_union(all(a), all(b), ret.begin());\n        break;\n    case 'i':\n        it = set_intersection(all(a), all(b), ret.begin());\n        break;\n    case 'd':\n        it = set_difference(all(a), all(b), ret.begin());\n        break;\n    case 's':\n        it = set_symmetric_difference(all(a), all(b), ret.begin());\n        break;\n    }\n    ret.erase(it, ret.end());\n    return ret;\n#undef all\n}\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return expr(begin);\n    }\n\n    // <expr> ::= <term> <op> <term>\n    // <op> ::= u | i | d | s\n    T expr(State &begin) {\n        T ret = term(begin);\n        for (;;) {\n            if (ops.find(*begin) != string::npos) {\n                char op = *begin;\n                begin++;\n                ret = set_oparate(ret, term(begin), op);\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\n\n    // <term> ::= c <factor> | <factor>\n    T term(State &begin) {\n        if (*begin == 'c') {\n            begin++;\n            return set_oparate(name2set['U'], factor(begin), 'd');\n        } else {\n            return factor(begin);\n        }\n    }\n\n    // <factor> ::= ( <expr> ) | <set>\n    T factor(State &begin) {\n        if (*begin == '(') {\n            begin++;    // skip '('\n            T ret = expr(begin);\n            begin++;    // skip ')'\n            return ret;\n        } else {\n            return name2set[*begin++];\n        }\n    }\n};\n\nint main() {\n    char name; int num;\n    while (cin >> name >> num) {\n        if (name == 'R') {\n            unique(name2set['U']);\n            for (auto &m : name2set) sort(m.second.begin(), m.second.end());\n            string S; cin >> S;\n            Parser<vector<int>> ps;\n            vector<int> res = ps.solve(S);\n            if (res.empty()) {\n                cout << \"NULL\" << endl;\n            } else {\n                for (int i = 0; i < res.size(); i++) {\n                    cout << res[i] << \" \\n\"[i == res.size() - 1];\n                }\n            }\n            name2set.clear();\n        } else {\n            for (int i = 0; i < num; i++) {\n                int member; cin >> member;\n                name2set[name].emplace_back(member);\n                name2set['U'].emplace_back(member);\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n \nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> elements;\n \n    Parse(string::iterator it, map<char, set<int>> elements) :\n        it(it), elements(elements) {}\n     \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n     \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n \n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n     \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n \n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n \n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n \n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n \nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> elements = {};\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n \n        elements['U'] = U;\n         \n        string str;\n        cin >> str;\n         \n        Parse parse(str.begin(), elements);\n        set<int> res = parse.expr();\n         \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint idx;\nstring s;\nvector<int> u;\nvector<int> v[128];\n\nvector<int> op(char ch,vector<int> a,vector<int> b=vector<int>()){\n\tvector<int> res(10000);\n\tvector<int>::iterator it;\n\n\tif(ch == 'u') it = set_union(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'i') it = set_intersection(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'd') it = set_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 's') it = set_symmetric_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'c') it = set_difference(u.begin(),u.end(),a.begin(),a.end(),res.begin());\n\n\tres.resize(it-res.begin());\n\treturn res;\n}\n\nvector<int> solve(void){\n\tbool flg = false;\n\tif(s[idx] == 'c'){\n\t\tflg = true;\n\t\tidx++;\n\t}\n\n\tvector<int> res;\n\tif(s[idx] == '('){\n\t\tidx++;\n\t\tres = solve();\n\t}\n\telse{\n\t\tres = v[s[idx++]];\n\t}\n\n\tif(flg) res = op('c',res);\n\n\twhile(idx < s.length() && s[idx] != ')'){\n\t\tchar ch = s[idx++];\n\n\t\tflg = false;\n\t\tif(s[idx] == 'c'){\n\t\t\tflg = true;\n\t\t\tidx++;\n\t\t}\n\n\t\tvector<int> tmp;\n\t\tif(s[idx] == '('){\n\t\t\tidx++;\n\t\t\ttmp = solve();\n\t\t}\n\t\telse{\n\t\t\ttmp = v[s[idx++]];\n\t\t}\n\n\t\tif(flg) tmp = op('c',tmp);\n\t\tres = op(ch,res,tmp);\n\t}\n\tidx++;\n\treturn res;\n}\n\nint main(void){\n\t/*\n\tvector<int> a;\n\ta.push_back(2);\n\ta.push_back(4);\n\ta.push_back(8);\n\n\tvector<int> b;\n\tb.push_back(2);\n\tb.push_back(4);\n\tb.push_back(8);\n\n\tvector<int> c = op('u',a,b);\n\tfor(int i=0;i<c.size();i++){\n\t\tcout<<c[i]<<\",\";\n\t}\n\tcout<<endl;\n\t*/\n\twhile(1){\n\t\tu.clear();\n\t\tfor(int i=0;i<5;i++) v['A'+i].clear();\n\n\t\twhile(1){\n\t\t\tchar name;\n\t\t\tint n;\n\t\t\tif(!(cin>>name>>n)) return 0;\n\t\t\tif(name == 'R') break;\n\n\t\t\tv[name] = vector<int>(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcin>>v[name][i];\n\t\t\t}\n\t\t\tsort(v[name].begin(),v[name].end());\n\t\t\tu = op('u',v[name],u);\n\t\t}\n\n\t\tcin>>s;\n\t\tidx = 0;\n\n\t\tvector<int> ans = solve();\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tcout<<ans[i]<<\" \";\n\t\t}\n\t\tcout<<ans[ans.size()-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        //return (c ? C(ret) : ret);\n        return ret;\n    } else {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        begin++;\n    }\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            if(c == 'R' && n == 0) break;\n            f = true;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n\n        if(not f) break;\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << '\\0' << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = term(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(my_left, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(my_left, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(my_left, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(my_left, term(begin));\n        }\n        else{\n            break;\n        }\n   }\n   return ret;\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n\n    /*\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = D(sets['U'], v);\n    }\n    else {\n        ret = factor(begin);\n    }\n\n    return ret;\n    */\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        char se;\n        int n;\n\n        while (cin >> se >> n) {\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        if(sets['U'].size() == 0){\n            break;\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  return factor(str,numbers,U,pos);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(1){\n    if(pos >= str.size()){\n      break;\n    }\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else{\n      break;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = equation(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    char alphabet[2];\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(~scanf(\"%s %d\",alphabet,&num_of_elements)){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        goto skip;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        scanf(\"%d\",&num);\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n  skip:;\n    string text;\n    cin >> text;\n    P r = equation(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n        printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string s;\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele) :\n        s(s), ele(ele) {\n        it = s.begin();\n    }\n    \n    set<int> fact()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n\n    set<int> term()\n    {\n        set<int> a;\n        if(*it == 'c'){\n            ++it;\n            a = fact();\n            a = complement(a);\n        }else{\n            a = fact();\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            if(*it == 'd'){\n                ++it;\n                b = term();\n                a = difference(a, b);\n            }else if(*it == 'i'){\n                ++it;\n                b = term();\n                a = intersection(a, b);\n            }else if(*it == 's'){\n                ++it;\n                b = term();\n                a = sym_difference(a, b);\n            }else if(*it == 'u'){\n                ++it;\n                b = term();\n                a = union_(a, b);\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    bool eof_ = 0;\n    while(1)\n    {\n        map<char, set<int>> ele;\n        while(1)\n        {\n            if(cin >> ch >> N){\n                if(ch == 'R') break;\n                set<int> st;\n                for(int i = 0 ; i < N ; i++){\n                    cin >> x;\n                    st.insert(x);\n                }\n                    \n                ele[ch] = st;\n                for(auto x : st){\n                    ele['U'].insert(x);\n                }\n            }else{\n                eof_ = 1;\n                break;\n            }\n        }\n        if(eof_) break;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\ntypedef vector<int> vec;\n\nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  int a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n    if(ans.size()>0){\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <string>\n#include <stack>\nusing namespace std;\n\ntemplate <class Set>\nvoid print_set(Set& setA)\n{\n  typename Set::iterator it;\n  int n = 0;\n  if (setA.empty()) { cout << \"NULL\" << endl; return; }\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    n++;\n    if (n != setA.size()) printf(\"%d \", *it);\n    else printf(\"%d\\n\", *it);\n  }\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet union_set(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.insert(*it);\n  }\n  return res;\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet intersection_set(Set& setA, Set& setB)\n{\n  Set res;\n  typename Set::iterator it;\n\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    if (setA.find(*it) != setA.end())\n    {\n      res.insert(*it);\n    }\n  }\n  return res;\n}\n\n\n// ?£???????????¨????\ntemplate <class Set>\nSet complement(Set& setA, Set& U)\n{\n  Set res(U);\n  typename Set::iterator it;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A-B\ntemplate <class Set>\nSet difference(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A . B\ntemplate <class Set>\nSet symmetric_difference(Set& setA, Set& setB)\n{\n  Set s1 = difference(setA, setB);\n  Set s2 = difference(setB, setA);\n  return union_set(s1, s2);\n}\n\nstring rev_polish_notation(string& exp)\n{\n  stack<char> stk;\n  string rexp;\n  string::iterator it;\n\n  for (it = exp.begin(); it != exp.end(); ++it)\n  {\n    if (*it == '(')\n    {\n      stk.push(*it);\n    }\n    else if (*it == ')')\n    {\n      while (stk.top() != '(')\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.pop();                // top???'('???????????????\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      while ((!stk.empty()) && (stk.top() != '('))\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.push(*it);\n    }\n    else if (*it == 'c')\n    {\n      stk.push(*it);\n    }\n    else if ((*it == 'A') || (*it == 'B') || (*it == 'C') || (*it == 'D') || (*it == 'E'))\n    {\n      rexp = rexp + (*it);\n    }\n  }\n\n  while (!stk.empty())\n  {\n    char tkn = stk.top();\n    rexp = rexp + tkn;\n    stk.pop();\n  }\n\n  return rexp;\n}\n\n\ntemplate <class Set>\nSet set_operation(string& exp, Set& A, Set& B, Set& C, Set& D, Set& E, Set& U)\n{\n  Set S;\n  string rexp = rev_polish_notation(exp); // ???????????????????¨????\n  stack<Set> stk;\n\n  string::iterator it;\n  for (it = rexp.begin(); it != rexp.end(); ++it)\n  {\n    if (*it == 'A') { stk.push(A); }\n    else if (*it == 'B') { stk.push(B); }\n    else if (*it == 'C') { stk.push(C); }\n    else if (*it == 'D') { stk.push(D); }\n    else if (*it == 'E') { stk.push(E); }\n    else if (*it == 'c')\n    {\n      Set s = stk.top();\n      stk.pop();\n      stk.push(complement(s, U));\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      Set s1 = stk.top();\n      stk.pop();\n      Set s2 = stk.top();\n      stk.pop();\n      Set ans;\n\n      switch (*it)\n      {\n      case 'u': stk.push(union_set(s1, s2)); break;\n      case 'i': stk.push(intersection_set(s1, s2)); break;\n      case 'd': stk.push(difference(s2, s1)); break; // ????????????????????¨???\n      case 's': stk.push(symmetric_difference(s1, s2)); break;\n      }\n    }\n  }\n  return stk.top();\n}\n\n\nint main() {\n  set<int> A, B, C, D, E, U;\n  char name;\n  int num;\n  int e;\n  string exp;\n\n  while (cin >> name >> num)\n  {\n    switch (name)\n    {\n    case 'A':\n      for (int i=0;i<num;i++) { cin >> e; A.insert(e); U.insert(e); }\n      break;\n    case 'B':\n      for (int i=0;i<num;i++) { cin >> e; B.insert(e); U.insert(e); }\n      break;\n    case 'C':\n      for (int i=0;i<num;i++) { cin >> e; C.insert(e); U.insert(e); }\n      break;\n    case 'D':\n      for (int i=0;i<num;i++) { cin >> e; D.insert(e); U.insert(e); }\n      break;\n    case 'E':\n      for (int i=0;i<num;i++) { cin >> e; E.insert(e); U.insert(e); }\n      break;\n    case 'R':\n      cin >> exp;\n      set<int> res = set_operation(exp, A, B, C, D, E, U);\n      print_set(res);\n      // ??????????????????????¶???????\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      U.clear();\n      break;\n    }\n    if (cin.eof()) break;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\ntypedef set<int>::iterator si;\n\nconst int N = 26;\n\nset<int> s[N];\nstring str;\nint pos;\n\nset<int> exp();\n\nset<int> val(){\n\tset<int> res;\n\tif(str[pos] == 'c'){\n\t\t++pos;\n\t\tset<int> tmp = val();\n\t\tfor(si ite=s['U'-'A'].begin();ite!=s['U'-'A'].end();++ite){\n\t\t\tif(tmp.find(*ite) == tmp.end()) res.insert(*ite);\n\t\t}\n\t}else if(str[pos] == '('){\n\t\t++pos;\n\t\tres = exp();\n\t\t++pos;\n\t}else if('A' <= str[pos] && str[pos] <= 'Z'){\n\t\tres = s[str[pos] - 'A'];\n\t\t++pos;\n\t}\n\treturn res;\n}\n\nset<int> exp(){\n\tset<int> a = val();\n\twhile(pos < str.size()){\n\t\tset<int> b, c;\n\t\tif(str[pos] == 'u'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite) c.insert(*ite);\n\t\t\tfor(si ite=b.begin();ite!=b.end();++ite) c.insert(*ite);\n\t\t}else if(str[pos] == 'i'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) != b.end()) c.insert(*ite);\n\t\t\t}\n\t\t}else if(str[pos] == 'd'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) == b.end()) c.insert(*ite);\n\t\t\t}\n\t\t}else if(str[pos] == 's'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tset<int> d, e;\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) == b.end()) c.insert(*ite);\n\t\t\t}\t\t\n\t\t\tfor(si ite=b.begin();ite!=b.end();++ite){\n\t\t\t\tif(a.find(*ite) == a.end()) c.insert(*ite);\n\t\t\t}\t\t\n\t\t}else break;\n\t\ta = c;\n\t}\n\treturn a;\n}\n\nint main(){\n\tchar c;\n\tint n;\n\twhile(cin >> c >> n){\n\t\tfor(int i=0;i<N;++i) s[i].clear();\n\t\twhile(1){\n\t\t\tif(c == 'R' && n == 0) break;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\ts[c-'A'].insert(in);\n\t\t\t}\n\t\t\tcin >> c >> n;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(si ite=s[i].begin();ite!=s[i].end();++ite) s['U'-'A'].insert(*ite);\n\t\t}\n\t\tcin >> str;\n\t\tpos = 0;\n\t\tset<int> ans = exp();\n\t\tif(ans.size() == 0){\n\t\t\tcout << \"NULL\" << endl;\n\t\t}else{\n\t\t\tfor(si ite=ans.begin();ite!=ans.end();++ite){\n\t\t\t\tif(ite != ans.begin()) cout << ' ';\n\t\t\t\tcout << *ite;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint idx;\nstring s;\nvector<int> v[128];\n\nvector<int> op(char ch,vector<int> a,vector<int> b=vector<int>()){\n\tvector<int> res(502);\n\tvector<int>::iterator it;\n\n\tif(ch == 'u') it = set_union(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'i') it = set_intersection(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'd') it = set_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 's') it = set_symmetric_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'c') it = set_difference(v['U'].begin(),v['U'].end(),a.begin(),a.end(),res.begin());\n\n\tres.resize(it-res.begin());\n\treturn res;\n}\n\nvector<int> solve(void){\n\tif(s[idx] == ')'){\n\t\tidx++;\n\t\treturn vector<int>();\n\t}\n\n\tbool flg = false;\n\tif(s[idx] == 'c'){\n\t\tflg = true;\n\t\tidx++;\n\t}\n\n\tvector<int> res;\n\tif(s[idx] == '('){\n\t\tidx++;\n\t\tres = solve();\n\t}\n\telse{\n\t\tres = v[s[idx++]];\n\t}\n\n\tif(flg) res = op('c',res);\n\n\twhile(idx < s.length() && s[idx] != ')'){\n\t\tchar ch = s[idx++];\n\n\t\tflg = false;\n\t\tif(s[idx] == 'c'){\n\t\t\tflg = true;\n\t\t\tidx++;\n\t\t}\n\n\t\tvector<int> tmp;\n\t\tif(s[idx] == '('){\n\t\t\tidx++;\n\t\t\ttmp = solve();\n\t\t}\n\t\telse{\n\t\t\ttmp = v[s[idx++]];\n\t\t}\n\n\t\tif(flg) tmp = op('c',tmp);\n\t\tres = op(ch,res,tmp);\n\t}\n\tidx++;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tv['U'].clear();\n\t\tfor(int i=0;i<5;i++) v['A'+i].clear();\n\n\t\twhile(1){\n\t\t\tchar name;\n\t\t\tint n;\n\t\t\tif(!(cin>>name>>n)) return 0;\n\t\t\tif(name == 'R') break;\n\n\t\t\tv[name] = vector<int>(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcin>>v[name][i];\n\t\t\t}\n\t\t\tsort(v[name].begin(),v[name].end());\n\t\t\tv['U'] = op('u',v[name],v['U']);\n\t\t}\n\n\t\tcin>>s;\n\t\tidx = 0;\n\n\t\tvector<int> ans = solve();\n\t\tif(ans.empty()){\n\t\t\tcout<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tcout<<ans[i]<<\" \";\n\t\t}\n\t\tcout<<ans[ans.size()-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef set <int> SI;\ntypedef map <string, SI> MSI;\n\nMSI M;\nVI T;\n\nSI getU() {\n    SI res;\n    string S[5] = { \"A\", \"B\", \"C\", \"D\", \"E\" };\n    for ( int i = 0; i < 5; ++ i ) {\n        for ( SI::iterator it_i = M[S[i]].begin(); it_i != M[S[i]].end(); ++ it_i ) {\n            res.insert( *it_i );\n        }\n    }\n    SI st( res.begin(), res.end() );\n    return SI( st.begin(), st.end() );\n}\n\nSI getCU( SI A ) {\n    SI res;\n    SI U = getU();\n    for ( SI::iterator it_i = U.begin(); it_i != U.end(); ++ it_i ) {\n        bool flag = true;\n        for ( SI::iterator it_j = A.begin(); it_j != A.end(); ++ it_j ) {\n            if ( *it_j == *it_i ) flag = false;\n        }\n        if ( flag ) res.insert( *it_i );\n    }\n    return res;\n}\n\nvoid print_vi( SI s ) {\n    if ( s.empty() ) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n    VI v( s.begin(), s.end() );\n    for ( VI::iterator it_i = v.begin(); it_i != v.end(); ++ it_i ) {\n        cout << *it_i;\n        if ( it_i + 1 != v.end() ) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\nbool isOP( char c ) {\n    if ( c == 'u' ) return true;\n    if ( c == 'i' ) return true;\n    if ( c == 'd' ) return true;\n    if ( c == 's' ) return true;\n    return false;\n}\n\nstring toString( char c ) {\n    string res;\n    res += c;\n    return res;\n}\n\nSI getUnion( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    return res;\n}\n\nSI getIntersection( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        for ( SI::iterator it_j = B.begin(); it_j != B.end(); ++ it_j ) {\n            if ( *it_i == *it_j ) res.insert( *it_i );\n        }\n    }\n    return res;\n}\n\nSI getDifference( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.erase( *it_i );\n    }\n    return res;\n}\n\nSI getSymmetricDifference( SI A, SI B ) {\n    return getUnion( getDifference( A, B ), getDifference( B, A ) );\n}\n\nSI solve2( string s, int k ) {\n    int n = s.size();\n\n    SI A, B;\n    string op;\n    // A\n    if ( s[k] == '(' ) {\n        A = solve2( s, k + 1 );\n        k = T[k] + 1;\n    } else if ( s[k] == 'c' && s[k+1] == '(' ) {\n        A = getCU( solve2( s, k + 2 ) );\n        k = T[k+1] + 1;\n    } else {\n        if ( s[k] == 'c' ) {\n            A = getCU( M[toString(s[k+1])] );\n            k += 2;\n        } else {\n            A = M[toString(s[k])];\n            k += 1;\n        }\n    }\n\n    SI res = A;\n    while ( k < n && s[k] != ')' ) {\n        // O\n        op = s[k];\n        k ++;\n        // B\n        if ( s[k] == '(' ) {\n            B = solve2( s, k + 1 );\n            k = T[k] + 1;\n        } else if ( s[k] == 'c' && s[k+1] == '(' ) {\n            B = getCU( solve2( s, k + 2 ) );\n            k = T[k+1] + 1;\n        } else {\n            if ( s[k] == 'c' ) {\n                B = getCU( M[toString(s[k+1])] );\n                k += 2;\n            } else {\n                B = M[toString(s[k])];\n                k += 1;\n            }\n        }\n        if ( op == \"u\" ) {\n            res = getUnion( res, B );\n        } else if ( op == \"i\" ) {\n            res = getIntersection( res, B );\n        } else if ( op == \"d\" ) {\n            res = getDifference( res, B );\n        } else if ( op == \"s\" ) {\n            res = getSymmetricDifference( res, B );\n        }\n    }\n\n    return res;\n}\n\nvoid solve( string first_name, int first_n ) {\n    M.clear();\n\n    // input\n    for ( int i = 0; i < first_n; ++ i ) {\n        int elm;\n        cin >> elm;\n        M[first_name].insert( elm );\n    }\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        if ( name == \"R\" && n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            int elm;\n            cin >> elm;\n            M[name].insert( elm );\n        }\n    }\n    string exp;\n    cin >> exp;\n\n    int m = exp.size();\n    T = VI( m, m );\n    stack <int> st;\n    for ( int i = 0; i < m; ++ i ) {\n        if ( exp[i] == '(' ) {\n            st.push( i );\n        } else if ( exp[i] == ')' ) {\n            int left = st.top();\n            st.pop();\n            int right = i;\n            T[left] = right;\n        }\n    }\n\n    print_vi( solve2( exp, 0 ) );\n}\n\nint main() {\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        solve( name, n );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    sort(result.begin(), result.end());\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring e;\nvector<int> sets[256];\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nvector<int> parse(int a, int b)\n{\n\tint p = b;\n\tfor (int par = 0; p >= a; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < a)\n\t{\n\t\tif (e[a] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(a + 1, b));\n\t\telse if (e[a] == '(')\n\t\t\treturn parse(a + 1, b - 1);\n\t\telse\n\t\t\treturn sets[e[a]];\n\t}\n\n\treturn calculate(e[p], parse(a, p - 1), parse(p + 1, b));\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\trep (i, 256)\n\t\t\tsets[i].clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tif (!(cin >> a >> n))\n\t\t\t\treturn 0;\n\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tcin >> e;\n\t\tvector<int> res = parse(0, e.size() - 1);\n\t\tif (res.empty())\n\t\t\tcout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tcout << res[i];\n\t\t\t\tif (i + 1 < res.size())\n\t\t\t\t\tcout << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\ntypedef struct ParseResult {\n    bool flag;\n    bool isVector;\n    PII  value;\n} RES;\n\ntypedef std::set<int> SI;\n\nstd::set< char > ops;\nstd::map< char, SI > sets;\nSI uni;\n\n// Exp = Set {('u' | 'i' | 'd' | 's') Set}*\n// Set = '(' Exp ')' | Name\n// Name = setNames\n\nSI parseExp(State* s);\nSI parseSet(State* s);\n\nvoid printSet(SI set) {\n    EACH(it, set) {\n        std::cout << \" \" << *it;\n    }\n}\n\nSI parseExp(State* s) {\n    SI set1 = parseSet(s);\n\n    char op;\n    while( op = s->seek(), op != -1 && op != ')') {\n        s->eat(op);\n\n        SI set2 = parseSet(s);\n        if(op == 'u') {\n            //union\n            EACH(it, set2) {\n                set1.insert(*it);\n            }\n        } else if(op == 'i') {\n            //intersection\n            SI set_i = set1;\n            EACH(it, set1) {\n                if(set2.count(*it) == 0) {\n                    set_i.erase(*it);\n                }\n            }\n            set1 = set_i;\n\n        } else if(op == 'd') {\n            EACH(it, set2) {\n                set1.erase(*it);\n            }\n        } else if(op == 's') {\n            SI set_u = set1;\n            EACH(it, set2) {\n                set_u.insert(*it);\n            }\n\n            SI set_i = set1;\n            EACH(it, set1) {\n                if(set2.count(*it) == 0) {\n                    set_i.erase(*it);\n                }\n            }\n\n            EACH(it, set_i) {\n                set_u.erase(*it);\n            }\n            set1 = set_u;\n        }\n    }\n    return set1;\n}\n\nSI parseSet(State* s) {\n    if(s->seek() == '(') {\n        s->eat('(');\n        SI res = parseExp(s);\n        s->eat(')');\n        return res;\n    }\n\n    bool c = (s->seek() == 'c');\n    if(c) s->eat('c');\n\n    char name = s->getCh();\n    if(sets.count(name) > 0) {\n        SI set1 = sets[name];\n        if(!c) {\n            return set1;\n        }\n\n        SI set2 = uni;\n        EACH(it, set1) {\n            set2.erase(*it);\n        }\n        return set2;\n    } else {\n        return SI();\n    }\n}\n\nint main () {\n    ops.insert('u'), ops.insert('i'), ops.insert('d'), ops.insert('s');\n\n    char c;\n    int n;\n    while(std::cin >> c >> n) {\n        SI set;\n        REP(i, n) {\n            int x;\n            std::cin >> x;\n            set.insert(x);\n            uni.insert(x);\n        }\n        sets[c] = set;\n\n        while(std::cin >> c >> n) {\n            if(c == 'R' && n == 0) break;\n            set.clear();\n\n            REP(i, n) {\n                int x;\n                std::cin >> x;\n                set.insert(x);\n                uni.insert(x);\n            }\n            sets[c] = set;\n        }\n\n        std::string e;\n        std::cin >> e;\n    \n        State state = State {0, (int)e.length(), e};\n        SI res = parseExp(&state);\n        int i = 0;\n        EACH(it, res) {\n            if(i++ != 0) std::cout << ' ';\n            std::cout << *it;\n        }\n        std::cout << std::endl;\n\n        sets.clear();\n        uni.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\ntypedef vector<int> vint;\ntypedef set<int> sint;\n\nmap<char, sint > st;\nstring ope;\nint idx;\n\nsint expr();\nsint get();\n\nsint get() {\n  if(ope[idx] == 'c') {\n    idx++;\n    sint S = get();\n    sint T;\n    for(int e : st['U']) {\n      if(!S.count(e)) T.insert(e);\n    }\n    return T;\n  } else if(isupper(ope[idx])) {\n    char c = ope[idx++];\n    return st[c];\n  } else if(ope[idx] == '(') {\n    idx++;\n    sint S = expr();\n    idx++;\n    return S;\n  } else {\n    assert(false);\n  }\n}\n\nsint expr() {\n  sint S = get();\n  while(1) {\n    if(idx >= ope.size()) return S;\n    if(ope[idx] == ')') return S;\n    else if(ope[idx] == 'u') {\n      //cout<<\"union\"<<endl;\n      idx++;\n      sint T = get();\n      sint U;\n      for(int e : S) U.insert(e);\n      for(int e : T) U.insert(e);\n      S = U;//return U;\n    } else if(ope[idx] == 'i') {\n      //cout<<\"intersect\" << endl;\n      idx++;    \n      sint T = get();\n      sint U;\n      for(int e : S) {\n\tif(T.count(e)) U.insert(e);\n      }\n      S = U;//return U;\n    } else if(ope[idx] == 'd') {\n      //cout << \"differnce\"<<endl;\n      idx++;\n      sint T = get();\n      sint U;\n      for(int e : S) {\n\tif(!T.count(e)) U.insert(e);\n      }\n      S = U;//return U;\n    } else if(ope[idx] == 's') {\n      //cout <<\"symmetric\"<<endl;\n      idx++;    \n      sint T = get();\n      sint U;\n      for(int e : S) {\n\tif(!T.count(e)) U.insert(e);\n      }\n      for(int e : T) {\n\tif(!S.count(e)) U.insert(e);\n      }\n      S = U;//return U;\n    } else {\n      assert(false);\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  char c;\n  int sz;\n  while(cin >> c >> sz) {    \n    st.clear();\n    do {\n      rep(i, sz) {\n\tint e; cin >> e;\n\tst[c].insert(e);\n\tst['U'].insert(e);\n      }\n    } while(cin >> c >> sz, c != 'R');\n    cin >> ope;\n    idx = 0;\n    sint ans = expr();\n    bool flag = false;\n    for(int e : ans) {\n      if(flag) cout << \" \";\n      flag = true;      \n      cout << e;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\tassert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\n \nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n \nvector<int> U(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n    return ve;\n}\n \nvector<int> I(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n    return ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n    return ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n    vector<int> ve;\n     \n    for(int i=0;i<a1.size();i++){\n        int r;\n        if(a1[i]==1 && a2[i]==0) r=1;\n        else r=0;\n        ve.pb(r);\n    }\n    return ve;\n}\n \nvector<int> C(vector<int> a1){\n    vector<int> ve;\n    for(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n    return ve;\n}\nvector<int> shiki();\nvector<int> ka();\nvector<int> han(){\n//  cout<<s[it]<<endl;\n    if(s[it]=='c'){\n        it++;\n        vector<int> e=ka();\n        return C(e);\n    }\n    else{\n        it++;\n        return ch[s[it-1]-'A'];\n    }\n}\n \nvector<int> ka(){\n    if(s[it]=='('){\n        it++;\n        vector<int> q=shiki();\n        it++;\n        return q;\n    }\n    else return han();\n     \n}\n \n \n \nvector<int> shiki(){\n    vector<int> r= ka();\n    while(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n        char c=s[it];\n        it++;\n        vector<int> r2=ka();\n         \n        if(c=='u') r=U(r,r2);\n        if(c=='s') r=S(r,r2);\n        if(c=='d') r=D(r,r2);\n        if(c=='i') r=I(r,r2);\n    }\n    return r;\n}\n \nint cnt=0;\nsigned main(){\nchar c;\n    int d;\n    while(1){\n         \n        cnt++;\n    //  if(cnt>20) break;\n         \n        while(1){\n            cin>>c>>d;\n             \n            if(c=='R') break;\n            for(int i=0;i<d;i++){\n                int r;\n                cin>>r;\n                ve[c-'A'].pb(r);\n            }\n             \n        }\n        set<int> se;\n         \n        for(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n        V.clear();\n        for(auto its=se.begin();its!=se.end();its++){\n            V.pb(*its);\n        }\n         \n        for(int i=0;i<5;i++){\n            for(int j=0;j<V.size();j++){\n            bool b=false;\n            for(int k=0;k<ve[i].size();k++){\n                if(ve[i][k]==V[j]) b=true;\n            }\n            if(b) ch[i].pb(1);\n            else ch[i].pb(0);\n        }\n    //      for(int j=0;j<V.size();j++)cout<<ch[i][j];\n    //      cout<<endl;\n        }\n        it=0;\n        cin>>s;\n        s+=\"*\";\n        vector<int> ans=shiki();\n        bool r=false;\n        for(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n        if(!r) cout<<\"NULL\";\n        cout<<endl;\n         \n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename InputIterator> std::string join(InputIterator first, InputIterator last, const std::string &sep) {\n  if (first == last) return \"\";\n  std::stringstream ss;\n  ss << *(first++);\n  for_each(first, last, [&](auto &x) { ss << sep << x; });\n  return ss.str();\n}\n\nset<int> bin(set<int> l, set<int> r, char op) {\n  set<int> val;\n  if (op == 'u') set_union(all(l), all(r), inserter(val, val.begin()));\n  if (op == 'i') set_intersection(all(l), all(r), inserter(val, val.begin()));\n  if (op == 'd') set_difference(all(l), all(r), inserter(val, val.begin()));\n  if (op == 's') val = bin(bin(l, r, 'd'), bin(r, l, 'd'), 'u');\n  return val;\n}\n\nusing state = string::const_iterator;\n\nset<int> expr(state &);\n\nmap<char, set<int>> m;\nset<int> u;\n\nset<int> elem(state &s) {\n  char c = *s;\n  s++;\n  return m[c];\n}\n\nset<int> factor(state &s) {\n  if (*s == '(') {\n    s++;\n    set<int> val = expr(s);\n    s++;\n    return val;\n  }\n  return elem(s);\n}\n\nset<int> term(state &s) {\n  if (*s == 'c') {\n    s++;\n    set<int> val = factor(s);\n    set<int> cval;\n    for (auto x : u) {\n      if (!val.count(x)) cval.insert(x);\n    }\n    return cval;\n  }\n  return factor(s);\n}\n\nset<int> expr(state &s) {\n  set<int> val = term(s);\n  while (1) {\n    char c = *s;\n    if (string(\"uidsc\").find(c) != string::npos) {\n      s++;\n      val = bin(val, term(s), c);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nmain {\n  while (1) {\n    m.clear();\n    u.clear();\n    char c;\n    int k;\n    while (1) {\n      if (!(cin >> c >> k)) return 0;\n      if (!k) break;\n      while (k--) {\n        int x;\n        cin >> x;\n        m[c].insert(x);\n        u.insert(x);\n      }\n    }\n    string s;\n    cin >> s;\n    state p = s.begin();\n    set<int> w = expr(p);\n    cout << join(all(w), \" \") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing State = string::const_iterator;\nusing S = set<int>;\n\nS var[5];\nS U;\n\nS formula(State &itr);\nS variable(State &itr);\nS factor(State &itr);\n\nS unite(S a, S b){\n    for(auto &x : b){\n        a.insert(x);\n    }\n    return a;\n}\n\nS intersect(S a, S b){\n    S res;\n    for(auto &x : b){\n        if(a.count(x))\n        res.insert(x);\n    }\n    return res;\n}\n\nS diff(S a, S b){\n    S res;\n    for(auto &x : a){\n        if(b.count(x)==0){\n            res.insert(x);\n        }\n    }\n    return res;\n}\n\nS sym_diff(S a, S b){\n    return unite(diff(a,b),diff(b,a));\n}\n\nS comp(S a){\n    S res;\n    for(auto &x : U){\n        if(a.count(x)==0){\n            res.insert(x);\n        }\n    }\n    return res;\n}\n\nS formula(State &itr){\n    S res = factor(itr);\n    while(*itr){\n        if(*itr == 'u'){\n            itr++;\n            res = unite(res,factor(itr));\n        }else if(*itr == 'i'){\n            itr++;\n            res = intersect(res, factor(itr));\n        }else if(*itr == 'd'){\n            itr++;\n            res = diff(res, factor(itr));\n        }else if(*itr == 's'){\n            itr++;\n            res = sym_diff(res, factor(itr));\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nS factor(State &itr){\n    S res;\n    if(*itr == '('){\n        itr++;\n        res = formula(itr);\n        itr++; // '('\n    }else if(*itr == 'c'){\n        itr++;\n        res = comp(factor(itr));\n    }else if(isupper(*itr)){\n        res = variable(itr);\n    }else{\n        // error\n    }\n    return res;\n}\n\nS variable(State &itr){\n    S res;\n    if(*itr == 'U'){\n        res = U;\n    }else if(isalpha(*itr)){\n        res = var[*itr-'A'];\n    }else{\n        // error\n    }\n    itr++;\n    return res;\n}\n\nint solve(){\n    for(int i=0;i<5;i++){\n        var[i].clear();\n    }\n    U.clear();\n    char c;\n    int n;\n    while(cin >> c){\n        cin >> n;\n        if(c != 'R'){\n            int idx = c-'A';\n            for(int i=0;i<n;i++){\n                int x;\n                cin >> x;\n                var[idx].insert(x);\n                U.insert(x);\n            }\n        }else{\n            string s;\n            cin >> s;\n            State begin = s.begin();\n            S ans = formula(begin);\n            if(!ans.empty()){\n                for(auto itr=ans.begin();itr!=ans.end();++itr){\n                    if(itr!=ans.begin()) cout << \" \";\n                    cout << *itr;\n                }\n                cout << endl;\n            }else{\n                cout << \"NULL\" << endl;\n            }\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(){\n    while(solve()==0);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;typedef set<int>S;S s[86];S::iterator q;char e[9999];int p;S PT();S U(S a,S b){for(q=b.begin();q!=b.end();++q)a.insert(*q);return a;}S D(S a,S b){for(q=b.begin();q!=b.end();++q)a.erase(*q);return a;}S PB(){S a=PT();for(;;){if(e[p]=='u'){p++;a=U(a,PT());}else if(e[p]=='i'){p++;a=D(a,D(s[85],PT()));}else if(e[p]=='d'){p++;a=D(a,PT());}else if(e[p]=='s'){p++;S b=PT();a=U(D(a,b),D(b,a));}else return a;}}S PT(){S a;if(e[p]=='('){p++;a=PB();p++;}else if(e[p]=='c'){p++;a=D(s[85],PT());}else{a=s[e[p++]];}return a;}int main(){char n;int m,v;for(;cin>>n>>m;){if(n-82){for(s[n].clear();m--;s[85].insert(v))cin>>v,s[n].insert(v);}else{cin>>e;p=0;S r=PB();for(q=r.begin();q!=r.end();cout<<(++q!=r.end()?' ':'\\n'))cout<<*q;if(r.empty())cout<<\"NULL\\n\";s[85].clear();}}}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n\ttmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n\tisok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,const vector<int>& U, int pos);\nP term(const string& str,const vector<int>& U, int pos);\nvector<int> numbers[256];\nvector<int> U;\n\nP factor(const string& str,const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n\t&& (str[pos] == 'u' || str[pos] == 'i'\n\t    || str[pos] == 'd' || str[pos] == 's')){\n    P r2 = term(str,U,pos+1);\n    if(str[pos] == 'u'){\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str, const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,U,pos+1);\n    return P(r.first,compute_complement(r.second,U));\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n\t  || str[pos] == 'C' || str[pos] == 'D'\n\t  || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    char alphabet[8];\n    int num_of_elements;\n    while(cin >> alphabet >> num_of_elements){\n\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n  \tbreak;\n      }\n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n  \tint num;\n  \tcin >> num;\n  \tnumbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n\n    string text;\n    //cin >> text;\n    if(!(cin >> text))break;\n    P r = factor(text,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n  \tprintf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n\n    for(int i = 0; i < 256; i++){\n      numbers[i].clear();\n    }\n\n    U.clear();\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cassert>\n#include <map>\nusing namespace std;\n\ntypedef pair<set<int>, int> result;\n#define value first\n#define p second\nmap<string, set<int> > idx;\nset<int> U;\n\nresult equation(const string &s, int p=0);\nresult term(const string &s,int p=0);\nresult factor(const string &s,int p=0);\n\nset<int> op(char c,set<int> s1,set<int> s2) {\n    if(c == 'u') {\n        for(set<int>::iterator it = s2.begin(); it != s2.end(); ++it)\n            s1.insert(*it);\n        return s1;\n    }else if(c == 'i') {\n        map<int,int> ap;\n        for(set<int>::iterator it = s1.begin(); it != s1.end(); ++it)\n            if(ap.find(*it) == ap.end()) ap[*it] = 1;\n            else ap[*it]++;\n\n        for(set<int>::iterator it = s2.begin(); it != s2.end(); ++it)\n            if(ap.find(*it) == ap.end()) ap[*it] = 1;\n            else ap[*it]++;\n\n        set<int> ss;\n        for(map<int,int>::iterator it = ap.begin(); it != ap.end(); ++it) {\n            if(it->second == 2) ss.insert(it->first);\n        }\n        return ss;\n    }else if(c == 'd') {\n        for(set<int>::iterator it = s2.begin(); it != s2.end(); ++it) {\n            if(s1.find(*it) != s1.end()) s1.erase(*it);\n        }\n        return s1;\n    }else if(c == 's') {\n        return op('u', op('d', s1, s2), op('d', s2, s1));\n    }\n    assert(false);\n    return set<int>();\n}\n\nresult equation(const string &s,int p) {\n    result r = factor(s, p);\n    while(s[r.p] == 'u' || s[r.p] == 'i' || s[r.p] == 'd'\n          || s[r.p] == 's') {\n        result r_ = factor(s, r.p+1);\n        r.value = op(s[r.p], r.value, r_.value);\n        r.p = r_.p;\n    }\n    return r;\n}\n\nresult factor(const string &s,int p) {\n    if(s[p] == 'c') {\n        result r = term(s,p+1);\n        return result(op('d', U, r.value),r.p);\n    }\n    return term(s,p);\n}\n\nresult term(const string &s,int p) {\n    if(s[p] == '(') {\n        result r = equation(s, p+1);\n        r.p++;\n        return r;\n    } else {\n        return result(idx[string(1,s[p])], p+1);\n    }\n}\n\nint main() {\n    string name,l;\n    int k,n;\n    while(cin>>name>>k) {\n\n        U.clear(); idx.clear();\n\n        if(name == \"R\") break;\n        for(int i=0; i<k; ++i) {\n            cin>>n;\n            idx[name].insert(n);\n            U.insert(n);\n        }\n        while(true) {\n            cin>>name>>k;\n            if(name == \"R\") break;\n            for(int i=0; i<k; ++i) {\n                cin>>n;\n                idx[name].insert(n);\n                U.insert(n);\n            }\n        }\n\n        cin>>l;\n        set<int> ss = equation(l).value;\n        for(set<int>::iterator it = ss.begin(); it != ss.end(); ++it) {\n            if(it != ss.begin()) cout<<\" \";\n            cout<<*it;\n        }\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 501;\n\nchar A[5][MAXN];\nint pos;\nstring line;\n\nvector<char> exp();\nvector<char> fact();\n\nvector<char> exp() {\n  vector<char> res = fact();\n  while(1) {\n    if(line[pos] == 'u') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] || x[i]);\n      }\n    } else if(line[pos] == 'i') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && x[i]);\n      }\n    } else if(line[pos] == 'd') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && !x[i]);\n      }\n    } else if(line[pos] == 's') {\n      ++pos;\n      vector<char> x = fact();\n      vector<char> a(res.size(),0), b(res.size(),0);\n      for(int i = 0; i< x.size(); ++i) {\n\ta[i] = (res[i] && !x[i]);\n      }\n      for(int i = 0; i< x.size(); ++i) {\n\tb[i] = (x[i] && !res[i]);\n      }\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (a[i] || b[i]);\n      }\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nvector<char> fact() {\n  vector<char> res;\n  if(line[pos] == 'c') {\n    ++pos;\n    res = fact();\n    for(int i = 0; i < res.size(); ++i) {\n      res[i] = 1-res[i];\n    }\n  } else if(isupper(line[pos])) {\n    char c = line[pos];\n    ++pos;\n    res = vector<char>(A[c-'A'], A[c-'A']+MAXN);\n  } else if(line[pos] == '(') {\n    ++pos;\n    res = exp();\n    ++pos;\n  }\n  return res;\n}\n\nmap<int,int> id, rid;\nint getId(int n) {\n  if(!id.count(n)) {\n    id[n] = id.size()-1;\n    rid[id[n]] = n;\n  }\n  return id[n];\n}\n\nint main() {\n  while(1) {\n    bool run = true;\n    fill(A[0], A[5], false);\n    id.clear();\n    rid.clear();\n    while(1) {\n      char c;\n      int n;\n      if(!(cin >> c >> n)) {\n\trun = false;\n\tbreak;\n      }\n      if(c == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i) {\n\tint a;\n\tcin >> a;\n\ta = getId(a);\n\tA[c-'A'][a] = true;\n      }\n    }\n    if(!run) break;\n    string s;\n    cin >> s;\n    line = s;\n    pos = 0;\n    vector<char> res = exp();\n    vector<int> ans;\n    for(int i = 0, cnt = 0; i < res.size(); ++i) {\n      if(rid.count(i) && res[i]) {\n\tans.push_back(rid[i]);\n      }\n    }\n    for(int i = 0; i < ans.size(); ++i) {\n      if(i) cout << \" \";\n      cout << ans[i];\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\ntypedef long long ll;\ntypedef vector<ll> vec;\n \nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n \nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n \nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n \n \nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n \nvec U;\n \nvec Not(vec a){\n  return Dif(U,a);\n}\n \nmap<char,vec> mp;\n \nvoid func(char ch,int num){\n  vec v;\n  ll a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n \nstring s;\nint pos,len;\nvec solve();\n \nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n \nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n \nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      if(ch=='R')break;\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    mp['U']=U;\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n    if(ans.size()==0)cout<<\"NULL\";\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>21) break;\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  return factor(str,numbers,U,pos);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(1){\n    if(pos >= str.size()){\n      break;\n    }\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else{\n      break;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = equation(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    char alphabet[2];\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(~scanf(\"%s %d\",alphabet,&num_of_elements)){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        goto skip;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        scanf(\"%d\",&num);\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n  skip:;\n    string text;\n    cin >> text;\n    P r = equation(text,numbers,U,0);\n    vector<int> result = r.second;\n    for(int i = 0; i < result.size(); i++){\n      printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n    }\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n \nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> elements;\n \n    Parse(string::iterator it, map<char, set<int>> elements) :\n        it(it), elements(elements) {}\n     \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n     \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n \n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n     \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n \n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n \n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n \n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n \nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> elements = {};\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n \n        elements['U'] = U;\n         \n        string str;\n        cin >> str;\n         \n        Parse parse(str.begin(), elements);\n        set<int> res = parse.expr();\n         \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(ret, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(ret, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(ret, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(ret, term(begin));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n\n    /*\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = D(sets['U'], v);\n    }\n    else {\n        ret = factor(begin);\n    }\n\n    return ret;\n    */\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nchar in[3];\nset<int> S[5];\nset<int> U;\nint cur;\nchar str[110000];\nset<int>expr();\nset<int>term(){\n    if(str[cur]=='('){\n        cur++;\n        set<int>ret=expr();\n        cur++;\n        return ret;\n    }\n    if(str[cur]=='c'){\n        cur++;\n        set<int>tmp=term();\n        set<int>ret;\n        for(set<int>::iterator it=U.begin();it!=U.end();it++){\n            if(!tmp.count(*it))ret.insert(*it);\n        }\n        return ret;\n    }\n    if(str[cur]=='U'){\n        cur++;\n        return U;\n    }\n    return S[str[cur++]-'A'];\n}\nset<int>expr(){\n    set<int>ret=term();\n    while(str[cur]=='u'||str[cur]=='i'||str[cur]=='d'||str[cur]=='s'){\n        char c=str[cur];\n        cur++;\n        set<int>tmp=term();\n        set<int>to;\n        if(c=='i'){\n            for(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n                if(tmp.count(*it))to.insert(*it);\n            }\n        }\n        if(c=='u'){\n            for(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n                to.insert(*it);\n            }\n            for(set<int>::iterator it=tmp.begin();it!=tmp.end();it++){\n                to.insert(*it);\n            }\n        }\n        if(c=='d'){\n            for(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n                if(!tmp.count(*it))to.insert(*it);\n            }\n        }\n        if(c=='s'){\n            for(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n                if(!tmp.count(*it))to.insert(*it);\n            }\n            for(set<int>::iterator it=tmp.begin();it!=tmp.end();it++){\n                if(!ret.count(*it))to.insert(*it);\n            }\n        }\n        ret=to;\n    }\n    return ret;\n}\nint main(){\n    int n;\n    while(~scanf(\"%s%d\",in,&n)){\n        for(int i=0;i<5;i++)S[i].clear();\n        U.clear();\n        cur=0;\n        for(int i=0;i<n;i++){\n            int p;scanf(\"%d\",&p);\n            S[in[0]-'A'].insert(p);\n            U.insert(p);\n        }\n        while(1){\n            scanf(\"%s%d\",in,&n);\n            if(in[0]=='R')break;\n            for(int i=0;i<n;i++){\n                int p;scanf(\"%d\",&p);\n                S[in[0]-'A'].insert(p);\n                U.insert(p);\n            }\n        }\n        scanf(\"%s\",str);\n        set<int>res=expr();\n        bool f=true;\n         \n        for(set<int>::iterator it=res.begin();it!=res.end();it++){\n            if(!f)printf(\" \");\n            printf(\"%d\",(*it));\n            f=false;\n        }\n        if(f)printf(\"NULL\");\n        printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str[0]=='c'){\n\t\treturn Complement(analysis(str.substr(1)),sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é.\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n//\treturn set<int>();\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\t\tsets['U'];\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n   // s=C(uni,st[S[p++]-'A']);\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint INF = (1<<24);\n\nvector<int> U;\nmap < int,bool > used;\n\nmap < char , vector<int> > t;\n\nstring str;\nint pos;\n\nbool input();\n\nvector<int> calc(vector<int>,char ch,vector<int>);\n\nvector<int> compute();\nvector<int> get();\n\nint main(){\n  vector<int> ans;\n  while(input()){\n    pos=0;\n    ans=compute();\n    /*\n    for(int i=0;i<(int)t['A'].size();i++){\n      cout<<t['A'][i]<<' ';\n    }\n    cout<<endl;\n    for(int i=0;i<(int)t['B'].size();i++){\n      cout<<t['B'][i]<<' ';\n    }\n    cout<<endl;\n\n    ans=calc(t['A'],'s',t['B']);\n    for(int i=0;i<(int)ans.size();i++){\n      cout<<ans[i]<<' ';\n    }\n    cout<<endl;\n    */\n    \n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n\nbool input(){\n  int n,a;\n  char ch;\n  U.clear();\n  used.clear();\n  t.clear();\n  while(1){\n    if(cin>>ch){\n    }else{\n      return false; \n    }\n    cin>>n;\n    if(ch=='R'&&n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a;\n\n      if(used[a]==false){U.push_back(a);used[a]=true;}\n\n      t[ch].push_back(a);\n    }\n    sort(t[ch].begin(),t[ch].end());\n  }\n  sort(U.begin(),U.end());\n  cin>>str;\n  str.push_back('=');\n  return true;\n}\n\nvector<int> calc(vector<int> A,char ch,vector<int> B){\n\n  int a=0,b=0,Asize=A.size(),Bsize=B.size(),nowA,nowB; \n  vector<int> res;\n\n  if(ch=='u'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n\n  }else if(ch=='i'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n\n  }else if(ch=='d'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n    \n  }else if(ch=='s'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n  }\n\n  return res;\n}\n\n\nvector<int> compute(){\n\n  vector<int> res,X;\n  char ch;\n  res=get();\n\n  while(1){\n    ch=str[pos++];\n    if(ch=='='||ch==')')break;\n    X=get();\n    res=calc(res,ch,X);\n  }\n\n  return res;\n}\n\n\nvector<int> get(){\n  if(str[pos]=='('){\n    pos++;\n    return compute();\n  }else if(str[pos]=='c'){\n    pos+=2;\n    return calc(U,'d',t[str[pos-1]]);\n  }else{\n    pos++;\n    return t[str[pos-1]];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans;//=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n    //if(S[p]-'A'>5)exit(0);\n    if(S[p]-'A'<0)exit(0);\n    s=C(uni,st[S[p]-'A']),p++;\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é.\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tif(str[0]=='c'){\n\t\treturn Complement(analysis(str.substr(1)),sets['U']);\n\t}\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\t\tsets['U'];\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\n//map<char, vector<int> > sets;\nvector<int> sets[256];\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nvector<int> parse(const string& e)\n{\n\tint p = e.size() - 1;\n\tfor (int par = 0; p >= 0; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < 0)\n\t{\n\t\tif (e[0] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(e.substr(1)));\n\t\telse if (e[0] == '(')\n\t\t\treturn parse(e.substr(1, e.size() - 2));\n\t\telse\n\t\t\treturn sets[e[0]];\n\t}\n\n\treturn calculate(e[p], parse(e.substr(0, p)), parse(e.substr(p + 1, e.size() - (p + 1))));\n}\nint main()\n{\n\twhile (!cin.eof())\n\t{\n\t\t//sets.clear();\n\t\trep (i, 256)\n\t\t\tsets[i].clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tcin >> a >> n;\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tstring exp;\n\t\tcin >> exp;\n\t\tvector<int> res = parse(exp);\n\t\tif (res.empty())\n\t\t\tcout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tcout << res[i];\n\t\t\t\tif (i + 1 < res.size())\n\t\t\t\t\tcout << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n\n#define rep(i,n)   for(int i=0;i<n;++i)\n\nusing namespace std;\ntypedef set<int> iset;\n\nstring src;\nint p;\n\niset set_u;\nmap<char, iset> sets;\n\niset parse_expr(); // proto\n\nbool end() { return p >= (int)src.length(); }\nchar peek() { return src[p]; }\nvoid succ() { if (!end()) ++p; }\n\niset set_union(const iset &sa, const iset &sb)\n{\n\tiset us = sa;\n\tfor (iset::const_iterator it = sb.begin(); it != sb.end(); ++it)\n\t{\n\t\tus.insert(*it);\n\t}\n\treturn us;\n}\n\niset set_intersect(const iset &sa, const iset &sb)\n{\n\tiset is;\n\tfor (iset::const_iterator it = sb.begin(); it != sb.end(); ++it)\n\t{\n\t\tif (sa.find(*it) != sa.end()) is.insert(*it);\n\t}\n\treturn is;\n}\n\niset set_diff(const iset &sa, const iset &sb)\n{\n\tiset ds = sa;\n\tfor (iset::const_iterator it = sb.begin(); it != sb.end(); ++it)\n\t{\n\t\tds.erase(*it);\n\t}\n\treturn ds;\n}\n\niset set_syndiff(const iset &sa, const iset &sb)\n{\n\treturn set_union(set_diff(sa, sb), set_diff(sb, sa));\n}\n\niset set_compl(const iset &s)\n{\n\tiset cs = set_u;\n\tfor (iset::const_iterator it = s.begin(); it != s.end(); ++it)\n\t{\n\t\tcs.erase(*it);\n\t}\n\treturn cs;\n}\n\niset parse_primary()\n{\n\tiset s;\n\n\tchar c = peek();\n\tswitch (c)\n\t{\n\tcase 'c':\n\t\tsucc();\n\t\ts = set_compl(parse_primary());\n\t\tbreak;\n\tcase '(':\n\t\tsucc();\n\t\ts = parse_expr();\n\t\tif (peek() == ')') succ();\n\t\tbreak;\n\tdefault:\n\t\tsucc();\n\t\ts = sets[c];\n\t\tbreak;\n\t}\n\treturn s;\n}\n\nbool is_op()\n{\n\tchar c = peek();\n\treturn c=='u'||c=='i'||c=='d'||c=='s';\n}\n\niset parse_expr()\n{\n\tiset a = parse_primary();\n\n\twhile (!end() && is_op())\n\t{\n\t\tchar op = peek();\n\t\tsucc();\n\n\t\tiset b = parse_primary();\n\t\tswitch (op)\n\t\t{\n\t\tcase 'u':\n\t\t\ta = set_union(a, b);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\ta = set_intersect(a, b);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\ta = set_diff(a, b);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\ta = set_syndiff(a, b);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\niset parse()\n{\n\tp = 0;\n\treturn parse_expr();\n}\n\nint main()\n{\n\twhile(!cin.eof())\n\t{\n\t\tchar name;\n\t\tint N, e;\n\n\t\tsets.clear();\n\t\tset_u.clear();\n\t\twhile(cin >> name >> N, name != 'R')\n\t\t{\n\t\t\trep(i,N)\n\t\t\t{\n\t\t\t\tcin >> e;\n\t\t\t\tsets[name].insert(e);\n\t\t\t\tset_u.insert(e);\n\t\t\t}\n\t\t}\n\n\t\tcin >> src;\n\t\tiset s = parse();\n\t\tif (s.size() == 0)\n\t\t{\n\t\t\tcout << \"NULL\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (iset::const_iterator &it = s.begin(); it != s.end(); ++it)\n\t\t{\n\t\t\tif (it != s.begin()) cout << \" \";\n\t\t\tcout << *it;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\t//assert(mp.find(c) != mp.end());\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\t//assert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\t//assert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = term(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(my_left, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(my_left, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(my_left, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(my_left, term(begin));\n        }\n        else{\n            break;\n        }\n   }\n   return ret;\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n\n    /*\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = D(sets['U'], v);\n    }\n    else {\n        ret = factor(begin);\n    }\n\n    return ret;\n    */\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        char se;\n        int n;\n\n        while (cin >> se >> n) {\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        if(sets['U'].size() == 0){\n            break;\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstring str;\nmap<char, vector<int> > mpp;\nint p;\n\nbool check()\n{\n  bool f = true;\n  if(str[p] == ')') return false;\n  if(p < str.size()) return f;\n  if(str[p] == 'u') return f;\n  if(str[p] == 'i') return f;\n  if(str[p] == 'd') return f;\n  if(str[p] == 's') return f;\n\n  return false;\n}\n\nvoid vprint(vector<int> vec)\n{\n  for(int i = 0; i < vec.size(); i++) cout << \" \" << vec[i];\n  cout << endl;\n\n  return ;\n}\n\nvector<int> elm();\nvector<int> func()\n{\n  vector<int> vec, vec3, vec2 = elm();\n\n  while(check()){\n    // cout << \"func[\" << p << \"]: \" << str[p] << endl;\n    char ch = str[p++];\n    vec3 = elm();\n    vec.clear();\n    vector<int> v(vec2.size()+vec3.size());\n    vector<int>::iterator lt;\n\n    if(ch == 'u'){\n      lt = set_union(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    } else if(ch == 'i'){\n      lt = set_intersection(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    } else if(ch == 'd'){\n      lt = set_difference(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    } else {\n      lt = set_symmetric_difference(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    }\n    for(vector<int>::iterator st = v.begin(); st != lt; st++) vec.push_back(*st);\n    vec2 = vec;\n\n    // vprint(vec);\n  }\n\n  return vec;\n}\n\nvector<int> elm()\n{\n  vector<int> vec;\n  \n  if(str[p] == '('){\n    // cout << \"elm[\" << p << \"]: (\" << str[p+1] << \")\" << endl;\n    p++;\n    vec = func();\n    if(str[p] == ')') p++;\n  } else if(str[p] == 'c'){\n    p++;\n    vector<int> uvec = mpp['U'], vec2;\n    // cout << \"elm[\" << p << \"]: c\" << str[p] << endl;\n    if(str[p] == '('){\n      p++;\n      vec2 = func();\n      if(str[p] == ')') p++;\n    } else {\n      vec2 = mpp[str[p++]];\n    }\n    // vprint(vec2);\n    // vprint(uvec);\n    vector<int> v(uvec.size());\n    vector<int>::iterator it = set_difference(uvec.begin(), uvec.end(), vec2.begin(), vec2.end(), v.begin());\n    for(vector<int>::iterator st = v.begin(); st != it; st++) vec.push_back(*st);\n  } else {\n    // cout << \"elm[\" << p << \"]: \" << str[p] << endl;\n    vec = mpp[str[p++]];\n  }\n  // vprint(vec);\n\n  return vec;\n}\n\nint main()\n{\n  char s;\n  int t, u;\n\n  while(!cin.eof()){\n    set<int> stt;\n\n    for(int i = 0; i < 5; i++){ \n      vector<int> v;\n      mpp['A'+i] = v;\n    }\n    while(cin>>s>>t){\n      vector<int> vec;\n      if(s == 'R' && t == 0) break;\n\n      while(t--){\n\tcin >> u;\n\tstt.insert(u);\n\tvec.push_back(u);\n      }\n      sort(vec.begin(), vec.end());\n      mpp[s] = vec;\n    }    \n    vector<int> res;\n    for(set<int>::iterator it = stt.begin(); it != stt.end(); it++)\n      res.push_back(*it);\n    mpp['U'] = res;\n\n    cin >> str;\n    p = 0;\n    // cout << str << endl;\n    res = func();\n    if(res.size() > 0){\n      cout << res[0];\n      for(int i = 1; i < res.size(); i++) cout << \" \" << res[i];\n    } else {\n      cout << \"NULL\";\n    }\n    cout << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nstruct S{\n  vector<int> a;\n  char s;\n  S(vector<int> a,char s):a(a),s(s){}\n};\nvector<int> a[6];\nvector<int> fi(vector<S> b){\n  int i,j,k;\n  for(i=0;i<(int)b.size();++i){    \n    if(b[i].s=='('){\n      k=1;\n      for(j=i;k;){\n\t++j;\n\tif(0){\n\t}else if(b[j].s=='('){\n\t  ++k;\n\t}else if(b[j].s==')'){\n\t  --k;\n\t}\n      }\n      vector<int> c=fi(vector<S>(b.begin()+i+1,b.begin()+j));\n      b.insert(b.erase(b.begin()+i,b.begin()+j+1),S(c,'\\0'));\n    }\n  }\n  for(i=1;i<(int)b.size();++i){\n    if(b[i-1].s=='c'&&b[i].s=='c'){\n      b.erase(b.begin()+i-1,b.begin()+i+1);\n      --i;\n    }\n  }\n  for(i=0;i<(int)b.size();++i){\n    if(b[i].s=='c'){\n      b[i].a.assign(512,0);\n      b[i].a.resize(set_difference(a[5].begin(),a[5].end(),b[i+1].a.begin(),b[i+1].a.end(),b[i].a.begin())-b[i].a.begin());\n      b[i].s='\\0';\n      b.erase(b.begin()+i+1);\n    }\n  }\n  while((int)b.size()>1){\n    b[1].a.assign(512,0);\n    if(0){\n    }else if(b[1].s=='u'){\n      b[1].a.resize(set_union(b[0].a.begin(),b[0].a.end(),b[2].a.begin(),b[2].a.end(),b[1].a.begin())-b[1].a.begin());\n    }else if(b[1].s=='i'){\n      b[1].a.resize(set_intersection(b[0].a.begin(),b[0].a.end(),b[2].a.begin(),b[2].a.end(),b[1].a.begin())-b[1].a.begin());\n    }else if(b[1].s=='d'){\n      b[1].a.resize(set_difference(b[0].a.begin(),b[0].a.end(),b[2].a.begin(),b[2].a.end(),b[1].a.begin())-b[1].a.begin());\n    }else if(b[1].s=='s'){\n      b[1].a.resize(set_symmetric_difference(b[0].a.begin(),b[0].a.end(),b[2].a.begin(),b[2].a.end(),b[1].a.begin())-b[1].a.begin());\n    }\n    b[1].s='\\0';\n    b.erase(b.begin()+2);\n    b.erase(b.begin());\n  }\n  return b[0].a;\n}\nint main(){\n  int i;\n  char s;\n  int n;\n  while(cin>>s>>n){\n    for(i=0;i<6;++i)\n      a[i].clear();\n    while(s!='R'){\n      for(i=0;i<n;++i){\n\tint p;\n\tcin>>p;\n\ta[s-'A'].push_back(p);\n\ta[5].push_back(p);\n      }\n      sort(a[s-'A'].begin(),a[s-'A'].end());\n      cin>>s>>n;\n    }\n    sort(a[5].begin(),a[5].end());\n    a[5].erase(unique(a[5].begin(),a[5].end()),a[5].end());\n    string t;\n    cin>>t;\n    int ln=t.length();\n    vector<S> b;\n    for(i=0;i<ln;++i){\n      if('A'<=t[i]&&t[i]<='E'){\n\tb.push_back(S(a[t[i]-'A'],'\\0'));\n      }else{\n\tb.push_back(S(vector<int>(),t[i]));\n      }\n    }\n    vector<int > d=fi(b);\n    for(i=0;i<(int)d.size()-1;++i)\n      cout<<d[i]<<\" \";\n    cout<<d[i]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>30) exit(1);\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nvector<int> numbers[256];\nvector<int> U;\n\nint main(){\n  while(1){\n    string alphabet;\n    int num_of_elements;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < 256; i++){\n      numbers[i].clear();\n    }\n    U.clear();\n    // if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        if(dataset.find(s) == dataset.end()) {\n            dataset[s] = set<int>();\n        }\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            dataset[s].insert(u);\n            U.insert(u);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef set <int> SI;\ntypedef map <string, SI> MSI;\n\nMSI M;\n\nSI getU() {\n    SI res;\n    string S[5] = { \"A\", \"B\", \"C\", \"D\", \"E\" };\n    for ( int i = 0; i < 5; ++ i ) {\n        for ( SI::iterator it_i = M[S[i]].begin(); it_i != M[S[i]].end(); ++ it_i ) {\n            res.insert( *it_i );\n        }\n    }\n    SI st( res.begin(), res.end() );\n    return SI( st.begin(), st.end() );\n}\n\nSI getCU( SI A ) {\n    SI res;\n    SI U = getU();\n    for ( SI::iterator it_i = U.begin(); it_i != U.end(); ++ it_i ) {\n        bool flag = true;\n        for ( SI::iterator it_j = A.begin(); it_j != A.end(); ++ it_j ) {\n            if ( *it_j == *it_i ) flag = false;\n        }\n        if ( flag ) res.insert( *it_i );\n    }\n    return res;\n}\n\nvoid print_vi( SI s ) {\n    VI v( s.begin(), s.end() );\n    for ( VI::iterator it_i = v.begin(); it_i != v.end(); ++ it_i ) {\n        cout << *it_i;\n        if ( it_i + 1 != v.end() ) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\nbool isOP( char c ) {\n    if ( c == 'u' ) return true;\n    if ( c == 'i' ) return true;\n    if ( c == 'd' ) return true;\n    if ( c == 's' ) return true;\n    return false;\n}\n\nstring toString( char c ) {\n    string res;\n    res += c;\n    return res;\n}\n\nSI getUnion( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    return res;\n}\n\nSI getIntersection( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        for ( SI::iterator it_j = B.begin(); it_j != B.end(); ++ it_j ) {\n            if ( *it_i == *it_j ) res.insert( *it_i );\n        }\n    }\n    return res;\n}\n\nSI getDifference( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.erase( *it_i );\n    }\n    return res;\n}\n\nSI getSymmetricDifference( SI A, SI B ) {\n    return getUnion( getDifference( A, B ), getDifference( B, A ) );\n}\n\nSI solve2( string s, int k ) {\n    int n = s.size();\n\n    SI A, B;\n    string op;\n    // A\n    if ( s[k] == '(' ) {\n        A = solve2( s, k + 1 );\n        for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n        k++;\n    } else {\n        if ( s[k] == 'c' ) {\n            A = getCU( M[toString(s[k+1])] );\n            k += 2;\n        } else {\n            A = M[toString(s[k])];\n            k += 1;\n        }\n    }\n\n    SI res = A;\n    while ( k < n && s[k] != ')' ) {\n        // O\n        op = s[k];\n        k ++;\n        // B\n        if ( s[k] == '(' ) {\n            B = solve2( s, k + 1 );\n            for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n            k++;\n        } else {\n            if ( s[k] == 'c' ) {\n                B = getCU( M[toString(s[k+1])] );\n                k += 2;\n            } else {\n                B = M[toString(s[k])];\n                k += 1;\n            }\n        }\n        if ( op == \"u\" ) {\n            res = getUnion( res, B );\n        } else if ( op == \"i\" ) {\n            res = getIntersection( res, B );\n        } else if ( op == \"d\" ) {\n            res = getDifference( res, B );\n        } else if ( op == \"s\" ) {\n            res = getSymmetricDifference( res, B );\n        }\n    }\n    return res;\n}\n\nvoid solve( string first_name, int first_n ) {\n    M.clear();\n\n    // input\n    for ( int i = 0; i < first_n; ++ i ) {\n        int elm;\n        cin >> elm;\n        M[first_name].insert( elm );\n    }\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        if ( name == \"R\" && n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            int elm;\n            cin >> elm;\n            M[name].insert( elm );\n        }\n    }\n    string exp;\n    cin >> exp;\n    print_vi( solve2( exp, 0 ) );\n}\n\nint main() {\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        solve( name, n );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<sstream>\n#include<iterator>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define osi ostream_iterator<int>\n#define all(c) c.begin(),c.end()\nusing namespace std;\ntypedef set<int> si;\nsi sCalc(char o,si l,si r){\n\tint t;si a;stringstream ss;\n\tswitch(o){\n\tcase 'u':\n\t\tset_union(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'i':\n\t\tset_intersection(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'd':\n\t\tset_difference(all(l),all(r),osi(ss,\" \"));break;\n\tcase 's':\n\t\tset_symmetric_difference(all(l),all(r),osi(ss,\" \"));break;\n\t}\n\twhile(ss>>t)a.insert(t);\n\treturn a;\n}\nsi st[5],u,ans; string expr;\nsi prs(int s,int t){\n\tint oi,p=0;char c;\n\tfor(oi=s;oi<t;oi++){\n\t\tc=expr[oi];if(c=='(')p++;if(c==')')p--;\n\t\tif(p==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(oi==t){\n\t\tif(expr[s]=='(')return prs(s+1,t-1);\n\t\tif(s+1==t)return st[expr[s]-'A'];\n\t\tif(expr[s]=='c')return sCalc('d',u,prs(s+1,t));\n\t}\n\treturn sCalc(expr[oi],prs(s,oi),prs(oi+1,t));\n}\nint main(){\n\tchar c; int k,t;\n\twhile(cin>>c>>k){\n\t\tif(c=='R'){\n\t\t\tcin>>expr;ans=prs(0,expr.size());\n\t\t\tcopy(all(ans),osi(cout,\" \"));cout<<endl;\n\t\t\trep(i,5)st[i].clear();ans.clear();\n\t\t}else rep(i,k)cin>>t,st[c-'A'].insert(t),u.insert(t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint idx;\nstring s;\nvector<int> v[128];\n\nvector<int> op(char ch,vector<int> a,vector<int> b=vector<int>()){\n\tvector<int> res(502);\n\tvector<int>::iterator it;\n\n\tif(ch == 'u') it = set_union(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'i') it = set_intersection(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'd') it = set_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 's') it = set_symmetric_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'c') it = set_difference(v['U'].begin(),v['U'].end(),a.begin(),a.end(),res.begin());\n\n\tres.resize(it-res.begin());\n\treturn res;\n}\n\nvector<int> solve(void){\n\tif(s[idx] == ')'){\n\t\tidx++;\n\t\treturn vector<int>();\n\t}\n\n\tbool flg = false;\n\tif(s[idx] == 'c'){\n\t\tflg = true;\n\t\tidx++;\n\t}\n\n\tvector<int> res;\n\tif(s[idx] == '('){\n\t\tidx++;\n\t\tres = solve();\n\t}\n\telse{\n\t\tres = v[s[idx++]];\n\t}\n\n\tif(flg) res = op('c',res);\n\n\twhile(idx < s.length() && s[idx] != ')'){\n\t\tchar ch = s[idx++];\n\n\t\tflg = false;\n\t\tif(s[idx] == 'c'){\n\t\t\tflg = true;\n\t\t\tidx++;\n\t\t}\n\n\t\tvector<int> tmp;\n\t\tif(s[idx] == '('){\n\t\t\tidx++;\n\t\t\ttmp = solve();\n\t\t}\n\t\telse{\n\t\t\ttmp = v[s[idx++]];\n\t\t}\n\n\t\tif(flg) tmp = op('c',tmp);\n\t\tres = op(ch,res,tmp);\n\t}\n\tidx++;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tv['U'].clear();\n\t\tfor(int i=0;i<5;i++) v['A'+i].clear();\n\n\t\twhile(1){\n\t\t\tchar name;\n\t\t\tint n;\n\t\t\tif(!(cin>>name>>n)) return 0;\n\t\t\tif(name == 'R') break;\n\n\t\t\tv[name] = vector<int>(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcin>>v[name][i];\n\t\t\t}\n\t\t\tsort(v[name].begin(),v[name].end());\n\t\t\tv['U'] = op('u',v[name],v['U']);\n\t\t}\n\n\t\tcin>>s;\n\t\tidx = 0;\n\n\t\tvector<int> ans = solve();\n\t\tif(ans.empty()){\n\t\t\tcout<<\"NULL\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tcout<<ans[i]<<\" \";\n\t\t}\n\t\tcout<<ans[ans.size()-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nchar in[3];\nset<int> S[5];\nset<int> U;\nint cur;\nchar str[110000];\nset<int>expr();\nset<int>term(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tset<int>ret=expr();\n\t\tcur++;\n\t\treturn ret;\n\t}\n\tif(str[cur]=='c'){\n\t\tcur++;\n\t\tset<int>tmp=term();\n\t\tset<int>ret;\n\t\tfor(set<int>::iterator it=U.begin();it!=U.end();it++){\n\t\t\tif(!tmp.count(*it))ret.insert(*it);\n\t\t}\n\t\treturn ret;\n\t}\n\tif(str[cur]=='U'){\n\t\tcur++;\n\t\treturn U;\n\t}\n\treturn S[str[cur++]-'A'];\n}\nset<int>expr(){\n\tset<int>ret=term();\n\twhile(str[cur]=='u'||str[cur]=='i'||str[cur]=='d'||str[cur]=='s'){\n\t\tchar c=str[cur];\n\t\tcur++;\n\t\tset<int>tmp=term();\n\t\tset<int>to;\n\t\tif(c=='i'){\n\t\t\tfor(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n\t\t\t\tif(tmp.count(*it))to.insert(*it);\n\t\t\t}\n\t\t}\n\t\tif(c=='u'){\n\t\t\tfor(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n\t\t\t\tto.insert(*it);\n\t\t\t}\n\t\t\tfor(set<int>::iterator it=tmp.begin();it!=tmp.end();it++){\n\t\t\t\tto.insert(*it);\n\t\t\t}\n\t\t}\n\t\tif(c=='d'){\n\t\t\tfor(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n\t\t\t\tif(!tmp.count(*it))to.insert(*it);\n\t\t\t}\n\t\t}\n\t\tif(c=='s'){\n\t\t\tfor(set<int>::iterator it=ret.begin();it!=ret.end();it++){\n\t\t\t\tif(!tmp.count(*it))to.insert(*it);\n\t\t\t}\n\t\t\tfor(set<int>::iterator it=tmp.begin();it!=tmp.end();it++){\n\t\t\t\tif(!ret.count(*it))to.insert(*it);\n\t\t\t}\n\t\t}\n\t\tret=to;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n;\n\twhile(~scanf(\"%s%d\",in,&n)){\n\t\tfor(int i=0;i<5;i++)S[i].clear();\n\t\tU.clear();\n\t\tcur=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint p;scanf(\"%d\",&p);\n\t\t\tS[in[0]-'A'].insert(p);\n\t\t\tU.insert(p);\n\t\t}\n\t\twhile(1){\n\t\t\tscanf(\"%s%d\",in,&n);\n\t\t\tif(in[0]=='R')break;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p;scanf(\"%d\",&p);\n\t\t\t\tS[in[0]-'A'].insert(p);\n\t\t\t\tU.insert(p);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",str);\n\t\tset<int>res=expr();\n\t\tbool f=true;\n\t\t\n\t\tfor(set<int>::iterator it=res.begin();it!=res.end();it++){\n\t\t\tif(!f)printf(\" \");\n\t\t\tprintf(\"%d\",(*it));\n\t\t\tf=false;\n\t\t}\n\t\tif(f)printf(\"NULL\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\t//assert(mp.find(c) != mp.end());\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\t//assert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << \"NULL\" << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstring::iterator it;\nmap<char, set<int>> elements;\n\nset<int> term();\nset<int> expr();\n\nset<int> difference(const set<int> a, const set<int> b)\n{\n    set<int> res;\n    for(auto x : elements['U']){\n        if(a.count(x) > 0 and b.count(x) == 0){\n            res.insert(x);\n        }\n    }\n    return res;\n}\n\nset<int> complement(const set<int> a)\n{\n    return difference(elements['U'], a);\n}\n    \nset<int> intersection(const set<int> a, const set<int> b)\n{\n    set<int> res;\n    for(auto x : elements['U']){\n        if(a.count(x) > 0 and b.count(x) > 0){\n            res.insert(x);\n        }\n    }            \n    return res;\n}\n\nset<int> union_(const set<int> a, const set<int> b)\n{\n    set<int> res;\n    for(auto x : elements['U']){\n        if(a.count(x) > 0 or b.count(x) > 0){\n            res.insert(x);\n        }\n    }            \n    return res;\n}\n\nset<int> sym_difference(const set<int> a, const set<int> b)\n{\n    return (union_(difference(a, b), difference(b, a)));\n}\n\nset<int> term()\n{\n    set<int> a;\n    if(*it == '('){\n        ++it;\n        a = expr();\n        ++it;\n    }else if(*it == 'c'){\n        ++it;\n        a = term();\n        a = complement(a);\n    }else{\n        a = elements[*it];\n        ++it;\n    }\n    return a;\n}\n    \nset<int> expr()\n{\n    set<int> a = term(), b;\n    while(*it == 'd' ||\n          *it == 'i' ||\n          *it == 's' ||\n          *it == 'u')\n    {\n        char ch = *it; ++it;\n        b = term();\n        switch(ch)\n        {\n            case 'd':\n                a = difference(a, b);\n                break;\n            case 'i':\n                a = intersection(a, b);\n                break;\n            case 's':\n                a = sym_difference(a, b);\n                break;\n            case 'u':\n                a = union_(a, b);\n                break;\n        }\n    }\n    return a;\n}\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        elements.clear();\n        set<int> U = {};\n\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n\n        elements['U'] = U;\n        \n        string str;\n        cin >> str;\n        it = str.begin();\n        set<int> res = expr();\n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[2000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tret.push_back(A[i]);\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tret.push_back(B[i]);\n\t}\n\n\tsort(ret.begin(),ret.end());\n\n\tret.erase(unique(ret.begin(),ret.end()),ret.end());\n\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tauto at = MAP.find(B[i]);\n\t\tif(at != MAP.end()){\n\t\t\tret.push_back(B[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tMAP[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tauto at = MAP.find(A[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tMAP[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tauto at = MAP.find(A[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\n\tMAP.clear();\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tauto at = MAP.find(B[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(B[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tauto at = MAP.find(U[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tU.push_back(V[i][k]);\n\t\t}\n\t}\n\tsort(U.begin(),U.end());\n\tU.erase(unique(U.begin(),U.end()),U.end());\n}\n\n\nvector<int> recursive(int left,int right){\n\n\t/*printf(\"\\n\\nleft:%d right:%d\\n\",left,right);\n\tfor(int i = left; i <= right; i++){\n\t\tprintf(\"%c\",equation[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\t\t\t//printf(\"???????????????\\n\");\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\t//printf(\"left??±??????()\\n\");\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t\t}*/\n\t\t\t}else{\n\n\t\t\t\t//printf(\"right??±??????()\\n\");\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_right.size(); k++){\n\t\t\t\t\tprintf(\"calc_right[%d]:%d\\n\",k,calc_right[k]);\n\t\t\t\t}*/\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\t//printf(\"?????????:%c\\n\",equation[index]);\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\t/*printf(\"??????:%c\\n\",equation[index]);\n\t\t\tfor(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"??? calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\t//printf(\"%d??¨intersect\\n\",loc[equation[index]-'A']);\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\t/*for(int i = 0; i < U.size(); i++){\n\t\tprintf(\"U[%d]:%d\\n\",i,U[i]);\n\t}*/\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>23) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring pat = \"uids\";\nmap< char, vector<int> > sets;\nvector<int> all_sets;\n\nvector<int> operate(vector<int> setA, vector<int> setB, char op, bool isC) {\n  sort(setA.begin(), setA.end());\n  sort(setB.begin(), setB.end());\n\n  vector<int> res;\n  if(op == 'i') {\n    set<int> S;\n    for(auto x : setA) S.insert(x);\n\n    for(auto x : setB) {\n      if(S.count(x)) res.push_back(x);\n    }\n  }\n  if(op == 'u') {\n    set<int> S;\n    for(auto x : setA) S.insert(x), res.push_back(x);\n\n    for(auto x : setB) {\n      if(!S.count(x)) res.push_back(x);\n    }\n  }\n  if(op == 'd') {\n    set<int> S;\n    for(int i=0; i<setB.size(); i++) S.insert(setB[i]);\n\n    for(int i=0; i<setA.size(); i++) {\n      if(!S.count(setA[i])) {\n\tres.push_back(setA[i]);\n      }\n    }\n  }\n  if(op == 's') {\n    map<int, int> mp;\n    for(auto x : setA) mp[x]++;\n    for(auto x : setB) mp[x]++;\n\n    for(auto x : mp) {\n      if(x.second > 1) continue;\n      res.push_back(x.first);\n    }\n  }\n  if(op == 'c') {\n    set<int> S;\n    for(auto x : setA) S.insert(x);\n\n    for(auto x : all_sets) {\n      if(!S.count(x)) res.push_back(x);\n    }\n  }\n\n  if(isC) {\n    return operate(res, vector<int>(), 'c', false);\n  }\n  else {\n    return res;\n  }\n}\n\nvector<int> parse(string s, int l, int r) {\n  // fprintf(stderr, \"parse [%d, %d)\\n\", l, r);\n  int paren = 0;\n  bool isC = false;\n  char op = 'u';\n  vector<int> ret;\n  for(int i=l; i<r; i++) {\n    if(s[i] == 'c') isC ^= true;\n    else if(s[i] == '(') {\n      paren++;\n      int nl = i++, nr = -1;\n      for(; paren > 0 and i < s.length(); i++) {\n\tif(s[i] == '(') paren++;\n\tif(s[i] == ')') paren--;\n      }\n      nr = i--;\n      // fprintf(stderr, \"operate [%d %d): %d\\n\", nl+1, nr-1, isC);\n      ret = operate(ret, parse(s, nl+1, nr-1), op, isC);\n      isC = false;\n    }\n    else if(pat.find(s[i]) != string::npos) {\n      // fprintf(stderr, \"set operator: %c\\n\", s[i]);\n      op = s[i];\n    }\n    else {\n      // fprintf(stderr, \"char %c: isC = %d\\n\", s[i], isC);\n      // fprintf(stderr, \"operate %c: %d\\n\", s[i], isC);\n      ret = operate(ret, sets[ s[i] ], op, isC);\n      isC = false;\n    }\n    // fprintf(stderr, \"temp state at i = %d:\", i);\n    // for(auto x : ret) fprintf(stderr, \" %d\", x);\n    // cerr << endl;\n  }\n  // fprintf(stderr, \"answer of parse [%d, %d):\", l, r);\n  // for(auto x : ret) fprintf(stderr, \" %d\", x);\n  // cerr << endl;\n  return ret;\n}\n\nint main() {\n  char set_name; int set_size;\n  while(cin >> set_name >> set_size) {\n    if(set_name == 'R') {\n      string expr; cin >> expr;\n      int len = expr.size();\n      vector<int> ans = parse(expr, 0, len);\n\n      sort(ans.begin(), ans.end());\n      if(ans.empty()) cout << \"NULL\" << endl;\n      else {\n\tfor(size_t i=0; i<ans.size(); i++) {\n\t  cout << ans[i] << \" \\n\"[i+1 == ans.size()];\n\t}\n      }\n\t\n      sets.clear();\n      all_sets.clear();\n    }\n    else {\n      sets[set_name] = vector<int>();\n      for(int i=0; i<set_size; i++) {\n\tint num; cin >> num;\n\tsets[set_name].push_back(num);\n      }\n      // fprintf(stderr, \"input end\\n\");\n      all_sets = operate(all_sets, sets[set_name], 'u', false);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nvi S[6];\nstring expr;\n\nvi calc(vi a,vi b,char op)\n{\n\tvi ret(a.size()+b.size());\n\tvi::iterator it;\n\tswitch(op)\n\t{\n\tcase 'u':\n\t\tit=set_union(all(a),all(b),ret.begin()); break;\n\tcase 'i':\n\t\tit=set_intersection(all(a),all(b),ret.begin()); break;\n\tcase 'd':\n\t\tit=set_difference(all(a),all(b),ret.begin()); break;\n\tcase 's':\n\t\tit=set_symmetric_difference(all(a),all(b),ret.begin()); break;\n\t}\n\tret.erase(it,ret.end());\n\treturn ret;\n}\n\nvi eval(int s,int t)\n{\n\tint d=0,p=t-1; char c;\n\tfor(;p>s;p--)\n\t{\n\t\tc=expr[p];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(p==s)\n\t{\n\t\tif(expr[s]=='(')return eval(s+1,t-1);\n\t\tif(expr[s]=='c')return calc(S[5],eval(s+1,t),'d');\n\t\tint idx=expr[s]=='U'?5:expr[s]-'A';\n\t\treturn S[idx];\n\t}\n\treturn calc(eval(s,p),eval(p+1,t),c);\n}\n\nint main()\n{\n\tchar c; int n;\n\twhile(cin>>c>>n)\n\t{\n\t\trep(i,6)S[i].clear();\n\t\tdo\n\t\t{\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tint t; cin>>t;\n\t\t\t\tS[c-'A'].pb(t);\n\t\t\t\tS[5].pb(t);\n\t\t\t}\n\t\t}while(cin>>c>>n,c!='R');\n\t\t\n\t\trep(i,6)\n\t\t\tsort(all(S[i])),S[i].erase(unique(all(S[i])),S[i].end());\n\t\tcin>>expr;\n\t\t\n\t\tvi ans=eval(0,expr.size());\n\t\trp(i,ans)cout<<ans[i]<<(i==ans.size()-1?\"\":\" \");\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstring::iterator it;\nmap<char, set<int>> elements;\n\nset<int> term();\nset<int> expr();\n\nset<int> difference(const set<int> a, const set<int> b)\n{\n    set<int> res;\n    for(auto x : elements['U']){\n        if(a.count(x) > 0 and b.count(x) == 0){\n            res.insert(x);\n        }\n    }\n    return res;\n}\n\nset<int> complement(const set<int> a)\n{\n    return difference(elements['U'], a);\n}\n    \nset<int> intersection(const set<int> a, const set<int> b)\n{\n    set<int> res;\n    for(auto x : elements['U']){\n        if(a.count(x) > 0 and b.count(x) > 0){\n            res.insert(x);\n        }\n    }            \n    return res;\n}\n\nset<int> union_(const set<int> a, const set<int> b)\n{\n    set<int> res;\n    for(auto x : elements['U']){\n        if(a.count(x) > 0 or b.count(x) > 0){\n            res.insert(x);\n        }\n    }            \n    return res;\n}\n\nset<int> sym_difference(const set<int> a, const set<int> b)\n{\n    return (union_(difference(a, b), difference(b, a)));\n}\n\nset<int> term()\n{\n    set<int> a;\n    if(*it == '('){\n        ++it;\n        a = expr();\n        ++it;\n    }else if(*it == 'c'){\n        ++it;\n        a = term();\n        a = complement(a);\n    }else{\n        a = elements[*it];\n        ++it;\n    }\n    return a;\n}\n    \nset<int> expr()\n{\n    set<int> a = term(), b;\n    while(*it == 'd' ||\n          *it == 'i' ||\n          *it == 's' ||\n          *it == 'u')\n    {\n        char ch = *it; ++it;\n        b = term();\n        switch(ch)\n        {\n            case 'd':\n                a = difference(a, b);\n                break;\n            case 'i':\n                a = intersection(a, b);\n                break;\n            case 's':\n                a = sym_difference(a, b);\n                break;\n            case 'u':\n                a = union_(a, b);\n                break;\n        }\n    }\n    return a;\n}\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        elements.clear();\n        set<int> U = {};\n\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n\n        elements['U'] = U;\n        \n        string str;\n        cin >> str;\n        it = str.begin();\n        set<int> res = expr();\n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_symmetric_difference(all(a), all(b), back_inserter(ret));\n    //set_difference(all(a), all(b), back_inserter(x));\n    //set_difference(all(b), all(a), back_inserter(y));\n    //set_union(all(x), all(y), back_inserter(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << \"NULL\" << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n    if(S[p]-'A'>5)exit(0);\n    //if(S[p]-'A'<0)exit(0);\n    s=C(uni,st[S[p]-'A']),p++;\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>22) exit(1);\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nVI factor(State&);\nVI term(State&);\n\nmap<char, VI> mp;\nVI all;\n\n// begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n            << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nVI uni(VI a, VI b) {\n\tVI ret;\n\tfor(int i: a) ret.PB(i);\n\tfor(int i: b) ret.PB(i);\n\tsort(ALL(ret));\n\tret.erase(unique(ALL(ret)), ret.end());\n\treturn ret;\n}\n\nVI inter(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: b) {\n\t\tif(tmp.find(i) != tmp.end()) {\n\t\t\tret.PB(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI diff(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: b) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: a) {\n\t\tif(tmp.find(i) == tmp.end()) {\n\t\t\tret.PB(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI symm(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tfor(int i: b) {\n\t\tif(tmp.find(i) != tmp.end()) tmp[i] = 2;\n\t\telse tmp[i] = 1;\n\t}\n\tVI ret;\n\tfor(int i: a) if(tmp[i] == 1) ret.PB(i);\n\tfor(int i: b) if(tmp[i] == 1) ret.PB(i);\n\treturn ret;\n}\n\nVI comp(VI a) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: all) if(tmp.find(i) == tmp.end()) ret.PB(i);\n\treturn ret;\n}\n\nVI expr(State &begin) {\n\t//cout << \"st:\" << *begin << endl;\n\tVI ret = term(begin);\n\twhile(1) {\n\t\t//cout << *begin << endl;\n\t\tif(*begin == 'u') {\n\t\t\tbegin++;\n\t\t\tret = uni(ret, term(begin));\n\t\t} else if(*begin == 'i') {\n\t\t\tbegin++;\n\t\t\tret = inter(ret, term(begin));\n\t\t} else if(*begin == 'd') {\n\t\t\tbegin++;\n\t\t\tret = diff(ret, term(begin));\n\t\t} else if(*begin == 's') {\n\t\t\tbegin++;\n\t\t\tret = symm(ret, term(begin));\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nVI term(State &begin) {\n\t//cout << \"te:\" << *begin << endl;\n\tif(*begin == 'c') {\n\t\tbegin++;\n\t\treturn comp(factor(begin));\n\t} else {\n\t\treturn factor(begin);\n\t}\n}\n\nVI factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tVI ret = expr(begin);\n\t\tconsume(begin, ')');\n\t\treturn ret;\n\t} else {\n\t\treturn mp[*begin++];\n\t}\n}\n\nsigned main(void)\n{\n\tchar name;\n\tint num;\n\twhile(cin >> name >> num) {\n\t\tif(name == 'R' && num == 0) {\n\t\t\tfor(auto i: mp) {\n\t\t\t\tfor(int j: i.second) {\n\t\t\t\t\tall.PB(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(all));\n\t\t\tall.erase(unique(ALL(all)), all.end());\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tState begin = s.begin();\n\t\t\tVI ans = expr(begin);\n\t\t\tsort(ALL(ans));\n\t\t\tREP(i, ans.size()) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif(i != ans.size()-1) cout << \" \";\n\t\t\t}\n\t\t\tif(ans.size() == 0) cout << \"NULL\";\n\t\t\tcout << endl;\n\t\t\tmp.erase(ALL(mp));\n\t\t\tall.erase(ALL(all));\n\t\t}\n\t\tREP(i, num) {\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\tmp[name].PB(m);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  set<int> value;\n  int p;\n  Result(set<int> v, int p) : value(v), p(p) {}\n};\n\nbool is_operator(char c){\n  string opes = \"uidsc\";\n  REP(i, opes.size()) if(c == opes[i]) return true;\n  return false;\n}\nset<int> operation(set<int>& s1, set<int>& s2, char ope){\n  set<int> res;\n  if(ope == 'u'){\n    FORIT(it, s1) res.insert(*it);\n    FORIT(it, s2) res.insert(*it);\n  }else if(ope == 'i'){\n    FORIT(it, s1) if(s2.count(*it)) res.insert(*it);\n  }else if(ope == 'd'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n  }else if(ope == 's'){\n    FORIT(it, s1) if(!s2.count(*it)) res.insert(*it);\n    FORIT(it, s2) if(!s1.count(*it)) res.insert(*it);\n  }else{\n    assert(false);\n  }\n  return res;\n}\nResult expr(const string& s, int p, map<char, set<int> >& vars);\nResult factor(const string& s, int p, map<char, set<int> >& vars);\nResult expr(const string& s, int p, map<char, set<int> >& vars){\n  Result r = factor(s, p, vars);\n  while(is_operator(s[r.p])){\n    Result r_ = factor(s, r.p + 1, vars);\n    r.value = operation(r.value, r_.value, s[r.p]);\n    r.p = r_.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p, map<char, set<int> >& vars){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1, vars);\n    assert(s[r.p] == ')');\n    r.p++;\n    return r;\n  }else if(s[p] == 'c'){\n    Result r = factor(s, p + 1, vars);\n    set<int> v;\n    FORIT(it, vars['U'])if(!r.value.count(*it)){\n      v.insert(*it);\n    }\n    r.value = v;\n    return r;\n  }else{\n    set<int> v = vars[s[p++]];\n    return Result(v, p);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    char v; int l;\n    map<char, set<int> > vars;\n    bool valid = false;\n    while(cin >> v >> l){\n      if(v == 'R'){\n        valid = true;\n        break;\n      }\n      set<int> s;\n      REP(i, l) {\n        int t; cin>>t;\n        s.insert(t);\n        vars['U'].insert(t);\n      }\n      vars[v] = s;\n    }\n    if(!valid) continue;\n    string s;\n    cin >> s;\n    set<int> res = expr(s, 0, vars).value;\n    FORIT(it, res){\n      if(it != res.begin()) cout << \" \";\n      cout << *it;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nset<int> fnd(set<int> c,set<int> d);\nset<int> fnc(set<int> c);\nset<int> fn(string s);\nset<int> a[5],b;\nset<int> fnu(set<int> c,set<int> d){\n  set<int> e;\n  set<int>::iterator it;\n  for(it=c.begin();it!=c.end();it++)\n    e.insert(*it);\n  for(it=d.begin();it!=d.end();it++)\n    e.insert(*it);\n  return e;\n}\nset<int> fni(set<int> c,set<int> d){\n  set<int> e;\n  set<int>::iterator it;\n  for(it=c.begin();it!=c.end();it++){\n    if(d.count(*it))\n      e.insert(*it);\n  }\n  return e;\n}\nset<int> fns(set<int> c,set<int> d){\n  return fnu(fnd(c,d),fnd(d,c));\n}\nset<int> fnd(set<int> c,set<int> d){\n  return fni(c,fnc(d));\n}\nset<int> fnc(set<int> c){\n  set<int> d;\n  set<int>::iterator it;\n  for(it=b.begin();it!=b.end();it++){\n    if(c.count(*it)==0)\n      d.insert(*it);\n  }\n  return d;\n}\npair<set<int>,int> fm(string s){\n  int j,k,l;\n  if(0){\n  }else if(s[0]=='('){\n    k=1;\n    for(j=1;k;j++){\n      if(0){\n      }else if(s[j]=='('){\n\tk++;\n      }else if(s[j]==')'){\n\tk--;\n      }\n    }\n    return make_pair(fn(s.substr(1,j-2)),j);\n  }else if(s[0]=='c'){\n    for(l=1;s[l]=='c';l++);\n    if(s[l]=='('){\n      k=1;\n      for(j=l+1;k;j++){\n\tif(0){\n\t}else if(s[j]=='('){\n\t  k++;\n\t}else if(s[j]==')'){\n\t  k--;\n\t}\n      }\n      if(l%2)\n\treturn make_pair(fnc(fn(s.substr(l+1,j-l-2))),j);\n      else\n\treturn make_pair(fn(s.substr(l+1,j-l-2)),j);\n    }else{\n      if(l%2)\n\treturn make_pair(fnc(a[s[l]-'A']),l+1);\n      else\n\treturn make_pair(a[s[l]-'A'],l+1);\n    }\n  }else{\n    return make_pair(a[s[0]-'A'],1);\n  }\n}\nset<int> fn(string s){\n  int i;\n  set<int> c;\n  pair<set<int>,int> p=fm(s);\n  c=p.first;\n  int ln=s.length();\n  for(i=p.second;i<ln;i+=p.second){\n    p=fm(s.substr(i+1));\n    if(0){\n    }else if(s[i]=='u'){\n      c=fnu(c,p.first);\n    }else if(s[i]=='i'){\n      c=fni(c,p.first);\n    }else if(s[i]=='d'){\n      c=fnd(c,p.first);\n    }else if(s[i]=='s'){\n      c=fns(c,p.first);\n    }\n  }\n  return c;\n}\nint main(){\n  int i;\n  char s;\n  int n;\n  while(cin>>s>>n){\n    for(i=0;i<5;i++)\n      a[i].clear();\n    b.clear();\n    while(s!='R'){\n      for(i=0;i<n;i++){\n\tint p;\n\tcin>>p;\n\ta[s-'A'].insert(p);\n\tb.insert(p);\n      }\n      cin>>s>>n;\n    }\n    string s;\n    cin>>s;\n    set<int> c=fn(s);\n    if(c.empty()){\n      cout<<\"NULL\"<<endl;\n    }else{\n      set<int>::iterator it;\n      cout<<*c.begin();\n      for(it=c.begin(),it++;it!=c.end();it++)\n\tcout<<\" \"<<*it;\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_symmetric_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        //return (c ? C(ret) : ret);\n        return ret;\n    } else {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << \"NULL\" << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//18\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> v[5],u;\nconst char *e;\nint x;\n\nvector<int> exp();\n\nvector<int> ss(){\n  if(e[x]=='('){\n    x++;\n    vector<int> r=exp();\n    x++;\n    return r;\n  }else if(e[x]!='c'){\n    return v[e[x++]-'A'];\n  }else{\n    x++;\n    vector<int> l=ss(),a(u.size());\n    vector<int>::iterator it;\n    it=set_difference(u.begin(),u.end(),l.begin(),l.end(),a.begin());\n    a.resize(it-a.begin());\n    return a;\n  }\n}\n\nvector<int> exp(){\n  vector<int> l=ss();\n  string op=\"uids\";\n  for(char o=e[x];op.find(o)!=string::npos;o=e[x]){\n    x++;\n    vector<int> r=ss(),a(u.size());\n    vector<int>::iterator it;\n    if(o=='u'){\n      it=set_union(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='i'){\n      it=set_intersection(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='d'){\n      it=set_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else{\n      it=set_symmetric_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }\n    a.resize(it-a.begin());\n    l=a;\n  }\n  return l;\n}\n\nint main(){\n  for(;;){\n    for(int i=0;i<5;i++){\n      v[i].clear();\n    }\n    char c;\n    int n;\n    while(cin>>c>>n,cin&&c!='R'){\n      int x=c-'A';\n      v[x].resize(n);\n      while(n--){\n\tcin>>v[x][n];\n\tu.push_back(v[x][n]);\n      }\n      sort(v[x].begin(),v[x].end());\n    }\n    if(!cin)return 0;\n    sort(u.begin(),u.end());\n    u.resize(unique(u.begin(),u.end())-u.begin());\n    string s;\n    cin>>s;\n    e=s.c_str();\n    x=0;\n    vector<int> r=exp();\n    if(r.empty()){\n      cout<<\"NULL\"<<endl;\n    }else{\n      for(int i=0;i<r.size();i++){\n\tcout<<r[i]<<((i==r.size()-1)?'\\n':' ');\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstring e;\n//vector<int> sets[256];\nmap<char, vector<int> > sets;\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nvector<int> parse(int a, int b)\n{\n\tint p = b;\n\tfor (int par = 0; p >= a; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < a)\n\t{\n\t\tif (e[a] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(a + 1, b));\n\t\telse if (e[a] == '(')\n\t\t\treturn parse(a + 1, b - 1);\n\t\telse\n\t\t\treturn sets[e[a]];\n\t}\n\n\treturn calculate(e[p], parse(a, p - 1), parse(p + 1, b));\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\t//rep (i, 256)\n\t\t//\tsets[i].clear();\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tif (!(cin >> a >> n))\n\t\t\t\treturn 0;\n\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tcin >> e;\n\t\tvector<int> res = parse(0, e.size() - 1);\n\t\tif (res.empty())\n\t\t\tcout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tcout << res[i];\n\t\t\t\tif (i + 1 < res.size())\n\t\t\t\t\tcout << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>15) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_symmetric_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << \"NULL\" << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\nif(p>=S.size())return s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\nelse exit(0);\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\nif(p>=S.size())return s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\nelse exit(0);\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\nif(p>=S.size())return s;\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>21) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nvi S[6];\nstring expr;\n\nvi calc(vi a,vi b,char op)\n{\n\tvi ret(a.size()+b.size());\n\tvi::iterator it;\n\tswitch(op)\n\t{\n\tcase 'u':\n\t\tit=set_union(all(a),all(b),ret.begin()); break;\n\tcase 'i':\n\t\tit=set_intersection(all(a),all(b),ret.begin()); break;\n\tcase 'd':\n\t\tit=set_difference(all(a),all(b),ret.begin()); break;\n\tcase 's':\n\t\tit=set_symmetric_difference(all(a),all(b),ret.begin()); break;\n\t}\n\tret.erase(it,ret.end());\n\treturn ret;\n}\n\nvi eval(int s,int t)\n{\n\tint d=0,p=t-1; char c;\n\tfor(;p>s;p--)\n\t{\n\t\tc=expr[p];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(p==s)\n\t{\n\t\tif(expr[s]=='(')return eval(s+1,t-1);\n\t\tif(expr[s]=='c')return calc(S[5],eval(s+1,t),'d');\n\t\treturn S[expr[s]-'A'];\n\t}\n\treturn calc(eval(s,p),eval(p+1,t),c);\n}\n\nint main()\n{\n\tchar c; int n;\n\twhile(cin>>c>>n)\n\t{\n\t\trep(i,5)S[i].clear();\n\t\tdo\n\t\t{\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tint t; cin>>t;\n\t\t\t\tS[c-'A'].pb(t);\n\t\t\t\tS[5].pb(t);\n\t\t\t}\n\t\t}while(cin>>c>>n,c!='R');\n\t\t\n\t\trep(i,6)\n\t\t\tsort(all(S[i])),S[i].erase(unique(all(S[i])),S[i].end());\n\t\tcin>>expr;\n\t\t\n\t\tvi ans=eval(0,expr.size());\n\t\trp(i,ans)cout<<ans[i]<<(i==ans.size()-1?\"\":\" \");\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<sstream>\n#include<iterator>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define osi ostream_iterator<int>\n#define all(c) c.begin(),c.end()\nusing namespace std;\ntypedef set<int> si;\nsi sCalc(char o,si l,si r){\n\tint t;si a;stringstream ss;\n\tswitch(o){\n\tcase 'u':\n\t\tset_union(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'i':\n\t\tset_intersection(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'd':\n\t\tset_difference(all(l),all(r),osi(ss,\" \"));break;\n\tcase 's':\n\t\tset_symmetric_difference(all(l),all(r),osi(ss,\" \"));break;\n\t}\n\twhile(ss>>t)a.insert(t);\n\treturn a;\n}\nsi st[5],u,ans; string expr;\nsi prs(int s,int t){\n\tint oi,p=0;char c;\n\tfor(oi=s;oi<t;oi++){\n\t\tc=expr[oi];if(c=='(')p++;if(c==')')p--;\n\t\tif(p==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(oi==t){\n\t\tif(expr[s]=='(')return prs(s+1,t-1);\n\t\tif(s+1==t)return st[expr[s]-'A'];\n\t\tif(expr[s]=='c')return sCalc('d',u,prs(s+1,t));\n\t}\n\treturn sCalc(expr[oi],prs(s,oi),prs(oi+1,t));\n}\nint main(){\n\tchar c; int k,t;\n\twhile(cin>>c>>k){\n\t\tif(c=='R'){\n\t\t\tcin>>expr;ans=prs(0,expr.size());\n\t\t\tfor(__typeof(ans.begin()) i=ans.begin();i!=ans.end();i++){\n\t\t\t\tif(i!=ans.begin())cout<<\" \";\n\t\t\t\tcout<<*i;\n\t\t\t}\n\t\t\tif(ans.empty())cout<<\"NULL\";cout<<endl;\n\t\t\trep(i,5)st[i].clear();u.clear();\n\t\t}else rep(i,k)cin>>t,st[c-'A'].insert(t),u.insert(t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n    s=C(uni,st[S[p++]-'A']);\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef map<char, set<int> > mapset;\n\nset<int> atom(string &expr, mapset &sets, int &k);\nset<int> block(string &expr, mapset &sets, int &k);\nset<int> unite(set<int> &s1, set<int> &s2);\nset<int> intersection(set<int> &s1, set<int> &s2);\nset<int> difference(set<int> &s1, set<int> &s2);\nset<int> symmetric_difference(set<int> &s1, set<int> &s2);\nset<int> parse(string &expr, mapset &sets, int &k);\nset<int> complement(mapset &sets, set<int> &s1);\n\nvoid print(set<int> s) {\n    cout << \"set: \";\n    for (set<int>::iterator it=s.begin(); it!=s.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n}\n\nset<int> atom(string &expr, mapset &sets, int &k) {\n    set<int> ret(sets[expr[k]]);\n    k ++;\n    return ret;\n}\n\nset<int> block(string &expr, mapset &sets, int &k) {\n    set<int> v;\n    if (expr[k] == '(') {\n        k ++;\n        v = parse(expr, sets, k);\n        k ++;\n        return v;\n    } else if (expr[k] == 'c') {\n        k ++;\n        v = block(expr, sets, k);\n        v = complement(sets, v);\n        return v;\n    } else {\n        v = atom(expr, sets, k);\n        return v;\n    }\n}\n\nset<int> unite(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.insert(*it);\n    }\n    return ret;\n}\n\nset<int> intersection(set<int> &s1, set<int> &s2) {\n    set<int> ret;\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        if (s1.find(*it) != s1.end()) {\n            ret.insert(*it);\n        }\n    }\n    return ret;\n}\n\nset<int> difference(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.erase(*it);\n    }\n    return ret;\n}\n\nset<int> symmetric_difference(set<int> &s1, set<int> &s2) {\n    set<int> dif1 = difference(s1, s2);\n    set<int> dif2 = difference(s2, s1);\n    return unite(dif1, dif2);\n}\n\nset<int> complement(mapset &sets, set<int> &s1) {\n    set<int> U;\n    for (mapset::iterator it=sets.begin(); it!=sets.end(); ++it) {\n        U = unite(U, it->second);\n    }\n    return difference(U, s1);\n}\n\nset<int> parse(string &expr, mapset &sets, int &k) {\n    set<int> v1 = block(expr, sets, k);\n    while (k < (int)expr.size() && expr[k] != ')') {\n        char op = expr[k];\n        k ++;\n        set<int> v2 = block(expr, sets, k);\n        if (op == 'u') {\n            v1 = unite(v1, v2);\n        } else if (op == 'i') {\n            v1 = intersection(v1, v2);\n        } else if (op == 'd') {\n            v1 = difference(v1, v2);\n        } else if (op == 's') {\n            v1 = symmetric_difference(v1, v2);\n        }\n    }\n    return v1;\n}\n\nvoid solve(string &expr, mapset &sets) {\n    int k = 0;\n    set<int> st = parse(expr, sets, k);\n    for (set<int>::iterator it=st.begin(); it!=st.end(); ++it) {\n        cout << (it == st.begin() ? \"\" : \" \") << *it;\n    }\n    cout << endl;\n}\n\nint main() {\n    char c; int k;\n    map<char, set<int> > sets;\n    while (cin >> c >> k) {\n        if (c != 'R') {\n            set<int> st; int t;\n            for (int i=0; i<k; ++i) {\n                cin >> t;\n                st.insert(t);\n            }\n            sets[c] = st;\n        } else {\n            string expr;\n            cin >> expr;\n            solve(expr, sets);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//18\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> v[5],u;\nconst char *e;\nint x;\n\nvector<int> exp();\n\nvector<int> ss(){\n  if(e[x]=='('){\n    x++;\n    vector<int> r=exp();\n    x++;\n    return r;\n  }else if(e[x]!='c'){\n    return v[e[x++]-'A'];\n  }else{\n    x++;\n    vector<int> l=ss(),a(u.size());\n    vector<int>::iterator it;\n    it=set_difference(u.begin(),u.end(),l.begin(),l.end(),a.begin());\n    a.resize(it-a.begin());\n    return a;\n  }\n}\n\nvector<int> exp(){\n  vector<int> l=ss();\n  string op=\"uids\";\n  for(char o=e[x];op.find(o)!=string::npos;o=e[x]){\n    x++;\n    vector<int> r=ss(),a(u.size());\n    vector<int>::iterator it;\n    if(o=='u'){\n      it=set_union(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='i'){\n      it=set_intersection(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='d'){\n      it=set_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else{\n      it=set_symmetric_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }\n    a.resize(it-a.begin());\n    l=a;\n  }\n  return l;\n}\n\nint main(){\n  for(;;){\n    for(int i=0;i<5;i++){\n      v[i].clear();\n    }\n    char c;\n    int n;\n    while(cin>>c>>n,c!='R'){\n      int x=c-'A';\n      v[x].resize(n);\n      while(n--){\n\tcin>>v[x][n];\n\tu.push_back(v[x][n]);\n      }\n      sort(v[x].begin(),v[x].end());\n    }\n    if(!cin)return 0;\n    sort(u.begin(),u.end());\n    u.resize(unique(u.begin(),u.end())-u.begin());\n    string s;\n    cin>>s;\n    e=s.c_str();\n    x=0;\n    vector<int> r=exp();\n    if(r.empty()){\n      cout<<\"NULL\"<<endl;\n    }else{\n      for(int i=0;i<r.size();i++){\n\tcout<<r[i]<<((i==r.size()-1)?'\\n':' ');\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>20) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\nint INF = (1<<24);\n\nvector<int> U;\nmap < int,bool > used;\n\nmap < char , vector<int> > t;\n\nstring str;\nint pos;\n\nbool input();\n\nvector<int> calc(vector<int>,char ch,vector<int>);\n\nvector<int> compute();\nvector<int> get();\n\nint main(){\n  vector<int> ans;\n  while(input()){\n    pos=0;\n    ans=compute();\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    if(ans.size()==0)cout<<\"NULL\";\n    cout<<endl;\n  }\n  return 0;\n}\n\n\nbool input(){\n  int n,a;\n  char ch;\n  U.clear();\n  used.clear();\n  t.clear();\n  while(1){\n    if(cin>>ch){\n    }else{\n      return false; \n    }\n    cin>>n;\n    if(ch=='R'&&n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a;\n\n      if(used[a]==false){U.push_back(a);used[a]=true;}\n\n      t[ch].push_back(a);\n    }\n    sort(t[ch].begin(),t[ch].end());\n  }\n  sort(U.begin(),U.end());\n  cin>>str;\n  str.push_back('=');\n  return true;\n}\n\nvector<int> calc(vector<int> A,char ch,vector<int> B){\n\n  int a=0,b=0,Asize=A.size(),Bsize=B.size(),nowA,nowB; \n  vector<int> res;\n\n  if(ch=='u'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n\n  }else if(ch=='i'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n\n  }else if(ch=='d'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n    \n  }else if(ch=='s'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n  }\n\n  return res;\n}\n\n\nvector<int> compute(){\n\n  vector<int> res,X;\n  char ch;\n  res=get();\n\n  while(1){\n    ch=str[pos++];\n    if(ch=='='||ch==')')break;\n    X=get();\n    res=calc(res,ch,X);\n  }\n\n  return res;\n}\n\n\nvector<int> get(){\n  if(str[pos]=='('){\n    pos++;\n    return compute();\n  }else if(str[pos]=='c'){\n    pos++;\n    return calc(U,'d',get());\n  }else{\n    pos++;\n    return t[str[pos-1]];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\nset<int> U;\nmap<char, set<int> > SET;\n \nset<int> solve(string s, int d) {\n//  cout << string(d, ' ') << s << endl;\n  int nest = 0;\n  set<int> res;\n  for (int i=s.size()-1; i>=0; --i) {\n//  REP(i, s.size()) {\n    if (s[i]=='(')\n      nest++;\n    else if (s[i]==')')\n      nest--;\n    else if (nest == 0) {\n      if (s[i]=='u' || s[i]=='i' || s[i]=='d' || s[i]=='s') {\n        set<int> A = solve(s.substr(0, i), d+1);\n        set<int> B = solve(s.substr(i+1), d+1);\n\n        if (s[i]=='u') {\n          res = A;\n          res.insert(ALL(B));\n        } else if (s[i]=='i') {\n          FOR(it, A) {\n            if (B.find(*it)!=B.end()) {\n              res.insert(*it);\n            }\n          }\n        } else if (s[i]=='d') {\n          FOR(it, A) {\n            if (B.find(*it)==B.end()) {\n              res.insert(*it);\n            }\n          }\n        } else if (s[i]=='s') {\n          FOR(it, A) {\n            if (B.find(*it)==B.end()) {\n              res.insert(*it);\n            }\n          }\n          FOR(it, B) {\n            if (A.find(*it)==A.end()) {\n              res.insert(*it);\n            }\n          }\n        }\n        // cout << string(d, ' ');\n        // FOR(it, res)\n        //   cout << *it << \" \";\n        // cout << endl;\n        return res;\n      }\n    }\n  }\n  \n  if (s[0] == '(') {\n    return solve(s.substr(1, s.size()-2), d+1);\n  } else if (s[0] == 'c'){\n    set<int> A = solve(s.substr(1), d+1);\n    FOR(it, U) {\n      if (A.find(*it) == A.end())\n        res.insert(*it);\n    }\n    // cout << string(d, ' ');\n    // FOR(it, res)\n    //   cout << *it << \" \";\n    // cout << endl;\n    return res;\n  }\n  // cout << string(d, ' ');\n  // FOR(it, SET[s[0]])\n  //   cout << *it << \" \";\n  // cout << endl;\n  return SET[s[0]];\n}\n\nint main() {\n  char c;\n  int m;\n  while(cin >> c>> m) {\n    U.clear();\n    SET.clear();\n    while(c!='R') {\n      REP(i, m) {\n        int a;\n        cin >> a;\n        SET[c].insert(a);\n        U.insert(a);\n      }\n      cin >> c >> m;\n    }\n    string s;\n    cin >> s;\n\n    set<int> res = solve(s,0);\n    int hoge = 0;\n    if (res.size() == 0)cout << \"NULL\";\n    FOR(it, res) {\n      if (hoge)\n        cout << \" \";\n      else hoge = 1;\n      cout << *it;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\ntypedef vector<int> vec;\n\nvec And(vec &a,vec &b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  int a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nchar c;\nstring s;\nint n;\nmap<char,set<ll>> m;\n\nvoid print(set<ll> s){\n    cout << \"set:\";\n    for(auto it = s.begin();it != s.end();it++){\n        cout << *it << \" \";\n    }\n    cout << endl;\n}\n\nset<ll> unite(set<ll> a,set<ll> b){\n    set<ll> res = a;\n    for(auto it = b.begin();it != b.end();it++)res.insert(*it);\n    return res;\n}\n\nset<ll> inter(set<ll> a,set<ll> b){\n    set<ll> res;\n    for(auto it = b.begin();it != b.end();it++){\n        if(a.find(*it) != a.end())res.insert(*it);\n    }\n    return res;\n}\n\nset<ll> differ(set<ll> a,set<ll> b){\n    set<ll> res;\n    for(auto it = a.begin();it != a.end();it++){\n        if(b.find(*it) == b.end())res.insert(*it);\n    }\n    return res;\n}\n\nset<ll> symme(set<ll> a,set<ll> b){\n    // cout << \"a\";\n    // print(a);\n    // cout << \"b\";\n    // print(b);\n    set<ll> res;\n    set<ll> U = unite(a,b);\n    set<ll> I = inter(a,b);\n    for(auto it = U.begin();it != U.end();it++){\n        if(I.find(*it) == I.end())res.insert(*it);\n    } \n    return res;\n}\n\nset<ll> comple(set<ll> a){\n    set<ll> res;\n    for(auto it = m['U'].begin();it != m['U'].end();it++){\n        if(a.find(*it) == a.end())res.insert(*it);\n    }\n    return res;\n}\n\nset<ll> term(int &i);\nset<ll> expr(int &i);\n\nset<ll> term(int &i){\n    // cout << \"!term\" << i << endl;\n    set<ll> res;\n    if(s[i] == '('){\n        i++;\n        res = expr(i);\n        i++;\n    }\n    else if(s[i] >= 'A' && s[i] <= 'E'){\n        res =  m[s[i]]; \n        i++;     \n    }\n    return res;\n}\n\nset<ll> expr(int &i){\n    // cout << \"!expr\" << i << endl;\n    set<ll> res = term(i);\n    while(1){\n        // cout << \"s[i]\" << s[i] << endl;\n        if(s[i] == 'u'){\n            i++;\n            res = unite(res,term(i));\n            // print(res);\n        }\n        else if(s[i] == 'i'){\n            i++;\n            res = inter(res,term(i));\n            // print(res);\n        }\n        else if(s[i] == 'd'){\n            i++;\n            res = differ(res,term(i));\n            // print(res);\n        }\n        else if(s[i] == 's'){\n            i++;\n            res = symme(res,term(i));\n            // print(res);\n        }\n        else if(s[i] == 'c'){\n            i++;\n            res = comple(term(i));\n            // print(res);\n        }\n        else break;\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        m.clear();\n        bool f = false;\n        while(cin >> c >> n && c != 'R'){\n            // cout << \"!\" << c << \" \" << n << endl;\n            f = true;\n            rep(i,n){\n                ll num;\n                cin >> num;\n                m[c].insert(num);\n                m['U'].insert(num);\n            }\n        }\n        if(!f)break;\n\n        cin >> s;\n        int i = 0;\n        set<ll> ans = expr(i);\n        // cout << \"!!\" <<  ans.size() << endl;\n        if(ans.size() == 0)cout << \"NULL\";\n        for(auto it = ans.begin();it != ans.end();it++){\n            if(it != ans.begin())cout << \" \";\n            cout << *it;\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <iterator>\n#include <vector>\nusing namespace std;\n\nconst char *ptr;\nvector<int> var[5], U;\n\nvector<int> parse();\n\nvector<int> factor(){\n\tif(*ptr == '('){\n\t\t++ptr;\n\t\tvector<int> x = parse();\n\t\t++ptr;\n\t\treturn x;\n\t}\n\treturn var[*ptr++ - 'A'];\n}\n\nvector<int> parse(){\n\tvector<int> tmp, x, y;\n\tback_insert_iterator<vector<int> > it(tmp);\n\n\tif(*ptr == 'c'){\n\t\t++ptr;\n\t\tx = factor();\n\t\tset_difference(U.begin(), U.end(), x.begin(), x.end(), it);\n\t\tx.swap(tmp);\n\t}\n\telse{\n\t\tx = factor();\n\t}\n\n\twhile(1){\n\t\ttmp.clear();\n\t\tif(*ptr == 'u'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_union(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse if(*ptr == 'i'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_intersection(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse if(*ptr == 'd'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_difference(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse if(*ptr == 's'){\n\t\t\t++ptr;\n\t\t\ty = factor();\n\t\t\tset_symmetric_difference(x.begin(), x.end(), y.begin(), y.end(), it);\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\n\t\tx.swap(tmp);\n\t}\n\t\n\treturn x;\n}\n\nint main(){\n\tstring s;\n\tchar ch;\n\tint n;\n\n\twhile(1){\n\t\tfor(int i = 0; i < 5; ++i){\n\t\t\tvar[i].clear();\n\t\t}\n\n\t\twhile(1){\n\t\t\tcin >> ch >> n;\n\t\t\tif(!cin) return 0;\n\t\t\tif(ch == 'R') break;\n\t\t\tvar[ch - 'A'].resize(n);\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tcin >> var[ch - 'A'][i];\n\t\t\t}\n\t\t}\n\n\t\tU.clear();\n\t\tfor(int i = 0; i < 5; ++i){\n\t\t\tsort(var[i].begin(), var[i].end());\n\t\t\tU.insert(U.end(), var[i].begin(), var[i].end());\n\t\t}\n\t\tsort(U.begin(), U.end());\n\t\tU.erase(unique(U.begin(), U.end()), U.end());\n\n\t\tcin >> s;\n\t\tptr = s.c_str();\n\n\t\tvector<int> ret = parse();\n\t\tif(ret.empty()){\n\t\t\tputs(\"NULL\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\", ret[0]);\n\t\t\tfor(int i = 1; i < ret.size(); ++i){\n\t\t\t\tprintf(\" %d\", ret[i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>23) break;\n\t\t\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nset<int> s[10],a;\nstring t;\nset<int> expr(int &p);\nset<int> term(int &p);\nset<int> factor(int &p);\nset<int> unio(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x) res.insert(i);\n  for(int i:y) res.insert(i);\n  return res;\n}\nset<int> inte(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x)\n    if(y.count(i)) res.insert(i);\n  return res;\n}\nset<int> diff(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x)\n    if(!y.count(i)) res.insert(i);\n  return res;\n}\nset<int> symm(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x)\n    if(!y.count(i)) res.insert(i);\n  for(int i:y)\n    if(!x.count(i)) res.insert(i);\n  return res;\n}\nset<int> comp(set<int> x){\n  set<int> res;\n  for(int i:a)\n    if(!x.count(i)) res.insert(i);\n  return res;\n}\nset<int> expr(int &p){\n  set<int> res=term(p);\n  while(p<(int)t.size()){\n    if(t[p]=='u'){\n      p++;\n      res=unio(res,term(p));\n      continue;\n    }\n    if(t[p]=='i'){\n      p++;\n      res=inte(res,term(p));\n      continue;\n    }\n    if(t[p]=='d'){\n      p++;\n      res=diff(res,term(p));\n      continue;\n    }\n    if(t[p]=='s'){\n      p++;\n      res=symm(res,term(p));\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nset<int> term(int &p){\n  set<int> res;\n  if(t[p]=='c'){\n    p++;\n    res=comp(term(p));\n  }else if(t[p]=='('){\n    p++;\n    res=expr(p);\n    p++;\n  }else{\n    res=factor(p);\n  }\n  return res;\n}\nset<int> factor(int &p){\n  set<int> res=s[t[p++]-'A'];\n  return res;\n}\n\n\nsigned main(){\n  char c;\n  while(cin>>c){\n    for(int i=0;i<10;i++) s[i].clear();\n    a.clear();\n    int x[10];\n    int k=0;\n    do{\n      cin>>x[k];\n      for(int i=0,t;i<x[k];i++){\n\tcin>>t;\n\ts[c-'A'].insert(t);\n\ta.insert(t);\n      }\n    }while(cin>>c,c!='R');\n    int p;\n    cin>>p>>t;\n    set<int> ans=expr(p);\n    bool f=0;\n    for(int i:ans){\n      if(f) cout<<\" \";\n      f=1;\n      cout<<i;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\ntypedef struct ParseResult {\n    bool flag;\n    bool isVector;\n    PII  value;\n} RES;\n\ntypedef std::set<int> SI;\n\nstd::set< char > ops;\nstd::map< char, SI > sets;\nSI uni;\n\n// Exp = Set {('u' | 'i' | 'd' | 's') Set}*\n// Set = '(' Exp ')' | Name\n// Name = setNames\n\nSI parseExp(State* s);\nSI parseSet(State* s);\n\nvoid printSet(SI set) {\n    EACH(it, set) {\n        std::cout << \" \" << *it;\n    }\n}\n\nSI parseExp(State* s) {\n    SI set1 = parseSet(s);\n\n    char op;\n    while( op = s->seek(), op != -1 && op != ')') {\n        s->eat(op);\n\n        SI set2 = parseSet(s);\n        if(op == 'u') {\n            EACH(it, set2) {\n                set1.insert(*it);\n            }\n        } else if(op == 'i') {\n            SI set_i = set1;\n            EACH(it, set1) {\n                if(set2.count(*it) == 0) {\n                    set_i.erase(*it);\n                }\n            }\n            set1 = set_i;\n        } else if(op == 'd') {\n            EACH(it, set2) {\n                set1.erase(*it);\n            }\n        } else if(op == 's') {\n            SI set_u = set1;\n            EACH(it, set2) {\n                set_u.insert(*it);\n            }\n\n            SI set_i = set1;\n            EACH(it, set1) {\n                if(set2.count(*it) == 0) {\n                    set_i.erase(*it);\n                }\n            }\n\n            EACH(it, set_i) {\n                set_u.erase(*it);\n            }\n            set1 = set_u;\n        }\n    }\n    return set1;\n}\n\nSI parseSet(State* s) {\n    if(s->seek() == '(') {\n        s->eat('(');\n        SI res = parseExp(s);\n        s->eat(')');\n        return res;\n    }\n\n    bool c = (s->seek() == 'c');\n    if(c) s->eat('c');\n\n    char name = s->getCh();\n    if(sets.count(name) > 0) {\n        SI set1 = sets[name];\n        if(!c) {\n            return set1;\n        }\n\n        SI set2 = uni;\n        EACH(it, set1) {\n            set2.erase(*it);\n        }\n        return set2;\n    } else {\n        return SI();\n    }\n}\n\nint main () {\n    ops.insert('u'), ops.insert('i'), ops.insert('d'), ops.insert('s');\n\n    char c;\n    int n;\n    while(std::cin >> c >> n) {\n        SI set;\n        REP(i, n) {\n            int x;\n            std::cin >> x;\n            set.insert(x);\n            uni.insert(x);\n        }\n        sets[c] = set;\n\n        while(std::cin >> c >> n) {\n            if(c == 'R' && n == 0) break;\n            set.clear();\n\n            REP(i, n) {\n                int x;\n                std::cin >> x;\n                set.insert(x);\n                uni.insert(x);\n            }\n            sets[c] = set;\n        }\n\n        std::string e;\n        std::cin >> e;\n    \n        State state = State {0, (int)e.length(), e};\n        SI res = parseExp(&state);\n\n        if(res.size() == 0) {\n            std::cout << \"NULL\\n\";\n        } else {\n            int i = 0;\n            EACH(it, res) {\n                if(i++ != 0) std::cout << ' ';\n                std::cout << *it;\n            }\n            std::cout << std::endl;\n        }\n        sets.clear();\n        uni.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele){\n        this->ele = ele;\n        it = s.begin();\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> ele;\n        set<int> U;\n        \n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            ele[ch] = st;\n        }while(cin >> ch >> N);\n\n        ele['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP equation(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  return factor(str,numbers,U,pos);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(1){\n    if(pos >= str.size()){\n      break;\n    }\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else{\n      break;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = equation(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        goto skip;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        cin >> num;\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n  skip:;\n    string text;\n    cin >> text;\n    P r = equation(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n        printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<sstream>\n#include<iterator>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define osi ostream_iterator<int>\n#define all(c) c.begin(),c.end()\nusing namespace std;\ntypedef set<int> si;\nsi sCalc(char o,si l,si r){\n\tint t;si a;stringstream ss;\n\tswitch(o){\n\tcase 'u':\n\t\tset_union(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'i':\n\t\tset_intersection(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'd':\n\t\tset_difference(all(l),all(r),osi(ss,\" \"));break;\n\tcase 's':\n\t\tset_symmetric_difference(all(l),all(r),osi(ss,\" \"));break;\n\t}\n\twhile(ss>>t)a.insert(t);\n\treturn a;\n}\nsi st[5],u,ans; string expr;\nsi prs(int s,int t){\n\tint oi,p=0;char c;\n\tfor(oi=s;oi<t;oi++){\n\t\tc=expr[oi];if(c=='(')p++;if(c==')')p--;\n\t\tif(p==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(oi==t){\n\t\tif(expr[s]=='(')return prs(s+1,t-1);\n\t\tif(s+1==t)return st[expr[s]-'A'];\n\t\tif(expr[s]=='c')return sCalc('d',u,prs(s+1,t));\n\t}\n\treturn sCalc(expr[oi],prs(s,oi),prs(oi+1,t));\n}\nint main(){\n\tchar c; int k,t;\n\twhile(cin>>c>>k){\n\t\tif(c=='R'){\n\t\t\tcin>>expr;ans=prs(0,expr.size());\n\t\t\tfor(__typeof(ans.begin()) i=ans.begin();i!=ans.end();i++){\n\t\t\t\tif(i!=ans.begin())cout<<\" \";\n\t\t\t\tcout<<*i;\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,5)st[i].clear();u.clear();\n\t\t}else rep(i,k)cin>>t,st[c-'A'].insert(t),u.insert(t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef string::const_iterator State;\n\nset<int> expression(State &begin);\nset<int> term(State &begin);\nset<int> factor(State &begin);\nset<int> elem(State &begin);\n\nmap<char, set<int>> m;\nset<int> all;\n\nset<int> expression(State &begin){\n    set<int> ret = term(begin);\n    while(1){\n        if(*begin == 'i'){\n            begin++;\n            set<int> tmp = term(begin), res;\n            for(int val : ret)  if(tmp.count(val))  res.insert(val);\n            ret = res;\n        }else if(*begin == 'u'){\n            begin++;\n            set<int> tmp = term(begin);\n            for(int val : tmp)  ret.insert(val);\n        }else if(*begin == 'd'){\n            begin++;\n            set<int> tmp = term(begin), res;\n            for(int val : ret)  if(tmp.count(val) == 0) res.insert(val);\n            ret = res;\n        }else if(*begin == 's'){\n            begin++;\n            set<int> tmp = term(begin), res;\n            for(int val : ret)  if(tmp.count(val) == 0) res.insert(val);\n            for(int val : tmp)  if(ret.count(val) == 0) res.insert(val);\n            ret = res;\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nset<int> term(State &begin){\n    if(*begin == 'c'){\n        begin++;\n        set<int> tmp = factor(begin);\n        set<int> ret;\n        for(int x : all)    if(tmp.count(x) == 0)   ret.insert(x);\n        return ret;\n    }else{\n        return factor(begin);\n    }\n}\n\nset<int> factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        set<int> tmp = expression(begin);\n        begin++;    // )\n        return tmp;\n    }else{\n        return elem(begin);\n    }\n}\n\nset<int> elem(State &begin){\n    set<int> ret = m[*begin];\n    begin++;\n    return ret;\n}\n\nint main(){\n    char c;\n    int n;\n    while(cin >> c >> n){\n        m.clear();\n        all.clear();\n        while(c != 'R'){\n            for(int i = 0; i < n; i++){\n                int x;  cin >> x;\n                m[c].insert(x);\n                all.insert(x);\n            }\n            cin >> c >> n;\n        }\n        string s;\n        cin >> s;\n        State it = s.begin();\n        set<int> res = expression(it);\n        if(res.size()){\n            for(set<int>::iterator it = res.begin(); it != res.end(); it++){\n                if(it != res.begin())   cout << \" \";\n                cout << *it;\n            }\n            cout << endl;\n        }else{\n            cout << \"NULL\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 501;\n\nchar A[5][MAXN];\nint pos;\nstring line;\n\nvector<char> exp();\nvector<char> fact();\n\nvector<char> exp() {\n  vector<char> res = fact();\n  while(1) {\n    if(line[pos] == 'u') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] || x[i]);\n      }\n    } else if(line[pos] == 'i') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && x[i]);\n      }\n    } else if(line[pos] == 'd') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && !x[i]);\n      }\n    } else if(line[pos] == 's') {\n      ++pos;\n      vector<char> x = fact();\n      vector<char> a(res.size(),0), b(res.size(),0);\n      for(int i = 0; i< x.size(); ++i) {\n\ta[i] = (res[i] && !x[i]);\n      }\n      for(int i = 0; i< x.size(); ++i) {\n\tb[i] = (x[i] && !res[i]);\n      }\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (a[i] || b[i]);\n      }\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nvector<char> fact() {\n  vector<char> res;\n  if(line[pos] == 'c') {\n    ++pos;\n    res = fact();\n    for(int i = 0; i < res.size(); ++i) {\n      res[i] = 1-res[i];\n    }\n  } else if(isupper(line[pos])) {\n    char c = line[pos];\n    ++pos;\n    res = vector<char>(A[c-'A'], A[c-'A']+MAXN);\n  } else if(line[pos] == '(') {\n    ++pos;\n    res = exp();\n    ++pos;\n  }\n  return res;\n}\n\nint main() {\n  while(1) {\n    bool run = true;\n    set<int> num;\n    fill(A[0], A[5], false);\n    while(1) {\n      char c;\n      int n;\n      if(!(cin >> c >> n)) {\n\trun = false;\n\tbreak;\n      }\n      if(c == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i) {\n\tint a;\n\tcin >> a;\n\tnum.insert(a);\n\tA[c-'A'][a] = true;\n      }\n    }\n    if(!run) break;\n    string s;\n    cin >> s;\n    line = s;\n    pos = 0;\n    vector<char> res = exp();\n    for(int i = 0, cnt = 0; i < res.size(); ++i) {\n      if(num.count(i) && res[i]) {\n\tif(cnt++) cout << \" \";\n\tcout << i;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,const vector<int>& U, int pos);\nP term(const string& str,const vector<int>& U, int pos);\nvector<int> numbers[256];\nvector<int> U;\n\nP factor(const string& str,const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    P r2 = term(str,U,pos+1);\n    if(str[pos] == 'u'){\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str, const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,U,pos+1);\n    return P(r.first,compute_complement(r.second,U));\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    char alphabet[8];\n    int num_of_elements;\n    while(1){\n      if(!(cin >> alphabet >> num_of_elements)){\n        return 0;\n      }\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < 256; i++){\n      numbers[i].clear();\n    }\n    U.clear();\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\ntypedef set<int>S;\nS s['U'+1];\nS::iterator q;\nchar e[9999];\nint p;\nS PT();\nS OU(S a,S b){\n\tfor(q=b.begin();q!=b.end();++q)\n\t\ta.insert(*q);\n\treturn a;\n}\nS OD(S a,S b){\n\tfor(q=b.begin();q!=b.end();++q)\n\t\ta.erase(*q);\n\treturn a;\n}\nS OS(S a,S b){\n\tfor(q=b.begin();q!=b.end();++q)\n\t\tif(a.erase(*q)==0)\n\t\t\ta.insert(*q);\n\treturn a;\n}\nS OC(S a){\n\treturn OD(s['U'],a);\n}\nS OI(S a,S b){\n\treturn OD(a,OC(b));\n}\nS PB(){\n\tS a=PT();\n\tfor(;;){\n\t\tif(e[p]=='u'){\n\t\t\tp++;\n\t\t\ta=OU(a,PT());\n\t\t}else if(e[p]=='i'){\n\t\t\tp++;\n\t\t\ta=OI(a,PT());\n\t\t}else if(e[p]=='d'){\n\t\t\tp++;\n\t\t\ta=OD(a,PT());\n\t\t}else if(e[p]=='s'){\n\t\t\tp++;\n\t\t\ta=OS(a,PT());\n\t\t}else \n\t\t\treturn a;\n\t}\n}\nS PT(){\n\tS a;\n\tint c=0;\n\tif(e[p]=='('){\n\t\tp++;\n\t\ta=PB();\n\t\tp++;\n\t}else if(e[p]=='c'){\n\t\tp++;\n\t\ta=OC(PT());\n\t}else{\n\t\ta=s[e[p]];\n\t\tp++;\n\t}\n\treturn a;\n}\nint main(){\n\tchar n;\n\tint m,v;\n\tfor(;cin>>n>>m;){\n\t\tif(n!='R'){\n\t\t\ts[n].clear();\n\t\t\tfor(;m--;){\n\t\t\t\tcin>>v;\n\t\t\t\ts[n].insert(v);\n\t\t\t\ts['U'].insert(v);\n\t\t\t}\n\t\t}else{\n\t\t\tcin>>e;\n\t\t\tp=0;\n\t\t\tS r=PB();\n\t\t\tfor(q=r.begin();q!=r.end();++q){\n\t\t\t\tif(!p)\n\t\t\t\t\tcout<<' ';\n\t\t\t\tp=0;\n\t\t\t\tcout<<*q;\n\t\t\t}\n\t\t\tcout<<'\\n';\n\t\t\ts['U'].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[10];\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0, l = s.size();\n  set<int> a,b,res;\n\n  if(!s.size())return res;\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p && ('a'<=s[i] && s[i]<='z' && s[i]!='c')){\n      a = parse(s.substr(0,i));\n      b = parse(s.substr(i+1,l-i-1));\n      if(s[i] == 'u'){\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = alp[0].begin();ite!=alp[0].end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  }\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n,tmp;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<6;i++)alp[i].clear();\n    while(c != 'R'){\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m[c]].insert(tmp);\n\talp[0].insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é.\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n\tif(str[0]=='c'){\n\t\treturn Complement(analysis(str.substr(1)),sets['U']);\n\t}\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\t//for(char ch='A'; ch <= 'E'; ch++){\n\t\t//\tsets[ch];\n\t\t//}\n\t\t//sets['U'];\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  else for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string s;\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele) :\n        s(s), ele(ele) {\n        it = s.begin();\n    }\n\n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            if(*it == 'd'){\n                ++it;\n                b = term();\n                a = difference(a, b);\n            }else if(*it == 'i'){\n                ++it;\n                b = term();\n                a = intersection(a, b);\n            }else if(*it == 's'){\n                ++it;\n                b = term();\n                a = sym_difference(a, b);\n            }else if(*it == 'u'){\n                ++it;\n                b = term();\n                a = union_(a, b);\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    bool eof_ = 0;\n    while(1)\n    {\n        map<char, set<int>> ele;\n        while(1)\n        {\n            if(cin >> ch >> N){\n                if(ch == 'R') break;\n                set<int> st;\n                for(int i = 0 ; i < N ; i++){\n                    cin >> x;\n                    st.insert(x);\n                }\n                    \n                ele[ch] = st;\n                for(auto x : st){\n                    ele['U'].insert(x);\n                }\n            }else{\n                eof_ = 1;\n                break;\n            }\n        }\n        if(eof_) break;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res)\n            {\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <string>\n#include <stack>\nusing namespace std;\n\ntemplate<class T>\nvoid print_set(set<T>& setA)\n{\n  typename set<T>::iterator it;\n  int n = 0;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    n++;\n    if (n != setA.size()) printf(\"%d \", *it);\n    else printf(\"%d\\n\", *it);\n  }\n}\n\n// ?????????????¨????\ntemplate<class T>\nset<T> union_set(set<T>& setA, set<T>& setB)\n{\n  set<T> res(setA);\n  typename set<T>::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.insert(*it);\n  }\n  return res;\n}\n\n// ?????????????¨????\ntemplate<class T>\nset<T> intersection_set(set<T>& setA, set<T> &setB)\n{\n  set<T> res;\n  typename set<T>::iterator it;\n\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    if (setA.find(*it) != setA.end())\n    {\n      res.insert(*it);\n    }\n  }\n  return res;\n}\n\n\n// ?£???????????¨????\ntemplate<class T>\nset<T> complement(set<T>& setA, set<T>& U)\n{\n  set<T> res(U);\n  typename set<T>::iterator it;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A-B\ntemplate<class T>\nset<T> difference(set<T>& setA, set<T>& setB)\n{\n  set<T> res(setA);\n  typename set<T>::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A . B\ntemplate <class Set>\nSet symmetric_difference(Set& setA, Set& setB)\n{\n  Set s1 = union_set(setA, setB);\n  Set s2 = intersection_set(setA, setB);\n  return difference(s1, s2);\n}\n\nstring rev_polish_notation(string& exp)\n{\n  stack<char> stk;\n  string rexp;\n  string::iterator it;\n\n  for (it = exp.begin(); it != exp.end(); ++it)\n  {\n    if (*it == '(')\n    {\n      stk.push(*it);\n    }\n    else if (*it == ')')\n    {\n      while (stk.top() != '(')\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.pop();                // top???'('???????????????\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      while ((!stk.empty()) && (stk.top() == 'c'))\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.push(*it);\n    }\n    else if (*it == 'c')\n    {\n      stk.push(*it);\n    }\n    else if ((*it == 'A') || (*it == 'B') || (*it == 'C') || (*it == 'D') || (*it == 'E'))\n    {\n      rexp = rexp + (*it);\n    }\n  }\n\n  while (!stk.empty())\n  {\n    char tkn = stk.top();\n    rexp = rexp + tkn;\n    stk.pop();\n  }\n\n  return rexp;\n}\n\n\ntemplate <class Set>\nSet set_operation(string& exp, Set& A, Set& B, Set& C, Set& D, Set& E, Set& U)\n{\n  Set S;\n  string rexp = rev_polish_notation(exp); // ???????????????????¨????\n  stack<Set> stk;\n\n  string::iterator it;\n  for (it = rexp.begin(); it != rexp.end(); ++it)\n  {\n    if (*it == 'A') { stk.push(A); }\n    else if (*it == 'B') { stk.push(B); }\n    else if (*it == 'C') { stk.push(C); }\n    else if (*it == 'D') { stk.push(D); }\n    else if (*it == 'E') { stk.push(E); }\n    else if (*it == 'c')\n    {\n      Set s = stk.top();\n      stk.pop();\n      stk.push(complement(s, U));\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      Set s1 = stk.top();\n      stk.pop();\n      Set s2 = stk.top();\n      stk.pop();\n      Set ans;\n\n      switch (*it)\n      {\n      case 'u': stk.push(union_set(s1, s2)); break;\n      case 'i': stk.push(intersection_set(s1, s2)); break;\n      case 'd': stk.push(difference(s2, s1)); break; // ????????????????????¨???\n      case 's': stk.push(symmetric_difference(s1, s2)); break;\n      }\n    }\n  }\n  return stk.top();\n}\n\n\nint main() {\n  set<int> A, B, C, D, E, U;\n  char name;\n  int num;\n  int e;\n  string exp;\n\n  while (cin >> name >> num)\n  {\n    switch (name)\n    {\n    case 'A':\n      for (int i=0;i<num;i++) { cin >> e; A.insert(e); U.insert(e); }\n      break;\n    case 'B':\n      for (int i=0;i<num;i++) { cin >> e; B.insert(e); U.insert(e); }\n      break;\n    case 'C':\n      for (int i=0;i<num;i++) { cin >> e; C.insert(e); U.insert(e); }\n      break;\n    case 'D':\n      for (int i=0;i<num;i++) { cin >> e; D.insert(e); U.insert(e); }\n      break;\n    case 'E':\n      for (int i=0;i<num;i++) { cin >> e; E.insert(e); U.insert(e); }\n      break;\n    case 'R':\n      cin.ignore();             // ??????????????????????£???°???\n      getline(cin, exp);\n\n      set<int> res = set_operation(exp,A,B,C,D,E,U);\n      print_set(res);\n\n      // ??????????????????????¶???????\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      U.clear();\n      break;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n\nstd::vector<std::string> ops={\"uidsc\"};\n\nstd::set<int> parse(const std::string& s, size_t& i, size_t preced,\n                    const std::map<char, std::set<int>>& sets) {\n\n  if (preced == ops.size()) {\n    if (isupper(s[i])) return sets.at(s[i++]);\n    if (s[i] == 'c') {\n      auto cmpl=parse(s, ++i, preced, sets);\n      std::set<int> res;\n      for (int x: sets.at('U'))\n        if (!cmpl.count(x)) res.insert(x);\n      return res;\n    }\n    if (s[i] == '(') {\n      auto res=parse(s, ++i, 0, sets);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    assert(false);\n  }\n\n  auto res=parse(s, i, preced+1, sets);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    auto rhs=parse(s, ++i, preced+1, sets);\n\n    if (op == 'u') {\n      for (int x: rhs) res.insert(x);\n    } else if (op == 'i') {\n      std::set<int> tmp;\n      for (int x: res)\n        if (rhs.count(x)) tmp.insert(x);\n      res = std::move(tmp);\n    } else if (op == 'd') {\n      std::set<int> tmp;\n      for (int x: res)\n        if (!rhs.count(x)) tmp.insert(x);\n      res = std::move(tmp);\n    } else if (op == 's') {\n      std::set<int> tmp;\n      for (int x: res)\n        if (!rhs.count(x)) tmp.insert(x);\n      for (int x: rhs)\n        if (!res.count(x)) tmp.insert(x);\n      res = std::move(tmp);\n    }\n  }\n  return res;\n}\n\nint testcase_ends() {\n  std::set<int> U;\n  std::map<char, std::set<int>> sets;\n\n  while (true) {\n    char name;\n    size_t n;\n    if (scanf(\" %c %zu\", &name, &n) == EOF) return 1;\n    if (name == 'R' && n == 0) break;\n    std::set<int> tmp;\n    for (size_t i=0; i<n; ++i) {\n      int a;\n      scanf(\"%d\", &a);\n      U.insert(a);\n      tmp.insert(a);\n    }\n    sets[name] = tmp;\n  }\n  sets['U'] = U;\n\n  char buf[131072];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  size_t i=0;\n  std::set<int> res=parse(s, i, 0, sets);\n  if (res.empty()) {\n    puts(\"NULL\");\n  } else {\n    for (auto it=res.cbegin(); it!=res.cend(); ++it) {\n      printf(\"%d%c\", *it, std::next(it)!=res.cend()? ' ':'\\n');\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint rst(int);\nvector<vector<int> > se;\nvector<set<int> > vse;\nvector<int> u;\nstring st;\nint main(){\n  while(1){\n    \n    se=vector<vector<int> >(5);\n    vse=vector<set<int> >(5);\n    while(1){\n      char ch;\n      int n;\n      cin >> ch >> n;\n      if(cin.eof())return 0;\n      if(ch=='R'&&n==0)break;\n      for(int i=0;i<n;i++){\n\tint num;\n\tcin >> num;\n\tse[ch-'A'].push_back(num);\n\tvse[ch-'A'].insert(num);\n\t//\tuse.insert(se[ch-'A'][i]);\n\tu.push_back(num);\n      }\n    }\n    st=\"\";\n    cin >> st;\n    st+=')';\n    int ans;\n    ans=rst(0);\n    sort(se[ans].begin(),se[ans].end());\n    if(se[ans].size()==0)cout << \"NULL\" << endl;\n    else {for(int i=0;i<se[ans].size();i++){\n      if(i)cout << \" \";\n      cout << se[ans][i];\n    }\n    cout << endl;\n    }\n  }\n  return 0;\n}\nint rst(int I){\n  int m1=-1,m2=-1;\n  int kc=1;\n  int fu=0;//1u2i3d4s\n  int csw=0;\n  for(int i=I;i<st.size();i++){\n    //cout << fu << \" \"<< i<< endl;\n    if(st[i]=='('){\n      kc++;\n      if(kc==2){\n\t//cout << \"in\" << endl;\n\tm2=rst(i+1);\n      }\n    }\n    else if(st[i]==')'){\n      kc--;\n      if(kc==0){\n\t//cout << \"out\" << endl;\n\treturn m1;\n      }\n    }\n    else if(kc>1)continue;\n    else if(st[i]=='u')fu=1;\n    else if(st[i]=='i')fu=2;\n    else if(st[i]=='d')fu=3;\n    else if(st[i]=='s')fu=4;\n    else if(st[i]=='c')csw=1;\n    else if(st[i]>='A'&&st[i]<='E'){\n      m2=st[i]-'A';\n      if(csw){\n\tcsw=0;\n\tvector<int> b;\n\tset<int> bse;\n\tfor(int i=0;i<u.size();i++){\n\t  if(!vse[m2].count(u[i])){\n\t    b.push_back(u[i]);\n\t    bse.insert(u[i]);\n\t  }\n\t}\n\tse.push_back(b);\n\tvse.push_back(bse);\n\tm2=vse.size()-1;\n      }\n    }\n    if(m1==-1){\n      m1=m2;\n      m2=-1;\n    }\n    else if(m1>=0&&m2>=0){\n      vector<int> bu;\n      set<int> buse;\n      if(fu==1){\n\t//cout << \"f1\"<< endl;\n\tbu=se[m1];\n\tbuse=vse[m1];\n\tfor(int i=0;i<se[m2].size();i++){\n\t  if(!buse.count(se[m2][i]))bu.push_back(se[m2][i]);\n\t  buse.insert(se[m2][i]);\n\t}\n      }\n      else if(fu==2){\n\t//cout << \"f2\"<< endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      }\n      else if(fu==3){\n\t//cout << \"f3\"<< endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(!vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      }\n      else if(fu==4){\n\t//cout << \"fu4\" << endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(!vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      \tfor(int i=0;i<se[m2].size();i++){\n\t  if(!vse[m1].count(se[m2][i])){\n\t    bu.push_back(se[m2][i]);\n\t    buse.insert(se[m2][i]);\n\t  }\n\t}\n      }\n      se.push_back(bu);\n      vse.push_back(buse);\n      m1=vse.size()-1;\n      m2=-1;\n      fu=0;\n    }\n    //    cout << m1 << \" \" << m2 << endl; \n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "//18\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> v[5],u;\nconst char *e;\nint x;\n\nvector<int> exp();\n\nvector<int> ss(){\n  if(e[x]=='('){\n    x++;\n    vector<int> r=exp();\n    x++;\n    return r;\n  }else if(e[x]!='c'){\n    return v[e[x++]-'A'];\n  }else{\n    x++;\n    vector<int> l=ss(),a(u.size());\n    vector<int>::iterator it;\n    it=set_difference(u.begin(),u.end(),l.begin(),l.end(),a.begin());\n    a.resize(it-a.begin());\n    return a;\n  }\n}\n\nvector<int> exp(){\n  vector<int> l=ss();\n  string op=\"uids\";\n  for(char o=e[x];op.find(o)!=string::npos;o=e[x]){\n    x++;\n    vector<int> r=ss(),a(u.size());\n    vector<int>::iterator it;\n    if(o=='u'){\n      it=set_union(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='i'){\n      it=set_intersection(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='d'){\n      it=set_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else{\n      it=set_symmetric_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }\n    a.resize(it-a.begin());\n    l=a;\n  }\n  return l;\n}\n\nint main(){\n  for(;;){\n    for(int i=0;i<5;i++){\n      v[i].clear();\n    }\n    char c;\n    int n;\n    while(cin>>c>>n,cin&&c!='R'){\n      int x=c-'A';\n      v[x].resize(n);\n      while(n--){\n\tcin>>v[x][n];\n\tu.push_back(v[x][n]);\n      }\n      sort(v[x].begin(),v[x].end());\n    }\n    if(!cin)return 0;\n    sort(u.begin(),u.end());\n    u.resize(unique(u.begin(),u.end())-u.begin());\n    string s;\n    cin>>s;\n    e=s.c_str();\n    x=0;\n    vector<int> r=exp();\n    if(r.empty()){\n      cout<<endl;\n    }else{\n      for(int i=0;i<r.size();i++){\n\tcout<<r[i]<<((i==r.size()-1)?'\\n':' ');\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\ntypedef struct ParseResult {\n    bool flag;\n    bool isVector;\n    PII  value;\n} RES;\n\ntypedef std::set<int> SI;\n\nstd::set< char > ops;\nstd::map< char, SI > sets;\nSI uni;\n\n// Exp = Set {('u' | 'i' | 'd' | 's') Set}*\n// Set = '(' Exp ')' | Name\n// Name = setNames\n\nSI parseExp(State* s);\nSI parseSet(State* s);\n\nvoid printSet(SI set) {\n    EACH(it, set) {\n        std::cout << \" \" << *it;\n    }\n}\n\nSI parseExp(State* s) {\n    SI set1 = parseSet(s);\n\n    char op;\n    while( op = s->seek(), op != -1 && op != ')') {\n        s->eat(op);\n\n        SI set2 = parseSet(s);\n        if(op == 'u') {\n            EACH(it, set2) {\n                set1.insert(*it);\n            }\n        } else if(op == 'i') {\n            SI set_i = set1;\n            EACH(it, set1) {\n                if(set2.count(*it) == 0) {\n                    set_i.erase(*it);\n                }\n            }\n            set1 = set_i;\n        } else if(op == 'd') {\n            EACH(it, set2) {\n                set1.erase(*it);\n            }\n        } else if(op == 's') {\n            SI set_u = set1;\n            EACH(it, set2) {\n                set_u.insert(*it);\n            }\n\n            SI set_i = set1;\n            EACH(it, set1) {\n                if(set2.count(*it) == 0) {\n                    set_i.erase(*it);\n                }\n            }\n\n            EACH(it, set_i) {\n                set_u.erase(*it);\n            }\n            set1 = set_u;\n        }\n    }\n    return set1;\n}\n\nSI parseSet(State* s) {\n    if(s->seek() == '(') {\n        s->eat('(');\n        SI res = parseExp(s);\n        s->eat(')');\n        return res;\n    }\n\n    bool c = (s->seek() == 'c');\n    if(c) s->eat('c');\n\n    char name = s->getCh();\n    if(sets.count(name) > 0) {\n        SI set1 = sets[name];\n        if(!c) {\n            return set1;\n        }\n\n        SI set2 = uni;\n        EACH(it, set1) {\n            set2.erase(*it);\n        }\n        return set2;\n    } else {\n        return SI();\n    }\n}\n\nint main () {\n    ops.insert('u'), ops.insert('i'), ops.insert('d'), ops.insert('s');\n\n    char c;\n    int n;\n    while(std::cin >> c >> n) {\n        SI set;\n        REP(i, n) {\n            int x;\n            std::cin >> x;\n            set.insert(x);\n            uni.insert(x);\n        }\n        sets[c] = set;\n\n        while(std::cin >> c >> n) {\n            if(c == 'R' && n == 0) break;\n            set.clear();\n\n            REP(i, n) {\n                int x;\n                std::cin >> x;\n                set.insert(x);\n                uni.insert(x);\n            }\n            sets[c] = set;\n        }\n\n        std::string e;\n        std::cin >> e;\n    \n        State state = State {0, (int)e.length(), e};\n        SI res = parseExp(&state);\n\n        if(res.size() == 0) {\n            std::cout << std::endl;\n        } else {\n            int i = 0;\n            EACH(it, res) {\n                if(i++ != 0) std::cout << ' ';\n                std::cout << *it;\n            }\n            std::cout << std::endl;\n        }\n        sets.clear();\n        uni.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>11) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  ll a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len){\n    char ch=s[pos];\n    if(ch==')')break;\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      if(ch=='R')break;\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    mp['U']=U;\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i&&ans[i]==ans[i-1])continue;\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nusing S = set<int>;\nS U;\nmap<char, S> m;\n\nstring s;\nint N;\nint c;\n\nS expr();\nS factor();\nS num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \" + s << endl;\n\tfor(int i = 0; i < text.size() + 1 + N; i++){\n\t\tif(i == text.size() + 1 + c) cout << \"*\";\n\t\telse cout << \" \";\n\t}\n\tcout << endl;\n}\n\nS Union(S s1, S s2){\n\tfor(auto v : s2){\n\t\ts1.insert(v);\n\t}\n\treturn s1;\n}\n\nS Intersection(S s1, S s2){\n\tS ret;\n\tfor(auto v : s2){\n\t\tif(s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Diff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS SymDiff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\tfor(auto v : s2){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Comp(S s1){\n\tS ret;\n\tfor(auto v : U){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS expr(){\n\tdebug(\"expr\");\n\tS x = factor();\n\twhile(c < N){\n\t\tif(s[c] == 'u'){\n\t\t\tc++;\n\t\t\tx = Union(x, factor());\n\t\t}\n\t\telse if(s[c] == 'i'){\n\t\t\tc++;\n\t\t\tx = Intersection(x, factor());\n\t\t}\n\t\telse if(s[c] == 'd'){\n\t\t\tc++;\n\t\t\tx = Diff(x, factor());\n\t\t}\n\t\telse if(s[c] == 's'){\n\t\t\tc++;\n\t\t\tx = SymDiff(x, factor());\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nS factor(){\n\tdebug(\"factor\");\n\tbool rev = false;\n\tif(s[c] == 'c'){\n\t\trev = 1;\n\t\tc++;\n\t}\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tS ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\tif(rev) ret = Comp(ret);\n\t\treturn ret;\n\t}\n\tS ret = num();\n\tif(rev) ret = Comp(ret);\n\treturn ret;\n}\n\nS num(){\n\tdebug(\"num\");\n\tS ret = m[s[c]];\n\tc++;\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tm.clear();\n\t\tU.clear();\n\t\tchar name;\n\t\tint n;\n\t\twhile(true){\n\t\t\tif(!(cin >> name >> n)) return 0;\n\t\t\tif(name == 'R') break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tU.insert(a);\n\t\t\t\tm[name].insert(a);\n\t\t\t}\n\t\t}\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tS ans = expr();\n\t\tvector<int> v(ans.begin(), ans.end());\n\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\tcout << v[i];\n\t\t\tif(i != v.size() - 1) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nset<int> U(set<int> A,set<int> B){\n  set<int> S=A;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end())S.insert(*I),I++;\n  return S;\n}\n\nset<int> M(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=A.begin();\n  while(I!=A.end()){\n    if(!B.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nset<int> T(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end()){\n    if(A.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nstring s;\nset<int> V[6];\n\nset<int> dfs(int l,int r){\n  set<int> A,B;\n  bool f=0,bf=0;\n  char cmd=0;\n  for(int j=l;j<r;j++){\n    if(s[j]=='('){\n      int c=1,st=j+1;\n      j++;\n      for(;c;j++){\n\tif(s[j]=='(')c++;\n\tif(s[j]==')')c--;\n      }\n      j--;\n      B=dfs(st,j);\n      bf=1;\n    }\n    if('a'<s[j]&&s[j]<'z'){\n      if(s[j]=='c')f=1;\n      else cmd=s[j];\n    }\n    if('A'<=s[j]&&s[j]<='E'){\n      B=V[s[j]-'A'];\n      bf=1;\n    }\n    if(bf){\n      if(f){\n\tB=M(V[5],B);\n\tf=0;\n      }\n      if(cmd=='u')A=U(A,B);\n      if(cmd=='i')A=T(A,B);\n      if(cmd=='d')A=M(A,B);\n      if(cmd=='s')A=U(M(A,B),M(B,A));\n      if(cmd==0)A=B;\n      bf=0;cmd=0;\n    }\n  }\n  return A;\n}\n\nint main(){\n  while(1){\n    for(int i=0;i<=5;i++)V[i].clear();\n    while(1){\n      char c;\n      int x;\n      if(cin>>c>>x==0)return 0;\n      if(c=='R')break;\n      for(int i=0,a;i<x;i++)cin>>a,V[c-'A'].insert(a),V[5].insert(a);\n    }\n\n    cin>>s;\n    set<int> res=dfs(0,s.size());\n    set<int>::iterator I=res.begin();\n    while(I!=res.end()){\n      if(I!=res.begin())cout<<\" \";\n      cout<<*I;\n      I++;\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <cctype>\n\nusing namespace std;\n\nvector<int> g_sets[5];\nvector<int> g_all;\n\nstruct Result {\n        vector<int> value;\n        int p;\n};\n\nResult expr(const string &s, int p);\nResult factor(const string &s, int p);\n\nResult expr(const string &s, int p){\n        Result r = factor(s, p);\n        while(islower(s[r.p])){\n                Result q = factor(s, r.p + 1);\n                vector<int> temp;\n                if(s[r.p] == 'u'){\n                        set_union(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }else if(s[r.p] == 'i'){\n                        set_intersection(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }else if(s[r.p] == 'd'){\n                        set_difference(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }else if(s[r.p] == 's'){\n                        set_symmetric_difference(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }\n                r.value = temp;\n                r.p = q.p;\n        }\n        return r;\n}\n\nResult factor(const string &s, int p){\n        bool complement = false;\n        while(s[p] == 'c'){\n                complement = !complement;\n                ++p;\n        }\n        Result r;\n        if(isupper(s[p])){\n                r.value = g_sets[s[p] - 'A'];\n                r.p = p + 1;\n        }else{\n                Result q = expr(s, p + 1);\n                r.value = q.value;\n                r.p = q.p + 1;\n        }\n        if(complement){\n                vector<int> temp;\n                set_difference(\n                        g_all.begin(), g_all.end(),\n                        r.value.begin(), r.value.end(),\n                        back_inserter(temp));\n                r.value = temp;\n        }\n        return r;\n}\n\nint main(){\n        while(!cin.eof()){\n                while(true){\n                        string s;\n                        int n;\n                        cin >> s >> n;\n                        if(s == \"R\" && n == 0){ break; }\n                        int index = s[0] - 'A';\n                        g_sets[index].clear();\n                        while(n--){\n                                int x;\n                                cin >> x;\n                                g_sets[index].push_back(x);\n                                g_all.push_back(x);\n                        }\n                        sort(g_sets[index].begin(), g_sets[index].end());\n                }\n                sort(g_all.begin(), g_all.end());\n                g_all.erase(unique(g_all.begin(), g_all.end()), g_all.end());\n                string q;\n                cin >> q;\n                vector<int> result = expr(q, 0).value;\n                if(result.size() == 0){\n                        cout << \"NULL\" << endl;\n                }else{\n                        for(int i = 0; i < result.size(); ++i){\n                                cout << result[i];\n                                if(i + 1 == result.size()){\n                                        cout << endl;\n                                }else{\n                                        cout << \" \";\n                                }\n                        }\n                }\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\n \nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\nvoid show(vector<int> ans){\n\tbool r=false;\n\t//cout<<ans.size()<<endl;\n\tfor(int i=0;i<ans.size();i++)if(ans[i]){\n\t\tif(r) cout<<\" \";\n\t\tr=true;\n\t\tcout<<V[i];\n\t}\n        if(!r) cout<<\"NULL\";\n        cout<<endl;\n}\nvector<int> U(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]|a2[i]);\n    return ve1;\n}\n \nvector<int> I(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]&a2[i]);\n    return ve1;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]^a2[i]);\n    return ve1;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n     \n    for(int i=0;i<a1.size();i++){\n        int r;\n        if(a1[i]==1 && a2[i]==0) r=1;\n        else r=0;\n        ve1.pb(r);\n    }\n    return ve1;\n}\n \nvector<int> C(vector<int> a1){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(1-a1[i]);\n    return ve1;\n}\nvector<int> shiki();\nvector<int> ka();\nvector<int> han(){\n//  cout<<s[it]<<endl;\n    if(s[it]=='c'){\n    //\tcout<<it<<endl;\n        it++;\n        vector<int> e=ka();\n    //\tshow(C(e));\n        return C(e);\n    }\n    else{\n        it++;\n        return ch[s[it-1]-'A'];\n    }\n}\n \nvector<int> ka(){\n    if(s[it]=='('){\n        it++;\n        vector<int> q=shiki();\n        it++;\n        return q;\n    }\n    else return han();\n     \n}\n \n \n \nvector<int> shiki(){\n    vector<int> r= ka();\n    while(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n        char c=s[it];\n    \t\n        it++;\n        vector<int> r2=ka();\n         \n        if(c=='u') r=U(r,r2);\n        if(c=='s') r=S(r,r2);\n        if(c=='d') r=D(r,r2);\n        if(c=='i') r=I(r,r2);\n    }\n//\tcout<<it<<endl;\n//\tshow(r);\n//\tcout<<r.size()<<endl;\n    return r;\n}\n \nint cnt=0;\nsigned main(){\nchar c;\n    int d;\n    while(cin>>c>>d){\n         \n        cnt++;\n    //  if(cnt>19) break;\n      \n    \t for(int i=0;i<d;i++){\n                int r;\n                cin>>r;\n                ve[c-'A'].pb(r);\n            }\n        while(1){\n            cin>>c>>d;\n             \n            if(c=='R') break;\n            for(int i=0;i<d;i++){\n                int r;\n                cin>>r;\n                ve[c-'A'].pb(r);\n            }\n             \n        }\n        set<int> se;\n         \n        for(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n        V.clear();\n        for(auto its=se.begin();its!=se.end();its++){\n            V.pb(*its);\n        }\n         \n        for(int i=0;i<5;i++){\n            for(int j=0;j<V.size();j++){\n            bool b=false;\n            for(int k=0;k<ve[i].size();k++){\n                if(ve[i][k]==V[j]) b=true;\n            }\n            if(b) ch[i].pb(1);\n            else ch[i].pb(0);\n        }\n    //      for(int j=0;j<V.size();j++)cout<<ch[i][j];\n    //      cout<<endl;\n        }\n        it=0;\n        cin>>s;\n        s+=\"*\";\n        vector<int> anss=shiki();\n   // \tcout<<anss.size()<<endl;\n   // \treturn 0;\n    \tshow(anss);\n    //\tcout<<\"s\"<<endl;\n   // \treturn 0;\n    \t\n    \tfor(int i=0;i<5;i++){\n    \t\tve[i].clear();\n    \t\tch[i].clear();\n    \t}\n    \tV.clear();\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> V;\nV A[10],U;\nstring S;\n\nV Union(V a,V b){\n  for(int i=0;i<(int)b.size();i++) a.push_back(b[i]);\n  sort(a.begin(),a.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  return a;\n}\n\nV Inter(V a,V b){\n  V res;\n  int n =a.size(),m=b.size();\n  for(int i=0;i<n;i++){\n    int flg = 0;\n    for(int j=0;j<m;j++) flg |= a[i] == b[j];\n    if(flg)res.push_back(a[i]);\n  }\n\n  sort(res.begin(),res.end());\n  return res;\n}\n\nV Diff(V a,V b){\n  V res;\n  int n = a.size();\n  int m = b.size();\n    for(int i=0;i<n;i++){\n    int flg =1;\n    for(int j=0;j<m;j++)flg &=a[i]!=b[j];\n    if(flg)res.push_back(a[i]);\n  }\n  \n  sort(res.begin(),res.end());\n  return res;\n}\n\nV Sdiff(V a,V b){return Union(Diff(a,b),Diff(b,a));}\n\nV Comp(V a){\n  V res;\n  int n = U.size(),m = a.size();\n  for(int i=0;i<n;i++){\n    int flg = 1;\n    for(int j=0;j<m;j++)flg &= U[i]!=a[j];\n    if(flg) res.push_back(U[i]);\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint p;\nV bnf();\nV getV(){\n  char ch = S[p];\n  V res;\n  if(ch == '(')p++,res = bnf(),p++;\n  else if(isupper(ch))p++,res = A[ch-'A'];\n  else if(ch=='c')p++,res = Comp(getV());\n  else assert(isupper(ch));\n  return res;\n}\n\nV bnf(){\n  V res = getV();\n  while(1){\n    char ch = S[p];\n    if(ch=='(')p++,res = bnf(),p++;\n    else if(ch=='c')p++,res = Comp(getV());\n    else if(ch=='u')p++,res = Union(res,getV());\n    else if(ch=='i')p++,res = Inter(res,getV());\n    else if(ch=='d')p++,res = Diff(res,getV());\n    else if(ch=='s')p++,res = Sdiff(res,getV());\n    else if(p<S.size()&&ch!=')')assert(ch==')');\n    else break;\n  }\n  return res;\n}\n\nint main(){\n\n  while(1){\n    U.clear();\n    while(1){\n      char ch;\n      assert('A'<=ch&&ch<='E');\n      int n;\n      if(!(cin>>ch>>n))exit(0);\n      if(ch == 'R' && n == 0) break;\n      int idx = ch-'A';\n      A[idx].resize(n);\n      for(int i=0;i<n;i++)cin>>A[idx][i],U.push_back(A[idx][i]);\n      sort(A[idx].begin(),A[idx].end());\n      A[idx].erase(unique(A[idx].begin(),A[idx].end()),A[idx].end());\n    }\n\n    sort(U.begin(),U.end());\n    U.erase(unique(U.begin(),U.end()),U.end());\n    cin >> S;\n    p = 0;\n    V ans = bnf();\n    \n    for(int i=0;i<ans.size();i++){\n      if(i)cout<<\" \";\n      cout<<ans[i];\n    }\n    if(ans.size()==0)cout<<\"NULL\";\n    cout<<endl;\n  }\n \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nmap<char,set<int> > S;\nset<int> U;\nstring parse;\nint pos;\n\nset<int> expression();\n\nset<int> term(){\n  if( parse[pos] == '(' ){\n    ++pos;\n    set<int> p = expression();\n    ++pos;\n    return p;\n  } else if( parse[pos] == 'c' ) {\n    ++pos;\n    set<int> p = term();\n    set<int> ret = U;\n    for(set<int>::iterator it = p.begin();it!=p.end();it++) ret.erase(*it);\n    return ret;\n  } else {\n    char c = parse[pos++];\n    return S[c];\n  }\n}\n\nset<int> expression(){\n  set<int> a = term();\n\n  while( parse[pos] == 'u' || parse[pos] == 'i' || parse[pos] == 'd' || parse[pos] == 's' || parse[pos] == 'c' ){\n    char opr = parse[pos++];\n    set<int> b = term();\n    if( opr == 'u' ){\n      set<int> u = a;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) u.insert(*it);\n      a = u;\n    } else if( opr == 'i' ) {\n      map<int,int> counter;\n      set<int> tmp;\n      for(set<int>::iterator it = a.begin() ; it != a.end(); it++ ) counter[*it]++;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) counter[*it]++;\n      for(auto& i : counter)if( i.second == 2 ) tmp.insert(i.first);\n      a = tmp;\n    } else if( opr == 'd' ) {\n      set<int> tmp = a;\n      for(auto& i : b)tmp.erase(i);\n      a = tmp;\n    } else if( opr == 's' ) {\n      map<int,int> counter;\n      set<int> tmp;\n      for(set<int>::iterator it = a.begin() ; it != a.end(); it++ ) counter[*it]++;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) counter[*it]++;\n      for(auto& i : counter)if( i.second != 2 ) tmp.insert(i.first);\n      a = tmp;\n    }\n  }\n  return a;\n}\n\nint main(){\n\n  char c;\n  int n,tmp;\n  while(cin >> c >> n){\n    pos = 0;\n    S.clear();\n    U.clear();\n    rep(i,n){\n      cin >> tmp;\n      S[c].insert(tmp);\n    }\n\n    while(true){\n      cin >> c >> n;\n      if( c == 'R' && n == 0 ) break;\n      rep(i,n){\n\tcin >> tmp;\n\tS[c].insert(tmp);\n      }\n    }\n\n    for(map<char,set<int> >::iterator it = S.begin(); it != S.end(); it++){\n\tfor(set<int>::iterator it2 = (it->second).begin(); it2 != (it->second).end();it2++){\n\t  U.insert(*it2);\n\t}\n    }\n\n    cin >> parse;\n\n    set<int> answer = expression();\n    int i = 0;\n    for(set<int>::iterator iter = answer.begin() ; iter != answer.end() ; iter++,i++ ){\n      if( i ) cout << ' ';\n      cout << *iter;\n    } cout << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef set <int> SI;\ntypedef map <string, SI> MSI;\n\nMSI M;\n\nSI getU() {\n    SI res;\n    string S[5] = { \"A\", \"B\", \"C\", \"D\", \"E\" };\n    for ( int i = 0; i < 5; ++ i ) {\n        for ( SI::iterator it_i = M[S[i]].begin(); it_i != M[S[i]].end(); ++ it_i ) {\n            res.insert( *it_i );\n        }\n    }\n    SI st( res.begin(), res.end() );\n    return SI( st.begin(), st.end() );\n}\n\nSI getCU( SI A ) {\n    SI res;\n    SI U = getU();\n    for ( SI::iterator it_i = U.begin(); it_i != U.end(); ++ it_i ) {\n        bool flag = true;\n        for ( SI::iterator it_j = A.begin(); it_j != A.end(); ++ it_j ) {\n            if ( *it_j == *it_i ) flag = false;\n        }\n        if ( flag ) res.insert( *it_i );\n    }\n    return res;\n}\n\nvoid print_vi( SI s ) {\n    if ( s.empty() ) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n    VI v( s.begin(), s.end() );\n    for ( VI::iterator it_i = v.begin(); it_i != v.end(); ++ it_i ) {\n        cout << *it_i;\n        if ( it_i + 1 != v.end() ) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n}\n\nbool isOP( char c ) {\n    if ( c == 'u' ) return true;\n    if ( c == 'i' ) return true;\n    if ( c == 'd' ) return true;\n    if ( c == 's' ) return true;\n    return false;\n}\n\nstring toString( char c ) {\n    string res;\n    res += c;\n    return res;\n}\n\nSI getUnion( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    return res;\n}\n\nSI getIntersection( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        for ( SI::iterator it_j = B.begin(); it_j != B.end(); ++ it_j ) {\n            if ( *it_i == *it_j ) res.insert( *it_i );\n        }\n    }\n    return res;\n}\n\nSI getDifference( SI A, SI B ) {\n    SI res;\n    for ( SI::iterator it_i = A.begin(); it_i != A.end(); ++ it_i ) {\n        res.insert( *it_i );\n    }\n    for ( SI::iterator it_i = B.begin(); it_i != B.end(); ++ it_i ) {\n        res.erase( *it_i );\n    }\n    return res;\n}\n\nSI getSymmetricDifference( SI A, SI B ) {\n    return getUnion( getDifference( A, B ), getDifference( B, A ) );\n}\n\nSI solve2( string s, int k ) {\n    int n = s.size();\n\n    SI A, B;\n    string op;\n    // A\n    if ( s[k] == '(' ) {\n        A = solve2( s, k + 1 );\n        for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n        k++;\n    } else if ( s[k] == 'c' && s[k+1] == '(' ) {\n        A = getCU( solve2( s, k + 2 ) );\n        for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n        k++;\n    } else {\n        if ( s[k] == 'c' ) {\n            A = getCU( M[toString(s[k+1])] );\n            k += 2;\n        } else {\n            A = M[toString(s[k])];\n            k += 1;\n        }\n    }\n\n    SI res = A;\n    while ( k < n && s[k] != ')' ) {\n        // O\n        op = s[k];\n        k ++;\n        // B\n        if ( s[k] == '(' ) {\n            B = solve2( s, k + 1 );\n            for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n            k++;\n        } else if ( s[k] == 'c' && s[k+1] == '(' ) {\n            B = getCU( solve2( s, k + 2 ) );\n            for ( int i = 0; i < n; ++ i )  if ( s[k++] == ')' ) break;\n            k++;\n        } else {\n            if ( s[k] == 'c' ) {\n                B = getCU( M[toString(s[k+1])] );\n                k += 2;\n            } else {\n                B = M[toString(s[k])];\n                k += 1;\n            }\n        }\n        if ( op == \"u\" ) {\n            res = getUnion( res, B );\n        } else if ( op == \"i\" ) {\n            res = getIntersection( res, B );\n        } else if ( op == \"d\" ) {\n            res = getDifference( res, B );\n        } else if ( op == \"s\" ) {\n            res = getSymmetricDifference( res, B );\n        }\n    }\n    return res;\n}\n\nvoid solve( string first_name, int first_n ) {\n    M.clear();\n\n    // input\n    for ( int i = 0; i < first_n; ++ i ) {\n        int elm;\n        cin >> elm;\n        M[first_name].insert( elm );\n    }\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        if ( name == \"R\" && n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            int elm;\n            cin >> elm;\n            M[name].insert( elm );\n        }\n    }\n    string exp;\n    cin >> exp;\n    print_vi( solve2( exp, 0 ) );\n}\n\nint main() {\n    string name;\n    int n;\n    while ( cin >> name >> n ) {\n        solve( name, n );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else s=st[S[p++]-'A'];\n\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 501;\n\nchar A[5][MAXN];\nint pos;\nstring line;\n\nvector<char> exp();\nvector<char> fact();\n\nvector<char> exp() {\n  vector<char> res = fact();\n  while(1) {\n    if(line[pos] == 'u') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] || x[i]);\n      }\n    } else if(line[pos] == 'i') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && x[i]);\n      }\n    } else if(line[pos] == 'd') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && !x[i]);\n      }\n    } else if(line[pos] == 's') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = ((res[i] && !x[i]) || (x[i] && !res[i]));\n      }\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nvector<char> fact() {\n  vector<char> res;\n  if(line[pos] == 'c') {\n    ++pos;\n    res = fact();\n    for(int i = 0; i < res.size(); ++i) {\n      res[i] = 1-res[i];\n    }\n  } else if(isupper(line[pos])) {\n    char c = line[pos];\n    ++pos;\n    res = vector<char>(A[c-'A'], A[c-'A']+MAXN);\n  } else if(line[pos] == '(') {\n    ++pos;\n    res = exp();\n    ++pos;\n  }\n  return res;\n}\n\nmap<int,int> id, rid;\nint getId(int n) {\n  if(!id.count(n)) {\n    id[n] = id.size()-1;\n    rid[id[n]] = n;\n  }\n  return id[n];\n}\n\nint main() {\n  while(1) {\n    bool run = true;\n    fill(A[0], A[5], false);\n    id.clear();\n    rid.clear();\n    while(1) {\n      char c;\n      int n;\n      if(!(cin >> c >> n)) {\n\trun = false;\n\tbreak;\n      }\n      if(c == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i) {\n\tint a;\n\tcin >> a;\n\ta = getId(a);\n\tA[c-'A'][a] = true;\n      }\n    }\n    if(!run) break;\n    string s;\n    cin >> s;\n    line = s;\n    pos = 0;\n    vector<char> res = exp();\n    vector<int> ans;\n    for(int i = 0, cnt = 0; i < res.size(); ++i) {\n      if(rid.count(i) && res[i]) {\n\tans.push_back(rid[i]);\n      }\n    }\n    sort(ans.begin(), ans.end());\n    if(ans.size() == 0) {\n      cout << \"NULL\" << endl;\n    } else {\n      for(int i = 0; i < ans.size(); ++i) {\n\tif(i) cout << \" \";\n\tcout << ans[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\nconst int MOD=1000000007;\nconst int INF=1000000000;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nll p=0;\nbool zerodiv=false;\nstring t;\nset<int> A;\nset<int> B;\nset<int> C;\nset<int> D;\nset<int> E;\nset<int> U;\n\n// 和集合の計算\ntemplate<class T>  set<T> Union(const set<T>& rsettA, const set<T>&rsettB) {\n    set<T> settUnion(rsettA);\n    for (typename set<T>::iterator itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T>  set<T> Product(const set<T>& rsettA,const set<T>&rsettB) {\n    set<T> settProduct;\n    for (typename set<T>::iterator itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n\n// 補集合の計算\ntemplate<class T>  set<T> Complement(const set<T>& rsettA,const set<T>&rsettB) {\n    set<T> settComplement(rsettA);\n    for (typename set<T>::iterator itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\n\n//symmetric differenceの計算\ntemplate<class T>  set<T> Symmetric(const set<T>& rsettA,const set<T>&rsettB) {\n    return Union(Complement(rsettA,rsettB),Complement(rsettB,rsettA));\n}\n\nclass Parser{\npublic:\n    set<int> pars(State &begin,State &end){\n        set<int> ret;\n        while(begin<end){\n            ret=expression(begin);\n            ++begin;\n        }\n        return ret;\n    }\n    set<int> number(State &begin)\n    {\n        set<int> ret;\n        while(int(*begin-'a')<0)\n        {\n            if(*begin=='A')\n            {\n                return A;\n            }\n            else if(*begin=='B')\n            {\n                return B;\n            }\n            else if(*begin=='C')\n            {\n                return C;\n            }\n            else if(*begin=='D')\n            {\n                return D;\n            }\n            else if(*begin=='E')\n            {\n                return E;\n            }\n        }\n        return ret;\n    }\n\n    set<int> expression(State &begin)\n    {\n        set<int> ret;\n        ret=factor(begin);\n        ++begin;\n        while(true){\n            if(*begin=='u')\n            {\n                begin++;\n                ret=Union(ret,factor(begin));\n                ++begin;\n            }\n            else if(*begin=='i')\n            {\n                begin++;\n                ret=Product(ret,factor(begin));\n                ++begin;\n            }\n            else if(*begin=='d')\n            {\n                begin++;\n                ret=Complement(ret,factor(begin));\n                ++begin;\n            }\n            else if(*begin=='s')\n            {\n                begin++;\n                ret=Symmetric(ret,factor(begin));\n                ++begin;\n            }\n            else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    set<int> factor(State &begin)\n    {\n        set<int> ret;\n        if(*begin=='c'){\n            ++begin;\n            if(*begin=='(')ret=Complement(U,expression(begin));\n            else ret=Complement(U,number(begin));\n        }\n        else if(*begin=='('){\n            ++begin;//skip '('\n            ret=expression(begin);\n        }\n        else ret=number(begin);\n        return ret;\n    }\n};\n\n\nint main(int argc,char const* argv[])\n{\n    char setname;\n    int setnum;\n    string t;\n    while(cin)\n    {\n        A.clear();\n        B.clear();\n        C.clear();\n        D.clear();\n        E.clear();\n        U.clear();\n        while(cin >> setname >> setnum)\n        {\n            if(setname=='R') break;\n            for(int i=0;i<setnum;i++)\n            {\n                int inum;\n                cin >> inum;\n                if(setname=='A')\n                {\n                    A.insert(inum);\n                }\n                if(setname=='B')\n                {\n                    B.insert(inum);\n                }\n                if(setname=='C')\n                {\n                    C.insert(inum);\n                }\n                if(setname=='D')\n                {\n                    D.insert(inum);\n                }\n                if(setname=='E')\n                {\n                    E.insert(inum);\n                }\n            }\n        }\n        if(!cin)break;\n        U=Union(A,B);\n        U=Union(U,C);\n        U=Union(U,D);\n        U=Union(U,E);\n        cin >> t;\n        Parser ps;\n        State begin=t.begin();\n        State end=t.end();\n        set<int> ans=ps.pars(begin,end);\n\n        int cnt=0;\n        for(auto it:ans)\n        {\n            if(cnt!=0)cout<<' ';\n            cout << it;\n            ++cnt;\n        }\n        if(ans.size()==0)cout<<\"NULL\";\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cassert>\n#include <map>\nusing namespace std;\n\ntypedef pair<set<int>, int> result;\n#define value first\n#define p second\nmap<string, set<int> > idx;\nset<int> U;\n\nresult equation(const string &s, int p=0);\nresult term(const string &s,int p=0);\nresult factor(const string &s,int p=0);\n\nset<int> op(char c,set<int> s1,set<int> s2) {\n    if(c == 'u') {\n        for(set<int>::iterator it = s2.begin(); it != s2.end(); ++it)\n            s1.insert(*it);\n        return s1;\n    }else if(c == 'i') {\n        map<int,int> ap;\n        for(set<int>::iterator it = s1.begin(); it != s1.end(); ++it)\n            if(ap.find(*it) == ap.end()) ap[*it] = 1;\n            else ap[*it]++;\n\n        for(set<int>::iterator it = s2.begin(); it != s2.end(); ++it)\n            if(ap.find(*it) == ap.end()) ap[*it] = 1;\n            else ap[*it]++;\n\n        set<int> ss;\n        for(map<int,int>::iterator it = ap.begin(); it != ap.end(); ++it) {\n            if(it->second == 2) ss.insert(it->first);\n        }\n        return ss;\n    }else if(c == 'd') {\n        for(set<int>::iterator it = s2.begin(); it != s2.end(); ++it) {\n            if(s1.find(*it) != s1.end()) s1.erase(*it);\n        }\n        return s1;\n    }else if(c == 's') {\n        return op('u', op('d', s1, s2), op('d', s2, s1));\n    }\n    assert(false);\n    return set<int>();\n}\n\nresult equation(const string &s,int p) {\n    result r = factor(s, p);\n    while(s[r.p] == 'u' || s[r.p] == 'i' || s[r.p] == 'd'\n          || s[r.p] == 's') {\n        result r_ = factor(s, r.p+1);\n        r.value = op(s[r.p], r.value, r_.value);\n        r.p = r_.p;\n    }\n    return r;\n}\n\nresult factor(const string &s,int p) {\n    if(s[p] == 'c') {\n        result r = term(s,p+1);\n        return result(op('d', U, r.value),r.p);\n    }\n    return term(s,p);\n}\n\nresult term(const string &s,int p) {\n    if(s[p] == '(') {\n        result r = equation(s, p+1);\n        r.p++;\n        return r;\n    } else {\n        return result(idx[string(1,s[p])], p+1);\n    }\n}\n\nint main() {\n    string name,l;\n    int k,n;\n    while(cin>>name>>k) {\n\n        U.clear(); idx.clear();\n\n        if(name == \"R\") break;\n        for(int i=0; i<k; ++i) {\n            cin>>n;\n            idx[name].insert(n);\n            U.insert(n);\n        }\n        while(true) {\n            cin>>name>>k;\n            if(name == \"R\") break;\n            for(int i=0; i<k; ++i) {\n                cin>>n;\n                idx[name].insert(n);\n                U.insert(n);\n            }\n        }\n\n        cin>>l;\n        set<int> ss = equation(l).value;\n        for(set<int>::iterator it = ss.begin(); it != ss.end(); ++it) {\n            if(it != ss.begin()) cout<<\" \";\n            cout<<*it;\n        }\n        if(ss.empty()) cout<<\"NULL\";\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <cctype>\n#include <cassert>\nusing namespace std;\ntypedef string::const_iterator State;\nconst int MOD=1000000007;\nconst int INF=1000000000;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nll p=0;\nbool zerodiv=false;\nstring t;\nset<int> A;\nset<int> B;\nset<int> C;\nset<int> D;\nset<int> E;\nset<int> U;\n\n// 和集合の計算\ntemplate<class T>  set<T> Union(const set<T>& rsettA, const set<T>& rsettB) {\n    set<T> settUnion(rsettA);\n    for (typename set<T>::iterator itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T>  set<T> Product(const set<T>& rsettA,const set<T>& rsettB) {\n    set<T> settProduct;\n    for (typename set<T>::iterator itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n\n// 補集合の計算\ntemplate<class T>  set<T> Complement(const set<T>& rsettA,const set<T>& rsettB) {\n    set<T> settComplement(rsettA);\n    for (typename set<T>::iterator itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\n\n//symmetric differenceの計算\ntemplate<class T>  set<T> Symmetric(const set<T>& rsettA,const set<T>& rsettB) {\n  return Union(Complement(rsettA,rsettB),Complement(rsettB,rsettA));\n}\n\nclass Parser{\npublic:\n \n  set<int> number(State &begin)\n  {\n    set<int> ret;\n    // while(*begin==')' || *begin=='(') begin++;\n    assert(isupper(*begin));\n    if(*begin=='A')\n      {\n\tret=A;\n      }\n    else if(*begin=='B')\n      {\t  \n\tret=B;\n      }\n    else if(*begin=='C')\n      {\n\tret=C;\n      }\n    else if(*begin=='D')\n      {\n\tret=D;\n      }\n    else if(*begin=='E')\n      {\n\tret=E;\n      }\n    ++begin;\n    return ret;\n  }\n \n  set<int> expression(State &begin)\n  {\n    set<int> ret=term(begin);\n    for(;;)\n      {\n\tif(*begin=='u')\n\t  {\n\t    begin++;\n\t    ret=Union(ret,term(begin));\n\t  }\n\telse if(*begin=='i')\n\t  {\n\t    begin++;\n\t    ret=Product(ret,term(begin));\n\t  }\n\telse if(*begin=='d')\n\t  {\n\t    begin++;\n\t    ret=Complement(ret,term(begin));\n\t  }\n\telse if(*begin=='s')\n\t  {\n\t    begin++;\n\t    ret=Symmetric(ret,term(begin));\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret;\n  }\n \n  set<int> term(State &begin)\n  {\n    set<int> ret;\n    if(*begin=='c')\n      {\n\tbegin++;\n\tret=Complement(U,term(begin));\n      }\n    else\n      {\n\tret=factor(begin);\n      }\n    return ret;\n  }\n \n  set<int> factor(State &begin)\n  {\n    set<int> ret;\n    if(*begin=='(')\n      {\n\tbegin++;\n        ret=expression(begin);\n\tassert(*begin == ')');\n\tbegin++;\n\treturn ret;\n      }\n    else\n      {\n\tret=number(begin);\n      }\n    return ret;\n  }\n};\n \n \nint main(int argc,char const* argv[])\n{\n  char setname;\n  int setnum;\n  string t;\n  while(cin)\n    {\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      while(cin >> setname >> setnum)\n\t{\n\t  if(setname=='R') break;\n\t  for(int i=0;i<setnum;i++)\n\t    {\n\t      int inum;\n\t      cin >> inum;\n\t      if(setname=='A')\n\t\t{\n\t\t  A.insert(inum);\n\t\t}\n\t      if(setname=='B')\n\t\t{\n\t\t  B.insert(inum);\n\t\t}\n\t      if(setname=='C')\n\t\t{\n\t\t  C.insert(inum);\n\t\t}\n\t      if(setname=='D')\n\t\t{\n\t\t  D.insert(inum);\n\t\t}\n\t      if(setname=='E')\n\t\t{\n\t\t  E.insert(inum);\n\t\t}\n\t    }\n\t}\n      if(!cin) break;\n      U=Union(A,B);\n      U=Union(U,C);\n      U=Union(U,D);\n      U=Union(U,E);\n      cin >> t;\n      Parser ps;\n      State begin=t.begin();\n      set<int> ans=ps.expression(begin);\n      if(int(ans.size())==0)\n\t{\n\t  cout << \"NULL\" << endl;\n\t}\n      else\n\t{\n\t  for(auto it=ans.begin();it!=ans.end();it++)\n\t    {\n\t      if (next(it) == ans.end()) \n\t\t{\n\t\t  cout << *it << endl;;\n\t\t}\n\t      else\n\t\t{\n\t\t  cout << *it << ' ';\n\t\t}\n\t    }\n\t}\n      //cout << \"END\" << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>10) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            if(c == 'R' && n == 0) break;\n            f = true;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << '\\0' << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        cin >> num;\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n        printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\t//assert(mp.find(c) != mp.end());\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\t//assert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\tassert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\";\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    p++;\n    s=C(uni,ge());\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str.size()==2){\n\t\treturn Complement(sets[str[1]],sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é.\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\t\tsets['U'];\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>16) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint rst(int);\nvector<vector<int> > se;\nvector<set<int> > vse;\nvector<int> u;\nstring st;\nint main(){\n  while(1){\n    se.clear();\n    u.clear();\n    vse.clear();\n    se=vector<vector<int> >(5);\n    vse=vector<set<int> >(5);\n    while(1){\n      char ch;\n      int n;\n      cin >> ch >> n;\n      if(cin.eof())return 0;\n      if(ch=='R'&&n==0)break;\n      for(int i=0;i<n;i++){\n\tint num;\n\tcin >> num;\n\tse[ch-'A'].push_back(num);\n\tvse[ch-'A'].insert(num);\n\t//\tuse.insert(se[ch-'A'][i]);\n\tu.push_back(num);\n      }\n    }\n    st=\"\";\n    cin >> st;\n    st+=')';\n    int ans;\n    ans=rst(0);\n    sort(se[ans].begin(),se[ans].end());\n    if(se[ans].empty())cout << \"NULL\" << endl;\n    else {\n      for(int i=0;i<se[ans].size();i++){\n\tif(i)cout << \" \";\n\tcout << se[ans][i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}\nint rst(int I){\n  int m1=-1,m2=-1;\n  int kc=1;\n  int fu=0;//1u2i3d4s\n  int csw=0;\n  for(int i=I;i<st.size();i++){\n    //cout << fu << \" \"<< i<< endl;\n    if(st[i]=='('){\n      kc++;\n      if(kc==2){\n\t//cout << \"in\" << endl;\n\tm2=rst(i+1);\n      }\n    }\n    else if(st[i]==')'){\n      kc--;\n      if(kc==0){\n\t//cout << \"out\" << endl;\n\treturn m1;\n      }\n    }\n    else if(kc>1)continue;\n    else if(st[i]=='u')fu=1;\n    else if(st[i]=='i')fu=2;\n    else if(st[i]=='d')fu=3;\n    else if(st[i]=='s')fu=4;\n    else if(st[i]=='c')csw=1;\n    else if(st[i]>='A'&&st[i]<='E'){\n      m2=st[i]-'A';\n      if(csw){\n\tcsw=0;\n\tvector<int> b;\n\tset<int> bse;\n\tfor(int i=0;i<u.size();i++){\n\t  if(!vse[m2].count(u[i])){\n\t    b.push_back(u[i]);\n\t    bse.insert(u[i]);\n\t  }\n\t}\n\tse.push_back(b);\n\tvse.push_back(bse);\n\tm2=vse.size()-1;\n      }\n    }\n    if(m1==-1){\n      m1=m2;\n      m2=-1;\n    }\n    else if(m1>=0&&m2>=0){\n      vector<int> bu;\n      set<int> buse;\n      if(fu==1){\n\t//cout << \"f1\"<< endl;\n\tbu=se[m1];\n\tbuse=vse[m1];\n\tfor(int i=0;i<se[m2].size();i++){\n\t  if(!buse.count(se[m2][i]))bu.push_back(se[m2][i]);\n\t  buse.insert(se[m2][i]);\n\t}\n      }\n      else if(fu==2){\n\t//cout << \"f2\"<< endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      }\n      else if(fu==3){\n\t//cout << \"f3\"<< endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(!vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      }\n      else if(fu==4){\n\t//cout << \"fu4\" << endl;\n\tfor(int i=0;i<se[m1].size();i++){\n\t  if(!vse[m2].count(se[m1][i])){\n\t    bu.push_back(se[m1][i]);\n\t    buse.insert(se[m1][i]);\n\t  }\n\t}\n      \tfor(int i=0;i<se[m2].size();i++){\n\t  if(!vse[m1].count(se[m2][i])){\n\t    bu.push_back(se[m2][i]);\n\t    buse.insert(se[m2][i]);\n\t  }\n\t}\n      }\n      se.push_back(bu);\n      vse.push_back(buse);\n      m1=vse.size()-1;\n      m2=-1;\n      fu=0;\n    }\n    //    cout << m1 << \" \" << m2 << endl; \n  }\n}\n      \n\t  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(ret, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(ret, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(ret, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(ret, term(begin));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n\n    /*\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = D(sets['U'], v);\n    }\n    else {\n        ret = factor(begin);\n    }\n\n    return ret;\n    */\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        char se;\n        int n;\n\n        while (cin >> se >> n) {\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        if(sets['U'].size() == 0){\n            break;\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nset<int> u;\nset<int> t[5];\n\nset<int> diff(set<int> a, set<int> b){\n  set<int> ret = a;\n\n  FOR(it, b){\n    set<int>::iterator it2 = ret.find(*it);\n    if(it2 != ret.end())\n      ret.erase(it2);\n  }\n\n  return ret;\n}\n\nset<int> add(set<int> a, set<int> b){\n  set<int> ret;\n  FOR(it, a) ret.insert(*it);\n  FOR(it, b) ret.insert(*it);\n  return ret;\n}\n\nset<int> mult(set<int> a, set<int> b){\n  set<int> ret;\n  FOR(it, a){\n    if(b.count(*it)){\n      ret.insert(*it);\n    }\n  }\n  return ret;\n}\n\nvoid print(set<int> s){\n  FOR(it, s) cout << *it << \" \";\n  cout << endl;\n}\n\nset<int> parse(const string &str, int pos){\n  int depth = 0;\n  char op = 0;\n  set<int> st[2];\n  int idx = 0;\n\n  for(int i = pos; i < str.size(); i++){\n    char c = str[i];\n\n    switch(c){\n    case '(':\n      if(depth == 0){\n\tst[idx] = parse(str, i + 1);\n\tif(op == 'c'){\n\t  st[idx] = diff(u, st[idx]);\n\t  op = 0;\n\t}\n\t\n\tidx++;\n\t\n\tif(idx == 2){\n\t  //cout << \"lhs: \"; print(st[0]);\n\t  //cout << \"rhs: \"; print(st[0]);\n\t  //cout << \"op: \" << op << endl;\n\t  switch(op){\n\t  case 'u': st[0] = add(st[0], st[1]); break;\n\t  case 'i': st[0] = mult(st[0], st[1]); break;\n\t  case 'd': st[0] = diff(st[0], st[1]); break;\n\t  case 's': st[0] = diff(add(st[0], st[1]), mult(st[0], st[1])); break;\n\t  }\n\t  //cout << \"result: \"; print(st[0]);\n\t}\n\tidx = 1;\n      }\n      depth++;\n      break;\n    case ')': depth--; break;\n    default:\n      if(depth == 0){\n\tif(isupper(c)){\n\t  st[idx] = t[c - 'A'];\n\n\t  if(op == 'c'){\n\t    st[idx] = diff(u, st[idx]);\n\t    op = 0;\n\t  }\n\n\t  idx++;\n\n\t  if(idx == 2){\n\t    //cout << \"lhs: \"; print(st[0]);\n\t    //cout << \"rhs: \"; print(st[0]);\n\t    //cout << \"op: \" << op << endl;\n\t    switch(op){\n\t    case 'u': st[0] = add(st[0], st[1]); break;\n\t    case 'i': st[0] = mult(st[0], st[1]); break;\n\t    case 'd': st[0] = diff(st[0], st[1]); break;\n\t    case 's': st[0] = diff(add(st[0], st[1]), mult(st[0], st[1])); break;\n\t    }\n\t    //cout << \"result: \"; print(st[0]);\n\t  }\n\t  idx = 1;\n\t}else{\n\t  op = c;\n\t}\n      }\n    }\n\n    if(depth < 0) return st[0];\n\n  }\n\n  return st[0];\n}\n\nint main(){\n  while(true){\n    u.clear();\n    REP(i,5) t[i].clear();\n\n    while(true){\n      string s;\n      int n;\n      \n      if(!(cin >> s >> n))\n\treturn 0;\n      \n      if(s == \"R\") break;\n      \n      int id = s[0] - 'A';\n      \n      REP(i,n){\n\tint tmp;\n\tcin >> tmp;\n\tt[id].insert(tmp);\n\tu.insert(tmp);\n      }\n    }\n\n    string exp;\n    cin >> exp;\n\n    set<int> ret = parse(exp, 0);\n    vector<int> ans(ret.begin(), ret.end());\n\n    REP(i,ans.size()) printf(\"%d%c\", ans[i], i == ans.size() - 1 ? '\\n' : ' ');\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<int,vi> parsed;\nparsed expr(const string& f,int i,const vi& u,const map<char,vi>& m);\n\nparsed term(const string& f,int i,const vi& u,const map<char,vi>& m)\n{\n\tif(f[i]=='('){\n\t\tparsed p=expr(f,i+1,u,m);\n\t\tp.first++;\n\t\treturn p;\n\t}\n\telse if(f[i]=='c'){\n\t\tparsed p=term(f,i+1,u,m);\n\t\tvi a(u.size());\n\t\ta.erase(set_difference(all(u),all(p.second),a.begin()),a.end());\n\t\treturn parsed(p.first,a);\n\t}\n\telse\n\t\treturn parsed(i+1,m.at(f[i]));\n}\n\nparsed expr(const string& f,int i,const vi& u,const map<char,vi>& m)\n{\n\tparsed p=term(f,i,u,m);\n\twhile(p.first<f.size() && islower(f[p.first])){\n\t\tchar op=f[p.first];\n\t\tparsed p2=term(f,p.first+1,u,m);\n\t\tvi a(u.size());\n\t\tif(op=='u')\n\t\t\ta.erase(set_union(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tif(op=='i')\n\t\t\ta.erase(set_intersection(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tif(op=='d')\n\t\t\ta.erase(set_difference(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tif(op=='s')\n\t\t\ta.erase(set_symmetric_difference(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tp=parsed(p2.first,a);\n\t}\n\treturn p;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tmap<char,vi> m;\n\t\tstring f;\n\t\t{\n\t\t\tchar c; int n;\n\t\t\twhile(cin>>c>>n && c!='R'){\n\t\t\t\tvi a(n);\n\t\t\t\trep(i,n)\n\t\t\t\t\tcin>>a[i];\n\t\t\t\tsort(all(a));\n\t\t\t\tm[c]=a;\n\t\t\t}\n\t\t\tif(!(cin>>f))\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvi u;\n\t\tfor(auto kv:m)\n\t\t\tu.insert(u.end(),all(kv.second));\n\t\tsort(all(u));\n\t\tu.erase(unique(all(u)),u.end());\n\t\t\n\t\tvi res=expr(f,0,u,m).second;\n\t\tif(res.empty())\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse\n\t\t\tfor(int i=0;i<res.size();i++)\n\t\t\t\tcout<<res[i]<<(i==res.size()-1?'\\n':' ');\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvector<int> expr();\nvector<int> set1();\nvector<int> set2();\nvector<int> alpha();\n\nint idx;\nchar s[2000];\n\nvector<int> S[5],U;\n\nvector<int> calc_c(const vector<int> &A){\n\tvector<int> B;\n\trep(i,U.size()) if(!binary_search(A.begin(),A.end(),U[i])) B.push_back(U[i]);\n\treturn B;\n}\n\nvector<int> calc_u(const vector<int> &A,const vector<int> &B){\n\tvector<int> C;\n\trep(i,A.size()) C.push_back(A[i]);\n\trep(i,B.size()) C.push_back(B[i]);\n\tsort(C.begin(),C.end());\n\tC.erase(unique(C.begin(),C.end()),C.end());\n\treturn C;\n}\n\nvector<int> calc_i(const vector<int> &A,const vector<int> &B){\n\treturn calc_c(calc_u(calc_c(A),calc_c(B)));\n}\n\nvector<int> calc_d(const vector<int> &A,const vector<int> &B){\n\treturn calc_i(A,calc_c(B));\n}\n\nvector<int> calc_s(const vector<int> &A,const vector<int> &B){\n\treturn calc_u(calc_d(A,B),calc_d(B,A));\n}\n\nvector<int> expr(){\n\tvector<int> A=set1();\n\twhile(s[idx] && s[idx]!=')'){\n\t\tchar op=s[idx++];\n\t\tvector<int> B=set1();\n\n\t\tif     (op=='u') A=calc_u(A,B);\n\t\telse if(op=='i') A=calc_i(A,B);\n\t\telse if(op=='d') A=calc_d(A,B);\n\t\telse             A=calc_s(A,B);\n\t}\n\treturn A;\n}\n\nvector<int> set1(){\n\tif(s[idx]=='c'){\n\t\tidx++;\n\t\treturn calc_c(set1());\n\t}\n\telse return set2();\n}\n\nvector<int> set2(){\n\tvector<int> A;\n\tif(s[idx]=='('){\n\t\tidx++;\n\t\tA=expr();\n\t\tidx++;\n\t}\n\telse A=alpha();\n\treturn A;\n}\n\nvector<int> alpha(){ return S[s[idx++]-'A']; }\n\nint main(){\n\twhile(1){\n\t\tU.clear();\n\t\twhile(1){\n\t\t\tchar c;\n\t\t\tint n;\n\t\t\tif(!~scanf(\" %c%d\",&c,&n)) return 0;\n\t\t\tif(c=='R') break;\n\n\t\t\tS[c-'A'].clear();\n\t\t\trep(i,n){\n\t\t\t\tint e; scanf(\"%d\",&e);\n\t\t\t\tS[c-'A'].push_back(e);\n\t\t\t\tU.push_back(e);\n\t\t\t}\n\t\t\tsort(S[c-'A'].begin(),S[c-'A'].end());\n\t\t}\n\t\tsort(U.begin(),U.end());\n\t\tU.erase(unique(U.begin(),U.end()),U.end());\n\n\t\tscanf(\"%s\",s);\n\t\tidx=0;\n\t\tvector<int> res=expr();\n\n\t\trep(i,res.size()) printf(\"%s%d\",i?\" \":\"\",res[i]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele){\n        this->ele = ele;\n        it = s.begin();\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> ele;\n        set<int> U;\n        \n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            ele[ch] = st;\n        }while(cin >> ch >> N);\n\n        ele['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    sort(result.begin(), result.end());\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint INF = (1<<24);\n\nvector<int> U;\nmap < int,bool > used;\n\nmap < char , vector<int> > t;\n\nstring str;\nint pos;\n\nbool input();\n\nvector<int> calc(vector<int>,char ch,vector<int>);\n\nvector<int> compute();\nvector<int> get();\n\nint main(){\n  vector<int> ans;\n  while(input()){\n    pos=0;\n    ans=compute();\n    /*\n    for(int i=0;i<(int)t['A'].size();i++){\n      cout<<t['A'][i]<<' ';\n    }\n    cout<<endl;\n    for(int i=0;i<(int)t['B'].size();i++){\n      cout<<t['B'][i]<<' ';\n    }\n    cout<<endl;\n\n    ans=calc(t['A'],'s',t['B']);\n    for(int i=0;i<(int)ans.size();i++){\n      cout<<ans[i]<<' ';\n    }\n    cout<<endl;\n    */\n    \n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n\nbool input(){\n  int n,a;\n  char ch;\n  U.clear();\n  used.clear();\n  t.clear();\n  while(1){\n    if(cin>>ch){\n    }else{\n      return false; \n    }\n    cin>>n;\n    if(ch=='R'&&n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a;\n\n      if(used[a]==false){U.push_back(a);used[a]=true;}\n\n      t[ch].push_back(a);\n    }\n    sort(t[ch].begin(),t[ch].end());\n  }\n  sort(U.begin(),U.end());\n  cin>>str;\n  str.push_back('=');\n  return true;\n}\n\nvector<int> calc(vector<int> A,char ch,vector<int> B){\n\n  int a=0,b=0,Asize=A.size(),Bsize=B.size(),nowA,nowB; \n  vector<int> res;\n\n  if(ch=='u'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n\n  }else if(ch=='i'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n\n  }else if(ch=='d'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n    \n  }else if(ch=='s'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n  }\n\n  return res;\n}\n\n\nvector<int> compute(){\n\n  vector<int> res,X;\n  char ch;\n  res=get();\n\n  while(1){\n    ch=str[pos++];\n    if(ch=='='||ch==')')break;\n    X=get();\n    res=calc(res,ch,X);\n  }\n\n  return res;\n}\n\n\nvector<int> get(){\n  if(str[pos]=='('){\n    pos++;\n    return compute();\n  }else if(str[pos]=='c'){\n    pos++;\n    return calc(U,'d',get());\n  }else{\n    pos++;\n    return t[str[pos-1]];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <string>\n#include <stack>\nusing namespace std;\n\ntemplate <class Set>\nvoid print_set(Set& setA)\n{\n  typename Set::iterator it;\n  int n = 0;\n  if (setA.empty()) { printf(\"\\n\"); return; }\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    n++;\n    if (n != setA.size()) printf(\"%d \", *it);\n    else printf(\"%d\\n\", *it);\n  }\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet union_set(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.insert(*it);\n  }\n  return res;\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet intersection_set(Set& setA, Set& setB)\n{\n  Set res;\n  typename Set::iterator it;\n\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    if (setA.find(*it) != setA.end())\n    {\n      res.insert(*it);\n    }\n  }\n  return res;\n}\n\n\n// ?£???????????¨????\ntemplate <class Set>\nSet complement(Set& setA, Set& U)\n{\n  Set res(U);\n  typename Set::iterator it;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A-B\ntemplate <class Set>\nSet difference(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A . B\ntemplate <class Set>\nSet symmetric_difference(Set& setA, Set& setB)\n{\n  Set s1 = difference(setA, setB);\n  Set s2 = difference(setB, setA);\n  return union_set(s1, s2);\n}\n\nstring rev_polish_notation(string& exp)\n{\n  stack<char> stk;\n  string rexp;\n  string::iterator it;\n\n  for (it = exp.begin(); it != exp.end(); ++it)\n  {\n    if (*it == '(')\n    {\n      stk.push(*it);\n    }\n    else if (*it == ')')\n    {\n      while (stk.top() != '(')\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.pop();                // top???'('???????????????\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      while ((!stk.empty()) && (stk.top() != '('))\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.push(*it);\n    }\n    else if (*it == 'c')\n    {\n      stk.push(*it);\n    }\n    else if ((*it == 'A') || (*it == 'B') || (*it == 'C') || (*it == 'D') || (*it == 'E'))\n    {\n      rexp = rexp + (*it);\n    }\n  }\n\n  while (!stk.empty())\n  {\n    char tkn = stk.top();\n    rexp = rexp + tkn;\n    stk.pop();\n  }\n\n  return rexp;\n}\n\n\ntemplate <class Set>\nSet set_operation(string& exp, Set& A, Set& B, Set& C, Set& D, Set& E, Set& U)\n{\n  Set S;\n  string rexp = rev_polish_notation(exp); // ???????????????????¨????\n  stack<Set> stk;\n\n  string::iterator it;\n  for (it = rexp.begin(); it != rexp.end(); ++it)\n  {\n    if (*it == 'A') { stk.push(A); }\n    else if (*it == 'B') { stk.push(B); }\n    else if (*it == 'C') { stk.push(C); }\n    else if (*it == 'D') { stk.push(D); }\n    else if (*it == 'E') { stk.push(E); }\n    else if (*it == 'c')\n    {\n      Set s = stk.top();\n      stk.pop();\n      stk.push(complement(s, U));\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      Set s1 = stk.top();\n      stk.pop();\n      Set s2 = stk.top();\n      stk.pop();\n      Set ans;\n\n      switch (*it)\n      {\n      case 'u': stk.push(union_set(s1, s2)); break;\n      case 'i': stk.push(intersection_set(s1, s2)); break;\n      case 'd': stk.push(difference(s2, s1)); break; // ????????????????????¨???\n      case 's': stk.push(symmetric_difference(s1, s2)); break;\n      }\n    }\n  }\n  return stk.top();\n}\n\n\nint main() {\n  set<int> A, B, C, D, E, U;\n  char name;\n  int num;\n  int e;\n  string exp;\n\n  while (cin >> name >> num)\n  {\n    switch (name)\n    {\n    case 'A':\n      for (int i=0;i<num;i++) { cin >> e; A.insert(e); U.insert(e); }\n      break;\n    case 'B':\n      for (int i=0;i<num;i++) { cin >> e; B.insert(e); U.insert(e); }\n      break;\n    case 'C':\n      for (int i=0;i<num;i++) { cin >> e; C.insert(e); U.insert(e); }\n      break;\n    case 'D':\n      for (int i=0;i<num;i++) { cin >> e; D.insert(e); U.insert(e); }\n      break;\n    case 'E':\n      for (int i=0;i<num;i++) { cin >> e; E.insert(e); U.insert(e); }\n      break;\n    case 'R':\n      cin.ignore();             // ??????????????????????£???°???\n      getline(cin, exp);\n\n      set<int> res = set_operation(exp,A,B,C,D,E,U);\n      print_set(res);\n\n      // ??????????????????????¶???????\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      U.clear();\n      break;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n#define EACH(it,n) for(S::iterator it = (n).begin(); it != (n).end() ; ++it)\ntypedef set<int> S;\nmap< string , S > data;\n\n\nstring expr;\n\nS uni(S a,S b){\n\tS ans;\n\tEACH(it,a) ans.insert(*it);\n\tEACH(it,b) ans.insert(*it);\n\treturn ans;\n}\nS inter(S a,S b){\n\tS ans;\n\tEACH(it,a) if(b.count(*it))ans.insert(*it);\n\treturn ans;\n}\nS diff(S a,S b){\n\tS ans;\n\tEACH(it,a) if(!b.count(*it))ans.insert(*it);\n\treturn ans;\n} \nS sym(S a,S b){\n\treturn uni(diff(a,b),diff(b,a));\n}\nS comp(S a){\n\tS ans;\n\tEACH(it,data[\"U\"]) if(!a.count(*it)) ans.insert(*it);\n\treturn ans;\n}\n\n\nint pos = 0;\n\nvoid view(S s){\n\tif(s.size()==0) cout << endl;\n\tEACH(it,s){\n\t\tcout << *it;\n\t\tS::iterator it2 = it;\n\t\tit2++;\n\t\tif( it2 == s.end()) cout << endl;\n\t\telse cout << \" \";\n\t}\n}\nset<int> f(int depth){\n\tstring table = \"uids\";\n\tset<int> le,ri;\n\twhile(pos < expr.size()){\n\t\tint jump = 1;\n\t\tif(expr[pos] == ')'){\n\t\t\treturn le;\n\t\t}else if(expr[pos] == '('){\n\t\t\tpos++;\n\t\t\tle = f(depth+1);\n\t\t}else if(expr[pos] == 'c'){\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos+=2;\n\t\t\t\tle = comp(f(depth+1));\n\t\t\t}else{\n\t\t\t\tjump ++;\n\t\t\t\tle = comp(data[string(1,expr[pos+1])]);\n\t\t\t}\n\t\t}else if(~table.find(expr[pos])){\n\t\t\tchar cc = expr[pos];\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos++;\n\t\t\t\tri = f(depth+1);\n\t\t\t}else{\n\t\t\t\tjump++;\n\t\t\t\tri = data[string(1,expr[pos+1])];\n\t\t\t}\n\t\t\tif(cc == 'u') le = uni(le,ri);\n\t\t\tif(cc == 'i') le = inter(le,ri);\n\t\t\tif(cc == 'd') le = diff(le,ri);\n\t\t\tif(cc == 's') le = sym(le,ri);\n\t\t}else{\n\t\t\tle = data[string(1,expr[pos])];\n\t\t}\n\t\tpos += jump;\n\t}\n\treturn le;\n}\nint main(){\n\twhile(1){\n\t\tstring a; int b;\n\t\tif(cin >> a >> b){\n\t\t\tif(a == \"R\" && b == 0){\n\t\t\t\tcin >> expr;\n\t\t\t\tpos = 0;\n\t\t\t\tset<int> res = f(0);\n\t\t\t\tview(res);\n\t\t\t\tdata.clear();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0 ; i < b ; i++){\n\t\t\t\t\tint t; cin >> t;\n\t\t\t\t\tdata[a].insert(t);\n\t\t\t\t\tdata[\"U\"].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}else return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>12) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[10],U;\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0;\n  int l = s.size();\n  set<int> a,b,res;\n\n  if(!s.size())return res;\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p){\n      if(s[i] == 'u'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = U.begin();ite!=U.end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  }\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n\n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<5;i++)alp[i].clear();\n    U.clear();\n    while(c != 'R'){\n      int tmp;\n\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m[c]].insert(tmp);\n\tU.insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> elements;\n\n    Parse(string s, map<char, set<int>> elements){\n        it = s.begin();\n        this->elements = elements;\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> elements;\n        set<int> U;\n\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n\n        elements['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, elements);\n        set<int> res = parse.expr();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//18\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> v[5],u;\nconst char *e;\nint x;\n\nvector<int> exp();\n\nvector<int> ss(){\n  if(e[x]=='('){\n    x++;\n    vector<int> r=exp();\n    x++;\n    return r;\n  }else if(e[x]!='c'){\n    return v[e[x++]-'A'];\n  }else{\n    x++;\n    vector<int> l=ss(),a(u.size());\n    vector<int>::iterator it;\n    it=set_difference(u.begin(),u.end(),l.begin(),l.end(),a.begin());\n    a.resize(it-a.begin());\n    return a;\n  }\n}\n\nvector<int> exp(){\n  vector<int> l=ss();\n  string op=\"uids\";\n  for(char o=e[x];op.find(o)!=string::npos;o=e[x]){\n    x++;\n    vector<int> r=ss(),a(u.size());\n    vector<int>::iterator it;\n    if(o=='u'){\n      it=set_union(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='i'){\n      it=set_intersection(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='d'){\n      it=set_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else{\n      it=set_symmetric_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }\n    a.resize(it-a.begin());\n    l=a;\n  }\n  return l;\n}\n\nint main(){\n  for(;;){\n    for(int i=0;i<5;i++){\n      v[i].clear();\n    }\n    char c;\n    int n;\n    while(cin>>c>>n,c!='R'){\n      if(!cin)return 0;\n      int x=c-'A';\n      v[x].resize(n);\n      while(n--){\n\tcin>>v[x][n];\n\tu.push_back(v[x][n]);\n      }\n      sort(v[x].begin(),v[x].end());\n    }\n    sort(u.begin(),u.end());\n    u.resize(unique(u.begin(),u.end())-u.begin());\n    string s;\n    cin>>s;\n    e=s.c_str();\n    x=0;\n    vector<int> r=exp();\n    if(r.empty()){\n      cout<<\"NULL\"<<endl;\n    }else{\n      for(int i=0;i<r.size();i++){\n\tcout<<r[i]<<((i==r.size()-1)?'\\n':' ');\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> A,B,C,D,E,U;//mapを使った方が楽。\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\nvoid consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret;\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        /*\n        cout << \"vstart \";\n        for(int i=0; i<v.size(); i++){\n            cout << v[i] << \" \";\n        }\n        cout << endl;\n        //*/\n        set_difference(U.begin(), U.end(), v.begin(), v.end(), std::inserter(ret, ret.end()));\n        /*\n        cout << \"retstart \";\n        for(int i=0; i<ret.size(); i++){\n            cout << ret[i] << \" \";\n        }\n        cout << endl;\n        //*/\n    }\n    else {\n        ret = _set(begin);\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n    \n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n\n            if (se == 'A') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    A.push_back(input);\n                    u.insert(input);\n                }\n                sort(A.begin(), A.end());\n            } else if (se == 'B') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    B.push_back(input);\n                    u.insert(input);\n                }\n                sort(B.begin(), B.end());\n            } else if (se == 'C') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    C.push_back(input);\n                    u.insert(input);\n                }\n                sort(C.begin(), C.end());\n            } else if (se == 'D') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    D.push_back(input);\n                    u.insert(input);\n                }\n                sort(D.begin(), D.end());\n            } else if (se == 'E') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    E.push_back(input);\n                    u.insert(input);\n                }\n                sort(E.begin(), E.end());\n            }\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  //else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    p++;\n    s=C(uni,ge());\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nusing P   = pair<ll, ll>;\nusing mat = vector<vector<ll>>;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nvoid IOS() { ios::sync_with_stdio(false), cin.tie(0); }\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-12;\n\ntemplate <typename T>\nvoid dump(T x) { cout << x << endl; }\nvoid dumpf(ld x, int t) { cout << setprecision(t) << fixed << x << endl; }\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\ninline ll mod(ll a, ll b) {\n\tif (a > 0) return a % b;\n\tif (a % b == 0) return 0;\n\tll x = -a / b + 1;\n\ta += x * b;\n\treturn a % b;\n}\nll powm(ll a, ll b, ll c) {\n\tif (b == 0)\n\t\treturn 1;\n\telse if (b % 2 == 0) {\n\t\tll d = powm(a, b / 2, c);\n\t\treturn (d * d) % c;\n\t} else\n\t\treturn (a * powm(a, b - 1, c)) % c;\n}\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n//ll dx[4] = {1, 0, -1, 0};\n//ll dy[4] = {0, 1, 0, -1};\n\nset<ll> num(State &);\nset<ll> factor(State &);\nset<ll> term(State &);\nset<ll> expr(State &);\nset<ll> s[6];\n\nset<ll> num(State &begin) {\n\tint i = *begin - 'A';\n\tbegin++;\n\tset<ll> res = s[i];\n\treturn res;\n}\nset<ll> factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tset<ll> tmp = expr(begin);\n\t\tbegin++;\n\t\treturn tmp;\n\t} else {\n\t\treturn num(begin);\n\t}\n}\nset<ll> term(State &begin) {\n\tif (*begin == 'c') {\n\t\tbegin++;\n\t\tset<ll> tmp = factor(begin);\n\t\tset<ll> res;\n\t\tset_difference(s[5].begin(), s[5].end(), tmp.begin(), tmp.end(), inserter(res, res.end()));\n\t\treturn res;\n\t} else {\n\t\treturn factor(begin);\n\t}\n}\n\nset<ll> expr(State &begin) {\n\tset<ll> res = term(begin);\n\twhile (1) {\n\t\tif (*begin == 'u') {\n\t\t\tbegin++;\n\t\t\tset<ll> ans, tmp = term(begin);\n\t\t\tset_union(res.begin(), res.end(), tmp.begin(), tmp.end(), inserter(ans, ans.end()));\n\t\t\tres = ans;\n\t\t} else if (*begin == 'i') {\n\t\t\tbegin++;\n\t\t\tset<ll> ans, tmp = term(begin);\n\t\t\tset_intersection(res.begin(), res.end(), tmp.begin(), tmp.end(), inserter(ans, ans.end()));\n\t\t\tres = ans;\n\t\t} else if (*begin == 'd') {\n\t\t\tbegin++;\n\t\t\tset<ll> ans, tmp = term(begin);\n\t\t\tset_difference(res.begin(), res.end(), tmp.begin(), tmp.end(), inserter(ans, ans.end()));\n\t\t\tres = ans;\n\t\t} else if (*begin == 's') {\n\t\t\tbegin++;\n\t\t\tset<ll> ans, tmp = term(begin);\n\t\t\tset_symmetric_difference(res.begin(), res.end(), tmp.begin(), tmp.end(), inserter(ans, ans.end()));\n\t\t\tres = ans;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tIOS();\n\tchar a;\n\tint b;\n\twhile (cin >> a >> b) {\n\t\tif (a == 'R') {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tState begin = t.begin();\n\t\t\tset<ll> ans = expr(begin);\n\t\t\tif (ans.size() == 0) {\n\t\t\t\tdump(\"NULL\");\n\t\t\t} else {\n\t\t\t\tbool blank = false;\n\t\t\t\tfor (auto it = ans.begin(); it != ans.end(); it++) {\n\t\t\t\t\tif (blank) cout << \" \";\n\t\t\t\t\tcout << *it;\n\t\t\t\t\tblank = true;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\ts[i].clear();\n\t\t\t}\n\t\t} else {\n\t\t\tint i = a - 'A';\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\tll x;\n\t\t\t\tcin >> x;\n\t\t\t\ts[i].insert(x);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tfor (auto it = s[j].begin(); it != s[j].end(); it++) {\n\t\t\t\t\ts[5].insert(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\n\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(ret, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(ret, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(ret, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(ret, term(begin));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        char se;\n        int n;\n\n        while (cin >> se >> n) {\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        if(sets['U'].size() == 0){\n            break;\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nvi S[6];\nstring expr;\n\nvi calc(vi a,vi b,char op)\n{\n\tvi ret(a.size()+b.size());\n\tvi::iterator it;\n\tswitch(op)\n\t{\n\tcase 'u':\n\t\tit=set_union(all(a),all(b),ret.begin()); break;\n\tcase 'i':\n\t\tit=set_intersection(all(a),all(b),ret.begin()); break;\n\tcase 'd':\n\t\tit=set_difference(all(a),all(b),ret.begin()); break;\n\tcase 's':\n\t\tit=set_symmetric_difference(all(a),all(b),ret.begin()); break;\n\t}\n\tret.erase(it,ret.end());\n\treturn ret;\n}\n\nvi eval(int s,int t)\n{\n\tint d=0,p=t-1; char c;\n\tfor(;p>s;p--)\n\t{\n\t\tc=expr[p];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(p==s)\n\t{\n\t\tif(expr[s]=='(')return eval(s+1,t-1);\n\t\tif(expr[s]=='c')return calc(S[5],eval(s+1,t),'d');\n\t\treturn S[expr[s]-'A'];\n\t}\n\treturn calc(eval(s,p),eval(p+1,t),c);\n}\n\nint main()\n{\n\tchar c; int n;\n\twhile(cin>>c>>n)\n\t{\n\t\trep(i,6)S[i].clear();\n\t\tdo\n\t\t{\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tint t; cin>>t;\n\t\t\t\tS[c-'A'].pb(t);\n\t\t\t\tS[5].pb(t);\n\t\t\t}\n\t\t}while(cin>>c>>n,c!='R');\n\t\t\n\t\trep(i,6)\n\t\t\tsort(all(S[i])),S[i].erase(unique(all(S[i])),S[i].end());\n\t\tcin>>expr;\n\t\t\n\t\tvi ans=eval(0,expr.size());\n\t\tif(ans.empty())cout<<\"NULL\"<<endl;\n\t\telse rp(i,ans)cout<<ans[i]<<(i==ans.size()-1?\"\\n\":\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<string>\n#include<sstream>\n\n#define MAX 128\n#define FOR(i,o) for(__typeof((o).begin()) i=(o).begin();i!=(o).end();++i)\n\nusing namespace std;\n\nclass Set{\npublic:\n  set<int> V;\n  Set Union(const Set &t)const{\n    Set ret;\n    FOR(its,V){ret.V.insert(*its);}\n    FOR(its,t.V){ret.V.insert(*its);}\n    return ret;\n  }\n  Set Intersection(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)!=t.V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  Set Difference(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)==t.V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  Set Symmetric(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)==t.V.end())ret.V.insert(*its);}\n    FOR(its,t.V){if(V.find(*its)==V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  string toString()const{\n    ostringstream oss;\n    FOR(its,V){\n      if(its!=V.begin())oss<<' ';\n      oss<<*its;\n    }\n    return oss.str();\n  }\n  Set Complement()const;\n};\n\ntypedef pair<Set,int> parsed;\n\nSet U; // universal Set\nSet emptySet;\nmap<char,Set> defaultSets;\n\nSet Set::Complement()const{\n  Set ret;\n  FOR(its,U.V){if(V.find(*its)==V.end())ret.V.insert(*its);}\n  return ret;\n}\n\nparsed parse(const parsed &now, const string &expr)\n{\n  parsed ret;\n  int pos = now.second;\n  if( expr[pos] == 'A' || expr[pos] == 'B' ||\n      expr[pos] == 'C' || expr[pos] == 'D' || expr[pos] == 'E' ){\n    ret = parsed( defaultSets[ expr[pos] ], now.second+1 );\n  }\n  if( expr[pos] == '(' ){\n    parsed next(now.first,now.second+1);\n    ret = parse( next, expr );\n    ret.second++;\n  }else if( expr[pos] == 'c' ){\n    char c = expr[now.second+1];\n    if( c == 'A' || c == 'B' ||\n\tc == 'C' || c == 'D' || c == 'E' ){\n      ret = parsed( defaultSets[ c ], now.second + 2 );\n    }else{\n      ret = parse( parsed(emptySet, now.second+1), expr );\n    }\n    ret.first = ret.first.Complement();\n  }\n  pos = ret.second;\n  if( expr[pos] == 'u' || expr[pos] == 'i' ||\n      expr[pos] == 'd' || expr[pos] == 's' ){\n    parsed next(emptySet,pos+1);\n    parsed now;\n    now = parse( next, expr );\n    switch(expr[pos]){\n    case 'u':ret.first = ret.first.Union( now.first );break;\n    case 'i':ret.first = ret.first.Intersection( now.first );break;\n    case 'd':ret.first = ret.first.Difference( now.first );break;\n    case 's':ret.first = ret.first.Symmetric( now.first );break;\n    }\n    ret.second = now.second;\n    return ret;\n  }\n}\n\nint main(){\n  while(true){\n\n    defaultSets['A'].V.clear();\n    defaultSets['B'].V.clear();\n    defaultSets['C'].V.clear();\n    defaultSets['D'].V.clear();\n    defaultSets['E'].V.clear();\n    U.V.clear();\n    while(true){\n      char c;\n      int n;\n      cin >> c; if(cin.eof())return 0;\n      cin >> n;\n      if( c == 'R' && n == 0 ) break;\n      for(int i = 0; i < n; ++i){\n\tint d; cin >> d; defaultSets[c].V.insert(d);\n\tU.V.insert(d);\n      }\n    }\n\n    string expr;\n    cin >> expr;\n    parsed init(emptySet, 0);\n    parsed result = init;\n    while(result.second < expr.length())\n      result = parse(result,expr);\n    cout << result.first.toString() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    string hoge;\n    cin >> hoge;\n  }\n  cout << \"baka\" << endl;\n  // while(1){\n  //   string alphabet;\n  //   int num_of_elements;\n  //   vector<int> numbers[256];\n  //   vector<int> U;\n  //   while(cin >> alphabet >> num_of_elements){\n  //     if(alphabet[0] == 'R' && num_of_elements == 0){\n  //         break;\n  //     }\n      \n  //     for(int element_i = 0; element_i < num_of_elements; element_i++){\n  //         int num;\n  //         cin >> num;\n  //         numbers[alphabet[0]].push_back(num);\n  //     }\n  //     U = compute_union(numbers[alphabet[0]],U);\n  //   }\n  //   string text;\n  //   cin >> text;\n  //   P r = factor(text,numbers,U,0);\n  //   vector<int> result = r.second;\n  //   if(result.size() == 0){\n  //     printf(\"NULL\");\n  //   }\n  //   else{\n  //     for(int i = 0; i < result.size(); i++){\n  //         printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n  //     }\n  //   }\n  //   printf(\"\\n\");\n  //   if(cin.eof()) break;\n  // }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> v[5];\nset<int> all;\nchar ch[5];\nstring str;\nint cnt,pos;\n\nvector<int> factor();\n\nvector<int> exp(){\n  vector<int> x = factor(),y,a;\n  while(str[pos] == 'u' || str[pos] == 'i' || str[pos] == 'd' || str[pos] == 's'){\n    char op = str[pos++];\n    y = factor();\n    if(op == 'u'){\n      for(int i=0;i<x.size();i++) a.push_back(x[i]);\n      for(int i=0;i<y.size();i++) a.push_back(y[i]);\n      sort(a.begin(),a.end());\n      for(int i=0;i<a.size()-1;i++){\n\tif(a[i] == a[i+1]){\n\t  a.erase(a.begin()+i);\n\t  i--;\n\t}\n      }\n    } else if(op == 'i'){\n      for(int i=0;i<x.size();i++)\n\tfor(int j=0;j<y.size();j++)\n\t  if(x[i] == y[j]) a.push_back(x[i]);\n    } else if(op == 'd'){\n      for(int i=0;i<x.size();i++){\n\tbool f = false;\n\tfor(int j=0;j<y.size();j++){\n\t  if(x[i] == y[j]){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n\tif(!f) a.push_back(x[i]);\n      }\n    } else if(op == 's'){\n      vector<int> b,c;\n      for(int i=0;i<x.size();i++){\n\tbool f = false;\n\tfor(int j=0;j<y.size();j++){\n\t  if(x[i] == y[j]){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n\tif(!f) b.push_back(x[i]);\n      }\n      for(int i=0;i<y.size();i++){\n\tbool f = false;\n\tfor(int j=0;j<x.size();j++){\n\t  if(y[i] == x[j]){\n\t    f = true;\n\t    break;\n\t  }\n\t}\n\tif(!f) c.push_back(y[i]);\n      }\n      for(int i=0;i<b.size();i++) a.push_back(b[i]);\n      for(int i=0;i<c.size();i++) a.push_back(c[i]);\n      sort(a.begin(),a.end());\n      for(int i=0;i<a.size()-1;i++){\n\tif(a[i] == a[i+1]){\n\t  a.erase(a.begin()+i);\n\t  i--;\n\t}\n      }\n    }\n    x = a;\n    a.clear();\n  }\n  return x;\n}\n\nvector<int> factor(){\n  vector<int> x;\n  if(str[pos] == '('){\n    pos++;\n    x = exp();\n    pos++;\n  } else if(str[pos] == 'c'){\n    pos++;\n    vector<int> y = factor();\n    for(set<int>::iterator it = all.begin(); it != all.end(); it++){\n      if(find(y.begin(),y.end(),*it) == y.end()) x.push_back(*it);\n    }\n  } else {\n    for(int i=0;i<cnt;i++){\n      if(str[pos] == ch[i]) x = v[i];\n    }\n    pos++;\n  }\n  return x;\n}\n\n\nint main(){\n  char c;\n  int n;\n  while(cin >> c >> n){\n    cnt = pos = 0;\n    for(int i=0;i<5;i++) v[i].clear();\n    while(n != 0){\n      ch[cnt] = c;\n      for(int i=0;i<n;i++){\n\tint x;\n\tcin >> x;\n\tv[cnt].push_back(x);\n\tall.insert(x);\n      }\n      cnt++;\n      cin >> c >> n;\n    }\n    cin >> str;\n    vector<int> ans = exp();\n    if(ans.size() > 0) cout << ans[0];\n    for(int i=1;i<ans.size();i++) cout << ' ' << ans[i];\n    cout << endl;\n  }\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> s[5];\nset<int> u;\nchar *code;\n\nbool consume(char c){\n    if(*code != c) return false;\n    ++code;\n    return true;\n}\n\nvector<int> expr();\nvector<int> unary();\n\nvector<int> expr(){\n    vector<int> ret = unary(), lhs, rhs;\n    while(true){\n        if(consume('u')){\n            lhs.clear();\n            copy(ret.begin(), ret.end(), back_inserter(lhs));\n            ret.clear();\n            rhs = unary();\n            set_union(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), back_inserter(ret));\n        }else if(consume('i')){\n            lhs.clear();\n            copy(ret.begin(), ret.end(), back_inserter(lhs));\n            ret.clear();\n            rhs = unary();\n            set_intersection(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), back_inserter(ret));\n        }else if(consume('d')){\n            lhs.clear();\n            copy(ret.begin(), ret.end(), back_inserter(lhs));\n            ret.clear();\n            rhs = unary();\n            set_difference(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), back_inserter(ret));\n        }else if(consume('s')){\n            lhs.clear();\n            copy(ret.begin(), ret.end(), back_inserter(lhs));\n            ret.clear();\n            rhs = unary();\n            set_symmetric_difference(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), back_inserter(ret));\n        }else break;\n    }\n\n    return ret;\n}\n\nvector<int> unary(){\n    vector<int> ret;\n    if(consume('c')){\n        auto lhs = unary();\n        set_difference(u.begin(), u.end(), lhs.begin(), lhs.end(), back_inserter(ret));\n        return ret;\n    }\n    if(consume('(')){\n        ret = expr();\n        assert(consume(')'));\n        return ret;\n    }\n    if('A' <= *code && *code <= 'E'){\n        return s[*(code++) - 'A'];\n    }\n    assert(false);\n}\n\nint main(){\n    char name;\n    int n;\n    while(cin >> name >> n){\n        for(int i=0;i<5;++i) s[i].clear();\n        u.clear();\n        while(true){\n            if(name == 'R') break;\n            s[name - 'A'].reserve(n);\n            for(int i=0;i<n;++i){\n                int x;\n                cin >> x;\n                s[name - 'A'].push_back(x);\n                u.insert(x);\n            }\n            cin >> name >> n;\n        }\n        for(int i=0;i<5;++i) sort(s[i].begin(), s[i].end());\n        string str;\n        cin >> str;\n        code = new char[str.size() + 1];\n        for(size_t i=0;i<str.size();++i) code[i] = str[i];\n        code[str.size()] = '\\0';\n        \n        auto ans = expr();\n        if(ans.size() == 0) cout << \"NULL\" << endl;\n        else{\n            for(size_t i=0;i<ans.size();++i) cout << ans[i] << \" \\n\"[i==ans.size()-1];\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<string>\n#include<sstream>\n\n#define MAX 128\n#define FOR(i,o) for(__typeof((o).begin()) i=(o).begin();i!=(o).end();++i)\n\nusing namespace std;\n\nclass Set{\npublic:\n  set<int> V;\n  Set Union(const Set &t)const{\n    Set ret;\n    FOR(its,V){ret.V.insert(*its);}\n    FOR(its,t.V){ret.V.insert(*its);}\n    return ret;\n  }\n  Set Intersection(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)!=t.V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  Set Difference(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)==t.V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  Set Symmetric(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)==t.V.end())ret.V.insert(*its);}\n    FOR(its,t.V){if(V.find(*its)==V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  string toString()const{\n    ostringstream oss;\n    FOR(its,V){\n      if(its!=V.begin())oss<<' ';\n      oss<<*its;\n    }\n    return oss.str();\n  }\n  Set Complement()const;\n};\n\ntypedef pair<Set,int> parsed;\n\nSet U; // universal Set\nSet emptySet;\nmap<char,Set> defaultSets;\n\nSet Set::Complement()const{\n  Set ret;\n  FOR(its,U.V){if(V.find(*its)==V.end())ret.V.insert(*its);}\n  return ret;\n}\n\nparsed Term(int pos, const string &expr);\nparsed Expr(int pos, const string &expr);\n\nparsed Expr(int pos, const string &expr){\n  parsed ret;\n  //  cout << \"EXPRESSION : \" << pos << ' ' << expr[pos] << endl;\n  ret = Term( pos, expr );\n  if(ret.second>=expr.length())return ret;\n  while( expr[ ret.second ] == 'u' ||\n\t expr[ ret.second ] == 'i' ||\n\t expr[ ret.second ] == 'd' ||\n\t expr[ ret.second ] == 's' ){\n    parsed operand = Term( ret.second + 1, expr );\n    switch( expr[ ret.second ] ){\n    case 'u':ret.first = ret.first.Union( operand.first );break;\n    case 'i':ret.first = ret.first.Intersection( operand.first );break;\n    case 'd':ret.first = ret.first.Difference( operand.first );break;\n    case 's':ret.first = ret.first.Symmetric( operand.first );break;\n    }\n    ret.second = operand.second;\n    if( ret.second >= expr.length() ) break;\n  }\n  return ret;\n}\n\nparsed Term(int pos, const string &expr){\n  //  cout << \"TERM : \" << pos << ' ' << expr[pos] << endl;\n  if( expr[pos] == '(' ){\n    parsed ret = Expr( pos + 1, expr );\n    ret.second++; // skip ')'\n    return ret;\n  }\n  if( expr[pos] == 'A' || expr[pos] == 'B' ||\n      expr[pos] == 'C' || expr[pos] == 'D' || expr[pos] == 'E' ){\n    return parsed( defaultSets[ expr[pos] ], pos+1 );\n  }\n  if( expr[pos] == 'c' ){\n    parsed ret = Term(pos+1,expr);\n    ret.first = ret.first.Complement();\n    return ret;\n  }\n}\n\nint main(){\n  while(true){\n\n    defaultSets['A'].V.clear();\n    defaultSets['B'].V.clear();\n    defaultSets['C'].V.clear();\n    defaultSets['D'].V.clear();\n    defaultSets['E'].V.clear();\n    U.V.clear();\n    while(true){\n      char c;\n      int n;\n      cin >> c; if(cin.eof())return 0;\n      cin >> n;\n      if( c == 'R' && n == 0 ) break;\n      for(int i = 0; i < n; ++i){\n\tint d; cin >> d; defaultSets[c].V.insert(d);\n\tU.V.insert(d);\n      }\n    }\n\n    string expr;\n    cin >> expr;\n    parsed init(emptySet, 0);\n    parsed result = init;\n    result = Expr(0,expr);\n    cout << result.first.toString() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<sstream>\n#include<iterator>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define osi ostream_iterator<int>\n#define all(c) c.begin(),c.end()\nusing namespace std;\ntypedef set<int> si;\nsi sCalc(char o,si l,si r){\n\tint t;si a;stringstream ss;\n\tswitch(o){\n\tcase 'u':\n\t\tset_union(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'i':\n\t\tset_intersection(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'd':\n\t\tset_difference(all(l),all(r),osi(ss,\" \"));break;\n\tcase 's':\n\t\tset_symmetric_difference(all(l),all(r),osi(ss,\" \"));break;\n\t}\n\twhile(ss>>t)a.insert(t);\n\treturn a;\n}\nsi st[5],u,ans; string expr;\nsi prs(int s,int t){\n\tint oi,p=0;char c;\n\tfor(oi=s;oi<t;oi++){\n\t\tc=expr[oi];if(c=='(')p++;if(c==')')p--;\n\t\tif(p==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(oi==t){\n\t\tif(expr[s]=='(')return prs(s+1,t-1);\n\t\tif(s+1==t)return st[expr[s]-'A'];\n\t\tif(expr[s]=='c')return sCalc('d',u,prs(s+1,t));\n\t}\n\treturn sCalc(expr[oi],prs(s,oi),prs(oi+1,t));\n}\nint main(){\n\tchar c; int k,t;\n\twhile(cin>>c>>k){\n\t\tif(c=='R'){\n\t\t\tcin>>expr;ans=prs(0,expr.size());\n\t\t\tfor(__typeof(ans.begin()) i=ans.begin();i!=ans.end();i++){\n\t\t\t\tif(i!=ans.begin())cout<<\" \";\n\t\t\t\tcout<<*i;\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,5)st[i].clear();ans.clear();\n\t\t}else rep(i,k)cin>>t,st[c-'A'].insert(t),u.insert(t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint INF = (1<<24);\n\nvector<int> U;\nmap < int,bool > used;\n\nmap < char , vector<int> > t;\n\nstring str;\nint pos;\n\nbool input();\n\nvector<int> calc(vector<int>,char ch,vector<int>);\n\nvector<int> compute();\nvector<int> get();\n\nint main(){\n  vector<int> ans;\n  while(input()){\n    pos=0;\n    ans=compute();\n    /*\n    for(int i=0;i<(int)t['A'].size();i++){\n      cout<<t['A'][i]<<' ';\n    }\n    cout<<endl;\n    for(int i=0;i<(int)t['B'].size();i++){\n      cout<<t['B'][i]<<' ';\n    }\n    cout<<endl;\n\n    ans=calc(t['A'],'s',t['B']);\n    for(int i=0;i<(int)ans.size();i++){\n      cout<<ans[i]<<' ';\n    }\n    cout<<endl;\n    */\n    \n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n\nbool input(){\n  int n,a;\n  char ch;\n  U.clear();\n  used.clear();\n  t.clear();\n  while(1){\n    if(cin>>ch){\n    }else{\n      return false; \n    }\n    cin>>n;\n    if(ch=='R'&&n==0)break;\n    for(int i=0;i<n;i++){\n      cin>>a;\n\n      if(used[a]==false){U.push_back(a);used[a]=true;}\n\n      t[ch].push_back(a);\n    }\n    sort(t[ch].begin(),t[ch].end());\n  }\n  sort(U.begin(),U.end());\n  t['U']=U;\n  cin>>str;\n  str.push_back('=');\n  return true;\n}\n\nvector<int> calc(vector<int> A,char ch,vector<int> B){\n\n  int a=0,b=0,Asize=A.size(),Bsize=B.size(),nowA,nowB; \n  vector<int> res;\n\n  if(ch=='u'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n\n  }else if(ch=='i'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\tres.push_back(nowA);\n\ta++;b++;\n      }else if(nowA<nowB){\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n\n  }else if(ch=='d'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tb++;\n      }\n    }\n    \n  }else if(ch=='s'){\n    while(a<Asize||b<Bsize){\n      nowA=(a<Asize?A[a]:INF);\n      nowB=(b<Bsize?B[b]:INF);\n      if(nowA==nowB){\n\ta++;b++;\n      }else if(nowA<nowB){\n\tres.push_back(nowA);\n\ta++;\n      }else{\n\tres.push_back(nowB);\n\tb++;\n      }\n    }\n  }\n\n  return res;\n}\n\n\nvector<int> compute(){\n\n  vector<int> res,X;\n  char ch;\n  res=get();\n\n  while(1){\n    ch=str[pos++];\n    if(ch=='='||ch==')')break;\n    X=get();\n    res=calc(res,ch,X);\n  }\n\n  return res;\n}\n\n\nvector<int> get(){\n  if(str[pos]=='('){\n    pos++;\n    return compute();\n  }else if(str[pos]=='c'){\n    pos++;\n    return calc(U,'d',get());\n  }else{\n    pos++;\n    return t[str[pos-1]];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> A,B,C,D,E,U;//mapを使った方が楽。\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\nvoid consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret;\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        /*\n        cout << \"vstart \";\n        for(int i=0; i<v.size(); i++){\n            cout << v[i] << \" \";\n        }\n        cout << endl;\n        //*/\n        set_difference(U.begin(), U.end(), v.begin(), v.end(), std::inserter(ret, ret.end()));\n        /*\n        cout << \"retstart \";\n        for(int i=0; i<ret.size(); i++){\n            cout << ret[i] << \" \";\n        }\n        cout << endl;\n        //*/\n    }\n    else {\n        ret = _set(begin);\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n    \n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n\n            if (se == 'A') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    A.push_back(input);\n                    u.insert(input);\n                }\n                sort(A.begin(), A.end());\n            } else if (se == 'B') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    B.push_back(input);\n                    u.insert(input);\n                }\n                sort(B.begin(), B.end());\n            } else if (se == 'C') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    C.push_back(input);\n                    u.insert(input);\n                }\n                sort(C.begin(), C.end());\n            } else if (se == 'D') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    D.push_back(input);\n                    u.insert(input);\n                }\n                sort(D.begin(), D.end());\n            } else if (se == 'E') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    E.push_back(input);\n                    u.insert(input);\n                }\n                sort(E.begin(), E.end());\n            }\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nmap<char,set<int> > m;\nset<int> N();\nset<int> solve();\nset<int> u;\nstring s;\nint p;\n\nset<int> U(set<int> a, set<int> b) {\n  tr(it,b) a.insert(*it);\n  return a;\n}\nset<int> I(set<int> a, set<int> b) {\n  set<int> c;\n  tr(it,b) {\n    if(a.count(*it)) c.insert(*it);\n  }\n  return c;\n}\nset<int> D(set<int> a, set<int> b) {\n  set<int> c;\n  tr(it,a) {\n    if(!b.count(*it)) c.insert(*it);\n  }\n  return c;\n}\nset<int> S(set<int> a, set<int> b) {\n  set<int> c=D(a,b),d=D(b,a);\n  return U(c,d);\n}\nset<int> C(set<int> a) {\n  set<int> b;\n  tr(it,u) {\n    if(!a.count(*it)) b.insert(*it);\n  }\n  return b;\n}\n\nset<int> N() {\n  if(s[p]=='(') {\n    p++;\n    return solve();\n  } else if(s[p]=='c') {\n    p++;\n    return C(N());\n  }\n  set<int> a=m[s[p]];\n  p++;\n  return a;\n}\n\nset<int> solve() {\n  set<int> a=N();\n  while(p<s.size()&&s[p]!=')') {\n    char ch=s[p];p++;\n    set<int> b=N();\n    if(ch=='u') a=U(a,b);\n    else if(ch=='i') a=I(a,b);\n    else if(ch=='d') a=D(a,b);\n    else a=S(a,b);\n  }\n  p++;\n  return a;\n}\n  \nint main() {\n  char c;\n  int n;\n  while(cin >> c >> n) {\n    m.clear();\n    u.clear();\n    for(int i=0; i<n; i++) {\n      int x;\n      cin >> x;\n      m[c].insert(x);\n      u.insert(x);\n    }\n    while(cin >> c >> n && c!='R') {\n      for(int i=0; i<n; i++) {\n        int x;\n        cin >> x;\n        m[c].insert(x);\n        u.insert(x);\n      }\n    }\n    cin >> s;\n    p=0;\n    set<int> ans=solve();\n    if(ans.size()) {\n      bool f=0;\n      tr(it,ans) {\n        if(f) cout << \" \";f=1;\n        cout << *it;\n      }\n      cout << endl;\n    } else cout << \"NULL\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n#define EACH(it,n) for(S::iterator it = (n).begin(); it != (n).end() ; ++it)\ntypedef set<int> S;\nmap< string , S > data;\n\n\nstring expr;\n\nS uni(S a,S b){\n\tS ans;\n\tEACH(it,a) ans.insert(*it);\n\tEACH(it,b) ans.insert(*it);\n\treturn ans;\n}\nS inter(S a,S b){\n\tS ans;\n\tEACH(it,a) if(b.count(*it))ans.insert(*it);\n\treturn ans;\n}\nS diff(S a,S b){\n\tS ans;\n\tEACH(it,a) if(!b.count(*it))ans.insert(*it);\n\treturn ans;\n} \nS sym(S a,S b){\n\treturn uni(diff(a,b),diff(b,a));\n}\nS comp(S a){\n\tS ans;\n\tEACH(it,data[\"U\"]) if(!a.count(*it)) ans.insert(*it);\n\treturn ans;\n}\n\n\nint pos = 0;\n\nvoid view(S s){\n\tEACH(it,s){\n\t\tcout << *it;\n\t\tS::iterator it2 = it;\n\t\tit2++;\n\t\tif( it2 == s.end()) cout << endl;\n\t\telse cout << \" \";\n\t}\n}\nset<int> f(){\n\tstring table = \"uids\";\n\tset<int> le,ri;\n\twhile(pos < expr.size()){\n\t\tint jump = 1;\n\t\tif(expr[pos] == ')'){\n\t\t\treturn le;\n\t\t}else if(expr[pos] == '('){\n\t\t\tpos++;\n\t\t\tle = f();\n\t\t}else if(expr[pos] == 'c'){\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos++;\n\t\t\t\tle = comp(f());\n\t\t\t}else{\n\t\t\t\tjump ++;\n\t\t\t\tle = comp(data[string(1,expr[pos+1])]);\n\t\t\t}\n\t\t}else if(~table.find(expr[pos])){\n\t\t\tchar cc = expr[pos];\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos++;\n\t\t\t\tri = f();\n\t\t\t}else{\n\t\t\t\tjump++;\n\t\t\t\tri = data[string(1,expr[pos+1])];\n\t\t\t}\n\t\t\tif(cc == 'u') le = uni(le,ri);\n\t\t\tif(cc == 'i') le = inter(le,ri);\n\t\t\tif(cc == 'd') le = diff(le,ri);\n\t\t\tif(cc == 's') le = sym(le,ri);\n\t\t}else{\n\t\t\tle = data[string(1,expr[pos])];\n\t\t}\n\t\tpos += jump;\n\t}\n\treturn le;\n}\nint main(){\n\twhile(1){\n\t\tstring a; int b;\n\t\tif(cin >> a >> b){\n\t\t\tif(a == \"R\" && b == 0){\n\t\t\t\tcin >> expr;\n\t\t\t\tpos = 0;\n\t\t\t\tset<int> res = f();\n\t\t\t\tview(res);\n\t\t\t\tdata.clear();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0 ; i < b ; i++){\n\t\t\t\t\tint t; cin >> t;\n\t\t\t\t\tdata[a].insert(t);\n\t\t\t\t\tdata[\"U\"].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}else return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[1000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 2)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tif(check[A[i]] == false){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 1)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tif(check[U[i]] == false){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tcheck[V[i][k]] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])U.push_back(i);\n\t}\n}\n\n\nvector<int> recursive(int left,int right){\n\n\t/*printf(\"\\n\\nleft:%d right:%d\\n\",left,right);\n\tfor(int i = left; i <= right; i++){\n\t\tprintf(\"%c\",equation[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\t\t\t//printf(\"???????????????\\n\");\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\t//printf(\"left??±??????()\\n\");\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t\t}*/\n\t\t\t}else{\n\n\t\t\t\t//printf(\"right??±??????()\\n\");\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_right.size(); k++){\n\t\t\t\t\tprintf(\"calc_right[%d]:%d\\n\",k,calc_right[k]);\n\t\t\t\t}*/\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\t//printf(\"?????????:%c\\n\",equation[index]);\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\t/*printf(\"??????:%c\\n\",equation[index]);\n\t\t\tfor(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"??? calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\t//printf(\"%d??¨intersect\\n\",loc[equation[index]-'A']);\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\t/*for(int i = 0; i < U.size(); i++){\n\t\tprintf(\"U[%d]:%d\\n\",i,U[i]);\n\t}*/\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tauto n = exp();\n\t\tn = calc(mp['U'], n, 'd');\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\tassert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa) {\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty()) {\n\t\t\t\tcout << \"NULL\" << endl;\n\t\t\t}\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nVI factor(State&);\nVI term(State&);\n\nmap<char, VI> mp;\nVI all;\n\n// begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n            << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nVI uni(VI a, VI b) {\n\tVI ret;\n\tfor(int i: a) ret.PB(i);\n\tfor(int i: b) ret.PB(i);\n\tsort(ALL(ret));\n\tret.erase(unique(ALL(ret)), ret.end());\n\treturn ret;\n}\n\nVI inter(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: b) {\n\t\tif(tmp.find(i) != tmp.end()) {\n\t\t\tret.PB(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI diff(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: b) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: a) {\n\t\tif(tmp.find(i) == tmp.end()) {\n\t\t\tret.PB(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nVI symm(VI a, VI b) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tfor(int i: b) {\n\t\tif(tmp.find(i) != tmp.end()) tmp[i] = 2;\n\t\telse tmp[i] = 1;\n\t}\n\tVI ret;\n\tfor(int i: a) if(tmp[i] == 1) ret.PB(i);\n\tfor(int i: b) if(tmp[i] == 1) ret.PB(i);\n\treturn ret;\n}\n\nVI comp(VI a) {\n\tmap<int, int> tmp;\n\tfor(int i: a) tmp[i] = 1;\n\tVI ret;\n\tfor(int i: all) if(tmp.find(i) == tmp.end()) ret.PB(i);\n\treturn ret;\n}\n\nVI expr(State &begin) {\n\t//cout << \"st:\" << *begin << endl;\n\tVI ret = term(begin);\n\twhile(1) {\n\t\t//cout << *begin << endl;\n\t\tif(*begin == 'u') {\n\t\t\tbegin++;\n\t\t\tret = uni(ret, term(begin));\n\t\t} else if(*begin == 'i') {\n\t\t\tbegin++;\n\t\t\tret = inter(ret, term(begin));\n\t\t} else if(*begin == 'd') {\n\t\t\tbegin++;\n\t\t\tret = diff(ret, term(begin));\n\t\t} else if(*begin == 's') {\n\t\t\tbegin++;\n\t\t\tret = symm(ret, term(begin));\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nVI term(State &begin) {\n\t//cout << \"te:\" << *begin << endl;\n\tif(*begin == 'c') {\n\t\tbegin++;\n\t\treturn comp(factor(begin));\n\t} else {\n\t\treturn factor(begin);\n\t}\n}\n\nVI factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tVI ret = expr(begin);\n\t\tconsume(begin, ')');\n\t\treturn ret;\n\t} else if(isupper(*begin)){\n\t\tVI ret = mp[*begin];\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\treturn {};\n}\n\nsigned main(void)\n{\n\tchar name;\n\tint num;\n\twhile(cin >> name >> num) {\n\t\tif(name == 'R' && num == 0) {\n\t\t\tfor(auto i: mp) {\n\t\t\t\tfor(int j: i.second) {\n\t\t\t\t\tall.PB(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(all));\n\t\t\tall.erase(unique(ALL(all)), all.end());\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tState begin = s.begin();\n\t\t\tVI ans = expr(begin);\n\t\t\tsort(ALL(ans));\n\t\t\tREP(i, ans.size()) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif(i != ans.size()-1) cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tmp.erase(ALL(mp));\n\t\t\tall.erase(ALL(all));\n\t\t}\n\t\tREP(i, num) {\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\tmp[name].PB(m);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\nelse exit(0);\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,p++;//,s=C(uni,st[S[p++]-'A']);\n  else s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    //if(S[t]=='u')s=U(s,g);\n    //if(S[t]=='i')s=I(s,g);\n    //if(S[t]=='d')s=D(s,g);\n    //if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> V;\nV A[10],U;\nstring S;\n\nV Union(V a,V b){\n  for(int i=0;i<(int)b.size();i++) a.push_back(b[i]);\n  sort(a.begin(),a.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  return a;\n}\n\nV Inter(V a,V b){\n  V res;\n  int n =a.size(),m=b.size();\n  a.push_back(1e9),b.push_back(1e9);\n  int i = 0,j = 0;\n  while(i<n||j<m){\n    if(a[i]<b[j])i++;\n    else if(a[i]>b[j])j++;\n    else res.push_back(a[i]),i++,j++;\n  }\n  return res;\n}\n\nV Diff(V a,V b){\n  V res;\n  int n = a.size();\n  int m = b.size();\n  b.push_back(1e9);\n  \n  int j =0;\n  for(int i=0;i<n;i++){\n    while(a[i]>b[j])j++;\n    if(a[i]!=b[j]) res.push_back(a[i]);\n  }\n  return res;\n}\n\nV Sdiff(V a,V b){return Union(Diff(a,b),Diff(b,a));}\n\nV Comp(V a){\n  V res;\n  int j = 0;\n  a.push_back(1e9);\n  for(int i=0;i<(int)U.size();i++) {\n    while(a[j] < U[i])j++;\n    if(a[j]!=U[i]) res.push_back(U[i]);\n  }\n  return res;\n}\n\nint p = 0;\nV bnf();\nV getV(){\n  char ch = S[p];\n  V res;\n  if(ch == '(')p++,res = bnf(),p++;\n  else if(isupper(ch))p++,res = A[ch-'A'];\n  else if(ch=='c')p++,res = Comp(getV());\n  else assert(isupper(ch));\n  return res;\n}\n\nV bnf(){\n  V res;\n  while(1){\n    char ch = S[p];\n    if(isupper(ch))p++, res = A[ch-'A'];\n    else if(ch=='(')p++,res = bnf(),p++;\n    else if(ch=='c')p++,res = Comp(getV());\n    else if(ch=='u')p++,res = Union(res,getV());\n    else if(ch=='i')p++,res = Inter(res,getV());\n    else if(ch=='d')p++,res = Diff(res,getV());\n    else if(ch=='s')p++,res = Sdiff(res,getV());\n    else if(p<S.size()&&ch!=')')assert(ch==')');\n    else break;\n  }\n  return res;\n}\n\nint main(){\n\n  while(1){\n    U.clear();\n    while(1){\n      char ch;\n      int n;\n      if(!(cin>>ch>>n))exit(0);\n      if(ch == 'R' && n == 0) break;\n      int idx = ch-'A';\n      A[idx].resize(n);\n      for(int i=0;i<n;i++)cin>>A[idx][i],U.push_back(A[idx][i]);\n      sort(A[idx].begin(),A[idx].end());\n      A[idx].erase(unique(A[idx].begin(),A[idx].end()),A[idx].end());\n    }\n    \n    sort(U.begin(),U.end());\n    U.erase(unique(U.begin(),U.end()),U.end());\n    cin >> S;\n    p = 0;\n    V ans = bnf();\n\n    for(int i=0;i<ans.size();i++){\n      if(i)cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\ntypedef set<int>::iterator si;\n\nset<int> s[6];\nstring str;\nint pos;\n\nset<int> exp();\n\nset<int> val(){\n\tset<int> res;\n\tif(str[pos] == 'c'){\n\t\t++pos;\n\t\tset<int> tmp = val();\n\t\tfor(si ite=s[5].begin();ite!=s[5].end();++ite){\n\t\t\tif(tmp.find(*ite) == tmp.end()) res.insert(*ite);\n\t\t}\n\t}else if(str[pos] == '('){\n\t\t++pos;\n\t\tres = exp();\n\t\t++pos;\n\t}else if('A' <= str[pos] && str[pos] <= 'D'){\n\t\tres = s[str[pos] - 'A'];\n\t\t++pos;\n\t}\n\t//cout << \"res.size() = \" << res.size() << endl;\n\treturn res;\n}\n\nset<int> exp(){\n\tset<int> a = val();\n\twhile(pos < str.size()){\n\t\t//for(int i=0;i<5;i++){\n\t\t//cout << pos << endl;\n\t\tset<int> b, c;\n\t\tif(str[pos] == 'u'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite) c.insert(*ite);\n\t\t\tfor(si ite=b.begin();ite!=b.end();++ite) c.insert(*ite);\n\t\t}else if(str[pos] == 'i'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) != b.end()) c.insert(*ite);\n\t\t\t}\n\t\t}else if(str[pos] == 'd'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) == b.end()) c.insert(*ite);\n\t\t\t}\n\t\t}else if(str[pos] == 's'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tset<int> d, e;\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) == b.end()) d.insert(*ite);\n\t\t\t}\t\t\n\t\t\tfor(si ite=b.begin();ite!=b.end();++ite){\n\t\t\t\tif(a.find(*ite) == a.end()) e.insert(*ite);\n\t\t\t}\t\t\n\t\t\tfor(si ite=d.begin();ite!=d.end();++ite) c.insert(*ite);\n\t\t\tfor(si ite=e.begin();ite!=e.end();++ite) c.insert(*ite);\t\t\n\t\t}else break;\n\t\ta = c;\n\t}\n\treturn a;\n}\n\nint main(){\n\tchar c;\n\tint n;\n\twhile(cin >> c >> n){\n\t\tfor(int i=0;i<6;++i) s[i].clear();\n\t\twhile(1){\n\t\t\tif(c == 'R' && n == 0) break;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\ts[c-'A'].insert(in);\n\t\t\t}\n\t\t\tcin >> c >> n;\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(si ite=s[i].begin();ite!=s[i].end();++ite) s[5].insert(*ite);\n\t\t}\n\t\tcin >> str;\n\t\tpos = 0;\n\t\tset<int> ans = exp();\n\t\tif(ans.size() == 0){\n\t\t\tcout << \"NULL\" << endl;\n\t\t}else{\n\t\t\tfor(si ite=ans.begin();ite!=ans.end();++ite){\n\t\t\t\tif(ite != ans.begin()) cout << ' ';\n\t\t\t\tcout << *ite;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>20) break;\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> term(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> D(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(), my_right.begin(), my_right.end(), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> U(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> S(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), back_inserter(ret));\n\n    return ret;\n}\n\nvector<int> C(vector<int> v){\n    vector<int> ret = {};\n    std::set_difference(sets['U'].begin(), sets['U'].end(), v.begin(), v.end(), back_inserter(ret));\n    return ret;\n}\n\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            ret = U(ret, term(begin));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            ret = I(ret, term(begin));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            ret = D(ret, term(begin));\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            ret = S(ret, term(begin));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> term(State &begin) {\n\n    /*\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = D(sets['U'], v);\n    }\n    else {\n        ret = factor(begin);\n    }\n\n    return ret;\n    */\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        return C(factor(begin));\n    }\n    else{\n        return factor(begin);\n    }\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        /*\n        vector<int> ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n        return ret;\n         */\n        return sets[*begin++];\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        sets.clear();\n\n        char se;\n        int n;\n\n        while (cin >> se >> n) {\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    sets['U'].push_back(input);\n                }\n            }\n        }\n\n        if(sets['U'].size() == 0){\n            break;\n        }\n\n        for(auto &itr : sets){\n            sort(itr.second.begin(), itr.second.end());\n        }\n\n        //重複削除\n        compress(sets['U']);\n\n        cin.ignore();\n        string formula;\n        getline(cin, formula);\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.empty()) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<string>\n#include<sstream>\n\n#define MAX 128\n#define FOR(i,o) for(__typeof((o).begin()) i=(o).begin();i!=(o).end();++i)\n\nusing namespace std;\n\nclass Set{\npublic:\n  set<int> V;\n  Set Union(const Set &t)const{\n    Set ret;\n    FOR(its,V){ret.V.insert(*its);}\n    FOR(its,t.V){ret.V.insert(*its);}\n    return ret;\n  }\n  Set Intersection(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)!=t.V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  Set Difference(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)==t.V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  Set Symmetric(const Set &t)const{\n    Set ret;\n    FOR(its,V){if(t.V.find(*its)==t.V.end())ret.V.insert(*its);}\n    FOR(its,t.V){if(V.find(*its)==V.end())ret.V.insert(*its);}\n    return ret;\n  }\n  string toString()const{\n    ostringstream oss;\n    if(V.size() == 0)oss<<\"NULL\";\n    FOR(its,V){\n      if(its!=V.begin())oss<<' ';\n      oss<<*its;\n    }\n    return oss.str();\n  }\n  Set Complement()const;\n};\n\ntypedef pair<Set,int> parsed;\n\nSet U; // universal Set\nSet emptySet;\nmap<char,Set> defaultSets;\n\nSet Set::Complement()const{\n  Set ret;\n  FOR(its,U.V){if(V.find(*its)==V.end())ret.V.insert(*its);}\n  return ret;\n}\n\nparsed Term(int pos, const string &expr);\nparsed Expr(int pos, const string &expr);\n\nparsed Expr(int pos, const string &expr){\n  parsed ret;\n  //  cout << \"EXPRESSION : \" << pos << ' ' << expr[pos] << endl;\n  ret = Term( pos, expr );\n  if(ret.second>=expr.length())return ret;\n  while( expr[ ret.second ] == 'u' ||\n\t expr[ ret.second ] == 'i' ||\n\t expr[ ret.second ] == 'd' ||\n\t expr[ ret.second ] == 's' ){\n    parsed operand = Term( ret.second + 1, expr );\n    switch( expr[ ret.second ] ){\n    case 'u':ret.first = ret.first.Union( operand.first );break;\n    case 'i':ret.first = ret.first.Intersection( operand.first );break;\n    case 'd':ret.first = ret.first.Difference( operand.first );break;\n    case 's':ret.first = ret.first.Symmetric( operand.first );break;\n    }\n    ret.second = operand.second;\n    if( ret.second >= expr.length() ) break;\n  }\n  return ret;\n}\n\nparsed Term(int pos, const string &expr){\n  //  cout << \"TERM : \" << pos << ' ' << expr[pos] << endl;\n  if( expr[pos] == '(' ){\n    parsed ret = Expr( pos + 1, expr );\n    ret.second++; // skip ')'\n    return ret;\n  }\n  if( expr[pos] == 'A' || expr[pos] == 'B' ||\n      expr[pos] == 'C' || expr[pos] == 'D' || expr[pos] == 'E' ){\n    return parsed( defaultSets[ expr[pos] ], pos+1 );\n  }\n  if( expr[pos] == 'c' ){\n    parsed ret = Term(pos+1,expr);\n    ret.first = ret.first.Complement();\n    return ret;\n  }\n}\n\nint main(){\n  while(true){\n\n    defaultSets['A'].V.clear();\n    defaultSets['B'].V.clear();\n    defaultSets['C'].V.clear();\n    defaultSets['D'].V.clear();\n    defaultSets['E'].V.clear();\n    U.V.clear();\n    while(true){\n      char c;\n      int n;\n      cin >> c; if(cin.eof())return 0;\n      cin >> n;\n      if( c == 'R' && n == 0 ) break;\n      for(int i = 0; i < n; ++i){\n\tint d; cin >> d; defaultSets[c].V.insert(d);\n\tU.V.insert(d);\n      }\n    }\n\n    string expr;\n    cin >> expr;\n    parsed init(emptySet, 0);\n    parsed result = init;\n    result = Expr(0,expr);\n    cout << result.first.toString() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nmap<char, vector<int> > sets;\nvector<int> parse(const string& e)\n{\n\tif (e.empty())\n\t\treturn vector<int>();\n\telse if (e.size() == 1)\n\t\treturn sets[e[0]];\n\telse if (e.size() == 2)\n\t{\n\t\tvector<int> res(sets['U'].size() - sets[e[1]].size());\n\t\tset_symmetric_difference(all(sets[e[1]]), all(sets['U']), res.begin());\n\t\treturn res;\n\t}\n\t\n\tvector<int> left, right;\n\tchar ope;\n\tif (e[0] == '(')\n\t{\n\t\tint i, par = 1;\n\t\tfor (i = 1; par; ++i)\n\t\t{\n\t\t\tif (e[i] == '(')\n\t\t\t\t++par;\n\t\t\telse if (e[i] == ')')\n\t\t\t\t--par;\n\t\t}\n\t\tope = e[i];\n\t\tleft = parse(e.substr(1, i - 2));\n\t\tif (i == e.size())\n\t\t\treturn left;\n\t\tright = parse(e.substr(i + 1, e.size() - (i + 1)));\n\t}\n\telse if (e[0] == 'c')\n\t{\n\t\tope = e[2];\n\t\tleft = parse(e.substr(0, 2));\n\t\tright = parse(e.substr(3, e.size() - 3));\n\t}\n\telse\n\t{\n\t\tope = e[1];\n\t\tleft = parse(e.substr(0, 1));\n\t\tright = parse(e.substr(2, e.size() - 2));\n\t}\n\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nint main()\n{\n\twhile (!feof(stdin))\n\t{\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tscanf(\" %c%d\", &a, &n);\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tstatic char buf[4096];\n\t\tscanf(\" %s\", buf);\n\t\tvector<int> res = parse(buf);\n\t\tif (res.empty())\n\t\t\tputs(\"NULL\");\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t\tprintf(\"%d%c\", res[i], i + 1 == res.size() ? '\\n' : ' ');\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nmap<char, vector<int> > sets;\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nvector<int> parse(const string& e)\n{\n\tint p = e.size() - 1;\n\tfor (int par = 0; p >= 0; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < 0)\n\t{\n\t\tif (e[0] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(e.substr(1)));\n\t\telse if (e[0] == '(')\n\t\t\treturn parse(e.substr(1, e.size() - 2));\n\t\telse\n\t\t\treturn sets[e[0]];\n\t}\n\n\treturn calculate(e[p], parse(e.substr(0, p)), parse(e.substr(p + 1, e.size() - (p + 1))));\n}\nint main()\n{\n\twhile (!feof(stdin))\n\t{\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tscanf(\" %c%d\", &a, &n);\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tchar buf[512];\n\t\tscanf(\" %s\", buf);\n\t\tvector<int> res = parse(buf);\n\t\tif (res.empty())\n\t\t\tputs(\"NULL\");\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t\tprintf(\"%d%c\", res[i], i + 1 == res.size() ? '\\n' : ' ');\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,const vector<int>& U, int pos);\nP term(const string& str,const vector<int>& U, int pos);\nvector<int> numbers[256];\nvector<int> U;\n\nP factor(const string& str,const vector<int>& U, int pos){\n  vector<int> current_set;\n\n  P r1 = term(str,U,pos);\n  pos = r1.first;\n  current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str, const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,U,pos+1);\n    return P(r.first,compute_complement(r.second,U));\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    char alphabet[8];\n    int num_of_elements;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < 256; i++){\n      numbers[i].clear();\n    }\n    U.clear();\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\ntypedef set<int>S;\nS s['U'+1];\nS::iterator q;\nchar e[9999];\nint p;\nS PT();\nS OU(S a,S b){\n\tfor(q=b.begin();q!=b.end();++q)\n\t\ta.insert(*q);\n\treturn a;\n}\nS OD(S a,S b){\n\tfor(q=b.begin();q!=b.end();++q)\n\t\ta.erase(*q);\n\treturn a;\n}\nS OS(S a,S b){\n\tfor(q=b.begin();q!=b.end();++q)\n\t\tif(a.erase(*q)==0)\n\t\t\ta.insert(*q);\n\treturn a;\n}\nS OC(S a){\n\treturn OD(s['U'],a);\n}\nS OI(S a,S b){\n\treturn OD(a,OC(b));\n}\nS PB(){\n\tS a=PT();\n\tfor(;;){\n\t\tif(e[p]=='u'){\n\t\t\tp++;\n\t\t\ta=OU(a,PT());\n\t\t}else if(e[p]=='i'){\n\t\t\tp++;\n\t\t\ta=OI(a,PT());\n\t\t}else if(e[p]=='d'){\n\t\t\tp++;\n\t\t\ta=OD(a,PT());\n\t\t}else if(e[p]=='s'){\n\t\t\tp++;\n\t\t\ta=OS(a,PT());\n\t\t}else \n\t\t\treturn a;\n\t}\n}\nS PT(){\n\tS a;\n\tint c=0;\n\tif(e[p]=='('){\n\t\tp++;\n\t\ta=PB();\n\t\tp++;\n\t}else if(e[p]=='c'){\n\t\tp++;\n\t\ta=OC(PT());\n\t}else{\n\t\ta=s[e[p]];\n\t\tp++;\n\t}\n\treturn a;\n}\nint main(){\n\tchar n;\n\tint m,v;\n\tfor(;cin>>n>>m;){\n\t\tif(n!='R'){\n\t\t\ts[n].clear();\n\t\t\tfor(;m--;){\n\t\t\t\tcin>>v;\n\t\t\t\ts[n].insert(v);\n\t\t\t\ts['U'].insert(v);\n\t\t\t}\n\t\t}else{\n\t\t\tcin>>e;\n\t\t\tp=0;\n\t\t\tS r=PB();\n\t\t\tfor(q=r.begin();q!=r.end();){\n\t\t\t\tcout<<*q;\n\t\t\t\tcout<<(++q!=r.end()?' ':'\\n');\n\t\t\t}\n\t\t\tif(r.empty())\n\t\t\t\tcout<<\"NULL\\n\";\n\t\t\ts['U'].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tauto n = exp();\n\t\tn = calc(mp['U'], n, 'd');\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\tassert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele) :\n        ele(ele) {\n        it = s.begin();\n    }\n    \n    set<int> fact()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n\n    set<int> term()\n    {\n        set<int> a;\n        if(*it == 'c'){\n            ++it;\n            a = fact();\n            a = complement(a);\n        }else{\n            a = fact();\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    bool eof = 0;\n    while(1)\n    {\n        map<char, set<int>> ele;\n        set<int> U;\n        while(1)\n        {\n            if(cin >> ch >> N){\n                if(ch == 'R') break;\n                set<int> st;\n                for(int i = 0 ; i < N ; i++){\n                    cin >> x;\n                    st.insert(x);\n                    U.insert(x);\n                }                    \n                ele[ch] = st;\n            }else{\n                eof = 1;\n                break;\n            }\n        }\n        if(eof) break;\n\n        ele['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(pos >= str.size()){\n    return P(pos+1,U);\n  }\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(1){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n          break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n          int num;\n          cin >> num;\n          numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n          printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n    if(cin.eof()) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct evaluator\n{\n  vector<int> all;\n  vector<int> sets[5];\n\n  vector<int> factor(Iterator& it, const Iterator& last) const\n  {\n    if (*it == '(') {\n      ++it;\n      const vector<int> r = expr(it, last);\n      ++it;\n      return r;\n    } else {\n      const int i = *it-'A';\n      ++it;\n      return sets[i];\n    }\n  }\n\n  vector<int> term(Iterator& it, const Iterator& last) const\n  {\n    if (*it == 'c') {\n      ++it;\n      const vector<int> s = factor(it, last);\n      vector<int>::const_iterator kt = s.begin();\n      vector<int> r;\n      for (vector<int>::const_iterator jt = all.begin(); jt != all.end(); ++jt) {\n        if (kt != s.end() && *jt == *kt) {\n          ++kt;\n        } else {\n          r.push_back(*jt);\n        }\n      }\n      return r;\n    } else {\n      return factor(it, last);\n    }\n  }\n\n  vector<int> expr(Iterator& it, const Iterator& last) const\n  {\n    vector<int> r = term(it, last);\n    while (it != last && (*it == 'u' || *it == 'i' || *it == 'd' || *it == 's')) {\n      const char op = *it;\n      ++it;\n      const vector<int> l = term(it, last);\n      vector<int> o;\n      switch (op) {\n        case 'u':\n          set_union(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'i':\n          set_intersection(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'd':\n          set_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 's':\n          set_symmetric_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n      }\n      swap(r, o);\n    }\n    return r;\n  }\n};\n\nint main()\n{\n  while (!cin.eof()) {\n    string name;\n    int n;\n    evaluator e;\n    while (cin >> name >> n && name != \"R\") {\n      vector<int>& s = e.sets[name[0]-'A'];\n      for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        e.all.push_back(x);\n        s.push_back(x);\n      }\n      sort(s.begin(), s.end());\n    }\n    sort(e.all.begin(), e.all.end());\n    e.all.erase(unique(e.all.begin(), e.all.end()), e.all.end());\n\n    string s;\n    cin >> s;\n    Iterator it = s.begin(), last = s.end();\n    const vector<int> r = e.expr(it, last);\n    copy(r.begin(), r.end(), ostream_iterator<int>(cout, \" \"));\n    cout << endl;\n\n    cin.ignore();\n    cin.peek();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n\n#define rep(i,n)   for(int i=0;i<n;++i)\n\nusing namespace std;\ntypedef set<int> iset;\n\nstring src;\nint p;\n\niset set_u;\nmap<char, iset> sets;\n\niset parse_expr(); // proto\n\nbool end() { return p >= (int)src.length(); }\nchar peek() { return src[p]; }\nvoid succ() { if (!end()) ++p; }\n\niset set_union(const iset &sa, const iset &sb)\n{\n\tiset us = sa;\n\tfor (iset::const_iterator it = sb.begin(); it != sb.end(); ++it)\n\t{\n\t\tus.insert(*it);\n\t}\n\treturn us;\n}\n\niset set_intersect(const iset &sa, const iset &sb)\n{\n\tiset is;\n\tfor (iset::const_iterator it = sb.begin(); it != sb.end(); ++it)\n\t{\n\t\tif (sa.find(*it) != sa.end()) is.insert(*it);\n\t}\n\treturn is;\n}\n\niset set_diff(const iset &sa, const iset &sb)\n{\n\tiset ds = sa;\n\tfor (iset::const_iterator it = sb.begin(); it != sb.end(); ++it)\n\t{\n\t\tds.erase(*it);\n\t}\n\treturn ds;\n}\n\niset set_syndiff(const iset &sa, const iset &sb)\n{\n\treturn set_union(set_diff(sa, sb), set_diff(sb, sa));\n}\n\niset set_compl(const iset &s)\n{\n\tiset cs = set_u;\n\tfor (iset::const_iterator it = s.begin(); it != s.end(); ++it)\n\t{\n\t\tcs.erase(*it);\n\t}\n\treturn cs;\n}\n\niset parse_primary()\n{\n\tiset s;\n\n\tchar c = peek();\n\tswitch (c)\n\t{\n\tcase 'c':\n\t\tsucc();\n\t\ts = set_compl(parse_primary());\n\t\tbreak;\n\tcase '(':\n\t\tsucc();\n\t\ts = parse_expr();\n\t\tif (peek() == ')') succ();\n\t\tbreak;\n\tdefault:\n\t\tsucc();\n\t\ts = sets[c];\n\t\tbreak;\n\t}\n\treturn s;\n}\n\nbool is_op()\n{\n\tchar c = peek();\n\treturn c=='u'||c=='i'||c=='d'||c=='s';\n}\n\niset parse_expr()\n{\n\tiset a = parse_primary();\n\n\twhile (!end() && is_op())\n\t{\n\t\tchar op = peek();\n\t\tsucc();\n\n\t\tiset b = parse_primary();\n\t\tswitch (op)\n\t\t{\n\t\tcase 'u':\n\t\t\ta = set_union(a, b);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\ta = set_intersect(a, b);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\ta = set_diff(a, b);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\ta = set_syndiff(a, b);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\niset parse()\n{\n\tp = 0;\n\treturn parse_expr();\n}\n\nint main()\n{\n\twhile(!cin.eof())\n\t{\n\t\tchar name;\n\t\tint N, e;\n\n\t\tsets.clear();\n\t\tset_u.clear();\n\t\twhile(cin >> name >> N, name != 'R')\n\t\t{\n\t\t\trep(i,N)\n\t\t\t{\n\t\t\t\tcin >> e;\n\t\t\t\tsets[name].insert(e);\n\t\t\t\tset_u.insert(e);\n\t\t\t}\n\t\t}\n\n\t\tcin >> src;\n\t\tiset s = parse();\n\t\tif (s.size() == 0)\n\t\t{\n\t\t\tcout << \"NULL\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (iset::const_iterator it = s.begin(); it != s.end(); ++it)\n\t\t{\n\t\t\tif (it != s.begin()) cout << \" \";\n\t\t\tcout << *it;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>13) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string s;\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele) :\n        s(s), ele(ele) {\n        it = s.begin();\n    }\n\n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            if(*it == 'd'){\n                ++it;\n                b = term();\n                a = difference(a, b);\n            }else if(*it == 'i'){\n                ++it;\n                b = term();\n                a = intersection(a, b);\n            }else if(*it == 's'){\n                ++it;\n                b = term();\n                a = sym_difference(a, b);\n            }else if(*it == 'u'){\n                ++it;\n                b = term();\n                a = union_(a, b);\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    bool eof_ = 0;\n    while(1)\n    {\n        map<char, set<int>> ele;\n        while(1)\n        {\n            if(cin >> ch >> N){\n                if(ch == 'R') break;\n                set<int> st;\n                for(int i = 0 ; i < N ; i++){\n                    cin >> x;\n                    st.insert(x);\n                }\n                    \n                ele[ch] = st;\n                for(auto x : st){\n                    ele['U'].insert(x);\n                }\n            }else{\n                eof_ = 1;\n                break;\n            }\n        }\n        if(eof_) break;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res)\n            {\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef pair<int, vector<int> > Result;\nvector<int> universal;\nvector<int> sets[100];\n\nvoid print_vector(const vector<int>& v)\n{\n  for (int i = 0; i < (int)v.size(); ++i) {\n    if (i != 0) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nResult parse_atom(const string& str, int k);\n\nResult parse_expr(const string& str, int k)\n{\n  Result lhs = parse_atom(str, k);\n  while (islower(str[lhs.first])) {\n    Result rhs = parse_atom(str, lhs.first + 1);\n    vector<int> result;\n    switch (str[lhs.first]) {\n    case 'u':\n      set_union(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'i':\n      set_intersection(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 'd':\n      set_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    case 's':\n      set_symmetric_difference(ALL(lhs.second), ALL(rhs.second), back_inserter(result));\n      break;\n    }\n    lhs = make_pair(rhs.first, result);\n  }\n  return lhs;\n}\n\nResult parse_atom(const string& str, int k)\n{\n  if (str[k] == 'c') {\n    Result ret = parse_atom(str, k+1);\n    vector<int> result;\n    set_difference(ALL(universal), ALL(ret.second), back_inserter(result));\n    return make_pair(ret.first, result);\n  } else if (str[k] == '(') {\n    Result ret = parse_expr(str, k+1);\n    return make_pair(ret.first+1, ret.second);\n  } else {\n    return make_pair(k+1, sets[str[k]-'A']);\n  }\n}\n\nint main()\n{\n  for (;;) {\n    char name;\n    int n;\n    universal.clear();\n    for (int i = 0; i < 100; ++i) {\n      sets[i].clear();\n    }\n    for (;;) {\n      if (!(cin >> name >> n)) { return 0; }\n      if (name == 'R') { break; }\n      for (int i = 0; i < n; ++i) {\n        int v; cin >> v;\n        sets[name-'A'].push_back(v);\n        universal.push_back(v);\n      }\n      sort(ALL(sets[name-'A']));\n      unique(ALL(sets[name-'A']));\n    }\n    sort(ALL(universal));\n    unique(ALL(universal));\n    string str; cin >> str;\n    vector<int> ret = parse_expr(str + \".\", 0).second;\n    if (ret.empty()) {\n      cout << \"NULL\" << endl;\n    } else {\n      print_vector(ret);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n \nusing namespace std;\n\nstring::iterator it;\nmap<char, set<int>> elements;\n\nclass Parse\n{\n  public:     \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n     \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n \n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n     \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n \n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n \n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n \n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n \nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        elements.clear();\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n \n        elements['U'] = U;\n         \n        string str;\n        cin >> str;\n         \n        Parse parse;\n        it = str.begin();\n        set<int> res = parse.expr();\n         \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[5],U;\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0;\n  int l = s.size();\n  set<int> a,b,res;\n\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p && ('a'<=s[i] && s[i]<='z' && s[i]!='c')){\n      a = parse(s.substr(0,i));\n      b = parse(s.substr(i+1,l-i-1));\n      if(s[i] == 'u'){\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = U.begin();ite!=U.end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  }\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n\n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<5;i++)alp[i].clear();\n    while(c != 'R'){\n      int tmp;\n\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m[c]].insert(tmp);\n\tU.insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    p++;\n    if(S[p]-'A'>5)exit(0);\n    s=C(uni,st[S[p]-'A']),p++;\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint idx;\nstring str;\nset<int> u;\n\nset<int> calc_union(const set<int>& a, const set<int>& b) {\n\tset<int> res(a);\n\tset<int>::const_iterator it, en = b.end();\n\tfor(it = b.begin(); it != en; ++it)\n\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_intersection(const set<int>& a, const set<int>& b) {\n\tset<int> res;\n\tset<int>::const_iterator it, en = a.end(), en2 = b.end();\n\tfor(it = a.begin(); it != en; ++it)\n\t\tif(b.find(*it) != en2)\n\t\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_difference(const set<int>& a, const set<int>& b) {\n\tset<int> res;\n\tset<int>::const_iterator it, en = a.end(), en2 = b.end();\n\tfor(it = a.begin(); it != en; ++it)\n\t\tif(b.find(*it) == en2)\n\t\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_symmetric_difference(const set<int>& a, const set<int>& b) {\n\treturn calc_union(calc_difference(a, b), calc_difference(b, a));\n}\n\nset<int> complement(const set<int>& a) {\n\treturn calc_difference(u, a);\n}\n\nset<int> s[128];\nset<int> (*func[128])(const set<int>&, const set<int>&);\n\nset<int> expr();\n\nset<int> fact() {\n\tif(str[idx] == '(') {\n\t\t++idx;\n\t\tconst set<int> res = expr();\n\t\t++idx;\n\t\treturn res;\n\t}\n\telse\n\t\treturn s[str[idx++]];\t\n}\n\nset<int> term() {\n\tif(str[idx] == 'c') {\n\t\t++idx;\n\t\treturn complement(fact());\n\t}\n\telse\n\t\treturn fact();\n}\n\nset<int> expr() {\n\tset<int> res = term();\n\twhile(str[idx] == 'u' || str[idx] == 'i' || str[idx] == 'd' || str[idx] == 's') {\n\t\tconst char tmp = str[idx++];\n\t\tres = func[tmp](res, term());\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfunc['u'] = calc_union;\n\tfunc['i'] = calc_intersection;\n\tfunc['d'] = calc_difference;\n\tfunc['s'] = calc_symmetric_difference;\n\n\twhile(true) {\n\t\tu.clear();\n\t\tfor(int i = 'A'; i <= 'E'; ++i)\n\t\t\ts[i].clear();\n\n\t\tchar c;\n\t\tint num;\n\t\twhile(true) {\n\t\t\tif(!(cin >> c >> num))\n\t\t\t\treturn EXIT_SUCCESS;\n\n\t\t\tif(c == 'R')\n\t\t\t\tbreak;\n\n\t\t\twhile(num--) {\n\t\t\t\tint element;\n\t\t\t\tcin >> element;\n\t\t\t\ts[c].insert(element);\n\t\t\t\tu.insert(element);\n\t\t\t}\n\t\t}\n\n\t\tidx = 0;\n\t\tcin >> str;\n\n\t\tconst set<int> ans = expr();\n\t\tset<int>::const_iterator it = ans.begin(), en = ans.end();\n\t\tif(ans.size()) {\n\t\t\twhile(true) {\n\t\t\t\tcout << (*it);\n\t\t\t\tif(++it == en)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nusing S = set<int>;\nS U;\nmap<char, S> m;\n\nstring s;\nint N;\nint c;\n\nS expr();\nS factor();\nS num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \" + s << endl;\n\tfor(int i = 0; i < text.size() + 1 + N; i++){\n\t\tif(i == text.size() + 1 + c) cout << \"*\";\n\t\telse cout << \" \";\n\t}\n\tcout << endl;\n}\n\nS Union(S s1, S s2){\n\tfor(auto v : s2){\n\t\ts1.insert(v);\n\t}\n\treturn s1;\n}\n\nS Intersection(S s1, S s2){\n\tS ret;\n\tfor(auto v : s2){\n\t\tif(s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Diff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS SymDiff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\tfor(auto v : s2){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Comp(S s1){\n\tS ret;\n\tfor(auto v : U){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS expr(){\n\tdebug(\"expr\");\n\tS x = factor();\n\twhile(c < N){\n\t\tif(s[c] == 'u'){\n\t\t\tc++;\n\t\t\tx = Union(x, factor());\n\t\t}\n\t\telse if(s[c] == 'i'){\n\t\t\tc++;\n\t\t\tx = Intersection(x, factor());\n\t\t}\n\t\telse if(s[c] == 'd'){\n\t\t\tc++;\n\t\t\tx = Diff(x, factor());\n\t\t}\n\t\telse if(s[c] == 's'){\n\t\t\tc++;\n\t\t\tx = SymDiff(x, factor());\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nS factor(){\n\tdebug(\"factor\");\n\tbool rev = false;\n\tif(s[c] == 'c'){\n\t\trev = 1;\n\t\tc++;\n\t}\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tS ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\tif(rev) ret = Comp(ret);\n\t\treturn ret;\n\t}\n\tS ret = num();\n\tif(rev) ret = Comp(ret);\n\treturn ret;\n}\n\nS num(){\n\tdebug(\"num\");\n\tS ret = m[s[c]];\n\tc++;\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tm.clear();\n\t\tU.clear();\n\t\tchar name;\n\t\tint n;\n\t\twhile(true){\n\t\t\tif(!(cin >> name >> n)) return 0;\n\t\t\tif(name == 'R') break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tU.insert(a);\n\t\t\t\tm[name].insert(a);\n\t\t\t}\n\t\t}\n\t\t//m['U'] = U;\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tS ans = expr();\n\t\tif(ans.size()){\n\t\t\tvector<int> v(ans.begin(), ans.end());\n\t\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\t\tcout << v[i];\n\t\t\t\tif(i != v.size() - 1) cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NULL\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\ntypedef vector<int> vint;\ntypedef set<int> sint;\n\nmap<char, sint > st;\nstring ope;\nint idx;\n\nsint expr();\nsint get();\n\nsint get() {\n  if(ope[idx] == 'c') {\n    idx++;\n    sint S = get();\n    sint T;\n    for(int e : st['U']) {\n      if(!S.count(e)) T.insert(e);\n    }\n    return T;\n  } else if(isupper(ope[idx])) {\n    char c = ope[idx++];\n    return st[c];\n  } else if(ope[idx] == '(') {\n    idx++;\n    sint S = expr();\n    idx++;\n    return S;\n  } else {\n    assert(false);\n  }\n}\n\nsint expr() {\n  sint S = get();\n  while(1) {\n    if(idx >= ope.size()) return S;\n    if(ope[idx] == ')') return S;\n    else if(ope[idx] == 'u') {\n      //cout<<\"union\"<<endl;\n      idx++;\n      sint T = get();\n      sint U;\n      for(int e : S) U.insert(e);\n      for(int e : T) U.insert(e);\n      S = U;//return U;\n    } else if(ope[idx] == 'i') {\n      //cout<<\"intersect\" << endl;\n      idx++;    \n      sint T = get();\n      sint U;\n      for(int e : S) {\n\tif(T.count(e)) U.insert(e);\n      }\n      S = U;//return U;\n    } else if(ope[idx] == 'd') {\n      //cout << \"differnce\"<<endl;\n      idx++;\n      sint T = get();\n      sint U;\n      for(int e : S) {\n\tif(!T.count(e)) U.insert(e);\n      }\n      S = U;//return U;\n    } else if(ope[idx] == 's') {\n      //cout <<\"symmetric\"<<endl;\n      idx++;    \n      sint T = get();\n      sint U;\n      for(int e : S) {\n\tif(!T.count(e)) U.insert(e);\n      }\n      for(int e : T) {\n\tif(!S.count(e)) U.insert(e);\n      }\n      S = U;//return U;\n    } else {\n      assert(false);\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  char c;\n  int sz;\n  while(cin >> c >> sz) {    \n    st.clear();\n    do {\n      rep(i, sz) {\n\tint e; cin >> e;\n\tst[c].insert(e);\n\tst['U'].insert(e);\n      }\n    } while(cin >> c >> sz, c != 'R');\n    cin >> ope;\n    idx = 0;\n    sint ans = expr();\n    if(ans.empty()) {\n      cout<<\"NULL\"<<endl;\n      continue;\n    }\n    bool flag = false;    \n    for(int e : ans) {\n      if(flag) cout << \" \";\n      flag = true;      \n      cout << e;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\nset<int> U;\nmap<char, set<int> > SET;\n \nset<int> solve(string s) {\n  // cout << s << endl;\n  int nest = 0;\n  set<int> res;\n  for (int i=s.size()-1; i>=0; --i) {\n    if (s[i]=='(')\n      nest++;\n    else if (s[i]==')')\n      nest--;\n    else if (nest == 0) {\n      if (s[i]=='u' || s[i]=='i' || s[i]=='d' || s[i]=='s') {\n        set<int> A = solve(s.substr(0, i));\n        set<int> B = solve(s.substr(i+1));\n\n        if (s[i]=='u') {\n          res = A;\n          res.insert(ALL(B));\n        } else if (s[i]=='i') {\n          FOR(it, A) {\n            if (B.find(*it)!=B.end()) {\n              res.insert(*it);\n            }\n          }\n        } else if (s[i]=='d') {\n          FOR(it, A) {\n            if (B.find(*it)==B.end()) {\n              res.insert(*it);\n            }\n          }\n        } else if (s[i]=='s') {\n          FOR(it, A) {\n            if (B.find(*it)==B.end()) {\n              res.insert(*it);\n            }\n          }\n          FOR(it, B) {\n            if (A.find(*it)==A.end()) {\n              res.insert(*it);\n            }\n          }\n        }\n        return res;\n      }\n    }\n  }\n  \n  if (s[0] == '(') {\n    return solve(s.substr(1, s.size()-2));\n  } else if (s[0] == 'c'){\n    set<int> A = solve(s.substr(1));\n    FOR(it, U) {\n      if (A.find(*it) == A.end())\n        res.insert(*it);\n    }\n    return res;\n  }\n  return SET[s[0]];\n}\n\nint main() {\n  char c;\n  int m;\n  while(cin >> c>> m) {\n    U.clear();\n    SET.clear();\n    while(c!='R') {\n      REP(i, m) {\n        int a;\n        cin >> a;\n        SET[c].insert(a);\n        U.insert(a);\n      }\n      cin >> c >> m;\n    }\n    string s;\n    cin >> s;\n\n    set<int> res = solve(s);\n    int hoge = 0;\n    FOR(it, res) {\n      if (hoge)\n        cout << \" \";\n      else hoge = 1;\n      cout << *it;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nvi S[6];\nstring expr;\n\nvi calc(vi a,vi b,char op)\n{\n\tvi ret(a.size()+b.size());\n\tvi::iterator it;\n\tswitch(op)\n\t{\n\tcase 'u':\n\t\tit=set_union(all(a),all(b),ret.begin()); break;\n\tcase 'i':\n\t\tit=set_intersection(all(a),all(b),ret.begin()); break;\n\tcase 'd':\n\t\tit=set_difference(all(a),all(b),ret.begin()); break;\n\tcase 's':\n\t\tit=set_symmetric_difference(all(a),all(b),ret.begin()); break;\n\t}\n\tret.erase(it,ret.end());\n\treturn ret;\n}\n\nvi eval(int s,int t)\n{\n\tint d=0,p=t-1; char c;\n\tfor(;p>s;p--)\n\t{\n\t\tc=expr[p];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(p==s)\n\t{\n\t\tif(expr[s]=='(')return eval(s+1,t-1);\n\t\tif(expr[s]=='c')return calc(S[5],eval(s+1,t),'d');\n\t\treturn S[expr[s]-'A'];\n\t}\n\treturn calc(eval(s,p),eval(p+1,t),c);\n}\n\nint main()\n{\n\tchar c; int n;\n\twhile(cin>>c>>n)\n\t{\n\t\trep(i,6)S[i].clear();\n\t\tdo\n\t\t{\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tint t; cin>>t;\n\t\t\t\tS[c-'A'].pb(t);\n\t\t\t\tS[5].pb(t);\n\t\t\t}\n\t\t}while(cin>>c>>n,c!='R');\n\t\t\n\t\trep(i,6)\n\t\t\tsort(all(S[i])),S[i].erase(unique(all(S[i])),S[i].end());\n\t\tcin>>expr;\n\t\t\n\t\tvi ans=eval(0,expr.size());\n\t\trp(i,ans)cout<<ans[i]<<(i==ans.size()-1?\"\":\" \");\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st['B'-'A']),p++;\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nmap<char, vector<int> > sets;\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nvector<int> parse(const string& e)\n{\n\tint p = e.size() - 1;\n\tfor (int par = 0; p >= 0; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < 0)\n\t{\n\t\tif (e[0] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(e.substr(1)));\n\t\telse if (e[0] == '(')\n\t\t\treturn parse(e.substr(1, e.size() - 2));\n\t\telse\n\t\t\treturn sets[e[0]];\n\t}\n\n\treturn calculate(e[p], parse(e.substr(0, p)), parse(e.substr(p + 1, e.size() - (p + 1))));\n}\nint main()\n{\n\twhile (!cin.eof())\n\t{\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tcin >> a >> n;\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tstring exp;\n\t\tcin >> exp;\n\t\tvector<int> res = parse(exp);\n\t\tif (res.empty())\n\t\t\tcout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tcout << res[i];\n\t\t\t\tif (i + 1 < res.size())\n\t\t\t\t\tcout << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\ntypedef vector<int> Set;\nSet sets[5];\nSet U;\nstring input;\nint index;\n\nvoid Print(const Set& s) {\n  if (s.empty()) {\n    cout << \"NULL\";\n  } else {\n    for (int i = 0; i < s.size(); ++i) {\n      if (i != 0) cout << \" \";\n      cout << s[i];\n    }\n  }\n  cout << endl;\n}\n\nSet Union(const Set& a, const Set& b) {\n  Set r;\n  set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nSet Intersection(const Set& a, const Set& b) {\n  Set r;\n  set_intersection(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nSet Diff(const Set& a, const Set& b) {\n  Set r;\n  set_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nSet SymDiff(const Set& a, const Set& b) {\n  Set r;\n  set_symmetric_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(r));\n  return r;\n}\n\nstring bin_ops = \"uids\";\nSet Fact();\nSet Exp() {\n  Set val = Fact();\n  while (index < input.size() && bin_ops.find(input[index]) != string::npos) {\n    char op = input[index++];\n    Set b = Fact();\n    switch (op) {\n    case 'u': val = Union(val, b); break;\n    case 'i': val = Intersection(val, b); break;\n    case 'd': val = Diff(val, b); break;\n    case 's': val = SymDiff(val, b); break;\n    }\n  }\n  return val;\n}\n\nSet Fact() {\n  char op = input[index++];\n  Set r;\n  if (op == 'c') {\n    r = Diff(U, Fact());\n  } else if (op == '(') {\n    r = Exp();\n    ++index;\n  } else {\n    r = sets[op - 'A'];\n  }\n  return r;\n}\n\nint main() {\n  char name;\n  int num;\n  while (cin >> name >> num) {\n    for (Set& s : sets) s.clear(); U.clear();\n    do {\n      for (int i = 0; i < num; ++i) {\n\tint v;\n\tcin >> v;\n\tsets[name - 'A'].push_back(v);\n      }\n    } while (cin >> name >> num && name != 'R');\n    for (Set& s : sets) {\n      sort(s.begin(), s.end());\n      U = Union(U, s);\n    }\n    cin >> input;\n    index = 0;\n    Set res = Exp();\n    Print(res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct evaluator\n{\n  vector<int> all;\n  vector<int> sets[5];\n\n  vector<int> factor(Iterator& it, const Iterator& last) const\n  {\n    if (*it == '(') {\n      ++it;\n      const vector<int> r = expr(it, last);\n      ++it;\n      return r;\n    } else {\n      const int i = *it-'A';\n      ++it;\n      return sets[i];\n    }\n  }\n\n  vector<int> term(Iterator& it, const Iterator& last) const\n  {\n    if (*it == 'c') {\n      ++it;\n      const vector<int> s = factor(it, last);\n      vector<int> r;\n      set_difference(all.begin(), all.end(), s.begin(), s.end(), back_inserter(r));\n      return r;\n    } else {\n      return factor(it, last);\n    }\n  }\n\n  vector<int> expr(Iterator& it, const Iterator& last) const\n  {\n    vector<int> r = term(it, last);\n    while (it != last && (*it == 'u' || *it == 'i' || *it == 'd' || *it == 's')) {\n      const char op = *it;\n      ++it;\n      const vector<int> l = term(it, last);\n      vector<int> o;\n      switch (op) {\n        case 'u':\n          set_union(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'i':\n          set_intersection(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'd':\n          set_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 's':\n          set_symmetric_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n      }\n      swap(r, o);\n    }\n    return r;\n  }\n};\n\nint main()\n{\n  while (!cin.eof()) {\n    string name;\n    int n;\n    evaluator e;\n    while (cin >> name >> n && name != \"R\") {\n      vector<int>& s = e.sets[name[0]-'A'];\n      for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        e.all.push_back(x);\n        s.push_back(x);\n      }\n      sort(s.begin(), s.end());\n    }\n    sort(e.all.begin(), e.all.end());\n    e.all.erase(unique(e.all.begin(), e.all.end()), e.all.end());\n\n    string s;\n    cin >> s;\n    Iterator it = s.begin(), last = s.end();\n    const vector<int> r = e.expr(it, last);\n    if (r.empty()) {\n      cout << \"NULL\" << endl;\n    } else {\n      for (vector<int>::const_iterator it = r.begin(); it != r.end(); ++it) {\n        if (it != r.begin()) {\n          cout << ' ';\n        }\n        cout << *it;\n      }\n      cout << endl;\n    }\n\n    cin.ignore();\n    cin.peek();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>100000) break;\n\t\t\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> elements;\n\n    Parse(string s, map<char, set<int>> elements){\n        it = s.begin();\n        this->elements = elements;\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n    \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n\n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> elements = {};\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n\n        elements['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, elements);\n        set<int> res = parse.expr();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint idx;\nstring s;\nvector<int> u;\nvector<int> v[128];\n\nvector<int> op(char ch,vector<int> a,vector<int> b=vector<int>()){\n\tvector<int> res(502);\n\tvector<int>::iterator it;\n\n\tif(ch == 'u') it = set_union(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'i') it = set_intersection(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'd') it = set_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 's') it = set_symmetric_difference(a.begin(),a.end(),b.begin(),b.end(),res.begin());\n\tif(ch == 'c') it = set_difference(u.begin(),u.end(),a.begin(),a.end(),res.begin());\n\n\tres.resize(it-res.begin());\n\treturn res;\n}\n\nvector<int> solve(void){\n\tif(s[idx] == ')'){\n\t\tidx++;\n\t\treturn vector<int>();\n\t}\n\n\tbool flg = false;\n\tif(s[idx] == 'c'){\n\t\tflg = true;\n\t\tidx++;\n\t}\n\n\tvector<int> res;\n\tif(s[idx] == '('){\n\t\tidx++;\n\t\tres = solve();\n\t}\n\telse{\n\t\tres = v[s[idx++]];\n\t}\n\n\tif(flg) res = op('c',res);\n\n\twhile(idx < s.length() && s[idx] != ')'){\n\t\tchar ch = s[idx++];\n\n\t\tflg = false;\n\t\tif(s[idx] == 'c'){\n\t\t\tflg = true;\n\t\t\tidx++;\n\t\t}\n\n\t\tvector<int> tmp;\n\t\tif(s[idx] == '('){\n\t\t\tidx++;\n\t\t\ttmp = solve();\n\t\t}\n\t\telse{\n\t\t\ttmp = v[s[idx++]];\n\t\t}\n\n\t\tif(flg) tmp = op('c',tmp);\n\t\tres = op(ch,res,tmp);\n\t}\n\tidx++;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tu.clear();\n\t\tfor(int i=0;i<5;i++) v['A'+i].clear();\n\n\t\twhile(1){\n\t\t\tchar name;\n\t\t\tint n;\n\t\t\tif(!(cin>>name>>n)) return 0;\n\t\t\tif(name == 'R') break;\n\n\t\t\tv[name] = vector<int>(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcin>>v[name][i];\n\t\t\t}\n\t\t\tsort(v[name].begin(),v[name].end());\n\t\t\tu = op('u',v[name],u);\n\t\t}\n\n\t\tcin>>s;\n\t\tidx = 0;\n\n\t\tvector<int> ans = solve();\n\t\tif(ans.empty()){\n\t\t\tcout<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tcout<<ans[i]<<\" \";\n\t\t}\n\t\tcout<<ans[ans.size()-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_symmetric_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return m[*begin++];\n    }\n}\n\nvector<int> term(State &begin){\n    if (*begin == 'c') {\n        begin++;\n        return C(factor(begin));\n    } else {\n        return factor(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = term(begin);\n\n    for (;;) {\n        if (*begin == 'u') {\n            begin++;\n            ret = U(ret, term(begin));\n        } else if(*begin == 'i') {\n            begin++;\n            ret = I(ret, term(begin));\n        } else if(*begin == 'd') {\n            begin++;\n            ret = D(ret, term(begin));\n        } else if(*begin == 's') {\n            begin++;\n            ret = S(ret, term(begin));\n        } else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << \"NULL\" << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> A,B,C,D,E,U;//mapを使った方が楽。\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        set_difference(U.begin(), U.end(), v.begin(), v.end(), std::inserter(ret, ret.end()));\n    }\n    else {\n        ret = _set(begin);\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else if (se == 'A') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    A.push_back(input);\n                    u.insert(input);\n                }\n                sort(A.begin(), A.end());\n            } else if (se == 'B') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    B.push_back(input);\n                    u.insert(input);\n                }\n                sort(B.begin(), B.end());\n            } else if (se == 'C') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    C.push_back(input);\n                    u.insert(input);\n                }\n                sort(C.begin(), C.end());\n            } else if (se == 'D') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    D.push_back(input);\n                    u.insert(input);\n                }\n                sort(D.begin(), D.end());\n            } else if (se == 'E') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    E.push_back(input);\n                    u.insert(input);\n                }\n                sort(E.begin(), E.end());\n            }\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (ll i = (ll)(a); i < (ll)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#define ALL(x) x.begin(), x.end()\n#ifdef DEBUG\n#define line() cerr << \"[\" << __LINE__ << \"] \";\n#define dump(i) cerr << #i \": \" << i << \" \";\n#define dumpl(i) cerr << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\ntypedef string::const_iterator State;\n\nmap<char, set<int>> mp;\n\nset<int> ev_expr(State &begin);\nset<int> ev_term(State &begin);\nset<int> ev_setorparen(State &begin);\nset<int> ev_set(State &begin);\nchar ev_op(State &begin);\n\nclass ParseError\n{\n};\n\nvoid consume(State &begin, char expected)\n{\n\n    if (*begin == expected)\n    {\n        begin++;\n    }\n    else\n    {\n        cerr << \"Expected:\" << expected << \" but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin)\n        {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\n/*\nAiB\n<expr>:=<term><op><expr>|<term>\n<term>:=c<setorp>|<setop>\n<setorparen>::=<set>|(<expr>)\n<op>:=u|i|d|c\n<set>:=A|B|C|D\n*/\nset<int> ev_expr(State &begin)\n{\n    set<int> ret;\n\n    auto a = ev_term(begin);\n    ret = a;\n    while (*begin == 'u' || *begin == 'i' || *begin == 'd' || *begin == 's')\n    {\n\n        ret.clear();\n        char op = ev_op(begin);\n        auto b = ev_term(begin);\n        //cerr << \"op:\" << *begin << endl;\n        if (op == 'i')\n        {\n            set_intersection(ALL(a), ALL(b), inserter(ret, ret.end()));\n        }\n        else if (op == 'u')\n        {\n            set_union(ALL(a), ALL(b), inserter(ret, ret.end()));\n        }\n        else if (op == 'd')\n        {\n            set_difference(ALL(a), ALL(b), inserter(ret, ret.end()));\n        }\n        else if (op == 's')\n        {\n\n            set_symmetric_difference(ALL(a), ALL(b), inserter(ret, ret.end()));\n        }\n        a = ret;\n    }\n    return ret;\n}\n\nset<int> ev_term(State &begin)\n{\n    set<int> ret;\n    if (*begin == 'c')\n    {\n        auto u = mp['U'];\n        begin++;\n        auto target = ev_term(begin);\n        set_difference(ALL(u), ALL(target), inserter(ret, ret.end()));\n        return ret;\n    }\n    else\n    {\n        ret = ev_setorparen(begin);\n        return ret;\n    }\n}\n\nchar ev_op(State &begin)\n{\n    char ret = *begin;\n    begin++;\n    return ret;\n}\n\nset<int> ev_setorparen(State &begin)\n{\n    if (*begin == '(')\n    {\n        consume(begin, '(');\n        auto ret = ev_expr(begin);\n        consume(begin, ')');\n        return ret;\n    }\n    else\n    {\n        auto ret = ev_set(begin);\n        return ret;\n    }\n}\n\nset<int> ev_set(State &begin)\n{\n\n    auto ret = mp[*begin];\n    begin++;\n    return ret;\n}\n\nint main()\n{\n    while (true)\n    {\n        mp.clear();\n        char name;\n        int size;\n        bool f = false;\n        while (cin >> name >> size)\n        {\n            f = true;\n            if (name == 'R')\n                break;\n            rep(j, size)\n            {\n                int t;\n                cin >> t;\n                //    cerr << name << \":\" << t << endl;\n                mp[name].insert(t);\n                mp['U'].insert(t);\n            }\n        }\n        if (f == false)\n            break;\n        string s;\n        cin >> s;\n        // cerr << \"eval:\" << s << endl;\n        State begin = s.begin();\n        auto ret = ev_expr(begin);\n        if (ret.size() == 0)\n        {\n            cout << \"NULL\" << endl;\n        }\n        else\n        {\n            int count = 0;\n            for (auto i : ret)\n            {\n                cout << i << (count == ret.size() - 1 ? \"\" : \" \");\n                count++;\n            }\n\n            cout << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[10],U;\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0;\n  int l = s.size();\n  set<int> a,b,res;\n\n  if(!s.size())return res;\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p && ('a'<=s[i] && s[i]<='z' && s[i]!='c')){\n      a = parse(s.substr(0,i));\n      b = parse(s.substr(i+1,l-i-1));\n      if(s[i] == 'u'){\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = U.begin();ite!=U.end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  }\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n\n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<5;i++)alp[i].clear();\n    U.clear();\n    while(c != 'R'){\n      int tmp;\n\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m[c]].insert(tmp);\n\tU.insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nmap<char,set<int> > S;\nset<int> U;\nstring parse;\nint pos;\n\nset<int> expression();\n\nset<int> term(){\n  if( parse[pos] == '(' ){\n    ++pos;\n    set<int> p = expression();\n    ++pos;\n    return p;\n  } else if( parse[pos] == 'c' ) {\n    ++pos;\n    set<int> p = term();\n    set<int> ret = U;\n    for(set<int>::iterator it = p.begin();it!=p.end();it++) ret.erase(*it);\n    return ret;\n  } else {\n    char c = parse[pos++];\n    return S[c];\n  }\n}\n\nset<int> expression(){\n  set<int> a = term();\n\n  while( parse[pos] == 'u' || parse[pos] == 'i' || parse[pos] == 'd' || parse[pos] == 's' || parse[pos] == 'c' ){\n    char opr = parse[pos++];\n    set<int> b = term();\n    if( opr == 'u' ){\n      set<int> u = a;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) u.insert(*it);\n      a = u;\n    } else if( opr == 'i' ) {\n      map<int,int> counter;\n      set<int> tmp;\n      for(set<int>::iterator it = a.begin() ; it != a.end(); it++ ) counter[*it]++;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) counter[*it]++;\n      for(auto& i : counter)if( i.second == 2 ) tmp.insert(i.first);\n      a = tmp;\n    } else if( opr == 'd' ) {\n      set<int> tmp = a;\n      for(auto& i : b)tmp.erase(i);\n      a = tmp;\n    } else if( opr == 's' ) {\n      map<int,int> counter;\n      set<int> tmp;\n      for(set<int>::iterator it = a.begin() ; it != a.end(); it++ ) counter[*it]++;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) counter[*it]++;\n      for(auto& i : counter)if( i.second != 2 ) tmp.insert(i.first);\n      a = tmp;\n    }\n  }\n  return a;\n}\n\nint main(){\n\n  char c;\n  int n,tmp;\n  while(cin >> c >> n){\n    pos = 0;\n    S.clear();\n    U.clear();\n    rep(i,n){\n      cin >> tmp;\n      S[c].insert(tmp);\n    }\n\n    while(true){\n      cin >> c >> n;\n      if( c == 'R' && n == 0 ) break;\n      rep(i,n){\n\tcin >> tmp;\n\tS[c].insert(tmp);\n      }\n    }\n\n    for(map<char,set<int> >::iterator it = S.begin(); it != S.end(); it++){\n\tfor(set<int>::iterator it2 = (it->second).begin(); it2 != (it->second).end();it2++){\n\t  U.insert(*it2);\n\t}\n    }\n\n    cin >> parse;\n\n    set<int> answer = expression();\n    int i = 0;\n    for(set<int>::iterator iter = answer.begin() ; iter != answer.end() ; iter++,i++ ){\n      if( i ) cout << ' ';\n      cout << *iter;\n    } cout << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <cctype>\n\nusing namespace std;\n\nvector<int> g_sets[5];\nvector<int> g_all;\n\nstruct Result {\n        vector<int> value;\n        int p;\n};\n\nResult expr(const string &s, int p);\nResult factor(const string &s, int p);\n\nResult expr(const string &s, int p){\n        Result r = factor(s, p);\n        while(islower(s[r.p])){\n                Result q = factor(s, r.p + 1);\n                vector<int> temp;\n                if(s[r.p] == 'u'){\n                        set_union(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }else if(s[r.p] == 'i'){\n                        set_intersection(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }else if(s[r.p] == 'd'){\n                        set_difference(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }else if(s[r.p] == 's'){\n                        set_symmetric_difference(\n                                r.value.begin(), r.value.end(),\n                                q.value.begin(), q.value.end(),\n                                back_inserter(temp));\n                }\n                r.value = temp;\n                r.p = q.p;\n        }\n        return r;\n}\n\nResult factor(const string &s, int p){\n        bool complement = false;\n        while(s[p] == 'c'){\n                complement = !complement;\n                ++p;\n        }\n        Result r;\n        if(isupper(s[p])){\n                r.value = g_sets[s[p] - 'A'];\n                r.p = p + 1;\n        }else{\n                Result q = expr(s, p + 1);\n                r.value = q.value;\n                r.p = q.p + 1;\n        }\n        if(complement){\n                vector<int> temp;\n                set_difference(\n                        g_all.begin(), g_all.end(),\n                        r.value.begin(), r.value.end(),\n                        back_inserter(temp));\n                r.value = temp;\n        }\n        return r;\n}\n\nint main(){\n        while(!cin.eof()){\n                g_all.clear();\n                while(true){\n                        string s;\n                        int n;\n                        if(!(cin >> s >> n)){ return 0; }\n                        if(s == \"R\" && n == 0){ break; }\n                        int index = s[0] - 'A';\n                        g_sets[index].clear();\n                        while(n--){\n                                int x;\n                                cin >> x;\n                                g_sets[index].push_back(x);\n                                g_all.push_back(x);\n                        }\n                        sort(g_sets[index].begin(), g_sets[index].end());\n                }\n                sort(g_all.begin(), g_all.end());\n                g_all.erase(unique(g_all.begin(), g_all.end()), g_all.end());\n                string q;\n                cin >> q;\n                vector<int> result = expr(q, 0).value;\n                if(result.size() == 0){\n                        cout << \"NULL\" << endl;\n                }else{\n                        for(int i = 0; i < result.size(); ++i){\n                                cout << result[i];\n                                if(i + 1 == result.size()){\n                                        cout << endl;\n                                }else{\n                                        cout << \" \";\n                                }\n                        }\n                }\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[1000000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 2)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tif(check[A[i]] == false){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 1)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tif(check[U[i]] == false){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tcheck[V[i][k]] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])U.push_back(i);\n\t}\n}\n\n\nvector<int> recursive(int left,int right){\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t}else{\n\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct evaluator\n{\n  vector<int> all;\n  vector<int> sets[5];\n\n  vector<int> factor(Iterator& it, const Iterator& last) const\n  {\n    if (*it == '(') {\n      ++it;\n      const vector<int> r = expr(it, last);\n      ++it;\n      return r;\n    } else {\n      const int i = *it-'A';\n      ++it;\n      return sets[i];\n    }\n  }\n\n  vector<int> term(Iterator& it, const Iterator& last) const\n  {\n    if (*it == 'c') {\n      ++it;\n      const vector<int> s = factor(it, last);\n      vector<int>::const_iterator kt = s.begin();\n      vector<int> r;\n      for (vector<int>::const_iterator jt = all.begin(); jt != all.end(); ++jt) {\n        if (kt != s.end() && *jt == *kt) {\n          ++kt;\n        } else {\n          r.push_back(*jt);\n        }\n      }\n      return r;\n    } else {\n      return factor(it, last);\n    }\n  }\n\n  vector<int> expr(Iterator& it, const Iterator& last) const\n  {\n    vector<int> r = term(it, last);\n    while (it != last && (*it == 'u' || *it == 'i' || *it == 'd' || *it == 's')) {\n      const char op = *it;\n      ++it;\n      const vector<int> l = term(it, last);\n      vector<int> o;\n      switch (op) {\n        case 'u':\n          set_union(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'i':\n          set_intersection(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'd':\n          set_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 's':\n          set_symmetric_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n      }\n      swap(r, o);\n    }\n    return r;\n  }\n};\n\nint main()\n{\n  while (!cin.eof()) {\n    string name;\n    int n;\n    evaluator e;\n    while (cin >> name >> n && name != \"R\") {\n      vector<int>& s = e.sets[name[0]-'A'];\n      for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        e.all.push_back(x);\n        s.push_back(x);\n      }\n      sort(s.begin(), s.end());\n    }\n    sort(e.all.begin(), e.all.end());\n    e.all.erase(unique(e.all.begin(), e.all.end()), e.all.end());\n\n    string s;\n    cin >> s;\n    Iterator it = s.begin(), last = s.end();\n    const vector<int> r = e.expr(it, last);\n    if (r.empty()) {\n      cout << \"NULL\" << endl;\n    } else {\n      copy(r.begin(), r.end(), ostream_iterator<int>(cout, \" \"));\n      cout << endl;\n    }\n\n    cin.ignore();\n    cin.peek();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n \nconst int MAXN = 501;\n \nchar A[5][MAXN];\nint pos;\nstring line;\n \nvector<char> exp();\nvector<char> fact();\n \nvector<char> exp() {\n  vector<char> res = fact();\n  while(1) {\n    if(line[pos] == 'u') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] || x[i]);\n      }\n    } else if(line[pos] == 'i') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && x[i]);\n      }\n    } else if(line[pos] == 'd') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && !x[i]);\n      }\n    } else if(line[pos] == 's') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = ((res[i] && !x[i]) || (x[i] && !res[i]));\n      }\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n \nvector<char> fact() {\n  vector<char> res;\n  if(line[pos] == 'c') {\n    ++pos;\n    res = fact();\n    for(int i = 0; i < res.size(); ++i) {\n      res[i] = 1-res[i];\n    }\n  } else if(isupper(line[pos])) {\n    char c = line[pos];\n    ++pos;\n    res = vector<char>(A[c-'A'], A[c-'A']+MAXN);\n  } else if(line[pos] == '(') {\n    ++pos;\n    res = exp();\n    ++pos;\n  }\n  return res;\n}\n \nmap<int,int> id, rid;\nint getId(int n) {\n  if(!id.count(n)) {\n    id[n] = id.size()-1;\n    rid[id[n]] = n;\n  }\n  return id[n];\n}\n \nint main() {\n  while(1) {\n    bool run = true;\n    fill(A[0], A[5], false);\n    id.clear();\n    rid.clear();\n    while(1) {\n      char c;\n      int n;\n      if(!(cin >> c >> n)) {\n\trun = false;\n\tbreak;\n      }\n      if(c == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i) {\n\tint a;\n\tcin >> a;\n\ta = getId(a);\n\tA[c-'A'][a] = true;\n      }\n    }\n    if(!run) break;\n    string s;\n    cin >> s;\n    line = s;\n    pos = 0;\n    vector<char> res = exp();\n    vector<int> ans;\n    for(int i = 0, cnt = 0; i < res.size(); ++i) {\n      if(rid.count(i) && res[i]) {\n\tans.push_back(rid[i]);\n      }\n    }\n    sort(ans.begin(), ans.end());\n    if(ans.size() == 0) {\n      cout << \"NULL\" << endl;\n    } else {\n      for(int i = 0; i < ans.size(); ++i) {\n\tif(i) cout << \" \";\n\tcout << ans[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    //if(S[t]=='u')s=U(s,g);\n    //if(S[t]=='i')s=I(s,g);\n    //if(S[t]=='d')s=D(s,g);\n    //if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    sort(result.begin(), result.end());\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        consume(begin,'c');\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n        sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        assert(0);\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            f = true;\n            if(c == 'R' && n == 0) break;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n        if(not f) break;\n        for(auto &it:m) sort(all(it.second));\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        if(ans.empty()) cout << \"NULL\" << endl;\n        else rep(i,ans.size()) cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> V;\nV A[10],U;\nstring S;\n\nV Union(V a,V b){\n  for(int i=0;i<(int)b.size();i++) a.push_back(b[i]);\n  sort(a.begin(),a.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  return a;\n}\n\nV Inter(V a,V b){\n  V res;\n  int n =a.size(),m=b.size();\n  for(int i=0;i<n;i++){\n    int flg = 0;\n    for(int j=0;j<m;j++) flg |= a[i] == b[j];\n    if(flg)res.push_back(a[i]);\n  }\n\n  sort(res.begin(),res.end());\n  return res;\n}\n\nV Diff(V a,V b){\n  V res;\n  int n = a.size();\n  int m = b.size();\n    for(int i=0;i<n;i++){\n    int flg =1;\n    for(int j=0;j<m;j++)flg &=a[i]!=b[j];\n    if(flg)res.push_back(a[i]);\n  }\n  \n  sort(res.begin(),res.end());\n  return res;\n}\n\nV Sdiff(V a,V b){return Union(Diff(a,b),Diff(b,a));}\n\nV Comp(V a){\n  V res;\n  int n = U.size(),m = a.size();\n  for(int i=0;i<n;i++){\n    int flg = 1;\n    for(int j=0;j<m;j++)flg &= U[i]!=a[j];\n    if(flg) res.push_back(U[i]);\n  }\n  sort(res.begin(),res.end());\n  return res;\n}\n\nint p;\nV bnf();\nV getV(){\n  char ch = S[p];\n  V res;\n  if(ch == '(')p++,res = bnf(),p++;\n  else if(isupper(ch))p++,res = A[ch-'A'];\n  else if(ch=='c')p++,res = Comp(getV());\n  else assert(isupper(ch));\n  return res;\n}\n\nV bnf(){\n  V res = getV();\n  while(1){\n    char ch = S[p];\n    if(ch=='(')p++,res = bnf(),p++;\n    else if(ch=='c')p++,res = Comp(getV());\n    else if(ch=='u')p++,res = Union(res,getV());\n    else if(ch=='i')p++,res = Inter(res,getV());\n    else if(ch=='d')p++,res = Diff(res,getV());\n    else if(ch=='s')p++,res = Sdiff(res,getV());\n    else if(p<S.size()&&ch!=')')assert(ch==')');\n    else break;\n  }\n  return res;\n}\n\nint main(){\n\n  while(1){\n    U.clear();\n    while(1){\n      char ch;\n      int n;\n      if(!(cin>>ch>>n))exit(0);\n      if(ch == 'R' && n == 0) break;\n      int idx = ch-'A';\n      A[idx].resize(n);\n      for(int i=0;i<n;i++)cin>>A[idx][i],U.push_back(A[idx][i]);\n      sort(A[idx].begin(),A[idx].end());\n      A[idx].erase(unique(A[idx].begin(),A[idx].end()),A[idx].end());\n    }\n\n    sort(U.begin(),U.end());\n    U.erase(unique(U.begin(),U.end()),U.end());\n    cin >> S;\n    p = 0;\n    V ans = bnf();\n    \n    for(int i=0;i<ans.size();i++){\n      if(i)cout<<\" \";\n      cout<<ans[i];\n    }\n    if(ans.size()==0)cout<<\"NULL\";\n    cout<<endl;\n  }\n \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> U;//mapを使った方が楽。\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = dif(U, v);\n    }\n    else {\n        ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    u.insert(input);\n                }\n            }\n        }\n\n        for(pair<char,vector<int>> v : sets){\n            sort(v.second.begin(), v.second.end());\n            cout << v.first << \" : \";\n            for(int num : v.second){\n                cout << num << \" \";\n            }\n            cout << endl;\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstring str;\nmap<char, vector<int> > mpp;\nint p;\n\nbool check()\n{\n  bool f = true;\n  if(str[p] == ')') return false;\n  if(p < str.size()) return f;\n  if(str[p] == 'u') return f;\n  if(str[p] == 'i') return f;\n  if(str[p] == 'd') return f;\n  if(str[p] == 's') return f;\n\n  return false;\n}\n\nvoid vprint(vector<int> vec)\n{\n  for(int i = 0; i < vec.size(); i++) cout << \" \" << vec[i];\n  cout << endl;\n\n  return ;\n}\n\nvector<int> elm();\nvector<int> func()\n{\n  vector<int> vec, vec3, vec2 = elm();\n\n  while(check()){\n    // cout << \"func[\" << p << \"]: \" << str[p] << endl;\n    char ch = str[p++];\n    vec3 = elm();\n    vec.clear();\n    vector<int> v(vec2.size()+vec3.size());\n    vector<int>::iterator lt;\n\n    if(ch == 'u'){\n      lt = set_union(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    } else if(ch == 'i'){\n      lt = set_intersection(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    } else if(ch == 'd'){\n      lt = set_difference(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    } else {\n      lt = set_symmetric_difference(vec2.begin(), vec2.end(), vec3.begin(), vec3.end(), v.begin());\n    }\n    for(vector<int>::iterator st = v.begin(); st != lt; st++) vec.push_back(*st);\n    vec2 = vec;\n\n    // vprint(vec);\n  }\n\n  return vec;\n}\n\nvector<int> elm()\n{\n  vector<int> vec;\n  \n  if(str[p] == '('){\n    // cout << \"elm[\" << p << \"]: (\" << str[p+1] << \")\" << endl;\n    p++;\n    vec = func();\n    if(str[p] == ')') p++;\n  } else if(str[p] == 'c'){\n    p++;\n    vector<int> uvec = mpp['U'], vec2;\n    // cout << \"elm[\" << p << \"]: c\" << str[p] << endl;\n    if(str[p] == '('){\n      p++;\n      vec2 = func();\n      if(str[p] == ')') p++;\n    } else {\n      vec2 = mpp[str[p++]];\n    }\n    // vprint(vec2);\n    // vprint(uvec);\n    vector<int> v(uvec.size());\n    vector<int>::iterator it = set_difference(uvec.begin(), uvec.end(), vec2.begin(), vec2.end(), v.begin());\n    for(vector<int>::iterator st = v.begin(); st != it; st++) vec.push_back(*st);\n  } else {\n    // cout << \"elm[\" << p << \"]: \" << str[p] << endl;\n    vec = mpp[str[p++]];\n  }\n  // vprint(vec);\n\n  return vec;\n}\n\nint main()\n{\n  char s;\n  int t, u;\n\n  while(!cin.eof()){\n    set<int> stt;\n    while(cin>>s>>t){\n      vector<int> vec;\n      if(s == 'R' && t == 0) break;\n\n      while(t--){\n\tcin >> u;\n\tstt.insert(u);\n\tvec.push_back(u);\n      }\n      sort(vec.begin(), vec.end());\n      mpp[s] = vec;\n    }    \n    vector<int> res;\n    for(set<int>::iterator it = stt.begin(); it != stt.end(); it++)\n      res.push_back(*it);\n    mpp['U'] = res;\n\n    cin >> str;\n    p = 0;\n    // cout << str << endl;\n    res = func();\n    if(res.size() > 0){\n      cout << res[0];\n      for(int i = 1; i < res.size(); i++) cout << \" \" << res[i];\n    } else {\n      cout << \"NULL\";\n    }\n    cout << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\ntypedef vector<int> vec;\n\nvec And(vec &a,vec &b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  int a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nset<int> s[10],a;\nstring t;\nset<int> expr(int &p);\nset<int> term(int &p);\nset<int> factor(int &p);\nset<int> unio(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x) res.insert(i);\n  for(int i:y) res.insert(i);\n  return res;\n}\nset<int> inte(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x)\n    if(y.count(i)) res.insert(i);\n  return res;\n}\nset<int> diff(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x)\n    if(!y.count(i)) res.insert(i);\n  return res;\n}\nset<int> symm(set<int> x,set<int> y){\n  set<int> res;\n  for(int i:x)\n    if(!y.count(i)) res.insert(i);\n  for(int i:y)\n    if(!x.count(i)) res.insert(i);\n  return res;\n}\nset<int> comp(set<int> x){\n  set<int> res;\n  for(int i:a)\n    if(!x.count(i)) res.insert(i);\n  return res;\n}\nset<int> expr(int &p){\n  set<int> res=term(p);\n  while(p<(int)t.size()){\n    if(t[p]=='u'){\n      p++;\n      res=unio(res,term(p));\n      continue;\n    }\n    if(t[p]=='i'){\n      p++;\n      res=inte(res,term(p));\n      continue;\n    }\n    if(t[p]=='d'){\n      p++;\n      res=diff(res,term(p));\n      continue;\n    }\n    if(t[p]=='s'){\n      p++;\n      res=symm(res,term(p));\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nset<int> term(int &p){\n  set<int> res;\n  if(t[p]=='c'){\n    p++;\n    res=comp(term(p));\n  }else if(t[p]=='('){\n    p++;\n    res=expr(p);\n    p++;\n  }else{\n    res=factor(p);\n  }\n  return res;\n}\nset<int> factor(int &p){\n  set<int> res=s[t[p++]-'A'];\n  return res;\n}\n\n\nsigned main(){\n  char c;\n  while(cin>>c){\n    for(int i=0;i<10;i++) s[i].clear();\n    a.clear();\n    int x[10];\n    int k=0;\n    do{\n      cin>>x[k];\n      for(int i=0,t;i<x[k];i++){\n\tcin>>t;\n\ts[c-'A'].insert(t);\n\ta.insert(t);\n      }\n    }while(cin>>c,c!='R');\n    int p;\n    cin>>p>>t;\n    set<int> ans=expr(p);\n    bool f=0;\n    for(int i:ans){\n      if(f) cout<<\" \";\n      f=1;\n      cout<<i;\n    }\n    if(ans.empty()) cout<<\"NULL\";\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\nusing std::begin;\nusing std::end;\n\ntypedef map<char, set<int> > M;\n\nvector<int> conv_vec(set<int> st) {\n    vector<int> vec;\n    for(set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n        vec.push_back(*it);\n    }\n    return vec;\n}\n\nset<int> conv_set(vector<int> vec) {\n    set<int> st;\n    for(vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        st.insert(*it);\n    }\n    return st;\n}\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nset<int> calc(set<int> st_A, set<int> st_B, char order) {\n    vector<int> result;\n    vector<int> A = conv_vec(st_A), B = conv_vec(st_B);\n\n    if (order == 'u') {\n        std::set_union(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'i') {\n        std::set_intersection(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'd') {\n        std::set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 's') {\n        std::set_symmetric_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    } else if (order == 'c') {\n        std::set_difference(begin(A), end(A), begin(B), end(B), inserter(result, end(result)));\n    }\n    //show(A, B, order, result);\n    return conv_set(result);\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nset<int> parse(string str, M dataset, int start) {\n    int p = start;\n    set<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    set<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (set<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    set<int> U;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            dataset['U'] = U;\n            solve(str, dataset);\n            dataset.clear();\n            U.clear();\n            continue;\n        }\n        set<int> st;\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            st.insert(u);\n            U.insert(u);\n        }\n        dataset[s] = st;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nstring test = \"uids\";\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\tassert(mp.find(c) != mp.end());\n\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\t//assert(test.find(op) != string::npos);\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\tif(!(cin>>c>>d))return 0;\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvector<int> compute_union(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    tmp.insert(A[i]);\n  }\n  for(int i = 0; i < B.size(); i++){\n    tmp.insert(B[i]);\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_intersection(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        tmp.insert(A[i]);\n      }\n    }\n  }\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_difference(const vector<int>& A,const vector<int>& B){\n  set<int> tmp;\n  for(int i = 0; i < A.size(); i++){\n    bool isok = true;\n    for(int j = 0; j < B.size(); j++){\n      if(A[i] == B[j]){\n        isok = false;\n      }\n    }\n    if(isok){\n      tmp.insert(A[i]);\n    }\n  }\n\n  vector<int> res;\n  for(set<int>::iterator it = tmp.begin(); it != tmp.end(); it++){\n    res.push_back(*it);\n  }\n  return res;\n}\n\nvector<int> compute_symmetric_difference(const vector<int>& A,const vector<int>& B){\n  vector<int> intersection = compute_intersection(A,B);\n  vector<int> diff_a = compute_difference(A,intersection);\n  vector<int> diff_b = compute_difference(B,intersection);\n  return compute_union(diff_a,diff_b);\n}\n\nvector<int> compute_complement(const vector<int>& A,const vector<int>& U){\n  vector<int> intersection = compute_intersection(A,U);\n  return compute_difference(U,intersection);\n}\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos);\n\nP factor(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  P r1 = term(str,numbers,U,pos);\n  pos = r1.first;\n  vector<int> current_set = r1.second;\n  while(pos < str.size()\n        && (str[pos] == 'u' || str[pos] == 'i'\n            || str[pos] == 'd' || str[pos] == 's')){\n    if(str[pos] == 'u'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_union(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'i'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_intersection(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 'd'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n    else if(str[pos] == 's'){\n      P r2 = term(str,numbers,U,pos+1);\n      current_set = compute_symmetric_difference(current_set,r2.second);\n      pos = r2.first;\n    }\n  }\n  return P(pos,current_set);\n}\n\nP term(const string& str,vector<int> numbers[256],const vector<int>& U, int pos){\n  if(str[pos] == '('){\n    P r = factor(str,numbers,U,pos+1);\n    pos = r.first;\n    pos++;\n    return P(pos,r.second);\n  }\n  else if(str[pos] == 'c'){\n    P r = term(str,numbers,U,pos+1);\n    vector<int> current_set = compute_complement(r.second,U);\n    return P(r.first,current_set);\n  }\n  else if(str[pos] == 'A' || str[pos] == 'B'\n          || str[pos] == 'C' || str[pos] == 'D'\n          || str[pos] == 'E'){\n    return P(pos+1,numbers[str[pos]]);\n  }\n}\n\nint main(){\n  while(!cin.eof()){\n    string alphabet;\n    int num_of_elements;\n    vector<int> numbers[256];\n    vector<int> U;\n    while(cin >> alphabet >> num_of_elements){\n      if(alphabet[0] == 'R' && num_of_elements == 0){\n        break;\n      }\n      \n      for(int element_i = 0; element_i < num_of_elements; element_i++){\n        int num;\n        cin >> num;\n        numbers[alphabet[0]].push_back(num);\n      }\n      U = compute_union(numbers[alphabet[0]],U);\n    }\n    string text;\n    cin >> text;\n    P r = factor(text,numbers,U,0);\n    vector<int> result = r.second;\n    if(result.size() == 0){\n      printf(\"NULL\");\n    }\n    else{\n      for(int i = 0; i < result.size(); i++){\n        printf(\"%s%d\", i == 0 ? \"\" : \" \", result[i]);\n      }\n    }\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\n \nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\nvoid show(vector<int> ans){\n\tbool r=false;\n        for(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n        if(!r) cout<<\"NULL\";\n        cout<<endl;\n}\nvector<int> U(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]|a2[i]);\n    return ve1;\n}\n \nvector<int> I(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]&a2[i]);\n    return ve1;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(a1[i]^a2[i]);\n    return ve1;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n    vector<int> ve1;\n     \n    for(int i=0;i<a1.size();i++){\n        int r;\n        if(a1[i]==1 && a2[i]==0) r=1;\n        else r=0;\n        ve1.pb(r);\n    }\n    return ve1;\n}\n \nvector<int> C(vector<int> a1){\n    vector<int> ve1;\n    for(int i=0;i<a1.size();i++)ve1.pb(1-a1[i]);\n    return ve1;\n}\nvector<int> shiki();\nvector<int> ka();\nvector<int> han(){\n//  cout<<s[it]<<endl;\n    if(s[it]=='c'){\n    //\tcout<<it<<endl;\n        it++;\n        vector<int> e=ka();\n    //\tshow(C(e));\n        return C(e);\n    }\n    else{\n        it++;\n        return ch[s[it-1]-'A'];\n    }\n}\n \nvector<int> ka(){\n    if(s[it]=='('){\n        it++;\n        vector<int> q=shiki();\n        it++;\n        return q;\n    }\n    else return han();\n     \n}\n \n \n \nvector<int> shiki(){\n    vector<int> r= ka();\n    while(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n        char c=s[it];\n    \t\n        it++;\n        vector<int> r2=ka();\n         \n        if(c=='u') r=U(r,r2);\n        if(c=='s') r=S(r,r2);\n        if(c=='d') r=D(r,r2);\n        if(c=='i') r=I(r,r2);\n    }\n//\tcout<<it<<endl;\n//\tshow(r);\n    return r;\n}\n \nint cnt=0;\nsigned main(){\nchar c;\n    int d;\n    while(1){\n         \n        cnt++;\n      if(cnt>20) break;\n         \n        while(1){\n            cin>>c>>d;\n             \n            if(c=='R') break;\n            for(int i=0;i<d;i++){\n                int r;\n                cin>>r;\n                ve[c-'A'].pb(r);\n            }\n             \n        }\n        set<int> se;\n         \n        for(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n        V.clear();\n        for(auto its=se.begin();its!=se.end();its++){\n            V.pb(*its);\n        }\n         \n        for(int i=0;i<5;i++){\n            for(int j=0;j<V.size();j++){\n            bool b=false;\n            for(int k=0;k<ve[i].size();k++){\n                if(ve[i][k]==V[j]) b=true;\n            }\n            if(b) ch[i].pb(1);\n            else ch[i].pb(0);\n        }\n    //      for(int j=0;j<V.size();j++)cout<<ch[i][j];\n    //      cout<<endl;\n        }\n        it=0;\n        cin>>s;\n        s+=\"*\";\n        vector<int> anss=shiki();\n   // \tcout<<anss.size()<<endl;\n   // \treturn 0;\n    \tshow(anss);\n    //\tcout<<\"s\"<<endl;\n   // \treturn 0;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str.size()==2){\n\t\treturn Complement(sets[str[1]],sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nmap<char, vector<int> > sets;\nvector<int> parse(const string& e)\n{\n\tif (e.empty())\n\t\treturn vector<int>();\n\telse if (e.size() == 1)\n\t\treturn sets[e[0]];\n\telse if (e.size() == 2)\n\t{\n\t\tvector<int> res(sets['U'].size() - sets[e[1]].size());\n\t\tset_symmetric_difference(all(sets[e[1]]), all(sets['U']), res.begin());\n\t\treturn res;\n\t}\n\t\n\tvector<int> left, right;\n\tchar ope;\n\tif (e[0] == '(')\n\t{\n\t\tint i, par = 1;\n\t\tfor (i = 1; par; ++i)\n\t\t{\n\t\t\tif (e[i] == '(')\n\t\t\t\t++par;\n\t\t\telse if (e[i] == ')')\n\t\t\t\t--par;\n\t\t}\n\t\tope = e[i];\n\t\tleft = parse(e.substr(1, i - 2));\n\t\tif (i == e.size())\n\t\t\treturn left;\n\t\tright = parse(e.substr(i + 1, e.size() - (i + 1)));\n\t}\n\telse if (e[0] == 'c')\n\t{\n\t\tope = e[2];\n\t\tleft = parse(e.substr(0, 2));\n\t\tright = parse(e.substr(3, e.size() - 3));\n\t}\n\telse\n\t{\n\t\tope = e[1];\n\t\tleft = parse(e.substr(0, 1));\n\t\tright = parse(e.substr(2, e.size() - 2));\n\t}\n\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nint main()\n{\n\twhile (!feof(stdin))\n\t{\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tscanf(\" %c%d\", &a, &n);\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tstatic char buf[512];\n\t\tscanf(\" %s\", buf);\n\t\tvector<int> res = parse(buf);\n\t\tif (res.empty())\n\t\t\tputs(\"NULL\");\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t\tprintf(\"%d%c\", res[i], i + 1 == res.size() ? '\\n' : ' ');\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<int,vi> parsed;\nparsed expr(const string& f,int i,const vi& u,const map<char,vi>& m);\n\nparsed term(const string& f,int i,const vi& u,const map<char,vi>& m)\n{\n\tif(f[i]=='('){\n\t\tparsed p=expr(f,i+1,u,m);\n\t\tp.first++;\n\t\treturn p;\n\t}\n\telse if(f[i]=='c'){\n\t\tparsed p=term(f,i+1,u,m);\n\t\tvi a(u.size());\n\t\ta.erase(set_difference(all(u),all(p.second),a.begin()),a.end());\n\t\treturn parsed(p.first,a);\n\t}\n\telse\n\t\treturn parsed(i+1,m.at(f[i]));\n}\n\nparsed expr(const string& f,int i,const vi& u,const map<char,vi>& m)\n{\n\tparsed p=term(f,i,u,m);\n\twhile(p.first<f.size() && islower(f[p.first])){\n\t\tchar op=f[p.first];\n\t\tparsed p2=term(f,p.first+1,u,m);\n\t\tvi a(u.size());\n\t\tif(op=='u')\n\t\t\ta.erase(set_union(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tif(op=='i')\n\t\t\ta.erase(set_intersection(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tif(op=='d')\n\t\t\ta.erase(set_difference(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tif(op=='s')\n\t\t\ta.erase(set_symmetric_difference(all(p.second),all(p2.second),a.begin()),a.end());\n\t\tp=parsed(p2.first,a);\n\t}\n\treturn p;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tmap<char,vi> m;\n\t\tstring f;\n\t\t{\n\t\t\tchar c; int n;\n\t\t\twhile(cin>>c>>n && c!='R'){\n\t\t\t\tvi a(n);\n\t\t\t\trep(i,n)\n\t\t\t\t\tcin>>a[i];\n\t\t\t\tsort(all(a));\n\t\t\t\tm[c]=a;\n\t\t\t}\n\t\t\tif(!(cin>>f))\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvi u;\n\t\tfor(auto kv:m)\n\t\t\tu.insert(u.end(),all(kv.second));\n\t\tsort(all(u));\n\t\tu.erase(unique(all(u)),u.end());\n\t\t\n\t\tparsed p=expr(f,0,u,m);\n\t\tfor(int i=0;i<p.second.size();i++)\n\t\t\tcout<<p.second[i]<<(i==p.second.size()-1?'\\n':' ');\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> A,B,C,D,E,U;//mapを使った方が楽。\nmap<char, vector<int>> sets;\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        sort(v.begin(), v.end());\n        ret = dif(U, v);\n    }\n    else {\n        ret = sets[*begin];\n        sort(ret.begin(), ret.end());\n        begin++;\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n            else{\n                for(int i=0; i<n; i++){\n                    int input;\n                    cin >> input;\n                    sets[se].push_back(input);\n                    u.insert(input);\n                }\n            }\n        }\n\n        for(pair<char,vector<int>> v : sets){\n            sort(v.second.begin(), v.second.end());\n            cout << v.first << \" : \";\n            for(int num : v.second){\n                cout << num << \" \";\n            }\n            cout << endl;\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n#define EACH(it,n) for(S::iterator it = (n).begin(); it != (n).end() ; ++it)\ntypedef set<int> S;\nmap< string , S > data;\n\n\nstring expr;\n\nS uni(S a,S b){\n\tS ans;\n\tEACH(it,a) ans.insert(*it);\n\tEACH(it,b) ans.insert(*it);\n\treturn ans;\n}\nS inter(S a,S b){\n\tS ans;\n\tEACH(it,a) if(b.count(*it))ans.insert(*it);\n\treturn ans;\n}\nS diff(S a,S b){\n\tS ans;\n\tEACH(it,a) if(!b.count(*it))ans.insert(*it);\n\treturn ans;\n} \nS sym(S a,S b){\n\treturn uni(diff(a,b),diff(b,a));\n}\nS comp(S a){\n\tS ans;\n\tEACH(it,data[\"U\"]) if(!a.count(*it)) ans.insert(*it);\n\treturn ans;\n}\n\n\nint pos = 0;\n\nvoid view(S s){\n\tif(s.size()==0) cout << \"NULL\" << endl;\n\tEACH(it,s){\n\t\tcout << *it;\n\t\tS::iterator it2 = it;\n\t\tit2++;\n\t\tif( it2 == s.end()) cout << endl;\n\t\telse cout << \" \";\n\t}\n}\nset<int> f(int depth){\n\tstring table = \"uids\";\n\tset<int> le,ri;\n\twhile(pos < expr.size()){\n\t\tint jump = 1;\n\t\tif(expr[pos] == ')'){\n\t\t\treturn le;\n\t\t}else if(expr[pos] == '('){\n\t\t\tpos++;\n\t\t\tle = f(depth+1);\n\t\t}else if(expr[pos] == 'c'){\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos+=2;\n\t\t\t\tle = comp(f(depth+1));\n\t\t\t}else{\n\t\t\t\tjump ++;\n\t\t\t\tle = comp(data[string(1,expr[pos+1])]);\n\t\t\t}\n\t\t}else if(~table.find(expr[pos])){\n\t\t\tchar cc = expr[pos];\n\t\t\tif(expr[pos+1] == '('){\n\t\t\t\tpos+=2;\n\t\t\t\tri = f(depth+1);\n\t\t\t}else if(expr[pos+1] == 'c'){\n\t\t\t\tif(expr[pos+2] == '('){\n\t\t\t\t\tpos+=3;\n\t\t\t\t\tri = comp(f(depth+1));\n\t\t\t\t}else{\n\t\t\t\t\tjump+=2;\n\t\t\t\t\tri = comp(data[string(1,expr[pos+2])]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tjump++;\n\t\t\t\tri = data[string(1,expr[pos+1])];\n\t\t\t}\n\t\t\tif(cc == 'u') le = uni(le,ri);\n\t\t\tif(cc == 'i') le = inter(le,ri);\n\t\t\tif(cc == 'd') le = diff(le,ri);\n\t\t\tif(cc == 's') le = sym(le,ri);\n\t\t}else{\n\t\t\tle = data[string(1,expr[pos])];\n\t\t}\n\t\tpos += jump;\n\t}\n\treturn le;\n}\nint main(){\n\twhile(1){\n\t\tstring a; int b;\n\t\tif(cin >> a >> b){\n\t\t\tif(a == \"R\" && b == 0){\n\t\t\t\tcin >> expr;\n\t\t\t\twhile(~expr.find(\"cc\")) expr.replace(expr.find(\"cc\"),2,\"\");\n\t\t\t\tpos = 0;\n\t\t\t\tset<int> res = f(0);\n\t\t\t\tview(res);\n\t\t\t\tdata.clear();\n\t\t\t}else{\n\t\t\t\tfor(int i = 0 ; i < b ; i++){\n\t\t\t\t\tint t; cin >> t;\n\t\t\t\t\tdata[a].insert(t);\n\t\t\t\t\tdata[\"U\"].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}else return 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\ntypedef set<int>::iterator si;\n\nconst int N = 26;\n\nset<int> s[N];\nstring str;\nint pos;\n\nset<int> exp();\n\nset<int> val(){\n\tset<int> res;\n\tif(str[pos] == 'c'){\n\t\t++pos;\n\t\tset<int> tmp = val();\n\t\tfor(si ite=s['U'-'A'].begin();ite!=s['U'-'A'].end();++ite){\n\t\t\tif(tmp.find(*ite) == tmp.end()) res.insert(*ite);\n\t\t}\n\t}else if(str[pos] == '('){\n\t\t++pos;\n\t\tres = exp();\n\t\t++pos;\n\t}else if('A' <= str[pos] && str[pos] <= 'D'){\n\t\tres = s[str[pos] - 'A'];\n\t\t++pos;\n\t}\n\t//cout << \"res.size() = \" << res.size() << endl;\n\treturn res;\n}\n\nset<int> exp(){\n\tset<int> a = val();\n\twhile(pos < str.size()){\n\t\t//for(int i=0;i<5;i++){\n\t\t//cout << pos << endl;\n\t\tset<int> b, c;\n\t\tif(str[pos] == 'u'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite) c.insert(*ite);\n\t\t\tfor(si ite=b.begin();ite!=b.end();++ite) c.insert(*ite);\n\t\t}else if(str[pos] == 'i'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) != b.end()) c.insert(*ite);\n\t\t\t}\n\t\t}else if(str[pos] == 'd'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) == b.end()) c.insert(*ite);\n\t\t\t}\n\t\t}else if(str[pos] == 's'){\n\t\t\t++pos;\n\t\t\tb = val();\n\t\t\tset<int> d, e;\n\t\t\tfor(si ite=a.begin();ite!=a.end();++ite){\n\t\t\t\tif(b.find(*ite) == b.end()) d.insert(*ite);\n\t\t\t}\t\t\n\t\t\tfor(si ite=b.begin();ite!=b.end();++ite){\n\t\t\t\tif(a.find(*ite) == a.end()) e.insert(*ite);\n\t\t\t}\t\t\n\t\t\tfor(si ite=d.begin();ite!=d.end();++ite) c.insert(*ite);\n\t\t\tfor(si ite=e.begin();ite!=e.end();++ite) c.insert(*ite);\t\t\n\t\t}else break;\n\t\ta = c;\n\t}\n\treturn a;\n}\n\nint main(){\n\tchar c;\n\tint n;\n\twhile(cin >> c >> n){\n\t\tfor(int i=0;i<N;++i) s[i].clear();\n\t\twhile(1){\n\t\t\tif(c == 'R' && n == 0) break;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\ts[c-'A'].insert(in);\n\t\t\t}\n\t\t\tcin >> c >> n;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(si ite=s[i].begin();ite!=s[i].end();++ite) s['U'-'A'].insert(*ite);\n\t\t}\n\t\tcin >> str;\n\t\tpos = 0;\n\t\tset<int> ans = exp();\n\t\tif(ans.size() == 0){\n\t\t\tcout << \"NULL\" << endl;\n\t\t}else{\n\t\t\tfor(si ite=ans.begin();ite!=ans.end();++ite){\n\t\t\t\tif(ite != ans.begin()) cout << ' ';\n\t\t\t\tcout << *ite;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct evaluator\n{\n  vector<int> all;\n  vector<int> sets[5];\n\n  vector<int> factor(Iterator& it, const Iterator& last) const\n  {\n    if (*it == '(') {\n      ++it;\n      const vector<int> r = expr(it, last);\n      ++it;\n      return r;\n    } else {\n      const int i = *it-'A';\n      ++it;\n      return sets[i];\n    }\n  }\n\n  vector<int> term(Iterator& it, const Iterator& last) const\n  {\n    if (*it == 'c') {\n      ++it;\n      const vector<int> s = factor(it, last);\n      vector<int>::const_iterator kt = s.begin();\n      vector<int> r;\n      for (vector<int>::const_iterator jt = all.begin(); jt != all.end(); ++jt) {\n        if (kt != s.end() && *jt == *kt) {\n          ++kt;\n        } else {\n          r.push_back(*jt);\n        }\n      }\n      return r;\n    } else {\n      return factor(it, last);\n    }\n  }\n\n  vector<int> expr(Iterator& it, const Iterator& last) const\n  {\n    vector<int> r = term(it, last);\n    while (it != last && (*it == 'u' || *it == 'i' || *it == 'd' || *it == 's')) {\n      const char op = *it;\n      ++it;\n      const vector<int> l = term(it, last);\n      vector<int> o;\n      switch (op) {\n        case 'u':\n          set_union(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'i':\n          set_intersection(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 'd':\n          set_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n        case 's':\n          set_symmetric_difference(r.begin(), r.end(), l.begin(), l.end(), back_inserter(o));\n          break;\n      }\n      swap(r, o);\n    }\n    return r;\n  }\n};\n\nint main()\n{\n  while (!cin.eof()) {\n    string name;\n    int n;\n    evaluator e;\n    while (cin >> name >> n && name != \"R\") {\n      vector<int>& s = e.sets[name[0]-'A'];\n      for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        e.all.push_back(x);\n        s.push_back(x);\n      }\n      sort(s.begin(), s.end());\n    }\n    sort(e.all.begin(), e.all.end());\n    e.all.erase(unique(e.all.begin(), e.all.end()), e.all.end());\n\n    string s;\n    cin >> s;\n    Iterator it = s.begin(), last = s.end();\n    const vector<int> r = e.expr(it, last);\n    if (r.empty()) {\n      cout << \"NULL\" << endl;\n    } else {\n      for (vector<int>::const_iterator it = r.begin(); it != r.end(); ++it) {\n        if (it != r.begin()) {\n          cout << ' ';\n        }\n        cout << *it;\n      }\n      cout << endl;\n    }\n\n    cin.ignore();\n    cin.peek();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvector<int> expr();\nvector<int> set1();\nvector<int> set2();\nvector<int> alpha();\n\nint idx;\nchar s[2000];\n\nvector<int> S[5],U;\n\nvector<int> calc_c(const vector<int> &A){\n\tvector<int> B;\n\trep(i,U.size()) if(!binary_search(A.begin(),A.end(),U[i])) B.push_back(U[i]);\n\treturn B;\n}\n\nvector<int> calc_u(const vector<int> &A,const vector<int> &B){\n\tvector<int> C;\n\trep(i,A.size()) C.push_back(A[i]);\n\trep(i,B.size()) C.push_back(B[i]);\n\tsort(C.begin(),C.end());\n\tC.erase(unique(C.begin(),C.end()),C.end());\n\treturn C;\n}\n\nvector<int> calc_i(const vector<int> &A,const vector<int> &B){\n\treturn calc_c(calc_u(calc_c(A),calc_c(B)));\n}\n\nvector<int> calc_d(const vector<int> &A,const vector<int> &B){\n\treturn calc_i(A,calc_c(B));\n}\n\nvector<int> calc_s(const vector<int> &A,const vector<int> &B){\n\treturn calc_u(calc_d(A,B),calc_d(B,A));\n}\n\nvector<int> expr(){\n\tvector<int> A=set1();\n\twhile(s[idx] && s[idx]!=')'){\n\t\tchar op=s[idx++];\n\t\tvector<int> B=set1();\n\n\t\tif     (op=='u') A=calc_u(A,B);\n\t\telse if(op=='i') A=calc_i(A,B);\n\t\telse if(op=='d') A=calc_d(A,B);\n\t\telse             A=calc_s(A,B);\n\t}\n\treturn A;\n}\n\nvector<int> set1(){\n\tif(s[idx]=='c'){\n\t\tidx++;\n\t\treturn calc_c(set1());\n\t}\n\telse return set2();\n}\n\nvector<int> set2(){\n\tvector<int> A;\n\tif(s[idx]=='('){\n\t\tidx++;\n\t\tA=expr();\n\t\tidx++;\n\t}\n\telse A=alpha();\n\treturn A;\n}\n\nvector<int> alpha(){ return S[s[idx++]-'A']; }\n\nint main(){\n\twhile(1){\n\t\tU.clear();\n\t\twhile(1){\n\t\t\tchar c;\n\t\t\tint n;\n\t\t\tif(!~scanf(\" %c%d\",&c,&n)) return 0;\n\t\t\tif(c=='R') break;\n\n\t\t\tS[c-'A'].clear();\n\t\t\trep(i,n){\n\t\t\t\tint e; scanf(\"%d\",&e);\n\t\t\t\tS[c-'A'].push_back(e);\n\t\t\t\tU.push_back(e);\n\t\t\t}\n\t\t\tsort(S[c-'A'].begin(),S[c-'A'].end());\n\t\t}\n\t\tsort(U.begin(),U.end());\n\t\tU.erase(unique(U.begin(),U.end()),U.end());\n\n\t\tscanf(\"%s\",s);\n\t\tidx=0;\n\t\tvector<int> res=expr();\n\n\t\tif(res.size()==0) puts(\"NULL\");\n\t\telse rep(i,res.size()) printf(\"%d%c\",res[i],i<(int)res.size()-1?' ':'\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n \nconst int MAXN = 501;\n \nchar A[5][MAXN];\nint pos;\nstring line;\n \nvector<char> exp();\nvector<char> fact();\n \nvector<char> exp() {\n  vector<char> res = fact();\n  while(1) {\n    if(line[pos] == 'u') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] || x[i]);\n      }\n    } else if(line[pos] == 'i') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && x[i]);\n      }\n    } else if(line[pos] == 'd') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = (res[i] && !x[i]);\n      }\n    } else if(line[pos] == 's') {\n      ++pos;\n      vector<char> x = fact();\n      for(int i = 0; i< x.size(); ++i) {\n\tres[i] = ((res[i] && !x[i]) || (x[i] && !res[i]));\n      }\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n \nvector<char> fact() {\n  vector<char> res;\n  if(line[pos] == 'c') {\n    ++pos;\n    res = fact();\n    for(int i = 0; i < res.size(); ++i) {\n      res[i] = 1-res[i];\n    }\n  } else if(isupper(line[pos])) {\n    char c = line[pos];\n    ++pos;\n    res = vector<char>(A[c-'A'], A[c-'A']+MAXN);\n  } else if(line[pos] == '(') {\n    ++pos;\n    res = exp();\n    ++pos;\n  }\n  return res;\n}\n \nmap<int,int> id, rid;\nint getId(int n) {\n  if(!id.count(n)) {\n    id[n] = id.size()-1;\n    rid[id[n]] = n;\n  }\n  return id[n];\n}\n \nint main() {\n  while(1) {\n    bool run = true;\n    fill(A[0], A[5], false);\n    id.clear();\n    rid.clear();\n    while(1) {\n      char c;\n      int n;\n      if(!(cin >> c >> n)) {\n\trun = false;\n\tbreak;\n      }\n      if(c == 'R' && n == 0) break;\n      for(int i = 0; i < n; ++i) {\n\tint a;\n\tcin >> a;\n\ta = getId(a);\n\tA[c-'A'][a] = true;\n      }\n    }\n    if(!run) break;\n    string s;\n    cin >> s;\n    line = s;\n    pos = 0;\n    vector<char> res = exp();\n    vector<int> ans;\n    for(int i = 0, cnt = 0; i < res.size(); ++i) {\n      if(rid.count(i) && res[i]) {\n\tans.push_back(rid[i]);\n      }\n    }\n    sort(ans.begin(), ans.end());\n    if(ans.size() == 0) {\n      cout << \"NULL\" << endl;\n    } else {\n      for(int i = 0; i < ans.size(); ++i) {\n\tif(i) cout << \" \";\n\tcout << ans[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define State string::const_iterator\n\nclass ParseError {};\n\nvector<int> A,B,C,D,E,U;//mapを使った方が楽。\n\nvector<int> expression(State &begin);\nvector<int> com(State &begin);\nvector<int> _set(State &begin);\nvector<int> factor(State &begin);\ninline void consume(State &begin, char expected);\n\nvector<int> dif(vector<int> my_left, vector<int>my_right){\n    vector<int> ret = {};\n    std::set_difference(my_left.begin(), my_left.end(),\n                        my_right.begin(), my_right.end(),\n                        std::inserter(ret, ret.end()));\n    return ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nvector<int> expression(State &begin) {\n    vector<int> my_left = factor(begin);\n    vector<int> ret = {};\n\n    while(true){\n        if(*begin == 'u'){\n            consume(begin, 'u');\n            vector<int> my_right = factor(begin);\n            set_union(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'i'){\n            consume(begin, 'i');\n            vector<int> my_right = factor(begin);\n            set_intersection(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else if(*begin == 'd'){\n            consume(begin, 'd');\n            vector<int> my_right = factor(begin);\n            ret = dif(my_left, my_right);\n        }\n        else if(*begin == 's'){\n            consume(begin, 's');\n            vector<int> my_right = factor(begin);\n            set_symmetric_difference(std::begin(my_left), std::end(my_left), std::begin(my_right), std::end(my_right), std::inserter(ret, std::end(ret)));\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nvector<int> com(State &begin) {\n\n    vector<int> ret = {};\n    if(*begin == 'c'){\n        consume(begin, 'c');\n        vector<int> v = factor(begin);\n        set_difference(U.begin(), U.end(), v.begin(), v.end(), std::inserter(ret, ret.end()));\n    }\n    else {\n        ret = _set(begin);\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nvector<int> _set(State &begin) {\n    vector<int> ret;\n\n    if(*begin == 'A'){\n        consume(begin, 'A');\n        ret = A;\n    }\n    else if(*begin == 'B'){\n        consume(begin, 'B');\n        ret = B;\n    }\n    else if(*begin == 'C'){\n        consume(begin, 'C');\n        ret = C;\n    }\n    else if(*begin == 'D'){\n        consume(begin, 'D');\n        ret = D;\n    }\n    else if(*begin == 'E'){\n        consume(begin, 'E');\n        ret = E;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nvector<int> factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '('); // '('を飛ばす。\n        vector<int> ret = expression(begin);\n        consume(begin, ')'); // ')'を飛ばす。\n        return ret;\n    } else {\n        return com(begin);\n    }\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\ninline void consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        set<int> u;\n\n        while (true) {\n\n            char se;\n            int n;\n\n            cin >> se >> n;\n\n            if (se == 'R') {\n                break;\n            }\n\n            if (se == 'A') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    A.push_back(input);\n                    u.insert(input);\n                }\n                sort(A.begin(), A.end());\n            } else if (se == 'B') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    B.push_back(input);\n                    u.insert(input);\n                }\n                sort(B.begin(), B.end());\n            } else if (se == 'C') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    C.push_back(input);\n                    u.insert(input);\n                }\n                sort(C.begin(), C.end());\n            } else if (se == 'D') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    D.push_back(input);\n                    u.insert(input);\n                }\n                sort(D.begin(), D.end());\n            } else if (se == 'E') {\n                for (int i = 0; i < n; i++) {\n                    int input;\n                    cin >> input;\n                    E.push_back(input);\n                    u.insert(input);\n                }\n                sort(E.begin(), E.end());\n            }\n        }\n\n        for (int num : u) {\n            U.push_back(num);\n        }\n\n        string formula;\n\n        cin >> formula;\n\n        if(formula == \"shutdown\"){\n            break;\n        }\n\n        State begin = formula.begin();\n\n        vector<int> ans = expression(begin);\n\n        if (ans.size() == 0) {\n            cout << \"NULL\" << endl;\n        } else {\n            cout << ans[0];\n\n            for (int i = 1; i < ans.size(); i++) {\n                cout << \" \" << ans[i];\n            }\n\n            cout << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n \nusing namespace std;\n\nmap<char, set<int>> elements;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n \n    Parse(string s){\n        it = s.begin();\n    }\n     \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n     \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n \n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n     \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n \n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n \n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n \n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n \nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        elements.clear();\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n \n        elements['U'] = U;\n         \n        string str;\n        cin >> str;\n         \n        Parse parse(str);\n        set<int> res = parse.expr();\n         \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    p++;\n    if(S[p]-'A'>5)exit(0);if(S[p]-'A'<0)exit(0);\n    s=C(uni,st[S[p]-'A']),p++;\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\ntypedef vector<int> vec;\n\nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    int av=(ai==as?INF:a[ai]);\n    int bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  int a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      if(ch=='R')break;\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nset<int> U(set<int> A,set<int> B){\n  set<int> S=A;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end())S.insert(*I),I++;\n  return S;\n}\n\nset<int> M(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=A.begin();\n  while(I!=A.end()){\n    if(!B.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nset<int> T(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end()){\n    if(A.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nstring s;\nset<int> V[6];\n\nset<int> dfs(int l,int r){\n  set<int> A,B;\n  bool f=0,bf=0;\n  char cmd=0;\n  for(int j=l;j<r;j++){\n\n    if(s[j]=='('){\n      int c=1,st=j+1;\n      j++;\n      for(;c;j++){\n\tif(s[j]=='(')c++;\n\tif(s[j]==')')c--;\n      }\n      j--;\n      B=dfs(st,j);\n      bf=1;\n    }\n    \n    if('a'<s[j]&&s[j]<'z'){\n      if(s[j]=='c')f=1;\n      else cmd=s[j];\n    }\n    \n    if('A'<=s[j]&&s[j]<'Z'){\n      int nid=s[j]-'A';\n      if(s[j]=='U')nid=5;\n      B=V[nid];\n      bf=1;\n    }\n\n    if(bf){\n      if(f){\n\tB=M(V[5],B);\n\tf=0;\n      }\n      if(cmd=='u')A=U(A,B);\n      if(cmd=='i')A=T(A,B);\n      if(cmd=='d')A=M(A,B);\n      if(cmd=='s')A=U(M(A,B),M(B,A));\n      if(cmd==0)A=B;\n      bf=0;cmd=0;\n    }\n  }\n  return A;\n}\n\nint main(){\n  while(1){\n    for(int i=0;i<=5;i++)V[i].clear();\n    while(1){\n      char c;\n      int x;\n      if(cin>>c>>x==0)return 0;\n      if(c=='R')break;\n      for(int i=0,a;i<x;i++)cin>>a,V[c-'A'].insert(a),V[5].insert(a);\n    }\n\n    cin>>s;\n    \n    set<int> res=dfs(0,s.size());\n    set<int>::iterator I=res.begin();\n    while(I!=res.end()){\n      if(I!=res.begin())cout<<\" \";\n      cout<<*I;\n      I++;\n    }\n    if(res.size()==0)cout<<\"NULL\";\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nusing S = set<int>;\nS U;\nmap<char, S> m;\n\nstring s;\nint N;\nint c;\n\nS expr();\nS factor();\nS num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \" + s << endl;\n\tfor(int i = 0; i < text.size() + 1 + N; i++){\n\t\tif(i == text.size() + 1 + c) cout << \"*\";\n\t\telse cout << \" \";\n\t}\n\tcout << endl;\n}\n\nS Union(S s1, S s2){\n\tfor(auto v : s2){\n\t\ts1.insert(v);\n\t}\n\treturn s1;\n}\n\nS Intersection(S s1, S s2){\n\tS ret;\n\tfor(auto v : s2){\n\t\tif(s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Diff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS SymDiff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\tfor(auto v : s2){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Comp(S s1){\n\tS ret;\n\tfor(auto v : U){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS expr(){\n\tdebug(\"expr\");\n\tS x = factor();\n\twhile(c < N){\n\t\tif(s[c] == 'u'){\n\t\t\tc++;\n\t\t\tx = Union(x, factor());\n\t\t}\n\t\telse if(s[c] == 'i'){\n\t\t\tc++;\n\t\t\tx = Intersection(x, factor());\n\t\t}\n\t\telse if(s[c] == 'd'){\n\t\t\tc++;\n\t\t\tx = Diff(x, factor());\n\t\t}\n\t\telse if(s[c] == 's'){\n\t\t\tc++;\n\t\t\tx = SymDiff(x, factor());\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nS factor(){\n\tdebug(\"factor\");\n\tbool rev = false;\n\tif(s[c] == 'c'){\n\t\trev = 1;\n\t\tc++;\n\t}\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tS ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\tif(rev) ret = Comp(ret);\n\t\treturn ret;\n\t}\n\tS ret = num();\n\tif(rev) ret = Comp(ret);\n\treturn ret;\n}\n\nS num(){\n\tdebug(\"num\");\n\tS ret = m[s[c]];\n\tc++;\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tm.clear();\n\t\tU.clear();\n\t\tchar name;\n\t\tint n;\n\t\twhile(true){\n\t\t\tif(!(cin >> name >> n)) return 0;\n\t\t\tif(name == 'R') break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tU.insert(a);\n\t\t\t\tm[name].insert(a);\n\t\t\t}\n\t\t}\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tS ans = expr();\n\t\tfor(auto v : ans){\n\t\t\tcout << v << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\n// mapで文字集合を管理しておくのがよさそう\nmap<char, set<int> > mset;\nset<int> U; // 全体集合\n\n// 和集合\nset<int> unite(set<int> X, set<int> Y) {\n    for(auto &x : Y) {\n        X.insert(x);\n    }\n    return X;\n}\n\n// 積集合\nset<int> intersect(set<int> X, set<int> Y) {\n    set<int> ret;\n    for(auto &x : Y) {\n        if(X.count(x)) ret.insert(x);\n    }\n    return ret;\n}\n\n// dの処理\nset<int> diff(set<int> X, set<int> Y) {\n    set<int> ret;\n    for(auto &x : X) {\n        if(Y.count(x) == 0) ret.insert(x);\n    }\n    return ret;\n}\n\n// sの処理\nset<int> sym_diff(set<int> X, set<int> Y) {\n    return unite(diff(X, Y), diff(Y, X));\n}\n\n// cの処理\nset<int> comp(set<int> X) {\n    set<int> ret;\n    for(auto &x : U) {\n        if(X.count(x) == 0) ret.insert(x);\n    }\n    return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    // エラー検出\n    void consume(State &begin, char expected) {\n        if(*begin == expected) begin++;\n        else {\n            cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n            cerr << \"Rest string is '\";\n            while(*begin) {\n                cerr << *begin++;\n            }\n            cerr << \"'\" << endl;\n            throw ParseError();\n        }\n    }\n\n    // 数字の列をパースして、その数を返す\n    // 今回は文字を扱うので使わない\n    ll number(State &begin) {\n        ll ret = 0;\n        while(isdigit(*begin)) {\n            ret *= 10;\n            ret += (*begin - '0');\n            begin++;\n        }\n        return ret;\n    }\n\n    // 括弧か数をパースして、その評価結果を返す\n    // numberをその集合をリターンする形に変更\n    set<int> factor(State &begin) {\n        if(*begin == '(') {\n            consume(begin, '(');    // '('を飛ばす\n            set<int> ret = expression(begin);\n            consume(begin, ')');    // ')'を飛ばす\n            return ret;\n        }else {\n            // 値を取得してから1個進めておく\n            return mset[*begin++];\n        }\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    // cの処理が他より優先\n    set<int> term(State &begin) {\n        while(1) {\n            if(*begin == 'c') {\n                consume(begin, 'c');\n                return comp(factor(begin));\n            }else break;\n        }\n        return factor(begin);\n    }\n\n    // 四則演算の式をパースして、その評価結果を返す\n    // u, i, d, sの分岐を行う\n    set<int> expression(State &begin) {\n        set<int> ret = term(begin);\n        while(1) {\n            if(*begin == 'u') {\n                consume(begin, 'u');\n                ret = unite(ret, term(begin));\n            }else if(*begin == 'i') {\n                consume(begin, 'i');\n                ret = intersect(ret, term(begin));\n            }else if(*begin == 'd') {\n                consume(begin, 'd');\n                ret = diff(ret, term(begin));\n            }else if(*begin == 's') {\n                consume(begin, 's');\n                ret = sym_diff(ret, term(begin));\n            }else break;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    while(1) {\n        bool flg = false;\n        U.clear();  // 全体集合を初期化する\n        mset.clear();   // 一度mapを初期化する\n        // setに値を詰めている\n        char c; int n;\n        while(cin >> c >> n) {\n            flg = true;\n            if(c == 'R') break;\n            for(int i = 0; i < n; ++i) {\n                int xx; cin >> xx;\n                mset[c].insert(xx);\n                U.insert(xx);\n            }\n        }\n        if(!flg) break;\n\n        // 構文解析のフェーズ\n        Parser ps;\n        cin.ignore();\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        set<int> ans = ps.expression(begin);\n        int anslen = ans.size();\n        int cnt = 0;\n        if(anslen == 0) cout << \"NULL\" << endl;\n        else {\n            for(auto xans : ans) {\n                if(cnt == anslen-1) cout << xans << endl;\n                else cout << xans << \" \";\n                cnt++;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nenum{A,B,C,D,E,U};\nvector<int>S[6];\n\nint P;\nstring Expr;\n\nvector<int> calculate(vector<int>A,vector<int>B,char op){\n  vector<int>res(A.size()+B.size());\n  vector<int>::iterator x;\n  switch(op){\n  case 'u':\n    x=set_union(A.begin(),A.end(),B.begin(),B.end(),res.begin());\n    break;\n  case 'i':\n    x=set_intersection(A.begin(),A.end(),B.begin(),B.end(),res.begin());\n    break;\n  case 'd':\n    x=set_difference(A.begin(),A.end(),B.begin(),B.end(),res.begin());\n    break;\n  case 's':\n    x=set_symmetric_difference(A.begin(),A.end(),B.begin(),B.end(),res.begin());\n    break;\n  }\n  res.erase(x,res.end());\n  return res;\n}\n\nvector<int>equation();\nvector<int>term();\n\nvector<int>equation(){\n  vector<int>res=term();\n  char op;\n  while(1){\n    op=Expr[P];\n    if(op!='u'&&op!='i'&&op!='d'&&op!='s')break;\n    P++;\n    vector<int>res2=term();\n    res=calculate(res,res2,op);\n  }\n  return res;\n}\nvector<int>term(){\n  vector<int>res;\n  switch(Expr[P++]){\n  case 'c':\n    res=calculate(S[U],term(),'d');\n    break;\n  case '(':\n    res=equation();\n    P++;\n    break;\n  default:\n    res=S[Expr[P-1]-'A'];\n    break;\n  }\n  return res;\n}\n\nint main()\n{\n  char name;\n  int number,element;\n  while(cin>>name>>number){\n    do{\n      for(int i=0;i<number;i++){\n        cin>>element;\n        S[name-'A'].push_back(element);\n        S[U].push_back(element);\n      }\n    }while(cin>>name>>number,name!='R');\n    for(int i=0;i<6;i++){\n      sort(S[i].begin(),S[i].end());\n      S[i].erase(unique(S[i].begin(),S[i].end()),S[i].end());\n    }\n    cin>>Expr;\n    P=0;\n    vector<int>ans=equation();\n    vector<int>::iterator x;\n    if(ans.empty()){\n      cout<<\"NULL\"<<endl;\n    }else{\n      for(x=ans.begin();x!=ans.end();x++){\n        if(x!=ans.begin())cout<<\" \";\n        cout<<*x;\n      }\n      cout<<endl;\n    }\n    for(int i=0;i<6;i++)S[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nmap<char,set<int> > S;\nset<int> U;\nstring parse;\nint pos;\n\nset<int> expression();\n\nset<int> term(){\n  if( parse[pos] == '(' ){\n    ++pos;\n    set<int> p = expression();\n    ++pos;\n    return p;\n  } else if( parse[pos] == 'c' ) {\n    ++pos;\n    set<int> p = term();\n    set<int> ret = U;\n    for(set<int>::iterator it = p.begin();it!=p.end();it++) ret.erase(*it);\n    return ret;\n  } else {\n    char c = parse[pos++];\n    return S[c];\n  }\n}\n\nset<int> expression(){\n  set<int> a = term();\n\n  while( parse[pos] == 'u' || parse[pos] == 'i' || parse[pos] == 'd' || parse[pos] == 's' || parse[pos] == 'c' ){\n    char opr = parse[pos++];\n    set<int> b = term();\n    if( opr == 'u' ){\n      set<int> tmp = a;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) tmp.insert(*it);\n      a = tmp;\n    } else if( opr == 'i' ) {\n      map<int,int> counter;\n      set<int> tmp;\n      for(set<int>::iterator it = a.begin() ; it != a.end(); it++ ) counter[*it]++;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) counter[*it]++;\n      for(auto& i : counter)if( i.second == 2 ) tmp.insert(i.first);\n      a = tmp;\n    } else if( opr == 'd' ) {\n      set<int> tmp = a;\n      for(auto& i : b)tmp.erase(i);\n      a = tmp;\n    } else if( opr == 's' ) {\n      map<int,int> counter;\n      set<int> tmp;\n      for(set<int>::iterator it = a.begin() ; it != a.end(); it++ ) counter[*it]++;\n      for(set<int>::iterator it = b.begin() ; it != b.end(); it++ ) counter[*it]++;\n      for(auto& i : counter)if( i.second != 2 ) tmp.insert(i.first);\n      a = tmp;\n    }\n  }\n  return a;\n}\n\nint main(){\n\n  char c;\n  int n,tmp;\n  while(cin >> c >> n){\n    pos = 0;\n    S.clear();\n    U.clear();\n    rep(i,n){\n      cin >> tmp;\n      S[c].insert(tmp);\n    }\n\n    while(true){\n      cin >> c >> n;\n      if( c == 'R' && n == 0 ) break;\n      rep(i,n){\n\tcin >> tmp;\n\tS[c].insert(tmp);\n      }\n    }\n\n    for(map<char,set<int> >::iterator it = S.begin(); it != S.end(); it++){\n\tfor(set<int>::iterator it2 = (it->second).begin(); it2 != (it->second).end();it2++){\n\t  U.insert(*it2);\n\t}\n    }\n\n    cin >> parse;\n\n    set<int> answer = expression();\n    int i = 0;\n    bool output = false;\n    for(set<int>::iterator iter = answer.begin() ; iter != answer.end() ; iter++,i++ ){\n      if( i ) cout << ' ';\n      output = true;\n      cout << *iter;\n    } \n    if( !output ) cout << \"NULL\";\n    cout << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n\n#define M 5\n\nusing namespace std;\n\nstatic set<int>     U;\nstatic set<int>     lis[ M ];\nstatic const char * e;\n\n\nstatic set<int> expr ( void );\n\nstatic set<int>\nset_intersection (\n  const set<int> & a,\n  const set<int> & b\n  )\n{\n  set<int>::iterator ia, ib;\n  set<int> res;\n\n  for ( ia = a.begin ( ), ib = b.begin ( )\n      ; ia != a.end ( ) && ib != b.end ( ); )\n  {\n    if ( *ia == *ib )\n    {\n      res.insert ( *ia );\n      ++ia; ++ib;\n    }\n    else\n    {\n      ++( *ia < *ib ? ia : ib );\n    }\n  }\n\n  return ( res );\n}\n\nstatic set<int>\nset_union (\n  const set<int> & a,\n  const set<int> & b\n  )\n{\n  set<int>::iterator it;\n  set<int> res;\n\n  for ( it = a.begin ( ); it != a.end ( ); ++it )\n  {\n    res.insert ( *it );\n  }\n  for ( it = b.begin ( ); it != b.end ( ); ++it )\n  {\n    res.insert ( *it );\n  }\n\n  return ( res );\n}\n\nstatic set<int>\nset_difference (\n  const set<int> & a,\n  const set<int> & b\n  )\n{\n  set<int>::iterator ia, ib;\n  set<int> res;\n\n  for ( ia = a.begin ( ), ib = b.begin ( )\n      ; ia != a.end ( ); )\n  {\n    while ( ib != b.end ( ) && *ib < *ia )\n    {\n      ++ib;\n    }\n\n    if ( ib != b.end ( ) && *ia == *ib )\n    {\n      ++ia; ++ib;\n    }\n    else\n    {\n      res.insert ( *( ia++ ) );\n    }\n  }\n\n  return ( res );\n}\n\nstatic set<int>\nterm (\n  void\n  )\n{\n  if ( *e == '(' )\n  {\n    set<int> res;\n\n    ++e;\n    res = expr ( );\n    ++e;\n\n    return ( res );\n  }\n  else if ( *e == 'c' )\n  {\n    set<int> rt;\n    set<int>::iterator ia, ib;\n\n    ++e;\n    rt = term ( );\n\n    return\n    set_difference ( U, rt );\n  }\n\n  return ( lis[ *( e++ ) - 'A' ] );\n}\n\nstatic set<int>\nexpr (\n  void\n  )\n{\n  set<int> res;\n\n  res = term ( );\n\n  for ( ; ; )\n  {\n    char ope;\n    set<int> rt;\n\n    if ( *e == ')' || *e == '\\0' ) break ;\n\n    ope = *( e++ );\n    rt = term ( );\n    switch ( ope )\n    {\n      case 'i':\n        res = set_intersection ( res, rt );\n        break ;\n      case 'u':\n        res = set_union ( res, rt );\n        break ;\n      case 'd':\n        res = set_difference ( res, rt );\n        break ;\n      case 's':\n        res = set_union ( set_difference ( res, rt )\n                        , set_difference ( rt, res ) );\n        break ;\n    }\n  }\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    set<int> res;\n    string s;\n\n    U.clear ( );\n    for ( i = 0; i < M; ++i )\n    {\n      lis[ i ].clear ( );\n    }\n\n    for ( ; ; )\n    {\n      char ch;\n      int n;\n\n      if ( !( cin >> ch >> n ) ) goto ESC;\n      if ( ch == 'R' ) break ;\n\n      while ( n-- )\n      {\n        int d;\n\n        cin >> d;\n        U.insert ( d );\n        lis[ ch - 'A' ].insert ( d );\n      }\n    }\n\n    cin >> s;\n    e = s.c_str ( );\n    res = expr ( );\n    if ( res.empty ( ) )\n    {\n      puts ( \"NULL\" );\n    }\n    else\n    {\n      for ( set<int>::iterator it = res.begin ( )\n          ; it != res.end ( ); ++it )\n      {\n        if ( it != res.begin ( ) )  putchar ( ' ' );\n        printf ( \"%d\", *it );\n      }\n      puts ( \"\" );\n    }\n  }\n\nESC: ;\n  return ( 0 );\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\nvector<int> shiki();\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=shiki();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\n\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t//\tif(cnt>20) break;\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<sstream>\n#include<iterator>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define osi ostream_iterator<int>\n#define all(c) c.begin(),c.end()\nusing namespace std;\ntypedef set<int> si;\nsi sCalc(char o,si l,si r){\n\tint t;si a;stringstream ss;\n\tswitch(o){\n\tcase 'u':\n\t\tset_union(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'i':\n\t\tset_intersection(all(l),all(r),osi(ss,\" \"));break;\n\tcase 'd':\n\t\tset_difference(all(l),all(r),osi(ss,\" \"));break;\n\tcase 's':\n\t\tset_symmetric_difference(all(l),all(r),osi(ss,\" \"));break;\n\t}\n\twhile(ss>>t)a.insert(t);\n\treturn a;\n}\nsi st[26],u,ans; string expr;\nsi prs(int s,int t){\n\tint oi,p=0;char c;\n\tfor(oi=s;oi<t;oi++){\n\t\tc=expr[oi];if(c=='(')p++;if(c==')')p--;\n\t\tif(p==0&&(c=='u'||c=='i'||c=='d'||c=='s'))break;\n\t}\n\tif(oi==t){\n\t\tif(expr[s]=='(')return prs(s+1,t-1);\n\t\tif(s+1==t)return st[expr[s]-'A'];\n\t\tif(expr[s]=='c')return sCalc('d',u,prs(s+1,t));\n\t}\n\treturn sCalc(expr[oi],prs(s,oi),prs(oi+1,t));\n}\nint main(){\n\tchar c; int k,t;\n\twhile(cin>>c>>k){\n\t\tif(c=='R'){\n\t\t\tcin>>expr;ans=prs(0,expr.size());\n\t\t\tfor(__typeof(ans.begin()) i=ans.begin();i!=ans.end();i++){\n\t\t\t\tif(i!=ans.begin())cout<<\" \";\n\t\t\t\tcout<<*i;\n\t\t\t}\n\t\t\tif(ans.empty())cout<<\"NULL\";cout<<endl;\n\t\t\trep(i,26)st[i].clear();u.clear();\n\t\t}else rep(i,k)cin>>t,st[c-'A'].insert(t),u.insert(t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nmap<char, set<int>>mp;\nset<int>calc(const set<int>&l, const set<int>&r,char c) {\n\tset<int>ans;\n\tif (c == 'u') {\n\t\tans = l;\n\t\tfor (auto n : r)ans.emplace(n);\n\t}\n\telse if (c == 'i') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n)!=r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 'd') {\n\t\tfor (auto&&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\t\t}\n\t}\n\telse if (c == 's') {\n\t\tfor (auto &&n : l) {\n\t\t\tif (r.find(n) == r.end())ans.emplace(n);\n\n\t\t}\n\t\tfor (auto&&n : r) {\n\t\t\tif (l.find(n) == l.end())ans.emplace(n);\n\t\t}\n\t}\n\treturn ans;\n}\nstring st; int a;\nset<int>expr();\nset<int>exp() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tauto n= expr();\n\t\treturn n;\n\t}else if (st[a] == 'c') {\n\t\ta++;\n\t\tchar c(st[a]);\n\t\tset<int>n(mp[c]);\n\t\tn = calc(mp['U'], n, 'd');\n\t\ta++;\n\t\treturn n;\n\t}\n\telse {\n\t\tchar c(st[a]);\n\t\tset<int>n(mp[c]);\n\t\ta++;\n\t\treturn n;\n\t}\n}\nset<int>expr() {\n\tset<int>l(exp());\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn l;\n\t\t}\n\t\telse {\n\t\t\tchar op = st[a];\n\t\t\ta++;\n\t\t\tset<int>r(exp());\n\t\t\tl = calc(l, r, op);\n\t\t}\n\t}\n}\nint main() {\n\tchar c; int n;\n\twhile (cin >> c >> n) {\n\t\tif (c == 'R') {\n\t\t\tset<int>v;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto n : m.second) {\n\t\t\t\t\tv.insert(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp['U'] = v;\n\t\t\tcin >> st;\n\t\t\tauto ans = expr();\n\t\t\tfor (auto aa : ans) {\n\t\t\t\tcout << aa;\n\t\t\t\tif (*prev(ans.end()) == aa)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t\tif (ans.empty())cout << endl;\n\t\t\tmp.clear();\n\t\t\ta = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tmp[c].emplace(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\tcnt++;\n\t\tif(cnt>14) break;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename InputIterator> std::string join(InputIterator first, InputIterator last, const std::string &sep) {\n  if (first == last) return \"\";\n  std::stringstream ss;\n  ss << *(first++);\n  for_each(first, last, [&](auto &x) { ss << sep << x; });\n  return ss.str();\n}\n\nset<int> bin(set<int> l, set<int> r, char op) {\n  set<int> val;\n  if (op == 'u') set_union(all(l), all(r), inserter(val, val.begin()));\n  if (op == 'i') set_intersection(all(l), all(r), inserter(val, val.begin()));\n  if (op == 'd') set_difference(all(l), all(r), inserter(val, val.begin()));\n  if (op == 's') val = bin(bin(l, r, 'd'), bin(r, l, 'd'), 'u');\n  return val;\n}\n\nusing state = string::const_iterator;\n\nset<int> expr(state &);\n\nmap<char, set<int>> m;\nset<int> u;\n\nset<int> elem(state &s) {\n  char c = *s;\n  s++;\n  return m[c];\n}\n\nset<int> factor(state &s) {\n  if (*s == '(') {\n    s++;\n    set<int> val = expr(s);\n    s++;\n    return val;\n  }\n  return elem(s);\n}\n\nset<int> term(state &s) {\n  int k = 0;\n  while (*s == 'c') s++, k++;\n  if (odd(k)) {\n    set<int> val = factor(s);\n    set<int> cval;\n    for (auto x : u) {\n      if (!val.count(x)) cval.insert(x);\n    }\n    return cval;\n  }\n  return factor(s);\n}\n\nset<int> expr(state &s) {\n  set<int> val = term(s);\n  while (1) {\n    char c = *s;\n    if (string(\"uidsc\").find(c) != string::npos) {\n      s++;\n      val = bin(val, term(s), c);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nmain {\n  while (1) {\n    m.clear();\n    u.clear();\n    char c;\n    int k;\n    while (1) {\n      if (!(cin >> c >> k)) return 0;\n      if (!k) break;\n      while (k--) {\n        int x;\n        cin >> x;\n        m[c].insert(x);\n        u.insert(x);\n      }\n    }\n    string s;\n    cin >> s;\n    state p = s.begin();\n    set<int> w = expr(p);\n    cout << join(all(w), \" \") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <string>\n#include <stack>\nusing namespace std;\n\ntemplate <class Set>\nvoid print_set(Set& setA)\n{\n  typename Set::iterator it;\n  int n = 0;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    n++;\n    if (n != setA.size()) printf(\"%d \", *it);\n    else printf(\"%d\", *it);\n  }\n  printf(\"\\n\");\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet union_set(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.insert(*it);\n  }\n  return res;\n}\n\n// ?????????????¨????\ntemplate <class Set>\nSet intersection_set(Set& setA, Set& setB)\n{\n  Set res;\n  typename Set::iterator it;\n\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    if (setA.find(*it) != setA.end())\n    {\n      res.insert(*it);\n    }\n  }\n  return res;\n}\n\n\n// ?£???????????¨????\ntemplate <class Set>\nSet complement(Set& setA, Set& U)\n{\n  Set res(U);\n  typename Set::iterator it;\n  for (it = setA.begin(); it != setA.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A-B\ntemplate <class Set>\nSet difference(Set& setA, Set& setB)\n{\n  Set res(setA);\n  typename Set::iterator it;\n  for (it = setB.begin(); it != setB.end(); ++it)\n  {\n    res.erase(*it);\n  }\n  return res;\n}\n\n// A . B\ntemplate <class Set>\nSet symmetric_difference(Set& setA, Set& setB)\n{\n  Set s1 = difference(setA, setB);\n  Set s2 = difference(setB, setA);\n  return union_set(s1, s2);\n}\n\nstring rev_polish_notation(string& exp)\n{\n  stack<char> stk;\n  string rexp;\n  string::iterator it;\n\n  for (it = exp.begin(); it != exp.end(); ++it)\n  {\n    if (*it == '(')\n    {\n      stk.push(*it);\n    }\n    else if (*it == ')')\n    {\n      while (stk.top() != '(')\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.pop();                // top???'('???????????????\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      while ((!stk.empty()) && (stk.top() != '('))\n      {\n        char tkn = stk.top();\n        rexp = rexp + tkn;\n        stk.pop();\n      }\n      stk.push(*it);\n    }\n    else if (*it == 'c')\n    {\n      stk.push(*it);\n    }\n    else if ((*it == 'A') || (*it == 'B') || (*it == 'C') || (*it == 'D') || (*it == 'E'))\n    {\n      rexp = rexp + (*it);\n    }\n  }\n\n  while (!stk.empty())\n  {\n    char tkn = stk.top();\n    rexp = rexp + tkn;\n    stk.pop();\n  }\n\n  return rexp;\n}\n\n\ntemplate <class Set>\nSet set_operation(string& exp, Set& A, Set& B, Set& C, Set& D, Set& E, Set& U)\n{\n  Set S;\n  string rexp = rev_polish_notation(exp); // ???????????????????¨????\n  stack<Set> stk;\n\n  string::iterator it;\n  for (it = rexp.begin(); it != rexp.end(); ++it)\n  {\n    if (*it == 'A') { stk.push(A); }\n    else if (*it == 'B') { stk.push(B); }\n    else if (*it == 'C') { stk.push(C); }\n    else if (*it == 'D') { stk.push(D); }\n    else if (*it == 'E') { stk.push(E); }\n    else if (*it == 'c')\n    {\n      Set s = stk.top();\n      stk.pop();\n      stk.push(complement(s, U));\n    }\n    else if ((*it == 'u') || (*it == 'i') || (*it == 'd') || (*it == 's'))\n    {\n      Set s1 = stk.top();\n      stk.pop();\n      Set s2 = stk.top();\n      stk.pop();\n      Set ans;\n\n      switch (*it)\n      {\n      case 'u': stk.push(union_set(s1, s2)); break;\n      case 'i': stk.push(intersection_set(s1, s2)); break;\n      case 'd': stk.push(difference(s2, s1)); break; // ????????????????????¨???\n      case 's': stk.push(symmetric_difference(s1, s2)); break;\n      }\n    }\n  }\n  return stk.top();\n}\n\n\nint main() {\n  set<int> A, B, C, D, E, U;\n  char name;\n  int num;\n  int e;\n  string exp;\n\n  while (cin >> name >> num)\n  {\n    switch (name)\n    {\n    case 'A':\n      for (int i=0;i<num;i++) { cin >> e; A.insert(e); U.insert(e); }\n      break;\n    case 'B':\n      for (int i=0;i<num;i++) { cin >> e; B.insert(e); U.insert(e); }\n      break;\n    case 'C':\n      for (int i=0;i<num;i++) { cin >> e; C.insert(e); U.insert(e); }\n      break;\n    case 'D':\n      for (int i=0;i<num;i++) { cin >> e; D.insert(e); U.insert(e); }\n      break;\n    case 'E':\n      for (int i=0;i<num;i++) { cin >> e; E.insert(e); U.insert(e); }\n      break;\n    case 'R':\n      cin.ignore();             // ??????????????????????£???°???\n      getline(cin, exp);\n\n      set<int> res = set_operation(exp, A, B, C, D, E, U);\n      print_set(res);\n\n      // ??????????????????????¶???????\n      A.clear();\n      B.clear();\n      C.clear();\n      D.clear();\n      E.clear();\n      U.clear();\n      break;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>20) break;\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>30) exit(0);\n\t\t\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\nint cnt=0;\nsigned main(){\nchar c;\n\tint d;\n\twhile(cin>>c>>d){\n\t\t\n\t\tcnt++;\n\t\tif(cnt>20) break;\n\t\t\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[1000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 2)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tif(check[A[i]] == false){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tint check[101];\n\n\tfor(int i = 1; i <= 100; i++)check[i] = 0;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]]++;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tcheck[B[i]]++;\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i] == 1)ret.push_back(i);\n\t}\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tcheck[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tif(check[U[i]] == false){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tbool check[101];\n\tfor(int i = 1; i <= 100; i++)check[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tcheck[V[i][k]] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(check[i])U.push_back(i);\n\t}\n}\n\n\nint debug = 0;\n\nvector<int> recursive(int left,int right){\n\n\tdebug++;\n\tif(debug >= 10){\n\t\tvector<int> ret;\n\t\tret.push_back(889);\n\t\treturn ret;\n\t}\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t}else{\n\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n    if(S[p]-'A'>5)exit(0);\n    if(S[p]-'A'<0)exit(0);\n    s=C(uni,st[S[p]-'A']),p++;\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n   s=C(uni,uni);\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  //if(!ans.size())cout<<\"NULL\"<<endl;\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c'){\n    while(S[p]=='c')p++;\n   s=C(uni,uni]);\n  }\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nvector<int> U;\nvector<int> V[5];\nint loc[128],N,length;\nchar buf[2],equation[2000];\n\nvector<int> calc_union(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tret.push_back(A[i]);\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tret.push_back(B[i]);\n\t}\n\n\tsort(ret.begin(),ret.end());\n\n\tret.erase(unique(ret.begin(),ret.end()),ret.end());\n\n\treturn ret;\n}\n\nvector<int> calc_intersection(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tauto at = MAP.find(B[i]);\n\t\tif(at != MAP.end()){\n\t\t\tret.push_back(B[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tMAP[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tauto at = MAP.find(A[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> calc_sym_diff(vector<int> A,vector<int> B){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tMAP[B[i]] = true;\n\t}\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tauto at = MAP.find(A[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(A[i]);\n\t\t}\n\t}\n\n\tMAP.clear();\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < B.size(); i++){\n\t\tauto at = MAP.find(B[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(B[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvector<int> calc_complement(vector<int> A){\n\n\tvector<int> ret;\n\n\tmap<int,bool> MAP;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tMAP[A[i]] = true;\n\t}\n\n\tfor(int i = 0; i < U.size(); i++){\n\t\tauto at = MAP.find(U[i]);\n\t\tif(at == MAP.end()){\n\t\t\tret.push_back(U[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid makeU(){\n\n\tU.clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tU.push_back(V[i][k]);\n\t\t}\n\t}\n\tsort(U.begin(),U.end());\n\tU.erase(unique(U.begin(),U.end()),U.end());\n}\n\n\nvector<int> recursive(int left,int right){\n\n\t/*printf(\"\\n\\nleft:%d right:%d\\n\",left,right);\n\tfor(int i = left; i <= right; i++){\n\t\tprintf(\"%c\",equation[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tvector<int> calc_left,calc_right;\n\n\tint index = left,depth,close_pos;\n\tchar pre = '@';\n\n\twhile(index <= right){\n\n\t\tswitch(equation[index]){\n\t\tcase '(':\n\t\t\t//printf(\"???????????????\\n\");\n\t\t\tdepth = 0;\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(equation[i] == '(')depth++;\n\t\t\t\telse if(equation[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre == '@'){\n\t\t\t\t//printf(\"left??±??????()\\n\");\n\t\t\t\tcalc_left = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t\t}*/\n\t\t\t}else{\n\n\t\t\t\t//printf(\"right??±??????()\\n\");\n\t\t\t\tcalc_right = recursive(index+1,close_pos-1);\n\t\t\t\t/*for(int k = 0; k < calc_right.size(); k++){\n\t\t\t\t\tprintf(\"calc_right[%d]:%d\\n\",k,calc_right[k]);\n\t\t\t\t}*/\n\n\t\t\t\tswitch(pre){\n\t\t\t\tcase 'u':\n\t\t\t\t\tcalc_left = calc_union(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tcalc_left = calc_intersection(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tcalc_left = calc_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcalc_left = calc_sym_diff(calc_left,calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tcalc_left = calc_complement(calc_right);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = ')';\n\t\t\tindex = close_pos+1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\t//printf(\"?????????:%c\\n\",equation[index]);\n\t\t\tpre = equation[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\tdefault: //A-E\n\t\t\t/*printf(\"??????:%c\\n\",equation[index]);\n\t\t\tfor(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"??? calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tswitch(pre){\n\t\t\tcase '@':\n\t\t\t\tcalc_left = V[loc[equation[index]-'A']];\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tcalc_left = calc_union(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\t//printf(\"%d??¨intersect\\n\",loc[equation[index]-'A']);\n\t\t\t\tcalc_left = calc_intersection(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tcalc_left = calc_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tcalc_left = calc_sym_diff(calc_left,V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcalc_left = calc_complement(V[loc[equation[index]-'A']]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*for(int k = 0; k < calc_left.size(); k++){\n\t\t\t\tprintf(\"calc_left[%d]:%d\\n\",k,calc_left[k]);\n\t\t\t}*/\n\t\t\tpre = 'X';\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn calc_left;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 5; i++)V[i].clear();\n\n\tint index = 0;\n\n\tint num,tmp;\n\tscanf(\"%d\",&num);\n\n\tloc[buf[0]-'A'] = index;\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tV[index].push_back(tmp);\n\t}\n\tindex++;\n\n\twhile(true){\n\t\tscanf(\"%s %d\",buf,&num);\n\t\tif(buf[0] == 'R' && num == 0)break;\n\n\t\tloc[buf[0]-'A'] = index;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tV[index].push_back(tmp);\n\t\t}\n\t\tindex++;\n\t}\n\n\tN = index;\n\n\tmakeU();\n\n\tscanf(\"%s\",equation);\n\n\t/*for(int i = 0; i < U.size(); i++){\n\t\tprintf(\"U[%d]:%d\\n\",i,U[i]);\n\t}*/\n\n\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\tvector<int> ans = recursive(0,length-1);\n\n\tif(ans.size() == 0){\n\t\tprintf(\"NULL\\n\");\n\t}else{\n\t\tprintf(\"%d\",ans[0]);\n\t\tfor(int i = 1; i < ans.size(); i++){\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<string>\nusing namespace std;\n\nset<int> alp[5],U;\nmap<char,int> m;\nset<int>::iterator ite;\n\nset<int> parse(string s){\n  int p = 0;\n  int l = s.size();\n  set<int> a,b,res;\n\n  if(!s.size())return res;\n  for(int i=l-1;i>=0;i--){\n    if(s[i]==')')p++;\n    if(s[i]=='(')p--;\n    if(!p){\n      if(s[i] == 'u'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'i'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)!=b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 'd'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\treturn res;\n      }\n      if(s[i] == 's'){\n\ta = parse(s.substr(0,i));\n\tb = parse(s.substr(i+1,l-i-1));\n\tfor(ite = a.begin();ite!=a.end();ite++)\n\t  if(b.find(*ite)==b.end())res.insert(*ite);\n\tfor(ite = b.begin();ite!=b.end();ite++)\n\t  if(a.find(*ite)==a.end())res.insert(*ite);\n\treturn res;\n      }\n    }\n  }\n\n  if(s[0] == 'c'){\n    a = parse(s.substr(1,l-1));\n    for(ite = U.begin();ite!=U.end();ite++)\n      if(a.find(*ite)==a.end())res.insert(*ite);\n    return res;\n  }\n  if(s[0] == '(' && s[l-1] == ')')return parse(s.substr(1,l-2));\n\n  return alp[m[s[0]]];\n}\n\nint main(){\n  char c;\n  int n;\n  string str;\n\n  while(cin >> c >> n){\n    m.clear();\n    for(int i=0;i<5;i++)alp[i].clear();\n    while(c != 'R'){\n      int tmp;\n\n      m[c] = m.size();\n      for(int i=0;i<n;i++){\n\tcin >> tmp;\n\talp[m[c]].insert(tmp);\n\tU.insert(tmp);\n      }\n      cin >> c >> n;\n    }\n    cin >> str;\n    \n    set<int> ans = parse(str);\n    if(ans.empty())cout << \"NULL\\n\";\n    else{\n      set<int>::iterator ansend = --(ans.end());\n      for(ite = ans.begin();ite!=ansend;ite++)cout << *ite << \" \";\n      cout << *ansend << endl;\n    }\n  }\n}     "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  ll a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      if(ch=='R')break;\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    mp['U']=U;\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> ele;\n\n    Parse(string s, map<char, set<int>> ele) :\n        ele(ele) {\n        it = s.begin();\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = exp();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = ele[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> exp()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(set<int> a)\n    {\n        set<int> res;\n        for(auto x : ele['U']){\n            if(a.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n    \n    set<int> difference(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) == 0){\n                res.insert(x);\n            }   \n        }\n        return res;\n    }\n\n    set<int> intersection(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a){\n            if(b.count(x) > 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> sym_difference(set<int> a, set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(set<int> a, set<int> b)\n    {\n        set<int> res;\n        for(auto x : a) res.insert(x);\n        for(auto x : b) res.insert(x);\n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> ele;\n        set<int> U;\n        \n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            ele[ch] = st;\n        }while(cin >> ch >> N);\n\n        ele['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, ele);\n        set<int> res = parse.exp();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto x : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\ntypedef map<char, vector<int> > M;\n\nvoid show(vector<int> A, vector<int> B, char order, vector<int> result)\n{\n    cout << \"{ \";\n    for (int i = 0; i < A.size(); i += 1) {\n        cout << A[i] << \" \";\n    }\n    cout << \"} \" << order << \" { \";\n    for (int i = 0; i < B.size(); i += 1) {\n        cout << B[i] << \" \";\n    }\n    cout << \"} = { \";\n    for (int i = 0; i < result.size(); i += 1) {\n        cout << result[i] << \" \";\n    } \n    cout << \"}\" << endl;\n    return;\n}\n\nvector<int> calc(vector<int> A, vector<int> B, char order) {\n    vector<int> result(A.size()+B.size());\n    vector<int>::iterator it;\n\n    if (order == 'u') {\n        it = set_union(A.begin(), A.end(), B.begin(), B.end(), result.begin());\n    } else if (order == 'i') {\n        it = set_intersection(A.begin(), A.end(), B.begin(), B.end(), result.begin());\n    } else if (order == 'd') {\n        it = set_difference(A.begin(), A.end(), B.begin(), B.end(), result.begin());\n    } else if (order == 's') {\n        it = set_symmetric_difference(A.begin(), A.end(), B.begin(), B.end(), result.begin());\n    } else if (order == 'c') {\n        it = set_difference(A.begin(), A.end(), B.begin(), B.end(), result.begin());\n    }\n    result.erase(it,result.end());\n    //show(A, B, order, result);\n\n    return result;\n}\n\nint p_skip(string str, int p) {\n    int cnt = 1;\n    while(p < str.size()) {\n        if (str[p] == '(') {\n            ++cnt;\n        } else if (str[p] == ')') {\n            --cnt;\n        }\n        ++p;\n        if (cnt == 0) {\n            break;\n        }\n    }\n    return p;\n}\n\nvector<int> parse(string str, M dataset, int start) {\n    int p = start;\n    vector<int> A, B;\n    if (str[p] == '(') {\n        p += 1;\n        A = parse(str, dataset, p);\n        p = p_skip(str, p);\n    } else if (str[p] == 'c') {\n        p += 1;\n        if(str[p] == '(') {\n            p += 1;\n            A = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else {\n            A = dataset[str[p]];\n            p += 1;\n        }\n        A = calc(dataset['U'], A, 'c');\n    } else {\n        A = dataset[str[p]];\n        p += 1;\n    }\n\n    while(p < str.size()) {\n        if (((string)(\"uids\")).find(str[p]) == string::npos) {\n            break;\n        }\n\n        char order = str[p];\n        ++p;\n\n        if (str[p] == '(') {\n            p += 1;\n            B = parse(str, dataset, p);\n            p = p_skip(str, p);\n        } else if (str[p] == 'c') {\n            p += 1;\n            if(str[p] == '(') {\n                p += 1;\n                B = parse(str, dataset, p);\n                p = p_skip(str, p);\n            } else {\n                B = dataset[str[p]];\n                p += 1;\n            }\n            B = calc(dataset['U'], B, 'c');\n        } else {\n            B = dataset[str[p]];\n            p += 1;\n        }\n\n        A = calc(A, B, order);\n    }\n\n    return A;\n}\n\nvoid solve(string str, M dataset) {\n    vector<int> result = parse(str, dataset, 0);\n    if (result.empty()) {\n        cout << \"NULL\" << endl;\n        return;\n    }\n\n    int cnt = 0;\n    for (vector<int>::iterator it = result.begin(); it != result.end(); ++it) {\n        if (cnt == (int)(result.size())-1) {\n            cout << *it << endl;\n        } else {\n            cout << *it << \" \";\n            cnt += 1;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    char s;\n    int t;\n    string str;\n    M dataset;\n\n    while(!cin.eof()) {\n        cin >> s >> t;\n        if(s == 'R'){\n            cin >> str;\n            //cout << \"str: \" << str << endl;\n            solve(str, dataset);\n            dataset.clear();\n            continue;\n        }\n        int u;\n        for (int i = 0; i < t; i += 1) {\n            cin >> u;\n            dataset[s].push_back(u);\n        }\n        sort(dataset[s].begin(), dataset[s].end());\n        dataset['U'] = calc(dataset['U'], dataset[s], 'u');\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\nusing namespace std;\n\nenum{\n  BINARY_OPERATOR = 0,\n  UNARY_OPERATOR  = 1,\n  VALUE           = 2\n};\n\nstruct Tree{\n  int type;\n\n  // Identifier, Value or Operator\n  string s;\n\n  struct Tree *left;\n  struct Tree *right;\n\n  Tree(int t, const string &v, Tree *l = NULL, Tree *r = NULL)\n    : type(t), s(v), left(l), right(r) {}\n\n  Tree(int t, char v, Tree *l = NULL, Tree *r = NULL)\n    : type(t), left(l), right(r) {\n    stringstream ss; ss << v;\n    s = ss.str();\n  }\n\n  ~Tree(){\n    delete left; delete right;\n  }\n\n  void debug(){\n    cout << \"(\";\n    switch(type){\n    case BINARY_OPERATOR:\n      left->debug();\n      cout << s;\n      right->debug();\n      break;\n    case UNARY_OPERATOR:\n      cout << s;\n      left->debug();\n      break;\n    case VALUE:\n      cout << s;\n      break;\n    }\n    cout << \")\";\n  }\n};\n\nstruct Parser{\n  const string bop1;\n  const string bop2;\n  const string uop;\n\n  Parser(const string &b1 = \"+-\",\n         const string &b2 = \"*/\",\n         const string &u = \"-\")\n    : bop1(b1), bop2(b2), uop(u) {}\n\n  typedef pair<Tree *, const char *> P;\n\n  P parseExpr(const char *p) const{\n    P r = parseTerm(p);\n    while( *r.second != '\\0' && bop1.find(*r.second) != string::npos ){\n      char op   = *r.second;\n      Tree *tmp = r.first;\n      r = parseTerm(r.second + 1);\n      r.first = new Tree(BINARY_OPERATOR, op, tmp, r.first);\n    }\n    return r;\n  }\n\n  P parseTerm(const char *p) const{\n    P r = parseFact(p);\n    while( *r.second != '\\0' && bop2.find(*r.second) != string::npos ){\n      char op   = *r.second;\n      Tree *tmp = r.first;\n      r = parseFact(r.second + 1);\n      r.first = new Tree(BINARY_OPERATOR, op, tmp, r.first);\n    }\n    return r;\n  }\n\n  P parseFact(const char *p) const{\n    if(uop.find(*p) != string::npos){\n      P r = parseFact(p + 1);\n      return P(new Tree(UNARY_OPERATOR, *p, r.first), r.second);\n    }else if(*p == '('){\n      P r = parseExpr(p + 1);\n      if(*r.second != ')') throw make_pair(\"fact1\", p);\n      return P(r.first, r.second + 1);\n    }else{\n      // identifier or value\n      stringstream ss;\n      while(*p != '\\0' &&\n            bop1.find(*p) == string::npos &&\n            bop2.find(*p) == string::npos &&\n            uop.find(*p)  == string::npos &&\n            *p != '(' && *p != ')'){\n        ss << *p++;\n      }\n      if(ss.str().size() == 0) throw make_pair(\"fact2\", p);\n      return P(new Tree(VALUE, ss.str()), p);\n    }\n  }\n\n  Tree *parse(const string &str) const{\n    return parseExpr(str.c_str()).first;\n  }\n};\n\nvoid print(set<int> s){\n  bool f = false;\n  FOR(it, s){\n    if(f) cout << \" \";\n    else f = true;\n    cout << *it;\n  }\n  cout << endl;\n}\n\ntemplate<typename T>\nstruct Evaluater{\n  typedef T result;\n  map<string, set<int> > m;\n  set<int> u;\n\n  Evaluater(map<string, set<int> > _m) : m(_m){\n    FOR(it, m){\n      FOR(it2, it->second){\n        u.insert(*it2);\n      }\n    }\n  }\n\n  // Binary Operator\n  T operator()(const T &lhs, char op, const T &rhs) const{\n    set<int> ret;\n    switch(op){\n    case 'u':\n      ret = lhs;\n      FOR(it, rhs) ret.insert(*it);\n      break;\n    case 'i':\n      FOR(it, lhs){\n        if(rhs.count(*it))\n          ret.insert(*it);\n      }\n      break;\n    case 'd':\n      FOR(it, lhs){\n        if(rhs.count(*it) == 0)\n          ret.insert(*it);\n      }\n      break;\n    case 's':\n      FOR(it, lhs){\n        if(rhs.count(*it) == 0)\n          ret.insert(*it);\n      }\n      FOR(it, rhs){\n        if(lhs.count(*it) == 0)\n          ret.insert(*it);\n      }\n      break;\n    default:\n      throw \"Unknown Binary Operator\";\n    }\n\n    return ret;\n  }\n\n  // Unary Operator\n  T operator()(char op, const T &rhs) const{\n    set<int> ret = u;\n    FOR(it, rhs)\n      ret.erase(*it);\n    return ret;\n  }\n\n  // Value\n  T operator()(const string &str) const{\n    return m.at(str);\n  }\n};\n\ntemplate<typename E>\ntypename E::result eval(Tree *p, const E &e){\n  switch(p->type){\n  case BINARY_OPERATOR:\n    return e(eval(p->left, e), p->s[0], eval(p->right, e));\n  case UNARY_OPERATOR:\n    return e(p->s[0], eval(p->left, e));\n  case VALUE:\n    return e(p->s);\n  default:\n    throw \"Evaluater error\";\n  }\n}\n\n\nint main(){\n  Parser ps(\"uids\", \"\", \"c\");\n  string buff;\n  int n;\n\n  while(cin >> buff >> n){\n    map<string, set<int> > m;\n\n    do{\n      int v;\n      REP(j,n){\n        cin >> v; m[buff].insert(v);\n      }\n      cin >> buff >> n;\n    }while(buff != \"R\");\n\n    cin >> buff;\n\n    Tree *t = ps.parse(buff);\n    set<int> ans = eval(t, Evaluater<set<int> >(m));\n    print(ans);\n\n    delete t;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  if(!ans.size())cout<<\"NULL\"<<endl;\n  else for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    p=0;\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();if(and.size()==0)exit(0);\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str.size()==2){\n\t\treturn Complement(sets[str[1]],sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nset<int> U(set<int> A,set<int> B){\n  set<int> S=A;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end())S.insert(*I),I++;\n  return S;\n}\n\nset<int> M(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=A.begin();\n  while(I!=A.end()){\n    if(!B.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nset<int> T(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end()){\n    if(A.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nstring s;\nset<int> V[6];\n\nset<int> dfs(int l,int r){\n  set<int> A,B;\n  bool f=0,bf=0;\n  char cmd=0;\n  for(int j=l;j<r;j++){\n    if(s[j]=='('){\n      int c=1,st=j+1;\n      j++;\n      for(;c;j++){\n\tif(s[j]=='(')c++;\n\tif(s[j]==')')c--;\n      }\n      j--;\n      B=dfs(st,j);\n      bf=1;\n    }\n    if('a'<s[j]&&s[j]<'z'){\n      if(s[j]=='c')f=1;\n      else cmd=s[j];\n    }\n    if('A'<=s[j]&&s[j]<='E'){\n      B=V[s[j]-'A'];\n      bf=1;\n    }\n    if(bf){\n      if(f){\n\tB=M(V[5],B);\n\tf=0;\n      }\n      if(cmd=='u')A=U(A,B);\n      if(cmd=='i')A=T(A,B);\n      if(cmd=='d')A=M(A,B);\n      if(cmd=='s')A=U(M(A,B),M(B,A));\n      if(cmd==0)A=B;\n      bf=0;cmd=0;\n    }\n  }\n  return A;\n}\n\nint main(){\n  char c;\n  int x;\n  while(1){\n   \n    for(int i=0;i<=5;i++)V[i].clear();\n    while(1){\n      if(cin>>c>>x==0)return 0;\n      if(c=='R')break;\n      for(int i=0,a;i<x;i++)cin>>a,V[c-'A'].insert(a),V[5].insert(a);\n    }\n    cin>>s;\n    set<int> res=dfs(0,s.size());\n    set<int>::iterator I=res.begin();\n    while(I!=res.end()){\n      if(I!=res.begin())cout<<\" \";\n      cout<<*I;\n      I++;\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint idx;\nstring str;\nset<int> u;\n\nset<int> calc_union(const set<int>& a, const set<int>& b) {\n\tset<int> res(a);\n\tset<int>::const_iterator it, en = b.end();\n\tfor(it = b.begin(); it != en; ++it)\n\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_intersection(const set<int>& a, const set<int>& b) {\n\tset<int> res;\n\tset<int>::const_iterator it, en = a.end(), en2 = b.end();\n\tfor(it = a.begin(); it != en; ++it)\n\t\tif(b.find(*it) != en2)\n\t\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_difference(const set<int>& a, const set<int>& b) {\n\tset<int> res;\n\tset<int>::const_iterator it, en = a.end(), en2 = b.end();\n\tfor(it = a.begin(); it != en; ++it)\n\t\tif(b.find(*it) == en2)\n\t\t\tres.insert(*it);\n\n\treturn res;\n}\n\nset<int> calc_symmetric_difference(const set<int>& a, const set<int>& b) {\n\treturn calc_union(calc_difference(a, b), calc_difference(b, a));\n}\n\nset<int> complement(const set<int>& a) {\n\treturn calc_difference(u, a);\n}\n\nset<int> s[128];\nset<int> (*func[128])(const set<int>&, const set<int>&);\n\nset<int> expr();\n\nset<int> fact() {\n\tif(str[idx] == '(') {\n\t\t++idx;\n\t\tconst set<int> res = expr();\n\t\t++idx;\n\t\treturn res;\n\t}\n\telse\n\t\treturn s[str[idx++]];\t\n}\n\nset<int> term() {\n\tif(str[idx] == 'c') {\n\t\t++idx;\n\t\treturn complement(fact());\n\t}\n\telse\n\t\treturn fact();\n}\n\nset<int> expr() {\n\tset<int> res = term();\n\twhile(str[idx] == 'u' || str[idx] == 'i' || str[idx] == 'd' || str[idx] == 's') {\n\t\tconst char tmp = str[idx++];\n\t\tres = func[tmp](res, term());\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfunc['u'] = calc_union;\n\tfunc['i'] = calc_intersection;\n\tfunc['d'] = calc_difference;\n\tfunc['s'] = calc_symmetric_difference;\n\n\twhile(true) {\n\t\tu.clear();\n\t\tfor(int i = 'A'; i <= 'E'; ++i)\n\t\t\ts[i].clear();\n\n\t\tchar c;\n\t\tint num;\n\t\twhile(true) {\n\t\t\tif(!(cin >> c >> num))\n\t\t\t\treturn EXIT_SUCCESS;\n\n\t\t\tif(c == 'R')\n\t\t\t\tbreak;\n\n\t\t\twhile(num--) {\n\t\t\t\tint element;\n\t\t\t\tcin >> element;\n\t\t\t\ts[c].insert(element);\n\t\t\t\tu.insert(element);\n\t\t\t}\n\t\t}\n\n\t\tidx = 0;\n\t\tcin >> str;\n\n\t\tconst set<int> ans = expr();\n\t\tset<int>::const_iterator it = ans.begin(), en = ans.end();\n\t\tif(ans.size()) {\n\t\t\twhile(true) {\n\t\t\t\tcout << (*it);\n\t\t\t\tif(++it == en) {\n\t\t\t\t\tcout << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  ll a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\nvec solve2();\nvec solve3();\nvec solve4();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=solve2();\n  while(pos<len){\n    char ch=s[pos];\n    if(ch==')')break;\n    pos++;\n    vec num=solve2();\n    if(ch=='u')res=Or(res,num);\n  }\n  return res;\n}\n\nvec solve2(){\n  vec res=solve3();\n  while(pos<len){\n    char ch=s[pos];\n    if(ch==')')break;\n    pos++;\n    vec num=solve3();\n    if(ch=='i')res=And(res,num);\n  }\n  return res;\n}\nvec solve3(){\n  vec res=solve4();\n  while(pos<len){\n    char ch=s[pos];\n    if(ch==')')break;\n    pos++;\n    vec num=solve4();\n    if(ch=='d')res=Dif(res,num);\n  }\n  return res;\n}\nvec solve4(){\n  vec res=getNum();\n  while(pos<len){\n    char ch=s[pos];\n    if(ch==')')break;\n    pos++;\n    vec num=getNum();\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      if(ch=='R')break;\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    mp['U']=U;\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n    if(ans.size()==0)cout<<\"NULL\"<<endl;\n    for(int i=0;i<(int)ans.size();i++){\n      if(i&&ans[i]==ans[i-1])continue;\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nmap<char,vector<int>> m;\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nvector<int> U(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_union(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> I(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_intersection(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> D(vector<int> a, vector<int> b){\n    vector<int> ret;\n    set_difference(all(a), all(b), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> S(vector<int> a, vector<int> b){\n    vector<int> x,y,ret;\n    set_difference(all(a), all(b), back_inserter(x));\n    set_difference(all(b), all(a), back_inserter(y));\n    set_union(all(x), all(y), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\nvector<int> C(vector<int> a){\n    vector<int> ret;\n    set_difference(all(m['U']), all(a), back_inserter(ret));\n    if(not ret.empty()) sort(all(ret));\n    return ret;\n}\n\ntypedef string::const_iterator State;\nvector<int> factor(State&);\nvector<int> expression(State&);\nvoid consume(State&,char);\n\nvector<int> factor(State &begin) {\n    bool c = false;\n    if(*begin == 'c'){\n        c = true;\n        begin++;\n    }\n\n    if (*begin == '(') {\n        consume(begin,'(');\n        //begin++; // '('????£???°??????\n        vector<int> ret = expression(begin);\n        consume(begin,')');\n        //begin++; // ')'????£???°??????\n        return (c ? C(ret) : ret);\n    } else {\n        begin++;\n        return (c ? C(m[*(begin - 1)]) : m[*(begin - 1)]);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nvector<int> expression(State &begin) {\n    vector<int> ret = factor(begin);\n\n    for (;;) {\n            sort(all(ret));\n        if (*begin == 'u') {\n            consume(begin,'u');\n            ret = U(ret, factor(begin));\n        }else if(*begin == 'i') {\n            consume(begin,'i');\n            ret = I(ret, factor(begin));\n        }else if(*begin == 'd') {\n            consume(begin,'d');\n            ret = D(ret, factor(begin));\n        }else if(*begin == 's') {\n            consume(begin,'s');\n            ret = S(ret, factor(begin));\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint main(){\n    while(true){\n        m.clear();\n        char c;\n        int n;\n        bool f = false;\n        while(cin >> c >> n){\n            if(c == 'R' && n == 0) break;\n            f = true;\n            int a;\n            rep(i,n){\n                cin >> a;\n                m['U'].emplace_back(a);\n                m[c].emplace_back(a);\n            }\n        }\n        compress(m['U']);\n\n        if(not f) break;\n\n        cin.ignore();\n        string s;\n        getline(cin,s);\n        State tmp = s.begin();\n        vector<int> ans = expression(tmp);\n        assert(tmp == s.end());\n        rep(i,ans.size()){\n            cout << ans[i] << (i == ans.size() - 1 ? '\\n' : ' ');\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);exit(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nset<int> U(set<int> A,set<int> B){\n  set<int> S=A;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end())S.insert(*I),I++;\n  return S;\n}\n\nset<int> M(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=A.begin();\n  while(I!=A.end()){\n    if(!B.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nset<int> T(set<int> A,set<int> B){\n  set<int> S;\n  set<int>::iterator I=B.begin();\n  while(I!=B.end()){\n    if(A.count(*I))S.insert(*I);\n    I++;\n  }\n  return S;\n}\n\nstring s;\nset<int> V[6];\n\nset<int> dfs(int l,int r){\n  set<int> A,B;\n  bool f=0,bf=0;\n  char cmd=0;\n  for(int j=l;j<r;j++){\n\n    if(s[j]=='('){\n      int c=1,st=j+1;\n      j++;\n      for(;c;j++){\n\tif(s[j]=='(')c++;\n\tif(s[j]==')')c--;\n      }\n      j--;\n      B=dfs(st,j);\n      bf=1;\n    }\n    \n    if('a'<s[j]&&s[j]<'z'){\n      if(s[j]=='c')f=1;\n      else cmd=s[j];\n    }\n    \n    if('A'<=s[j]&&s[j]<'Z'){\n      int nid=s[j]-'A';\n      if(s[j]=='U')nid=5;\n      B=V[nid];\n      bf=1;\n    }\n\n    if(bf){\n      if(f){\n\tB=M(V[5],B);\n\tf=0;\n      }\n      if(cmd=='u')A=U(A,B);\n      if(cmd=='i')A=T(A,B);\n      if(cmd=='d')A=M(A,B);\n      if(cmd=='s')A=U(M(A,B),M(B,A));\n      if(cmd==0)A=B;\n      bf=0;cmd=0;\n    }\n  }\n  return A;\n}\n\nint main(){\n  while(1){\n    for(int i=0;i<=5;i++)V[i].clear();\n    while(1){\n      char c;\n      int x;\n      if(cin>>c>>x==0)return 0;\n      if(c=='R')break;\n      for(int i=0,a;i<x;i++)cin>>a,V[c-'A'].insert(a),V[5].insert(a);\n    }\n\n    cin>>s;\n    set<int> res=dfs(0,s.size());\n    set<int>::iterator I=res.begin();\n    while(I!=res.end()){\n      if(I!=res.begin())cout<<\" \";\n      cout<<*I;\n      I++;\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nmap<char, vector<int> > sets;\nvector<int> calculate(char ope, const vector<int>& left, const vector<int>& right)\n{\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nvector<int> parse(const string& e)\n{\n\tint p = e.size() - 1;\n\tfor (int par = 0; p >= 0; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < 0)\n\t{\n\t\tif (e[0] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(e.substr(1)));\n\t\telse if (e[0] == '(')\n\t\t\treturn parse(e.substr(1, e.size() - 2));\n\t\telse\n\t\t\treturn sets[e[0]];\n\t}\n\n\treturn calculate(e[p], parse(e.substr(0, p)), parse(e.substr(p + 1, e.size() - (p + 1))));\n}\nstring e;\nvector<int> parse(int a, int b)\n{\n\tint p = b;\n\tfor (int par = 0; p >= a; --p)\n\t{\n\t\tif (e[p] == '(')\n\t\t\t++par;\n\t\telse if (e[p] == ')')\n\t\t\t--par;\n\t\telse if (par == 0 && strchr(\"uids\", e[p]))\n\t\t\tbreak;\n\t}\n\tif (p < a)\n\t{\n\t\tif (e[a] == 'c')\n\t\t\treturn calculate('s', sets['U'], parse(a + 1, b));\n\t\telse if (e[a] == '(')\n\t\t\treturn parse(a + 1, b - 1);\n\t\telse\n\t\t\treturn sets[e[a]];\n\t}\n\n\treturn calculate(e[p], parse(a, p - 1), parse(p + 1, b));\n}\nint main()\n{\n\twhile (!cin.eof())\n\t{\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tcin >> a >> n;\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tcin >> e;\n\t\tvector<int> res = parse(0, e.size() - 1);\n\t\tif (res.empty())\n\t\t\tcout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tcout << res[i];\n\t\t\t\tif (i + 1 < res.size())\n\t\t\t\t\tcout << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint x,p,n;\nchar c;\nstring S;\nset<int>st[6],uni;\nset<int>bnf();\nset<int>::iterator it;\nvoid Prin(set<int> ans){\n  for(it=ans.begin();it!=ans.end();it++){\n    if(it!=ans.begin())cout<<' ';\n    cout<<*it;\n  }\n  cout<<endl;\n}\nset<int> U(set<int> a,set<int> b){\n  set<int>s=b;\n  it=a.begin();\n  while(it!=a.end())s.insert(*it),it++;\n  return s;\n}\nset<int> I(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> D(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> C(set<int> a,set<int> b){\n  set<int>s;\n  it=a.begin();\n  while(it!=a.end()){\n    if(!b.count(*it))s.insert(*it);\n    it++;\n  }\n  return s;\n}\nset<int> ge(){\n  set<int>s;\n  if(S[p]=='(')p++,s=bnf(),p++;\n  else if(S[p]=='c')p++,s=C(uni,st[S[p++]-'A']);\n  else if('A'<=S[p]&&S[p]<='Z')s=st[S[p++]-'A'];\n  return s;\n}\nset<int> bnf(){\n  set<int>s=ge();\n  while('a'<=S[p]&&S[p]<='z'){\n    int t=p++;\n    set<int>g=ge();\n    if(S[t]=='u')s=U(s,g);\n    if(S[t]=='i')s=I(s,g);\n    if(S[t]=='d')s=D(s,g);\n    if(S[t]=='s')s=U(D(s,g),D(g,s));\n  }\n  return s;\n}\nmain(){\n  while(cin>>c){\n    uni.clear();\n    r(i,6)st[i].clear();\n    cin>>n;\n    r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    while(1){\n      cin>>c>>n;\n      if(c=='R')break;\n      r(i,n)cin>>x,st[c-'A'].insert(x),uni.insert(x);\n    }\n    cin>>S;\n    set<int>ans=bnf();\n    Prin(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef map<char, set<int> > mapset;\n\nset<int> atom(string &expr, mapset &sets, int &k);\nset<int> block(string &expr, mapset &sets, int &k);\nset<int> unite(set<int> &s1, set<int> &s2);\nset<int> intersection(set<int> &s1, set<int> &s2);\nset<int> difference(set<int> &s1, set<int> &s2);\nset<int> symmetric_difference(set<int> &s1, set<int> &s2);\nset<int> parse(string &expr, mapset &sets, int &k);\nset<int> complement(mapset &sets, set<int> &s1);\n\nvoid print(set<int> s) {\n    cout << \"set: \";\n    for (set<int>::iterator it=s.begin(); it!=s.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n}\n\nset<int> atom(string &expr, mapset &sets, int &k) {\n    set<int> ret(sets[expr[k]]);\n    k ++;\n    return ret;\n}\n\nset<int> block(string &expr, mapset &sets, int &k) {\n    set<int> v;\n    if (expr[k] == '(') {\n        k ++;\n        v = parse(expr, sets, k);\n        k ++;\n        return v;\n    } else if (expr[k] == 'c') {\n        k ++;\n        v = block(expr, sets, k);\n        v = complement(sets, v);\n        return v;\n    } else {\n        v = atom(expr, sets, k);\n        return v;\n    }\n}\n\nset<int> unite(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.insert(*it);\n    }\n    return ret;\n}\n\nset<int> intersection(set<int> &s1, set<int> &s2) {\n    set<int> ret;\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        if (s1.find(*it) != s1.end()) {\n            ret.insert(*it);\n        }\n    }\n    return ret;\n}\n\nset<int> difference(set<int> &s1, set<int> &s2) {\n    set<int> ret(s1);\n    for (set<int>::iterator it=s2.begin(); it!=s2.end(); ++it) {\n        ret.erase(*it);\n    }\n    return ret;\n}\n\nset<int> symmetric_difference(set<int> &s1, set<int> &s2) {\n    set<int> dif1 = difference(s1, s2);\n    set<int> dif2 = difference(s2, s1);\n    return unite(dif1, dif2);\n}\n\nset<int> complement(mapset &sets, set<int> &s1) {\n    set<int> U;\n    for (mapset::iterator it=sets.begin(); it!=sets.end(); ++it) {\n        U = unite(U, it->second);\n    }\n    return difference(U, s1);\n}\n\nset<int> parse(string &expr, mapset &sets, int &k) {\n    set<int> v1 = block(expr, sets, k);\n    while (k < (int)expr.size() && expr[k] != ')') {\n        char op = expr[k];\n        k ++;\n        set<int> v2 = block(expr, sets, k);\n        if (op == 'u') {\n            v1 = unite(v1, v2);\n        } else if (op == 'i') {\n            v1 = intersection(v1, v2);\n        } else if (op == 'd') {\n            v1 = difference(v1, v2);\n        } else if (op == 's') {\n            v1 = symmetric_difference(v1, v2);\n        }\n    }\n    return v1;\n}\n\nvoid solve(string &expr, mapset &sets) {\n    int k = 0;\n    set<int> st = parse(expr, sets, k);\n    for (set<int>::iterator it=st.begin(); it!=st.end(); ++it) {\n        cout << (it == st.begin() ? \"\" : \" \") << *it;\n    }\n    cout << endl;\n}\n\nint main() {\n    char c; int k;\n    map<char, set<int> > sets;\n    while (cin >> c >> k) {\n        sets.clear();\n        if (c != 'R') {\n            set<int> st; int t;\n            for (int i=0; i<k; ++i) {\n                cin >> t;\n                st.insert(t);\n            }\n            sets[c] = st;\n        } else {\n            string expr;\n            cin >> expr;\n            solve(expr, sets);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nvec And(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      ai++;\n    }else if(av==bv){\n      res.push_back(av);\n      ai++;\n      bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\nvec Or(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      res.push_back(av);ai++;bi++;\n    }else{\n      res.push_back(bv);bi++;\n    }\n  }\n  return res;\n}\n\nvec Dif(vec a,vec b){\n  sort(a.begin(),a.end());sort(b.begin(),b.end());\n  vec res;\n  int as=a.size(),bs=b.size();\n  int ai=0,bi=0;\n  while(ai<as||bi<bs){\n    ll av=(ai==as?INF:a[ai]);\n    ll bv=(bi==bs?INF:b[bi]);\n    if(av<bv){\n      res.push_back(av);ai++;\n    }else if(av==bv){\n      ai++;bi++;\n    }else{\n      bi++;\n    }\n  }\n  return res;\n}\n\n\nvec Xor(vec a,vec b){\n  return Or(Dif(a,b),Dif(b,a));\n}\n\nvec U;\n\nvec Not(vec a){\n  return Dif(U,a);\n}\n\nmap<char,vec> mp;\n\nvoid func(char ch,int num){\n  vec v;\n  ll a;\n  for(int i=0;i<num;i++){\n    cin>>a;\n    v.push_back(a);\n  }\n  sort(v.begin(),v.end());\n  mp[ch]=v;\n  U=Or(U,v);\n}\n\nstring s;\nint pos,len;\nvec solve();\n\nvec getNum(){\n  if(s[pos]=='c'){\n    pos++;\n    return Not(getNum());\n  }else if(s[pos]=='('){\n    pos++;\n    vec res=solve();\n    pos++;\n    return res;\n  }else{\n    char ch=s[pos];\n    pos++;\n    return mp[ch];\n  }\n}\n\nvec solve(){\n  vec res=getNum();\n  while(pos<len&&s[pos]!=')'){\n    char ch=s[pos];\n    pos++;\n    vec num=getNum();\n    if(ch=='u')res=Or(res,num);\n    if(ch=='i')res=And(res,num);\n    if(ch=='d')res=Dif(res,num);\n    if(ch=='s')res=Xor(res,num);\n  }\n  return res;\n}\n\nint main(){\n  int num;\n  char ch;\n  while(cin>>ch>>num){\n    mp.clear();U.clear();\n    func(ch,num);\n    while(1){\n      if(ch=='R')break;\n      cin>>ch>>num;\n      if(ch=='R')break;\n      func(ch,num);\n    }\n    sort(U.begin(),U.end());\n    pos=0;\n    cin>>s;\n    len=s.size();\n    vec ans=solve();\n\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nclass Parse\n{\n  public:\n    string::iterator it;\n    map<char, set<int>> elements;\n\n    Parse(string s, map<char, set<int>> elements){\n        it = s.begin();\n        this->elements = elements;\n    }\n    \n    set<int> term()\n    {\n        set<int> a;\n        if(*it == '('){\n            ++it;\n            a = expr();\n            ++it;\n        }else if(*it == 'c'){\n            ++it;\n            a = term();\n            a = complement(a);\n        }else{\n            a = elements[*it];\n            ++it;\n        }\n        return a;\n    }\n    \n    set<int> expr()\n    {\n        set<int> a = term(), b;\n        while(*it == 'd' ||\n              *it == 'i' ||\n              *it == 's' ||\n              *it == 'u')\n        {\n            char ch = *it; ++it;\n            b = term();\n            switch(ch)\n            {\n                case 'd':\n                    a = difference(a, b);\n                    break;\n                case 'i':\n                    a = intersection(a, b);\n                    break;\n                case 's':\n                    a = sym_difference(a, b);\n                    break;\n                case 'u':\n                    a = union_(a, b);\n                    break;\n            }\n        }\n        return a;\n    }\n\n    set<int> complement(const set<int> a)\n    {\n        return difference(elements['U'], a);\n    }\n    \n    set<int> difference(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) == 0){\n                res.insert(x);\n            }\n        }\n        return res;\n    }\n\n    set<int> intersection(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 and b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n\n    set<int> sym_difference(const set<int> a, const set<int> b)\n    {\n        return (union_(difference(a, b), difference(b, a)));\n    }\n\n    set<int> union_(const set<int> a, const set<int> b)\n    {\n        set<int> res;\n        for(auto x : elements['U']){\n            if(a.count(x) > 0 or b.count(x) > 0){\n                res.insert(x);\n            }\n        }            \n        return res;\n    }\n};\n\nint main()\n{\n    char ch;\n    int N, x;\n    while(cin >> ch >> N)\n    {\n        map<char, set<int>> elements = {};\n        set<int> U = {};\n        do{\n            if(ch == 'R') break;\n            set<int> st;\n            for(int i = 0 ; i < N ; i++){\n                cin >> x;\n                st.insert(x);\n                U.insert(x);\n            }                    \n            elements[ch] = st;\n        }while(cin >> ch >> N);\n\n        elements['U'] = U;\n        \n        string str;\n        cin >> str;\n        \n        Parse parse(str, elements);\n        set<int> res = parse.expr();\n        \n        if(res.size() == 0){\n            cout << \"NULL\" << endl;\n        }else{\n            bool sp = 0;\n            for(auto r : res){\n                if(sp) cout << \" \";\n                sp = 1;\n                cout << r;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nusing S = set<int>;\nS U;\nmap<char, S> m;\n\nstring s;\nint N;\nint c;\n\nS expr();\nS factor();\nS num();\n\nvoid debug(string text){\n\t//return;\n\tcout << text + \" \" + s << endl;\n\tfor(int i = 0; i < text.size() + 1 + N; i++){\n\t\tif(i == text.size() + 1 + c) cout << \"*\";\n\t\telse cout << \" \";\n\t}\n\tcout << endl;\n}\n\nS Union(S s1, S s2){\n\tfor(auto v : s2){\n\t\ts1.insert(v);\n\t}\n\treturn s1;\n}\n\nS Intersection(S s1, S s2){\n\tS ret;\n\tfor(auto v : s2){\n\t\tif(s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Diff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS SymDiff(S s1, S s2){\n\tS ret;\n\tfor(auto v : s1){\n\t\tif(!s2.count(v)) ret.insert(v);\n\t}\n\tfor(auto v : s2){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS Comp(S s1){\n\tS ret;\n\tfor(auto v : U){\n\t\tif(!s1.count(v)) ret.insert(v);\n\t}\n\treturn ret;\n}\n\nS expr(){\n\tdebug(\"expr\");\n\tS x = factor();\n\twhile(c < N){\n\t\tif(s[c] == 'u'){\n\t\t\tc++;\n\t\t\tx = Union(x, factor());\n\t\t}\n\t\telse if(s[c] == 'i'){\n\t\t\tc++;\n\t\t\tx = Intersection(x, factor());\n\t\t}\n\t\telse if(s[c] == 'd'){\n\t\t\tc++;\n\t\t\tx = Diff(x, factor());\n\t\t}\n\t\telse if(s[c] == 's'){\n\t\t\tc++;\n\t\t\tx = SymDiff(x, factor());\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nS factor(){\n\tdebug(\"factor\");\n\tbool rev = false;\n\tif(s[c] == 'c'){\n\t\trev = 1;\n\t\tc++;\n\t}\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tS ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\tif(rev) ret = Comp(ret);\n\t\treturn ret;\n\t}\n\tS ret = num();\n\tif(rev) ret = Comp(ret);\n\treturn ret;\n}\n\nS num(){\n\tdebug(\"num\");\n\tS ret = m[s[c]];\n\tc++;\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tm.clear();\n\t\tU.clear();\n\t\tchar name;\n\t\tint n;\n\t\twhile(true){\n\t\t\tif(!(cin >> name >> n)) return 0;\n\t\t\tif(name == 'R') break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tU.insert(a);\n\t\t\t\tm[name].insert(a);\n\t\t\t}\n\t\t}\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tS ans = expr();\n\t\tif(ans.size()){\n\t\t\tvector<int> v(ans.begin(), ans.end());\n\t\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\t\tcout << v[i];\n\t\t\t\tif(i != v.size() - 1) cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NULL\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n\nset<int> Union(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it = A.begin(); it!=A.end(); it++){\n\t\tret.insert(*it);\n\t}\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Intersection(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=B.begin(); it!=B.end(); it++){\n\t\tif(A.find(*it)!=A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> Difference(const set<int> &A,const set<int> &B){\n\tset<int> ret;\n\tfor(set<int>::iterator it=A.begin(); it!=A.end(); it++){\n\t\tif(B.find(*it)==B.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\n\nset<int> SymmetricDifference(const set<int> &A,const set<int> &B){\n\treturn Union(Difference(A,B),Difference(B,A));\n}\n\nset<int> Complement(const set<int> &A,const set<int> &U){\n\tset<int> ret;\n\tfor(set<int>::iterator it = U.begin(); it != U.end(); it++){\n\t\tif(A.find(*it)==A.end())\n\t\t\tret.insert(*it);\n\t}\n\treturn ret;\n}\nmap<char,set<int> > sets;\n\nset<int> analysis(string str){\n\tstack<int> s;\n\tif(str.size()==1){\n\t\treturn sets[str[0]];\n\t}\n\telse if(str.size()==2){\n\t\treturn Complement(sets[str[1]],sets['U']);\n\t}\n\telse if(str[0]=='('&&str[str.size()-1]==')'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(i!=str.size()-1&&s.size()==0)\n\t\t\t\tf=true;\n\t\t}\n\t\tif(!f){\n\t\t\treturn analysis(str.substr(1,str.size()-2));\n\t\t}\n\t}\n\t// ÊÉðÍ.ãë©ç©Ä¢«Astackª0ÌóÔÅZqð©Â¯½çAÄA·é.\n\tfor(int i = str.size()-1; i >= 0; i--){\n\t\tif(str[i]==')'){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]=='('){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(s.size()==0){\n\t\t\tif(str[i]=='u'){\n\t\t\t\treturn Union(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='i'){\n\t\t\t\treturn Intersection(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='d'){\n\t\t\t\treturn Difference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t\telse if(str[i]=='s'){\n\t\t\t\treturn SymmetricDifference(analysis(str.substr(0,i)),analysis(str.substr(i+1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn set<int>();\n}\n\nint main(){\n\n\n\twhile(1){\n\t\tsets.clear();\n\t\tfor(char ch='A'; ch <= 'E'; ch++){\n\t\t\tsets[ch];\n\t\t}\n\t\tsets['U'];\n\n\t\tchar ch;\n\t\tbool f=false;\n\t\twhile(cin>>ch){\n\t\t\tif(ch=='R'){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=true;\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tsets[ch].insert(t);\n\t\t\t\tsets['U'].insert(t);\n\t\t\t}\n\t\t}\n\t\tif(!f)\n\t\t\tbreak;\n\t\tstring str;\n\t\tcin>>str;\n\t\tset<int> s = analysis(str);\n\t\tif(s.size()==0)\n\t\t\tcout<<\"NULL\"<<endl;\n\t\telse{\n\t\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\t\tcout<<*it;\n\t\t\t\tif(it==--(s.end())){\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout<<\" \";\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename InputIterator> std::string join(InputIterator first, InputIterator last, const std::string &sep) {\n  if (first == last) return \"\";\n  std::stringstream ss;\n  ss << *(first++);\n  for_each(first, last, [&](auto &x) { ss << sep << x; });\n  return ss.str();\n}\n\nset<int> bin(set<int> l, set<int> r, char op) {\n  set<int> val;\n  if (op == 'u') set_union(all(l), all(r), inserter(val, val.begin()));\n  if (op == 'i') set_intersection(all(l), all(r), inserter(val, val.begin()));\n  if (op == 'd') set_difference(all(l), all(r), inserter(val, val.begin()));\n  if (op == 's') val = bin(bin(l, r, 'd'), bin(r, l, 'd'), 'u');\n  return val;\n}\n\nusing state = string::const_iterator;\n\nset<int> expr(state &);\n\nmap<char, set<int>> m;\nset<int> u;\n\nset<int> elem(state &s) {\n  char c = *s;\n  s++;\n  return m[c];\n}\n\nset<int> factor(state &s) {\n  if (*s == '(') {\n    s++;\n    set<int> val = expr(s);\n    s++;\n    return val;\n  }\n  return elem(s);\n}\n\nset<int> term(state &s) {\n  int k = 0;\n  while (*s == 'c') s++, k++;\n  if (odd(k)) {\n    set<int> val = factor(s);\n    return bin(u, val, 'd');\n  }\n  return factor(s);\n}\n\nset<int> expr(state &s) {\n  set<int> val = term(s);\n  while (1) {\n    char c = *s;\n    if (string(\"uidsc\").find(c) != string::npos) {\n      s++;\n      val = bin(val, term(s), c);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nmain {\n  while (1) {\n    m.clear();\n    u.clear();\n    char c;\n    int k;\n    while (1) {\n      if (!(cin >> c >> k)) return 0;\n      if (!k) break;\n      while (k--) {\n        int x;\n        cin >> x;\n        m[c].insert(x);\n        u.insert(x);\n      }\n    }\n    string s;\n    cin >> s;\n    state p = s.begin();\n    set<int> w = expr(p);\n    cout << (w.size() ? join(all(w), \" \") : \"NULL\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                #include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                         \n                                using namespace std;\n                      \n                                class Point{\n                                \tpublic:\n                                \tdouble x,y;\n                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                \tdouble absv() {return sqrt(norm());}\n                                \tdouble norm() {return x*x+y*y;}\n                                \tbool operator < (const Point &p) const{\n                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                \t}\n                                \tbool operator == (const Point &p) const{\n                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                \t}\n                                };\n                                typedef Point Vector;\n                         \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                \treturn a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                \treturn a.x*b.y-a.y*b.x;\n                                }\n                            \n    bool parareru(Point a,Point b,Point c,Point d){\n    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n    \treturn abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //\t\tcout<<\"sss\"<<endl;\n    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n    \t\treturn false;\n    \t}\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n     \n    double segment_dis(Segment a,Segment b){\n    \tif(is_intersected_ls(a,b))return 0;\n    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n    \treturn r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n     \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n     \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                     \n                    int gcd(int v,int b){\n                    \tif(v>b) return gcd(b,v);\n                    \tif(v==b) return b;\n                    \tif(b%v==0) return v;\n                    \treturn gcd(v,b%v);\n                    }\n     \n                    double distans(double x1,double y1,double x2,double y2){\n                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                    \treturn sqrt(rr);\n                    \t\n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */ \n    int beki(int wa,int rr,int warukazu){\n    \tif(rr==0) return 1ll;\n    \tif(rr==1) return wa%warukazu;\n    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n    \tint zx=beki(wa,rr/2,warukazu);\n    \treturn (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n    \tpr[0]=1;\n    \tfor(int i=1;i<100010;i++){\n    \t\tpr[i]=(pr[i-1]*i)%inf;\n    \t}\n    \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n    \t\n    }\n     \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n     \n    void shoki(int n){\n    \tfor(int i=0;i<n;i++){\n    \t\tpar[i]=i;\n    \t\tranks[i]=0;\n    \t\tkosuu[i]=1;\n    \t}\n    }\n     \n    int root(int x){\n    \treturn par[x]==x ? x : par[x]=root(par[x]);\n    }\n     \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n     \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n    \tint xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n    \tif(ranks[x]<ranks[y]){\n    \t\tpar[x]=y;\n    \t\tkosuu[y]=yy+xx;\n    \t}\n     else {\n    \tpar[y]=x;\n    \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n     \tkosuu[x]=yy+xx;\n     }\n    \treturn;\n    }\n    */\n\nstring s;\nint it;\nvector<int> ve[5];\nvector<int> V;\nvector<int> ch[5];\n\nvector<int> U(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]|a2[i]);\n\treturn ve;\n}\n\nvector<int> I(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]&a2[i]);\n\treturn ve;\n}\nvector<int> S(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(a1[i]^a2[i]);\n\treturn ve;\n}\nvector<int> D(vector<int> a1,vector<int> a2){\n\tvector<int> ve;\n\t\n\tfor(int i=0;i<a1.size();i++){\n\t\tint r;\n\t\tif(a1[i]==1 && a2[i]==0) r=1;\n\t\telse r=0;\n\t\tve.pb(r);\n\t}\n\treturn ve;\n}\n\nvector<int> C(vector<int> a1){\n\tvector<int> ve;\n\tfor(int i=0;i<a1.size();i++)ve.pb(1-a1[i]);\n\treturn ve;\n}\n\nvector<int> han(){\n//\tcout<<s[it]<<endl;\n\tif(s[it]=='c'){\n\t\tit++;\n\t\tvector<int> e=han();\n\t\treturn C(e);\n\t}\n\telse{\n\t\tit++;\n\t\treturn ch[s[it-1]-'A'];\n\t}\n}\nvector<int> shiki();\nvector<int> ka(){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tvector<int> q=shiki();\n\t\tit++;\n\t\treturn q;\n\t}\n\telse return han();\n\t\n}\n\n\n\nvector<int> shiki(){\n\tvector<int> r= ka();\n\twhile(s[it]=='u'||s[it]=='s'||s[it]=='d'||s[it]=='i'){\n\t\tchar c=s[it];\n\t\tit++;\n\t\tvector<int> r2=ka();\n\t\t\n\t\tif(c=='u') r=U(r,r2);\n\t\tif(c=='s') r=S(r,r2);\n\t\tif(c=='d') r=D(r,r2);\n\t\tif(c=='i') r=I(r,r2);\n\t}\n\treturn r;\n}\n\n\nsigned main(){\nchar c;\n\tint d;\n\twhile(1){\n\t\tif(!(cin>>c>>d))return 0;\n\t\tfor(int i=0;i<5;i++) ve[i].clear(),ch[i].clear();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\tve[c-'A'].pb(r);\n\t\t}\n\t\twhile(1){\n\t\t\tcin>>c>>d;\n\t\t\t\n\t\t\tif(c=='R') break;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tve[c-'A'].pb(r);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tset<int> se;\n\t\t\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<ve[i].size();j++)se.insert(ve[i][j]);\n\t\tV.clear();\n\t\tfor(auto its=se.begin();its!=se.end();its++){\n\t\t\tV.pb(*its);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=0;j<V.size();j++){\n\t\t\tbool b=false;\n\t\t\tfor(int k=0;k<ve[i].size();k++){\n\t\t\t\tif(ve[i][k]==V[j]) b=true;\n\t\t\t}\n\t\t\tif(b) ch[i].pb(1);\n\t\t\telse ch[i].pb(0);\n\t\t}\n\t//\t\tfor(int j=0;j<V.size();j++)cout<<ch[i][j];\n\t//\t\tcout<<endl;\n\t\t}\n\t\tit=0;\n\t\tcin>>s;\n\t\ts+=\"*\";\n\t\tvector<int> ans=shiki();\n\t\tbool r=false;\n\t\tfor(int i=0;i<ans.size();i++)if(ans[i]) r=true, cout<<V[i]<<\" \";\n\t\tif(!r) cout<<\"NULL\";\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nmap<char, vector<int> > sets;\nvector<int> parse(const string& e)\n{\n\tif (e.empty())\n\t\treturn vector<int>();\n\telse if (e.size() == 1)\n\t\treturn sets[e[0]];\n\telse if (e.size() == 2)\n\t{\n\t\tvector<int> res(sets['U'].size() - sets[e[1]].size());\n\t\tset_symmetric_difference(all(sets[e[1]]), all(sets['U']), res.begin());\n\t\treturn res;\n\t}\n\t\n\tvector<int> left, right;\n\tchar ope;\n\tif (e[0] == '(')\n\t{\n\t\tint i, par = 1;\n\t\tfor (i = 1; par; ++i)\n\t\t{\n\t\t\tif (e[i] == '(')\n\t\t\t\t++par;\n\t\t\telse if (e[i] == ')')\n\t\t\t\t--par;\n\t\t}\n\t\tope = e[i];\n\t\tleft = parse(e.substr(1, i - 2));\n\t\tif (i == e.size())\n\t\t\treturn left;\n\t\tright = parse(e.substr(i + 1, e.size() - (i + 1)));\n\t}\n\telse if (e[0] == 'c')\n\t{\n\t\tope = e[2];\n\t\tleft = parse(e.substr(0, 2));\n\t\tright = parse(e.substr(3, e.size() - 3));\n\t}\n\telse\n\t{\n\t\tope = e[1];\n\t\tleft = parse(e.substr(0, 1));\n\t\tright = parse(e.substr(2, e.size() - 2));\n\t}\n\n\tvector<int> res(left.size() + right.size());\n\tvector<int>::iterator end;\n\tif (ope == 'u')\n\t\tend = set_union(all(left), all(right), res.begin());\n\telse if (ope == 'i')\n\t\tend = set_intersection(all(left), all(right), res.begin());\n\telse if (ope == 'd')\n\t\tend = set_difference(all(left), all(right), res.begin());\n\telse if (ope == 's')\n\t\tend = set_symmetric_difference(all(left), all(right), res.begin());\n\n\tres.erase(end, res.end());\n\treturn res;\n}\nint main()\n{\n\twhile (!feof(stdin))\n\t{\n\t\tsets.clear();\n\n\t\tvector<int> universe;\n\t\twhile (true)\n\t\t{\n\t\t\tchar a;\n\t\t\tint n;\n\t\t\tscanf(\" %c%d\", &a, &n);\n\t\t\tif (a == 'R')\n\t\t\t\tbreak;\n\n\t\t\tsets[a] = vector<int>();\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tsets[a].push_back(t);\n\t\t\t\tuniverse.push_back(t);\n\t\t\t}\n\t\t\tsort(all(sets[a]));\n\t\t}\n\t\tsort(all(universe));\n\t\tuniverse.erase(unique(all(universe)), universe.end());\n\t\tsets['U'] = universe;\n\n\t\tchar buf[512];\n\t\tscanf(\" %s\", buf);\n\t\tvector<int> res = parse(buf);\n\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\tprintf(\"%d%c\", res[i], i + 1 == res.size() ? '\\n' : ' ');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//18\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> v[5],u;\nconst char *e;\nint x;\n\nvector<int> exp();\n\nvector<int> ss(){\n  if(e[x]=='('){\n    x++;\n    vector<int> r=exp();\n    x++;\n    return r;\n  }else if(e[x]!='c'){\n    return v[e[x++]-'A'];\n  }else{\n    x++;\n    vector<int> l=ss(),a(u.size());\n    vector<int>::iterator it;\n    it=set_difference(u.begin(),u.end(),l.begin(),l.end(),a.begin());\n    a.resize(it-a.begin());\n    return a;\n  }\n}\n\nvector<int> exp(){\n  vector<int> l=ss();\n  string op=\"uids\";\n  for(char o=e[x];op.find(o)!=string::npos;o=e[x]){\n    x++;\n    vector<int> r=ss(),a(u.size());\n    vector<int>::iterator it;\n    if(o=='u'){\n      it=set_union(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='i'){\n      it=set_intersection(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else if(o=='d'){\n      it=set_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }else{\n      it=set_symmetric_difference(l.begin(),l.end(),r.begin(),r.end(),a.begin());\n    }\n    a.resize(it-a.begin());\n    l=a;\n  }\n  return l;\n}\n\nint main(){\n  for(;;){\n    u.clear();\n    for(int i=0;i<5;i++){\n      v[i].clear();\n    }\n    char c;\n    int n;\n    while(cin>>c>>n,cin&&c!='R'){\n      int x=c-'A';\n      v[x].resize(n);\n      while(n--){\n\tcin>>v[x][n];\n\tu.push_back(v[x][n]);\n      }\n      sort(v[x].begin(),v[x].end());\n    }\n    if(!cin)return 0;\n    sort(u.begin(),u.end());\n    u.resize(unique(u.begin(),u.end())-u.begin());\n    string s;\n    cin>>s;\n    e=s.c_str();\n    x=0;\n    vector<int> r=exp();\n    if(r.empty()){\n      cout<<\"NULL\"<<endl;\n    }else{\n      for(int i=0;i<r.size();i++){\n\tcout<<r[i]<<((i==r.size()-1)?'\\n':' ');\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t0\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t0\n#define ERROR_INVALID_CALCULATION\t0\n#define ERROR_INVALID_RESULT\t\t0\n#define ERROR_LIMIT_EXCEEDED\t\t0\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now<0x80)return 0;\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x00,0x80) */\n\t\t\t\tif(now<0x40)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x30,0x32) */\n\t\t\t\tif(now==0x30)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x52 */\n\t\t\t\tif(now==0x53)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t0\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t0\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t0\n#define ERROR_INVALID_CALCULATION\t0\n#define ERROR_INVALID_RESULT\t\t0\n#define ERROR_LIMIT_EXCEEDED\t\t0\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t0\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(setname[0]=='R' && now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x40) */\n\t\t\t\tif(now<0x30)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x22) */\n\t\t\t\tif(now==0x20)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x00,0x40) */\n\t\t\t\tif(now<0x20)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x50 - 0x58 */\n\t\t\t\tif(now<0x54)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now<0x80)return 0;\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x30,0x34) */\n\t\t\t\tif(now<0x32)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now==0x20)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x22) */\n\t\t\t\tif(now==0x21)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(2);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(4);\n\t\t}\n\t}\n\tif(stack_num!=1)exit(5);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return 1;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(4);\n\t\t}\n\t}\n\tif(stack_num!=1)exit(5);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return 1;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x24) */\n\t\t\t\tif(now<0x22)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(setname[0]=='R' && now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1012\nTitle Operations with Finite Sets\n3/12 RE\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n\nstruct set_st\n{\n  char name [10];\n  int num;\n  int elements[500];} sets[5];\n#define BUF_SIZ 100\nstruct set_st buf[BUF_SIZ];\nstruct set_st UALL;\nint bufptr;\nchar expr[1001];\nchar *bin_op=\"uids\";\n//\nvoid print_symbol_value()\n{\n  extern void print_st(struct set_st *);\n\n  int i,j,nn;\n  for(i=0;i<5;i++)\n    {\n      print_st(&(sets[i]));\n      printf(\"\\n\");\n    }\n  printf(\"-----------------\\n\");\n}\nint comp(void * x,void * y)\n{\n  return(*(int *)x-*(int *)y);\n}\nvoid print_st(struct set_st *setp)\n{\n  int i;\n  if(setp->num)\n    {\n      qsort(&(setp->elements[0]),setp->num,sizeof(int),(__compar_fn_t)comp);\n      for(i=0;i<setp->num;i++)\n\tprintf(\"%d \",setp->elements[i]);\n    }\n  else\n    printf(\"NULL\");\n  printf(\"\\n\");\n}\nstruct set_st *alloc_set_area()\n{\n    struct set_st *setp;\n    setp=&(buf[bufptr]);\n    bufptr++;\n    if(bufptr>BUF_SIZ)\n      bufptr=0;\n    setp->num=0;\n    return(setp);\n}\nvoid copy_set(struct set_st *to,struct set_st *from)\n{\n  memcpy(to,from,sizeof(struct set_st));\n}\nvoid make_universal_set()\n{\n  extern void add_element(struct set_st *,int);\n\n  int i,j;\n  UALL.num=0;\n  for(i=0;i<5;i++)\n    for(j=0;j<sets[i].num;j++)\n      add_element(&UALL,sets[i].elements[j]);\n      \n}\nvoid add_element(struct set_st *setp,int elm)\n{\n  int i;\n  for(i=0;i<setp->num;i++)\n    if(elm == setp->elements[i])\n      return;\n  setp->elements[(setp->num)++]=elm;\n}\nstruct set_st * calc_union(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i;\n  setp=alloc_set_area();\n  copy_set(setp,a1);\n  for(i=0;i<a2->num;i++)\n    add_element(setp,a2->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_intersect(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    for(j=0;j<a2->num;j++)\n      if(a1->elements[i]==a2->elements[j])\n\tadd_element(setp,a1->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  return(setp);\n}\nstruct set_st * calc_sym_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  for(i=0;i<a2->num;i++)\n    {\n      for(j=0;j<a1->num;j++)\n\tif(a1->elements[j]==a2->elements[i])\n\t  goto NEXT2;\n    \n\tadd_element(setp,a2->elements[i]);\n    NEXT2:;\n    }\n  return(setp);\n}\nstruct set_st * calc_expr1(struct set_st *a1,struct set_st *a2 ,char operator)\n{\n#if DEBUGX\n  printf(\"A1\");\n  print_st(a1);\n  printf(\"A2\");\n  print_st(a2);\n#endif\n  switch(operator){\n  case 'u':\n    return(calc_union(a1,a2));\n  case 'i':\n    return(calc_intersect(a1,a2));\n  case 'd':\n    return(calc_diff(a1,a2));\n  case 's':\n    return(calc_sym_diff(a1,a2));\n  default:\n    break;\n    }\n}\nstruct set_st * calc_cpl(struct set_st *a1)\n{\n  return(calc_diff(&UALL,a1));\n}\nstruct set_st * eval_symbol(char c)\n{\n  return(&(sets[c-'A']));\n}\nvoid clear_symbol()\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    sets[i].num=0;\n}\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=0;i<len;i++)\n    { \n      if(s[i]=='(')\n\td++;\n      else if (s[i]==')')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op,s[i]);\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nvoid print_expr(char *s,int len)\n{\n  int i;\n\n  printf(\"Expr=\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n}\nstruct set_st *calc_expr(char *s,int len)\n{\n  char *r;\n#ifdef DEBUG\n  print_expr(s,len);\n#endif\n  if(len == 1 && strchr(\"ABCDE\",s[0]))\n    return(eval_symbol(s[0]));\n  r=find_bin_op(s,len);\n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  if(s[0]=='c')\n     return(calc_cpl(calc_expr(s+1,len-1)));\n  else   if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n    return(NULL);\n}\nmain()\n{\n  int i;\n  char c;\n  int n,setp;\n  struct set_st *r;\n\n  bufptr=0;\n START:\n  clear_symbol();\n      while(1)\n\t{\n\t  if(EOF==scanf(\"%c %d\",&c,&n))\n\t    goto END;\n\t  if((c=='R') && (n==0))\n\t    break;\n\t  setp=c-'A';\n\t  sets[setp].num=n;\n\t  for(i=0;i<n;i++)\n\t    scanf(\"%d \",&(sets[setp].elements[i]));\n\t}\n      make_universal_set();\n\n      fgets(expr,10,stdin);  //junp CRLF\n      fgets(expr,100,stdin);\n      \n      expr[strlen(expr)-1]='\\0';\n      //printf(\"e:%s\",expr);\n\n      r=calc_expr(expr,strlen(expr));\n      print_st(r);\n      //print_st(calc_expr(expr,strlen(expr)));\n      //print_symbol_value();\n      goto START;\nEND:\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x28) */\n\t\t\t\tif(now<0x24)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\nint set[5][110], len[5];\nint uSet[MAX], uLen;\nint ans[MAX], aLen;\nchar buf[MAX], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint reform(int *a, int alen)\n{\n\tint i, j;\n\n\tif (alen <= 0) return 0;\n\tqsort(a, alen, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < alen; j++) {\n\t\tif (a[j] != a[i]) {\n\t\t\tif (++i != j) a[i] = a[j];\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint bsch(int x, int *a, int alen)\n{\n\tint m, l = 0, r = alen-1;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (*(a+m) < x) l = m + 1; else r = m;\n    }\n\treturn *(a+l) == x;\n}\n\nint factor(int *a)\n{\n\tint i, la, lx, id, f = 0;\n\tint *x;\n\n\tif (*p == 'c') while (*p == 'c') p++, f = !f;\n\tx = calloc(MAX, sizeof(int));\n\tif (*p == '(') { p++; lx = expr(x); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tid = *p++ - 'A', lx = len[id];\n\t\tmemcpy(x, set[id], sizeof(int)*lx);\n\t} else while (1);  // panic\n\tif (f) {\n\t\tfor (la = i = 0; i < uLen; i++) {\n\t\t\tif (!bsch(uSet[i], x, lx)) a[la++] = uSet[i];\n\t\t}\n\t} else memcpy(a, x, sizeof(int)*lx), la = lx;\n\tfree(x);\n\treturn la;\n}\n\nint expr(int *x)\n{\n\tint i, lx, ly, lz, op;\n\tint *y, *z;\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\ty = calloc(MAX, sizeof(int));\n\t\tly = factor(y);\n\t\tz = calloc(MAX, sizeof(int)); lz = 0;\n\t\tif (op == 'u') {\n\t\t\tmemcpy(z, x, sizeof(int)*lx);\n\t\t\tmemcpy(z + lx, y, sizeof(int)*ly);\n\t\t\tlz = reform(z, lx + ly);\n\t\t} else if (op == 'i') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (!bsch(y[i], x, lx))\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tmemcpy(x, z, sizeof(int)*lz);\n\t\tlx = reform(x, lz);\n\t\tfree(z);\n\t\tfree(y);\n\t}\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(len, 0, sizeof(len)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tid = *s - 'A', len[id] = n;\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tqsort(set[id], n, sizeof(int), cmp);\n\t\t}\n\t\tuLen = reform(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = reform(ans, aLen);\n\t\tif (aLen == 0) putchar('\\n');\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now<0x40)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\nint set[5][110], len[5];\nint uSet[MAX], uLen;\nint ans[MAX], aLen;\nchar buf[MAX], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint reform(int *a, int alen)\n{\n\tint i, j;\n\n\tif (alen <= 0) return 0;\n\tqsort(a, alen, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < alen; j++) {\n\t\tif (a[j] != a[i]) {\n\t\t\tif (++i != j) a[i] = a[j];\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint bsch(int x, int *a, int alen)\n{\n\tint m, l = 0, r = alen-1;\n\n\tif (alen <= 0) return 0;\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (*(a+m) < x) l = m + 1; else r = m;\n    }\n\treturn *(a+l) == x;\n}\n\nint factor(int *a)\n{\n\tint i, la, lx, id, f = 0;\n\tint *x;\n\n\twhile (*p == 'c') p++, f = !f;\n\tx = calloc(MAX, sizeof(int));\n\tif (*p == '(') { p++; lx = expr(x); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tid = *p++ - 'A', lx = len[id];\n\t\tmemcpy(x, set[id], sizeof(int)*lx);\n\t} else while (1);  // panic\n\tif (f) {\n\t\tfor (la = i = 0; i < uLen; i++) {\n\t\t\tif (!bsch(uSet[i], x, lx)) a[la++] = uSet[i];\n\t\t}\n\t} else memcpy(a, x, sizeof(int)*lx), la = lx;\n\tfree(x);\n\treturn la;\n}\n\nint expr(int *x)\n{\n\tint i, lx, ly, lz, op;\n\tint *y, *z;\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\ty = calloc(MAX, sizeof(int));\n\t\tly = factor(y);\n\t\tz = calloc(MAX, sizeof(int)); lz = 0;\n\t\tif (op == 'u') {\n\t\t\tmemcpy(z, x, sizeof(int)*lx), lz = lx;\n\t\t\tfor (i = 0; i < ly; i++) z[lz++] = y[i];\n\t\t\tlz = reform(z, lz);\n\t\t} else if (op == 'i') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (!bsch(y[i], x, lx))\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tmemcpy(x, z, sizeof(int)*lz);\n\t\tlx = reform(x, lz);\n\t\tfree(z);\n\t\tfree(y);\n\t}\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(len, 0, sizeof(len)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tid = *s - 'A', len[id] = n;\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tqsort(set[id], n, sizeof(int), cmp);\n\t\t}\n\t\tuLen = reform(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = reform(ans, aLen);\n\t\tif (aLen == 0) putchar('\\n');\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint set[5][100], len[5];\nint uSet[500], uLen;\nint ans[500], aLen;\nchar buf[500], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint reform(int *a, int alen)\n{\n\tint i, j;\n\n\tif (alen <= 0) return 0;\n\tqsort(a, alen, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < alen; j++) {\n\t\tif (a[j] != a[i])\n\t\t\tif (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint factor(int *a)\n{\n\tint i, l, id, f = 0;\n\n\tif (*p == '(') { p++; l = expr(a); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tid = *p++ - 'A', l = len[id];\n\t\tmemcpy(a, set[id], sizeof(int)*l);\n\t} else if (*p == 'c') {\n\t\tp++; id = *p++ - 'A';\n\t\tfor (l = i = 0; i < uLen; i++) {\n\t\t\tif (bsearch(uSet+i, set[id], len[id], sizeof(int), cmp) == NULL)\n\t\t\t\ta[l++] = uSet[i];\n\t\t}\n\t}\n\treturn l;\n}\n\nint expr(int *a)\n{\n\tint i, lx, ly, lz, op;\n\tint x[500], y[500], z[500];\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\tly = factor(y);\n\t\tif (op == 'u') {\n\t\t\tmemcpy(z, x, sizeof(int)*lx);\n\t\t\tmemcpy(z + lx, y, sizeof(int)*ly);\n\t\t\tlz = reform(z, lx + ly);\n\t\t} else if (op == 'i') {\n\t\t\tfor (lz = i = 0; i < lx; i++) {\n\t\t\t\tif (bsearch(x+i, y, ly, sizeof(int), cmp) != NULL)\tz[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (lz = i = 0; i < lx; i++) {\n\t\t\t\tif (bsearch(x+i, y, ly, sizeof(int), cmp) == NULL)\tz[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (lz = i = 0; i < lx; i++) {\n\t\t\t\tif (bsearch(x+i, y, ly, sizeof(int), cmp) == NULL)\tz[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (bsearch(y+i, x, lx, sizeof(int), cmp) == NULL)\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tmemcpy(x, z, sizeof(int)*lz);\n\t\tlx = reform(x, lz);\n\t}\n\tmemcpy(a, x, sizeof(int)*lx);\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(len, 0, sizeof(len)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tid = *s - 'A', len[id] = n;\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tqsort(set[id], n, sizeof(int), cmp);\n\t\t}\n\t\tuLen = reform(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = reform(ans, aLen);\n\t\tif (aLen == 0) putchar('\\n');\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t0\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t0\n#define ERROR_INVALID_CALCULATION\t0\n#define ERROR_INVALID_RESULT\t\t0\n#define ERROR_LIMIT_EXCEEDED\t\t0\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now<0x80)return 1;\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\nint set[5][110], len[5];\nint uSet[MAX], uLen;\nint ans[MAX], aLen;\nchar buf[MAX], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint reform(int *a, int alen)\n{\n\tint i, j;\n\n\tif (alen <= 0) return 0;\n\tqsort(a, alen, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < alen; j++) {\n\t\tif (a[j] != a[i]) {\n\t\t\tif (++i != j) a[i] = a[j];\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint bsch(int x, int *a, int alen)\n{\n\tint m, l = 0, r = alen-1;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (*(a+m) < x) l = m + 1; else r = m;\n    }\n\treturn *(a+l) == x;\n}\n\nint factor(int *a)\n{\n\tint i, l, id, f = 0;\n\n\tif (*p == '(') { p++; l = expr(a); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tid = *p++ - 'A', l = len[id];\n\t\tmemcpy(a, set[id], sizeof(int)*l);\n\t} else if (*p == 'c') {\n\t\tp++; if (*p < 'A' || *p > 'E') while (1);  // Panic\n\t\tid = *p++ - 'A';\n\t\tfor (l = i = 0; i < uLen; i++) {\n\t\t\tif (!bsch(uSet[i], set[id], len[id])) a[l++] = uSet[i];\n\t\t}\n\t}\n\treturn l;\n}\n\nint expr(int *x)\n{\n\tint i, lx, ly, lz, op;\n\tint *y, *z;\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\ty = calloc(MAX, sizeof(int));\n\t\tly = factor(y);\n\t\tz = calloc(MAX, sizeof(int)); lz = 0;\n\t\tif (op == 'u') {\n\t\t\tmemcpy(z, x, sizeof(int)*lx);\n\t\t\tmemcpy(z + lx, y, sizeof(int)*ly);\n\t\t\tlz = reform(z, lx + ly);\n\t\t} else if (op == 'i') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (!bsch(y[i], x, lx))\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tmemcpy(x, z, sizeof(int)*lz);\n\t\tlx = reform(x, lz);\n\t\tfree(z);\n\t\tfree(y);\n\t}\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(len, 0, sizeof(len)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tid = *s - 'A', len[id] = n;\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tqsort(set[id], n, sizeof(int), cmp);\n\t\t}\n\t\tuLen = reform(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = reform(ans, aLen);\n\t\tif (aLen == 0) putchar('\\n');\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1012\nTitle\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nstruct set_st\n{\n  char name [10];\n  int num;\n  int elements[100];} sets[5];\n#define BUF_SIZ 100\nstruct set_st buf[BUF_SIZ];\nstruct set_st UALL;\nint bufptr;\nchar expr[1001];\nchar *bin_op=\"uids\";\n//\nvoid print_symbol_value()\n{\n  extern void print_st(struct set_st *);\n\n  int i,j,nn;\n  for(i=0;i<5;i++)\n    {\n      print_st(&(sets[i]));\n      printf(\"\\n\");\n    }\n  printf(\"-----------------\\n\");\n}\nint comp(void * x,void * y)\n{\n  return(*(int *)x-*(int *)y);\n}\nvoid print_st(struct set_st *setp)\n{\n  int i;\n  if(setp->num)\n    {\n      qsort(&(setp->elements[0]),setp->num,sizeof(int),(__compar_fn_t)comp);\n      for(i=0;i<setp->num;i++)\n\tprintf(\"%d \",setp->elements[i]);\n    }\n  else\n    printf(\"NULL\");\n  printf(\"\\n\");\n}\nstruct set_st *alloc_set_area()\n{\n    struct set_st *setp;\n    setp=&(buf[bufptr]);\n    bufptr++;\n    if(bufptr>BUF_SIZ)\n      bufptr=0;\n    setp->num=0;\n    return(setp);\n}\nvoid copy_set(struct set_st *to,struct set_st *from)\n{\n  memcpy(to,from,sizeof(struct set_st));\n}\nvoid make_universal_set()\n{\n  extern void add_element(struct set_st *,int);\n\n  int i,j;\n  UALL.num=0;\n  for(i=0;i<5;i++)\n    for(j=0;j<sets[i].num;j++)\n      add_element(&UALL,sets[i].elements[j]);\n      \n}\nvoid add_element(struct set_st *setp,int elm)\n{\n  int i;\n  for(i=0;i<setp->num;i++)\n    if(elm == setp->elements[i])\n      return;\n  setp->elements[(setp->num)++]=elm;\n}\nstruct set_st * calc_union(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i;\n  setp=alloc_set_area();\n  copy_set(setp,a1);\n  for(i=0;i<a2->num;i++)\n    add_element(setp,a2->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_intersect(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    for(j=0;j<a2->num;j++)\n      if(a1->elements[i]==a2->elements[j])\n\tadd_element(setp,a1->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  return(setp);\n}\nstruct set_st * calc_sym_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  for(i=0;i<a2->num;i++)\n    {\n      for(j=0;j<a1->num;j++)\n\tif(a1->elements[j]==a2->elements[i])\n\t  goto NEXT2;\n    \n\tadd_element(setp,a2->elements[i]);\n    NEXT2:;\n    }\n  return(setp);\n}\nstruct set_st * calc_expr1(struct set_st *a1,struct set_st *a2 ,char operator)\n{\n#if DEBUG\n  printf(\"A1\");\n  print_st(a1);\n  printf(\"A2\");\n  print_st(a2);\n#endif\n  switch(operator){\n  case 'u':\n    return(calc_union(a1,a2));\n  case 'i':\n    return(calc_intersect(a1,a2));\n  case 'd':\n    return(calc_diff(a1,a2));\n  case 's':\n    return(calc_sym_diff(a1,a2));\n  default:\n    break;\n    }\n}\nstruct set_st * calc_cpl(struct set_st *a1)\n{\n  return(calc_diff(&UALL,a1));\n}\nstruct set_st * eval_symbol(char c)\n{\n  return(&(sets[c-'A']));\n}\nvoid clear_symbol()\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    sets[i].num=0;\n}\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=0;i<len;i++)\n    { \n      if(s[i]=='(')\n\td++;\n      else if (s[i]==')')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op,s[i]);\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nvoid print_expr(char *s,int len)\n{\n  int i;\n\n  printf(\"Expr=\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n}\nstruct set_st *calc_expr(char *s,int len)\n{\n  char *r;\n#ifdef DEBUG\n  print_expr(s,len);\n#endif\n  if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n  if(len == 1 && strchr(\"ABCDE\",s[0]))\n    return(eval_symbol(s[0]));\n  r=find_bin_op(s,len);\n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  if(s[0]=='c')\n     return(calc_cpl(calc_expr(s+1,len-1)));\n  else\n    return(NULL);\n}\nmain()\n{\n  int i;\n  char c;\n  int n,setp;\n  struct set_st *r;\n\n  bufptr=0;\n START:\n  clear_symbol();\n      while(1)\n\t{\n\t  if(EOF==scanf(\"%c %d\",&c,&n))\n\t    goto END;\n\t  if((c=='R') && (n==0))\n\t    break;\n\t  setp=c-'A';\n\t  sets[setp].num=n;\n\t  for(i=0;i<n;i++)\n\t    scanf(\"%d \",&(sets[setp].elements[i]));\n\t}\n      make_universal_set();\n#ifdef DEBUG\n      //printf(\"UNIV=\");\n      //print_st(&UALL);\n#endif\n      fgets(expr,1000,stdin);  //junp CRLF\n      fgets(expr,1000,stdin);\n      expr[strlen(expr)-1]='\\0';\n      //printf(\"e:%s\",expr);\n\n      r=calc_expr(expr,strlen(expr));\n      print_st(r);\n      //print_st(calc_expr(expr,strlen(expr)));\n      //print_symbol_value();\n      goto START;\nEND:\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x30) */\n\t\t\t\tif(now<0x28)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x50 - 0x60 */\n\t\t\t\tif(now<0x58)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x30,0x40) */\n\t\t\t\tif(now<0x38)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x20,0x40) */\n\t\t\t\tif(now<0x30)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t0\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x52 or 0x53 */\n\t\t\t\tif(now==0x52)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x30,0x38) */\n\t\t\t\tif(now<0x34)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:/* [0x00,0x40) */\n\t\t\t\tif(now<0x20)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfound=0;\n\t\twhile(1) {\n\t\t\tif(found)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tfound=1;\n\t\t\tif(setname[0]=='R' && now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1012\nTitle Operations with Finite Sets\n3/12 RE\n3/21 WA\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n\nstruct set_st\n{\n  char name [10];\n  int num;\n  int elements[500];} sets[5];\n#define BUF_SIZ 100\nstruct set_st buf[BUF_SIZ];\nstruct set_st UALL;\nint bufptr;\nchar expr[1001];\nchar *bin_op=\"uids\";\n//\nvoid print_symbol_value()\n{\n  extern void print_st(struct set_st *);\n\n  int i,j,nn;\n  for(i=0;i<5;i++)\n    {\n      print_st(&(sets[i]));\n      printf(\"\\n\");\n    }\n  printf(\"-----------------\\n\");\n}\nint comp(void * x,void * y)\n{\n  return(*(int *)x-*(int *)y);\n}\nvoid print_st(struct set_st *setp)\n{\n  int i;\n  if(setp->num)\n    {\n      qsort(&(setp->elements[0]),setp->num,sizeof(int),(__compar_fn_t)comp);\n      for(i=0;i<setp->num;i++)\n\tprintf(\"%d \",setp->elements[i]);\n    }\n  else\n    printf(\"NULL\");\n  printf(\"\\n\");\n}\nstruct set_st *alloc_set_area()\n{\n    struct set_st *setp;\n    setp=&(buf[bufptr]);\n    bufptr++;\n    if(bufptr>BUF_SIZ)\n      bufptr=0;\n    setp->num=0;\n    return(setp);\n}\nvoid copy_set(struct set_st *to,struct set_st *from)\n{\n  memcpy(to,from,sizeof(struct set_st));\n}\nvoid make_universal_set()\n{\n  extern void add_element(struct set_st *,int);\n\n  int i,j;\n  UALL.num=0;\n  for(i=0;i<5;i++)\n    for(j=0;j<sets[i].num;j++)\n      add_element(&UALL,sets[i].elements[j]);\n      \n}\nvoid add_element(struct set_st *setp,int elm)\n{\n  int i;\n  for(i=0;i<setp->num;i++)\n    if(elm == setp->elements[i])\n      return;\n  setp->elements[(setp->num)++]=elm;\n}\nstruct set_st * calc_union(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i;\n  setp=alloc_set_area();\n  copy_set(setp,a1);\n  for(i=0;i<a2->num;i++)\n    add_element(setp,a2->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_intersect(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    for(j=0;j<a2->num;j++)\n      if(a1->elements[i]==a2->elements[j])\n\tadd_element(setp,a1->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  return(setp);\n}\nstruct set_st * calc_sym_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  for(i=0;i<a2->num;i++)\n    {\n      for(j=0;j<a1->num;j++)\n\tif(a1->elements[j]==a2->elements[i])\n\t  goto NEXT2;\n    \n\tadd_element(setp,a2->elements[i]);\n    NEXT2:;\n    }\n  return(setp);\n}\nstruct set_st * calc_expr1(struct set_st *a1,struct set_st *a2 ,char operator)\n{\n#if DEBUGX\n  printf(\"A1\");\n  print_st(a1);\n  printf(\"A2\");\n  print_st(a2);\n#endif\n  switch(operator){\n  case 'u':\n    return(calc_union(a1,a2));\n  case 'i':\n    return(calc_intersect(a1,a2));\n  case 'd':\n    return(calc_diff(a1,a2));\n  case 's':\n    return(calc_sym_diff(a1,a2));\n  default:\n    break;\n    }\n}\nstruct set_st * calc_cpl(struct set_st *a1)\n{\n  return(calc_diff(&UALL,a1));\n}\nstruct set_st * eval_symbol(char c)\n{\n  return(&(sets[c-'A']));\n}\nvoid clear_symbol()\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    sets[i].num=0;\n}\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op,s[i]);\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nvoid print_expr(char *s,int len)\n{\n  int i;\n\n  printf(\"Expr=\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n}\nstruct set_st *calc_expr(char *s,int len)\n{\n  char *r;\n#ifdef DEBUG\n  print_expr(s,len);\n#endif\n  if(len == 1 && strchr(\"ABCDE\",s[0]))\n    return(eval_symbol(s[0]));\n  r=find_bin_op(s,len);\n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  if(s[0]=='c')\n     return(calc_cpl(calc_expr(s+1,len-1)));\n  else   if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n    return(NULL);\n}\nmain()\n{\n  int i;\n  char c;\n  int n,setp;\n  struct set_st *r;\n\n  bufptr=0;\n START:\n  clear_symbol();\n      while(1)\n\t{\n\t  if(EOF==scanf(\"%c %d\",&c,&n))\n\t    goto END;\n\t  if((c=='R') && (n==0))\n\t    break;\n\t  setp=c-'A';\n\t  sets[setp].num=n;\n\t  for(i=0;i<n;i++)\n\t    scanf(\"%d \",&(sets[setp].elements[i]));\n\t}\n      make_universal_set();\n\n      fgets(expr,10,stdin);  //junp CRLF\n      fgets(expr,100,stdin);\n      \n      expr[strlen(expr)-1]='\\0';\n      //printf(\"e:%s\",expr);\n\n      r=calc_expr(expr,strlen(expr));\n      print_st(r);\n      //print_st(calc_expr(expr,strlen(expr)));\n      //print_symbol_value();\n      goto START;\nEND:\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x40 - 0x80 */\n\t\t\t\tif(now<0x60)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x40 - 0x60 */\n\t\t\t\tif(now<0x50)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now<0x40)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 510\n\nint set[5][110], sLen[5];\nint uSet[MAX], uLen;\nint ans[MAX], aLen;\nchar buf[MAX], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint norm(int *a, int len)\n{\n\tint i, j;\n\n\tif (len <= 0) return 0;\n\tqsort(a, len, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < len; j++) {\n\t\tif (a[j] != a[i]) {\n\t\t\tif (++i != j) a[i] = a[j];\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint bsch(int x, int *a, int len)\n{\n\tint m, l = 0, r = len-1;\n\n\tif (len <= 0) return 0;\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (*(a+m) == x) return 1;\n        if (*(a+m) < x) l = m + 1; else r = m;\n    }\n\treturn *(a+l) == x;\n}\n\nint factor(int *a)\n{\n\tint i, la, lx, f = 0;\n\tint *x;\n\n\twhile (*p == 'c') p++, f = !f;\n\tif (*p == '(') { p++; x = a, lx = expr(x); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tint id = *p++ - 'A';\n\t\tx = set[id], lx = sLen[id];\n\t} else while (1);  // panic\n\tif (f) {\n\t\tfor (la = i = 0; i < uLen; i++) {\n\t\t\tif (!bsch(uSet[i], x, lx)) a[la++] = uSet[i];\n\t\t}\n\t} else {\n\t\tla = lx;\n\t\tif (x != a) memcpy(a, x, sizeof(int)*la);\n\t}\n\treturn la;\n}\n\nint expr(int *x)\n{\n\tint i, lx, ly, lz, op;\n\tint *y, *z;\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\ty = calloc(MAX, sizeof(int));\n\t\tly = factor(y);\n\t\tz = calloc(MAX, sizeof(int)); lz = 0;\n\t\tif (op == 'u') {\n\t\t\tlz = lx, memcpy(z, x, sizeof(int)*lz);\n\t\t\tfor (i = 0; i < ly; i++) z[lz++] = y[i];\n\t\t\tlz = norm(z, lz);\n\t\t} else if (op == 'i') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (!bsch(y[i], x, lx))\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tlx = lz, memcpy(x, z, sizeof(int)*lz);\n\t\tlx = norm(x, lx);\n\t\tfree(z);\n\t\tfree(y);\n\t}\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(sLen, 0, sizeof(sLen)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tif (*s < 'A' || *s > 'E') while (1);  // panic\n\t\t\tid = *s - 'A';\n\t\t\tif (sLen[id] > 0) while (1); // panic\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tsLen[id] = norm(set[id], n);\n\t\t}\n\t\tuLen = norm(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = norm(ans, aLen);\n\t\tif (aLen == 0) putchar('\\n');\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1012\nTitle Operations with Finite Sets\n3/12 RE\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n\nstruct set_st\n{\n  char name [10];\n  int num;\n  int elements[500];} sets[5];\n#define BUF_SIZ 100\nstruct set_st buf[BUF_SIZ];\nstruct set_st UALL;\nint bufptr;\nchar expr[1001];\nchar *bin_op=\"uids\";\n//\nvoid print_symbol_value()\n{\n  extern void print_st(struct set_st *);\n\n  int i,j,nn;\n  for(i=0;i<5;i++)\n    {\n      print_st(&(sets[i]));\n      printf(\"\\n\");\n    }\n  printf(\"-----------------\\n\");\n}\nint comp(void * x,void * y)\n{\n  return(*(int *)x-*(int *)y);\n}\nvoid print_st(struct set_st *setp)\n{\n  int i;\n  if(setp->num)\n    {\n      qsort(&(setp->elements[0]),setp->num,sizeof(int),(__compar_fn_t)comp);\n      for(i=0;i<setp->num;i++)\n\tprintf(\"%d \",setp->elements[i]);\n    }\n  else\n    printf(\"NULL\");\n  printf(\"\\n\");\n}\nstruct set_st *alloc_set_area()\n{\n    struct set_st *setp;\n    setp=&(buf[bufptr]);\n    bufptr++;\n    if(bufptr>BUF_SIZ)\n      bufptr=0;\n    setp->num=0;\n    return(setp);\n}\nvoid copy_set(struct set_st *to,struct set_st *from)\n{\n  memcpy(to,from,sizeof(struct set_st));\n}\nvoid make_universal_set()\n{\n  extern void add_element(struct set_st *,int);\n\n  int i,j;\n  UALL.num=0;\n  for(i=0;i<5;i++)\n    for(j=0;j<sets[i].num;j++)\n      add_element(&UALL,sets[i].elements[j]);\n      \n}\nvoid add_element(struct set_st *setp,int elm)\n{\n  int i;\n  for(i=0;i<setp->num;i++)\n    if(elm == setp->elements[i])\n      return;\n  setp->elements[(setp->num)++]=elm;\n}\nstruct set_st * calc_union(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i;\n  setp=alloc_set_area();\n  copy_set(setp,a1);\n  for(i=0;i<a2->num;i++)\n    add_element(setp,a2->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_intersect(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    for(j=0;j<a2->num;j++)\n      if(a1->elements[i]==a2->elements[j])\n\tadd_element(setp,a1->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  return(setp);\n}\nstruct set_st * calc_sym_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  for(i=0;i<a2->num;i++)\n    {\n      for(j=0;j<a1->num;j++)\n\tif(a1->elements[j]==a2->elements[i])\n\t  goto NEXT2;\n    \n\tadd_element(setp,a2->elements[i]);\n    NEXT2:;\n    }\n  return(setp);\n}\nstruct set_st * calc_expr1(struct set_st *a1,struct set_st *a2 ,char operator)\n{\n#if DEBUG\n  printf(\"A1\");\n  print_st(a1);\n  printf(\"A2\");\n  print_st(a2);\n#endif\n  switch(operator){\n  case 'u':\n    return(calc_union(a1,a2));\n  case 'i':\n    return(calc_intersect(a1,a2));\n  case 'd':\n    return(calc_diff(a1,a2));\n  case 's':\n    return(calc_sym_diff(a1,a2));\n  default:\n    break;\n    }\n}\nstruct set_st * calc_cpl(struct set_st *a1)\n{\n  return(calc_diff(&UALL,a1));\n}\nstruct set_st * eval_symbol(char c)\n{\n  return(&(sets[c-'A']));\n}\nvoid clear_symbol()\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    sets[i].num=0;\n}\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=0;i<len;i++)\n    { \n      if(s[i]=='(')\n\td++;\n      else if (s[i]==')')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op,s[i]);\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nvoid print_expr(char *s,int len)\n{\n  int i;\n\n  printf(\"Expr=\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n}\nstruct set_st *calc_expr(char *s,int len)\n{\n  char *r;\n#ifdef DEBUG\n  print_expr(s,len);\n#endif\n  if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n  if(len == 1 && strchr(\"ABCDE\",s[0]))\n    return(eval_symbol(s[0]));\n  r=find_bin_op(s,len);\n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  if(s[0]=='c')\n     return(calc_cpl(calc_expr(s+1,len-1)));\n  else\n    return(NULL);\n}\nmain()\n{\n  int i;\n  char c;\n  int n,setp;\n  struct set_st *r;\n\n  bufptr=0;\n START:\n  clear_symbol();\n      while(1)\n\t{\n\t  if(EOF==scanf(\"%c %d\",&c,&n))\n\t    goto END;\n\t  if((c=='R') && (n==0))\n\t    break;\n\t  setp=c-'A';\n\t  sets[setp].num=n;\n\t  for(i=0;i<n;i++)\n\t    scanf(\"%d \",&(sets[setp].elements[i]));\n\t}\n      make_universal_set();\n\n      fgets(expr,10,stdin);  //junp CRLF\n      fgets(expr,100,stdin);\n      \n      expr[strlen(expr)-1]='\\0';\n      //printf(\"e:%s\",expr);\n\n      r=calc_expr(expr,strlen(expr));\n      print_st(r);\n      //print_st(calc_expr(expr,strlen(expr)));\n      //print_symbol_value();\n      goto START;\nEND:\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!='\\r' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1012\nTitle\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nstruct set_st\n{\n  char name [10];\n  int num;\n  int elements[100];} sets[5];\n#define BUF_SIZ 100\nstruct set_st buf[BUF_SIZ];\nstruct set_st UALL;\nint bufptr;\nchar expr[1001];\nchar *bin_op=\"uids\";\n//\nvoid print_symbol_value()\n{\n  extern void print_st(struct set_st *);\n\n  int i,j,nn;\n  for(i=0;i<5;i++)\n    {\n      print_st(&(sets[i]));\n      printf(\"\\n\");\n    }\n  printf(\"-----------------\\n\");\n}\nint comp(void * x,void * y)\n{\n  return(*(int *)x-*(int *)y);\n}\nvoid print_st(struct set_st *setp)\n{\n  int i;\n  if(setp->num)\n    {\n      qsort(&(setp->elements[0]),setp->num,sizeof(int),(__compar_fn_t)comp);\n      for(i=0;i<setp->num;i++)\n\tprintf(\"%d \",setp->elements[i]);\n    }\n  else\n    printf(\"NULL\");\n  printf(\"\\n\");\n}\nstruct set_st *alloc_set_area()\n{\n    struct set_st *setp;\n    setp=&(buf[bufptr]);\n    bufptr++;\n    if(bufptr>BUF_SIZ)\n      bufptr=0;\n    setp->num=0;\n    return(setp);\n}\nvoid copy_set(struct set_st *to,struct set_st *from)\n{\n  memcpy(to,from,sizeof(struct set_st));\n}\nvoid make_universal_set()\n{\n  extern void add_element(struct set_st *,int);\n\n  int i,j;\n  UALL.num=0;\n  for(i=0;i<5;i++)\n    for(j=0;j<sets[i].num;j++)\n      add_element(&UALL,sets[i].elements[j]);\n      \n}\nvoid add_element(struct set_st *setp,int elm)\n{\n  int i;\n  for(i=0;i<setp->num;i++)\n    if(elm == setp->elements[i])\n      return;\n  setp->elements[(setp->num)++]=elm;\n}\nstruct set_st * calc_union(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i;\n  setp=alloc_set_area();\n  copy_set(setp,a1);\n  for(i=0;i<a2->num;i++)\n    add_element(setp,a2->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_intersect(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    for(j=0;j<a2->num;j++)\n      if(a1->elements[i]==a2->elements[j])\n\tadd_element(setp,a1->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  return(setp);\n}\nstruct set_st * calc_sym_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  for(i=0;i<a2->num;i++)\n    {\n      for(j=0;j<a1->num;j++)\n\tif(a1->elements[j]==a2->elements[i])\n\t  goto NEXT2;\n    \n\tadd_element(setp,a2->elements[i]);\n    NEXT2:;\n    }\n  return(setp);\n}\nstruct set_st * calc_expr1(struct set_st *a1,struct set_st *a2 ,char operator)\n{\n#if DEBUG\n  printf(\"A1\");\n  print_st(a1);\n  printf(\"A2\");\n  print_st(a2);\n#endif\n  switch(operator){\n  case 'u':\n    return(calc_union(a1,a2));\n  case 'i':\n    return(calc_intersect(a1,a2));\n  case 'd':\n    return(calc_diff(a1,a2));\n  case 's':\n    return(calc_sym_diff(a1,a2));\n  default:\n    break;\n    }\n}\nstruct set_st * calc_cpl(struct set_st *a1)\n{\n  return(calc_diff(&UALL,a1));\n}\nstruct set_st * eval_symbol(char c)\n{\n  return(&(sets[c-'A']));\n}\nvoid clear_symbol()\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    sets[i].num=0;\n}\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=0;i<len;i++)\n    { \n      if(s[i]=='(')\n\td++;\n      else if (s[i]==')')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op,s[i]);\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nvoid print_expr(char *s,int len)\n{\n  int i;\n\n  printf(\"Expr=\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n}\nstruct set_st *calc_expr(char *s,int len)\n{\n  char *r;\n#ifdef DEBUG\n  print_expr(s,len);\n#endif\n  if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n  if(len == 1 && strchr(\"ABCDE\",s[0]))\n    return(eval_symbol(s[0]));\n  r=find_bin_op(s,len);\n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  if(s[0]=='c')\n     return(calc_cpl(calc_expr(s+1,len-1)));\n  else\n    return(NULL);\n}\nmain()\n{\n  int i;\n  char c;\n  int n,setp;\n  struct set_st *r;\n\n  bufptr=0;\n START:\n  clear_symbol();\n      while(1)\n\t{\n\t  if(EOF==scanf(\"%c %d\",&c,&n))\n\t    goto END;\n\t  if((c=='R') && (n==0))\n\t    break;\n\t  setp=c-'A';\n\t  sets[setp].num=n;\n\t  for(i=0;i<n;i++)\n\t    scanf(\"%d \",&(sets[setp].elements[i]));\n\t}\n      make_universal_set();\n\n      fgets(expr,10,stdin);  //junp CRLF\n      fgets(expr,100,stdin);\n      expr[strlen(expr)-1]='\\0';\n      //printf(\"e:%s\",expr);\n\n      r=calc_expr(expr,strlen(expr));\n      print_st(r);\n      //print_st(calc_expr(expr,strlen(expr)));\n      //print_symbol_value();\n      goto START;\nEND:\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1012\nTitle Operations with Finite Sets\n3/12 RE\n3/21 WA // hidari ketugou\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n\nstruct set_st\n{\n  char name [10];\n  int num;\n  int elements[500];} sets[5];\n#define BUF_SIZ 100\nstruct set_st buf[BUF_SIZ];\nstruct set_st UALL;\nint bufptr;\nchar expr[1001];\nchar *bin_op=\"uids\";\n//\nvoid print_symbol_value()\n{\n  extern void print_st(struct set_st *);\n\n  int i,j,nn;\n  for(i=0;i<5;i++)\n    {\n      print_st(&(sets[i]));\n      printf(\"\\n\");\n    }\n  printf(\"-----------------\\n\");\n}\nint comp(void * x,void * y)\n{\n  return(*(int *)x-*(int *)y);\n}\nvoid print_st(struct set_st *setp)\n{\n  int i;\n  if(setp->num)\n    {\n      qsort(&(setp->elements[0]),setp->num,sizeof(int),(__compar_fn_t)comp);\n      for(i=0;i<setp->num;i++)\n\t{\n\t  printf(\"%d\",setp->elements[i]);\n\t  if(i<setp->num-1)\n\t    printf(\" \");\n\t}\n    }\n  else\n    printf(\"NULL\");\n  printf(\"\\n\");\n}\nstruct set_st *alloc_set_area()\n{\n    struct set_st *setp;\n    setp=&(buf[bufptr]);\n    bufptr++;\n    if(bufptr>BUF_SIZ)\n      bufptr=0;\n    setp->num=0;\n    return(setp);\n}\nvoid copy_set(struct set_st *to,struct set_st *from)\n{\n  memcpy(to,from,sizeof(struct set_st));\n}\nvoid make_universal_set()\n{\n  extern void add_element(struct set_st *,int);\n\n  int i,j;\n  UALL.num=0;\n  for(i=0;i<5;i++)\n    for(j=0;j<sets[i].num;j++)\n      add_element(&UALL,sets[i].elements[j]);\n      \n}\nvoid add_element(struct set_st *setp,int elm)\n{\n  int i;\n  for(i=0;i<setp->num;i++)\n    if(elm == setp->elements[i])\n      return;\n  setp->elements[(setp->num)++]=elm;\n}\nstruct set_st * calc_union(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i;\n  setp=alloc_set_area();\n  copy_set(setp,a1);\n  for(i=0;i<a2->num;i++)\n    add_element(setp,a2->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_intersect(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    for(j=0;j<a2->num;j++)\n      if(a1->elements[i]==a2->elements[j])\n\tadd_element(setp,a1->elements[i]);\n  return(setp);\n}\nstruct set_st * calc_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  return(setp);\n}\nstruct set_st * calc_sym_diff(struct set_st *a1,struct set_st *a2 )\n{\n  struct set_st *setp;\n\n  int i,j;\n  setp=alloc_set_area();\n  for(i=0;i<a1->num;i++)\n    {\n      for(j=0;j<a2->num;j++)\n\tif(a1->elements[i]==a2->elements[j])\n\t  goto NEXT;\n    \n\tadd_element(setp,a1->elements[i]);\n    NEXT:;\n    }\n  for(i=0;i<a2->num;i++)\n    {\n      for(j=0;j<a1->num;j++)\n\tif(a1->elements[j]==a2->elements[i])\n\t  goto NEXT2;\n    \n\tadd_element(setp,a2->elements[i]);\n    NEXT2:;\n    }\n  return(setp);\n}\nstruct set_st * calc_expr1(struct set_st *a1,struct set_st *a2 ,char operator)\n{\n#if DEBUGX\n  printf(\"A1\");\n  print_st(a1);\n  printf(\"A2\");\n  print_st(a2);\n#endif\n  switch(operator){\n  case 'u':\n    return(calc_union(a1,a2));\n  case 'i':\n    return(calc_intersect(a1,a2));\n  case 'd':\n    return(calc_diff(a1,a2));\n  case 's':\n    return(calc_sym_diff(a1,a2));\n  default:\n    break;\n    }\n}\nstruct set_st * calc_cpl(struct set_st *a1)\n{\n  return(calc_diff(&UALL,a1));\n}\nstruct set_st * eval_symbol(char c)\n{\n  return(&(sets[c-'A']));\n}\nvoid clear_symbol()\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    sets[i].num=0;\n}\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op,s[i]);\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nvoid print_expr(char *s,int len)\n{\n  int i;\n\n  printf(\"Expr=\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n}\nstruct set_st *calc_expr(char *s,int len)\n{\n  char *r;\n#ifdef DEBUG\n  print_expr(s,len);\n#endif\n  if(len == 1 && strchr(\"ABCDE\",s[0]))\n    return(eval_symbol(s[0]));\n  r=find_bin_op(s,len);\n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  if(s[0]=='c')\n     return(calc_cpl(calc_expr(s+1,len-1)));\n  else   if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n    return(NULL);\n}\nmain()\n{\n  int i;\n  char c;\n  int n,setp;\n  struct set_st *r;\n\n  bufptr=0;\n START:\n  clear_symbol();\n      while(1)\n\t{\n\t  if(EOF==scanf(\"%c %d\",&c,&n))\n\t    goto END;\n\t  if((c=='R') && (n==0))\n\t    break;\n\t  setp=c-'A';\n\t  sets[setp].num=n;\n\t  for(i=0;i<n;i++)\n\t    scanf(\"%d \",&(sets[setp].elements[i]));\n\t}\n      make_universal_set();\n\n      fgets(expr,10,stdin);  //junp CRLF\n      fgets(expr,100,stdin);\n      \n      expr[strlen(expr)-1]='\\0';\n      //printf(\"e:%s\",expr);\n\n      r=calc_expr(expr,strlen(expr));\n      print_st(r);\n      //print_st(calc_expr(expr,strlen(expr)));\n      //print_symbol_value();\n      goto START;\nEND:\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\nint set[5][110], len[5];\nint uSet[MAX], uLen;\nint ans[MAX], aLen;\nchar buf[MAX], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint reform(int *a, int alen)\n{\n\tint i, j;\n\n\tif (alen <= 0) return 0;\n\tqsort(a, alen, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < alen; j++) {\n\t\tif (a[j] != a[i])\n\t\t\tif (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint factor(int *a)\n{\n\tint i, l, id, f = 0;\n\n\tif (*p == '(') { p++; l = expr(a); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tid = *p++ - 'A', l = len[id];\n\t\tmemcpy(a, set[id], sizeof(int)*l);\n\t} else if (*p == 'c') {\n\t\tp++; id = *p++ - 'A';\n\t\tfor (l = i = 0; i < uLen; i++) {\n\t\t\tif (bsearch(uSet+i, set[id], len[id], sizeof(int), cmp) == NULL)\n\t\t\t\ta[l++] = uSet[i];\n\t\t}\n\t}\n\treturn l;\n}\n\nint expr(int *x)\n{\n\tint i, lx, ly, lz, op;\n\tint *y, *z;\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\ty = calloc(MAX, sizeof(int));\n\t\tly = factor(y);\n\t\tz = calloc(MAX, sizeof(int));\n\t\tif (op == 'u') {\n\t\t\tmemcpy(z, x, sizeof(int)*lx);\n\t\t\tmemcpy(z + lx, y, sizeof(int)*ly);\n\t\t\tlz = reform(z, lx + ly);\n\t\t} else if (op == 'i') {\n\t\t\tfor (lz = i = 0; i < lx; i++) {\n\t\t\t\tif (bsearch(x+i, y, ly, sizeof(int), cmp) != NULL)\tz[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (lz = i = 0; i < lx; i++) {\n\t\t\t\tif (bsearch(x+i, y, ly, sizeof(int), cmp) == NULL)\tz[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (lz = i = 0; i < lx; i++) {\n\t\t\t\tif (bsearch(x+i, y, ly, sizeof(int), cmp) == NULL)\tz[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (bsearch(y+i, x, lx, sizeof(int), cmp) == NULL)\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tmemcpy(x, z, sizeof(int)*lz);\n\t\tlx = reform(x, lz);\n\t\tfree(z);\n\t\tfree(y);\n\t}\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(len, 0, sizeof(len)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tid = *s - 'A', len[id] = n;\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tqsort(set[id], n, sizeof(int), cmp);\n\t\t}\n\t\tuLen = reform(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = reform(ans, aLen);\n\t\tif (aLen == 0) putchar('\\n');\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:/* 0x50 - 0x54 */\n\t\t\t\tif(now<0x52)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(now<0x80)exit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1012: Operations with Finite Sets\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 510\n\nint set[5][110], sLen[5];\nint uSet[MAX], uLen;\nint ans[MAX], aLen;\nchar buf[MAX], *p;\n\nint cmp(int *a, int *b) { return *a - *b; }\nint expr(int *a);\n\nint norm(int *a, int len)\n{\n\tint i, j;\n\n\tif (len <= 0) return 0;\n\tqsort(a, len, sizeof(int), cmp);\n\tfor (i = 0, j = 1; j < len; j++) {\n\t\tif (a[j] != a[i]) {\n\t\t\tif (++i != j) a[i] = a[j];\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint bsch(int x, int *a, int len)\n{\n\tint m, l = 0, r = len-1;\n\n\tif (len <= 0) return 0;\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (*(a+m) == x) return 1;\n        if (*(a+m) < x) l = m + 1; else r = m;\n    }\n\treturn *(a+l) == x;\n}\n\nint factor(int *a)\n{\n\tint i, la, lx, f = 0;\n\tint *x;\n\n\twhile (*p == 'c') p++, f = !f;\n\tif (*p == '(') { p++; x = a, lx = expr(x); p++; }\n\telse if (*p >= 'A' && *p <= 'E') {\n\t\tint id = *p++ - 'A';\n\t\tx = set[id], lx = sLen[id];\n\t} else while (1);  // panic\n\tif (f) {\n\t\tfor (la = i = 0; i < uLen; i++) {\n\t\t\tif (!bsch(uSet[i], x, lx)) a[la++] = uSet[i];\n\t\t}\n\t} else {\n\t\tla = lx;\n\t\tif (x != a) memcpy(a, x, sizeof(int)*la);\n\t}\n\treturn la;\n}\n\nint expr(int *x)\n{\n\tint i, lx, ly, lz, op;\n\tint *y, *z;\n\n\tlx = factor(x);\n\twhile (1) {\n\t\top = *p;\n\t\tif (op == 'u' || op == 'i' || op == 'd' || op == 's') p++;\n\t\telse break;\n\t\ty = calloc(MAX, sizeof(int));\n\t\tly = factor(y);\n\t\tz = calloc(MAX, sizeof(int)); lz = 0;\n\t\tif (op == 'u') {\n\t\t\tlz = lx, memcpy(z, x, sizeof(int)*lz);\n\t\t\tfor (i = 0; i < ly; i++) z[lz++] = y[i];\n\t\t\tlz = norm(z, lz);\n\t\t} else if (op == 'i') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else if (op == 'd') {\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t} else {  // op == 's'\n\t\t\tfor (i = 0; i < lx; i++) {\n\t\t\t\tif (!bsch(x[i], y, ly)) z[lz++] = x[i];\n\t\t\t}\n\t\t\tfor (i = 0; i < ly; i++) {\n\t\t\t\tif (!bsch(y[i], x, lx))\tz[lz++] = y[i];\n\t\t\t}\n\t\t}\n\t\tlx = lz, memcpy(x, z, sizeof(int)*lz);\n\t\tlx = norm(x, lx);\n\t\tfree(z);\n\t\tfree(y);\n\t}\n\treturn lx;\n}\n\nint main()\n{\n\tint n, i, id, a;\n\tchar s[5];\n\n\twhile (1) {\n\t\tmemset(sLen, 0, sizeof(sLen)), uLen = 0;\n\t\twhile (1) {\n\t\t\tif (scanf(\"%s%d\", s, &n) != 2) return 0;\n\t\t\tif (*s == 'R') break;\n\t\t\tif (*s < 'A' || *s > 'E') while (1);  // panic\n\t\t\tid = *s - 'A';\n\t\t\tif (sLen[id] > 0) while (1); // panic\n\t\t\tfor (i = 0; i < n; i++) scanf(\"%d\", &a), set[id][i] = a, uSet[uLen++] = a;\n\t\t\tsLen[id] = norm(set[id], n);\n\t\t}\n\t\tuLen = norm(uSet, uLen);\n\n\t\tscanf(\"%s\", buf); p = buf;\n\t\taLen = expr(ans);\n\t\taLen = norm(ans, aLen);\n\t\tif (aLen == 0) puts(\"NULL\");\n\t\telse {\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor (i = 1; i < aLen; i++) printf(\" %d\", ans[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t0\n#define ERROR_INVALID_EXPRESSION\t0\n#define ERROR_INVALID_STACK\t\t\t0\n#define ERROR_INVALID_CALCULATION\t0\n#define ERROR_INVALID_RESULT\t\t0\n#define ERROR_LIMIT_EXCEEDED\t\t0\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\t\t{\n\t\t\tint buf;\n\t\t\tif((buf=getchar())=='\\n')exit(-1);/* so-syo */\n\t\t\tungetc(buf,stdin);\n\t\t}\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t0\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*exit(2);*/\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(4);\n\t\t}\n\t}\n\tif(stack_num!=1)exit(5);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return 1;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t0\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t0\n#define ERROR_INVALID_CALCULATION\t0\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t0\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(2);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(3);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(4);\n\t\t}\n\t}\n\tif(stack_num!=1)exit(5);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return 1;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[6];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(0);\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR_WRONG_SET_NAME\t\t1\n#define ERROR_INVALID_EXPRESSION\t2\n#define ERROR_INVALID_STACK\t\t\t3\n#define ERROR_INVALID_CALCULATION\t4\n#define ERROR_INVALID_RESULT\t\t5\n#define ERROR_LIMIT_EXCEEDED\t\t6\t\n\nenum {\n\tTYPE_SET,\n\tTYPE_UNION,\n\tTYPE_INTERSECTION,\n\tTYPE_DIFFERENCE,\n\tTYPE_SYMMETRIC_DIFFERENCE,\n\tTYPE_CONPLEMENT,\n\tTYPE_BRACKET\n};\n\n#define SYSTEM_LIMIT 1000000\n\nint qsort_comp(const void* x,const void* y) {\n\tconst int* a=(const int*)x;\n\tconst int* b=(const int*)y;\n\tif(*a>*b)return 1;\n\tif(*a<*b)return -1;\n\treturn 0;\n}\n\ntypedef struct {\n\t/* 8*64==512>500 */\n\tunsigned long long list[8];\n} set_t;\n\ntypedef struct {\n\tint type;\n\tint value;\n} rp_t;\n\nint element_raw_num;\nint element_num;\nint elements_raw[500];\nint elements[500];\nset_t sets[7];\nint set_num[5];\nint set_elements[5][100];\n\nint stack_num;\nint operator_stack[SYSTEM_LIMIT];\nset_t calc_stack[SYSTEM_LIMIT];\nint rp_num;\nrp_t rp[SYSTEM_LIMIT];\n\nint search_element(int element) {\n\tint left,right,mid;\n\tleft=0;right=element_num-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(elements[mid]==element)return mid;\n\t\telse if(elements[mid]<element)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn -1;\n}\n\nvoid set_empty(set_t* set) {\n\tint i;\n\tfor(i=0;i<8;i++)set->list[i]=0;\n}\n\nvoid set_add(set_t* set,int toadd) {\n\tint pos=search_element(toadd);\n\tif(pos<0)return;\n\tset->list[pos/64]|=(1ull<<(pos%64));\n}\n\nint is_included(set_t* set,int pos) {\n\treturn set->list[pos/64] & (1ull<<(pos%64));\n}\n\nvoid compile_reverse_porland(void) {\n\tint now;\n\tstack_num=0;\n\trp_num=0;\n\twhile((now=getchar())!='\\n' && now!=EOF) {\n\t\tswitch(now) {\n\t\t\tcase 'A':case 'B':case 'C':case 'D':case 'E':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=now-'A';\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=5;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\trp[rp_num].type=TYPE_SET;\n\t\t\t\trp[rp_num].value=6;\n\t\t\t\trp_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_UNION;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_INTERSECTION;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\toperator_stack[stack_num++]=TYPE_SYMMETRIC_DIFFERENCE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\toperator_stack[stack_num++]=TYPE_CONPLEMENT;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\toperator_stack[stack_num++]=TYPE_BRACKET;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\toperator_stack[stack_num-1]!=TYPE_BRACKET) {\n\t\t\t\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_EXPRESSION);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t\tif(rp_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\twhile(stack_num>0) {\n\t\trp[rp_num++].type=operator_stack[--stack_num];\n\t}\n}\n\nset_t calc_reverse_porland(void) {\n\tint i,j;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i].type) {\n\t\t\tcase TYPE_SET:\n\t\t\t\tcalc_stack[stack_num++]=sets[rp[i].value];\n\t\t\t\tbreak;\n\t\t\tcase TYPE_UNION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]|=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INTERSECTION:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]&=\n\t\t\t\t\t\t~calc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_SYMMETRIC_DIFFERENCE:\n\t\t\t\tif(stack_num<2)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-2].list[j]^=\n\t\t\t\t\t\tcalc_stack[stack_num-1].list[j];\n\t\t\t\t}\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_CONPLEMENT:\n\t\t\t\tif(stack_num<1)exit(ERROR_INVALID_STACK);\n\t\t\t\tfor(j=0;j<8;j++) {\n\t\t\t\t\tcalc_stack[stack_num-1].list[j]=\n\t\t\t\t\t\t(~calc_stack[stack_num-1].list[j]) &\n\t\t\t\t\t\tsets[5].list[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(ERROR_INVALID_CALCULATION);\n\t\t}\n\t\tif(stack_num>=SYSTEM_LIMIT-1)exit(ERROR_LIMIT_EXCEEDED);\n\t}\n\tif(stack_num!=1)exit(ERROR_INVALID_RESULT);\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tint now_set_num;\n\tchar setname[4];\n\tint i,j;\n\tset_t result;\n\tint found;\n\twhile(scanf(\"%s%d\",setname,&now_set_num)==2) {\n\t\t/* load sets */\n\t\telement_raw_num=0;\n\t\tset_num[0]=set_num[1]=set_num[2]=set_num[3]=set_num[4]=0;\n\t\tfor(i=0;i<5;i++) {\n\t\t\tif(i!=0)scanf(\"%s%d\",setname,&now_set_num);\n\t\t\tif(now_set_num==0)break;\n\t\t\tif(now_set_num<0 || now_set_num>100)return ERROR_LIMIT_EXCEEDED;\n\t\t\tif(setname[0]<'A' || setname[0]>'E')return ERROR_WRONG_SET_NAME;\n\t\t\tset_num[setname[0]-'A']=now_set_num;\n\t\t\tfor(j=0;j<now_set_num;j++) {\n\t\t\t\tint buf;\n\t\t\t\tscanf(\"%d\",&buf);\n\t\t\t\tset_elements[setname[0]-'A'][j]=buf;\n\t\t\t\telements_raw[element_raw_num++]=buf;\n\t\t\t}\n\t\t}\n\t\twhile(getchar()!='\\n');\n\n\t\t/* make element list */\n\t\tqsort(elements_raw,element_raw_num,sizeof(int),qsort_comp);\n\t\telement_num=0;\n\t\tfor(i=0;i<element_raw_num;i++) {\n\t\t\tif(i==0 || elements_raw[i-1]!=elements_raw[i]) {\n\t\t\t\telements[element_num++]=elements_raw[i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++) {\n\t\t\tset_empty(&sets[i]);\n\t\t\tfor(j=0;j<set_num[i];j++) {\n\t\t\t\tset_add(&sets[i],set_elements[i][j]);\n\t\t\t}\n\t\t}\n\t\t/* make set U */\n\t\tset_empty(&sets[5]);\n\t\tfor(i=0;i<element_num;i++)set_add(&sets[5],elements[i]);\n\t\t/* make set R */\n\t\tset_empty(&sets[6]);\n\n\t\t/* do calcuation */\n\t\tcompile_reverse_porland();\n\t\tresult=calc_reverse_porland();\n\n\t\t/* output result */\n\t\tfound=0;\n\t\tfor(i=0;i<element_num;i++) {\n\t\t\tif(is_included(&result,i)) {\n\t\t\t\tif(found)putchar(' ');\n\t\t\t\tprintf(\"%d\",elements[i]);\n\t\t\t\tfound=1;\n\t\t\t}\n\t\t}\n\t\tif(!found)printf(\"NULL\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(true) return;\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tif(line.length() <= 0) return;\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].equals(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.TreeSet;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, HashSet<Integer>> setsEnvironment;\n\tHashSet<Integer> setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, HashSet<Integer>>();\n\n\t\tsetU = new HashSet<Integer>();\n\n\t\t/*\n\t\tHashSet<Integer> setA = new HashSet<Integer>();\n\t\tsetA.add(2);\n\t\tsetA.add(4);\n\t\tsetA.add(6);\n\t\tsetA.add(8);\n\n\t\tHashSet<Integer> setB = new HashSet<Integer>();\n\t\tsetB.add(2);\n\t\tsetB.add(6);\n\t\tsetB.add(9);\n\t\tsetB.add(10);\n\n\t\tSystem.out.println(i(setA, setB));\n\t\t*/\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\t//int num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\tHashSet<Integer> resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tTreeSet<Integer> resultTreeSet = new TreeSet<Integer>(resultSet);\n\t\t\t\t\tInteger resultArray[] = (Integer[])resultTreeSet.toArray(new Integer[0]);\n\n\t\t\t\t\tSystem.out.print(resultArray[0]);\n\t\t\t\t\tfor(int i = 1; i < resultArray.length; i++){\n\t\t\t\t\t\tSystem.out.print(\" \" + resultArray[i]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\n\t\t\t\t\tsetU = new HashSet<Integer>();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, HashSet<Integer>>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tHashSet<Integer> calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t//System.out.println(leftStr);\n\t\t\t//System.out.println(rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tHashSet<Integer> leftSet = calc(leftStr);\n\t\t\tHashSet<Integer> rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic HashSet<Integer> u(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic HashSet<Integer> i(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic HashSet<Integer> d(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic HashSet<Integer> s(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].equals(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Main {\n    static class Calculator {\n        private final Map<Character, Set<Integer>> sets;\n        private final char[] input;\n        private final Set<Integer> U;\n        private int ptr = 0;\n\n        public Calculator(Map<Character, Set<Integer>> sets, char[] expr) {\n            this.sets = sets;\n            this.input = expr;\n            Set<Integer> U = new HashSet<Integer>();\n            for (Set<Integer> set: sets.values()) {\n                U.addAll(set);\n            }\n            this.U = U;\n        }\n\n        private Set<Integer> expr() {\n            Set<Integer> value = term();\n            while (ptr < input.length) {\n                if (input[ptr] == 'u') {\n                    ptr++;\n                    value.addAll(term());\n                } else if (input[ptr] == 'i') {\n                    ptr++;\n                    value.retainAll(term());\n                } else if (input[ptr] == 'd') {\n                    ptr++;\n                    value.removeAll(term());\n                } else if (input[ptr] == 's') {\n                    ptr++;\n                    Set<Integer> A = value;\n                    Set<Integer> A1 = new HashSet<Integer>(A);\n                    Set<Integer> B = term();\n                    Set<Integer> B1 = new HashSet<Integer>(B);\n                    A1.removeAll(B);\n                    B1.removeAll(A);\n                    A1.addAll(B1);\n                    value = A1;\n                } else {\n                    break;\n                }\n            }\n            return value;\n        }\n\n        private Set<Integer> term() {\n            Set<Integer> value;\n            if (input[ptr] == 'c') {\n                ptr++;\n                value = new HashSet<Integer>(U);\n                value.removeAll(factor());\n            } else {\n                value = factor();\n            }\n            return value;\n        }\n\n        private Set<Integer> factor() {\n            Set<Integer> value;\n            if (input[ptr] == '(') {\n                ptr++;\n                value = expr();\n                assert input[ptr] == ')';\n                ptr++;\n            } else {\n                value = new HashSet<Integer>(sets.get(input[ptr]));\n                ptr++;\n            }\n            return value;\n        }\n\n        public Set<Integer> run() {\n            return expr();\n        }\n    }\n\n    private static void solve() {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            Map<Character, Set<Integer>> sets = \n                new HashMap<Character, Set<Integer>>();\n            Set<Integer> result;\n            while (true) {\n                char name = scanner.next().charAt(0);\n                int n = scanner.nextInt();\n                if (name == 'R') {\n                    char[] expr = scanner.next().toCharArray();\n                    result = new Calculator(sets, expr).run();\n                    break;\n                } else {\n                    Set<Integer> value = new HashSet<Integer>();\n                    for (int i = 0; i < n; i++) {\n                        value.add(scanner.nextInt());\n                    }\n                    sets.put(name, value);\n                }\n            }\n            boolean space = false;\n            Object[] elements = result.toArray();\n            Arrays.sort(elements);\n            for (Object e: elements) {\n                if (space) {\n                    System.out.print(' ');\n                }\n                System.out.print(e);\n                space = true;\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t\tif(true) return;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res.length>0&&res.length<501){\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\tif(exp.length()<1){\n\t\t\treturn new Expression();\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t\te = null;\n\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\te = new Expression('c',parse(p));\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\tif(!opfound){\n\t\t\tif(exp.charAt(0)=='('){\n\t\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t\t} else {\n\t\t\t\t//if(exp.length()==1){\n\t\t\t\treturn new Expression(exp);\n\t\t\t\t//} else {\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\tres[0] = -1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nclass Expression {\n\tpublic char op;\n\tpublic String end;\n\tpublic Expression left,right;\n\t//blank node\n\tpublic Expression(){\n\t\tthis.op = 'n';\n\t}\n\t//leaf node\n\tpublic Expression(String s){\n\t\tthis.op = '-';\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.end = s;\n\t}\n\t//complement\n\tpublic Expression(char op, Expression left){\n\t\tthis.op = op;\n\t\tthis.left = left;\n\t}\n\t//other operands\n\tpublic Expression(char op, Expression left, Expression right){\n\t\tthis.op = op;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\tpublic void output(){\n\t\tSystem.out.print(\"(\");\n\t\tif(left==null&&right==null){\n\t\t\tSystem.out.print(this.end);\n\t\t} else if(op=='c'){\n\t\t\tSystem.out.print(op + \" \");\n\t\t\tleft.output();\n\t\t} else if(right==null){\n\t\t\tleft.output();\n\t\t} else {\n\t\t\tSystem.out.print(op + \" \");\n\t\t\tleft.output(); \n\t\t\tSystem.out.print(\" \");\n\t\t\tright.output();\n\t\t}\n\t\tSystem.out.print(\")\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//D: Operations with Finite Sets\npublic class Main{\n\n\tstatic Set<Integer> u;\n\tstatic Set<Integer>[] set;\n\tstatic Map<String, Integer> ref;\n\n\tstatic char[] s;\n\tstatic int index;\n\n\tstatic char c(){\n\t\treturn s[index++];\n\t}\n\n\tstatic Set<Integer> exp(){\n\t\tSet<Integer> ans = fac();\n\t\twhile(index < s.length){\n\t\t\tchar c = c();\n\t\t\tif(c=='u'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.add(a);\n\t\t\t}\n\t\t\telse if(c=='i'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(ans.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse if(c=='d'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.remove(a);\n\t\t\t}\n\t\t\telse if(c=='s'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(!ans.contains(a))tmp.add(a);\n\t\t\t\tfor(int a:ans)if(!e.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic Set<Integer> fac(){\n\t\tchar c = c();\n\t\tif(c=='(')return exp();\n\t\tif(c!='c')\n\t\t\treturn set[ref.get(c+\"\")];\n\t\tint k = 1;\n\t\tc = c();\n\t\twhile(c=='c'){\n\t\t\tk++;\n\t\t\tc = c();\n\t\t}\n\t\tindex--;\n\t\tSet<Integer> ans = fac();\n\t\tif(k%2==1){\n\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\ttmp.addAll(u);\n\t\t\tfor(int a:ans)tmp.remove(a);\n\t\t\treturn tmp;\n\t\t}\n\t\telse{\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tu = new HashSet<Integer>();\n\t\t\tset = new HashSet[5];\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tint id = 0;\n\t\t\twhile(true){\n\t\t\t\tString n = sc.next();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tif(n.equals(\"R\"))break;\n\t\t\t\tref.put(n, id);\n\t\t\t\tset[id] = new HashSet<Integer>();\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tset[id].add(x);\n\t\t\t\t\tu.add(x);\n\t\t\t\t}\n\t\t\t\tid++;\n\t\t\t}\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tindex = 0;\n\t\t\tSet<Integer> a = exp();\n\t\t\tif(a.isEmpty())System.out.println(\"NULL\");\n\t\t\telse {\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\t\tfor(int i:a)q.add(i);\n\t\t\t\tboolean f = true;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tif(!f)System.out.print(\" \");\n\t\t\t\t\tf = false;\n\t\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, OriginalSet> setsEnvironment;\n\tOriginalSet setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\n\t\tsetU = new OriginalSet();\n\n\t\t/*\n\t\tOriginalSet setA = new OriginalSet();\n\t\tsetA.add(2);\n\t\tsetA.add(4);\n\t\tsetA.add(6);\n\t\tsetA.add(8);\n\n\t\tOriginalSet setB = new OriginalSet();\n\t\tsetB.add(2);\n\t\tsetB.add(6);\n\t\tsetB.add(9);\n\t\tsetB.add(10);\n\n\t\tSystem.out.println(i(setA, setB));\n\t\t*/\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\t//int num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tOriginalSet set = new OriginalSet();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\t// System.out.println(\"計算\");\n\t\t\t\t\tOriginalSet resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tresultSet.print();\n\n\t\t\t\t\tsetU = new OriginalSet();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tOriginalSet calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\t// System.out.print(\"演算子: \");\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t// System.out.println(leftStr + \", \" + rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tOriginalSet leftSet = calc(leftStr);\n\t\t\tOriginalSet rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\t// System.out.print(\"括弧除去: \");\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\tSystem.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// System.out.print(\"補集合: \");\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\t\t\t// System.out.println(\"補集合おわり\");\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\t// System.out.print(\"環境参照: \");\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t\t// System.out.println(\"環境参照おわり\");\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic OriginalSet u(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic OriginalSet i(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic OriginalSet d(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic OriginalSet s(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tArrays.sort(res);\n\t\t\t\tfor(Integer i : res){\n\t\t\t\t\tSystem.out.print(i+ \" \");\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\t//single term\n\t\tif(exp.length()<=2){\n\t\t\tExpression e = new Expression(exp);\n\t\t\treturn e;\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\t\t\t\t\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t\te = null;\n\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\te = new Expression('c',parse(exp.substring(2,index)));\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\tif(!opfound){\n\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t}\n\n\t\treturn e;\n\t}\n\t\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[500];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\tif(i==j){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\t\t\t\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\t\t\t\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\t\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\t\t\t\t\t\t\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left,right;\n\t\tpublic Expression (String s){\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\t\t//complement\n\t\tpublic Expression(char op, Expression left){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\t\t//other operands\n\t\tpublic Expression(char op, Expression left, Expression right){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tpublic void output(){\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif(left==null&&right==null){\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if(op=='c'){\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if(right==null){\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output(); \n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main{\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is;\n                String[] ia;\n                while((is = in.readLine()) != null){\n                        name = new String[5];\n                        set = new ArrayList<TreeSet<Integer>>();\n                        setu = new TreeSet<Integer>();\n                        for(int i = 0;i < 5; ++i){\n                                ia = is.split(\" \");\n                                if(ia[0].equals(\"R\") && ia[1].equals(\"0\")){\n                                        break;\n                                }\n                                name[i] = ia[0];\n                                TreeSet<Integer> se = new TreeSet<Integer>();\n                                ia = in.readLine().split(\" \");\n                                for(int j = 0;j < ia.length; ++j){\n                                        se.add(new Integer(Integer.parseInt(ia[j])));\n                                        setu.add(new Integer(Integer.parseInt(ia[j])));\n                                }\n                                set.add(se);\n                                is = in.readLine();\n                        }\n                        is = in.readLine();\n                        TreeSet<Integer> ans = solve(is);\n                        Iterator it = ans.iterator();\n                        if(it.hasNext()){\n                                while(true){\n                                        System.out.printf(\"%d\",it.next());\n                                        if(it.hasNext()){\n                                                System.out.printf(\" \");\n                                        } else {\n                                                break;\n                                        }\n                                } System.out.println(\"\");\n                        }\n                }\n        }\n        static String[] name;\n        static TreeSet<Integer> setu;\n        static ArrayList<TreeSet<Integer>> set;\n        static TreeSet<Integer> solve(String a){\n                if(a.length() == 1){\n                        for(int i = 0;i < 5 && name[i] != null; ++i){\n                                if(a.equals(name[i])){\n                                        return set.get(i);\n                                }\n                        }\n                }\n                TreeSet<Integer> x = new TreeSet<Integer>();\n                boolean y = false;\n                if(a.charAt(0) == '(' && a.charAt(a.length()-1) == ')'){\n                        a = a.substring(1,a.length()-1);\n                }\n                if(a.charAt(0) == 'c' && a.matches(\"[(].*[)]\")){\n                        return cs(solve(a.substring(1)));\n                } else if(a.charAt(0) == 'c' && a.matches(\"[ABCDEc]*\")){\n                        return cs(solve(a.substring(1)));                }\n                for(int i = 0;i < a.length(); ++i){\n                        if(a.charAt(i) == '('){\n                                int c = 0;\n                                for(;i < a.length(); ++i){\n                                        if(a.charAt(i) == '('){\n                                                ++c;\n                                        } else if(a.charAt(i) == ')'){\n                                                --c;\n                                        } else if(c == 0){\n                                                break;\n                                        }\n                                }\n                        }\n                        if(a.charAt(i) == 'c'){\n                                int c = 0;\n                                for(;i < a.length(); ++i){\n                                        if(a.charAt(i) == '('){\n                                                ++c;\n                                        } else if(a.charAt(i) == ')'){\n                                                --c;\n                                        } else if(a.charAt(i) == 'u' ||\n                                                  a.charAt(i) == 'i' ||\n                                                  a.charAt(i) == 'd' ||\n                                                  a.charAt(i) == 's'){\n                                                if(c == 0){\n                                                        --i;\n                                                        break;\n                                                }\n                                        }\n                                }\n                        }\n                        if(a.charAt(i) == 'u'){\n                                                                TreeSet<Integer> tmp = us(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                                                                return tmp;\n                        } else if(a.charAt(i) == 'i'){\n                                                                TreeSet<Integer> tmp = is(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                                                                return tmp;\n                        } else if(a.charAt(i) == 'd'){\n                                                                TreeSet<Integer> tmp = ds(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                                                                return tmp;\n                        } else if(a.charAt(i) == 's'){\n                                                                TreeSet<Integer> tmp = ss(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                                                                return tmp;\n                        }\n                }\n                return new TreeSet<Integer>();\n        }\n        static TreeSet<Integer> cs(TreeSet<Integer> a){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                tmp.addAll(setu);\n                Iterator it = a.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n        static TreeSet<Integer> us(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                tmp.addAll(a);\n                tmp.addAll(b);\n                return tmp;\n        }\n        static TreeSet<Integer> is(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                TreeSet<Integer> tmp1 = ds(a,b);\n                tmp.addAll(a);\n                Iterator it = tmp1.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n        static TreeSet<Integer> ds(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                tmp.addAll(a);\n                Iterator it = b.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n        static TreeSet<Integer> ss(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = us(a,b);\n                TreeSet<Integer> tmp1 = is(a,b);\n                Iterator it = tmp1.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tif(line == null) return;\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].equals(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\tif(true) return;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\tTreeSet<Integer>[] sets;\n\tString exp;\n\tTreeSet<Integer> U;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tfor (; sc.hasNext();) {\n\t\t\tsets = new TreeSet[256];\n\t\t\tfor (char c = 'A'; c <= 'E'; c++) {\n\t\t\t\tsets[c] = new TreeSet<Integer>();\n\t\t\t}\n\t\t\tU = new TreeSet<Integer>();\n\t\t\tfor (;;) {\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif (c == 'R' && n == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\tsets[c].add(e);\n\t\t\t\t\tU.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\texp = sc.next();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\texp += '\\0';\n\t\tResult r = e(0);\n\t\tdebug(r.set.toArray());\n\t\tfor(Iterator<Integer> it=r.set.iterator();it.hasNext();){\n\t\t\tprint(it.next()+(it.hasNext()?\" \":\"\\n\"));\n\t\t}\n\t}\n\n\tResult e(int p) {\n\t\tdebug(\"e\", p);\n\t\tResult r = f(p);\n\t\tdebug(r.set.toArray(), r.p);\n\t\tfor (;;) {\n\t\t\tif (op(exp.charAt(r.p))) {\n\t\t\t\tResult r2 = f(r.p + 1);\n\t\t\t\t// debug(r2.set.toArray(),r2.p);\n\t\t\t\tswitch (exp.charAt(r.p)) {\n\t\t\t\tcase 'u': // or\n\t\t\t\t\tr.set.addAll(r2.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i': // and\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd': // diff\n\t\t\t\t\tfor (int e : r2.set) {\n\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // sym\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr.p = r2.p;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tboolean op(char c) {\n\t\treturn c == 'u' || c == 'i' || c == 'd' || c == 's';\n\t}\n\n\tResult f(int p) {\n\t\tdebug(\"f\", p);\n\t\tif (exp.charAt(p) == 'c') {\n\t\t\tResult r = t(p + 1);\n\t\t\tTreeSet<Integer> c = new TreeSet<Integer>();\n\t\t\tfor (int e : U) {\n\t\t\t\tif (!r.set.contains(e)) {\n\t\t\t\t\tc.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.set.clear();\n\t\t\tr.set.addAll(c);\n\t\t\treturn r;\n\t\t} else {\n\t\t\treturn t(p);\n\t\t}\n\t}\n\n\tResult t(int p) {\n\t\tdebug(\"t\", p);\n\t\tif (exp.charAt(p) == '(') {\n\t\t\tResult r = e(p + 1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t} else {\n\t\t\tResult r = new Result(p + 1);\n\t\t\tr.set.addAll(sets[exp.charAt(p)]);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tclass Result {\n\t\tint p;\n\t\tTreeSet<Integer> set;\n\n\t\tResult(int p) {\n\t\t\tthis.p = p;\n\t\t\tset = new TreeSet<Integer>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\t//System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//D: Operations with Finite Sets\npublic class Main{\n\n\tstatic Set<Integer> u;\n\tstatic Set<Integer>[] set;\n\tstatic Map<String, Integer> ref;\n\n\tstatic char[] s;\n\tstatic int index;\n\n\tstatic char c(){\n\t\treturn s[index++];\n\t}\n\n\tstatic Set<Integer> exp(){\n\t\tSet<Integer> ans = fac();\n\t\twhile(index < s.length){\n\t\t\tchar c = c();\n\t\t\tif(c=='u'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.add(a);\n\t\t\t}\n\t\t\telse if(c=='i'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(ans.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse if(c=='d'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.remove(a);\n\t\t\t}\n\t\t\telse if(c=='s'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(!ans.contains(a))tmp.add(a);\n\t\t\t\tfor(int a:ans)if(!e.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic Set<Integer> fac(){\n\t\tchar c = c();\n\t\tif(c=='(')return exp();\n\t\tif(c!='c')\n\t\t\treturn set[ref.get(c+\"\")];\n\t\tint k = 1;\n\t\tc = c();\n\t\twhile(c=='c'){\n\t\t\tk++;\n\t\t\tc = c();\n\t\t}\n\t\tindex--;\n\t\tSet<Integer> ans = fac();\n\t\tif(k%2==1){\n\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\ttmp.addAll(u);\n\t\t\tfor(int a:tmp)ans.remove(a);\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tu = new HashSet<Integer>();\n\t\t\tset = new HashSet[5];\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tint id = 0;\n\t\t\twhile(true){\n\t\t\t\tString n = sc.next();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tif(n.equals(\"R\"))break;\n\t\t\t\tref.put(n, id);\n\t\t\t\tset[id] = new HashSet<Integer>();\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tset[id].add(x);\n\t\t\t\t\tu.add(x);\n\t\t\t\t}\n\t\t\t\tid++;\n\t\t\t}\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tindex = 0;\n\t\t\tSet<Integer> a = exp();\n\t\t\tif(a.isEmpty())System.out.println(\"NULL\");\n\t\t\telse {\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\t\tfor(int i:a)q.add(i);\n\t\t\t\tboolean f = true;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tif(!f)System.out.print(\" \");\n\t\t\t\t\tf = false;\n\t\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<Group> preset = new ArrayList<Group>();\n\tstatic Group U;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (sc.hasNext()) {\n\t\t\tpreset.clear();\n\t\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\t\tpreset.add(new Group());\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tString label = sc.next();\n\t\t\t\tint N = sc.nextInt();\n\t\t\t\tif (label.equals(\"R\")) break;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tpreset.get(label.charAt(0) - 'A').set.add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\tU = new Group();\n\t\t\tfor (int i = 0; i < preset.size(); ++i) {\n\t\t\t\tU.set.addAll(preset.get(i).set);\n\t\t\t}\n\t\t\tParser parser = new Parser(sc.next());\n\t\t\tGroup result = parser.parse();\n\t\t\tArrayList<Integer> ans = new ArrayList<Integer>(result.set);\n\t\t\tCollections.sort(ans);\n\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\tif (i != 0) System.out.print(\" \");\n\t\t\t\tSystem.out.print(ans.get(i));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic class Parser {\n\t\tString expr;\n\t\tint pos = 0;\n\n\t\tParser(String expr) {\n\t\t\tthis.expr = expr;\n\t\t}\n\n\t\tGroup parse() {\n\t\t\tGroup left = term();\n\t\t\twhile (pos < expr.length()) {\n\t\t\t\tchar op = expr.charAt(pos);\n\t\t\t\t++pos;\n\t\t\t\tif (op == ')') break;\n\t\t\t\tGroup right = term();\n\t\t\t\tswitch (op) {\n\t\t\t\tcase 'u':\n\t\t\t\t\tleft.set.addAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tleft.set.retainAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tleft.set.removeAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tHashSet<Integer> intersect = new HashSet<Integer>(left.set);\n\t\t\t\t\tintersect.retainAll(right.set);\n\t\t\t\t\tleft.set.removeAll(intersect);\n\t\t\t\t\tright.set.removeAll(intersect);\n\t\t\t\t\tleft.set.addAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left;\n\t\t}\n\n\t\tGroup term() {\n\t\t\tchar c = expr.charAt(pos);\n\t\t\t++pos;\n\t\t\tif (c == '(') {\n\t\t\t\treturn parse();\n\t\t\t}\n\t\t\tif (c == 'c') {\n\t\t\t\tGroup g = term();\n\t\t\t\tGroup ret = new Group();\n\t\t\t\tret.set.addAll(U.set);\n\t\t\t\tret.set.removeAll(g.set);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tGroup ret = new Group();\n\t\t\tret.set.addAll(preset.get(c - 'A').set);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\tHashSet<Integer> set = new HashSet<Integer>();;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].equals(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\n\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, OriginalSet> setsEnvironment;\n\tOriginalSet setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\n\t\tsetU = new OriginalSet();\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\t//int num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tOriginalSet set = new OriginalSet();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\t// System.out.println(\"計算\");\n\t\t\t\t\tOriginalSet resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tresultSet.print();\n\n\t\t\t\t\tsetU = new OriginalSet();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\t//System.err.println(e);\n\t\t}\n\t}\n\n\tOriginalSet calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\t// System.out.print(\"演算子: \");\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t// System.out.println(leftStr + \", \" + rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tOriginalSet leftSet = calc(leftStr);\n\t\t\tOriginalSet rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\t// System.out.print(\"括弧除去: \");\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\t// System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// System.out.print(\"補集合: \");\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\t\t\t// System.out.println(\"補集合おわり\");\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\t// System.out.print(\"環境参照: \");\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t\t// System.out.println(\"環境参照おわり\");\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic OriginalSet u(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic OriginalSet i(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic OriginalSet d(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic OriginalSet s(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\t\t/* input from here */\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile ((line = r.readLine()) == null) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res.length>0&&res.length<501){\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\tif(exp.length()<1){\n\t\t\treturn new Expression();\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t}\n\t\tif(!opfound){\n\t\t\tif(exp.charAt(0)=='('){\n\t\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t\t} else if(exp.charAt(0)=='c'){\n\t\t\t\te = null;\n\t\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\t\te = new Expression('c',parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t//res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nclass Expression {\n\tpublic char op;\n\tpublic String end;\n\tpublic Expression left,right;\n\t//blank node\n\tpublic Expression(){\n\t\tthis.op = 'n';\n\t}\n\t//leaf node\n\tpublic Expression(String s){\n\t\tthis.op = '-';\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.end = s;\n\t}\n\t//complement\n\tpublic Expression(char op, Expression left){\n\t\tthis.op = op;\n\t\tthis.left = left;\n\t}\n\t//other operands\n\tpublic Expression(char op, Expression left, Expression right){\n\t\tthis.op = op;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\tpublic void output(){\n\t\tSystem.out.print(\"(\");\n\t\tif(left==null&&right==null){\n\t\t\tSystem.out.print(this.end);\n\t\t} else if(op=='c'){\n\t\t\tSystem.out.print(op + \" \");\n\t\t\tleft.output();\n\t\t} else if(right==null){\n\t\t\tleft.output();\n\t\t} else {\n\t\t\tSystem.out.print(op + \" \");\n\t\t\tleft.output(); \n\t\t\tSystem.out.print(\" \");\n\t\t\tright.output();\n\t\t}\n\t\tSystem.out.print(\")\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\t/*\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}*/\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Main {\n    static class Calculator {\n        private final Map<Character, Set<Integer>> sets;\n        private final char[] input;\n        private final Set<Integer> U;\n        private int ptr = 0;\n\n        public Calculator(Map<Character, Set<Integer>> sets, char[] expr) {\n            this.sets = sets;\n            this.input = expr;\n            Set<Integer> U = new HashSet<Integer>();\n            for (Set<Integer> set: sets.values()) {\n                U.addAll(set);\n            }\n            this.U = U;\n        }\n\n        private Set<Integer> expr() {\n            Set<Integer> value = term();\n            while (ptr < input.length) {\n                if (input[ptr] == 'u') {\n                    ptr++;\n                    value.addAll(term());\n                } else if (input[ptr] == 'i') {\n                    ptr++;\n                    value.retainAll(term());\n                } else if (input[ptr] == 'd') {\n                    ptr++;\n                    value.removeAll(term());\n                } else if (input[ptr] == 's') {\n                    ptr++;\n                    Set<Integer> A = value;\n                    Set<Integer> A1 = new HashSet<Integer>(A);\n                    Set<Integer> B = term();\n                    Set<Integer> B1 = new HashSet<Integer>(B);\n                    A1.removeAll(B);\n                    B1.removeAll(A);\n                    A1.addAll(B1);\n                    value = A1;\n                } else {\n                    break;\n                }\n            }\n            return value;\n        }\n\n        private Set<Integer> term() {\n            Set<Integer> value;\n            if (input[ptr] == 'c') {\n                ptr++;\n                value = new HashSet<Integer>(U);\n                value.removeAll(factor());\n            } else {\n                value = factor();\n            }\n            return value;\n        }\n\n        private Set<Integer> factor() {\n            Set<Integer> value;\n            if (input[ptr] == '(') {\n                ptr++;\n                value = expr();\n                assert input[ptr] == ')';\n                ptr++;\n            } else {\n                value = new HashSet<Integer>(sets.get(input[ptr]));\n                ptr++;\n            }\n            return value;\n        }\n\n        public Set<Integer> run() {\n            return expr();\n        }\n    }\n\n    private static void solve() {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            Map<Character, Set<Integer>> sets = \n                new HashMap<Character, Set<Integer>>();\n            Set<Integer> result;\n            while (true) {\n                char name = scanner.next().charAt(0);\n                int n = scanner.nextInt();\n                if (name == 'R') {\n                    char[] expr = scanner.next().toCharArray();\n                    result = new Calculator(sets, expr).run();\n                    break;\n                } else {\n                    Set<Integer> value = new HashSet<Integer>();\n                    for (int i = 0; i < n; i++) {\n                        value.add(scanner.nextInt());\n                    }\n                    sets.put(name, value);\n                }\n            }\n            boolean space = false;\n            Object[] elements = result.toArray();\n            Arrays.sort(elements);\n            if (elements.length == 0) {\n                System.out.println(\"NULL\");\n            } else {\n                for (Object e: elements) {\n                    if (space) {\n                        System.out.print(' ');\n                    }\n                    System.out.print(e);\n                    space = true;\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\treturn;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line = r.readLine())!=null){\n\t\t\t\tif(line.length()<1){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* input from here */\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res.length>0&&res.length<501){\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\tif(exp.length()<1){\n\t\t\treturn new Expression();\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t}\n\t\tif(!opfound){\n\t\t\tif(exp.charAt(0)=='('){\n\t\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t\t} else if(exp.charAt(0)=='c'){\n\t\t\t\te = null;\n\t\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\t\te = new Expression('c',parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t//res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left,right;\n\t\t//blank node\n\t\tpublic Expression(){\n\t\t\tthis.op = 'n';\n\t\t}\n\t\t//leaf node\n\t\tpublic Expression(String s){\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\t\t//complement\n\t\tpublic Expression(char op, Expression left){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\t\t//other operands\n\t\tpublic Expression(char op, Expression left, Expression right){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tpublic void output(){\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif(left==null&&right==null){\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if(op=='c'){\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if(right==null){\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output(); \n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Operations with Finite Sets\npublic class Main{\n\n\tboolean[][] set;\n\tboolean[] u;\n\tMap<Integer, Integer> ref;\n\tint n;\n\t\n\tchar[] s;\n\tint id;\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\t\n\tboolean[] exp(){\n\t\tboolean[] res = new boolean[n];\n\t\tres = fact();\n\t\tfor(;;){\n\t\t\tchar ch = get();\n\t\t\tboolean[] x;\n\t\t\tif(ch=='u'){\n\t\t\t\tx = fact();\n\t\t\t\tfor(int i=0;i<n;i++)res[i]=res[i]|x[i];\n\t\t\t}\n\t\t\telse if(ch=='i'){\n\t\t\t\tx = fact();\n\t\t\t\tfor(int i=0;i<n;i++)res[i]=res[i]&x[i];\n\t\t\t}\n\t\t\telse if(ch=='d'){\n\t\t\t\tx = fact();\n\t\t\t\tfor(int i=0;i<n;i++)res[i]=res[i]&&!x[i];\n\t\t\t}\n\t\t\telse if(ch=='s'){\n\t\t\t\tx = fact();\n\t\t\t\tfor(int i=0;i<n;i++)res[i]=res[i]^x[i];\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tboolean[] fact(){\n\t\tboolean[] res = new boolean[n];\n\t\tchar ch = get();\n\t\tif(Character.isUpperCase(ch)){\n\t\t\tif(ch=='U'){\n\t\t\t\tArrays.fill(res, true);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)res[i] = set[ch-'A'][i];\n\t\t\treturn res;\n\t\t}\n\t\tif(ch=='('){\n\t\t\treturn exp();\n\t\t}\n\t\tch = s[id];\n\t\tboolean[] x;\n\t\tif(ch=='('){\n\t\t\tget();\n\t\t\tx = exp();\n\t\t}\n\t\telse x = fact();\n\t\tfor(int i=0;i<n;i++)res[i]=!x[i];\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tset = new boolean[5][500];\n\t\t\tu = new boolean[500];\n\t\t\tref = new HashMap<Integer, Integer>();\n\t\t\tn = 0;\n\t\t\tint[] rev = new int[500];\n\t\t\tfor(;;){\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tif(ch=='R')break;\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tif(!ref.containsKey(x)){\n\t\t\t\t\t\trev[n] = x;\n\t\t\t\t\t\tref.put(x, n++);\n\t\t\t\t\t}\n\t\t\t\t\tset[ch-'A'][ref.get(x)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tid = 0;\n\t\t\tArrays.fill(u, true);\n\t\t\tboolean[] res = exp();\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\tfor(int i=0;i<n;i++)if(res[i])q.add(rev[i]);\n\t\t\tif(q.isEmpty())System.out.println(\"NULL\");\n\t\t\telse {\n\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\twhile(!q.isEmpty())System.out.print(\" \"+q.poll());\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\tTreeSet<Integer>[] sets;\n\tString exp;\n\tTreeSet<Integer> U;\n\n\tvoid run() {\n\t\tfor (; sc.hasNext();) {\n\t\t\tsets = new TreeSet[256];\n\t\t\tfor (char c = 'A'; c <= 'E'; c++) {\n\t\t\t\tsets[c] = new TreeSet<Integer>();\n\t\t\t}\n\t\t\tU = new TreeSet<Integer>();\n\t\t\tfor (;;) {\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif (c == 'R' && n == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\tsets[c].add(e);\n\t\t\t\t\tU.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\texp = sc.next();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\texp += '\\0';\n\t\tResult r = e(0);\n\t\tdebug(r.set.toArray());\n\t\tfor(Iterator<Integer> it=r.set.iterator();it.hasNext();){\n\t\t\tprint(it.next()+(it.hasNext()?\" \":\"\\n\"));\n\t\t}\n\t}\n\n\tResult e(int p) {\n\t\tdebug(\"e\", p);\n\t\tResult r = f(p);\n\t\tdebug(r.set.toArray(), r.p);\n\t\tfor (;;) {\n\t\t\tif (op(exp.charAt(r.p))) {\n\t\t\t\tResult r2 = f(r.p + 1);\n\t\t\t\t// debug(r2.set.toArray(),r2.p);\n\t\t\t\tswitch (exp.charAt(r.p)) {\n\t\t\t\tcase 'u': // or\n\t\t\t\t\tr.set.addAll(r2.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i': // and\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd': // diff\n\t\t\t\t\tfor (int e : r2.set) {\n\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // sym\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr.p = r2.p;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tboolean op(char c) {\n\t\treturn c == 'u' || c == 'i' || c == 'd' || c == 's';\n\t}\n\n\tResult f(int p) {\n\t\tdebug(\"f\", p);\n\t\tif (exp.charAt(p) == 'c') {\n\t\t\tResult r = t(p + 1);\n\t\t\tTreeSet<Integer> c = new TreeSet<Integer>();\n\t\t\tfor (int e : U) {\n\t\t\t\tif (!r.set.contains(e)) {\n\t\t\t\t\tc.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.set.clear();\n\t\t\tr.set.addAll(c);\n\t\t\treturn r;\n\t\t} else {\n\t\t\treturn t(p);\n\t\t}\n\t}\n\n\tResult t(int p) {\n\t\tdebug(\"t\", p);\n\t\tif (exp.charAt(p) == '(') {\n\t\t\tResult r = e(p + 1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t} else {\n\t\t\tResult r = new Result(p + 1);\n\t\t\tr.set.addAll(sets[exp.charAt(p)]);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tclass Result {\n\t\tint p;\n\t\tTreeSet<Integer> set;\n\n\t\tResult(int p) {\n\t\t\tthis.p = p;\n\t\t\tset = new TreeSet<Integer>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\t//System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.TreeSet;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, HashSet<Integer>> setsEnvironment;\n\tHashSet<Integer> setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, HashSet<Integer>>();\n\n\t\tsetU = new HashSet<Integer>();\n\n\t\t/*\n\t\tHashSet<Integer> setA = new HashSet<Integer>();\n\t\tsetA.add(2);\n\t\tsetA.add(4);\n\t\tsetA.add(6);\n\t\tsetA.add(8);\n\n\t\tHashSet<Integer> setB = new HashSet<Integer>();\n\t\tsetB.add(2);\n\t\tsetB.add(6);\n\t\tsetB.add(9);\n\t\tsetB.add(10);\n\n\t\tSystem.out.println(i(setA, setB));\n\t\t*/\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\tint num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\tHashSet<Integer> resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tTreeSet<Integer> resultTreeSet = new TreeSet<Integer>(resultSet);\n\t\t\t\t\tInteger resultArray[] = (Integer[])resultTreeSet.toArray(new Integer[0]);\n\n\t\t\t\t\tSystem.out.print(resultArray[0]);\n\t\t\t\t\tfor(int i = 1; i < resultArray.length; i++){\n\t\t\t\t\t\tSystem.out.print(\" \" + resultArray[i]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\n\t\t\t\t\tsetU = new HashSet<Integer>();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, HashSet<Integer>>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tHashSet<Integer> calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t//System.out.println(leftStr);\n\t\t\t//System.out.println(rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tHashSet<Integer> leftSet = calc(leftStr);\n\t\t\tHashSet<Integer> rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic HashSet<Integer> u(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic HashSet<Integer> i(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic HashSet<Integer> d(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic HashSet<Integer> s(HashSet<Integer> setA, HashSet<Integer> setB){\n\t\tHashSet<Integer> resultSet = new HashSet<Integer>();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\n/*\n * 上級アルゴリズムのクラスでは，n^2 の生徒が n*n に座っている\n */"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif(true) return;\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tif(true) return;\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tif(true) return;\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tif(true) return;\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tArrays.sort(res);\n\t\t\t\tif(res.length>0){\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\t//single term\n\t\tif(exp.length()<=2){\n\t\t\tExpression e = new Expression(exp);\n\t\t\treturn e;\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t\te = null;\n\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\te = new Expression('c',parse(p));\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\tif(!opfound){\n\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[500];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left,right;\n\t\t//blank node\n\t\tpublic Expression(){\n\n\t\t}\n\t\t//leaf node\n\t\tpublic Expression(String s){\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\t\t//complement\n\t\tpublic Expression(char op, Expression left){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\t\t//other operands\n\t\tpublic Expression(char op, Expression left, Expression right){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tpublic void output(){\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif(left==null&&right==null){\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if(op=='c'){\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if(right==null){\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output(); \n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Main {\n    static class Calculator {\n        private final Map<Character, Set<Integer>> sets;\n        private final char[] input;\n        private final Set<Integer> U;\n        private int ptr = 0;\n\n        public Calculator(Map<Character, Set<Integer>> sets, char[] expr) {\n            this.sets = sets;\n            this.input = expr;\n            Set<Integer> U = new HashSet<Integer>();\n            for (Set<Integer> set: sets.values()) {\n                U.addAll(set);\n            }\n            this.U = U;\n        }\n\n        private Set<Integer> expr() {\n            Set<Integer> value = term();\n            while (ptr < input.length) {\n                if (input[ptr] == 'u') {\n                    ptr++;\n                    value.addAll(term());\n                } else if (input[ptr] == 'i') {\n                    ptr++;\n                    value.retainAll(term());\n                } else if (input[ptr] == 'd') {\n                    ptr++;\n                    value.removeAll(term());\n                } else if (input[ptr] == 's') {\n                    ptr++;\n                    Set<Integer> A = value;\n                    Set<Integer> A1 = new HashSet<Integer>(A);\n                    Set<Integer> B = term();\n                    Set<Integer> B1 = new HashSet<Integer>(B);\n                    A1.removeAll(B);\n                    B1.removeAll(A);\n                    A1.addAll(B1);\n                    value = A1;\n                } else {\n                    break;\n                }\n            }\n            return value;\n        }\n\n        private Set<Integer> term() {\n            Set<Integer> value;\n            if (input[ptr] == 'c') {\n                ptr++;\n                value = new HashSet<Integer>(U);\n                value.removeAll(factor());\n            } else {\n                value = factor();\n            }\n            return value;\n        }\n\n        private Set<Integer> factor() {\n            Set<Integer> value;\n            if (input[ptr] == '(') {\n                ptr++;\n                value = expr();\n                assert input[ptr] == ')';\n                ptr++;\n            } else {\n                value = new HashSet<Integer>(sets.get(input[ptr]));\n                ptr++;\n            }\n            return value;\n        }\n\n        public Set<Integer> run() {\n            return expr();\n        }\n    }\n\n    private static void solve() {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            Map<Character, Set<Integer>> sets = \n                new HashMap<Character, Set<Integer>>();\n            Set<Integer> result;\n            while (true) {\n                char name = scanner.next().charAt(0);\n                int n = scanner.nextInt();\n                if (name == 'R') {\n                    char[] expr = scanner.next().toCharArray();\n                    result = new Calculator(sets, expr).run();\n                    break;\n                } else {\n                    Set<Integer> value = new HashSet<Integer>();\n                    for (int i = 0; i < n; i++) {\n                        value.add(scanner.nextInt());\n                    }\n                    sets.put(name, value);\n                }\n            }\n            boolean space = false;\n            Object[] elements = result.toArray();\n            Arrays.sort(elements);\n            if (elements.length == 0) {\n                System.out.println(\"NULL\");\n            } else {\n                for (Object e: elements) {\n                    if (space) {\n                        System.out.print(' ');\n                    }\n                    System.out.print(e);\n                    space = true;\n                }\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tArrays.sort(res);\n\t\t\t\tif(res.length>0){\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\t//single term\n\t\tif(exp.length()<=2){\n\t\t\tExpression e = new Expression(exp);\n\t\t\treturn e;\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t\te = null;\n\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\te = new Expression('c',parse(p));\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\tif(!opfound){\n\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[500];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left,right;\n\t\t//blank node\n\t\tpublic Expression(){\n\n\t\t}\n\t\t//leaf node\n\t\tpublic Expression(String s){\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\t\t//complement\n\t\tpublic Expression(char op, Expression left){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\t\t//other operands\n\t\tpublic Expression(char op, Expression left, Expression right){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tpublic void output(){\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif(left==null&&right==null){\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if(op=='c'){\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if(right==null){\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output(); \n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main{\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is;\n                String[] ia;\n                while((is = in.readLine()) != null){\n                        name = new String[5];\n                        set = new ArrayList<TreeSet<Integer>>();\n                        setu = new TreeSet<Integer>();\n                        for(int i = 0;i < 5; ++i){\n                                ia = is.split(\" \");\n                                if(ia[0].equals(\"R\") && ia[1].equals(\"0\")){\n                                        break;\n                                }\n                                name[i] = ia[0];\n                                TreeSet<Integer> se = new TreeSet<Integer>();\n                                ia = in.readLine().split(\" \");\n                                for(int j = 0;j < ia.length; ++j){\n                                        se.add(new Integer(Integer.parseInt(ia[j])));\n                                        setu.add(new Integer(Integer.parseInt(ia[j])));\n                                }\n                                set.add(se);\n                                is = in.readLine();\n                        }\n                        is = in.readLine();\n                        TreeSet<Integer> ans = solve(is);\n                        Iterator it = ans.iterator();\n                        if(it.hasNext()){\n                                while(true){\n                                        System.out.printf(\"%d\",it.next());\n                                        if(it.hasNext()){\n                                                System.out.printf(\" \");\n                                        } else {\n                                                break;\n                                        }\n                                } System.out.println(\"\");\n                        }\n                }\n        }\n        static String[] name;\n        static TreeSet<Integer> setu;\n        static ArrayList<TreeSet<Integer>> set;\n        static TreeSet<Integer> solve(String a){\n                if(a.length() == 1){\n                        for(int i = 0;i < 5 && name[i] != null; ++i){\n                                if(a.equals(name[i])){\n                                        return set.get(i);\n                                }\n                        }\n                }\n                TreeSet<Integer> x = null;\n                boolean y = false;\n                for(int i = 0;i < a.length(); ++i){\n                        if(a.charAt(i) == '('){\n                                x = solve(a.substring(i+1));\n                                y = true;\n                                int c = 0;\n                                for(;i < a.length(); ++i){\n                                        if(a.charAt(i) == '('){\n                                                ++c;\n                                        } else if(a.charAt(i) == ')'){\n                                                --c;\n                                        } else if(a.charAt(i) == 'u' ||\n                                                  a.charAt(i) == 'i' ||\n                                                  a.charAt(i) == 'd' ||\n                                                  a.charAt(i) == 's'){\n                                                if(c == 0){\n                                                        break;\n                                                }\n                                        }\n                                }\n                                --i;\n                        } else if(a.charAt(i) == ')'){\n                                return solve(a.substring(0,i));\n                        } else if(a.charAt(i) == 'c'){\n                                int c = 0;\n                                int j = i+1;\n                                for(;i < a.length(); ++i){\n                                        if(a.charAt(i) == '('){\n                                                ++c;\n                                        } else if(a.charAt(i) == ')'){\n                                                --c;\n                                        } else if(a.charAt(i) == 'u' ||\n                                                  a.charAt(i) == 'i' ||\n                                                  a.charAt(i) == 'd' ||\n                                                  a.charAt(i) == 's'){\n                                                if(c == 0){\n                                                        break;\n                                                }\n                                        }\n                                }\n                                x = cs(solve(a.substring(j,i)));\n                                y = true;\n\n                        } else if(a.charAt(i) == 'u'){\n                                if(y){\n                                        return us(x,solve(a.substring(i+1)));\n                                }\n                                return us(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                        } else if(a.charAt(i) == 'i'){\n                                if(y){\n                                        return is(x,solve(a.substring(i+1)));\n                                }\n                                return is(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                        } else if(a.charAt(i) == 'd'){\n                                if(y){\n                                        return ds(x,solve(a.substring(i+1)));\n                                }\n                                return ds(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                        } else if(a.charAt(i) == 's'){\n                                if(y){\n                                        return ss(x,solve(a.substring(i+1)));\n                                }\n                                return ss(solve(a.substring(0,i)),solve(a.substring(i+1)));\n                        }\n                }\n                if(y){\n                        return x;\n                }\n                return new TreeSet<Integer>();\n        }\n        static TreeSet<Integer> cs(TreeSet<Integer> a){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                tmp.addAll(setu);\n                Iterator it = a.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n        static TreeSet<Integer> us(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                tmp.addAll(a);\n                tmp.addAll(b);\n                return tmp;\n        }\n        static TreeSet<Integer> is(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                TreeSet<Integer> tmp1 = ds(a,b);\n                tmp.addAll(a);\n                Iterator it = tmp1.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n        static TreeSet<Integer> ds(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = new TreeSet<Integer>();\n                tmp.addAll(a);\n                Iterator it = b.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n        static TreeSet<Integer> ss(TreeSet<Integer> a, TreeSet<Integer> b){\n                TreeSet<Integer> tmp = us(a,b);\n                TreeSet<Integer> tmp1 = is(a,b);\n                Iterator it = tmp1.iterator();\n                while(it.hasNext()){\n                        tmp.remove(it.next());\n                }\n                return tmp;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//D: Operations with Finite Sets\npublic class Main{\n\n\tstatic Set<Integer> u;\n\tstatic Set<Integer>[] set;\n\tstatic Map<String, Integer> ref;\n\n\tstatic char[] s;\n\tstatic int index;\n\n\tstatic char c(){\n\t\treturn s[index++];\n\t}\n\n\tstatic Set<Integer> exp(){\n\t\tSet<Integer> ans = fac();\n\t\twhile(index < s.length){\n\t\t\tchar c = c();\n\t\t\tif(c=='u'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.add(a);\n\t\t\t}\n\t\t\telse if(c=='i'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(ans.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse if(c=='d'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.remove(a);\n\t\t\t}\n\t\t\telse if(c=='s'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(!ans.contains(a))tmp.add(a);\n\t\t\t\tfor(int a:ans)if(!e.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic Set<Integer> fac(){\n\t\tchar c = c();\n\t\tif(c=='(')return exp();\n\t\tif(c!='c')\n\t\t\treturn set[ref.get(c+\"\")];\n\t\tint k = 1;\n\t\tc = c();\n\t\twhile(c=='c'){\n\t\t\tk++;\n\t\t\tc = c();\n\t\t}\n\t\tif(k%2==1){\n\t\t\tSet<Integer> ans = new HashSet<Integer>();\n\t\t\tans.addAll(u);\n\t\t\tint id = ref.get(c+\"\");\n\t\t\tfor(int a:set[id])ans.remove(a);\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\treturn set[ref.get(c+\"\")];\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tu = new HashSet<Integer>();\n\t\t\tset = new HashSet[5];\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tint id = 0;\n\t\t\twhile(true){\n\t\t\t\tString n = sc.next();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tif(n.equals(\"R\"))break;\n\t\t\t\tref.put(n, id);\n\t\t\t\tset[id] = new HashSet<Integer>();\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tset[id].add(x);\n\t\t\t\t\tu.add(x);\n\t\t\t\t}\n\t\t\t\tid++;\n\t\t\t}\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tindex = 0;\n\t\t\tSet<Integer> a = exp();\n\t\t\tif(a.isEmpty())System.out.println(\"NULL\");\n\t\t\telse {\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\t\tfor(int i:a)q.add(i);\n\t\t\t\tboolean f = true;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tif(!f)System.out.print(\" \");\n\t\t\t\t\tf = false;\n\t\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\t/*\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t\t*/\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res.length>0&&res.length<501){\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\tif(exp.length()<1){\n\t\t\treturn new Expression();\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t}\n\t\tif(!opfound){\n\t\t\tif(exp.charAt(0)=='('){\n\t\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t\t} else if(exp.charAt(0)=='c'){\n\t\t\t\te = null;\n\t\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\t\te = new Expression('c',parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\tres[0] = -1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left,right;\n\t\t//blank node\n\t\tpublic Expression(){\n\t\t\tthis.op = 'n';\n\t\t}\n\t\t//leaf node\n\t\tpublic Expression(String s){\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\t\t//complement\n\t\tpublic Expression(char op, Expression left){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\t\t//other operands\n\t\tpublic Expression(char op, Expression left, Expression right){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tpublic void output(){\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif(left==null&&right==null){\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if(op=='c'){\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if(right==null){\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output(); \n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t\tif(true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tArrays.sort(res);\n\t\t\t\tif(res.length>0){\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\t//single term\n\t\tif(exp.length()<=2){\n\t\t\tExpression e = new Expression(exp);\n\t\t\treturn e;\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t\te = null;\n\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\te = new Expression('c',parse(p));\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\tif(!opfound){\n\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[500];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nclass Expression {\n\tpublic char op;\n\tpublic String end;\n\tpublic Expression left,right;\n\t//blank node\n\tpublic Expression(){\n\n\t}\n\t//leaf node\n\tpublic Expression(String s){\n\t\tthis.op = '-';\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.end = s;\n\t}\n\t//complement\n\tpublic Expression(char op, Expression left){\n\t\tthis.op = op;\n\t\tthis.left = left;\n\t}\n\t//other operands\n\tpublic Expression(char op, Expression left, Expression right){\n\t\tthis.op = op;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\tpublic void output(){\n\t\tSystem.out.print(\"(\");\n\t\tif(left==null&&right==null){\n\t\t\tSystem.out.print(this.end);\n\t\t} else if(op=='c'){\n\t\t\tSystem.out.print(op + \" \");\n\t\t\tleft.output();\n\t\t} else if(right==null){\n\t\t\tleft.output();\n\t\t} else {\n\t\t\tSystem.out.print(op + \" \");\n\t\t\tleft.output(); \n\t\t\tSystem.out.print(\" \");\n\t\t\tright.output();\n\t\t}\n\t\tSystem.out.print(\")\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tif(true) return;\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile (true) {\n\t\t\t\t/* input from here */\n\t\t\t\tif ((line = r.readLine()) == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, OriginalSet> setsEnvironment;\n\tOriginalSet setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\n\t\tsetU = new OriginalSet();\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\t//int num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tOriginalSet set = new OriginalSet();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\t// System.out.println(\"計算\");\n\t\t\t\t\tOriginalSet resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tresultSet.print();\n\n\t\t\t\t\tsetU = new OriginalSet();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tOriginalSet calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\t// System.out.print(\"演算子: \");\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t// System.out.println(leftStr + \", \" + rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tOriginalSet leftSet = calc(leftStr);\n\t\t\tOriginalSet rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\t// System.out.print(\"括弧除去: \");\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\t// System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// System.out.print(\"補集合: \");\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\t\t\t// System.out.println(\"補集合おわり\");\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\t// System.out.print(\"環境参照: \");\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t\t// System.out.println(\"環境参照おわり\");\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic OriginalSet u(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic OriginalSet i(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic OriginalSet d(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic OriginalSet s(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].equals(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input from here */\n\t\t\t\tif((line = r.readLine())==null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tHashMap<String, Integer[]>  sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile(true){\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif(str[0].contains(\"R\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif(!U.contains(e[i])) U.add((Integer)e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]); \n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e,sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res.length>0&&res.length<501){\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor(int i=0;i<res.length-1;i++){\n\t\t\t\t\t\tSystem.out.print(res[i]+ \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length-1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp){\n\t\tif(exp.length()<1){\n\t\t\treturn new Expression();\n\t\t}\n\t\t//2-term-operands\n\t\tString ops = \"iuds\"; \n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length()-1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile(index>=0){\n\t\t\tif(exp.charAt(index)==')'){\n\t\t\t\tlevel++;\n\t\t\t} else if(exp.charAt(index)=='('){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif(level==0&&ops.indexOf(exp.substring(index,index+1))>-1){\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0,index);\n\t\t\t\tright = exp.substring(index+1,exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t//single-term operand\n\t\tif(!opfound&&exp.charAt(0)=='c'){\n\t\t}\n\t\tif(!opfound){\n\t\t\tif(exp.charAt(0)=='('){\n\t\t\t\treturn parse(exp.substring(1,exp.length()-1));\n\t\t\t} else if(exp.charAt(0)=='c'){\n\t\t\t\te = null;\n\t\t\t\tif(exp.charAt(1)!='('){\n\t\t\t\t\te = new Expression('c',new Expression(exp.substring(1,2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile(exp.charAt(index)!=')'){\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2,index);\n\t\t\t\t\te = new Expression('c',parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets){\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t//res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d',u,e.left),sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor(Integer i : calc(e.left, sets)){\n\t\t\t\tfor(Integer j :calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u' :\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left,sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor(Integer i : calc(e.right,sets)){\n\t\t\t\tfor(Integer j : calc(e.left,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd' :\n\t\t\tfound = false;\n\t\t\tfor(Integer i : calc(e.left,sets)){\n\t\t\t\tfor(Integer j : calc(e.right,sets)){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found){\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's' :\n\t\t\tExpression sleft = new Expression('d',e.left,e.right);\n\t\t\tExpression sright = new Expression('d',e.right,e.left);\n\n\t\t\tres = calc(new Expression('u',sleft,sright),sets);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif(e.end.charAt(0)=='('){\n\t\t\t\te.end = e.end.substring(1,e.end.length()-1);\n\t\t\t} else if(e.end.charAt(0)=='c'){\n\t\t\t\tres = calc(new Expression('c',new Expression(e.end.substring(1))),sets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left,right;\n\t\t//blank node\n\t\tpublic Expression(){\n\t\t\tthis.op = 'n';\n\t\t}\n\t\t//leaf node\n\t\tpublic Expression(String s){\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\t\t//complement\n\t\tpublic Expression(char op, Expression left){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\t\t//other operands\n\t\tpublic Expression(char op, Expression left, Expression right){\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\tpublic void output(){\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif(left==null&&right==null){\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if(op=='c'){\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if(right==null){\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output(); \n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//D: Operations with Finite Sets\npublic class Main{\n\n\tstatic Set<Integer> u;\n\tstatic Set<Integer>[] set;\n\tstatic Map<String, Integer> ref;\n\t\n\tstatic char[] s;\n\tstatic int index;\n\t\n\tstatic char c(){\n\t\treturn s[index++];\n\t}\n\t\n\tstatic Set<Integer> exp(){\n\t\tSet<Integer> ans = fac();\n\t\twhile(index < s.length){\n\t\t\tchar c = c();\n\t\t\tif(c=='u'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.add(a);\n\t\t\t}\n\t\t\telse if(c=='i'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(ans.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse if(c=='d'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tfor(int a:e)ans.remove(a);\n\t\t\t}\n\t\t\telse if(c=='s'){\n\t\t\t\tSet<Integer> e = fac();\n\t\t\t\tSet<Integer> tmp = new HashSet<Integer>();\n\t\t\t\tfor(int a:e)if(!ans.contains(a))tmp.add(a);\n\t\t\t\tfor(int a:ans)if(!e.contains(a))tmp.add(a);\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic Set<Integer> fac(){\n\t\tchar c = c();\n\t\tif(c=='(')return exp();\n\t\tif(c=='c'){\n\t\t\tSet<Integer> ans = new HashSet<Integer>();\n\t\t\tans.addAll(u);\n\t\t\tint id = ref.get(c()+\"\");\n\t\t\tfor(int a:set[id])ans.remove(a);\n\t\t\treturn ans;\n\t\t}\n\t\treturn set[ref.get(c+\"\")];\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tu = new HashSet<Integer>();\n\t\t\tset = new HashSet[5];\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tint id = 0;\n\t\t\twhile(true){\n\t\t\t\tString n = sc.next();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tif(n.equals(\"R\"))break;\n\t\t\t\tref.put(n, id);\n\t\t\t\tset[id] = new HashSet<Integer>();\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tset[id].add(x);\n\t\t\t\t\tu.add(x);\n\t\t\t\t}\n\t\t\t\tid++;\n\t\t\t}\n\t\t\ts = (sc.next()+\"$\").toCharArray();\n\t\t\tindex = 0;\n\t\t\tSet<Integer> a = exp();\n\t\t\tif(a.isEmpty())System.out.println(\"NULL\");\n\t\t\telse {\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\t\tfor(int i:a)q.add(i);\n\t\t\t\tboolean f = true;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tif(!f)System.out.print(\" \");\n\t\t\t\t\tf = false;\n\t\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t\tif(true) return;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\n\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, OriginalSet> setsEnvironment;\n\tOriginalSet setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\n\t\tsetU = new OriginalSet();\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\t//int num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tOriginalSet set = new OriginalSet();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\t// System.out.println(\"計算\");\n\t\t\t\t\tOriginalSet resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tresultSet.print();\n\n\t\t\t\t\tsetU = new OriginalSet();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\t//System.err.println(e);\n\t\t}\n\t}\n\n\tOriginalSet calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\t// System.out.print(\"演算子: \");\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t// System.out.println(leftStr + \", \" + rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tOriginalSet leftSet = calc(leftStr);\n\t\t\tOriginalSet rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\t// System.out.print(\"括弧除去: \");\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\t// System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// System.out.print(\"補集合: \");\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\t\t\t// System.out.println(\"補集合おわり\");\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\t// System.out.print(\"環境参照: \");\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t\t// System.out.println(\"環境参照おわり\");\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic OriginalSet u(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic OriginalSet i(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic OriginalSet d(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic OriginalSet s(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\tTreeSet<Integer>[] sets;\n\tString exp;\n\tTreeSet<Integer> U;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tfor (; sc.hasNext();) {\n\t\t\tsets = new TreeSet[256];\n\t\t\tfor (char c = 'A'; c <= 'E'; c++) {\n\t\t\t\tsets[c] = new TreeSet<Integer>();\n\t\t\t}\n\t\t\tU = new TreeSet<Integer>();\n\t\t\tfor (;;) {\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif (c == 'R' && n == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\tsets[c].add(e);\n\t\t\t\t\tU.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\texp = sc.next();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\texp += '\\0';\n\t\tResult r = e(0);\n\t\tdebug(r.set.toArray());\n\t\tfor (Iterator<Integer> it = r.set.iterator(); it.hasNext();) {\n\t\t\tprint(it.next() + (it.hasNext() ? \" \" : \"\\n\"));\n\t\t}\n\t}\n\n\tResult e(int p) {\n\t\tdebug(\"e\", p);\n\t\tResult r = f(p);\n\t\tdebug(r.set.toArray(), r.p);\n\t\tfor (;;) {\n\t\t\tif (op(exp.charAt(r.p))) {\n\t\t\t\tResult r2 = f(r.p + 1);\n\t\t\t\t// debug(r2.set.toArray(),r2.p);\n\t\t\t\tswitch (exp.charAt(r.p)) {\n\t\t\t\tcase 'u': // or\n\t\t\t\t\tr.set.addAll(r2.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i': // and\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd': // diff\n\t\t\t\t\tr.set.removeAll(r2.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // sym\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t} else if (r2.set.contains(e)) {\n\t\t\t\t\t\t\tr.set.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr.p = r2.p;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tboolean op(char c) {\n\t\treturn c == 'u' || c == 'i' || c == 'd' || c == 's';\n\t}\n\n\tResult f(int p) {\n\t\tdebug(\"f\", p);\n\t\tif (exp.charAt(p) == 'c') {\n\t\t\tResult r = t(p + 1);\n\t\t\tTreeSet<Integer> c = new TreeSet<Integer>();\n\t\t\tfor (int e : U) {\n\t\t\t\tif (!r.set.contains(e)) {\n\t\t\t\t\tc.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.set.clear();\n\t\t\tr.set.addAll(c);\n\t\t\treturn r;\n\t\t} else {\n\t\t\treturn t(p);\n\t\t}\n\t}\n\n\tResult t(int p) {\n\t\tdebug(\"t\", p);\n\t\tif (exp.charAt(p) == '(') {\n\t\t\tResult r = e(p + 1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t} else {\n\t\t\tResult r = new Result(p + 1);\n\t\t\tr.set.addAll(sets[exp.charAt(p)]);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tclass Result {\n\t\tint p;\n\t\tTreeSet<Integer> set;\n\n\t\tResult(int p) {\n\t\t\tthis.p = p;\n\t\t\tset = new TreeSet<Integer>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<Group> preset = new ArrayList<Group>();\n\tstatic Group U;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (sc.hasNext()) {\n\t\t\tpreset.clear();\n\t\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\t\tpreset.add(new Group());\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tString label = sc.next();\n\t\t\t\tint N = sc.nextInt();\n\t\t\t\tif (label.equals(\"R\")) break;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tpreset.get(label.charAt(0) - 'A').set.add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\tU = new Group();\n\t\t\tfor (int i = 0; i < preset.size(); ++i) {\n\t\t\t\tU.set.addAll(preset.get(i).set);\n\t\t\t}\n\t\t\tParser parser = new Parser(sc.next());\n\t\t\tGroup result = parser.parse();\n\t\t\tArrayList<Integer> ans = new ArrayList<Integer>(result.set);\n\t\t\tCollections.sort(ans);\n\t\t\tif (ans.isEmpty()) {\n\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\t\t\tif (i != 0) System.out.print(\" \");\n\t\t\t\t\tSystem.out.print(ans.get(i));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Parser {\n\t\tString expr;\n\t\tint pos = 0;\n\n\t\tParser(String expr) {\n\t\t\tthis.expr = expr;\n\t\t}\n\n\t\tGroup parse() {\n\t\t\tGroup left = term();\n\t\t\twhile (pos < expr.length()) {\n\t\t\t\tchar op = expr.charAt(pos);\n\t\t\t\t++pos;\n\t\t\t\tif (op == ')') break;\n\t\t\t\tGroup right = term();\n\t\t\t\tswitch (op) {\n\t\t\t\tcase 'u':\n\t\t\t\t\tleft.set.addAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\n\t\t\t\t\tleft.set.retainAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tleft.set.removeAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tHashSet<Integer> intersect = new HashSet<Integer>(left.set);\n\t\t\t\t\tintersect.retainAll(right.set);\n\t\t\t\t\tleft.set.removeAll(intersect);\n\t\t\t\t\tright.set.removeAll(intersect);\n\t\t\t\t\tleft.set.addAll(right.set);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left;\n\t\t}\n\n\t\tGroup term() {\n\t\t\tchar c = expr.charAt(pos);\n\t\t\t++pos;\n\t\t\tif (c == '(') {\n\t\t\t\treturn parse();\n\t\t\t}\n\t\t\tif (c == 'c') {\n\t\t\t\tGroup g = term();\n\t\t\t\tGroup ret = new Group();\n\t\t\t\tret.set.addAll(U.set);\n\t\t\t\tret.set.removeAll(g.set);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tGroup ret = new Group();\n\t\t\tret.set.addAll(preset.get(c - 'A').set);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\tHashSet<Integer> set = new HashSet<Integer>();;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tif(true) return;\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t\tHashMap<String, Integer[]> sets = new HashMap<String, Integer[]>();\n\t\t\t\tArrayList<Integer> U = new ArrayList<Integer>();\n\t\t\t\twhile (true) {\n\t\t\t\t\tString[] str = line.split(\" \");\n\t\t\t\t\tif (str[0].contains(\"R\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length < 2) return;\n\t\t\t\t\tint n = Integer.parseInt(str[1]);\n\t\t\t\t\tInteger[] e = new Integer[n];\n\t\t\t\t\tString[] line2 = r.readLine().split(\" \");\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\te[i] = Integer.parseInt(line2[i]);\n\t\t\t\t\t\tif (!U.contains(e[i]))\n\t\t\t\t\t\t\tU.add((Integer) e[i]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(e);\n\t\t\t\t\tsets.put(str[0], e);\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t}\n\t\t\t\tInteger[] setU = U.toArray(new Integer[U.size()]);\n\t\t\t\tArrays.sort(setU);\n\t\t\t\tsets.put(\"U\", setU);\n\n\t\t\t\tString exp = r.readLine();\n\t\t\t\t/* input till here */\n\t\t\t\t/* parsing from here */\n\t\t\t\tExpression e = parse(exp);\n\t\t\t\t/* parsing till here */\n\t\t\t\t/* semantic analysis from here */\n\t\t\t\tInteger[] res = calc(e, sets);\n\t\t\t\t/* semantic analysis till here */\n\t\t\t\t/* output */\n\t\t\t\tif (res.length > 0 && res.length < 501) {\n\t\t\t\t\tArrays.sort(res);\n\t\t\t\t\tfor (int i = 0; i < res.length - 1; i++) {\n\t\t\t\t\t\tSystem.out.print(res[i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res[res.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NULL\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t//e.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Expression parse(String exp) {\n\t\tif (exp.length() < 1) {\n\t\t\treturn new Expression();\n\t\t}\n\t\t// 2-term-operands\n\t\tString ops = \"iuds\";\n\t\tString left = \"\", right = \"\";\n\t\tint index = exp.length() - 1;\n\t\tint level = 0;\n\t\tExpression e = null;\n\t\tboolean opfound = false;\n\t\twhile (index >= 0) {\n\t\t\tif (exp.charAt(index) == ')') {\n\t\t\t\tlevel++;\n\t\t\t} else if (exp.charAt(index) == '(') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level == 0 && ops.indexOf(exp.substring(index, index + 1)) > -1) {\n\t\t\t\tchar op = exp.charAt(index);\n\t\t\t\tleft = exp.substring(0, index);\n\t\t\t\tright = exp.substring(index + 1, exp.length());\n\n\t\t\t\te = new Expression(op, parse(left), parse(right));\n\t\t\t\topfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex--;\n\t\t}\n\t\t// single-term operand\n\t\tif (!opfound && exp.charAt(0) == 'c') {\n\t\t}\n\t\tif (!opfound) {\n\t\t\tif (exp.charAt(0) == '(') {\n\t\t\t\treturn parse(exp.substring(1, exp.length() - 1));\n\t\t\t} else if (exp.charAt(0) == 'c') {\n\t\t\t\te = null;\n\t\t\t\tif (exp.charAt(1) != '(') {\n\t\t\t\t\te = new Expression('c', new Expression(exp.substring(1, 2)));\n\t\t\t\t} else {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\twhile (exp.charAt(index) != ')') {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tString p = exp.substring(2, index);\n\t\t\t\t\te = new Expression('c', parse(p));\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\treturn new Expression(exp);\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n\n\tpublic static Integer[] calc(Expression e, HashMap<String, Integer[]> sets) {\n\t\tInteger[] res = new Integer[501];\n\t\tArrayList<Integer> reslist = new ArrayList<Integer>();\n\t\tArrayList<Integer> left = null;\n\t\tswitch (e.op) {\n\t\tcase 'n':\n\t\t\t// res[0] = null;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tExpression u = new Expression(\"U\");\n\t\t\tres = calc(new Expression('d', u, e.left), sets);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\treslist.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tleft = new ArrayList<Integer>(Arrays.asList(calc(e.left, sets)));\n\n\t\t\tboolean found = false;\n\t\t\treslist = left;\n\n\t\t\tfor (Integer i : calc(e.right, sets)) {\n\t\t\t\tfor (Integer j : calc(e.left, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfound = false;\n\t\t\tfor (Integer i : calc(e.left, sets)) {\n\t\t\t\tfor (Integer j : calc(e.right, sets)) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treslist.add(i);\n\t\t\t\t}\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\tres = reslist.toArray(new Integer[reslist.size()]);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tExpression sleft = new Expression('d', e.left, e.right);\n\t\t\tExpression sright = new Expression('d', e.right, e.left);\n\n\t\t\tres = calc(new Expression('u', sleft, sright), sets);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (e.end.charAt(0) == '(') {\n\t\t\t\te.end = e.end.substring(1, e.end.length() - 1);\n\t\t\t} else if (e.end.charAt(0) == 'c') {\n\t\t\t\tres = calc(\n\t\t\t\t\t\tnew Expression('c', new Expression(e.end.substring(1))),\n\t\t\t\t\t\tsets);\n\t\t\t} else {\n\t\t\t\tres = sets.get(e.end);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Expression {\n\t\tpublic char op;\n\t\tpublic String end;\n\t\tpublic Expression left, right;\n\n\t\t// blank node\n\t\tpublic Expression() {\n\t\t\tthis.op = 'n';\n\t\t}\n\n\t\t// leaf node\n\t\tpublic Expression(String s) {\n\t\t\tthis.op = '-';\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.end = s;\n\t\t}\n\n\t\t// complement\n\t\tpublic Expression(char op, Expression left) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t}\n\n\t\t// other operands\n\t\tpublic Expression(char op, Expression left, Expression right) {\n\t\t\tthis.op = op;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\tpublic void output() {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (left == null && right == null) {\n\t\t\t\tSystem.out.print(this.end);\n\t\t\t} else if (op == 'c') {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t} else if (right == null) {\n\t\t\t\tleft.output();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(op + \" \");\n\t\t\t\tleft.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tright.output();\n\t\t\t}\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\n\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\t(new Main()).sets();\n\t}\n\n\tHashMap<String, OriginalSet> setsEnvironment;\n\tOriginalSet setU;\n\n\tvoid sets(){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\n\t\tsetU = new OriginalSet();\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tString args[] = str.split(\" \");\n\n\t\t\t\t// メソッドで場合分け\n\t\t\t\tif(!args[0].equals(\"R\")){\n\t\t\t\t\t//int num = Integer.parseInt(args[1]);\n\n\t\t\t\t\t// 行列の入力を受け付ける\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tString elementsStr[] = str.split(\" \");\n\n\t\t\t\t\t// 行列を作成\n\t\t\t\t\tOriginalSet set = new OriginalSet();\n\t\t\t\t\tfor(int i = 0; i < elementsStr.length; i++){\n\t\t\t\t\t\tset.add(Integer.parseInt(elementsStr[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\t// 環境ハッシュに登録\n\t\t\t\t\tsetsEnvironment.put(args[0], set);\n\n\t\t\t\t\t// 全体集合に追加\n\t\t\t\t\tsetU.addAll(set);\n\n\t\t\t\t\t//System.out.println(setsEnvironment.get(args[0]));\n\t\t\t\t}else{\n\t\t\t\t\t// 環境ハッシュに全体集合を追加\n\t\t\t\t\tsetsEnvironment.put(\"U\", setU);\n\n\t\t\t\t\t// 計算\n\t\t\t\t\t// System.out.println(\"計算\");\n\t\t\t\t\tOriginalSet resultSet = calc(br.readLine());\n\t\t\t\t\t//System.out.println(resultSet);\n\n\t\t\t\t\t// ソートして出力\n\t\t\t\t\tresultSet.print();\n\n\t\t\t\t\tsetU = new OriginalSet();\n\t\t\t\t\tsetsEnvironment = new HashMap<String, OriginalSet>();\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tOriginalSet calc(String str){\n\t\tint lvl = 0;\n\t\tint opPointer = 0;\n\t\tchar op = ' ';\n\t\tfor(int pointer = 0; pointer < str.length(); pointer++){\n\t\t\tchar pointingChar = str.charAt(pointer);\n\t\t\tif(pointingChar == '(') lvl++;\n\t\t\tif(pointingChar == ')') lvl--;\n\t\t\tif(lvl == 0){\n\t\t\t\tif(pointingChar == 'u' || pointingChar == 'i' || pointingChar == 'd' || pointingChar == 's'){\n\t\t\t\t\topPointer = pointer;\n\t\t\t\t\top = str.charAt(opPointer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tif(opPointer != 0){\n\t\t\t// オペランドが見つかった場合\n\t\t\t// System.out.print(\"演算子: \");\n\t\t\tString leftStr = str.substring(0,opPointer);\n\t\t\tString rightStr = str.substring(opPointer + 1);\n\t\t\t// System.out.println(leftStr + \", \" + rightStr);\n\n\t\t\t// それぞれを構文解析にかける\n\t\t\tOriginalSet leftSet = calc(leftStr);\n\t\t\tOriginalSet rightSet = calc(rightStr);\n\n\t\t\tswitch(op){\n\t\t\tcase 'u':\n\t\t\t\tresultSet = u(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tresultSet = i(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tresultSet = d(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tresultSet = s(leftSet, rightSet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(str.charAt(0) == '('){\n\t\t\t// 括弧を除去する必要がある場合\n\t\t\t// System.out.print(\"括弧除去: \");\n\t\t\tString nextStr = str.substring(1, str.length() - 1);\n\t\t\t// System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\n\t\t}else if(str.charAt(0) == 'c'){\n\t\t\t// System.out.print(\"補集合: \");\n\t\t\t// 補集合をとらなくちゃいけない場合\n\t\t\tString nextStr = str.substring(1, str.length());\n\t\t\t//System.out.println(nextStr);\n\t\t\tresultSet = calc(nextStr);\n\t\t\tresultSet = d(setU, resultSet);\n\t\t\t// System.out.println(\"補集合おわり\");\n\n\t\t}else{\n\t\t\t// 記号に対応する集合を求める\n\t\t\t// System.out.print(\"環境参照: \");\n\t\t\tresultSet = setsEnvironment.get(str);\n\t\t\t// System.out.println(\"環境参照おわり\");\n\t\t}\n\t\treturn resultSet;\n\t}\n\n\t// union\n\tstatic OriginalSet u(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.addAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// intersection\n\tstatic OriginalSet i(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(d(setA, setB));\n\t\treturn resultSet;\n\t}\n\n\t// difference\n\tstatic OriginalSet d(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(setA);\n\t\tresultSet.removeAll(setB);\n\t\treturn resultSet;\n\t}\n\n\t// symmetric difference\n\tstatic OriginalSet s(OriginalSet setA, OriginalSet setB){\n\t\tOriginalSet resultSet = new OriginalSet();\n\t\tresultSet.addAll(d(setA, setB));\n\t\tresultSet.addAll(d(setB, setA));\n\t\treturn resultSet;\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString is;\n\t\tString[] ia;\n\t\twhile((is = in.readLine()) != null){\n\t\t\tname = new String[5];\n\t\t\tset = new ArrayList<TreeSet<Integer>>();\n\t\t\tsetu = new TreeSet<Integer>();\n\t\t\tfor(int i = 0;i < 5; ++i){\n\t\t\t\tia = is.split(\" \");\n\t\t\t\tif(ia[0].equals(\"R\") && ia[1].equals(\"0\")){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[i] = ia[0];\n\t\t\t\tTreeSet<Integer> se = new TreeSet<Integer>();\n\t\t\t\tia = in.readLine().split(\" \");\n\t\t\t\tfor(int j = 0;j < ia.length; ++j){\n\t\t\t\t\tse.add(new Integer(Integer.parseInt(ia[j])));\n\t\t\t\t\tsetu.add(new Integer(Integer.parseInt(ia[j])));\n\t\t\t\t}\n\t\t\t\tset.add(se);\n\t\t\t\tis = in.readLine();\n\t\t\t}\n\t\t\tis = in.readLine();\n\t\t\tTreeSet<Integer> ans = solve(is);\n\t\t\tIterator it = ans.iterator();\n\t\t\tif(it.hasNext()){\n\t\t\t\twhile(true){\n\t\t\t\t\tSystem.out.printf(\"%d\",it.next());\n\t\t\t\t\tif(it.hasNext()){\n\t\t\t\t\t\tSystem.out.printf(\" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} System.out.println(\"\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic String[] name;\n\tstatic TreeSet<Integer> setu;\n\tstatic ArrayList<TreeSet<Integer>> set;\n\tstatic TreeSet<Integer> solve(String a){\n\t\tif(a.length() == 1){\n\t\t\tfor(int i = 0;i < 5 && name[i] != null; ++i){\n\t\t\t\tif(a.equals(name[i])){\n\t\t\t\t\treturn set.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTreeSet<Integer> x = new TreeSet<Integer>();\n\t\tboolean y = false;\n\t\tif(a.charAt(0) == '(' && a.charAt(a.length()-1) == ')'){\n\t\t\ta = a.substring(1,a.length()-1);\n\t\t}\n\t\tif(a.charAt(0) == 'c' && a.matches(\"[(].*[)]\")){\n\t\t\treturn cs(solve(a.substring(1)));\n\t\t} else if(a.charAt(0) == 'c' && a.matches(\"[ABCDEc]*\")){\n\t\t\treturn cs(solve(a.substring(1)));\n\t\t}\n\t\tfor(int i = 0;i < a.length(); ++i){\n\t\t\tif(a.charAt(i) == '('){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(;i < a.length(); ++i){\n\t\t\t\t\tif(a.charAt(i) == '('){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else if(a.charAt(i) == ')'){\n\t\t\t\t\t\t--c;\n\t\t\t\t\t} else if(c == 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a.charAt(i) == 'c'){\n\t\t\t\tint c = 0;\n\t\t\t\tfor(;i < a.length(); ++i){\n\t\t\t\t\tif(a.charAt(i) == '('){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else if(a.charAt(i) == ')'){\n\t\t\t\t\t\t--c;\n\t\t\t\t\t} else if(a.charAt(i) == 'u' ||\n\t\t\t\t\t\t  a.charAt(i) == 'i' ||\n\t\t\t\t\t\t  a.charAt(i) == 'd' ||\n\t\t\t\t\t\t  a.charAt(i) == 's'){\n\t\t\t\t\t\tif(c == 0){\n\t\t\t\t\t\t\t--i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a.charAt(i) == 'u'){\n\t\t\t\t\t\t\t\tTreeSet<Integer> tmp = us(solve(a.substring(0,i)),solve(a.substring(i+1)));\n\t\t\t\t\t\t\t\treturn tmp;\n\t\t\t} else if(a.charAt(i) == 'i'){\n\t\t\t\t\t\t\t\tTreeSet<Integer> tmp = is(solve(a.substring(0,i)),solve(a.substring(i+1)));\n\t\t\t\t\t\t\t\treturn tmp;\n\t\t\t} else if(a.charAt(i) == 'd'){\n\t\t\t\t\t\t\t\tTreeSet<Integer> tmp = ds(solve(a.substring(0,i)),solve(a.substring(i+1)));\n\t\t\t\t\t\t\t\treturn tmp;\n\t\t\t} else if(a.charAt(i) == 's'){\n\t\t\t\t\t\t\t\tTreeSet<Integer> tmp = ss(solve(a.substring(0,i)),solve(a.substring(i+1)));\n\t\t\t\t\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\treturn new TreeSet<Integer>();\n\t}\n\tstatic TreeSet<Integer> cs(TreeSet<Integer> a){\n\t\tTreeSet<Integer> tmp = new TreeSet<Integer>();\n\t\ttmp.addAll(setu);\n\t\tIterator it = a.iterator();\n\t\twhile(it.hasNext()){\n\t\t\ttmp.remove(it.next());\n\t\t}\n\t\treturn tmp;\n\t}\n\tstatic TreeSet<Integer> us(TreeSet<Integer> a, TreeSet<Integer> b){\n\t\tTreeSet<Integer> tmp = new TreeSet<Integer>();\n\t\ttmp.addAll(a);\n\t\ttmp.addAll(b);\n\t\treturn tmp;\n\t}\n\tstatic TreeSet<Integer> is(TreeSet<Integer> a, TreeSet<Integer> b){\n\t\tTreeSet<Integer> tmp = new TreeSet<Integer>();\n\t\tTreeSet<Integer> tmp1 = ds(a,b);\n\t\ttmp.addAll(a);\n\t\tIterator it = tmp1.iterator();\n\t\twhile(it.hasNext()){\n\t\t\ttmp.remove(it.next());\n\t\t}\n\t\treturn tmp;\n\t}\n\tstatic TreeSet<Integer> ds(TreeSet<Integer> a, TreeSet<Integer> b){\n\t\tTreeSet<Integer> tmp = new TreeSet<Integer>();\n\t\ttmp.addAll(a);\n\t\tIterator it = b.iterator();\n\t\twhile(it.hasNext()){\n\t\t\ttmp.remove(it.next());\n\t\t}\n\t\treturn tmp;\n\t}\n\tstatic TreeSet<Integer> ss(TreeSet<Integer> a, TreeSet<Integer> b){\n\t\tTreeSet<Integer> tmp = us(a,b);\n\t\tTreeSet<Integer> tmp1 = is(a,b);\n\t\tIterator it = tmp1.iterator();\n\t\twhile(it.hasNext()){\n\t\t\ttmp.remove(it.next());\n\t\t}\n\t\treturn tmp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\tTreeSet<Integer>[] sets;\n\tString exp;\n\tTreeSet<Integer> U;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tfor (; sc.hasNext();) {\n\t\t\tsets = new TreeSet[256];\n\t\t\tfor (char c = 'A'; c <= 'E'; c++) {\n\t\t\t\tsets[c] = new TreeSet<Integer>();\n\t\t\t}\n\t\t\tU = new TreeSet<Integer>();\n\t\t\tfor (;;) {\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif (c == 'R' && n == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint e = sc.nextInt();\n\t\t\t\t\tsets[c].add(e);\n\t\t\t\t\tU.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\texp = sc.next();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\texp += '\\0';\n\t\tResult r = e(0);\n\t\tdebug(r.set.toArray());\n\t\tif(r.set.size()==0){\n\t\t\tprintln(\"NULL\");\n\t\t}else{\n\t\tfor (Iterator<Integer> it = r.set.iterator(); it.hasNext();) {\n\t\t\tprint(it.next() + (it.hasNext() ? \" \" : \"\\n\"));\n\t\t}\n\t\t}\n\t}\n\n\tResult e(int p) {\n\t\tdebug(\"e\", p);\n\t\tResult r = f(p);\n\t\tdebug(r.set.toArray(), r.p);\n\t\tfor (;;) {\n\t\t\tif (op(exp.charAt(r.p))) {\n\t\t\t\tResult r2 = f(r.p + 1);\n\t\t\t\t// debug(r2.set.toArray(),r2.p);\n\t\t\t\tswitch (exp.charAt(r.p)) {\n\t\t\t\tcase 'u': // or\n\t\t\t\t\tr.set.addAll(r2.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i': // and\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd': // diff\n\t\t\t\t\tr.set.removeAll(r2.set);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // sym\n\t\t\t\t\tfor (int e : U) {\n\t\t\t\t\t\tif (r.set.contains(e) && r2.set.contains(e)) {\n\t\t\t\t\t\t\tr.set.remove(e);\n\t\t\t\t\t\t} else if (r2.set.contains(e)) {\n\t\t\t\t\t\t\tr.set.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr.p = r2.p;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tvoid test(){\n\t\tTreeSet<Integer> a=new TreeSet<Integer>();\n\t\tTreeSet<Integer> b=new TreeSet<Integer>();\n\t\ta.add(1);\n\t\ta.add(2);\n\t\ta.add(3);\n\t\ta.add(4);\n\t\ta.add(5);\n\t\ta.add(6);\n\n\t\tb.add(1);\n\t\tb.add(3);\n\t\tb.add(5);\n\t\tb.add(7);\n\t\tb.add(9);\n\t\tb.add(11);\n\t\t\n\t\tTreeSet<Integer> u=new TreeSet<Integer>();\n\t\tu.addAll(a);\n\t\tu.addAll(b);\n\t\t\n\t\tTreeSet<Integer> s=new TreeSet<Integer>();\n\t\tTreeSet<Integer> t=new TreeSet<Integer>();\n\n\t\ts.addAll(a);\n\t\tt.addAll(b);\n\n\t\ts.addAll(t);\n\t\tdebug(\"or\",s.toArray());\n\n\t\ts.clear();\n\t\ts.addAll(a);\n\t\t\n\t\tfor (int e : u) {\n\t\t\tif (s.contains(e) && t.contains(e)) {\n\t\t\t} else {\n\t\t\t\ts.remove(e);\n\t\t\t}\n\t\t}\n\n\t\tdebug(\"and\",s.toArray());\n\t\t\n\t\ts.clear();\n\t\ts.addAll(a);\n\t\t\n\t\ts.removeAll(t);\n\t\tdebug(\"diff\",s.toArray());\n\t\t\n\t\ts.clear();\n\t\ts.addAll(a);\n\t\t\n\t\tfor (int e : u) {\n\t\t\tif (s.contains(e) && t.contains(e)) {\n\t\t\t\ts.remove(e);\n\t\t\t} else if (t.contains(e)) {\n\t\t\t\ts.add(e);\n\t\t\t}\n\t\t}\n\t\tdebug(\"sym\",s.toArray());\n\t\t\n\t}\n\t\n\tboolean op(char c) {\n\t\treturn c == 'u' || c == 'i' || c == 'd' || c == 's';\n\t}\n\n\tResult f(int p) {\n\t\tdebug(\"f\", p);\n\t\tif (exp.charAt(p) == 'c') {\n\t\t\tResult r = f(p + 1);\n\t\t\tTreeSet<Integer> c = new TreeSet<Integer>();\n\t\t\tfor (int e : U) {\n\t\t\t\tif (!r.set.contains(e)) {\n\t\t\t\t\tc.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.set.clear();\n\t\t\tr.set.addAll(c);\n\t\t\treturn r;\n\t\t} else {\n\t\t\treturn t(p);\n\t\t}\n\t}\n\n\tResult t(int p) {\n\t\tdebug(\"t\", p);\n\t\tif (exp.charAt(p) == '(') {\n\t\t\tResult r = e(p + 1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t} else {\n\t\t\tResult r = new Result(p + 1);\n\t\t\tr.set.addAll(sets[exp.charAt(p)]);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tclass Result {\n\t\tint p;\n\t\tTreeSet<Integer> set;\n\n\t\tResult(int p) {\n\t\t\tthis.p = p;\n\t\t\tset = new TreeSet<Integer>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\t//System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s;\n\t\t\tif((s=Console.ReadLine())==null)break;\n\t\t\tDictionary<String,String> strSets=new Dictionary<String,String>();\n\t\t\twhile(true){\n\t\t\t\tvar t=Console.ReadLine();\n//Console.WriteLine(s.Substring(0,1)+\"\\t\"+t);\n\t\t\t\tstrSets.Add(s.Substring(0,1),t);\n\t\t\t\ts=Console.ReadLine();\n\t\t\t\tif(s[0]=='R')break;\n\t\t\t\t//s=Console.ReadLine();\n\t\t\t}\n\t\t\tString expr=Console.ReadLine();\n\t\t\tSol mySol=new Sol(strSets,expr);\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\t\n\tSet U;\n\t\n\tpublic Sol(Dictionary<String,String> strSets,String expr_in){\n\t\tString expr=expr_in;\n\n\t\tSet[] sets=new Set[strSets.Count];\n\t\t\n\t\tint i=0;\n\t\tforeach(KeyValuePair<string, string> kvp in strSets){\n\t\t\tvar s=kvp.Value.Replace(' ',',');\n\t\t\ts=\"{\"+s+\"}\";\n\n\t\t\tsets[i]=new Set(s);\n\t\t\ti++;\n\t\t\t//式中はすべてcsv({a,b,...})で統一\n\t\t\texpr=expr.Replace(kvp.Key,s);\n\t\t}\n//Console.WriteLine(expr);\n//Console.WriteLine(sets[0].toCsv()+\"i\"+sets[1].toCsv()+\"=\"+Set.CreateIntersection(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"u\"+sets[1].toCsv()+\"=\"+Set.CreateUnion(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"d\"+sets[1].toCsv()+\"=\"+Set.CreateSub(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"s\"+sets[1].toCsv()+\"=\"+Set.CreateSymDiff(sets[0],sets[1]).toCsv());\n\n\t\t\n\t\tU=Set.CreateAllUnion(sets);\n//Console.WriteLine(\"ALL Union\"+\"=\"+U.toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"-Complement\"+\"=\"+Set.CreateSub(U,sets[0]).toCsv());\n\n\t\tString ss=ParseAndCalc(expr);\n\t\t\n\t\tif(ss==\"{}\")ans=\"NULL\";\n\t\tif(ss!=\"{}\"){\n\t\t\tss=ss.Substring(1,ss.Length-2);\n\t\t\tss=ss.Replace(',',' ');\n\t\t\tans=ss;\n\t\t}\n\t}\n\n\tString ParseAndCalc(String expr){\n\t\tString ret=String.Copy(expr);\n//Console.WriteLine(ret);\n\t\tbool chk=true;\n\t\twhile(chk){\n//Console.WriteLine(ret+\"1\\t\"+chk.ToString());\n\t\t\tchk=false;\n\t\t\tint i;\n\t\t\t\n\t\t\t//まず'('を処理する\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='('){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//Console.WriteLine(ret+\"2\\t\"+chk.ToString());\n\t\t\tif(chk){\n\t\t\t\tint depth=1;\n\t\t\t\tint j=i;\n\t\t\t\twhile(depth!=0){\n\t\t\t\t\tj++;\n\t\t\t\t\tif(ret[j]=='(')depth++;\n\t\t\t\t\tif(ret[j]==')')depth--;\n\t\t\t\t}\n\t\t\t\tvar s=ret.Substring(i+1,j-i+1-2);\n\t\t\t\tret=ret.Substring(0,i)+ParseAndCalc(s)+ret.Substring(j+1);\n\t\t\t\tcontinue;\n\t\t\t}\n//Console.WriteLine(ret+\"3\\t\"+chk.ToString());\n\t\t\t//集合演算子は先頭から処理。\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'||ret[i]=='c'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//Console.WriteLine(ret+\"4\\t\"+chk.ToString());\n\n\t\t\tif(chk){\n\t\t\t\tint lt=0;\n\t\t\t\tint lb=0;\n\t\t\t\tint rt=0;\n\t\t\t\tint rb=0;\n\t\t\t\t//右オペランド\n\t\t\t\trt=i+1;\n\t\t\t\tfor(rb=rt;ret[rb]!='}';rb++);\n\t\t\t\tSet R=new Set(ret.Substring(rt,rb-rt+1));\n\t\t\t\t//左オペランド\n\t\t\t\tSet L=null;\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'){\n\t\t\t\t\tlb=i-1;\n\t\t\t\t\tfor(lt=lb;ret[lt]!='{';lt--);\n\t\t\t\t\tL=new Set(ret.Substring(lt,lb-lt+1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch(ret[i]){\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateUnion(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateIntersection(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSub(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSymDiff(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tret=ret.Substring(0,i)+Set.CreateSub(U,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n//Console.WriteLine(ret+\"5\\t\"+chk.ToString());\n\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\n}\n\n\n\n\n\nclass Set{\n\tList<int> content;\n\tpublic int this[int i]{\n\t\t//set{content[i]=value;}\n\t\tget{return content[i];}\n\t}\n\t\n\tpublic int Size{\n\t\tget{return content.Count;}\n\t}\n\n\tpublic String toCsv(){\n\t\tString s=\"{\";\n\t\tif(this.Size>0){\n\t\t\tString[] t=Array.ConvertAll(content.ToArray(),elem=>elem.ToString());\n\t\t\ts=s+String.Join(\",\",t);\n\t\t}\n\t\ts+=\"}\";\n\t\treturn s;\n\t}\n\t\n\n\n\t\n\tpublic Set(List<int> Lin){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<Lin.Count;k++){\n\t\t\tcontent.Add(Lin[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(int[] arr){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<arr.Length;k++){\n\t\t\tcontent.Add(arr[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(String csv){ //csv: {a,b,...} or {}(empty)\n\t\tcontent=new List<int>();\n\t\tif(csv.Length>2){\n\t\t\tvar ss=csv.Substring(1,csv.Length-2).Split(',');\n\t\t\tfor(int k=0;k<ss.Length;k++){\n\t\t\t\tcontent.Add(int.Parse(ss[k]));\n\t\t\t}\n\t\t\t//sort when constructed\n\t\t\tcontent.Sort();\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tpublic static Set CreateIntersection(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tfor(int j=0;j<B.Size;j++){\n\t\t\t\tif(A[i]==B[j]){\n\t\t\t\t\tL.Add(A[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateUnion(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<B.Size;i++){\n\t\t\tL.Add(B[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tif(L.Contains(A[i])==false)L.Add(A[i]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateSub(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tL.Add(A[i]);\n\t\t}\n\t\t\n\t\tfor(int j=0;j<B.Size;j++){\n\t\t\tif(L.Contains(B[j]))L.Remove(B[j]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\t\n\tpublic static Set CreateSymDiff(Set A,Set B){\n\t\treturn Set.CreateUnion( Set.CreateSub(A,B),Set.CreateSub(B,A));\n\t}\n\t\n\tpublic static Set CreateAllUnion(Set[] sets){\n\n\t\tint[] arr=new int[sets[0].Size];\n\t\tfor(int i=0;i<sets[0].Size;i++)arr[i]=sets[0][i];\n\t\tSet U= new Set(arr);\n\n\t\tif(sets.Length==1){\n\t\t\treturn U;\n\t\t}\n\t\t\n\t\tSet V=U;\n\t\tfor(int i=1;i<sets.Length;i++){\n\t\t\tV=Set.CreateUnion(V,sets[i]);\n\t\t}\n\t\treturn V;\n\t}\n}\n\t"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s;\n\t\t\tif((s=Console.ReadLine())==null)break;\n\t\t\tDictionary<String,String> strSets=new Dictionary<String,String>();\n\t\t\twhile(true){\n\t\t\t\tvar t=Console.ReadLine();\n//Console.WriteLine(s.Substring(0,1)+\"\\t\"+t);\n\t\t\t\tstrSets.Add(s.Substring(0,1),t);\n\t\t\t\ts=Console.ReadLine();\n\t\t\t\tif(s[0]=='R')break;\n\t\t\t\t//s=Console.ReadLine();\n\t\t\t}\n\t\t\tString expr=Console.ReadLine();\n\t\t\tSol mySol=new Sol(strSets,expr);\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\t\n\tSet U;\n\t\n\tpublic Sol(Dictionary<String,String> strSets,String expr_in){\n\t\tString expr=expr_in;\n\n\t\tSet[] sets=new Set[strSets.Count];\n\t\t\n\t\tint i=0;\n\t\tforeach(KeyValuePair<string, string> kvp in strSets){\n\t\t\tvar s=kvp.Value.Replace(' ',',');\n\t\t\ts=\"{\"+s+\"}\";\n\n\t\t\tsets[i]=new Set(s);\n\t\t\ti++;\n\t\t\t//式中はすべてcsv({a,b,...})で統一\n\t\t\texpr=expr.Replace(kvp.Key,s);\n\t\t}\n\t\t\n\t\tU=Set.CreateAllUnion(sets);\n\n\t\tString ss=ParseAndCalc(expr);\n\t\t\n\t\tif(ss==\"{}\")ans=\"NULL\";\n\t\tif(ss!=\"{}\"){\n\t\t\tss=ss.Substring(1,ss.Length-2);\n\t\t\tss=ss.Replace(',',' ');\n\t\t\tans=ss;\n\t\t}\n\t}\n\n\tString ParseAndCalc(String expr){\n\t\tString ret=String.Copy(expr);\n\t\tbool chk=true;\n\t\twhile(chk){\n\t\t\tchk=false;\n\t\t\tint i;\n\t\t\t\n\t\t\t//まず'('を処理する\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='('){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chk){\n\t\t\t\tint depth=1;\n\t\t\t\tint j=i;\n\t\t\t\twhile(depth!=0){\n\t\t\t\t\tj++;\n\t\t\t\t\tif(ret[j]=='(')depth++;\n\t\t\t\t\tif(ret[j]==')')depth--;\n\t\t\t\t}\n\t\t\t\tvar s=ret.Substring(i+1,j-i+1-2);\n\t\t\t\tret=ret.Substring(0,i)+ParseAndCalc(s)+ret.Substring(j+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//次にComplementを処理\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='c'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chk){\n\t\t\t\tint rt=0;\n\t\t\t\tint rb=0;\n\t\t\t\t//右オペランド\n\t\t\t\trt=i+1;\n\t\t\t\tfor(rb=rt;ret[rb]!='}';rb++);\n\t\t\t\tSet R=new Set(ret.Substring(rt,rb-rt+1));\n\t\t\t\t\n\t\t\t\tret=ret.Substring(0,i)+Set.CreateSub(U,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//集合演算子は先頭から処理。\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(chk){\n\t\t\t\tint lt=0;\n\t\t\t\tint lb=0;\n\t\t\t\tint rt=0;\n\t\t\t\tint rb=0;\n\t\t\t\t//右オペランド\n\t\t\t\trt=i+1;\n\t\t\t\tfor(rb=rt;ret[rb]!='}';rb++);\n\t\t\t\tSet R=new Set(ret.Substring(rt,rb-rt+1));\n\t\t\t\t//左オペランド\n\t\t\t\tlb=i-1;\n\t\t\t\tfor(lt=lb;ret[lt]!='{';lt--);\n\t\t\t\tSet L=new Set(ret.Substring(lt,lb-lt+1));\n\t\t\t\t\n\t\t\t\tswitch(ret[i]){\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateUnion(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateIntersection(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSub(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSymDiff(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\n}\n\n\n\n\n\nclass Set{\n\tList<int> content;\n\tpublic int this[int i]{\n\t\t//set{content[i]=value;}\n\t\tget{return content[i];}\n\t}\n\t\n\tpublic int Size{\n\t\tget{return content.Count;}\n\t}\n\n\tpublic String toCsv(){\n\t\tString s=\"{\";\n\t\tif(this.Size>0){\n\t\t\tString[] t=Array.ConvertAll(content.ToArray(),elem=>elem.ToString());\n\t\t\ts=s+String.Join(\",\",t);\n\t\t}\n\t\ts+=\"}\";\n\t\treturn s;\n\t}\n\t\n\n\n\t\n\tpublic Set(List<int> Lin){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<Lin.Count;k++){\n\t\t\tcontent.Add(Lin[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(int[] arr){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<arr.Length;k++){\n\t\t\tcontent.Add(arr[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(String csv){ //csv: {a,b,...} or {}(empty)\n\t\tcontent=new List<int>();\n\t\tif(csv.Length>2){\n\t\t\tvar ss=csv.Substring(1,csv.Length-2).Split(',');\n\t\t\tfor(int k=0;k<ss.Length;k++){\n\t\t\t\tcontent.Add(int.Parse(ss[k]));\n\t\t\t}\n\t\t\t//sort when constructed\n\t\t\tcontent.Sort();\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tpublic static Set CreateIntersection(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tfor(int j=0;j<B.Size;j++){\n\t\t\t\tif(A[i]==B[j]){\n\t\t\t\t\tL.Add(A[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateUnion(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<B.Size;i++){\n\t\t\tL.Add(B[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tif(L.Contains(A[i])==false)L.Add(A[i]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateSub(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tL.Add(A[i]);\n\t\t}\n\t\t\n\t\tfor(int j=0;j<B.Size;j++){\n\t\t\tif(L.Contains(B[j]))L.Remove(B[j]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\t\n\tpublic static Set CreateSymDiff(Set A,Set B){\n\t\treturn Set.CreateUnion( Set.CreateSub(A,B),Set.CreateSub(B,A));\n\t}\n\t\n\tpublic static Set CreateAllUnion(Set[] sets){\n\n\t\tint[] arr=new int[sets[0].Size];\n\t\tfor(int i=0;i<sets[0].Size;i++)arr[i]=sets[0][i];\n\t\tSet U= new Set(arr);\n\n\t\tif(sets.Length==1){\n\t\t\treturn U;\n\t\t}\n\t\t\n\t\tSet V=U;\n\t\tfor(int i=1;i<sets.Length;i++){\n\t\t\tV=Set.CreateUnion(V,sets[i]);\n\t\t}\n\t\treturn V;\n\t}\n}\n\t"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\n\tstatic void aMain(){\n\t\tSet A=new Set(\"{1,3,-5}\");\n\t\tSet B=new Set(new int[20]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,28,19,20});\n\t\tSet C=new Set(new int[5]{2,4,-100,28,39});\n\t\tConsole.WriteLine(A.toCsv());\n\t\tConsole.WriteLine(B.toCsv());\n\t\tConsole.WriteLine(C.toCsv());\n\t\tConsole.WriteLine(Set.CreateIntersection(A,B).toCsv());\n\t\tConsole.WriteLine(Set.CreateIntersection(B,C).toCsv());\n\t\tConsole.WriteLine(Set.CreateIntersection(C,A).toCsv());\n\t\tConsole.WriteLine(Set.CreateUnion(A,B).toCsv());\n\t\tConsole.WriteLine(Set.CreateUnion(B,C).toCsv());\n\t\tConsole.WriteLine(Set.CreateUnion(C,A).toCsv());\n\t\tConsole.WriteLine(Set.CreateSub(A,B).toCsv());\n\t\tConsole.WriteLine(Set.CreateSub(B,C).toCsv());\n\t\tConsole.WriteLine(Set.CreateSub(C,A).toCsv());\n\t\tConsole.WriteLine(Set.CreateSymDiff(A,B).toCsv());\n\t\tConsole.WriteLine(Set.CreateSymDiff(B,C).toCsv());\n\t\tConsole.WriteLine(Set.CreateSymDiff(C,A).toCsv());\n\n\n\n\n\t}\n\n\n\n\n\n\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s;\n\t\t\tif((s=Console.ReadLine())==null)break;\n\t\t\tDictionary<String,String> strSets=new Dictionary<String,String>();\n\t\t\twhile(true){\n\t\t\t\tvar t=Console.ReadLine();\n//Console.WriteLine(s.Substring(0,1)+\"\\t\"+t);\n\t\t\t\tstrSets.Add(s.Substring(0,1),t);\n\t\t\t\ts=Console.ReadLine();\n\t\t\t\tif(s[0]=='R')break;\n\t\t\t\t//s=Console.ReadLine();\n\t\t\t}\n\t\t\tString expr=Console.ReadLine();\n\t\t\tSol mySol=new Sol(strSets,expr);\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\t\n\tSet U;\n\t\n\tpublic Sol(Dictionary<String,String> strSets,String expr_in){\n\t\tString expr=expr_in;\n\n\t\tSet[] sets=new Set[strSets.Count];\n\t\t\n\t\tint i=0;\n\t\tforeach(KeyValuePair<string, string> kvp in strSets){\n\t\t\tvar s=kvp.Value.Replace(' ',',');\n\t\t\ts=\"{\"+s+\"}\";\n\n\t\t\tsets[i]=new Set(s);\n\t\t\ti++;\n\t\t\t//式中はすべてcsv({a,b,...})で統一\n\t\t\texpr=expr.Replace(kvp.Key,s);\n\t\t}\n//Console.WriteLine(expr);\n//Console.WriteLine(sets[0].toCsv()+\"i\"+sets[1].toCsv()+\"=\"+Set.CreateIntersection(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"u\"+sets[1].toCsv()+\"=\"+Set.CreateUnion(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"d\"+sets[1].toCsv()+\"=\"+Set.CreateSub(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"s\"+sets[1].toCsv()+\"=\"+Set.CreateSymDiff(sets[0],sets[1]).toCsv());\n\n\t\t\n\t\tU=Set.CreateAllUnion(sets);\n//Console.WriteLine(\"ALL Union\"+\"=\"+U.toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"-Complement\"+\"=\"+Set.CreateSub(U,sets[0]).toCsv());\n\n\t\tString ss=ParseAndCalc(expr);\n\t\t\n\t\tif(ss==\"{}\")ans=\"NULL\";\n\t\tif(ss!=\"{}\"){\n\t\t\tss=ss.Substring(1,ss.Length-2);\n\t\t\tss=ss.Replace(',',' ');\n\t\t\tans=ss;\n\t\t}\n\t}\n\n\tString ParseAndCalc(String expr){\n\t\tString ret=String.Copy(expr);\n//Console.WriteLine(ret);\n\t\tbool chk=true;\n\t\twhile(chk){\n//Console.WriteLine(ret+\"1\\t\"+chk.ToString());\n\t\t\tchk=false;\n\t\t\tint i;\n\t\t\t\n\t\t\t//まず'('を処理する\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='('){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//Console.WriteLine(ret+\"2\\t\"+chk.ToString());\n\t\t\tif(chk){\n\t\t\t\tint depth=1;\n\t\t\t\tint depthmax=depth;\n\t\t\t\t//最も深い()をParseする（再帰潜りすぎ対策）\n\t\t\t\tint l=0;int j=0;\n\t\t\t\tfor(l=i;l<ret.Length;l++){\n\t\t\t\t\tif(ret[l]=='(')depth++;\n\t\t\t\t\tif(ret[l]==')')depth--;\n\t\t\t\t\tif(depthmax<depth){\n\t\t\t\t\t\tdepthmax=depth;\n\t\t\t\t\t\ti=l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(j=i;ret[j]!=')';j++);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar s=ret.Substring(i+1,j-i+1-2);\n\t\t\t\tret=ret.Substring(0,i)+ParseAndCalc(s)+ret.Substring(j+1);\n\t\t\t\tcontinue;\n\t\t\t}\n//Console.WriteLine(ret+\"3\\t\"+chk.ToString());\n\t\t\t//集合演算子は先頭から処理。\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'||ret[i]=='c'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//Console.WriteLine(ret+\"4\\t\"+chk.ToString());\n\n\t\t\tif(chk){\n\t\t\t\tint lt=0;\n\t\t\t\tint lb=0;\n\t\t\t\tint rt=0;\n\t\t\t\tint rb=0;\n\t\t\t\t//右オペランド\n\t\t\t\trt=i+1;\n\t\t\t\tfor(rb=rt;ret[rb]!='}';rb++);\n\t\t\t\tSet R=new Set(ret.Substring(rt,rb-rt+1));\n\t\t\t\t//左オペランド\n\t\t\t\tSet L=new Set(\"{}\");\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'){\n\t\t\t\t\tlb=i-1;\n\t\t\t\t\tfor(lt=lb;ret[lt]!='{';lt--);\n\t\t\t\t\tL=new Set(ret.Substring(lt,lb-lt+1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch(ret[i]){\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateUnion(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateIntersection(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSub(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSymDiff(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tret=ret.Substring(0,i)+Set.CreateSub(U,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n//Console.WriteLine(ret+\"5\\t\"+chk.ToString());\n\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\n}\n\n\n\n\n\nclass Set{\n\tList<int> content;\n\tpublic int this[int i]{\n\t\t//set{content[i]=value;}\n\t\tget{return content[i];}\n\t}\n\t\n\tpublic int Size{\n\t\tget{return content.Count;}\n\t}\n\n\tpublic String toCsv(){\n\t\tString s=\"{\";\n\t\tif(this.Size>0){\n\t\t\tString[] t=Array.ConvertAll(content.ToArray(),elem=>elem.ToString());\n\t\t\ts=s+String.Join(\",\",t);\n\t\t}\n\t\ts+=\"}\";\n\t\treturn s;\n\t}\n\t\n\n\n\t\n\tpublic Set(List<int> Lin){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<Lin.Count;k++){\n\t\t\tcontent.Add(Lin[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(int[] arr){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<arr.Length;k++){\n\t\t\tcontent.Add(arr[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(String csv){ //csv: {a,b,...} or {}(empty)\n\t\tcontent=new List<int>();\n\t\tif(csv.Length>2){\n\t\t\tvar ss=csv.Substring(1,csv.Length-2).Split(',');\n\t\t\tfor(int k=0;k<ss.Length;k++){\n\t\t\t\tcontent.Add(int.Parse(ss[k]));\n\t\t\t}\n\t\t\t//sort when constructed\n\t\t\tcontent.Sort();\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tpublic static Set CreateIntersection(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tfor(int j=0;j<B.Size;j++){\n\t\t\t\tif(A[i]==B[j]){\n\t\t\t\t\tL.Add(A[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateUnion(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<B.Size;i++){\n\t\t\tL.Add(B[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tif(L.Contains(A[i])==false)L.Add(A[i]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateSub(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tL.Add(A[i]);\n\t\t}\n\t\t\n\t\tfor(int j=0;j<B.Size;j++){\n\t\t\tif(L.Contains(B[j]))L.Remove(B[j]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\t\n\tpublic static Set CreateSymDiff(Set A,Set B){\n\t\treturn Set.CreateUnion( Set.CreateSub(A,B),Set.CreateSub(B,A));\n\t}\n\t\n\tpublic static Set CreateAllUnion(Set[] sets){\n\n\t\tint[] arr=new int[sets[0].Size];\n\t\tfor(int i=0;i<sets[0].Size;i++)arr[i]=sets[0][i];\n\t\tSet U= new Set(arr);\n\n\t\tif(sets.Length==1){\n\t\t\treturn U;\n\t\t}\n\t\t\n\t\tSet V=U;\n\t\tfor(int i=1;i<sets.Length;i++){\n\t\t\tV=Set.CreateUnion(V,sets[i]);\n\t\t}\n\t\treturn V;\n\t}\n}\n\t"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s;\n\t\t\tif((s=Console.ReadLine())==null)break;\n\t\t\tDictionary<String,String> strSets=new Dictionary<String,String>();\n\t\t\twhile(true){\n\t\t\t\tvar t=Console.ReadLine();\n//Console.WriteLine(s.Substring(0,1)+\"\\t\"+t);\n\t\t\t\tstrSets.Add(s.Substring(0,1),t);\n\t\t\t\ts=Console.ReadLine();\n\t\t\t\tif(s[0]=='R')break;\n\t\t\t\t//s=Console.ReadLine();\n\t\t\t}\n\t\t\tString expr=Console.ReadLine();\n\t\t\tSol mySol=new Sol(strSets,expr);\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\t\n\tSet U;\n\t\n\tpublic Sol(Dictionary<String,String> strSets,String expr_in){\n\t\tString expr=expr_in;\n\n\t\tSet[] sets=new Set[strSets.Count];\n\t\t\n\t\tint i=0;\n\t\tforeach(KeyValuePair<string, string> kvp in strSets){\n\t\t\tvar s=kvp.Value.Replace(' ',',');\n\t\t\ts=\"{\"+s+\"}\";\n\n\t\t\tsets[i]=new Set(s);\n\t\t\ti++;\n\t\t\t//式中はすべてcsv({a,b,...})で統一\n\t\t\texpr=expr.Replace(kvp.Key,s);\n\t\t}\n//Console.WriteLine(expr);\n//Console.WriteLine(sets[0].toCsv()+\"i\"+sets[1].toCsv()+\"=\"+Set.CreateIntersection(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"u\"+sets[1].toCsv()+\"=\"+Set.CreateUnion(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"d\"+sets[1].toCsv()+\"=\"+Set.CreateSub(sets[0],sets[1]).toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"s\"+sets[1].toCsv()+\"=\"+Set.CreateSymDiff(sets[0],sets[1]).toCsv());\n\n\t\t\n\t\tU=Set.CreateAllUnion(sets);\n//Console.WriteLine(\"ALL Union\"+\"=\"+U.toCsv());\n//Console.WriteLine(sets[0].toCsv()+\"-Complement\"+\"=\"+Set.CreateSub(U,sets[0]).toCsv());\n\n\t\tString ss=ParseAndCalc(expr);\n\t\t\n\t\tif(ss==\"{}\")ans=\"NULL\";\n\t\tif(ss!=\"{}\"){\n\t\t\tss=ss.Substring(1,ss.Length-2);\n\t\t\tss=ss.Replace(',',' ');\n\t\t\tans=ss;\n\t\t}\n\t}\n\n\tString ParseAndCalc(String expr){\n\t\tString ret=String.Copy(expr);\n//Console.WriteLine(ret);\n\t\tbool chk=true;\n\t\twhile(chk){\n//Console.WriteLine(ret+\"1\\t\"+chk.ToString());\n\t\t\tchk=false;\n\t\t\tint i;\n\t\t\t\n\t\t\t//まず'('を処理する\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='('){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//Console.WriteLine(ret+\"2\\t\"+chk.ToString());\n\t\t\tif(chk){\n\t\t\t\tint depth=1;\n\t\t\t\tint depthmax=depth;\n\t\t\t\t//最も深い()をParseする（再帰潜りすぎ対策）\n\t\t\t\tint l=0;int j=0;\n\t\t\t\tfor(l=i;l<ret.Length;l++){\n\t\t\t\t\tif(ret[l]=='(')depth++;\n\t\t\t\t\tif(ret[l]==')')depth--;\n\t\t\t\t\tif(depthmax<depth){\n\t\t\t\t\t\tdepthmax=depth;\n\t\t\t\t\t\ti=l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(j=i;ret[j]!=')';j++);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar s=ret.Substring(i+1,j-i+1-2);\n\t\t\t\tret=ret.Substring(0,i)+ParseAndCalc(s)+ret.Substring(j+1);\n\t\t\t\tcontinue;\n\t\t\t}\n//Console.WriteLine(ret+\"3\\t\"+chk.ToString());\n\t\t\t//集合演算子は先頭から処理。\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'||ret[i]=='c'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//Console.WriteLine(ret+\"4\\t\"+chk.ToString());\n\n\t\t\tif(chk){\n\t\t\t\tint lt=0;\n\t\t\t\tint lb=0;\n\t\t\t\tint rt=0;\n\t\t\t\tint rb=0;\n\t\t\t\t//右オペランド\n\t\t\t\trt=i+1;\n\t\t\t\tfor(rb=rt;ret[rb]!='}';rb++);\n\t\t\t\tSet R=new Set(ret.Substring(rt,rb-rt+1));\n\t\t\t\t//左オペランド\n\t\t\t\tSet L=null;\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'){\n\t\t\t\t\tlb=i-1;\n\t\t\t\t\tfor(lt=lb;ret[lt]!='{';lt--);\n\t\t\t\t\tL=new Set(ret.Substring(lt,lb-lt+1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch(ret[i]){\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateUnion(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateIntersection(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSub(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSymDiff(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tret=ret.Substring(0,i)+Set.CreateSub(U,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n//Console.WriteLine(ret+\"5\\t\"+chk.ToString());\n\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\n}\n\n\n\n\n\nclass Set{\n\tList<int> content;\n\tpublic int this[int i]{\n\t\t//set{content[i]=value;}\n\t\tget{return content[i];}\n\t}\n\t\n\tpublic int Size{\n\t\tget{return content.Count;}\n\t}\n\n\tpublic String toCsv(){\n\t\tString s=\"{\";\n\t\tif(this.Size>0){\n\t\t\tString[] t=Array.ConvertAll(content.ToArray(),elem=>elem.ToString());\n\t\t\ts=s+String.Join(\",\",t);\n\t\t}\n\t\ts+=\"}\";\n\t\treturn s;\n\t}\n\t\n\n\n\t\n\tpublic Set(List<int> Lin){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<Lin.Count;k++){\n\t\t\tcontent.Add(Lin[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(int[] arr){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<arr.Length;k++){\n\t\t\tcontent.Add(arr[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(String csv){ //csv: {a,b,...} or {}(empty)\n\t\tcontent=new List<int>();\n\t\tif(csv.Length>2){\n\t\t\tvar ss=csv.Substring(1,csv.Length-2).Split(',');\n\t\t\tfor(int k=0;k<ss.Length;k++){\n\t\t\t\tcontent.Add(int.Parse(ss[k]));\n\t\t\t}\n\t\t\t//sort when constructed\n\t\t\tcontent.Sort();\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tpublic static Set CreateIntersection(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tfor(int j=0;j<B.Size;j++){\n\t\t\t\tif(A[i]==B[j]){\n\t\t\t\t\tL.Add(A[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateUnion(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<B.Size;i++){\n\t\t\tL.Add(B[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tif(L.Contains(A[i])==false)L.Add(A[i]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateSub(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tL.Add(A[i]);\n\t\t}\n\t\t\n\t\tfor(int j=0;j<B.Size;j++){\n\t\t\tif(L.Contains(B[j]))L.Remove(B[j]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\t\n\tpublic static Set CreateSymDiff(Set A,Set B){\n\t\treturn Set.CreateUnion( Set.CreateSub(A,B),Set.CreateSub(B,A));\n\t}\n\t\n\tpublic static Set CreateAllUnion(Set[] sets){\n\n\t\tint[] arr=new int[sets[0].Size];\n\t\tfor(int i=0;i<sets[0].Size;i++)arr[i]=sets[0][i];\n\t\tSet U= new Set(arr);\n\n\t\tif(sets.Length==1){\n\t\t\treturn U;\n\t\t}\n\t\t\n\t\tSet V=U;\n\t\tfor(int i=1;i<sets.Length;i++){\n\t\t\tV=Set.CreateUnion(V,sets[i]);\n\t\t}\n\t\treturn V;\n\t}\n}\n\t"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s;\n\t\t\tif((s=Console.ReadLine())==null)break;\n\t\t\tDictionary<String,String> strSets=new Dictionary<String,String>();\n\t\t\twhile(true){\n\t\t\t\tvar t=Console.ReadLine();\n\t\t\t\tstrSets.Add(s.Substring(0,1),t);\n\t\t\t\ts=Console.ReadLine();\n\t\t\t\tif(s[0]=='R')break;\n\t\t\t\t//s=Console.ReadLine();\n\t\t\t}\n\t\t\tString expr=Console.ReadLine();\n\t\t\tSol mySol=new Sol(strSets,expr);\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\t\n\tSet U;\n\t\n\tpublic Sol(Dictionary<String,String> strSets,String expr_in){\n\t\tString expr=expr_in;\n\n\t\tSet[] sets=new Set[strSets.Count];\n\t\t\n\t\tint i=0;\n\t\tforeach(KeyValuePair<string, string> kvp in strSets){\n\t\t\tvar s=kvp.Value.Replace(' ',',');\n\t\t\ts=\"{\"+s+\"}\";\n\n\t\t\tsets[i]=new Set(s);\n\t\t\ti++;\n\t\t\t//式中はすべてcsv({a,b,...})で統一\n\t\t\texpr=expr.Replace(kvp.Key,s);\n\t\t}\n\t\t\n\t\tU=Set.CreateAllUnion(sets);\n\t\tString ss=ParseAndCalc(expr);\n\t\t\n\t\tif(ss==\"{}\")ans=\"NULL\";\n\t\tif(ss!=\"{}\"){\n\t\t\tss=ss.Substring(1,ss.Length-2);\n\t\t\tss=ss.Replace(',',' ');\n\t\t\tans=ss;\n\t\t}\n\t}\n\n\tString ParseAndCalc(String expr){\n\t\tString ret=String.Copy(expr);\n\t\tbool chk=true;\n\t\twhile(chk){\n\t\t\tchk=false;\n\t\t\tint i;\n\t\t\t\n\t\t\t//まず'('を処理する\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='('){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chk){\n\t\t\t\tint depth=1;\n\t\t\t\tint j=i;\n\t\t\t\twhile(depth!=0){\n\t\t\t\t\tj++;\n\t\t\t\t\tif(ret[j]=='(')depth++;\n\t\t\t\t\tif(ret[j]==')')depth--;\n\t\t\t\t}\n\t\t\t\tvar s=ret.Substring(i+1,j-i+1-2);\n\t\t\t\tret=ret.Substring(0,i)+ParseAndCalc(s)+ret.Substring(j+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//集合演算子は先頭から処理。\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'||ret[i]=='c'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(chk){\n\t\t\t\tint lt=0;\n\t\t\t\tint lb=0;\n\t\t\t\tint rt=0;\n\t\t\t\tint rb=0;\n\t\t\t\t//右オペランド\n\t\t\t\trt=i+1;\n\t\t\t\tfor(rb=rt;ret[rb]!='}';rb++);\n\t\t\t\tSet R=new Set(ret.Substring(rt,rb-rt+1));\n\t\t\t\t//左オペランド\n\t\t\t\tSet L=null;\n\t\t\t\tif(ret[i]=='u'||ret[i]=='i'||ret[i]=='d'||ret[i]=='s'){\n\t\t\t\t\tlb=i-1;\n\t\t\t\t\tfor(lt=lb;ret[lt]!='{';lt--);\n\t\t\t\t\tL=new Set(ret.Substring(lt,lb-lt+1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch(ret[i]){\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateUnion(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateIntersection(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSub(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tret=ret.Substring(0,lt)+Set.CreateSymDiff(L,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tret=ret.Substring(0,i)+Set.CreateSub(U,R).toCsv()+ret.Substring(rb+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\n}\n\n\n\n\n\nclass Set{\n\tList<int> content;\n\tpublic int this[int i]{\n\t\t//set{content[i]=value;}\n\t\tget{return content[i];}\n\t}\n\t\n\tpublic int Size{\n\t\tget{return content.Count;}\n\t}\n\n\tpublic String toCsv(){\n\t\tString s=\"{\";\n\t\tif(this.Size>0){\n\t\t\tString[] t=Array.ConvertAll(content.ToArray(),elem=>elem.ToString());\n\t\t\ts=s+String.Join(\",\",t);\n\t\t}\n\t\ts+=\"}\";\n\t\treturn s;\n\t}\n\t\n\n\n\t\n\tpublic Set(List<int> Lin){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<Lin.Count;k++){\n\t\t\tcontent.Add(Lin[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(int[] arr){\n\t\tcontent=new List<int>();\n\t\tfor(int k=0;k<arr.Length;k++){\n\t\t\tcontent.Add(arr[k]);\n\t\t}\n\t\t//sort when constructed\n\t\tcontent.Sort();\n\t}\n\tpublic Set(String csv){ //csv: {a,b,...} or {}(empty)\n\t\tcontent=new List<int>();\n\t\tif(csv.Length>2){\n\t\t\tvar ss=csv.Substring(1,csv.Length-2).Split(',');\n\t\t\tfor(int k=0;k<ss.Length;k++){\n\t\t\t\tcontent.Add(int.Parse(ss[k]));\n\t\t\t}\n\t\t\t//sort when constructed\n\t\t\tcontent.Sort();\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tpublic static Set CreateIntersection(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tfor(int j=0;j<B.Size;j++){\n\t\t\t\tif(A[i]==B[j]){\n\t\t\t\t\tL.Add(A[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateUnion(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<B.Size;i++){\n\t\t\tL.Add(B[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tif(L.Contains(A[i])==false)L.Add(A[i]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\tpublic static Set CreateSub(Set A,Set B){\n\t\tList<int> L=new List<int>();\n\t\tfor(int i=0;i<A.Size;i++){\n\t\t\tL.Add(A[i]);\n\t\t}\n\t\t\n\t\tfor(int j=0;j<B.Size;j++){\n\t\t\tif(L.Contains(B[j]))L.Remove(B[j]);\n\t\t}\n\t\treturn new Set(L);\n\t}\n\t\n\tpublic static Set CreateSymDiff(Set A,Set B){\n\t\treturn Set.CreateUnion( Set.CreateSub(A,B),Set.CreateSub(B,A));\n\t}\n\t\n\tpublic static Set CreateAllUnion(Set[] sets){\n\n\t\tint[] arr=new int[sets[0].Size];\n\t\tfor(int i=0;i<sets[0].Size;i++)arr[i]=sets[0][i];\n\t\tSet U= new Set(arr);\n\n\t\tif(sets.Length==1){\n\t\t\treturn U;\n\t\t}\n\t\t\n\t\tSet V=U;\n\t\tfor(int i=1;i<sets.Length;i++){\n\t\t\tV=Set.CreateUnion(V,sets[i]);\n\t\t}\n\t\treturn V;\n\t}\n}\n\t"
  },
  {
    "language": "Ruby",
    "code": "class Set\n\tdef initialize(a, dict)\n\t\t@dict = dict\n\t\t@bits = 0\n\t\ta.each do |x|\n\t\t\t@bits |= (1 << @dict[x])\n\t\tend\n\tend\n\n\tdef !@\n\t\ts = dup\n\t\ts.bits = (@bits ^ ((1 << @dict.size) - 1))\n\t\ts\n\tend\n\n\tdef |(other)\n\t\ts = dup\n\t\ts.bits = (@bits | other.bits)\n\t\ts\n\tend\n\n\tdef &(other)\n\t\ts = dup\n\t\ts.bits = (@bits & other.bits)\n\t\ts\n\tend\n\n\tdef ^(other)\n\t\ts = dup\n\t\ts.bits = (@bits ^ other.bits)\n\t\ts\n\tend\n\n\tdef -(other)\n\t\ts = dup\n\t\ts.bits -= (@bits & other.bits)\n\t\ts\n\tend\n\n\tdef to_a\n\t\t(0..@dict.size-1).map{|i| [@dict.invert[i]] * @bits[i]}.flatten\n\tend\n\n\tdef to_s\n\t\tto_a.to_s\n\tend\n\n\tattr_accessor :bits\nend\n\nloop do\n\tset = {}\n\telem = {}\n\ta = b = c = d = e = nil\n\tloop do\n\t\tname, _ = gets.chomp.split rescue exit\n\t\tbreak if name == ?R\n\t\ta = gets.split.map &:to_i\n\t\ta.each{|x| elem[x] ||= elem.size}\n\t\tset[name.downcase] = a\n\tend\n\tset.each do |name, arr|\n\t\teval \"#{name} = Set.new(arr, elem)\"\t\n\tend\n\texpr = gets.chomp.tr(\"ABCDEuidsc\", 'abcde|&\\-^!')\n\tputs eval(expr).to_a.sort * ' '\nend"
  },
  {
    "language": "Ruby",
    "code": "class Set\n\tdef initialize(a, dict)\n\t\t@dict = dict\n\t\t@bits = 0\n\t\ta.each do |x|\n\t\t\t@bits |= (1 << @dict[x])\n\t\tend\n\tend\n\n\tdef !@\n\t\ts = dup\n\t\ts.bits = (@bits ^ ((1 << @dict.size) - 1))\n\t\ts\n\tend\n\n\tdef |(other)\n\t\ts = dup\n\t\ts.bits = (@bits | other.bits)\n\t\ts\n\tend\n\n\tdef &(other)\n\t\ts = dup\n\t\ts.bits = (@bits & other.bits)\n\t\ts\n\tend\n\n\tdef ^(other)\n\t\ts = dup\n\t\ts.bits = (@bits ^ other.bits)\n\t\ts\n\tend\n\n\tdef -(other)\n\t\ts = dup\n\t\ts.bits -= (@bits & other.bits)\n\t\ts\n\tend\n\n\tdef to_a\n\t\t(0..@dict.size-1).map{|i| [@dict.invert[i]] * @bits[i]}.flatten\n\tend\n\n\tdef to_s\n\t\tto_a.to_s\n\tend\n\n\tattr_accessor :bits\nend\n\nloop do\n\tset = {}\n\telem = {}\n\ta = b = c = d = e = nil\n\tloop do\n\t\tname, _ = gets.chomp.split rescue exit\n\t\tbreak if name == ?R\n\t\ta = gets.split.map &:to_i\n\t\ta.each{|x| elem[x] ||= elem.size}\n\t\tset[name.downcase] = a\n\tend\n\tset.each do |name, arr|\n\t\teval \"#{name} = Set.new(arr, elem)\"\t\n\tend\n\texpr = gets.chomp.tr(\"ABCDEuidsc\", 'abcde|&\\-^!')\n\tarr = eval(expr).to_a\n\tputs arr.empty? ? 'NULL' : arr.sort * ' '\nend"
  },
  {
    "language": "Ruby",
    "code": "### global variables\n\n$U = {}\n\n### subroutines\n\ndef op_u(set0, set1)\n  res = {}\n  (set0.keys + set1.keys).each{|i| res[i] = 1}\n  res\nend\n\ndef op_i(set0, set1)\n  res = {}\n  set0.keys.each{|i| res[i] = 1 if set1.include?(i)}\n  res\nend\n\ndef op_d(set0, set1)\n  res = {}\n  set0.keys.each{|i| res[i] = 1 if ! set1.include?(i)}\n  res\nend\n\ndef op_s(set0, set1)\n  op_u(op_d(set0, set1), op_d(set1, set0))\nend\n\ndef op_c(set0)\n  op_d($U, set0)\nend\n\n### <exp> := <term> (op2 <term>)*\n### <term> := '(' <exp> ') | op1 <term> | sn\n###   op2 := [uids], op1 := 'c', sn := [A-E]\n\ndef calc_exp()\n  t0 = calc_term()\n\n  while ! $expr[$pc].nil? && 'uids'.include?($expr[$pc])\n    op2 = $expr[$pc]\n    $pc += 1\n    t1 = calc_term()\n\n    case op2\n    when 'u'\n      t0 = op_u(t0, t1)\n    when 'i'\n      t0 = op_i(t0, t1)\n    when 'd'\n      t0 = op_d(t0, t1)\n    when 's'\n      t0 = op_s(t0, t1)\n    end\n  end\n\n  t0\nend\n\ndef calc_term()\n  case $expr[$pc]\n  when '('\n    $pc += 1\n    exp0 = calc_exp()\n    $pc += 1\n    return exp0\n  when 'c'\n    $pc += 1\n    return op_c(calc_term())\n  end\n\n  ret = $sets[$expr[$pc]]\n  $pc += 1\n  ret\nend\n\n### main\n\nwhile line = gets\n  line.strip!\n\n  $sets = {}\n  ('A'..'E').each{|sn| $sets[sn] = {}}\n  $U = {}\n\n  while line != 'R 0'\n    sn, k = line.split(' ')\n    gets.strip.split(' ').each{|s| $sets[sn][s.to_i] = $U[s.to_i] = 1}\n    line = gets.strip\n  end\n  #p $sets\n  #p $U\n\n  $expr = gets.strip\n  $pc = 0\n\n  puts calc_exp().keys.sort.join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "class Set\n\tdef initialize(a, dict)\n\t\t@dict = dict\n\t\t@bits = 0\n\t\ta.each do |x|\n\t\t\t@bits |= (1 << @dict[x])\n\t\tend\n\tend\n\n\tdef !@\n\t\ts = dup\n\t\ts.bits = (@bits ^ ((1 << @dict.size) - 1))\n\t\ts\n\tend\n\n\tdef |(other)\n\t\ts = dup\n\t\ts.bits = (@bits | other.bits)\n\t\ts\n\tend\n\n\tdef &(other)\n\t\ts = dup\n\t\ts.bits = (@bits & other.bits)\n\t\ts\n\tend\n\n\tdef ^(other)\n\t\ts = dup\n\t\ts.bits = (@bits ^ other.bits)\n\t\ts\n\tend\n\n\tdef -(other)\n\t\ts = dup\n\t\ts.bits -= (@bits & other.bits)\n\t\ts\n\tend\n\n\tdef to_a\n\t\t(0..@dict.size-1).map{|i| [@dict.invert[i]] * @bits[i]}.flatten\n\tend\n\n\tdef to_s\n\t\tto_a.to_s\n\tend\n\n\tattr_accessor :bits\nend\n\nloop do\n\tset = {}\n\telem = {}\n\ta = b = c = d = e = nil\n\tloop do\n\t\tname, _ = gets.chomp.split rescue exit\n\t\tbreak if name == ?R\n\t\ta = gets.split.map &:to_i\n\t\ta.each{|x| elem[x] ||= elem.size}\n\t\tset[name.downcase] = a\n\tend\n\tset.each do |name, arr|\n\t\teval \"#{name} = Set.new(arr, elem)\"\t\n\tend\n\texpr = gets.chomp.tr(\"ABCDEuidsc\", 'abcde|&\\-^!')\n\tputs eval(expr).to_a.sort * ' '\nend"
  },
  {
    "language": "Ruby",
    "code": "## global variables\n\n$U = {}\n\n### subroutines\n\ndef op_u(set0, set1)\n  res = {}\n  (set0.keys + set1.keys).each{|i| res[i] = 1}\n  res\nend\n\ndef op_i(set0, set1)\n  res = {}\n  set0.keys.each{|i| res[i] = 1 if set1.include?(i)}\n  res\nend\n\ndef op_d(set0, set1)\n  res = {}\n  set0.keys.each{|i| res[i] = 1 if ! set1.include?(i)}\n  res\nend\n\ndef op_s(set0, set1)\n  op_u(op_d(set0, set1), op_d(set1, set0))\nend\n\ndef op_c(set0)\n  op_d($U, set0)\nend\n\n### <exp> := <term> (op2 <term>)*\n### <term> := '(' <exp> ') | op1 <term> | sn\n###   op2 := [uids], op1 := 'c', sn := [A-E]\n\ndef calc_exp()\n  t0 = calc_term()\n\n  while ! $expr[$pc].nil? && 'uids'.include?($expr[$pc])\n    op2 = $expr[$pc]\n    $pc += 1\n    t1 = calc_term()\n\n    case op2\n    when 'u'\n      t0 = op_u(t0, t1)\n    when 'i'\n      t0 = op_i(t0, t1)\n    when 'd'\n      t0 = op_d(t0, t1)\n    when 's'\n      t0 = op_s(t0, t1)\n    end\n  end\n\n  t0\nend\n\ndef calc_term()\n  case $expr[$pc]\n  when '('\n    $pc += 1\n    exp0 = calc_exp()\n    $pc += 1\n    return exp0\n  when 'c'\n    $pc += 1\n    return op_c(calc_term())\n  end\n\n  ret = $sets[$expr[$pc]]\n  $pc += 1\n  ret\nend\n\n### main\n\nwhile line = gets\n  line.strip!\n\n  $sets = {}\n  ('A'..'E').each{|sn| $sets[sn] = {}}\n  $U = {}\n\n  while line != 'R 0'\n    sn, k = line.split(' ')\n    gets.strip.split(' ').each{|s| $sets[sn][s.to_i] = $U[s.to_i] = 1}\n    line = gets.strip\n  end\n  #p $sets\n  #p $U\n\n  $expr = gets.strip\n  $pc = 0\n\n  ans = calc_exp()\n\n  if ans.empty?\n    puts 'NULL'\n  else\n    puts ans.keys.sort.join(' ')\n  end\nend"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.container;\nimport std.typecons;\nimport std.string;\n\nalias Tuple!(string, \"rest\", int[], \"data\") Context;\n\nvoid main(){\n\tint[][5] sets;\n\tauto U = new RedBlackTree!(int, \"a < b\", false)();\n    while(true){\n        auto line = readln();\n        if(line == \"\") break;\n\t\t\n        auto input = line.split();\n        if(input[0] == \"R\"){\n            exp(readln.chomp, sets, U[].array).data.map!(to!string).join(\" \").writeln;\n\t\t\tsets = (int[][5]).init;\n\t\t\tU.clear;\n\t\t\tcontinue;\n        }\n        char c = input[0][0];\n        foreach(elem; readln.split.map!(to!int)){\n            sets[c - 'A'] ~= elem;\n            U.insert(elem);\n        }\n\t\tsets[c - 'A'].sort();\n    }\n}\n\nContext exp(string input, int[][5] sets, int[] U){\n        Context r = id(input, sets, U);\n\t\twhile(true){\n\t\t\tif(r.rest.length == 0) break;\n\t\t\tif(r.rest[0] == ')') break;\n  \t        char op = r.rest[0];\n        \tContext rhs = id(r.rest[1..$], sets, U);\n    \t    r.rest = rhs.rest;\n\t        final switch(op){\n           \t \tcase 'u':\n            \t    r.data = (r.data.setUnion(rhs.data).array.redBlackTree!false)[].array;\n        \t        break;\n    \t        case 'i':\n   \t             r.data = r.data.setIntersection(rhs.data).array;\n                \tbreak;\n            \tcase 'd':\n                \tr.data = r.data.setDifference(rhs.data).array;\n            \t    break;\n         \t    case 's':\n                \tr.data = r.data.setSymmetricDifference(rhs.data).array;\n            \t    break;\n            }\n\t    }\n        return r;\n}\n\nContext id(string input, int[][5] sets, int[] U){\n\tif(input[0] == '('){\n\t\tContext r = exp(input[1..$], sets, U);\n\t\tr.rest = r.rest[1..$];\n\t\treturn r;\n\t}else if(input[0] == 'c'){\n        return Context(input[2..$], U.setDifference(sets[input[1] - 'A']).array);\n    }else{\n        return Context(input[1..$], sets[input[0] - 'A']);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.container;\nimport std.typecons;\nimport std.string;\n\nalias Tuple!(string, \"rest\", int[], \"data\") Context;\n\nvoid main(){\n\tint[][5] sets;\n\tauto U = new RedBlackTree!(int, \"a < b\", false)();\n    while(true){\n        auto line = readln();\n        if(line == \"\") break;\n\t\t\n        auto input = line.split();\n        if(input[0] == \"R\"){\n            exp(readln.chomp, sets, U[].array).data.map!(to!string).join(\" \").writeln;\n\t\t\tsets = (int[][5]).init;\n\t\t\tU.clear;\n\t\t\tcontinue;\n        }\n        char c = input[0][0];\n        foreach(elem; readln.split.map!(to!int)){\n            sets[c - 'A'] ~= elem;\n            U.insert(elem);\n        }\n\t\tsets[c - 'A'].sort();\n    }\n}\n\nContext exp(string input, int[][5] sets, int[] U){\n        Context r = id(input, sets, U);\n\t\twhile(true){\n\t\t\tif(r.rest.length == 0) break;\n\t\t\tif(r.rest[0] == ')') break;\n  \t        char op = r.rest[0];\n        \tContext rhs = id(r.rest[1..$], sets, U);\n    \t    r.rest = rhs.rest;\n\t        final switch(op){\n           \t \tcase 'u':\n            \t    r.data = (r.data.setUnion(rhs.data).array.redBlackTree!false)[].array;\n        \t        break;\n    \t        case 'i':\n   \t             r.data = r.data.setIntersection(rhs.data).array;\n                \tbreak;\n            \tcase 'd':\n                \tr.data = r.data.setDifference(rhs.data).array;\n            \t    break;\n         \t    case 's':\n                \tr.data = r.data.setSymmetricDifference(rhs.data).array;\n            \t    break;\n            }\n\t    }\n        return r;\n}\n\nContext id(string input, int[][5] sets, int[] U){\n\tif(input[0] == '('){\n\t\tContext r = exp(input[1..$], sets, U);\n\t\tr.rest = r.rest[1..$];\n\t\treturn r;\n\t}else if(input[0] == 'c'){\n\t\tContext r = id(input[1..$], sets, U);\n\t\tr.data = U.setDifference(r.data).array;\n        return r;\n    }else{\n        return Context(input[1..$], sets[input[0] - 'A']);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\nwhile True:\n    A = set()\n    B = set()\n    C = set()\n    D = set()\n    E = set()\n    while True:\n        try:\n            name, _ = raw_input().split()\n            if name == 'R':\n                break\n            globals()[name] = set(map(int, raw_input().split()))\n        except:\n            exit()\n    U = A | B | C | D | E\n\n    # evaluate operation\n    def operate(term1, term2, op):\n        if op == 'u':\n            return term1 | term2\n        if op == 'i':\n            return term1 & term2\n        if op == 'd':\n            return term1 - term2\n        if op == 's':\n            return term1 ^ term2\n\n    # evaluate expression without bracket\n    def calc(S):\n        if len(S) == 1:\n            if type(S[0]) == type(\"\"):\n                return globals()[S[0]]\n            else:\n                return S[0]\n        for i in range(len(S) - 1, -1, -1):\n            if S[i] in ['u', 'i', 'd', 's']:\n                return operate(calc(S[:i]), calc(S[i + 1:]), S[i])\n        return U - calc(S[1:]) # case of ['inv']\n\n    # evaluate expression\n    def br(S):\n        index = 0\n        lst = []\n        while True:\n            if index >= len(S) or S[index] == ')':\n                return index, calc(lst)\n            elif S[index] == '(':\n                ret, value = br(S[index + 1:])\n                index += ret + 1\n                lst.append(value)\n            else:\n                lst.append(S[index])\n            index += 1\n\n    def split(S):\n        ret = []\n        for c in S:\n            if c == 'c':\n                ret.append('inv')\n            else:\n                ret.append(c)\n        return ret\n\n    S = raw_input()\n    ans = br(split(S))[1]\n    print ' '.join(map(str, sorted(list(ans)))) if len(ans) > 0 else 'NULL'\n"
  },
  {
    "language": "Python",
    "code": "def convertC(r):\n    s=\"\"\n    i=0\n    stack=[]\n    while i<len(r):\n        if r[i]==\"c\":\n            if \"A\"<=r[i+1]<=\"E\":\n                s+=\"(U-\"+r[i+1]+\")\"\n                i+=2\n            elif r[i+1]==\"(\":\n                s+=\"(U-\"+r[i+1]\n                stack.append(r[i+1])\n                j=2\n                while stack<>[]:\n                    if r[i+j]==\"(\":\n                        stack.append(r[i+j])\n                    elif r[i+j]==\")\":\n                        stack.pop()\n                    s+=r[i+j]\n                    j+=1\n                else:\n                    s+=\")\"\n                    i=j\n        else:\n            s+=r[i]\n            i+=1\n    return s\n\nwhile True:\n    try:\n        name,elsize=raw_input().split()\n    except EOFError:\n        break\n    p={}\n    U=set()\n    while True:\n        p[name]=set(map(int,raw_input().split()))\n        U=U.union(p[name])\n        name,elsize=raw_input().split()\n        if name==\"R\" and elsize==\"0\":break\n    exp=raw_input()\n    exp=convertC(exp)\n    rule={\"d\":\"-\",\"i\":\"&\",\"u\":\"|\",\"s\":\"^\"}\n    print exp\n    for i in [\"A\",\"B\",\"C\",\"D\",\"E\"]:\n        exp=exp.replace(i,'p[\"'+i+'\"]')\n    for i in rule:\n        exp=exp.replace(i,rule[i])\n    t=sorted(eval(exp))\n    if len(t)==0:\n        print \"NULL\"\n    else:\n        print \" \".join(map(str,t))"
  },
  {
    "language": "Python",
    "code": "while True:\n    try:\n        name,elsize=raw_input().split()\n    except EOFError:\n        break\n    p={}\n    U=set()\n    while True:\n        p[name]=set(map(int,raw_input().split()))\n        U=U.union(p[name])\n        name,elsize=raw_input().split()\n        if name==\"R\" and elsize==\"0\":break\n    exp=raw_input()\n    rule={\"d\":\"-\",\"i\":\"&\",\"u\":\"|\",\"s\":\"^\",\"c\":\"U-\"}\n    for i in [\"A\",\"B\",\"C\",\"D\",\"E\"]:\n        exp=exp.replace(i,'p[\"'+i+'\"]')\n    for i in rule:\n        exp=exp.replace(i,rule[i])\n    t=sorted(eval(exp))\n    if t==[]:\n        print \"NULL\"\n    else:\n        print \" \".join(map(str,t))"
  },
  {
    "language": "Python",
    "code": "def convertC(r):\n    s=\"\"\n    i=0\n    stack=[]\n    while i<len(r):\n        if r[i]==\"c\":\n            if \"A\"<=r[i+1]<=\"E\":\n                s+=\"(U-\"+r[i+1]+\")\"\n                i+=2\n            elif r[i+1]==\"(\":\n                s+=\"(U-\"+r[i+1]\n                stack.append(r[i+1])\n                j=2\n                while stack<>[]:\n                    if r[i+j]==\"(\":\n                        stack.append(r[i+j])\n                    elif r[i+j]==\")\":\n                        stack.pop()\n                    s+=r[i+j]\n                    j+=1\n                else:\n                    s+=\")\"\n                    i+=j\n        else:\n            s+=r[i]\n            i+=1\n    return s\n\nwhile True:\n    try:\n        name,elsize=raw_input().split()\n    except EOFError:\n        break\n    p={}\n    U=set()\n    while True:\n        p[name]=set(map(int,raw_input().split()))\n        U=U.union(p[name])\n        name,elsize=raw_input().split()\n        if name==\"R\" and elsize==\"0\":break\n    exp=raw_input()\n    exp=convertC(exp)\n    rule={\"d\":\"-\",\"i\":\"&\",\"u\":\"|\",\"s\":\"^\"}\n    for i in [\"A\",\"B\",\"C\",\"D\",\"E\"]:\n        exp=exp.replace(i,'p[\"'+i+'\"]')\n    for i in rule:\n        exp=exp.replace(i,rule[i])\n    t=sorted(eval(exp))\n    if len(t)==0:\n        print \"NULL\"\n    else:\n        print \" \".join(map(str,t))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        for n in result:\n            print(n, end = \" \")\n        print()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        if len(result) > 0:\n            print(\" \".join([str(n) for n in result]))\n        else:\n            print(\"NULL\")\n        sets = {}\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\nfrom collections import defaultdict\n\nclass cset():\n    \n    def __init__(self, x):\n        self.x = set(x)\n    \n    def __or__(self, that):\n        return cset(self.x | that.x)\n    \n    def __sub__(self, that):\n        return cset(self.x - that.x)\n\n    def __and__(self, that):\n        return cset(self.x & that.x)\n    \n    def __xor__(self, that):\n        return cset(self.x ^ that.x)\n    \n    def __neg__(self):\n        return cset(U-self.x)\n\ntry:\n    while True:\n        X = defaultdict(list)\n        x, _ = input().split()\n        while x != \"R\":\n            X[x] = list(map(int, input().split()))\n            x, _ = input().split()\n        \n        A, B, C, D, E = X[\"A\"], X[\"B\"], X[\"C\"], X[\"D\"], X[\"E\"]\n        U = set()\n        U.update(A, B, C, D, E)\n        S = input()\n        #print(S)\n        for a, b in zip(list(\"uidsc\"), list(\"|&-^-\")):\n            S = S.replace(a, b)\n        #print(S)\n        for a in list(\"ABCDE\"):\n            S = S.replace(a, \"cset({})\".format(a))\n        #print(S)\n        ans = sorted(list(eval(S).x))\n        if len(ans) == 0:\n            print(\"NULL\")\n        else:\n            print(*ans)\nexcept:\n    pass\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\nfrom collections import defaultdict\n\nclass cset():\n    \n    def __init__(self, x):\n        self.x = set(x)\n    \n    def __or__(self, that):\n        return cset(self.x | that.x)\n    \n    def __sub__(self, that):\n        return cset(self.x - that.x)\n\n    def __and__(self, that):\n        return cset(self.x & that.x)\n    \n    def __xor__(self, that):\n        return cset(self.x ^ that.x)\n    \n    def __neg__(self):\n        return cset(U-self.x)\n\ntry:\n    while True:\n        X = defaultdict(list)\n        x, _ = input().split()\n        while x != \"R\":\n            X[x] = list(map(int, input().split()))\n            x, _ = input().split()\n        \n        A, B, C, D, E = X[\"A\"], X[\"B\"], X[\"C\"], X[\"D\"], X[\"E\"]\n        U = set()\n        U.update(A, B, C, D, E)\n        S = input()\n        for a, b in zip(list(\"uidsc\"), list(\"|&-^-\")):\n            S = S.replace(a, b)\n        for a in list(\"ABCDE\"):\n            S = S.replace(a, \"cset({})\".format(a))\n        ans = sorted(list(eval(S).x))\n        if len(S) == 0:\n            print(\"NULL\")\n        else:\n            print(*ans)\nexcept:\n    pass\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        if len(result) > 0:\n            for n in result:\n                print(n, end = \" \")\n            print()\n        else:\n            print(\"NULL\")\n        sets = {}\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\nfrom collections import defaultdict\n\nclass cset():\n    \n    def __init__(self, x):\n        self.x = set(x)\n    \n    def __or__(self, that):\n        return cset(self.x | that.x)\n    \n    def __sub__(self, that):\n        return cset(self.x - that.x)\n\n    def __and__(self, that):\n        return cset(self.x & that.x)\n    \n    def __xor__(self, that):\n        return cset(self.x ^ that.x)\n    \n    def __neg__(self):\n        return cset(U-self.x)\n\ntry:\n    while True:\n        X = defaultdict(list)\n        x, _ = input().split()\n        while x != \"R\":\n            X[x] = list(map(int, input().split()))\n            x, _ = input().split()\n        \n        A, B, C, D, E = X[\"A\"], X[\"B\"], X[\"C\"], X[\"D\"], X[\"E\"]\n        U = set()\n        U.update(A, B, C, D, E)\n        S = input()\n        for a, b in zip(list(\"uidsc\"), list(\"|&-^-\")):\n            S = S.replace(a, b)\n        for a in list(\"ABCDE\"):\n            S = S.replace(a, \"cset({})\".format(a))\n        print(*sorted(list(eval(S).x)))\nexcept:\n    pass\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        if len(result) > 0:\n            for n in result:\n                print(n, end = \" \")\n            print()\n        else:\n            print(\"NULL\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        if len(result) > 0:\n            for n in result:\n                print(n, end = \" \")\n            print()\n        else:\n            print(\"NULL\")\n        sets = {}\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        if len(result) > 0:\n            for n in result:\n                print(n, end = \" \")\n            print()\n        else:\n            print(\"NULL\")\n        sets = {}\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rpn(str):\n    r = []\n    stack = []\n    for i in range(0, len(str)):\n        c = str[i]\n        if c in \"idsu\":\n            while len(stack) > 0:\n                if stack[-1] in \"idsuc\":\n                    a = stack.pop()\n                    r.extend(a)\n                else:\n                    break\n            stack.extend(c)\n        elif c == \"c\":\n            stack.extend(c)\n        elif c == \"(\":\n            stack.extend(c)\n        elif c == \")\":\n            while len(stack) > 0:\n                a = stack.pop()\n                if a == \"(\":\n                    break\n                r.extend(a)\n        else:\n            r.extend(c)\n    while len(stack) > 0:\n        a = stack.pop()\n        r.extend(a)\n    return r\n\ndef intersect(a, b):\n    r = []\n    for e in a:\n        if e in b:\n            r.extend([e])\n    return r\n\ndef union(a, b):\n    r = list(set(a + b))\n    return r\n\ndef diff(a, b):\n    r = []\n    for e in a:\n        if e not in b:\n            r.extend([e])\n    return r\n\ndef universal(sets):\n    r = []\n    for v in sets.values():\n        r.extend(v)\n    r = list(set(r))\n    return r\n\ndef calc(rpn, sets):\n    stack = []\n    U = universal(sets)\n    for c in rpn:\n        if c in \"iuds\":\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if c == \"i\":\n                x = intersect(op1, op2)\n                stack.append(x)\n            elif c == \"u\":\n                x = union(op1, op2)\n                stack.append(x)\n            elif c == \"d\":\n                x = diff(op1, op2)\n                stack.append(x)\n            elif c == \"s\":\n                x = diff(op1, op2)\n                y = diff(op2, op1)\n                z = union(x, y)\n                stack.append(z)\n        elif c == \"c\":\n            op1 = stack.pop()\n            x = diff(U, op1)\n            stack.append(x)\n        else:\n            stack.append(sets[c])\n    return stack.pop()\n            \nlno = 0\nsets = {}\nname = \"\"\nfor line in sys.stdin:\n    lno += 1\n    if lno % 2 == 1:\n        name = line.strip().split()[0]\n    elif name != \"R\":\n        elem = list(map(int, line.strip().split()))\n        sets[name] = elem\n    else:\n        e = rpn(line.strip())\n        result = calc(e, sets)\n        result.sort()\n        if length(result) > 0:\n            for n in result:\n                print(n, end = \" \")\n            print()\n        else:\n            print(\"NULL\")\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    try:\n        name,elsize=raw_input().split()\n    except EOFError:\n        break\n    p={}\n    U=set()\n    while True:\n        p[name]=set(map(int,raw_input().split()))\n        U=U.union(p[name])\n        name,elsize=raw_input().split()\n        if name==\"R\" and elsize==\"0\":break\n    exp=raw_input()\n    rule={\"d\":\"-\",\"i\":\"&\",\"u\":\"|\",\"s\":\"^\",\"c\":\"U-\"}\n    for i in [\"A\",\"B\",\"C\",\"D\",\"E\"]:\n        exp=exp.replace(i,'p[\"'+i+'\"]')\n    for i in rule:\n        exp=exp.replace(i,rule[i])\n    t=sorted(eval(exp))\n    print \" \".join(map(str,t))"
  }
]