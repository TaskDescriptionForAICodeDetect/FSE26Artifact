[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SETS 10\n#define MAX_ELEMENTS 100\n\ntypedef struct {\n    int elements[MAX_ELEMENTS];\n    int size;\n} Set;\n\nSet sets[MAX_SETS];\nSet universal;\n\nvoid init_set(Set *s) {\n    s->size = 0;\n}\n\nvoid add_to_set(Set *s, int element) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == element) {\n            return;\n        }\n    }\n    s->elements[s->size++] = element;\n}\n\nvoid create_universal() {\n    init_set(&universal);\n    for (int i = 0; i < MAX_SETS; i++) {\n        for (int j = 0; j < sets[i].size; j++) {\n            add_to_set(&universal, sets[i].elements[j]);\n        }\n    }\n}\n\nSet union_set(Set a, Set b) {\n    Set result;\n    init_set(&result);\n    for (int i = 0; i < a.size; i++) {\n        add_to_set(&result, a.elements[i]);\n    }\n    for (int i = 0; i < b.size; i++) {\n        add_to_set(&result, b.elements[i]);\n    }\n    return result;\n}\n\nSet intersect_set(Set a, Set b) {\n    Set result;\n    init_set(&result);\n    for (int i = 0; i < a.size; i++) {\n        for (int j = 0; j < b.size; j++) {\n            if (a.elements[i] == b.elements[j]) {\n                add_to_set(&result, a.elements[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nSet diff_set(Set a, Set b) {\n    Set result;\n    init_set(&result);\n    for (int i = 0; i < a.size; i++) {\n        int found = 0;\n        for (int j = 0; j < b.size; j++) {\n            if (a.elements[i] == b.elements[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            add_to_set(&result, a.elements[i]);\n        }\n    }\n    return result;\n}\n\nSet symdiff_set(Set a, Set b) {\n    Set ab_diff = diff_set(a, b);\n    Set ba_diff = diff_set(b, a);\n    return union_set(ab_diff, ba_diff);\n}\n\nSet complement_set(Set a) {\n    return diff_set(universal, a);\n}\n\nvoid print_set(Set s) {\n    printf(\"{\");\n    for (int i = 0; i < s.size; i++) {\n        printf(\"%d\", s.elements[i]);\n        if (i < s.size - 1) {\n            printf(\", \");\n        }\n    }\n    printf(\"}\\n\");\n}\n\nSet evaluate_expression(char *expr, int *index) {\n    Set a, b;\n    char op;\n    if (expr[*index] == '(') {\n        (*index)++;\n        a = evaluate_expression(expr, index);\n        (*index)++;\n        op = expr[*index];\n        (*index)++;\n        b = evaluate_expression(expr, index);\n        (*index)++;\n        switch (op) {\n            case 'U': return union_set(a, b);\n            case 'I': return intersect_set(a, b);\n            case 'D': return diff_set(a, b);\n            case 'S': return symdiff_set(a, b);\n            case 'C': return complement_set(a);\n        }\n    } else if (expr[*index] == 'C') {\n        (*index)++;\n        a = evaluate_expression(expr, index);\n        return complement_set(a);\n    } else {\n        int set_num = expr[*index] - '0';\n        (*index)++;\n        return sets[set_num];\n    }\n}\n\nint main() {\n    int n, m, element;\n    char expr[100];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        init_set(&sets[i]);\n        scanf(\"%d\", &m);\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &element);\n            add_to_set(&sets[i], element);\n        }\n    }\n\n    create_universal();\n\n    scanf(\"%s\", expr);\n    int index = 0;\n    Set result = evaluate_expression(expr, &index);\n    print_set(result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SetOperations {\n    private Map<String, Set<Integer>> sets;\n    private Set<Integer> universalSet;\n\n    public SetOperations() {\n        sets = new HashMap<>();\n        universalSet = new HashSet<>();\n    }\n\n    public void createSet(String name, Set<Integer> elements) {\n        sets.put(name, new HashSet<>(elements));\n        universalSet.addAll(elements);\n    }\n\n    public Set<Integer> union(String set1Name, String set2Name) {\n        Set<Integer> set1 = sets.get(set1Name);\n        Set<Integer> set2 = sets.get(set2Name);\n        Set<Integer> result = new HashSet<>(set1);\n        result.addAll(set2);\n        return result;\n    }\n\n    public Set<Integer> intersection(String set1Name, String set2Name) {\n        Set<Integer> set1 = sets.get(set1Name);\n        Set<Integer> set2 = sets.get(set2Name);\n        Set<Integer> result = new HashSet<>(set1);\n        result.retainAll(set2);\n        return result;\n    }\n\n    public Set<Integer> difference(String set1Name, String set2Name) {\n        Set<Integer> set1 = sets.get(set1Name);\n        Set<Integer> set2 = sets.get(set2Name);\n        Set<Integer> result = new HashSet<>(set1);\n        result.removeAll(set2);\n        return result;\n    }\n\n    public Set<Integer> symmetricDifference(String set1Name, String set2Name) {\n        Set<Integer> set1 = sets.get(set1Name);\n        Set<Integer> set2 = sets.get(set2Name);\n        Set<Integer> result = new HashSet<>(set1);\n        result.addAll(set2);\n        Set<Integer> intersection = new HashSet<>(set1);\n        intersection.retainAll(set2);\n        result.removeAll(intersection);\n        return result;\n    }\n\n    public Set<Integer> complement(String setName) {\n        Set<Integer> set = sets.get(setName);\n        Set<Integer> result = new HashSet<>(universalSet);\n        result.removeAll(set);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        SetOperations so = new SetOperations();\n        \n        // Example usage\n        so.createSet(\"A\", new HashSet<>(Arrays.asList(1, 2, 3, 4)));\n        so.createSet(\"B\", new HashSet<>(Arrays.asList(3, 4, 5, 6)));\n        \n        Set<Integer> unionResult = so.union(\"A\", \"B\");\n        Set<Integer> intersectionResult = so.intersection(\"A\", \"B\");\n        Set<Integer> differenceResult = so.difference(\"A\", \"B\");\n        Set<Integer> symDiffResult = so.symmetricDifference(\"A\", \"B\");\n        Set<Integer> complementResult = so.complement(\"A\");\n        \n        System.out.println(\"Union: \" + unionResult);\n        System.out.println(\"Intersection: \" + intersectionResult);\n        System.out.println(\"Difference: \" + differenceResult);\n        System.out.println(\"Symmetric Difference: \" + symDiffResult);\n        System.out.println(\"Complement: \" + complementResult);\n    }\n}",
    "timestamp": "2025-08-05 18:56:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nset<int> universal;\n\nset<int> performUnion(const set<int>& a, const set<int>& b) {\n    set<int> result = a;\n    result.insert(b.begin(), b.end());\n    return result;\n}\n\nset<int> performIntersection(const set<int>& a, const set<int>& b) {\n    set<int> result;\n    set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(result, result.begin()));\n    return result;\n}\n\nset<int> performDifference(const set<int>& a, const set<int>& b) {\n    set<int> result;\n    set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(result, result.begin()));\n    return result;\n}\n\nset<int> performSymmetricDifference(const set<int>& a, const set<int>& b) {\n    set<int> result;\n    set_symmetric_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(result, result.begin()));\n    return result;\n}\n\nset<int> performComplement(const set<int>& a) {\n    set<int> result;\n    set_difference(universal.begin(), universal.end(), a.begin(), a.end(), inserter(result, result.begin()));\n    return result;\n}\n\nset<int> evaluateExpression(const string& expr, const map<char, set<int>>& sets) {\n    vector<set<int>> stack;\n    vector<char> ops;\n\n    for (char c : expr) {\n        if (isalpha(c)) {\n            stack.push_back(sets.at(c));\n        } else if (c == '(') {\n            ops.push_back(c);\n        } else if (c == ')') {\n            while (!ops.empty() && ops.back() != '(') {\n                char op = ops.back();\n                ops.pop_back();\n\n                set<int> b = stack.back();\n                stack.pop_back();\n                set<int> a = stack.back();\n                stack.pop_back();\n\n                set<int> res;\n                if (op == 'u') {\n                    res = performUnion(a, b);\n                } else if (op == 'i') {\n                    res = performIntersection(a, b);\n                } else if (op == 'd') {\n                    res = performDifference(a, b);\n                } else if (op == 's') {\n                    res = performSymmetricDifference(a, b);\n                }\n                stack.push_back(res);\n            }\n            ops.pop_back(); // Remove '('\n        } else {\n            ops.push_back(c);\n        }\n    }\n\n    while (!ops.empty()) {\n        char op = ops.back();\n        ops.pop_back();\n\n        if (op == 'c') {\n            set<int> a = stack.back();\n            stack.pop_back();\n            set<int> res = performComplement(a);\n            stack.push_back(res);\n        } else {\n            set<int> b = stack.back();\n            stack.pop_back();\n            set<int> a = stack.back();\n            stack.pop_back();\n\n            set<int> res;\n            if (op == 'u') {\n                res = performUnion(a, b);\n            } else if (op == 'i') {\n                res = performIntersection(a, b);\n            } else if (op == 'd') {\n                res = performDifference(a, b);\n            } else if (op == 's') {\n                res = performSymmetricDifference(a, b);\n            }\n            stack.push_back(res);\n        }\n    }\n\n    return stack.back();\n}\n\nint main() {\n    int N;\n    cin >> N;\n    map<char, set<int>> sets;\n\n    for (int i = 0; i < N; ++i) {\n        char name;\n        int size;\n        cin >> name >> size;\n        set<int> s;\n        for (int j = 0; j < size; ++j) {\n            int num;\n            cin >> num;\n            s.insert(num);\n            universal.insert(num);\n        }\n        sets[name] = s;\n    }\n\n    string expr;\n    cin >> expr;\n\n    set<int> result = evaluateExpression(expr, sets);\n\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SETS 100\n#define MAX_ELEMENTS 1000\n\ntypedef struct {\n    int elements[MAX_ELEMENTS];\n    int size;\n} Set;\n\nSet sets[MAX_SETS];\nint set_count = 0;\nSet universal_set;\n\nvoid initialize_universal_set() {\n    bool element_exists[MAX_ELEMENTS] = {false};\n    universal_set.size = 0;\n\n    for (int i = 0; i < set_count; i++) {\n        for (int j = 0; j < sets[i].size; j++) {\n            int elem = sets[i].elements[j];\n            if (!element_exists[elem]) {\n                universal_set.elements[universal_set.size++] = elem;\n                element_exists[elem] = true;\n            }\n        }\n    }\n}\n\nSet set_union(Set a, Set b) {\n    Set result;\n    bool exists[MAX_ELEMENTS] = {false};\n    result.size = 0;\n\n    for (int i = 0; i < a.size; i++) {\n        result.elements[result.size++] = a.elements[i];\n        exists[a.elements[i]] = true;\n    }\n\n    for (int i = 0; i < b.size; i++) {\n        if (!exists[b.elements[i]]) {\n            result.elements[result.size++] = b.elements[i];\n        }\n    }\n\n    return result;\n}\n\nSet set_intersection(Set a, Set b) {\n    Set result;\n    bool b_exists[MAX_ELEMENTS] = {false};\n    result.size = 0;\n\n    for (int i = 0; i < b.size; i++) {\n        b_exists[b.elements[i]] = true;\n    }\n\n    for (int i = 0; i < a.size; i++) {\n        if (b_exists[a.elements[i]]) {\n            result.elements[result.size++] = a.elements[i];\n        }\n    }\n\n    return result;\n}\n\nSet set_difference(Set a, Set b) {\n    Set result;\n    bool b_exists[MAX_ELEMENTS] = {false};\n    result.size = 0;\n\n    for (int i = 0; i < b.size; i++) {\n        b_exists[b.elements[i]] = true;\n    }\n\n    for (int i = 0; i < a.size; i++) {\n        if (!b_exists[a.elements[i]]) {\n            result.elements[result.size++] = a.elements[i];\n        }\n    }\n\n    return result;\n}\n\nSet set_symmetric_difference(Set a, Set b) {\n    Set diff_a = set_difference(a, b);\n    Set diff_b = set_difference(b, a);\n    return set_union(diff_a, diff_b);\n}\n\nSet set_complement(Set a) {\n    Set result;\n    bool a_exists[MAX_ELEMENTS] = {false};\n    result.size = 0;\n\n    for (int i = 0; i < a.size; i++) {\n        a_exists[a.elements[i]] = true;\n    }\n\n    for (int i = 0; i < universal_set.size; i++) {\n        if (!a_exists[universal_set.elements[i]]) {\n            result.elements[result.size++] = universal_set.elements[i];\n        }\n    }\n\n    return result;\n}\n\nvoid print_set(Set s) {\n    printf(\"{\");\n    for (int i = 0; i < s.size; i++) {\n        printf(\"%d%s\", s.elements[i], i < s.size - 1 ? \", \" : \"\");\n    }\n    printf(\"}\\n\");\n}\n\nint main() {\n    int num_sets, num_operations;\n    scanf(\"%d\", &num_sets);\n\n    for (int i = 0; i < num_sets; i++) {\n        int set_size;\n        scanf(\"%d\", &set_size);\n        sets[i].size = set_size;\n\n        for (int j = 0; j < set_size; j++) {\n            scanf(\"%d\", &sets[i].elements[j]);\n        }\n    }\n\n    set_count = num_sets;\n    initialize_universal_set();\n\n    scanf(\"%d\", &num_operations);\n\n    for (int i = 0; i < num_operations; i++) {\n        char op[20];\n        int set1, set2;\n        scanf(\"%s\", op);\n\n        if (strcmp(op, \"union\") == 0) {\n            scanf(\"%d %d\", &set1, &set2);\n            Set result = set_union(sets[set1], sets[set2]);\n            print_set(result);\n        } else if (strcmp(op, \"intersection\") == 0) {\n            scanf(\"%d %d\", &set1, &set2);\n            Set result = set_intersection(sets[set1], sets[set2]);\n            print_set(result);\n        } else if (strcmp(op, \"difference\") == 0) {\n            scanf(\"%d %d\", &set1, &set2);\n            Set result = set_difference(sets[set1], sets[set2]);\n            print_set(result);\n        } else if (strcmp(op, \"symmetric_difference\") == 0) {\n            scanf(\"%d %d\", &set1, &set2);\n            Set result = set_symmetric_difference(sets[set1], sets[set2]);\n            print_set(result);\n        } else if (strcmp(op, \"complement\") == 0) {\n            scanf(\"%d\", &set1);\n            Set result = set_complement(sets[set1]);\n            print_set(result);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <sstream>\n#include <algorithm>\n\nclass SetOperations {\nprivate:\n    std::unordered_map<std::string, std::set<int>> sets;\n    std::set<int> universal;\n\npublic:\n    void addSet(const std::string& name, const std::vector<int>& elements) {\n        sets[name] = std::set<int>(elements.begin(), elements.end());\n        updateUniversal();\n    }\n\n    void updateUniversal() {\n        universal.clear();\n        for (const auto& set : sets) {\n            universal.insert(set.second.begin(), set.second.end());\n        }\n    }\n\n    std::set<int> performOperation(const std::string& op, const std::string& set1, const std::string& set2 = \"\") {\n        if (op == \"UNION\") {\n            std::set<int> result = sets[set1];\n            result.insert(sets[set2].begin(), sets[set2].end());\n            return result;\n        }\n        if (op == \"INTERSECTION\") {\n            std::set<int> result;\n            std::set_intersection(\n                sets[set1].begin(), sets[set1].end(),\n                sets[set2].begin(), sets[set2].end(),\n                std::inserter(result, result.begin())\n            );\n            return result;\n        }\n        if (op == \"DIFFERENCE\") {\n            std::set<int> result;\n            std::set_difference(\n                sets[set1].begin(), sets[set1].end(),\n                sets[set2].begin(), sets[set2].end(),\n                std::inserter(result, result.begin())\n            );\n            return result;\n        }\n        if (op == \"SYMMETRIC_DIFFERENCE\") {\n            std::set<int> result;\n            std::set_symmetric_difference(\n                sets[set1].begin(), sets[set1].end(),\n                sets[set2].begin(), sets[set2].end(),\n                std::inserter(result, result.begin())\n            );\n            return result;\n        }\n        if (op == \"COMPLEMENT\") {\n            std::set<int> result;\n            std::set_difference(\n                universal.begin(), universal.end(),\n                sets[set1].begin(), sets[set1].end(),\n                std::inserter(result, result.begin())\n            );\n            return result;\n        }\n        return {};\n    }\n\n    void printSet(const std::set<int>& s) {\n        for (int x : s) {\n            std::cout << x << \" \";\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    SetOperations so;\n    int n;\n    std::cin >> n;\n\n    for (int i = 0; i < n; ++i) {\n        std::string name;\n        int m;\n        std::cin >> name >> m;\n        std::vector<int> elements(m);\n        for (int j = 0; j < m; ++j) {\n            std::cin >> elements[j];\n        }\n        so.addSet(name, elements);\n    }\n\n    int q;\n    std::cin >> q;\n\n    for (int i = 0; i < q; ++i) {\n        std::string op, set1, set2;\n        std::cin >> op >> set1;\n        if (op != \"COMPLEMENT\") {\n            std::cin >> set2;\n        }\n\n        std::set<int> result = so.performOperation(op, set1, set2);\n        so.printSet(result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class SetOperations {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        \n        Map<String, Set<Integer>> sets = new HashMap<>();\n        Set<Integer> universal = new HashSet<>();\n        \n        for (int i = 0; i < n; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            String name = parts[0];\n            Set<Integer> set = new HashSet<>();\n            for (int j = 1; j < parts.length; j++) {\n                int num = Integer.parseInt(parts[j]);\n                set.add(num);\n                universal.add(num);\n            }\n            sets.put(name, set);\n        }\n        \n        String expression = scanner.nextLine();\n        String postfix = infixToPostfix(expression);\n        Set<Integer> result = evaluatePostfix(postfix, sets, universal);\n        \n        List<Integer> sortedResult = new ArrayList<>(result);\n        Collections.sort(sortedResult);\n        System.out.println(sortedResult.stream().map(Object::toString).collect(Collectors.joining(\" \")));\n    }\n    \n    private static String infixToPostfix(String infix) {\n        StringBuilder postfix = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n        \n        for (int i = 0; i < infix.length(); i++) {\n            char c = infix.charAt(i);\n            if (Character.isWhitespace(c)) {\n                continue;\n            }\n            if (Character.isLetter(c)) {\n                postfix.append(c);\n            } else if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                while (!stack.isEmpty() && stack.peek() != '(') {\n                    postfix.append(stack.pop());\n                }\n                stack.pop();\n            } else {\n                while (!stack.isEmpty() && precedence(c) <= precedence(stack.peek())) {\n                    postfix.append(stack.pop());\n                }\n                stack.push(c);\n            }\n        }\n        while (!stack.isEmpty()) {\n            postfix.append(stack.pop());\n        }\n        return postfix.toString();\n    }\n    \n    private static int precedence(char op) {\n        switch (op) {\n            case '*': return 3;\n            case '+': return 2;\n            case '-': return 1;\n            default: return 0;\n        }\n    }\n    \n    private static Set<Integer> evaluatePostfix(String postfix, Map<String, Set<Integer>> sets, Set<Integer> universal) {\n        Stack<Set<Integer>> stack = new Stack<>();\n        \n        for (int i = 0; i < postfix.length(); i++) {\n            char c = postfix.charAt(i);\n            if (Character.isLetter(c)) {\n                stack.push(sets.get(String.valueOf(c)));\n            } else {\n                Set<Integer> b = stack.pop();\n                Set<Integer> a = stack.isEmpty() ? new HashSet<>() : stack.pop();\n                Set<Integer> result = new HashSet<>();\n                switch (c) {\n                    case '*':\n                        result.addAll(a);\n                        result.retainAll(b);\n                        break;\n                    case '+':\n                        result.addAll(a);\n                        result.addAll(b);\n                        break;\n                    case '-':\n                        result.addAll(a);\n                        result.removeAll(b);\n                        break;\n                    case '^':\n                        Set<Integer> temp = new HashSet<>(a);\n                        temp.retainAll(b);\n                        result.addAll(a);\n                        result.addAll(b);\n                        result.removeAll(temp);\n                        break;\n                    case '!':\n                        Set<Integer> complement = new HashSet<>(universal);\n                        complement.removeAll(b);\n                        result.addAll(complement);\n                        break;\n                }\n                stack.push(result);\n            }\n        }\n        return stack.pop();\n    }\n}",
    "timestamp": "2025-08-05 18:58:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def process_set_operations(sets, operations):\n    results = []\n    universal_set = set.union(*sets)\n    \n    for operation in operations:\n        op_type = operation[0]\n        if op_type == \"union\":\n            result = set.union(*operation[1:])\n        elif op_type == \"intersection\":\n            result = set.intersection(*operation[1:])\n        elif op_type == \"difference\":\n            result = set.difference(*operation[1:])\n        elif op_type == \"symmetric_difference\":\n            result = set.symmetric_difference(*operation[1:])\n        elif op_type == \"complement\":\n            result = universal_set.difference(operation[1])\n        else:\n            result = None\n        results.append(result)\n    \n    return results\n\n# Example Input:\n# sets = [set([1, 2, 3]), set([3, 4, 5]), set([5, 6, 7])]\n# operations = [\n#     (\"union\", set([1, 2, 3]), set([3, 4, 5])),\n#     (\"intersection\", set([1, 2, 3]), set([3, 4, 5])),\n#     (\"difference\", set([1, 2, 3]), set([3, 4, 5])),\n#     (\"symmetric_difference\", set([1, 2, 3]), set([3, 4, 5])),\n#     (\"complement\", set([1, 2, 3]))\n# ]\n# Expected Output:\n# [set([1, 2, 3, 4, 5]), set([3]), set([1, 2]), set([1, 2, 4, 5]), set([4, 5, 6, 7])]",
    "timestamp": "2025-08-13 01:30:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class SetOperations {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read sets\n        int numberOfSets = scanner.nextInt();\n        Map<String, Set<Integer>> sets = new HashMap<>();\n        \n        for (int i = 0; i < numberOfSets; i++) {\n            String setName = scanner.next();\n            int setSize = scanner.nextInt();\n            Set<Integer> set = new HashSet<>();\n            for (int j = 0; j < setSize; j++) {\n                set.add(scanner.nextInt());\n            }\n            sets.put(setName, set);\n        }\n        \n        // Determine the universal set\n        Set<Integer> universalSet = sets.values().stream()\n                .flatMap(Set::stream)\n                .collect(Collectors.toSet());\n\n        // Read operations\n        int numberOfOperations = scanner.nextInt();\n        \n        for (int i = 0; i < numberOfOperations; i++) {\n            String operation = scanner.next();\n            String setName1 = scanner.next();\n            String setName2 = null;\n            \n            Set<Integer> resultSet;\n            switch (operation) {\n                case \"union\":\n                    setName2 = scanner.next();\n                    resultSet = new HashSet<>(sets.get(setName1));\n                    resultSet.addAll(sets.get(setName2));\n                    break;\n                case \"intersection\":\n                    setName2 = scanner.next();\n                    resultSet = new HashSet<>(sets.get(setName1));\n                    resultSet.retainAll(sets.get(setName2));\n                    break;\n                case \"difference\":\n                    setName2 = scanner.next();\n                    resultSet = new HashSet<>(sets.get(setName1));\n                    resultSet.removeAll(sets.get(setName2));\n                    break;\n                case \"symDifference\":\n                    setName2 = scanner.next();\n                    resultSet = new HashSet<>(sets.get(setName1));\n                    resultSet.addAll(sets.get(setName2));\n                    Set<Integer> intersection = new HashSet<>(sets.get(setName1));\n                    intersection.retainAll(sets.get(setName2));\n                    resultSet.removeAll(intersection);\n                    break;\n                case \"complement\":\n                    resultSet = new HashSet<>(universalSet);\n                    resultSet.removeAll(sets.get(setName1));\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown operation: \" + operation);\n            }\n            System.out.println(resultSet);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 01:30:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define SET_SIZE 1000\n\ntypedef struct {\n    int elements[SET_SIZE];\n    int size;\n} Set;\n\nSet createSet() {\n    Set s;\n    s.size = 0;\n    memset(s.elements, 0, sizeof(s.elements));\n    return s;\n}\n\nvoid addElement(Set *s, int elem) {\n    if (s->size < SET_SIZE && !s->elements[elem]) {\n        s->elements[elem] = 1;\n        s->size++;\n    }\n}\n\nSet unionSet(Set s1, Set s2) {\n    Set result = createSet();\n    for (int i = 0; i < SET_SIZE; i++) {\n        if (s1.elements[i] || s2.elements[i]) {\n            addElement(&result, i);\n        }\n    }\n    return result;\n}\n\nSet intersectionSet(Set s1, Set s2) {\n    Set result = createSet();\n    for (int i = 0; i < SET_SIZE; i++) {\n        if (s1.elements[i] && s2.elements[i]) {\n            addElement(&result, i);\n        }\n    }\n    return result;\n}\n\nSet differenceSet(Set s1, Set s2) {\n    Set result = createSet();\n    for (int i = 0; i < SET_SIZE; i++) {\n        if (s1.elements[i] && !s2.elements[i]) {\n            addElement(&result, i);\n        }\n    }\n    return result;\n}\n\nSet symmetricDifferenceSet(Set s1, Set s2) {\n    Set result = createSet();\n    for (int i = 0; i < SET_SIZE; i++) {\n        if ((s1.elements[i] || s2.elements[i]) && !(s1.elements[i] && s2.elements[i])) {\n            addElement(&result, i);\n        }\n    }\n    return result;\n}\n\nSet complementSet(Set s, Set universal) {\n    return differenceSet(universal, s);\n}\n\nvoid readSet(Set *s) {\n    int elem;\n    while (scanf(\"%d\", &elem) == 1 && elem != -1) {\n        addElement(s, elem);\n    }\n}\n\nvoid printSet(Set s) {\n    for (int i = 0; i < SET_SIZE; i++) {\n        if (s.elements[i]) {\n            printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n}\n\nvoid computeUniversalSet(Set *sets, int n, Set *universal) {\n    *universal = createSet();\n    for (int i = 0; i < n; i++) {\n        *universal = unionSet(*universal, sets[i]);\n    }\n}\n\nint main() {\n    int nSets;\n    scanf(\"%d\", &nSets);\n    Set sets[nSets];\n\n    for (int i = 0; i < nSets; i++) {\n        sets[i] = createSet();\n        readSet(&sets[i]);\n    }\n\n    Set universal;\n    computeUniversalSet(sets, nSets, &universal);\n\n    char operation[100];\n    int set1, set2;\n    while (scanf(\"%s %d %d\", operation, &set1, &set2) == 3) {\n        if (strcasecmp(operation, \"union\") == 0) {\n            printSet(unionSet(sets[set1], sets[set2]));\n        } else if (strcasecmp(operation, \"intersection\") == 0) {\n            printSet(intersectionSet(sets[set1], sets[set2]));\n        } else if (strcasecmp(operation, \"difference\") == 0) {\n            printSet(differenceSet(sets[set1], sets[set2]));\n        } else if (strcasecmp(operation, \"symmetric_difference\") == 0) {\n            printSet(symmetricDifferenceSet(sets[set1], sets[set2]));\n        } else if (strcasecmp(operation, \"complement\") == 0) {\n            printSet(complementSet(sets[set1], universal));\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:30:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_set_operations(sets_data, queries):\n    # Create sets from input\n    sets = {}\n    universal_set = set()\n    \n    for name, elements in sets_data.items():\n        sets[name] = set(elements)\n        universal_set.update(elements)\n    \n    results = []\n    \n    # Process queries\n    for query in queries:\n        operation = query[0]\n        set_names = query[1:]\n        \n        if operation == 'union':\n            result = sets[set_names[0]].union(*[sets[name] for name in set_names[1:]])\n        elif operation == 'intersection':\n            result = sets[set_names[0]].intersection(*[sets[name] for name in set_names[1:]])\n        elif operation == 'difference':\n            result = sets[set_names[0]]\n            for name in set_names[1:]:\n                result -= sets[name]\n        elif operation == 'symmetric_difference':\n            result = sets[set_names[0]].symmetric_difference(*[sets[name] for name in set_names[1:]])\n        elif operation == 'complement':\n            result = universal_set - sets[set_names[0]]\n        \n        results.append(sorted(list(result)))\n    \n    return results",
    "timestamp": "2025-08-13 01:31:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    T = int(input[idx])\n    idx += 1\n    sets = {}\n    universal = set()\n    \n    for _ in range(T):\n        parts = input[idx].split()\n        idx += 1\n        name = parts[0]\n        elements = list(map(int, parts[1:]))\n        s = set(elements)\n        sets[name] = s\n        universal.update(s)\n    \n    while idx < len(input):\n        line = input[idx].strip()\n        idx += 1\n        if not line:\n            continue\n        \n        stack = []\n        i = 0\n        n = len(line)\n        while i < n:\n            c = line[i]\n            if c == ' ':\n                i += 1\n                continue\n            if c == '(':\n                stack.append(c)\n                i += 1\n            elif c == ')':\n                # Process until '('\n                temp = []\n                while stack[-1] != '(':\n                    temp.append(stack.pop())\n                stack.pop()  # Remove '('\n                # Process the temp in reverse order (original order)\n                temp.reverse()\n                res = temp[0]\n                for j in range(1, len(temp), 2):\n                    op = temp[j]\n                    operand = temp[j+1]\n                    if op == 'u':\n                        res = res.union(operand)\n                    elif op == 'n':\n                        res = res.intersection(operand)\n                    elif op == '\\\\':\n                        res = res.difference(operand)\n                    elif op == '^':\n                        res = res.symmetric_difference(operand)\n                    elif op == 'c':\n                        res = universal.difference(res)\n                stack.append(res)\n                i += 1\n            elif c in {'u', 'n', '\\\\', '^', 'c'}:\n                stack.append(c)\n                i += 1\n            else:\n                # Read set name\n                name = ''\n                while i < n and line[i] not in {' ', '(', ')', 'u', 'n', '\\\\', '^', 'c'}:\n                    name += line[i]\n                    i += 1\n                stack.append(sets[name])\n        \n        # Process remaining stack (if any operations left outside parentheses)\n        temp = stack\n        res = temp[0]\n        for j in range(1, len(temp), 2):\n            op = temp[j]\n            operand = temp[j+1]\n            if op == 'u':\n                res = res.union(operand)\n            elif op == 'n':\n                res = res.intersection(operand)\n            elif op == '\\\\':\n                res = res.difference(operand)\n            elif op == '^':\n                res = res.symmetric_difference(operand)\n            elif op == 'c':\n                res = universal.difference(res)\n        # Output the result\n        sorted_res = sorted(res)\n        print(' '.join(map(str, sorted_res)) if sorted_res else 'Empty Set')\n\nsolve()",
    "timestamp": "2025-08-13 01:31:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nset<int> complement(const set<int>& universalSet, const set<int>& inputSet) {\n    set<int> result;\n    for (int element : universalSet) {\n        if (inputSet.find(element) == inputSet.end()) {\n            result.insert(element);\n        }\n    }\n    return result;\n}\n\nset<int> parseSet(const string& input) {\n    set<int> result;\n    stringstream ss(input);\n    int number;\n    while (ss >> number) {\n        result.insert(number);\n    }\n    return result;\n}\n\nset<int> unionSet(const set<int>& A, const set<int>& B) {\n    set<int> result = A;\n    result.insert(B.begin(), B.end());\n    return result;\n}\n\nset<int> intersectionSet(const set<int>& A, const set<int>& B) {\n    set<int> result;\n    for (int element : A) {\n        if (B.find(element) != B.end()) {\n            result.insert(element);\n        }\n    }\n    return result;\n}\n\nset<int> differenceSet(const set<int>& A, const set<int>& B) {\n    set<int> result = A;\n    for (int element : B) {\n        result.erase(element);\n    }\n    return result;\n}\n\nset<int> symmetricDifferenceSet(const set<int>& A, const set<int>& B) {\n    set<int> result = differenceSet(unionSet(A, B), intersectionSet(A, B));\n    return result;\n}\n\nvoid printSet(const set<int>& s) {\n    for (int element : s) {\n        cout << element << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cin.ignore();\n    \n    vector<set<int>> sets(n);\n    set<int> universalSet;\n    \n    for (int i = 0; i < n; ++i) {\n        string line;\n        getline(cin, line);\n        sets[i] = parseSet(line);\n        universalSet = unionSet(universalSet, sets[i]);\n    }\n    \n    int m;\n    cin >> m;\n    cin.ignore();\n    \n    for (int i = 0; i < m; ++i) {\n        string operation;\n        getline(cin, operation);\n        \n        stringstream ss(operation);\n        string op;\n        int setA, setB;\n        \n        ss >> op >> setA >> setB;\n        setA--; setB--;\n\n        set<int> resultSet;\n        \n        if (op == \"union\") {\n            resultSet = unionSet(sets[setA], sets[setB]);\n        } else if (op == \"intersection\") {\n            resultSet = intersectionSet(sets[setA], sets[setB]);\n        } else if (op == \"difference\") {\n            resultSet = differenceSet(sets[setA], sets[setB]);\n        } else if (op == \"symmetric_difference\") {\n            resultSet = symmetricDifferenceSet(sets[setA], sets[setB]);\n        } else if (op == \"complement\") {\n            resultSet = complement(universalSet, sets[setA]);\n        }\n        \n        printSet(resultSet);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:38"
  }
]