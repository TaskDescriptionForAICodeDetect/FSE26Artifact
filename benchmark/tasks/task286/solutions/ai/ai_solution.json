[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PROCESSES 10\n#define MAX_RESOURCES 10\n\nint processes, resources;\nint allocation[MAX_PROCESSES][MAX_RESOURCES];\nint request[MAX_PROCESSES][MAX_RESOURCES];\nint available[MAX_RESOURCES];\nint work[MAX_RESOURCES];\nint finish[MAX_PROCESSES];\n\nint is_deadlock() {\n    memcpy(work, available, sizeof(int) * resources);\n    memset(finish, 0, sizeof(int) * processes);\n\n    int found;\n    do {\n        found = 0;\n        for (int i = 0; i < processes; i++) {\n            if (!finish[i]) {\n                int can_proceed = 1;\n                for (int j = 0; j < resources; j++) {\n                    if (request[i][j] > work[j]) {\n                        can_proceed = 0;\n                        break;\n                    }\n                }\n                if (can_proceed) {\n                    for (int j = 0; j < resources; j++) {\n                        work[j] += allocation[i][j];\n                    }\n                    finish[i] = 1;\n                    found = 1;\n                }\n            }\n        }\n    } while (found);\n\n    for (int i = 0; i < processes; i++) {\n        if (!finish[i]) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &processes, &resources);\n\n    for (int i = 0; i < resources; i++) {\n        scanf(\"%d\", &available[i]);\n    }\n\n    int time = 0;\n    int deadlock_time = -1;\n    while (1) {\n        int p, r, a;\n        if (scanf(\"%d %d %d\", &p, &r, &a) != 3) {\n            break;\n        }\n        if (a == 1) {\n            allocation[p][r]++;\n            available[r]--;\n        } else {\n            allocation[p][r]--;\n            available[r]++;\n            request[p][r]++;\n        }\n        time++;\n        if (is_deadlock()) {\n            deadlock_time = time;\n            break;\n        }\n    }\n\n    printf(\"%d\\n\", deadlock_time);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Event {\n    int time;\n    int process;\n    int resource;\n    bool is_alloc;\n};\n\nbool hasCycle(const vector<set<int>>& graph, vector<bool>& visited, vector<bool>& recStack, int v) {\n    if (!visited[v]) {\n        visited[v] = true;\n        recStack[v] = true;\n        for (int neighbor : graph[v]) {\n            if (!visited[neighbor] && hasCycle(graph, visited, recStack, neighbor)) {\n                return true;\n            } else if (recStack[neighbor]) {\n                return true;\n            }\n        }\n    }\n    recStack[v] = false;\n    return false;\n}\n\nbool isDeadlockUnavoidable(const vector<set<int>>& graph) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    vector<bool> recStack(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (hasCycle(graph, visited, recStack, i)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint findDeadlockTime(int N, int M, const vector<Event>& events) {\n    map<int, int> resourceOwner;\n    vector<set<int>> graph(N);\n\n    for (const Event& event : events) {\n        if (event.is_alloc) {\n            if (resourceOwner.count(event.resource)) {\n                int owner = resourceOwner[event.resource];\n                graph[event.process].insert(owner);\n            } else {\n                resourceOwner[event.resource] = event.process;\n            }\n        } else {\n            if (resourceOwner[event.resource] == event.process) {\n                resourceOwner.erase(event.resource);\n            }\n            for (auto& [res, owner] : resourceOwner) {\n                if (owner == event.process) {\n                    graph[owner].erase(event.process);\n                }\n            }\n        }\n        if (isDeadlockUnavoidable(graph)) {\n            return event.time;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<Event> events(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> events[i].time >> events[i].process >> events[i].resource >> events[i].is_alloc;\n        events[i].process--; // Assuming processes are 1-based in input\n    }\n    sort(events.begin(), events.end(), [](const Event& a, const Event& b) {\n        return a.time < b.time;\n    });\n    int result = findDeadlockTime(N, M, events);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Process {\n    int id;\n    Set<Integer> allocatedResources;\n    Set<Integer> requestedResources;\n\n    Process(int id) {\n        this.id = id;\n        this.allocatedResources = new HashSet<>();\n        this.requestedResources = new HashSet<>();\n    }\n}\n\npublic class DeadlockDetection {\n    public static int detectDeadlockUnavoidableTime(int[][] logs, int numProcesses, int numResources) {\n        Map<Integer, Process> processes = new HashMap<>();\n        for (int i = 0; i < numProcesses; i++) {\n            processes.put(i, new Process(i));\n        }\n\n        for (int time = 0; time < logs.length; time++) {\n            int processId = logs[time][0];\n            int resourceId = logs[time][1];\n            boolean isAllocation = logs[time][2] == 1;\n\n            Process process = processes.get(processId);\n            if (isAllocation) {\n                process.allocatedResources.add(resourceId);\n            } else {\n                process.requestedResources.add(resourceId);\n            }\n\n            if (isDeadlockUnavoidable(processes, numResources)) {\n                return time;\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean isDeadlockUnavoidable(Map<Integer, Process> processes, int numResources) {\n        Map<Integer, Set<Integer>> resourceToProcess = new HashMap<>();\n        for (Process p : processes.values()) {\n            for (int res : p.allocatedResources) {\n                resourceToProcess.computeIfAbsent(res, k -> new HashSet<>()).add(p.id);\n            }\n        }\n\n        boolean[][] graph = new boolean[processes.size()][processes.size()];\n        for (Process p : processes.values()) {\n            for (int res : p.requestedResources) {\n                if (resourceToProcess.containsKey(res)) {\n                    for (int blockingProcess : resourceToProcess.get(res)) {\n                        if (blockingProcess != p.id) {\n                            graph[p.id][blockingProcess] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return hasCycle(graph);\n    }\n\n    private static boolean hasCycle(boolean[][] graph) {\n        int n = graph.length;\n        boolean[] visited = new boolean[n];\n        boolean[] recursionStack = new boolean[n];\n\n        for (int i = 0; i < n; i++) {\n            if (isCyclicUtil(i, visited, recursionStack, graph)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isCyclicUtil(int i, boolean[] visited, boolean[] recursionStack, boolean[][] graph) {\n        if (recursionStack[i]) {\n            return true;\n        }\n        if (visited[i]) {\n            return false;\n        }\n\n        visited[i] = true;\n        recursionStack[i] = true;\n\n        for (int j = 0; j < graph.length; j++) {\n            if (graph[i][j] && isCyclicUtil(j, visited, recursionStack, graph)) {\n                return true;\n            }\n        }\n\n        recursionStack[i] = false;\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 20:56:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass DeadlockDetector {\n    static class Process {\n        int id;\n        List<Integer> requiredResources;\n        List<Integer> allocatedResources;\n        boolean isWaiting;\n\n        Process(int id, List<Integer> requiredResources) {\n            this.id = id;\n            this.requiredResources = requiredResources;\n            this.allocatedResources = new ArrayList<>();\n            this.isWaiting = false;\n        }\n    }\n\n    public static int detectDeadlockUnavoidableTime(List<Process> processes, List<Integer> availableResources) {\n        int time = 0;\n        Set<Integer> allocatedResourceSet = new HashSet<>();\n\n        while (true) {\n            boolean anyProcessProgress = false;\n\n            // Try to allocate resources to processes\n            for (Process process : processes) {\n                if (!process.isWaiting) {\n                    boolean canAllocate = true;\n                    for (int resource : process.requiredResources) {\n                        if (allocatedResourceSet.contains(resource)) {\n                            canAllocate = false;\n                            break;\n                        }\n                    }\n\n                    if (canAllocate) {\n                        process.allocatedResources.addAll(process.requiredResources);\n                        allocatedResourceSet.addAll(process.requiredResources);\n                        anyProcessProgress = true;\n                    } else {\n                        process.isWaiting = true;\n                    }\n                }\n            }\n\n            // Check if deadlock is unavoidable\n            int waitingProcessCount = 0;\n            for (Process process : processes) {\n                if (process.isWaiting) {\n                    waitingProcessCount++;\n                }\n            }\n\n            if (waitingProcessCount == processes.size()) {\n                return time;\n            }\n\n            // No progress made\n            if (!anyProcessProgress) {\n                time++;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<Process> processes = new ArrayList<>();\n        processes.add(new Process(1, Arrays.asList(1, 2)));\n        processes.add(new Process(2, Arrays.asList(2, 3)));\n\n        List<Integer> availableResources = Arrays.asList(1, 2, 3);\n\n        int deadlockTime = detectDeadlockUnavoidableTime(processes, availableResources);\n        System.out.println(\"Deadlock becomes unavoidable at time: \" + deadlockTime);\n    }\n}",
    "timestamp": "2025-08-05 20:56:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_PROCESSES 100\n#define MAX_RESOURCES 100\n\ntypedef struct {\n    int process_id;\n    int resources_needed[MAX_RESOURCES];\n    int resources_held[MAX_RESOURCES];\n    bool is_waiting;\n} Process;\n\ntypedef struct {\n    int total_resources[MAX_RESOURCES];\n    int available_resources[MAX_RESOURCES];\n} ResourceManager;\n\nint detect_deadlock_time(Process *processes, int num_processes, ResourceManager *rm, int num_resources) {\n    int current_time = 0;\n    bool system_deadlocked = false;\n\n    while (!system_deadlocked) {\n        int waiting_processes = 0;\n        bool progress_made = false;\n\n        for (int i = 0; i < num_processes; i++) {\n            if (processes[i].is_waiting) {\n                waiting_processes++;\n                bool can_allocate = true;\n\n                for (int j = 0; j < num_resources; j++) {\n                    if (processes[i].resources_needed[j] > rm->available_resources[j]) {\n                        can_allocate = false;\n                        break;\n                    }\n                }\n\n                if (can_allocate) {\n                    for (int j = 0; j < num_resources; j++) {\n                        rm->available_resources[j] -= processes[i].resources_needed[j];\n                        processes[i].resources_held[j] += processes[i].resources_needed[j];\n                        processes[i].resources_needed[j] = 0;\n                        processes[i].is_waiting = false;\n                    }\n                    progress_made = true;\n                }\n            }\n        }\n\n        if (!progress_made && waiting_processes > 0) {\n            system_deadlocked = true;\n            break;\n        }\n\n        current_time++;\n    }\n\n    return current_time;\n}\n\nint main() {\n    // Implementation details depend on specific input format\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nclass DeadlockDetector {\nprivate:\n    struct Process {\n        int id;\n        std::vector<int> resources_needed;\n        std::vector<int> resources_held;\n        bool blocked = false;\n    };\n\n    std::vector<Process> processes;\n    std::vector<int> available_resources;\n    std::unordered_map<int, std::unordered_set<int>> resource_allocation;\n\npublic:\n    void addProcess(int process_id, const std::vector<int>& needed, const std::vector<int>& held) {\n        processes.push_back({process_id, needed, held});\n    }\n\n    void setAvailableResources(const std::vector<int>& resources) {\n        available_resources = resources;\n    }\n\n    void recordResourceAllocation(int process_id, int resource_id) {\n        resource_allocation[process_id].insert(resource_id);\n    }\n\n    bool canProcessProceed(const Process& process) {\n        for (size_t i = 0; i < process.resources_needed.size(); ++i) {\n            if (process.resources_needed[i] > available_resources[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int detectDeadlockPoint() {\n        int time = 0;\n        std::unordered_set<int> blocked_processes;\n\n        while (true) {\n            bool progress_made = false;\n\n            for (auto& process : processes) {\n                if (!process.blocked && canProcessProceed(process)) {\n                    // Release resources and mark as progress\n                    for (size_t i = 0; i < process.resources_needed.size(); ++i) {\n                        available_resources[i] -= process.resources_needed[i];\n                    }\n                    progress_made = true;\n                } else {\n                    process.blocked = true;\n                    blocked_processes.insert(process.id);\n                }\n            }\n\n            // If no process can proceed, check for potential deadlock\n            if (!progress_made) {\n                // Check if blocked processes form a circular dependency\n                if (blocked_processes.size() > 1) {\n                    return time;\n                }\n                break;\n            }\n\n            time++;\n        }\n\n        return -1; // No deadlock detected\n    }\n};\n\nint main() {\n    DeadlockDetector detector;\n\n    // Example usage\n    detector.addProcess(1, {1, 2, 3}, {0, 0, 0});\n    detector.addProcess(2, {2, 1, 4}, {0, 0, 0});\n    detector.setAvailableResources({3, 3, 5});\n    detector.recordResourceAllocation(1, 1);\n    detector.recordResourceAllocation(2, 2);\n\n    int deadlock_time = detector.detectDeadlockPoint();\n    \n    if (deadlock_time != -1) {\n        std::cout << \"Deadlock becomes unavoidable at time: \" << deadlock_time << std::endl;\n    } else {\n        std::cout << \"No deadlock detected\" << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef find_deadlock_unavoidable_time(processes, resource_logs):\n    def can_allocate(requests, available, allocation):\n        work = available[:]\n        finish = [False] * len(processes)\n        \n        while True:\n            allocated_any = False\n            for i, process in enumerate(processes):\n                if not finish[i]:\n                    if all(requests[i][j] <= work[j] for j in range(len(work))):\n                        work = [work[j] + allocation[i][j] for j in range(len(work))]\n                        finish[i] = True\n                        allocated_any = True\n            if not allocated_any:\n                break\n\n        return all(finish)\n\n    n_processes = len(processes)\n    resources = set(r for p in processes for r in p['max'].keys())\n    allocation = [[0] * len(resources) for _ in range(n_processes)]\n    max_claim = [[0] * len(resources) for _ in range(n_processes)]\n    available = {r: processes[0]['available'][r] for r in resources}\n\n    for pi, process in enumerate(processes):\n        for r in process['max']:\n            max_claim[pi][r] = process['max'][r]\n\n    sorted_logs = sorted(resource_logs, key=lambda x: x[2])  # Sort by time\n\n    for log in sorted_logs:\n        proc_idx = log[0]\n        res_idx = log[1]\n        time = log[2]\n\n        allocation[proc_idx][res_idx] += 1\n        available[res_idx] -= 1\n\n        if not can_allocate(max_claim, list(available.values()), allocation):\n            return time\n        \n    return None\n\n# Example usage:\nprocesses = [\n    {'max': {0: 2, 1: 3}, 'available': {0: 3, 1: 3}},\n    {'max': {0: 3, 1: 2}, 'available': {0: 3, 1: 3}}\n]\n\nresource_logs = [\n    (0, 0, 1), # Process 0 allocated resource 0 at time 1\n    (1, 1, 2), # Process 1 allocated resource 1 at time 2\n    (1, 0, 3), # Process 1 allocated resource 0 at time 3\n    (0, 1, 4)  # Process 0 allocated resource 1 at time 4\n]\n\nprint(find_deadlock_unavoidable_time(processes, resource_logs))  # Output: 3",
    "timestamp": "2025-08-13 04:09:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DeadlockDetection {\n    static class Process {\n        int id;\n        Set<Integer> resourcesHeld;\n        Set<Integer> resourcesNeeded;\n        \n        Process(int id) {\n            this.id = id;\n            resourcesHeld = new HashSet<>();\n            resourcesNeeded = new HashSet<>();\n        }\n    }\n    \n    public static int detectDeadlock(Map<Integer, Process> processes, List<int[]> resourceLog) {\n        Map<Integer, Integer> resourceToProcess = new HashMap<>();\n        \n        for (int[] log : resourceLog) {\n            int time = log[0], processId = log[1], resourceId = log[2];\n            Process process = processes.get(processId);\n            \n            if (!resourceToProcess.containsKey(resourceId)) {\n                resourceToProcess.put(resourceId, processId);\n                process.resourcesHeld.add(resourceId);\n            } else {\n                process.resourcesNeeded.add(resourceId);\n            }\n            \n            if (isDeadlock(processes)) {\n                return time;\n            }\n        }\n        \n        return -1; // No deadlock unavoidable\n    }\n    \n    private static boolean isDeadlock(Map<Integer, Process> processes) {\n        Map<Integer, Integer> visited = new HashMap<>();\n        \n        for (Process process : processes.values()) {\n            if (detectCycle(process, processes, visited)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private static boolean detectCycle(Process current, Map<Integer, Process> processes, Map<Integer, Integer> visited) {\n        if (visited.getOrDefault(current.id, 0) == 1) return true;\n        if (visited.getOrDefault(current.id, 0) == 2) return false;\n        \n        visited.put(current.id, 1);\n        \n        for (int resNeeded : current.resourcesNeeded) {\n            for (Process process : processes.values()) {\n                if (process.resourcesHeld.contains(resNeeded) && detectCycle(process, processes, visited)) {\n                    return true;\n                }\n            }\n        }\n        \n        visited.put(current.id, 2);\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage.\n        Map<Integer, Process> processes = new HashMap<>();\n        \n        Process p1 = new Process(1);\n        p1.resourcesNeeded.add(2);\n        processes.put(1, p1);\n        \n        Process p2 = new Process(2);\n        p2.resourcesNeeded.add(3);\n        processes.put(2, p2);\n        \n        Process p3 = new Process(3);\n        p3.resourcesNeeded.add(1);\n        processes.put(3, p3);\n        \n        List<int[]> resourceLog = new ArrayList<>();\n        resourceLog.add(new int[]{0, 1, 1});\n        resourceLog.add(new int[]{1, 2, 2});\n        resourceLog.add(new int[]{2, 3, 3});\n        \n        int deadlockTime = detectDeadlock(processes, resourceLog);\n        System.out.println(\"Deadlock unavoidable at time: \" + deadlockTime);\n    }\n}",
    "timestamp": "2025-08-13 04:09:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_PROCESSES 100\n#define MAX_RESOURCES 100\n\ntypedef struct {\n    int allocation[MAX_RESOURCES];\n    int max[MAX_RESOURCES];\n    int need[MAX_RESOURCES];\n    int finished;\n} Process;\n\nint resource_count, process_count;\nint available[MAX_RESOURCES];\nProcess processes[MAX_PROCESSES];\n\nint isSafe() {\n    int work[MAX_RESOURCES];\n    int finished[MAX_PROCESSES] = {0};\n    for (int i = 0; i < resource_count; i++) {\n        work[i] = available[i];\n    }\n\n    while (1) {\n        int found = 0;\n        for (int p = 0; p < process_count; p++) {\n            if (!finished[p]) {\n                int canFinish = 1;\n                for (int r = 0; r < resource_count; r++) {\n                    if (processes[p].need[r] > work[r]) {\n                        canFinish = 0;\n                        break;\n                    }\n                }\n                if (canFinish) {\n                    for (int r = 0; r < resource_count; r++) {\n                        work[r] += processes[p].allocation[r];\n                    }\n                    finished[p] = 1;\n                    found = 1;\n                }\n            }\n        }\n        if (!found) break;\n    }\n\n    for (int p = 0; p < process_count; p++) {\n        if (!finished[p]) return 0;\n    }\n    return 1;\n}\n\nvoid checkState(int clock) {\n    for (int p = 0; p < process_count; p++) {\n        for (int r = 0; r < resource_count; r++) {\n            processes[p].need[r] = processes[p].max[r] - processes[p].allocation[r];\n        }\n    }\n    if (!isSafe()) {\n        printf(\"Deadlock unavoidable at time %d\\n\", clock);\n        exit(0);\n    }\n}\n\nint main() {\n    int times[MAX_PROCESSES][MAX_RESOURCES];\n\n    // Example inputs: Needs to be replaced with actual input reading\n    // Initialize processes, their allocation, max and resource count\n\n    // Sample input reading contrived for demo; replace it with real input processing\n    printf(\"Enter number of processes and resources: \");\n    scanf(\"%d %d\", &process_count, &resource_count);\n\n    // Reading available resources\n    printf(\"Enter available resources: \");\n    for (int i = 0; i < resource_count; i++) {\n        scanf(\"%d\", &available[i]);\n    }\n\n    // Reading each process's allocation and maximum requirements\n    for (int i = 0; i < process_count; i++) {\n        printf(\"Enter allocations for process %d: \", i);\n        for (int j = 0; j < resource_count; j++) {\n            scanf(\"%d\", &processes[i].allocation[j]);\n        }\n        printf(\"Enter maximum resources needed for process %d: \", i);\n        for (int j = 0; j < resource_count; j++) {\n            scanf(\"%d\", &processes[i].max[j]);\n        }\n    }\n\n    // Simulating clock tick; replace with actual time logs\n    for (int clock = 0; ; clock++) {\n        // Advance simulation clock and update allocations if needed\n\n        checkState(clock);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:09:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def detect_deadlock_unavoidable(processes, resource_log):\n    # Initialize resource tracking\n    allocated_resources = {}\n    process_waiting = {}\n    time_of_first_unavoidable_state = float('inf')\n\n    # Track resource allocation over time\n    for timestamp, event in sorted(resource_log.items()):\n        process, resource, action = event\n        \n        if action == 'request':\n            # Process is requesting a resource\n            if resource not in allocated_resources:\n                allocated_resources[resource] = process\n            else:\n                # Resource is already allocated\n                blocking_process = allocated_resources[resource]\n                if blocking_process != process:\n                    process_waiting[process] = blocking_process\n        \n        elif action == 'release':\n            # Process releases resource\n            if resource in allocated_resources and allocated_resources[resource] == process:\n                del allocated_resources[resource]\n        \n        # Check for circular dependency\n        if _has_circular_dependency(process_waiting):\n            time_of_first_unavoidable_state = min(time_of_first_unavoidable_state, timestamp)\n    \n    return time_of_first_unavoidable_state if time_of_first_unavoidable_state != float('inf') else -1\n\ndef _has_circular_dependency(process_waiting):\n    visited = set()\n    for process in process_waiting:\n        if _detect_cycle(process, process_waiting, visited):\n            return True\n    return False\n\ndef _detect_cycle(process, process_waiting, visited, path=None):\n    if path is None:\n        path = set()\n    \n    if process in path:\n        return True\n    \n    if process in visited:\n        return False\n    \n    visited.add(process)\n    path.add(process)\n    \n    if process in process_waiting:\n        next_process = process_waiting[process]\n        if _detect_cycle(next_process, process_waiting, visited, path):\n            return True\n    \n    path.remove(process)\n    return False",
    "timestamp": "2025-08-13 04:09:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef detect_deadlock_unavoidable(processes, resources, allocation_log):\n    # Initialize data structures\n    allocation = defaultdict(dict)\n    request = defaultdict(dict)\n    available = resources.copy()\n    process_list = list(processes.keys())\n    resource_list = list(resources.keys())\n    \n    # Initialize allocation and request matrices\n    for p in process_list:\n        for r in resource_list:\n            allocation[p][r] = 0\n            request[p][r] = processes[p].get(r, 0)\n    \n    # Sort allocation log by time\n    allocation_log.sort(key=lambda x: x[0])\n    \n    for time, process, resource, amount in allocation_log:\n        # Update allocation and available\n        allocation[process][resource] += amount\n        available[resource] -= amount\n        \n        # Check for deadlock-unavoidable state\n        if is_deadlock_unavoidable(allocation, request, available, process_list, resource_list):\n            return time\n    \n    return -1\n\ndef is_deadlock_unavoidable(allocation, request, available, process_list, resource_list):\n    work = available.copy()\n    finish = {p: False for p in process_list}\n    \n    # Find a process that can finish\n    while True:\n        found = False\n        for p in process_list:\n            if not finish[p]:\n                can_finish = True\n                for r in resource_list:\n                    if request[p][r] - allocation[p][r] > work[r]:\n                        can_finish = False\n                        break\n                if can_finish:\n                    found = True\n                    finish[p] = True\n                    for r in resource_list:\n                        work[r] += allocation[p][r]\n        if not found:\n            break\n    \n    # If all processes can finish, no deadlock\n    if all(finish.values()):\n        return False\n    return True\n\n# Example usage:\n# processes = {\n#     'P1': {'R1': 1, 'R2': 0},\n#     'P2': {'R1': 0, 'R2': 1}\n# }\n# resources = {'R1': 1, 'R2': 1}\n# allocation_log = [\n#     (1, 'P1', 'R1', 1),\n#     (2, 'P2', 'R2', 1),\n#     (3, 'P1', 'R2', 0),\n#     (4, 'P2', 'R1', 0)\n# ]\n# print(detect_deadlock_unavoidable(processes, resources, allocation_log))",
    "timestamp": "2025-08-13 04:10:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n\nstruct Process {\n    int id;\n    std::set<int> requiredResources;\n};\n\nstruct ResourceLog {\n    int time;\n    int processId;\n    int resourceId;\n    bool allocated; // true if allocated, false if released\n};\n\nbool isDeadlockUnavoidable(const std::vector<Process>& processes, const std::unordered_map<int, int>& allocation) {\n    std::set<int> freeResources, waitingResources;\n    \n    for (const auto& process : processes) {\n        for (int resource : process.requiredResources) {\n            if (allocation.find(resource) == allocation.end()) {\n                freeResources.insert(resource);\n            } else {\n                waitingResources.insert(resource);\n            }\n        }\n    }\n    \n    while (!waitingResources.empty()) {\n        bool progress = false;\n        for (const auto& process : processes) {\n            bool allResourcesFree = true;\n            for (int resource : process.requiredResources) {\n                if (waitingResources.find(resource) != waitingResources.end()) {\n                    allResourcesFree = false;\n                    break;\n                }\n            }\n            if (allResourcesFree) {\n                progress = true;\n                for (int resource : process.requiredResources) {\n                    freeResources.insert(resource);\n                    waitingResources.erase(resource);\n                }\n            }\n        }\n        if (!progress) {\n            return true;  // Deadlock unavoidable if no progress can be made\n        }\n    }\n    return false;\n}\n\nint findDeadlockUnavoidableTime(const std::vector<Process>& processes, const std::vector<ResourceLog>& logs) {\n    std::unordered_map<int, int> allocation;\n    \n    for (const auto& log : logs) {\n        if (log.allocated) {\n            allocation[log.resourceId] = log.processId;\n        } else {\n            allocation.erase(log.resourceId);\n        }\n        \n        if (isDeadlockUnavoidable(processes, allocation)) {\n            return log.time;\n        }\n    }\n    return -1; // Return -1 if no deadlock is unavoidable\n}\n\nint main() {\n    std::vector<Process> processes = {\n        {1, {1, 2}},\n        {2, {2, 3}}\n    };\n    \n    std::vector<ResourceLog> logs = {\n        {1, 1, 1, true},\n        {2, 2, 2, true},\n        {3, 1, 2, true},\n        {4, 1, 3, false},\n        {5, 2, 3, true}\n    };\n    \n    int deadlockTime = findDeadlockUnavoidableTime(processes, logs);\n    if (deadlockTime >= 0) {\n        std::cout << \"Deadlock unavoidable at time: \" << deadlockTime << std::endl;\n    } else {\n        std::cout << \"No unavoidable deadlock detected.\" << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:34"
  }
]