[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0){\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n    }\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n    assert(cnt[i]==0);\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0)\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n  }\n\n\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    assert(cnt[i]<0);\n    if(cnt[i]>0)return false;\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    bool check_terminated(vector<int> &need) {\n        bool terminated = true;\n        rep(r, R) terminated &= need[r] == 0;\n        return terminated;\n    }\n    \n    bool is_avoidable(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left = L;\n\n        vector<bool> terminated(P);\n        int terminated_num = 0;\n\n        // O(t * R) ? \n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n            if(left[r] < 0) {\n                return false; // lack of resource !\n            }\n            if(need[p][r] == 0) {\n                assert(not terminated[p]);\n                if(check_terminated(need[p])) {\n                    rep(r2, R) left[r2] += N[p][r2] - need[p][r2];\n                    terminated[p] = true;\n                    terminated_num++;                            \n                }\n            }\n        }            \n                \n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) terminatable &= need[p][r] <= left[r];\n                if(terminatable) {\n                    rep(r, R) left[r] += N[p][r] - need[p][r];\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        // cerr << \"! \" << t << \" \" << terminated_num << endl;\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = -1, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            // cerr << m << \" \" << l << \" \" << r << endl;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\ntypedef long long ll;\n\nint p,r,t;\nint l[353];\nint n[353][353];\nint nsum[353];\nint P[252521], R[252521];\n\nint l2[353], n2[353][353];\nint nsum2[353];\n\nint main(){\n  scanf(\"%d%d%d\",&p,&r,&t);\n  REP(i,r)scanf(\"%d\",l+i);\n  REP(i,p)REP(j,r)scanf(\"%d\",&n[i][j]);\n  REP(i,t)scanf(\"%d%d\",P+i,R+i);\n  REP(i,p){\n    nsum[i] = 0;\n    REP(j,r)nsum[i] += n[i][j];\n  }\n  REP(i,t)P[i]--, R[i]--;\n  int low = -1, high = t+1;\n  while(low+1 < high){\n    int x = (low+high)/2;\n    REP(i,r)l2[i] = l[i];\n    REP(i,p)REP(j,r)n2[i][j] = n[i][j];\n    REP(i,p)nsum2[i] = nsum[i];\n    REP(i,x){\n      l2[R[i]]--;\n      n2[P[i]][R[i]]--;\n      nsum2[P[i]]--;\n      if(nsum2[P[i]] == 0){\n        REP(j,r){\n          l2[j] += n[i][j];\n          n2[P[i]][j] = n[i][j];\n        }\n        nsum2[P[i]] = nsum[P[i]];\n      }\n    }\n    vector<bool> avoided(p, false);\n    int cnt = 0;\n    REP(_,p)REP(i,p)if(!avoided[i]){\n      bool ok = true;\n      REP(j,r)if(n2[i][j] > l2[j])ok=false;\n      if(ok){\n        REP(j,r)l2[j] += (n[i][j]-n2[i][j]);\n        avoided[i] = true;\n        cnt++;\n      }\n    }\n    if(cnt == p){\n      low = x;\n    }else{\n      high = x;\n    }\n  }\n  printf(\"%d\\n\", high);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\nconst int maxN = 333;\nconst int maxO = 2e5 + 100;\nint n, m, t, l[maxN], rec2[maxN];\nint nd[maxN][maxN], rec[maxN][maxN];\nbool li[maxN];\npii ope[maxO];\n\n\n/*\nbool deadlock(int w) {\n\tmemcpy(rec, nd, sizeof nd);\n\tmemcpy(rec2, l, sizeof l);\n\tmemset(li, false, sizeof li);\n\tfor (int i = 1; i <= w; ++i) {\n\t\tnd[ope[i].x][ope[i].y]--;\n\t\tl[ope[i].y]--;\n\t}\n\tfor (int p = 1; p <= n; ++p) {\n\t\tbool fd = false;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (li[i]) break;\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\tif (l[k] < nd[i][k]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\t\tl[k] += rec[i][k] - nd[i][k];\n\t\t\t\tli[i] = true;\n\t\t\t\tfd = true;\n\t\t\t}\n\t\t}\n\t//\tif (!fd) break;\n\t}\n\tmemcpy(nd, rec, sizeof rec);\n\tmemcpy(l, rec2, sizeof rec2);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!li[i]) return true;\n\treturn false;\n}\n*/\n\nint q[maxN][maxN], p[maxN];\nbool deadlock(int w) {\n\tmemcpy(q, nd, sizeof nd);\n\tmemcpy(p, l, sizeof l);\n\tmemset(li, 0, sizeof li);\n\tfor (int i = 1; i <= w; ++i) {\n\t\t--q[ope[i].x][ope[i].y];\n\t\t--p[ope[i].y];\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\tif (p[k] < q[j][k]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\t\tp[k] += nd[j][k] - q[j][k];\n\t\t\t\tli[j] = true;\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!li[i]) return true;\n\treturn false;\n\n}\n\nint main() {\n#ifdef lol\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tfor (int i = 1; i <= m; ++i)\n\t\tscanf(\"%d\", &l[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%d\", &nd[i][j]);\n\tfor (int i = 1; i <= t; ++i)\n\t\tscanf(\"%d %d\", &ope[i].x, &ope[i].y);\n\t//bool ded = 0;\n\t//for (int i = 1; i <= t; ++i)\n\t//\tif (deadlock(i)) {\n\t//\t\tded = true;\n\t//\t} else {\n\t//\t\tassert(!ded);\n\t//\t}\n\n\tif (!deadlock(t)) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\t//for (int i = 1; i <= t; ++i) {\n\t//\tif (deadlock(i)) {\n\t//\t\tprintf(\"%d\\n\", i);\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//puts(\"-1\");\n\t\n\t//return 0;\n\n\tint l = 1, r = t;\n\t//for (int i = 1; i <= t; ++i)\n\t//\tprintf(\"%d\", deadlock(i));\n\t//puts(\"\");\n\twhile (l != r) {\n\t//\tprintf(\"%d %d\\n\", l, r);\n\t\tif (r - l < 10) {\n\t\t\tfor (int i = l; i <= r; ++i) {\n\t\t\t\tif (deadlock(i)) {\n\t\t\t\t\tl = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (!deadlock(mid))\n\t\t\tl = mid + 1;\n\t\telse r = mid;\n\t}\n\tif (l == t && !deadlock(t)) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n \n\nsigned main(){\n\n  int p,r,t;\n  cin>>p>>r>>t;\n  \n  vector<int> LL(r);\n  for(int i=0;i<r;i++) cin>>LL[i];\n\n  vector<vector<int> > n(p,vector<int> (r));\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++) cin>>n[i][j];\n\n\n  vector<int> P(t),R(t);\n  for(int i=0;i<t;i++) cin>>P[i]>>R[i], P[i]--,R[i]--;\n  \n  \n  auto deadLock=[&](int x){\n    vector<int> L = LL;\n    vector<queue <int> > Q(r);\n    vector<vector<int> > cnt(p,vector<int> (r,0));\n    \n    auto ok = [&](int p){\n      for(int i=0;i<r;i++) if(n[p][i] != cnt[p][i]) return 0;\n      return 1;\n    };\n\n    auto freeL = [&](int p){\n      for(int i=0;i<r;i++) L[i] += cnt[p][i], cnt[p][i] = 0;\n    };\n\n    //cout<<\"L \";\n    //for(int i=0;i<r;i++) cout<<L[i]<<\" \";cout<<endl;\n    \n    auto use =[&](){\n      int res = 0;\n      for(int i=0;i<r;i++){\n\tif(Q[i].empty()) continue;\n\tif(L[i] == 0) continue;\n\tint process = Q[i].front(); Q[i].pop();\n\tL[i]--, cnt[process][i]++;\n\tif(!ok(process)) continue;\n\tfreeL(process);\n\tres = 1;\n      }\n      return res;\n    };\n    \n    for(int i=0;i<x;i++){\n      int pi = P[i];\n      int ri = R[i];\n      Q[ri].push(pi);\n      while(use());\n    }\n    // simulation owari\n\n    //for(int i=0;i<r;i++) cout<<Q[i].size()<<endl;\n\n    auto sum=[&](int p){\n      int res = 0;\n      for(int i=0;i<r;i++) res += cnt[p][i];\n      return res;\n    };\n\n    auto canFree=[&](int p){\n      for(int i=0;i<r;i++) if(n[p][i] - cnt[p][i] > L[i]) return 0;\n      return 1;\n    };\n\n    //cout<<\"L: \";\n    //for(int i=0;i<r;i++) cout<<L[i]<<\" \";cout<<endl;\n    /*for(int i=0;i<p;i++){\n      cout<<\"i=\"<<i<<\": \";\n      for(int j=0;j<r;j++) cout<<cnt[i][j]<<\" \";\n      cout<<endl;\n    }\n    */\n\n    int update = 1;\n    while(update){\n      update = 0;\n      for(int i=0;i<p;i++){ //process\n\tif(sum(i) == 0) {continue;}\n\tif(!canFree(i)) continue;\n\tupdate = 1;\n\tfreeL(i);\n\twhile(use());\n      }\n    }\n\n    for(int i=0;i<p;i++) if(sum(i)) return 1;   \n    for(int i=0;i<r;i++) if(!Q[i].empty()) return 1;\n    return 0;\n  };\n\n  \n  int ans = -1;\n  {\n    int L = 1, R = t+1;\n    while(L+1<R){\n      int M = (L+R)/2;\n      if(deadLock(M)) R = M;\n      else L = M;\n    }\n    ans = R;\n    if(R == t+1) ans = -1;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 305\n#define M 201000\nusing namespace std;\n\nint n,m,p;\nint now[N],sum[N];\nint need[N][N],has[N];\nint sneed[N][N],remain[N];\nint ax[M],ay[M];\nbool inq[N];\n\nbool check(int t)\n{\n\tint i,j,k;\n\tint a,b;\n\n\n\tfor(i=1;i<=m;i++)remain[i]=has[i];\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)\n\t\tsneed[i][j]=need[i][j];\n\tfor(i=1;i<=n;i++)inq[i]=1,now[i]=0;\n\t\n\tfor(i=1;i<=t;i++)\n\t{\n\t\ta=ax[i],b=ay[i];\n\t\tnow[a]++,sneed[a][b]--,remain[b]--;\n\t\tif(now[a]==sum[a])\n\t\t{\n\t\t\tfor(i=1;i<=m;i++)\n\t\t\t\tremain[i]+=need[a][i];\n\t\t\tinq[a]=0;\n\t\t}\n\t}\n\tbool flag=1;\n\twhile(flag)\n\t{\n\t\tflag=0;\n\t\tfor(i=1;i<=n;i++)if(inq[i])\n\t\t{\n\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\tif(sneed[i][j]>remain[j])\n\t\t\t\t\tbreak;\n\t\t\tif(j>m)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tremain[j]+=need[i][j]-sneed[i][j];\n\t\t\t\tinq[i]=0;\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)if(inq[i])return 0;\n\treturn 1;\n}\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n\n\tint i,j;\n\n\tscanf(\"%d%d%d\",&n,&m,&p);\n\tfor(i=1;i<=m;i++)scanf(\"%d\",&has[i]);\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)\n\t\tscanf(\"%d\",&need[i][j]),sum[i]+=need[i][j];\n\tfor(i=1;i<=p;i++)scanf(\"%d%d\",&ax[i],&ay[i]);\n\t\n\tif(check(p))puts(\"-1\");\n\telse {\n\t\tint l=0,r=p;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(check(mid))l=mid+1;\n\t\t\telse r=mid;\n\t\t}\n\t\tprintf(\"%d\\n\",l);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <iostream> \nusing namespace std;\n \npair<int, int> P[200005];\n \nint p, r, t;\n \nint ned[305][305];\nint num[305];\n \nint grid[305][305];\nint used[305];\nint bo[305];\n \nint check(int t) {\n    memset(used, 0, sizeof(used));\n    memset(grid, 0, sizeof(grid));\n    memset(bo, 0, sizeof(bo));\n    for (int i = 1; i <= t; ++i) {\n        ++used[P[i].second];\n        ++grid[P[i].first][P[i].second];\n    }\n    int tot = 0;\n    while (1) {\n        int flag = 0;\n        for (int i = 1; i <= p; ++i)\n            if (!bo[i]) {\n                int mark = 0;\n                for (int j = 1; j <= r; ++j)\n                    if (grid[i][j] + max(num[j] - used[j], 0) < ned[i][j])\n                        mark = 1;\n                if (mark == 0) {\n                    flag = i;\n                    break;\n                }\n            }\n        if (flag == 0) break;\n        bo[flag] = 1;\n        ++tot;\n        for (int j = 1; j <= r; ++j)\n            used[j] -= grid[flag][j];\n    }\n    return tot == p;\n}\n \nint main() {\n    scanf(\"%d%d%d\", &p, &r, &t);\n    for (int i = 1; i <= r; ++i) {\n        scanf(\"%d\", &num[i]);\n    }\n    for (int i = 1; i <= p; ++i)\n        for (int j = 1; j <= r; ++j)\n            scanf(\"%d\", &ned[i][j]);\n    for (int i = 1; i <= t; ++i) {\n        scanf(\"%d%d\", &P[i].first, &P[i].second);\n    }\n    // cout << check(0) << endl;\n    if (check(t)) {\n        puts(\"-1\");\n    }\n    else {\n        int head = 0, tail = t;\n        while (head < tail - 1) {\n            int mid = (head + tail) >> 1;\n            if (check(mid)) head = mid;\n            else tail = mid;\n        }\n        cout << tail << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\nconst int maxN = 333;\nconst int maxO = 2e5 + 100;\nint n, m, t, l[maxN], rec2[maxN];\nint nd[maxN][maxN], rec[maxN][maxN];\nbool li[maxN];\npii ope[maxO];\n\n\nbool deadlock(int w) {\n\tmemcpy(rec, nd, sizeof nd);\n\tmemcpy(rec2, l, sizeof l);\n\tmemset(li, false, sizeof li);\n\tfor (int i = 1; i <= w; ++i) {\n\t\tnd[ope[i].x][ope[i].y]--;\n\t\tl[ope[i].y]--;\n\t}\n\tfor (int p = 1; p <= n; ++p)\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (li[i]) break;\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\tif (l[k] < nd[i][k]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\t\tl[k] += rec[i][k] - nd[i][k];\n\t\t\t\tli[i] = true;\n\t\t\t}\n\t\t}\n\tmemcpy(nd, rec, sizeof rec);\n\tmemcpy(l, rec2, sizeof rec2);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!li[i]) return true;\n\treturn false;\n}\n\nint main() {\n#ifdef lol\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tfor (int i = 1; i <= m; ++i)\n\t\tscanf(\"%d\", &l[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%d\", &nd[i][j]);\n\tfor (int i = 1; i <= t; ++i)\n\t\tscanf(\"%d %d\", &ope[i].x, &ope[i].y);\n\tfor (int i = t; 0 < i; --i)\n\t\tif (!deadlock(i)) {\n\t\t\tif (i == 1) {\n\t\t\t\tputs(\"-1\");\n\t\t\t} else {\n\t\t\t\tprintf(\"%d\\n\", i+1);\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\tint l = 1, r = t;\n\t//for (int i = 1; i <= t; ++i)\n\t//\tprintf(\"%d\", deadlock(i));\n\t//puts(\"\");\n\twhile (l != r) {\n\t//\tprintf(\"%d %d\\n\", l, r);\n\t\tint mid = (l + r) >> 1;\n\t\tif (!deadlock(mid))\n\t\t\tl = mid + 1;\n\t\telse r = mid;\n\t}\n\tprintf(\"%d\\n\", l >= t ? -1 : l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int P, R, T, L[300], N[300][300];\n  int latte[200000], malta[200000];\n\n\n  cin >> P >> R >> T;\n  for(int i = 0; i < R; i++) {\n    cin >> L[i];\n  }\n  for(int i = 0; i < P; i++) {\n    for(int j = 0; j < R; j++) {\n      cin >> N[i][j];\n    }\n  }\n  for(int i = 0; i < T; i++) {\n    cin >> latte[i] >> malta[i];\n    --latte[i];\n    --malta[i];\n  }\n\n  int ok = -1, ng = T;\n  while(ng - ok > 1) {\n    int mid = (ok + ng) / 2;\n    ([&]\n     {\n       vector< vector< int > > need(P, vector< int >(R));\n       vector< int > available(R);\n       for(int i = 0; i < P; i++) {\n         for(int j = 0; j < R; j++) need[i][j] = N[i][j];\n       }\n       for(int i = 0; i < R; i++) available[i] = L[i];\n\n       for(int i = 0; i <= mid; i++) {\n         --need[latte[i]][malta[i]];\n         --available[malta[i]];\n       }\n\n       vector< int > live(P);\n       iota(begin(live), end(live), 0);\n\n       int sum = 0;\n       while(!live.empty()) {\n         vector< int > nxt;\n         bool update = false;\n         for(int i : live) {\n           bool f = true;\n           for(int j = 0; j < R; j++) {\n             if(need[i][j] == 0) continue;\n             f &= need[i][j] <= available[j];\n           }\n           if(f) {\n             update = true;\n             for(int j = 0; j < R; j++) available[j] += N[i][j] - need[i][j];\n           } else {\n             nxt.push_back(i);\n           }\n         }\n         if(!update) return (false);\n         swap(nxt, live);\n       }\n       return (true);\n     }() ? ok : ng) = mid;\n  }\n  if(ok >= T - 1) cout << -1 << endl;\n  else cout << ok + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200050;\n\nint p, r, t, a[510], m[510][510], s[510][510], b[510], u[N], v[N];\nbool vis[510];\n\nbool check(int mid) {\n    queue <int> q;\n    for (int i = 0; i < p; i++) {\n        vis[i] = false;\n        for (int j = 0; j < r; j++) {\n            s[i][j] = m[i][j];\n        }\n    }\n    for (int i = 0; i < r; i++) {\n        b[i] = a[i];\n    }\n    for (int i = 0; i <= mid; i++) {\n        b[v[i]]--;\n        s[u[i]][v[i]]--;\n        assert(u[i] < p);\n        assert(v[i] < r);\n        assert(b[v[i]] >= 0);\n        assert(s[u[i]][v[i]] >= 0);\n    }\n    for (int i = 0; i < p; i++) {\n        bool ok = true;\n        for (int j = 0; j < r; j++) {\n            if (s[i][j] > b[j]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            vis[i] = true;\n            q.push(i);\n        }\n    }\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = 0; i < r; i++) {\n            b[i] += m[now][i] - s[now][i];\n        }\n        for (int i = 0; i < p; i++) {\n            if (vis[i]) {\n                continue;\n            }\n            bool ok = true;\n            for (int j = 0; j < r; j++) {\n                if (s[i][j] > b[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                vis[i] = true;\n                q.push(i);\n            }\n        }\n    }\n    for (int i = 0; i < p; i++) {\n        if (!vis[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n\n    while (scanf(\"%d %d %d\", &p, &r, &t) != EOF) {\n        for (int i = 0; i < r; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < r; j++) {\n                scanf(\"%d\", &m[i][j]);\n            }\n        }\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &u[i], &v[i]);\n            u[i]--;\n            v[i]--;\n        }\n        if (check(t - 1)) {\n            puts(\"-1\");\n            continue;\n        }\n        int lo = -1;\n        int hi = t - 1;\n        for (int i = 0; i < t && i < 100; i++) {\n            assert(check(i) >= check(i + 1));\n        }\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid)) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        printf(\"%d\\n\", lo + 1);\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n,m,t;\nint have[303],dat[303];\nint need[303][303];\nint now[303][303];\nint a[200005],b[200005];\ninline bool ok(int step){\n\tmemset(now,0,sizeof now);\n\tmemcpy(have,dat,sizeof have);\n\tfor(int i=1;i<=step;i++){\n\t\tnow[a[i]][b[i]]++;\n\t\thave[b[i]]--;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint mul=inf;\n\t\tfor(int j=1;j<=m;j++)if(need[i][j])mul=min(mul,now[i][j]/need[i][j]);\n\t\tfor(int j=1;j<=m;j++)have[j]+=mul*need[i][j],now[i][j]-=mul*need[i][j];\n\t}\n\twhile(1){\n\t\tbool change=false;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(*max_element(now[i],now[i+1])==0)continue;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=1;j<=m;j++)if(need[i][j]-now[i][j]>have[j])ok=false;\n\t\t\tif(ok){\n\t\t\t\tfor(int j=1;j<=m;j++)have[j]+=now[i][j],now[i][j]=0;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t}\n\t\tif(!change)break;\n\t}\n\tif(*max_element(now[1],now[n+1])>0)return false;\n\treturn true;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);cout.tie(0);\n\tcin>>n>>m>>t;\n\tfor(int i=1;i<=m;i++)cin>>dat[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>need[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=t;i++)cin>>a[i]>>b[i];\n\tint l=0,r=t+1;\n\twhile(r-l>1){\n\t\tint mid=l+r>>1;\n\t\tif(ok(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tcout<<(r==t+1?-1:r)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint P,R,T;\nint init[303];\nint need[303][303];\nint p[200001],r[200001];\n\nbool f(int t){\n  vector<int> crtr(R);\n  vector<vector<int> > crtp(P,vector<int>(R)) ;\n  rep(i,R)crtr[i]=init[i];\n  rep(i,P)rep(j,R)crtp[i][j]=need[i][j];\n  rep(i,t){\n    crtr[r[i]]--;\n    crtp[p[i]][r[i]]--;\n    if(crtr[r[i]]<0)return false;\n  }\n\n  vector<bool> used(P,false);\n  bool update=true;\n  while(update){\n    update=false;\n    rep(i,P){\n      if(used[i])continue;\n      bool ok=true;\n      rep(j,R)if(crtp[i][j]>crtr[j])ok=false;\n      if(!ok)continue;\n      rep(j,R)crtr[j]+=need[i][j]-crtp[i][j];\n      used[i]=true;\n      update=true;\n    }\n  }\n  bool ok=true;\n  rep(i,P)if(!used[i])ok=false;\n  return ok;\n}\n\nint main(){\n  scanf(\"%d%d%d\",&P,&R,&T);\n  rep(i,R)scanf(\"%d\",init+i);\n  rep(i,P)rep(j,R)scanf(\"%d\",&need[i][j]);\n  rep(i,T){\n    scanf(\"%d%d\",p+i,r+i);\n    p[i]--;r[i]--;\n  }\n\n  int lb=0,ub=T+1;\n  while(ub-lb>1){\n    int mid=(lb+ub)/2;\n    if(f(mid))lb=mid;\n    else ub=mid;\n  }\n  if(lb==T)cout<<-1<<endl;\n  else cout<<lb+1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200050;\n\nint p, r, t, a[510], m[510][510], s[510][510], b[510], u[N], v[N];\nbool vis[510];\n\nbool check(int mid) {\n    queue <int> q;\n    for (int i = 0; i < p; i++) {\n        vis[i] = false;\n        for (int j = 0; j < r; j++) {\n            s[i][j] = m[i][j];\n        }\n    }\n    for (int i = 0; i < r; i++) {\n        b[i] = a[i];\n    }\n    for (int i = 0; i <= mid; i++) {\n        b[v[i]]--;\n        s[u[i]][v[i]]--;\n        assert(u[i] < p);\n        assert(v[i] < r);\n        //assert(b[v[i]] >= 0);\n        assert(s[u[i]][v[i]] >= 0);\n    }\n    //printf(\"debg %d ..\\n\", mid);\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < r; j++) {\n            //printf(\"%d \", s[i][j]);\n        }\n        //puts(\"\");\n    }\n    for (int i = 0; i < p; i++) {\n        bool ok = true;\n        bool eq = true;\n        for (int j = 0; j < r; j++) {\n            if (s[i][j] != 0) {\n                eq = false;\n                break;\n            }\n        }\n        for (int j = 0; j < r; j++) {\n            if (s[i][j] > b[j]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok || eq) {\n            vis[i] = true;\n            q.push(i);\n        }\n    }\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = 0; i < r; i++) {\n            b[i] += m[now][i] - s[now][i];\n        }\n        for (int i = 0; i < p; i++) {\n            if (vis[i]) {\n                continue;\n            }\n            bool ok = true;\n            bool eq = true;\n            for (int j = 0; j < r; j++) {\n                if (s[i][j] != 0) {\n                    eq = false;\n                    break;\n                }\n            }\n            for (int j = 0; j < r; j++) {\n                if (s[i][j] > b[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok || eq) {\n                vis[i] = true;\n                q.push(i);\n            }\n        }\n    }\n    for (int i = 0; i < p; i++) {\n        if (!vis[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n\n    while (scanf(\"%d %d %d\", &p, &r, &t) != EOF) {\n        for (int i = 0; i < r; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < r; j++) {\n                scanf(\"%d\", &m[i][j]);\n            }\n        }\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &u[i], &v[i]);\n            u[i]--;\n            v[i]--;\n        }\n        if (check(t - 1)) {\n            puts(\"-1\");\n            continue;\n        }\n        int lo = -1;\n        int hi = t - 1;\n        for (int i = 0; i + 1 < t && i < 100; i++) {\n            //printf(\"%d %d %d\\n\", i, check(i), check(i + 1));\n            //assert(check(i) >= check(i + 1));\n        }\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid)) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        printf(\"%d\\n\", lo + 1);\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint main(){\n    iostream_init();\n    int P, R, K;\n    while(cin >> P >> R >> K) {\n        vector<int> all(R);\n        vector<vector<int>> need_(P, vector<int>(R, 0));\n        vector<bool> used(P, true);\n\n        REP(i, R) cin >> all[i];\n        REP(i, P) REP(j, R) cin >> need_[i][j];\n\n        vector<int> X(K);\n        vector<int> Y(K);\n        REP(i, K) cin >> X[i] >> Y[i];\n        REP(i, K) X[i]--;\n        REP(i, K) Y[i]--;\n\n        auto zero = [&]() {\n            REP(i, P) {\n                REP(j, R) if(need_[i][j] > all[j]) return true;\n            }\n            return false;\n        };\n\n        assert(!zero());\n\n        auto check = [&](int T) {\n            vector<int> cur = all;\n            vector<vector<int>> need = need_;\n            vector<vector<int>> take(P, vector<int>(R, 0));\n            vector<int> have(P);\n\n            REP(i, T) {\n                cur[ Y[i] ]--;\n                need[ X[i] ][ Y[i] ]--;\n                take[ X[i] ][ Y[i] ]++;\n                have[ X[i] ]++;\n            }\n\n            while(true) {\n                bool updated = false;\n                REP(i, P) if(have[i] > 0) {\n                    bool ok = true;\n                    REP(j, R) if(need[i][j] > cur[j]){ ok = false; break; }\n                    if(ok) {\n                        updated = true;\n                        have[i] = 0;\n                        REP(j, R) cur[j] += take[i][j];\n                    }\n                }\n                if(!updated) break;\n            }\n\n            REP(i, P) if(have[i]) return false;\n            return true;\n        };\n\n        if(check(K)) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        int lb = 0, ub = K + 1;\n        // [lb, ub)\n        while(ub - lb > 1) {\n            int T = (lb + ub) / 2;\n            if(check(T)) {\n                lb = T;\n            } else {\n                ub = T;\n            }\n        }\n\n        assert(lb != K);\n\n        cout << ub << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint p,r,t;\nint l[310];\nint need[310][310];\nint proc[200010],res[200010];\n\nbool avoid(int t){\n\tint cl[310],cur[310][310];\n\tbool term[310];\n\t\n\trep(i,p)rep(j,r) cur[i][j]=0;\n\trep(j,r) cl[j]=l[j];\n\n\trep(i,t){\n\t\tcur[proc[i]][res[i]]++,cl[res[i]]--;\n\t\tterm[proc[i]]=true;\n\t\trep(j,r) if(cur[proc[i]][j]!=need[proc[i]][j]) term[proc[i]]=false;\n\t\tif(term[proc[i]]) rep(j,r) cl[j]+=need[proc[i]][j],cur[proc[i]][j]=0;\n\t}\n\n\t/*\n\tcout << need[0][0]-cur[0][0] << \" \" << need[0][1]-cur[0][1] << endl;\n\tcout << need[1][0]-cur[1][0] << \" \" << need[1][1]-cur[1][1] << endl;\n\tcout << cl[0] << \" \" << cl[1]  << endl;\n\t*/\n\n\trep(loop,p){\n\t\tbool can=false;\n\n\t\trep(i,p){\n\t\t\tif(term[i]) continue;\n\t\t\tbool ok=true;\n\t\t\trep(j,r) if(need[i][j]-cur[i][j]>cl[j]) ok=false;\n\t\t\t\n\t\t\tif(ok==false) continue;\n\t\t\tcan=true,term[i]=true;\n\t\t\trep(j,r) cl[j]+=cur[i][j],cur[i][j]=0;\n\t\t}\n\n\t\tif(can==false) break;\n\t}\n\n\trep(i,p) if(term[i]==false) return false;\n\treturn true;\n}\n\nint main(void){\n\tcin >> p >> r >> t;\n\trep(i,r) cin >> l[i];\n\trep(i,p)rep(j,r) cin >> need[i][j];\n\trep(i,t) cin >> proc[i] >> res[i],proc[i]--,res[i]--;\n\n\tint lb=0,ub=t+1;\n\twhile(abs(ub-lb)>1){\n\t\tconst int mid=(lb+ub)/2;\n\t\tif(avoid(mid))\n\t\t\tlb=mid;\n\t\telse\n\t\t\tub=mid;\n\t}\n\n\t//rep(i,1,t+1) cout << i << \" : \" << (avoid(i)?\"Avoid\":\"Unavoid\") << endl;\n\tcout << (ub==t+1?-1:ub) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N=305;\nstruct erz{int p,r;}e[200005];\nint a[N][N],nd[N][N],lp[N],dn[N],bg[N],ed[N],nd0[N][N],lp0[N],q[N],J;\nbool cmp(int x,int y) {return(nd[x][J]<nd[y][J]);}\nint check(int n,int m,int t)\n{\n    int i,j,h,sl=n;\n    for (i=1;i<=n;i++) dn[i]=0;\n    for (i=1;i<=m;i++) lp[i]=lp0[i];\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n     {\n         if (nd0[i][j]) dn[i]++;\n         nd[i][j]=nd0[i][j];\n     }\n\n    for (i=1;i<=t;i++)\n    {\n        int pp=e[i].p,rr=e[i].r;\n        nd[pp][rr]--;lp[rr]--;\n        if (!nd[pp][rr]) dn[pp]--;\n        if (!dn[pp]) {sl--;for (j=1;j<=m;j++) lp[j]+=nd0[pp][j];}\n    }\n    if (!sl) return 1;\n    h=1,t=0;\n    for (j=1;j<=m;j++) ed[j]=0;\n    for (i=1;i<=n;i++)\n    {\n        if (!dn[i]) continue;\n        for (j=1;j<=m;j++) if (nd[i][j]>lp[j]) break;\n        if (j==m+1) {sl--;dn[i]=0;q[++t]=i;continue;}\n        for (j=1;j<=m;j++) if (nd[i][j]) {if (nd[i][j]>lp[j]) a[j][++ed[j]]=i; else {dn[i]--;sl--;if (!dn[i]) q[++t]=i;}}\n    }\n    for (j=1;j<=m;j++) {J=j;bg[j]=1;if (ed[j]) sort(a[j]+1,a[j]+ed[j]+1,cmp);}\n    while (h<=t)\n    {\n        int x=q[h];sl--;if (!sl) return 1;\n        for (j=1;j<=m;j++)\n        {\n            lp[j]+=nd0[x][j]-nd[x][j];\n            for (i=bg[j];i<=ed[j];i++)\n            {\n                 if (nd[a[j][i]][j]>lp[j]) {bg[j]=i;break;}\n                 dn[a[j][i]]--;if (!dn[a[j][i]]) q[++t]=a[j][i];      \n            }\n            if (i==ed[j]+1) bg[j]=i;\n        }\n        h++;\n    }\n    return 0;\n}\nint main()\n{\n //   freopen(\"Z.in\",\"r\",stdin);freopen(\"Z.out\",\"w\",stdout);\n    int i,j,n,m,t;\n    scanf(\"%d%d%d\",&n,&m,&t);\n    for (i=1;i<=m;i++) scanf(\"%d\",&lp0[i]);\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n      scanf(\"%d\",&nd0[i][j]);\n    for (i=1;i<=t;i++) scanf(\"%d%d\",&e[i].p,&e[i].r);\n    if (check(n,m,t)) {printf(\"-1\\n\");return 0;}\n    int l=1,r=t;\n    while (r-l>1)\n    {\n        int mid=(l+r)/2;\n        if (check(n,m,mid)) l=mid; else r=mid;\n    }\n    printf(\"%d\\n\",r);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint p,r,t;\nint L[333];\nint lmp[333];\nint tmp[333][333];\nint n[333][333];\nbool used[333];\nint C[333];\nvector<P> D;\n\nbool isRelease( int id ){\n  for(int i=0;i<r;i++)\n    if( n[id][i] > L[i] ) return false;\n  return true;\n}\n\nbool check(int h){\n\n  for(int i=0;i<r;i++) L[i] = lmp[i];\n  for(int i=0;i<p;i++){\n    C[i] = r;\n    for(int j=0;j<r;j++){\n      n[i][j] = tmp[i][j];\n      if( n[i][j] == 0 ) C[i]--;\n    }\n  }\n  \n  memset( used,0,sizeof( used ));\n  for(int i=0;i<h;i++){\n    if( L[ D[i].second ] == 0 ) return true;\n    L[ D[i].second ]--;    \n    n[ D[i].first ][ D[i].second ]--;\n    assert( n[ D[i].first ][ D[i].second ] >= 0 );    \n    if( n[ D[i].first ][ D[i].second ] == 0 ) C[ D[i].first ]--;\n\n    if( C[ D[i].first ] == 0 ) {\n      used[ D[i].first ] = true;\n      for(int j=0;j<r;j++)\n        L[ j ] += tmp[ D[i].first ][ j ];      \n    }\n  }\n\n  /*\n  cout << \"time : \" <<  h << endl;\n  for(int i=0;i<r;i++) cout << L[i]<< \" \";\n  cout << endl;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<r;j++) cout << n[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n\n  bool loop = true;\n  while( loop ){\n    loop = false;\n    for(int i=0;i<p;i++){\n      if( used[i] ) continue;\n      if( isRelease( i ) ) {\n        for(int j=0;j<r;j++)\n          L[ j ] += tmp[i][j] - n[i][j];\n        used[i] = true;\n        loop = true;\n      }\n    }\n  }\n\n  for(int i=0;i<p;i++)\n    if( !used[i] ) return true;\n  return false;\n  \n}\n\nint main(){\n  cin >> p >> r >> t;\n  D.resize( t );\n  for(int i=0;i<r;i++) {\n    cin >> L[i]; lmp[i] = L[i];\n  }\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++){\n      cin >> n[i][j];\n      tmp[i][j] = n[i][j];\n    }\n  for(int i=0;i<t;i++){\n    cin >> D[i].first >> D[i].second;\n    D[i].first--; D[i].second--;\n  }\n\n  int st = 0, ed = t;\n  int res = -1;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( check( h ) ) {\n      ed = h-1; res = h;\n    } else {\n      st = h+1;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n#define RREP(i, n) for(int i=n-1;i>=0;i--)\n#define RREPS(i, n) for(int i=n;i>0;i--)\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define pb push_back\n#define eb emplace_back\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint n, m, q;\n\nint check(const vector<vi> &req, const vector<vi> &rest, vi ave, int debug = 0){\n\tvi target;\n\tREP(i, n) if(accumulate(ALL(rest[i]), 0)) target.pb(i);\n\trandom_shuffle(ALL(target));\n\twhile(1){\n\t\tint update = false;\n\t\tREP(ii, target.size()){\n\t\t\tint i = target[ii];\n\t\t\tint ok = 1;\n\t\t\tREP(j, m)if(ave[j] < rest[i][j]){\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok){\n//\t\t\t\tif(debug) cout << i << endl;\n\t\t\t\tREP(j, m) ave[j] += req[i][j] - rest[i][j];\n\t\t\t\tswap(target[ii], target.back());\n\t\t\t\ttarget.pop_back();\n\t\t\t\tii --;\n\t\t\t\tupdate = 1;\n\t\t\t}\n\t\t}\n\t\tif(!update) break;\n\t}\n\treturn target.empty();\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tvi res(m);\n\tvector<vi> req(n, vi(m));\n\tREP(i, m) scanf(\"%d\", &res[i]);\n\tREP(i, n)REP(j, m) scanf(\"%d\", &req[i][j]);\n\tvector<pii> query;\n\tREP(i, q){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);a --; b --;\n\t\tquery.eb(a, b);\n\t}\n\tint l = 0, r = q+1; // [0, l): ok, [0, r): NG\n\t\n\tvi checking(m);\n\tiota(ALL(checking), 0);\n\trandom_shuffle(ALL(checking));\n\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tauto rest = req;\n\t\tauto ave = res;\n//\tcout << \"!\" << mid << \",\" << l << \", \" << r << endl;\n//\tREP(i, m) cout << ave[i] << \" \\n\"[i+1 == m];cout << endl;\n\t\tREP(i, mid){\n\t\t\tint a, b;\n\t\t\ttie(a, b) = query[i];\n\t\t\trest[a][b] --;\n\t\t\tave[b] --;\n\t\t\tint f = 1;\n\t\t\tfor(int j : checking){\n\t\t\t\tif(rest[a][j]){\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tfor(int j : checking) ave[j] += req[a][j];\n\t\t\t}\n\t\t}\n//\tREP(i, m) cout << ave[i] << \" \\n\"[i+1 == m];cout << endl;\n//\tREP(i, n)REP(j, m) cout << rest[i][j] << \" \\n\"[j+1 == m];\n//\tcheck(req, rest, ave, 1);\n\t\tif(check(req, rest, ave)) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == q) cout << -1 << endl;\n\telse cout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\nconst int maxN = 333;\nconst int maxO = 2e5 + 100;\nint n, m, t, l[maxN], rec2[maxN];\nint nd[maxN][maxN], rec[maxN][maxN];\nbool li[maxN];\npii ope[maxO];\n\n\nbool deadlock(int w) {\n\tmemcpy(rec, nd, sizeof nd);\n\tmemcpy(rec2, l, sizeof l);\n\tmemset(li, false, sizeof li);\n\tfor (int i = 1; i <= w; ++i) {\n\t\tnd[ope[i].x][ope[i].y]--;\n\t\tl[ope[i].y]--;\n\t}\n\tfor (int p = 1; p <= n; ++p)\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (li[i]) break;\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\tif (l[k] < nd[i][k]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\t\tl[k] += rec[i][k] - nd[i][k];\n\t\t\t\tli[i] = true;\n\t\t\t}\n\t\t}\n\tmemcpy(nd, rec, sizeof rec);\n\tmemcpy(l, rec2, sizeof rec2);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!li[i]) return true;\n\treturn false;\n}\n\nint main() {\n#ifdef lol\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tfor (int i = 1; i <= m; ++i)\n\t\tscanf(\"%d\", &l[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%d\", &nd[i][j]);\n\tfor (int i = 1; i <= t; ++i)\n\t\tscanf(\"%d %d\", &ope[i].x, &ope[i].y);\n\tif (!deadlock(t)) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = 1, r = t;\n\t//for (int i = 1; i <= t; ++i)\n\t//\tprintf(\"%d\", deadlock(i));\n\t//puts(\"\");\n\twhile (l != r) {\n\t//\tprintf(\"%d %d\\n\", l, r);\n\t\tint mid = (l + r) >> 1;\n\t\tif (!deadlock(mid))\n\t\t\tl = mid + 1;\n\t\telse r = mid;\n\t}\n\tprintf(\"%d\\n\", l >= t ? -1 : l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint p,r,t;\nint L[333];\nint lmp[333];\nint tmp[333][333];\nint n[333][333];\nbool used[333];\nint C[333];\nvector<P> D;\n\nbool isRelease( int id ){\n  for(int i=0;i<r;i++)\n    if( n[id][i] > L[i] ) return false;\n  return true;\n}\n\nbool check(int h){\n\n  for(int i=0;i<r;i++) L[i] = lmp[i];\n  for(int i=0;i<p;i++){\n    C[i] = r;\n    for(int j=0;j<r;j++){\n      n[i][j] = tmp[i][j];\n      if( n[i][j] == 0 ) C[i]--;\n    }\n  }\n  \n  for(int i=0;i<h;i++){\n    if( L[ D[i].second ] == 0 ) return true;\n    L[ D[i].second ]--;    \n    n[ D[i].first ][ D[i].second ]--;\n    assert( n[ D[i].first ][ D[i].second ] >= 0 );    \n    if( n[ D[i].first ][ D[i].second ] == 0 ) C[ D[i].first ]--;\n\n    if( C[ D[i].first ] == 0 ) {\n      for(int j=0;j<r;j++)\n        L[ j ] += tmp[ D[i].first ][ j ];      \n    }\n  }\n\n  /*\n  cout << \"time : \" <<  h << endl;\n  for(int i=0;i<r;i++) cout << L[i]<< \" \";\n  cout << endl;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<r;j++) cout << n[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n\n  bool loop = true;\n  memset( used,0,sizeof( used ));\n  while( loop ){\n    loop = false;\n    for(int i=0;i<p;i++){\n      if( used[i] ) continue;\n      if( isRelease( i ) ) {\n        for(int j=0;j<r;j++)\n          L[ j ] += tmp[i][j] - n[i][j];\n        used[i] = true;\n        loop = true;\n      }\n    }\n  }\n\n  for(int i=0;i<p;i++)\n    if( !used[i] ) return true;\n  return false;\n  \n}\n\nint main(){\n  cin >> p >> r >> t;\n  D.resize( t );\n  for(int i=0;i<r;i++) {\n    cin >> L[i]; lmp[i] = L[i];\n  }\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++){\n      cin >> n[i][j];\n      tmp[i][j] = n[i][j];\n    }\n  for(int i=0;i<t;i++){\n    cin >> D[i].first >> D[i].second;\n    D[i].first--; D[i].second--;\n  }\n\n  int st = 0, ed = t;\n  int res = -1;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( check( h ) ) {\n      ed = h-1; res = h;\n    } else {\n      st = h+1;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N=305;\nstruct erz{int p,r;}e[200005];\nint a[N][N],nd[N][N],lp[N],dn[N],bg[N],ed[N],nd0[N][N],lp0[N],q[N],J;\nbool cmp(int x,int y) {return(nd[x][J]<nd[y][J]);}\nint check(int n,int m,int t)\n{\n    int i,j,h,sl=n;\n    for (i=1;i<=n;i++) dn[i]=0;\n    for (i=1;i<=m;i++) lp[i]=lp0[i];\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n     {\n         if (nd0[i][j]) dn[i]++;\n         nd[i][j]=nd0[i][j];\n     }\n\n    for (i=1;i<=t;i++)\n    {\n        int pp=e[i].p,rr=e[i].r;\n        nd[pp][rr]--;lp[rr]--;\n        if (!nd[pp][rr]) dn[pp]--;\n        if (!dn[pp]) sl--;\n    }\n    if (!sl) return 1;\n    h=1,t=0;\n    for (j=1;j<=m;j++) ed[j]=0;\n    for (i=1;i<=n;i++)\n    {\n        if (!dn[i]) continue;\n        for (j=1;j<=m;j++) if (nd[i][j]>lp[j]) break;\n        if (j==m+1) {sl--;dn[i]=0;q[++t]=i;continue;}\n        for (j=1;j<=m;j++) if (nd[i][j]) {if (nd[i][j]>lp[j]) a[j][++ed[j]]=i; else dn[i]--;}\n    }\n    for (j=1;j<=m;j++) {J=j;bg[j]=1;if (ed[j]) sort(a[j]+1,a[j]+ed[j]+1,cmp);}\n    for (i=1;i<=t;i++)\n     for (j=1;j<=m;j++)\n      lp[j]+=nd0[i][j]-nd[i][j];\n    while (h<=t)\n    {\n        int x=q[h];sl--;if (!sl) return 1;\n        for (j=1;j<=m;j++)\n        {\n            lp[j]+=nd0[x][j]-nd[x][j];\n            for (i=bg[j];i<=ed[j];i++)\n            {\n                 if (nd[a[j][i]][j]>lp[j]) {bg[j]=i;break;}\n                 dn[a[j][i]]--;if (!dn[a[j][i]]) q[++t]=a[j][i];      \n            }\n            if (i==ed[j]+1) bg[j]=i;\n        }\n        h++;\n    }\n    return 0;\n}\nint main()\n{\n //   freopen(\"Z.in\",\"r\",stdin);freopen(\"Z.out\",\"w\",stdout);\n    int i,j,n,m,t;\n    scanf(\"%d%d%d\",&n,&m,&t);\n    for (i=1;i<=m;i++) scanf(\"%d\",&lp0[i]);\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n      scanf(\"%d\",&nd0[i][j]);\n    for (i=1;i<=t;i++) scanf(\"%d%d\",&e[i].p,&e[i].r);\n    if (check(n,m,t)) {printf(\"-1\\n\");return 0;}\n    int l=1,r=t;\n    while (r-l>1)\n    {\n        int mid=(l+r)/2;\n        if (check(n,m,mid)) l=mid; else r=mid;\n    }\n    printf(\"%d\\n\",r);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    bool check_terminated(vector<int> &need) {\n        bool terminated = true;\n        rep(r, R) terminated &= need[r] == 0;\n        return terminated;\n    }\n    \n    bool is_avoidable(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left = L;\n\n        vector<bool> terminated(P);\n        int terminated_num = 0;\n\n        // simulation\n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n            if(left[r] < 0) {\n                return false; // lack of resource !\n            }\n            if(need[p][r] == 0) {\n                assert(not terminated[p]);\n                if(check_terminated(need[p])) {\n                    rep(r2, R) left[r2] += N[p][r2] - need[p][r2];\n                    terminated[p] = true;\n                    terminated_num++;                            \n                }\n            }\n        }            \n        // greedy\n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) terminatable &= need[p][r] <= left[r];\n                if(terminatable) {\n                    rep(r, R) left[r] += N[p][r] - need[p][r];\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = -1, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int p,r,t;\n    cin>>p>>r>>t;\n    vector<int> l(r);\n    for(int i=0;i<r;i++) cin>>l[i];\n    vector<vector<int>> n(p,vector<int>(r));\n    for(int i=0;i<p;i++)for(int j=0;j<r;j++) cin>>n[i][j];\n\n    vector<int> pv(t),rv(t);\n    for(int i=0;i<t;i++) cin>>pv[i]>>rv[i],pv[i]--,rv[i]--;\n    int lb=0,ub=t+1;\n    \n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        auto rest=l;\n        auto tmpn=n;\n        for(int i=0;i<mid;i++){\n            if(rest[rv[i]]){\n                rest[rv[i]]--;\n                tmpn[pv[i]][rv[i]]--;\n                if(count(tmpn[pv[i]].begin(),tmpn[pv[i]].end(),0)==r){\n                    tmpn[pv[i]]=n[pv[i]];\n                    for(int j=0;j<r;j++) rest[j]+=n[pv[i]][j];\n                }\n            }\n        }\n        vector<int> used(p);\n        int cnt=0;\n        for(int loop=0;loop<p;loop++){\n            for(int i=0;i<p;i++){\n                if(used[i]) continue;\n                bool isdead=false;\n                for(int j=0;j<r;j++){\n                    isdead=(isdead || rest[j]<tmpn[i][j]);\n                }\n                if(!isdead){\n                    cnt++;\n                    for(int j=0;j<r;j++){\n                        rest[j]+=n[i][j]-tmpn[i][j];\n                    }\n                    used[i]=true;\n                    break;\n                }                \n            }\n        }\n        if(cnt==p){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    if(ub==t+1){\n        cout<<-1<<endl;\n    }\n    else{\n        cout<<lb+1<<endl;\n    }\n\n\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N=305;\nstruct erz{int p,r;}e[200005];\nint a[N][N],nd[N][N],lp[N],dn[N],bg[N],ed[N],nd0[N][N],lp0[N],q[N],J;\nbool cmp(int x,int y) {return(nd[x][J]<nd[y][J]);}\nint check(int n,int m,int t0)\n{\n    int i,j,h=1,t=0,sl=n;\n    for (i=1;i<=n;i++) dn[i]=0;\n    for (i=1;i<=m;i++) lp[i]=lp0[i];\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n     {\n         if (nd0[i][j]) dn[i]++;\n         nd[i][j]=nd0[i][j];\n     }\n\n    for (i=1;i<=t0;i++)\n    {\n        int pp=e[i].p,rr=e[i].r;\n        nd[pp][rr]--;lp[rr]--;\n        if (!nd[pp][rr]) dn[pp]--;\n        if (!dn[pp]) {sl--;q[++t]=pp;}\n    }\n    if (!sl) return 1;\n    \n    for (j=1;j<=m;j++) ed[j]=0;\n    for (i=1;i<=n;i++)\n    {\n        if (!dn[i]) continue;\n        for (j=1;j<=m;j++) if (nd[i][j]>lp[j]) break;\n        if (j==m+1) {sl--;dn[i]=0;q[++t]=i;continue;}\n        for (j=1;j<=m;j++) if (nd[i][j]) {if (nd[i][j]>lp[j]) a[j][++ed[j]]=i; else dn[i]--;}\n    }\n    for (j=1;j<=m;j++) {J=j;bg[j]=1;if (ed[j]) sort(a[j]+1,a[j]+ed[j]+1,cmp);}\n    for (i=1;i<=t;i++)\n     for (j=1;j<=m;j++)\n      lp[j]+=nd0[q[i]][j]-nd[q[i]][j];\n    while (h<=t)\n    {\n        int x=q[h];\n        for (j=1;j<=m;j++)\n        {\n            lp[j]+=nd0[x][j]-nd[x][j];\n            for (i=bg[j];i<=ed[j];i++)\n            {\n                 if (nd[a[j][i]][j]>lp[j]) break;\n                 dn[a[j][i]]--;if (!dn[a[j][i]]) {q[++t]=a[j][i];sl--;if (!sl) return 1;}\n            }\n            bg[j]=i;\n        }\n        h++;\n    }\n    return 0;\n}\nint main()\n{\n   // freopen(\"Z.in\",\"r\",stdin);freopen(\"Z.out\",\"w\",stdout);\n    int i,j,n,m,t;\n    scanf(\"%d%d%d\",&n,&m,&t);\n    for (i=1;i<=m;i++) scanf(\"%d\",&lp0[i]);\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n      scanf(\"%d\",&nd0[i][j]);\n    for (i=1;i<=t;i++) scanf(\"%d%d\",&e[i].p,&e[i].r);\n    if (check(n,m,t)) {printf(\"-1\\n\");return 0;}\n    int l=1,r=t;\n    while (r-l>1)\n    {\n        int mid=(l+r)/2;\n        if (check(n,m,mid)) l=mid; else r=mid;\n    }\n    printf(\"%d\\n\",r);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nconst int MAXN = 305;\nconst int MAXT = 200005;\n\nint n, m, t, c[MAXN][MAXN], l[MAXN], p[MAXT], r[MAXT];\n\nbool check(int mid) {\n    vector<int> ins(m), cntSat(n, 0), pos(m, 0);\n    vector<vector<int> > req(n, vector<int>(m));\n    vector<vector<pii> > ord(m, vector<pii>());\n\n//    debug(mid);\n    fto(j, 0, m-1) {\n        ins[j] = l[j];\n        fto(i, 0, n-1)\n            req[i][j] = c[i][j];\n    }\n\n    int cntFinish = 0;\n    fto(i, 1, mid) {\n        --ins[r[i]];\n        --req[p[i]][r[i]];\n    }\n\n    fto(i, 0, n-1) {\n        bool term = true;\n        fto(j, 0, m-1)\n            if (req[i][j] > 0)\n                term = false;\n        if (term) {\n            ++cntFinish;\n            fto(j, 0, m-1)\n                ins[j] += c[i][j];\n        } else {\n            fto(j, 0, m-1)\n                ord[j].pb({req[i][j], i});\n        }\n    }\n\n    fto(j, 0, m-1)\n        sort(ord[j].begin(), ord[j].end());\n\n//    fto(i, 0, n-1) {\n//        fto(j, 0, m-1) printf(\"%d \", req[i][j]);\n//        puts(\"\");\n//    }\n//    fto(i, 0, m-1) printf(\"%d \", ins[i]);\n//    puts(\"\");\n//\n//    fto(j, 0, m-1) {\n//        for(pii p: ord[j]) printf(\"%d %d %d\\n\", j, p.ff, p.ss);\n//    }\n\n    queue<int> q;\n    fto(j, 0, m-1) {\n        int &i = pos[j];\n        while (i < sz(ord[j]) && ord[j][i].ff <= ins[j]) {\n            int id = ord[j][i].ss;\n            ++cntSat[id];\n            if (cntSat[id] == m)\n                q.push(id);\n            ++i;\n        }\n    }\n\n//    fto(i, 0, n-1) printf(\"%d \", cntSat[i]);\n//    puts(\"\");\n\n    while (!q.empty()) {\n        int i = q.front(); q.pop();\n        ++cntFinish;\n        fto(j, 0, m-1) {\n            ins[j] += c[i][j] - req[i][j];\n            int &i = pos[j];\n            while (i < sz(ord[j]) && ord[j][i].ff <= ins[j]) {\n                int id = ord[j][i].ss;\n                ++cntSat[id];\n                if (cntSat[id] == m)\n                    q.push(id);\n                ++i;\n            }\n        }\n    }\n\n    return (cntFinish == n);\n}\n\nint main () {\n    scanf(\"%d%d%d\", &n, &m, &t);\n    fto(i, 0, m-1) scanf(\"%d\", &l[i]);\n    fto(i, 0, n-1)\n        fto(j, 0, m-1)\n            scanf(\"%d\", &c[i][j]);\n    fto(i, 1, t) {\n        scanf(\"%d%d\", &p[i], &r[i]);\n        --p[i]; --r[i];\n    }\n\n    check(0);\n//    debug(maxFinish);\n\n    int lo = 1, hi = t, res = -1;\n    while (lo <= hi) {\n        int mid = (lo+hi)/2;\n//        debug(mid);\n        if (!check(mid)) {\n            res = mid;\n            hi = mid-1;\n        } else lo = mid+1;\n    }\n\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n\nint p, r, t;\nint L[320], tL[320], R[302][302], tR[302][302];\nint P[200020][2];\nint End[320];\n\nbool is_dead(int tim){\n\trep(i, p)End[i] = 0;\n\trep(i, p){\n\t\trep(j, r)tR[i][j] = R[i][j];\n\t}\n\trep(i, r)tL[i] = L[i];\n\t\n\tfor(int i=0;i<tim;i++){\n\t\tint x = P[i][0], y = P[i][1];\n\t\ttR[x][y]--, tL[y]--;\n\t}\n\trep(i, p){\n\t\tint c = 0;\n\t\tfor(c=0;c<r;c++)if(tR[i][c] != 0)break;\n\t\t\n\t\tif(c == r){\n\t\t\trep(j, r)tL[j] += R[i][j];\n\t\t\tEnd[i] = 1;\n\t\t}\n\t}\n\t\n\t\n\twhile(1){\n\t\tint changed = 0;\n\t\trep(i, p){\n\t\t\tif(End[i])continue;\n\t\t\tint c;\n\t\t\tfor(c=0;c<r;c++)if(tL[c] < tR[i][c])break;\n\t\t\t\n\t\t\tif(c == r){\n\t\t\t\trep(j, r){\n\t\t\t\t\ttL[j] += R[i][j] - tR[i][j];\n\t\t\t\t}\n\t\t\t\tEnd[i] = 1;\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t}\n\t\tif(changed == 0)break;\n\t}\n\t\n\t//rep(i, p)printf(\"%d\", End[i]);\n\t\n\tbool res = 0;\n\trep(i, p)res |= !End[i];\n\treturn res;\n}\n\nvoid solve(int tc){\n\tscanf(\"%d%d%d\", &p, &r, &t);\n\tfor(int i=0;i<r;i++)scanf(\"%d\", L+i);\n\tfor(int i=0;i<p;i++){\n\t\tfor(int j=0;j<r;j++)scanf(\"%d\", R[i]+j);\n\t}\n\tfor(int i=0;i<t;i++)scanf(\"%d%d\", P[i], P[i]+1);\n\tfor(int i=0;i<t;i++)P[i][0]--, P[i][1]--;\n\t\n\tint low = 1, high = t, ans = -1;\n\twhile(low <= high){\n\t\tint mid = (low + high) / 2;\n\t\tif(is_dead(mid))ans = mid, high = mid - 1;\n\t\telse low = mid + 1;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1;// scanf(\"%d\",&Tc);\n\tfor(int i=1;i<=Tc;i++){\n\t\tsolve(i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\n\nvoid solve() {\n\tint p, r, t; cin >> p >> r >> t;\n\tvector<int> l(r);\n\trep(i, r)cin >> l[i];\n\tvector<vector<int>> n(p);\n\trep(i, p) {\n\t\tn[i].resize(r);\n\t\trep(j, r)cin >> n[i][j];\n\t}\n\tvector<P> v(t);\n\trep(i, t) {\n\t\tcin >> v[i].first >> v[i].second; v[i].first--; v[i].second--;\n\t}\n\tint le = 0, ri = t + 1;\n\twhile (ri - le > 1) {\n\t\tint m = (le + ri) / 2;\n\t\tvector<vector<int>> c(p);\n\t\trep(i, p) {\n\t\t\tc[i].resize(r, 0);\n\t\t}\n\t\tvector<int> rest = l;\n\t\trep(i, m) {\n\t\t\tc[v[i].first][v[i].second]++;\n\t\t\trest[v[i].second]--;\n\t\t}\n\t\trep(i, p) {\n\t\t\tint d = mod;\n\t\t\trep(j, r) {\n\t\t\t\tif (n[i][j] == 0)continue;\n\t\t\t\td = min(d, c[i][j] / n[i][j]);\n\t\t\t}\n\t\t\tif (d > 0) {\n\t\t\t\trep(j, r) {\n\t\t\t\t\tc[i][j] -= d * n[i][j];\n\t\t\t\t\trest[j] += d * n[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> num(p, 0);\n\t\tvector<vector<P>> v(r);\n\t\trep(i, p) {\n\t\t\tbool exi1 = false;\n\t\t\trep(j, r) {\n\t\t\t\tif (c[i][j] > 0)exi1 = true;\n\t\t\t}\n\t\t\tif (!exi1) {\n\t\t\t\tnum[i] = r; continue;\n\t\t\t}\n\t\t\trep(j, r) {\n\t\t\t\tif (n[i][j] == c[i][j]) {\n\t\t\t\t\tnum[i]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[j].push_back({ n[i][j] - c[i][j],i });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, r)sort(v[j].begin(), v[j].end());\n\t\tvector<int> lid(r, 0);\n\t\twhile (true) {\n\t\t\tvector<int> nex;\n\t\t\trep(j, r) {\n\t\t\t\twhile (lid[j] < v[j].size() && v[j][lid[j]].first <= rest[j]) {\n\t\t\t\t\tnum[v[j][lid[j]].second]++;\n\t\t\t\t\tif (num[v[j][lid[j]].second] == r) {\n\t\t\t\t\t\tnex.push_back(v[j][lid[j]].second);\n\t\t\t\t\t}\n\t\t\t\t\tlid[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nex.empty())break;\n\t\t\trep(i, nex.size()) {\n\t\t\t\trep(j, r) {\n\t\t\t\t\trest[j] += c[nex[i]][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = true;\n\t\trep(j, p) {\n\t\t\tif (num[j] != r)f = false;\n\t\t}\n\t\t//cout << m << \" \" << f << endl;\n\t\tif (f) {\n\t\t\tle = m;\n\t\t}\n\t\telse {\n\t\t\tri = m;\n\t\t}\n\t}\n\tif (ri == t + 1)ri = -1;\n\tcout << ri << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint p,r,T;\nint N[300][300];\nvector<int> L,P,R;\n\nbool isAvoidable(int t){\n    int H[p][r];\n    fill(H[0],H[p],0);\n    vector<int> LL=L;\n    for(int i=0;i<t;i++){\n        H[P[i]][R[i]]++;\n        LL[R[i]]--;\n    }\n    vector<int> satisfied(p);\n    for(int i=0;i<p;i++){\n        satisfied[i]=true;\n        for(int j=0;j<r;j++){\n            if(N[i][j]!=H[i][j]){\n                satisfied[i]=false;\n                break;\n            }\n        }\n        if(satisfied[i]){\n            for(int j=0;j<r;j++){\n                LL[j]+=H[i][j];\n            }\n        }\n    }\n    bool updated=true;\n    while(updated){\n        updated=false;\n        for(int i=0;i<p;i++){\n            if(satisfied[i]) continue;\n            bool satisfiable=true;\n            for(int j=0;j<r;j++){\n                if(H[i][j]+LL[j]<N[i][j]){\n                    satisfiable=false;\n                    break;\n                }\n            }\n            if(satisfiable){\n                satisfied[i]=true;\n                for(int j=0;j<r;j++){\n                    LL[j]+=H[i][j];\n                }\n                updated=true;\n            }\n        }\n    }\n    bool ret = true;\n    for(int i=0;i<p;i++){\n        if(!satisfied[i]){\n            ret=false;\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin>>p>>r>>T;\n    L.resize(r);\n    for(int i=0;i<r;i++) cin>>L[i];\n    for(int i=0;i<p;i++){\n        for(int j=0;j<r;j++){\n            cin>>N[i][j];\n        }\n    }\n    P.resize(T); R.resize(T);\n    for(int i=0;i<T;i++){\n        cin>>P[i]>>R[i];\n        P[i]--; R[i]--;\n    }\n    if(!isAvoidable(0)){\n        cout<<0<<endl;\n        return 0;\n    }\n    if(isAvoidable(T)){\n        cout<<-1<<endl;\n        return 0;\n    }\n    int lo=0,up=T;\n    while(up-lo>=2){\n        int mid = (lo+up)/2;\n        if(isAvoidable(mid)){\n            lo=mid;\n        }else{\n            up=mid;\n        }\n    }\n    cout<<up<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint P, R, T;\n\nint res[300];\nint need[300][300];\nint rlog[200000][2];\n\nbool check(int t){\n\tint state[300][300];\n\tfor(int i = 0; i < P; i++){\n\t\tfor(int j = 0; j < R; j++){\n\t\t\tstate[i][j] = 0;\n\t\t}\n\t}\n\tint curres[300];\n\tfor(int i = 0; i < R; i++){\n\t\tcurres[i] = res[i];\n\t}\n\n\tfor(int i = 0; i < t; i++){\n\t\tint p = rlog[i][0];\n\t\tint r = rlog[i][1];\n\t\tstate[p][r]++;\n\t\tcurres[r]--;\n\t\tif(state[p][r] == need[p][r]){\n\t\t\tbool flg = true;\n\t\t\tfor(int j = 0; j < R; j++){\n\t\t\t\tif(state[p][j] < need[p][j]){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tfor(int j = 0; j < R; j++){\n\t\t\t\t\tcurres[j] += state[p][j];\n\t\t\t\t\tstate[p][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool fin[300];\n\tfor(int i = 0; i < P; i++){\n\t\tfin[i] = false;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t\tflg = false;\n\t\tfor(int i = 0; i < P; i++){\n\t\t\tif(!fin[i]){\n\t\t\t\tbool f2 = true;;\n\t\t\t\tfor(int j = 0; j < R; j++){\n\t\t\t\t\tif(need[i][j] - state[i][j] > curres[j]){\n\t\t\t\t\t\tf2 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f2){\n\t\t\t\t\tfor(int j = 0; j < R; j++){\n\t\t\t\t\t\tcurres[j] += state[i][j];\n\t\t\t\t\t\tstate[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfin[i] = true;\n\t\t\t\t\tflg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < P; i++){\n\t\tif(!fin[i]) return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tcin >> P >> R >> T;\n\tfor(int i = 0; i < R; i++){\n\t\tcin >> res[i];\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tfor(int j = 0; j < R; j++){\n\t\t\tcin >> need[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < T; i++){\n\t\tcin >> rlog[i][0] >> rlog[i][1];\n\t\trlog[i][0]--;\n\t\trlog[i][1]--;\n\t}\n\n\t\n\tint l = 0;\n\tint r = T + 2;\n\twhile(r - l > 1){\n\t\tint m = (l + r) / 2;\n\t\tif(check(m)){\n\t\t\tl = m;\n\t\t}else{\n\t\t\tr = m;\n\t\t}\n\t}\n\tif(l > T){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << (l+1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint main(){\n    iostream_init();\n    int P, R, K;\n    while(cin >> P >> R >> K) {\n        vector<int> all(R);\n        vector<vector<int>> need_(P, vector<int>(R, 0));\n\n        REP(i, R) cin >> all[i];\n        REP(i, P) REP(j, R) cin >> need_[i][j];\n\n        vector<int> X(K);\n        vector<int> Y(K);\n        REP(i, K) cin >> X[i] >> Y[i];\n        REP(i, K) X[i]--;\n        REP(i, K) Y[i]--;\n\n        auto zero = [&]() {\n            REP(i, P) {\n                REP(j, R) if(need_[i][j] > all[j]) return true;\n            }\n            return false;\n        };\n        assert(!zero());\n\n        auto check = [&](int T) {\n            vector<int> cur = all;\n            vector<vector<int>> need = need_;\n            vector<vector<int>> take(P, vector<int>(R, 0));\n            vector<int> have(P);\n            vector<int> rest(P);\n            REP(i, P) REP(j, R) rest[i] += need[i][j];\n\n            REP(i, T) {\n                cur[ Y[i] ]--;\n                need[ X[i] ][ Y[i] ]--;\n                take[ X[i] ][ Y[i] ]++;\n                have[ X[i] ]++;\n                if(--rest[X[i]] == 0) {\n                    have[X[i]] = 0;\n                    REP(j, R) {\n                        cur[j] += take[ X[i] ][j];\n                    }\n                }\n            }\n\n            while(true) {\n                bool updated = false;\n                REP(i, P) if(have[i] > 0) {\n                    bool ok = true;\n                    REP(j, R) if(need[i][j] > cur[j]){ ok = false; break; }\n                    if(ok) {\n                        updated = true;\n                        have[i] = 0;\n                        REP(j, R) cur[j] += take[i][j];\n                    }\n                }\n                if(!updated) break;\n            }\n\n            REP(i, P) if(have[i]) return false;\n            return true;\n        };\n\n        if(check(K)) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        int lb = 0, ub = K + 1;\n        // [lb, ub)\n        while(ub - lb > 1) {\n            int T = (lb + ub) / 2;\n            if(check(T)) {\n                lb = T;\n            } else {\n                ub = T;\n            }\n        }\n\n        assert(lb != K);\n\n        cout << ub << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\ntypedef long long ll;\n\nint p,r,t;\nint l[353];\nint n[353][353];\nint nsum[353];\nint P[252521], R[252521];\n\nint l2[353], n2[353][353];\nint nsum2[353];\n\nint main(){\n  scanf(\"%d%d%d\",&p,&r,&t);\n  REP(i,r)scanf(\"%d\",l+i);\n  REP(i,p)REP(j,r)scanf(\"%d\",&n[i][j]);\n  REP(i,t)scanf(\"%d%d\",P+i,R+i);\n  REP(i,p){\n    nsum[i] = 0;\n    REP(j,r)nsum[i] += n[i][j];\n  }\n  REP(i,t)P[i]--, R[i]--;\n  int low = -1, high = t+1;\n  while(low+1 < high){\n    int x = (low+high)/2;\n    REP(i,r)l2[i] = l[i];\n    REP(i,p)REP(j,r)n2[i][j] = n[i][j];\n    REP(i,p)nsum2[i] = nsum[i];\n    REP(i,x){\n      l2[R[i]]--;\n      n2[P[i]][R[i]]--;\n      nsum2[P[i]]--;\n      if(nsum2[P[i]] == 0){\n        REP(j,r){\n          l2[j] += n[P[i]][j];\n          n2[P[i]][j] = n[P[i]][j];\n        }\n        nsum2[P[i]] = nsum[P[i]];\n      }\n    }\n    vector<bool> avoided(p, false);\n    int cnt = 0;\n    REP(_,p)REP(i,p)if(!avoided[i]){\n      bool ok = true;\n      REP(j,r)if(n2[i][j] > l2[j])ok=false;\n      if(ok){\n        REP(j,r)l2[j] += (n[i][j]-n2[i][j]);\n        avoided[i] = true;\n        cnt++;\n      }\n    }\n    if(cnt == p){\n      low = x;\n    }else{\n      high = x;\n    }\n  }\n  printf(\"%d\\n\", high);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ms(x,y) memset(x,y,sizeof(x))\nusing namespace std;\nconst int N=305;\nconst int T=200005;\n\n\nint pn,rn,tn;\nint tp[T],tr[T];\nbool ter[N];\nint untercnt=0;\nint res[N],need[N][N],req[N][N];\nint tmpres[N],tmpneed[N][N];\nbool tmpter[N];\n\nbool terminate(int pi) {\n\tfor(int j=1;j<=rn;j++)\n\t\tif(need[pi][j])return false;\n\treturn true;\n}\n\nbool canter(int pi) {\n\tfor(int j=1;j<=rn;j++)\n\t\tif(tmpneed[pi][j]>tmpres[j])return false;\n\treturn true;\n}\nqueue<int> q;\nbool check() {\n\tmemcpy(tmpres,res,sizeof(res));\n\tmemcpy(tmpneed,need,sizeof(need));\n\tmemcpy(tmpter,ter,sizeof(ter));\n\t\n\tint cnt=0;\n\twhile(!q.empty())q.pop();\n\tfor(int i=1;i<=pn;i++) \n\t\tif(!tmpter[i])\n\t\t\tif(canter(i))\n\t\t\t\tq.push(i);\n\twhile(!q.empty()) {\n\t\twhile(!q.empty()){\n\t\t\tint now=q.front();\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\ttmpter[now]=true;\n\t\t\tfor(int j=1;j<=rn;j++)\n\t\t\t\ttmpres[j]+=req[now][j];\n\t\t}\n\t\tfor(int i=1;i<=pn;i++) \n\t\t\tif(!tmpter[i])\n\t\t\t\tif(canter(i))\n\t\t\t\t\tq.push(i);\n\t}\n\tif(cnt<untercnt)return false;\n\treturn true;\n}\n\nvoid goup(int now,int tt) {\n\tfor(int t=now;t>tt;t--){\n\t\tif(ter[tp[t]])continue;\n\t\tres[tr[t]]++;\n\t\tneed[tp[t]][tr[t]]++;\n\t}\n}\nvoid godown(int now,int tt){\n\tfor(int t=now+1;t<=tt;t++) {\n\t\tif(ter[tp[t]])continue;\n\t\tres[tr[t]]--;\n\t\tneed[tp[t]][tr[t]]--;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&pn,&rn,&tn);\n\tuntercnt=pn;\n\tfor(int i=1;i<=rn;i++)\n\t\tscanf(\"%d\",&res[i]);\n\tfor(int i=1;i<=pn;i++)\n\t\tfor(int j=1;j<=rn;j++) {\n\t\t\tscanf(\"%d\",&req[i][j]);\n\t\t\tif(req[i][j]>res[j]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tneed[i][j]=req[i][j];\n\t\t}\n\tms(ter,0);\n\tfor(int i=1;i<=tn;i++){\n\t\tscanf(\"%d%d\",&tp[i],&tr[i]);\n\t\tneed[tp[i]][tr[i]]--;\n\t\tres[tr[i]]--;\t\t\n\t\tif(terminate(tp[i])){\n\t\t\tter[tp[i]]=true;\n\t\t\tuntercnt--;\n\t\t\tfor(int j=1;j<=rn;j++)\n\t\t\t\tres[j]+=req[tp[i]][j];\n\t\t}\n\t}\n\tif(check()){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint l=0,r=tn,now=tn;\n\twhile(l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif(mid<now) goup(now,mid);\n\t\telse if(mid>now) godown(now,mid);\n\t\tnow=mid;\n\t\tif(check())\n\t\t\tl=mid+1;\n\t\telse\n\t\t\tr=mid;\n\t}\n\tprintf(\"%d\\n\",l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n \n\nsigned main(){\n\n  int p,r,t;\n  cin>>p>>r>>t;\n  \n  vector<int> LL(r);\n  for(int i=0;i<r;i++) cin>>LL[i];\n\n  vector<vector<int> > n(p,vector<int> (r));\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++) cin>>n[i][j];\n\n\n  vector<int> P(t),R(t);\n  for(int i=0;i<t;i++) cin>>P[i]>>R[i], P[i]--,R[i]--;\n  \n  \n  auto deadLock=[&](int x){\n    vector<int> L = LL;\n    vector<queue <int> > Q(r);\n    vector<vector<int> > cnt(p,vector<int> (r,0));\n    \n    auto ok = [&](int p){\n      for(int i=0;i<r;i++) if(n[p][i] != cnt[p][i]) return 0;\n      return 1;\n    };\n\n    auto freeL = [&](int p){\n      for(int i=0;i<r;i++) L[i] += cnt[p][i], cnt[p][i] = 0;\n    };\n    \n    auto use =[&](){\n      int res = 0;\n      for(int i=0;i<r;i++){\n\tif(Q[i].empty()) continue;\n\tif(L[i] == 0) continue;\n\tint process = Q[i].front(); Q[i].pop();\n\tL[i]--, cnt[process][i]++;\n\tif(!ok(process)) continue;\n\tfreeL(process);\n\tres = 1;\n      }\n      return res;\n    };\n    \n    for(int i=0;i<x;i++){\n      int pi = P[i];\n      int ri = R[i];\n      Q[ri].push(pi);\n      while(use());\n    }\n    \n    auto sum=[&](int p){\n      int res = 0;\n      for(int i=0;i<r;i++) res += cnt[p][i];\n      return res;\n    };\n\n    auto canFree=[&](int p){\n      for(int i=0;i<r;i++) if(n[p][i] - cnt[p][i] > L[i]) return 0;\n      return 1;\n    };\n\n    int update = 1;\n    while(update){\n      update = 0;\n      for(int i=0;i<p;i++){ //process\n\tif(sum(i) == 0) {continue;}\n\tif(!canFree(i)) continue;\n\tupdate = 1;\n\tfreeL(i);\n\twhile(use());\n      }\n    }\n\n    for(int i=0;i<p;i++) if(sum(i)) return 1;   \n    for(int i=0;i<r;i++) if(!Q[i].empty()) return 1;\n    return 0;\n  };\n\n  \n  int ans = -1;\n  {\n    int L = 1, R = t+1;\n    while(L+1<R){\n      int M = (L+R)/2;\n      if(deadLock(M)) R = M;\n      else L = M;\n    }\n    ans = R;\n    if(R == t+1) ans = -1;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define  fr(i,x,y) for(i=x;i<=y;i++)\n#define  frd(i,x,y) for(i=x;i>=y;i--)\nconst int maxn=310;\nconst int maxm=(int)2e5+10;\nint n,m,T,p;\nint have[maxn],a[maxn];\nint want[maxn][maxn],ori[maxn][maxn];\nint list[maxm][2];\nbool used[maxn];\nvoid Read()\n{\t\n\tint i,j;\n\tscanf(\"%d%d%d\",&n,&m,&T);\n\tfr(j,1,m)scanf(\"%d\",&have[j]);\n\tfr(i,1,n)\n\tfr(j,1,m)\n\t\tscanf(\"%d\",&want[i][j]),ori[i][j]=want[i][j];\n\tfr(i,1,T)scanf(\"%d%d\",&list[i][0],&list[i][1]);\n}\nvoid Go_up(int low,int high)\n{\n\tint i,p,r;\n\tfr(i,low+1,high)\n\t{\n\t\tp=list[i][0],r=list[i][1];\n\t\thave[r]--;\n\t\twant[p][r]--;\n\t}\n}\nvoid Go_down(int high,int low)\n{\n\tint i,p,r;\n\tfrd(i,high,low+1)\n\t{\n\t\tp=list[i][0],r=list[i][1];\n\t\thave[r]++;\n\t\twant[p][r]++;\n\t}\n}\nbool Check()\n{\n\tint i,j,cnt;\n\tbool bo;\n\tmemcpy(a+1,have+1,m*sizeof(int));\n\tcnt=0;\n\tbo=true;\n\tmemset(used+1,false,n*sizeof(bool));\n\twhile(bo)\n\t{\n\t\tbo=false;\n\t\tfr(i,1,n)if(!used[i])\n\t\t{\n\t\t\tfr(j,1,m)if(want[i][j]>a[j])break;\n\t\t\tif(j<=m)continue;\n\t\t\tcnt++;\n\t\t\tfr(j,1,m)a[j]+=ori[i][j]-want[i][j];\n\t\t\tbo=true;\n\t\t\tused[i]=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn cnt==n;\n}\nvoid Solve()\n{\n\tint le,ri,mi;\n\tle=1,ri=T;\n\tp=0;\n\twhile(le<=ri)\n\t{\n\t\tmi=(le+ri)>>1;\n\t\tif(mi>p)Go_up(p,mi);\n\t\telse Go_down(p,mi);\n\t\tp=mi;\n\t\tif(Check())le=mi+1;\n\t\telse ri=mi-1;\n\t}\n\tif(le>T)le=-1;\n\tprintf(\"%d\\n\",le);\n}\nint main()\n{\n\tRead();\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nint p, r, t;\nint l[310], nl[310];\nint n[310][310], nn[310][310];\npii a[200010];\nint cnt[310];\n\nbool check(int mid){\n\tfor (int i = 1; i <= r; i++){\n\t\tnl[i] = l[i];\n\t}\n\tfor (int i = 1; i <= p; i++){\n\t\tcnt[i] = 0;\n\t\tfor (int j = 1; j <= r; j++){\n\t\t\tnn[i][j] = n[i][j], cnt[i] += n[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i <= mid; i++){\n\t\tint P = a[i].fi, R = a[i].se;\n\t\tnl[R]--, nn[P][R]--, cnt[P]--;\n\t\tif (cnt[P] == 0){\n\t\t\tfor (int j = 1; j <= r; j++){\n\t\t\t\tnl[j] += n[P][j];\n\t\t\t}\n\t\t}\n\t}\n\tint pd = 1;\n\twhile (pd){\n\t\tpd = 0;\n\t\tfor (int i = 1; i <= p; i++){\n\t\t\tint flag = 1, ppp = 1;\n\t\t\tfor (int j = 1; j <= r; j++){\n\t\t\t\tif (nl[j] < nn[i][j]){\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nn[i][j]) ppp = 0;\n\t\t\t}\n\t\t\tif (!flag || ppp) continue;\n\t\t\tfor (int j = 1; j <= r; j++){\n\t\t\t\tnl[j] += n[i][j] - nn[i][j];\n\t\t\t\tnn[i][j] = 0;\n\t\t\t}\n\t\t\tpd = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= p; i++){\n\t\tfor (int j = 1; j <= r; j++){\n\t\t\tif (nn[i][j]) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &p, &r, &t);\n\tfor (int i = 1; i <= r; i++){\n\t\tscanf(\"%d\", &l[i]);\n\t}\n\tfor (int i = 1; i <= p; i++){\n\t\tfor (int j = 1; j <= r; j++){\n\t\t\tscanf(\"%d\", &n[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < t; i++){\n\t\tscanf(\"%d%d\", &a[i].fi, &a[i].se);\n\t}\n\tif (!check(t - 1)){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint l = 0, r = t - 1;\n\twhile (l < r){\n\t\tint mid = l + r >> 1;\n\t\tif (!check(mid)) l = mid + 1;\n\t\telse r = mid;\n\t}\n\tprintf(\"%d\\n\", l + 1);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:2\n*Problem:Deadlock Detection\n*Date:2019-7-5\n*Algorithm:Binary Search\n*Stats:AC-Aizu1361*/\n\nbool debug=false;\n\nint n,m;\nint need[305][305];\nint r[305];\n\npii op[200005];\nint t;\n\nint tneed[305][305];\nint tr[305];\n\nint zero[305];\n\nbool run[305];\n\nvoid recover(int pid){\n\tfor(int i=0;i<m;i++){\n\t\ttr[i]+=need[pid][i]-tneed[pid][i];\n\t\ttneed[pid][i]=need[pid][i];\n\t}\n}\n\nbool ok(int mid){\n////\tcout<<\"checking\"<<mid<<endl;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\ttneed[i][j]=need[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\ttr[i]=r[i];\n\t}\n\tmemset(zero,0,sizeof(zero));\n\tmemset(run,0,sizeof(run));\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(tneed[i][j]==0){\n\t\t\t\tzero[i]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n//\tcout<<\"ptp\"<<endl;\n\t\n\tfor(int i=0;i<=mid;i++){\n\t\ttr[op[i].second]--;\n\t\ttneed[op[i].first][op[i].second]--;\n\t\trun[op[i].first]=true;\n\t\tif(tneed[op[i].first][op[i].second]==0){\n\t\t\tzero[op[i].first]++;\n\t\t}\n\t\tif(zero[op[i].first]==m){\n\t\t\trun[op[i].first]=false;\n\t\t\tzero[op[i].first]=0;\n\t\t\trecover(op[i].first);\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(tneed[op[i].first][j]==0){\n\t\t\t\t\tzero[op[i].first]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n//\tcout<<\"ptp 2\"<<endl;\n//\tfor(int i=0;i<n;i++){\n//\t\tfor(int j=0;j<m;j++){\n//\t\t\tcout<<tneed[i][j]<<' ';\n//\t\t}\n//\t\tcout<<endl;\n//\t}\t\n//\tcout<<endl;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(!run[j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//check it\n\t\t\tbool ok=true;\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\tif(tr[k]<tneed[j][k]){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\trecover(j);\n\t\t\t\trun[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\t\n//\tcout<<\"ptp 3\"<<endl;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(run[i]){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(int argc,char* argv[]){\n//\tfreopen(\"test.txt\",\"r\",stdin);\n\tqi;\n\tcin>>n>>m>>t;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>r[i];\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>need[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<t;i++){\n\t\tcin>>op[i].first>>op[i].second;\n\t\top[i].first--;\n\t\top[i].second--;\n\t}\n\t\n\t\n\tint l=0,r=t-1,res=-2;\n\twhile(l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif(ok(mid)){\n\t\t\tres=mid;\n\t\t\tr=mid-1;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\t\n\tcout<<res+1<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint p,r,t;\nint l[333];\nint n[333][333];\nint P[214514],R[214514];\nvector<int> v[333][333];\nbool check(int T){\n  int x[333][333]={},y[333][333]={},z[333]={};\n  for(int j=0;j<r;j++) z[j]=l[j];\n  int cnt=0;\n  bool used[333]={};\n  for(int i=0;i<p;i++){\n    bool flg;\n    for(int j=0;j<r;j++){\n      //for(int k:v[i][j]) cout<<\"-\"<<k;cout<<endl;\n      int k=v[i][j].end()-upper_bound(v[i][j].begin(),v[i][j].end(),T);\n      //cout<<T<<\":\"<<*upper_bound(v[i][j].begin(),v[i][j].end(),T)<<endl;\n      x[i][j]=v[i][j].size()-k;\n      y[i][j]=n[i][j]-x[i][j];\n      //cout<<i<<\" \"<<j<<\":\"<<x[i][j]<<\" \"<<y[i][j]<<endl;\n      z[j]-=x[i][j];\n      flg&=k==0;\n    }\n    for(int j=0;j<r;j++)\n      if(flg) z[j]+=x[i][j];\n    used[i]=flg;\n  }\n  //for(int j=0;j<r;j++) cout<<z[j]<<\" \";cout<<endl;\n  while(1){\n    bool flg=0;\n    for(int i=0;i<p;i++){\n      if(used[i]) continue;\n      bool tmp=1;\n      for(int j=0;j<r;j++)\n\ttmp&=y[i][j]<=z[j];\n      if(!tmp) continue;\n      flg=used[i]=1;cnt++;\n      for(int j=0;j<r;j++) z[j]+=x[i][j];\n    }\n    if(!flg) break;\n  }\n  //cout<<T<<\":\"<<cnt<<\" \"<<p<<endl;\n  return cnt==p;\n}\nsigned main(){\n  scanf(\"%lld %lld %lld\",&p,&r,&t);\n  for(int i=0;i<r;i++) scanf(\"%lld\",l+i);\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++)\n      scanf(\"%lld\",n[i]+j);\n  for(int i=0;i<t;i++) scanf(\"%lld %lld\",P+i,R+i);\n  for(int i=0;i<t;i++){\n    P[i]--;R[i]--;\n    v[P[i]][R[i]].push_back(i+1);\n  }\n  if(check(t+1)){\n    puts(\"-1\");\n    return 0;\n  }\n  int X=0,Y=t+1;\n  while(X+1<Y){\n    int Z=(X+Y)/2;\n    if(check(Z)) X=Z;\n    else Y=Z;\n  }\n  printf(\"%lld\\n\",Y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nvoid print();\nint n,m,k;\nint alloc_data[305];\nint need_data[305][305];\npii data[200005];\nint alloc[305];\nint need[305][305];\nint zero[305];\nbool use[305];\n\ninline void recover(int x)\n{\n\tuse[x]=false;\n\tzero[x]=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\talloc[i]+=need_data[x][i]-need[x][i];\n\t\tneed[x][i]=need_data[x][i];\n\t\tzero[x]+=(need[x][i]==0);\n\t}\n}\n\ninline void run(int x)\n{\n\tmemset(use,false,sizeof(use));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\talloc[i]=alloc_data[i];\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tzero[i]=0;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tneed[i][j]=need_data[i][j];\n\t\t\tzero[i]+=(need_data[i][j]==0);\n\t\t}\n\t}\n\tfor(int i=0;i<=x;i++)\n\t{\n\t\tuse[data[i].first]=true;\n\t\talloc[data[i].second]--;\n\t\tneed[data[i].first][data[i].second]--;\n\t\tif(need[data[i].first][data[i].second]==0) zero[data[i].first]++;\n\t\tif(zero[data[i].first]==m) recover(data[i].first);\n\t}\n}\n\ninline bool check(int x)\n{\n\trun(x);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(use[j]==false) continue;\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t{\n\t\t\t\tif(alloc[k]<need[j][k])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==true) recover(j);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(use[i]) return true;\n\t}\n\treturn false;\n}\n\nvoid print()\n{\n\tcout<<\"ÄÚ´æÊ¹ÓÃÇé¿ö£º\\n\";\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<alloc[i]<<' ';\n\t}\n\tcout<<endl;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n>>m>>k;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>alloc_data[i];\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tcin>>need_data[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tcin>>data[i].first>>data[i].second;\n\t\tdata[i].first--;\n\t\tdata[i].second--;\n\t}\n\tint l=0,r=k-1,res=-2,mid;\n\twhile(l<=r)\n\t{\n\t\tmid=l+((r-l)>>1);\n\t\tif(check(mid))\n\t\t{\n\t\t\tres=mid;\n\t\t\tr=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\tcout<<res+1<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint p, r, T;\nvector<vi> num;\nvi l;\nvi in_P, in_R;\n\nbool check(int border){\n    int cnt = 0;\n    vi ended(p);\n    vi rest_n = l;\n    vector<vi> use_r(p, vi(r));\n    rep(t, border){\n        int P = in_P[t], R = in_R[t];\n\n        rest_n[R]--;\n        use_r[P][R]++;\n\n        bool ok = true;\n        rep(i, r){\n            ok &= (use_r[P][i] == num[P][i]);\n        }\n\n        // release\n        if(ok){\n            rep(i, r){\n                rest_n[i] += num[P][i];\n            }\n            ended[P] = true; cnt++;\n        }\n    }\n\n    /*\n    cerr << \"-----\" << endl;\n    cerr << \"border = \" << border << endl;\n    cerr << \"rest_n: \";\n    for(auto& e : rest_n) cerr << e << \" \"; cerr << endl;\n\n    cerr << \"use_r: \" << endl;\n    rep(i, p){\n        rep(j, r){\n            cerr << use_r[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    //*/\n\n    while(true){\n        int pcnt = cnt;\n        rep(i, p){\n            if(ended[i]) continue;\n\n            bool ok = true;\n            rep(j, r){\n                if(rest_n[j] < num[i][j] - use_r[i][j]){\n                    ok = false;\n                }\n            }\n\n            // release\n            if(ok){\n                rep(j, r){\n                    rest_n[j] += use_r[i][j];\n                }\n                ended[i] = true; cnt++;\n            }\n        }\n        if(pcnt == cnt) break;\n    }\n\n    return cnt == p;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> p >> r >> T;\n    l = vi(r); for(auto& e : l) cin >> e;\n    num = vector<vi>(p, vi(r));\n    rep(i, p) rep(j, r) cin >> num[i][j];\n\n    in_P = vi(T), in_R = vi(T);\n    rep(t, T) cin >> in_P[t] >> in_R[t], in_P[t]--, in_R[t]--;\n\n    int lb = 0, ub = T + 1;\n    bool deadlock = false;\n    while(ub - lb > 1){\n        int mid = (lb + ub) / 2;\n\n        if(check(mid)){\n            lb = mid;\n        }\n        else {\n            deadlock = true;\n            ub = mid;\n        }\n    }\n\n    if(deadlock){\n        cout << ub << endl;\n    }\n    else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=311,maxt=200011;\nint n,m,t,s[maxn],w[maxn][maxn],a[maxt],b[maxt];\nvoid init(){\n    scanf(\"%d%d%d\",&n,&m,&t);\n    for (int i=1;i<=m;++i) scanf(\"%d\",s+i);\n    for (int i=1;i<=n;++i) for (int j=1;j<=m;++j) scanf(\"%d\",&w[i][j]);\n    for (int i=1;i<=t;++i) scanf(\"%d%d\",a+i,b+i);\n}\nbool check(int t){\n    static int sx[maxn]; memcpy(sx,s,sizeof(s));\n    static int wx[maxn][maxn]; memset(wx,0,sizeof(w));\n    for (int i=1;i<=t;++i){\n        --sx[b[i]]; ++wx[a[i]][b[i]];\n    }\n    static bool vis[maxn]; memset(vis,0,sizeof(vis));\n    for (int t=1;t<=n;++t){\n        for (int i=1;i<=n;++i) if (!vis[i]){\n\t\t\tbool flag=1;\n\t\t\tfor (int j=1;j<=m;++j) if (wx[i][j]+max(0,sx[j])<w[i][j]){flag=0; break;}\n            if (flag){\n\t\t\t\tvis[i]=1;\n\t\t\t\tfor (int j=1;j<=m;++j) sx[j]+=wx[i][j];\n            }\n        }\n    }\n\tfor (int i=1;i<=n;++i) if (!vis[i]) return true;\n\treturn false;\n}\nvoid work(){\n    int t=1,w=::t;\n    while (t<=w){\n\t\tint mid=(t+w)>>1;\n\t\tif (check(mid)) w=mid-1;else t=mid+1;\n    }\n    printf(\"%d\\n\",w==::t?-1:w+1);\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <iostream> \nusing namespace std;\n\npair<int, int> P[200005];\n\nint p, r, t;\n\nint ned[305][305];\nint num[305];\n\nint grid[305][305];\nint used[305];\nint bo[305];\n\nint check(int t) {\n    memset(used, 0, sizeof(used));\n    memset(grid, 0, sizeof(grid));\n    memset(bo, 0, sizeof(bo));\n    for (int i = 1; i <= t; ++i) {\n        ++used[P[i].second];\n        ++grid[P[i].first][P[i].second];\n    }\n    int tot = 0;\n    while (1) {\n        int flag = 0;\n        for (int i = 1; i <= p; ++i)\n            if (!bo[i]) {\n                int mark = 0;\n                for (int j = 1; j <= r; ++j)\n                    if (grid[i][j] + num[j] - used[j] < ned[i][j])\n                        mark = 1;\n                if (mark == 0) {\n                    flag = i;\n                    break;\n                }\n            }\n        if (flag == 0) break;\n        bo[flag] = 1;\n        ++tot;\n        for (int j = 1; j <= r; ++j)\n            used[j] -= grid[flag][j];\n    }\n    return tot == p;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &p, &r, &t);\n    for (int i = 1; i <= r; ++i) {\n        scanf(\"%d\", &num[i]);\n    }\n    for (int i = 1; i <= p; ++i)\n        for (int j = 1; j <= r; ++j)\n            scanf(\"%d\", &ned[i][j]);\n    for (int i = 1; i <= t; ++i) {\n        scanf(\"%d%d\", &P[i].first, &P[i].second);\n    }\n    // cout << check(0) << endl;\n    if (check(t)) {\n        puts(\"-1\");\n    }\n    else {\n        int head = 0, tail = t;\n        while (head < tail - 1) {\n            int mid = (head + tail) >> 1;\n            if (check(mid)) head = mid;\n            else tail = mid;\n        }\n        cout << tail << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    // O(t)\n    tuple<vector<vector<int>>, vector<int>> calc_state(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left = L;\n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n        }\n        rep(p, P) {\n            bool ternimated = true;\n            rep(r, R) ternimated &=  need[p][r] == 0;\n            if(ternimated) {\n                rep(r, R) left[r] += N[p][r];\n            }\n        }\n        // cerr << \"state t = \" << t << endl;\n        // cerr << \"left \" << left << endl;\n        // cerr << need << endl;\n        return make_tuple(need, left);\n    }\n\n    bool is_avoidable(int t) {\n        vector<vector<int>> need;\n        vector<int> left;\n        tie(need, left) = calc_state(t);\n        \n        // check lack of resource\n        for(int l : left) if(l < 0) {\n                // cerr << \"Lack t = \" << t << endl;\n                return false;\n            }\n        \n        vector<bool> terminated(P);\n        int terminated_num = 0;\n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) {\n                    if(need[p][r] > left[r]) {\n                        terminatable = false;\n                        break;\n                    }\n                }\n                if(terminatable) {\n                    rep(r, R) {\n                        left[r] += N[p][r];\n                    }\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        // cerr << \"! \" << t << \" \" << terminated_num << endl;\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = 0, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            // cerr << m << \" \" << l << \" \" << r << endl;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nbool is_deadlocked(std::vector<int> resource_stock, std::vector<std::vector<int>> resource_reserved, const std::vector<std::vector<int>> &resource_need) {\n\tstd::queue<int> terminated;\n\tfor (auto i = 0; i < resource_need.size(); ++i) {\n\t\tbool can_execute = true;\n\t\tfor (auto r = 0; r < resource_stock.size(); ++r) {\n\t\t\tif (std::max(0, resource_stock[r]) + resource_reserved[i][r] < resource_need[i][r]) {\n\t\t\t\tcan_execute = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!can_execute) terminated.push(i);\n\t\telse {\n\t\t\tfor (auto r = 0; r < resource_stock.size(); ++r) {\n\t\t\t\tresource_stock[r] += resource_reserved[i][r];\n\t\t\t}\n\t\t}\n\t}\n\twhile (!terminated.empty()) {\n\t\tauto count = terminated.size();\n\t\tfor (auto c = 0; c < count; ++c) {\n\t\t\tauto process = terminated.front(); terminated.pop();\n\t\t\tbool can_execute = true;\n\t\t\tfor (auto r = 0; r < resource_stock.size(); ++r) {\n\t\t\t\tif (std::max(0, resource_stock[r]) + resource_reserved[process][r] < resource_need[process][r]) {\n\t\t\t\t\tcan_execute = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!can_execute) terminated.push(process);\n\t\t\telse {\n\t\t\t\tfor (auto r = 0; r < resource_stock.size(); ++r) {\n\t\t\t\t\tresource_stock[r] += resource_reserved[process][r];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count == terminated.size()) return true;\n\t}\n\treturn false;\n}\nbool is_deadlocked(std::vector<int> resource_stock, std::vector<std::vector<std::vector<int>>> rock_history, const std::vector<std::vector<int>>& resource_need, const int current_time) {\n\tstd::vector<std::vector<int>> resource_reserved;\n\tstd::transform(rock_history.begin(), rock_history.end(), std::back_inserter(resource_reserved), \n\t\t[current_time](const std::vector<std::vector<int>>& histories) {\n\t\tstd::vector<int> resource;\n\t\tstd::transform(histories.begin(), histories.end(), std::back_inserter(resource), \n\t\t\t[current_time](const std::vector<int>& history) {return std::distance(std::begin(history), std::upper_bound(std::begin(history), std::end(history), current_time)); });\n\t\treturn resource;\n\t\t});\n\tfor (const auto &reserved : resource_reserved) {\n\t\tfor (auto i = 0; i < resource_stock.size(); ++i)\n\t\t\tresource_stock[i] -= reserved[i];\n\t}\n\treturn is_deadlocked(resource_stock, resource_reserved, resource_need);\n}\nint main() {\n\tint p, r, t; std::cin >> p >> r >> t;\n\tstd::vector<int> stock(r); for (auto& s : stock) std::cin >> s;\n\tstd::vector<std::vector<int>> resource_needs(p, std::vector<int>(r));\n\tfor (auto& needs : resource_needs) for (auto& resource : needs) std::cin >> resource;\n\tstd::vector<std::vector<std::vector<int>>> rock_history(p, std::vector<std::vector<int>>(r));\n\tfor (auto i = 1; i <= t; ++i) {\n\t\tint proc, res; std::cin >> proc >> res;\n\t\trock_history[proc - 1][res - 1].push_back(i);\n\t}\n\tint min = 1, max = t + 1;\n\twhile (min < max) {\n\t\tconst auto mid = (min + max) / 2;\n\t\tif (is_deadlocked(stock, rock_history, resource_needs, mid)) max = mid;\n\t\telse min = mid + 1;\n\t}\n\tstd::cout << ((max > t) ? -1 : max) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 300\n\nstruct Info{\n\tint process,request;\n};\nint N,num_resource,T;\nint num[NUM],available_num[NUM];\nint need[NUM][NUM],tmp_have[NUM][NUM];\nint gather_num[NUM];\nbool finished[NUM];\nInfo info[200000];\n\nbool is_lock(int tmp_time){\n\n\tfor(int i = 0; i < N; i++){\n\t\tfinished[i] = false;\n\t\tgather_num[i] = 0;\n\t}\n\n\tfor(int i = 0; i < num_resource; i++){\n\t\tavailable_num[i] = num[i];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < num_resource; k++){\n\t\t\ttmp_have[i][k] = 0;\n\t\t\tif(need[i][k] == 0){\n\t\t\t\tgather_num[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint remain_num = N;\n\tint proc,req;\n\n\tfor(int i = 0; i < tmp_time; i++){\n\n\t\tif(available_num[info[i].request] == 0)continue;\n\n\t\tproc = info[i].process;\n\t\treq = info[i].request;\n\n\t\ttmp_have[proc][req]++;\n\t\tavailable_num[req]--;\n\n\t\tif(tmp_have[proc][req] == need[proc][req]){\n\t\t\tgather_num[proc]++;\n\n\t\t\tif(gather_num[proc] == num_resource){\n\n\t\t\t\tfinished[proc] = true;\n\t\t\t\tremain_num--;\n\t\t\t\tfor(int k = 0; k < num_resource; k++){\n\t\t\t\t\tavailable_num[k] += tmp_have[proc][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG,can_finish;\n\n\twhile(true){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < N; i++){\n\n\t\t\tif(finished[i])continue;\n\n\t\t\tcan_finish = true;\n\t\t\tfor(int k = 0; k < num_resource; k++){\n\t\t\t\tif(available_num[k] < need[i][k]-tmp_have[i][k]){\n\t\t\t\t\tcan_finish = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(can_finish){\n\t\t\t\tfinished[i] = true;\n\t\t\t\tFLG = true;\n\t\t\t\tremain_num--;\n\t\t\t\tfor(int k = 0; k < num_resource; k++){\n\t\t\t\t\tavailable_num[k] += tmp_have[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!FLG)break;\n\t}\n\treturn remain_num > 0;\n}\n\nint main(){\n\n\tscanf(\"%d %d %d\",&N,&num_resource,&T);\n\n\tfor(int i = 0; i < num_resource; i++){\n\t\tscanf(\"%d\",&num[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < num_resource; k++){\n\t\t\tscanf(\"%d\",&need[i][k]);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < T; i++){\n\t\tscanf(\"%d %d\",&info[i].process,&info[i].request);\n\t\tinfo[i].process--;\n\t\tinfo[i].request--;\n\t}\n\n\tint left = 0,right = T,m = (left+right)/2;\n\tint ans = -1;\n\n\twhile(left <= right){\n\n\t\tif(is_lock(m)){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0)\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n  }\n\n\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++)\n    if(cnt[i]>0)return false;\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Log {\n\tint p, r;\n};\n\ntypedef pair<int, int> Pair;\n\nint P, R, T;\nvector< vector<int> > p0;\nvector<int> r0;\nvector<Log> g;\nbool isAlive(int t) {\n\tvector< vector<int> > p = p0;\n\tvector<int> r = r0;\n\tfor (int i = 0; i < t; ++i) {\n\t\t--p[g[i].p][g[i].r];\n\t\t--r[g[i].r];\n\t}\n\tvector<bool> isFree(P, false);\n\tfor (int i = 0; i < P; ++i) {\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tcnt += p[i][j] == 0;\n\t\t}\n\t\tif (cnt == R) {\n\t\t\tisFree[i] = true;\n\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\tr[j] += p0[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> deadCount(P, 0);\n\tvector<bool> isDead(P, false);\n\tvector< set<Pair> > need(R);\n\tfor (int i = 0; i < P; ++i) {\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tif (p[i][j] > r[j]) {\n\t\t\t\tneed[j].insert( Pair(p[i][j], i) );\n\t\t\t\t++deadCount[i];\n\t\t\t\tisDead[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Pair> Q;\n\tfor (int i = 0; i < P; ++i) {\n\t\tif (!isFree[i] && !isDead[i]) {\n\t\t\tisFree[i] = true;\n\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\tQ.push( Pair(j, p0[i][j]) );\n\t\t\t}\n\t\t}\n\t}\n\twhile ( !Q.empty() ) {\n\t\tPair q = Q.front(); Q.pop();\n\t\tint rid = q.first, amount = q.second;\n\t\tr[rid] += amount;\n\t\twhile (need[rid].size() > 0) {\n\t\t\tset<Pair>::iterator it = need[rid].begin();\n\t\t\tif (it->first <= r[rid]) {\n\t\t\t\tif (--deadCount[it->second] == 0) {\n\t\t\t\t\tisDead[it->second] = false;\n\t\t\t\t\tisFree[it->second] = true;\n\t\t\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\t\t\tQ.push( Pair(j, p0[it->second][j]) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[rid].erase(it);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < P; ++i) {\n\t\tif (isDead[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin >> P >> R >> T;\n\tr0 = vector<int>(R);\n\tp0 = vector< vector<int> >(P, vector<int>(R));\n\tg.resize(T);\n\tfor (int i = 0; i < R; ++i) cin >> r0[i];\n\tfor (int i = 0; i < P; ++i) {\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tcin >> p0[i][j];\n\t\t}\n\t}\n\tfor (int t = 0; t < T; ++t) {\n\t\tcin >> g[t].p >> g[t].r; --g[t].p, --g[t].r;\n\t}\n\n\tint left = 0, right = T+1;\n\twhile ( right-left > 1 ) {\n\t\tint m = (left+right)/2;\n\t\tif ( isAlive(m) ) {\n\t\t\tleft = m;\n\t\t}\n\t\telse {\n\t\t\tright = m;\n\t\t}\n\t}\n\tif (left == T) cout << -1 << endl;\n\telse cout << left+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint p, r, t;\n\tcin >> p >> r >> t;\n\tvi resource(r);\n\tREP(i, r) cin >> resource[i];\n\tvector<vi> need(p, vi(r));\n\tREP(i, p)REP(j, r) cin >> need[i][j];\n\tvector<pii> query;\n\tREP(i, t)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tquery.emplace_back(a, b);\n\t}\t\t\n\tauto available = resource;\n\tauto tmp = need;\n\tREP(i, t)\n\t{\n\t\tint p = query[i].first, r = query[i].second;\n\t\tavailable[r]--;\n\t\ttmp[p][r]--;\n\t}\n\tint lb = 0, ub = t + 1;\n\twhile (ub - lb > 1)\n\t{\n\t\tint time = (ub + lb) / 2;\n\t\tauto available = resource;\n\t\tauto tmp = need;\n\t\tREP(i, time)\n\t\t{\n\t\t\tint p = query[i].first, r = query[i].second;\n\t\t\tavailable[r]--;\n\t\t\ttmp[p][r]--;\n\t\t}\n\t\tvector<bool> f(p, true);\n\t\tREP(i, p)REP(j, tmp[i].size())\n\t\t{\n\t\t\tif (tmp[i][j] > available[j]) f[i] = false;\n\t\t}\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (f[i])\n\t\t\t{\n\t\t\t\tREP(j, r) available[j] += need[i][j] - tmp[i][j];\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (!f[i])\n\t\t\t{\n\t\t\t\tREP(j, r)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i][j] > available[j]) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) lb = time;\n\t\telse ub = time;\n\t}\n\tif (ub == t + 1) cout << -1 << endl;\n\telse cout << ub << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <iostream> \nusing namespace std;\n\npair<int, int> P[200005];\n\nint p, r, t;\n\nint ned[305][305];\nint num[305];\n\nint grid[305][305];\nint used[305];\nint bo[305];\n\nint check(int t) {\n    memset(used, 0, sizeof(used));\n    memset(grid, 0, sizeof(grid));\n    memset(bo, 0, sizeof(bo));\n    for (int i = 1; i <= t; ++i) {\n        ++used[P[i].second];\n        ++grid[P[i].first][P[i].second];\n    }\n    int tot = 0;\n    for (int i = 1; i <= p; ++i) {\n        int mark = 0;\n        for (int j = 1; j <= r; ++j)\n            if (grid[i][j] < ned[i][j]) {\n                mark = 1;\n                break;\n            }\n        if (mark == 0) {\n            bo[i] = 1;\n            ++tot;\n            for (int j = 1; j <= r; ++j)\n                used[j] -= grid[i][j];\n        }\n    }\n    while (1) {\n        int flag = 0;\n        for (int i = 1; i <= p; ++i)\n            if (!bo[i]) {\n                int mark = 0;\n                for (int j = 1; j <= r; ++j)\n                    if (grid[i][j] + num[j] - used[j] < ned[i][j]) {\n                        mark = 1;\n                        break;\n                    }\n                if (mark == 0) {\n                    flag = i;\n                    break;\n                }\n            }\n        if (flag == 0) break;\n        bo[flag] = 1;\n        ++tot;\n        for (int j = 1; j <= r; ++j)\n            used[j] -= grid[flag][j];\n    }\n    return tot == p;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &p, &r, &t);\n    for (int i = 1; i <= r; ++i) {\n        scanf(\"%d\", &num[i]);\n    }\n    for (int i = 1; i <= p; ++i)\n        for (int j = 1; j <= r; ++j)\n            scanf(\"%d\", &ned[i][j]);\n    for (int i = 1; i <= t; ++i) {\n        scanf(\"%d%d\", &P[i].first, &P[i].second);\n    }\n    // cout << check(0) << endl;\n    if (check(t)) {\n        puts(\"-1\");\n    }\n    else {\n        int head = 0, tail = t;\n        while (head < tail - 1) {\n            int mid = (head + tail) >> 1;\n            if (check(mid)) head = mid;\n            else tail = mid;\n        }\n        cout << tail << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200050;\n\nint p, r, t, a[510], m[510][510], s[510][510], b[510], u[N], v[N];\nbool vis[510];\n\nbool check(int mid) {\n    queue <int> q;\n    for (int i = 0; i < p; i++) {\n        vis[i] = false;\n        for (int j = 0; j < r; j++) {\n            s[i][j] = m[i][j];\n        }\n    }\n    for (int i = 0; i < r; i++) {\n        b[i] = a[i];\n    }\n    for (int i = 0; i <= mid; i++) {\n        b[v[i]]--;\n        s[u[i]][v[i]]--;\n    }\n    for (int i = 0; i < p; i++) {\n        bool ok = true;\n        for (int j = 0; j < r; j++) {\n            if (s[i][j] > b[j]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            vis[i] = true;\n            q.push(i);\n        }\n    }\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = 0; i < r; i++) {\n            b[i] += m[now][i] - s[now][i];\n        }\n        for (int i = 0; i < p; i++) {\n            if (vis[i]) {\n                continue;\n            }\n            bool ok = true;\n            for (int j = 0; j < r; j++) {\n                if (s[i][j] > b[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                vis[i] = true;\n                q.push(i);\n            }\n        }\n    }\n    for (int i = 0; i < p; i++) {\n        if (!vis[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n\n    while (scanf(\"%d %d %d\", &p, &r, &t) != EOF) {\n        for (int i = 0; i < r; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < r; j++) {\n                scanf(\"%d\", &m[i][j]);\n            }\n        }\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &u[i], &v[i]);\n            u[i]--;\n            v[i]--;\n        }\n        if (check(t - 1)) {\n            puts(\"-1\");\n            continue;\n        }\n        int lo = -1;\n        int hi = t - 1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid)) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        printf(\"%d\\n\", lo + 1);\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint main(){\n    int p,r,t;\n    cin >> p >> r >> t;\n    vector<int> resources(r);\n    for(int i=0; i<r; i++){\n        cin >> resources[i];\n    }\n    vector<vector<int>> needs(p, vector<int>(r));\n    for(int i=0; i<p; i++){\n        for(int j=0; j<r; j++){\n            cin >> needs[i][j];\n        }\n    }\n    auto needs_def = needs;\n    vector<pair<int,int>> log(t);\n    for(int i=0; i<t; i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        log[i] = {a, b};\n    }\n\n    int ok=-1, ng=t;\n    int prevmid=-1;\n    while(ok+1 < ng){\n        int mid = (ok+ng)/2;\n        for(int i=prevmid; i<mid; i++){\n            needs[log[i+1].first][log[i+1].second]--;\n            resources[log[i+1].second]--;\n        }\n        for(int i=prevmid; i>mid; i--){\n            needs[log[i].first][log[i].second]++;\n            resources[log[i].second]++;\n        }\n        prevmid = mid;\n\n        auto rsc = resources;\n        vector<bool> terminated(p, false);\n        int endnum = 0;\n        for(int i=0; i<p; i++){\n            if(*max_element(needs[i].begin(), needs[i].end()) == 0){\n                terminated[i] = true;\n                for(int j=0; j<r; j++){\n                    rsc[j] += needs_def[i][j];\n                }\n                endnum++;\n            }\n        }\n        while(endnum < p){\n            bool deadlock = true;\n            for(int i=0; i<p; i++){\n                if(terminated[i]) continue;\n                bool ok = true;\n                for(int j=0; j<r; j++){\n                    if(rsc[j] < needs[i][j]) ok = false;\n                }\n                if(ok){\n                    terminated[i] = true;\n                    deadlock = false;\n                    for(int j=0; j<r; j++){\n                        rsc[j] += needs_def[i][j] -needs[i][j];\n                    }\n                    endnum++;\n                }\n            }\n            if(deadlock) break;\n        }\n        if(endnum == p){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    if(ng == t){\n        cout << -1 << endl;\n    }else{\n        cout << ng+1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for (int i=0;i<n;++i)\n#define REP(i,n) for (int i=1;i<=n;++i)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define read(x) scanf(\"%d\",&x)\nint P,R,T;\nint pp[305][305];\nint rr[305];\nclass state{\npublic:\n\tint p[305][305];\n\tint r[305];\n\tinline bool off(int i){\n\t\tfor (int j=1;j<=R;++j) if (p[i][j]) return 0;\n\t\treturn 1;\n\t}\n\tinline bool on(int i){\n\t\tfor (int j=1;j<=R;++j) if (p[i][j]) return 1;\n\t\treturn 0;\n\t}\n\tinline bool available(int i){\n\t\tfor (int j=1;j<=R;++j) if (p[i][j]>r[j]) return 0;\n\t\treturn 1;\n\t}\n\tinline void release(int i){\n\t\tfor (int j=1;j<=R;++j) r[j]+=pp[i][j];\n\t}\n\tinline bool judge(){// O(n^3)\n\t\tint p1[305][305],r1[305];\n\t\trep(i,305) rep(j,305) p1[i][j]=p[i][j];\n\t\trep(j,305) r1[j]=r[j];\n\t\twhile(1){\n\t\t\tint cnt=0;\n\t\t\tfor (int i=1;i<=P;++i) if (on(i)) ++cnt;\n\t\t\tif (!cnt){\n\t\t\t\trep(i,305) rep(j,305) p[i][j]=p1[i][j];\n\t\t\t\trep(j,305) r[j]=r1[j];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbool term=1;\n\t\t\tfor (int i=1;i<=P;++i){\n\t\t\t\tif (off(i)) continue;\n\t\t\t\tif (available(i)){\n\t\t\t\t\tterm=0;\n\t\t\t\t\tfor (int j=1;j<=R;++j){\n\t\t\t\t\t\tr[j]-=p[i][j];p[i][j]=0;r[j]+=pp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (term){\n\t\t\t\trep(i,305) rep(j,305) p[i][j]=p1[i][j];\n\t\t\t\trep(j,305) r[j]=r1[j];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tstate operator = (const state& st){\n\t\trep(i,305) rep(j,305) p[i][j]=st.p[i][j];\n\t\trep(j,305) r[j]=st.r[j];\n\t\treturn *this;\n\t}\n};\n\nint p_[200005],r_[200005];\nmap<int,state> m;\nmap<int,state>::iterator it;\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tcin>>P>>R>>T;\n\tfor (int i=1;i<=R;++i){\n\t\tcin>>rr[i];m[0].r[i]=rr[i];\n\t}\n\tfor (int i=1;i<=P;++i) for (int j=1;j<=R;++j){\n\t\tcin>>pp[i][j];m[0].p[i][j]=pp[i][j];\n\t}\n\tm[T]=m[0];\n\tfor (int i=1;i<=T;++i){\n\t\tcin>>p_[i]>>r_[i];\n\t\t--m[T].p[p_[i]][r_[i]];\n\t\t--m[T].r[r_[i]];\n\t}\n\tfor (int i=1;i<=P;++i) if (m[0].on(i)&&m[T].off(i)) m[T].release(i);\n\tif (m[T].judge()){\n\t\tcout<<-1<<endl;return 0;\n\t}\n\tif (!m[0].judge()){\n\t\tcout<<0<<endl;return 0;\n\t}\n\tint l=0,r=T;// l can, r can't\n\twhile(r-l>1){\n\t\tint t=(l+r)/2;\n\t\tm[t]=m[l];\n\t\tfor (int i=l+1;i<=t;++i){\n\t\t\t--m[t].p[p_[i]][r_[i]];\n\t\t\t--m[t].r[r_[i]];\n\t\t}\n\t\tfor (int i=1;i<=P;++i) if (m[l].on(i)&&m[t].off(i)) m[t].release(i);\n\t\tif (m[t].judge()) l=t;\n\t\telse r=t;\n\t}\n\tcout<<r<<endl;\n\tfor (int i=1;i<1e9;++i) r=r+1;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    \n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0){\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n    }\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n    assert(cnt[i]==0);\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++)scanf(\"%d\",&a[i]);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      scanf(\"%d\",&b[i][j]);\n\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  \n  if(check(K+1))left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define  fr(i,x,y) for(i=x;i<=y;i++)\n#define  frd(i,x,y) for(i=x;i>=y;i--)\nconst int maxn=310;\nconst int maxm=(int)2e5+10;\nint n,m,T,p;\nint have[maxn],a[maxn],left[maxn];\nint want[maxn][maxn],ori[maxn][maxn];\nint list[maxm][2];\nint fa[maxn],sta[maxn];\nvoid Read()\n{\t\n\tint i,j;\n\tscanf(\"%d%d%d\",&n,&m,&T);\n\tfr(j,1,m)scanf(\"%d\",&have[j]);\n\tmemset(left+1,0,n*sizeof(int));\n\tfr(i,1,n)\n\tfr(j,1,m)\n\t{\n\t\tscanf(\"%d\",&want[i][j]),ori[i][j]=want[i][j];\n\t\tif(want[i][j])left[i]++;\n\t}\n\tfr(i,1,T)scanf(\"%d%d\",&list[i][0],&list[i][1]);\n}\nvoid Go_up(int low,int high)\n{\n\tint i,j,p,r;\n\tfr(i,low+1,high)\n\t{\n\t\tp=list[i][0],r=list[i][1];\n\t\thave[r]--;\n\t\twant[p][r]--;\n\t\tif(!want[p][r])\n\t\t{\n\t\t\tleft[p]--;\n\t\t\tif(!left[p])fr(j,1,m)have[j]+=ori[p][j];\n\t\t}\n\t}\n}\nvoid Go_down(int high,int low)\n{\n\tint i,j,p,r;\n\tfrd(i,high,low+1)\n\t{\n\t\tp=list[i][0],r=list[i][1];\n\t\thave[r]++;\n\t\tif(!want[p][r])\n\t\t{\n\t\t\tif(left[p]==0)fr(j,1,m)have[j]-=ori[p][j];\n\t\t\tleft[p]++;\n\t\t}\n\t\twant[p][r]++;\n\t}\n}\nint Get_fa(int x)\n{\n\twhile(fa[x]!=x)sta[++sta[0]]=x,x=fa[x];\n\twhile(sta[0])fa[sta[sta[0]--]]=x;\n\treturn x;\n}\nbool Check()\n{\n\tint i,j,cnt;\n\tbool bo;\n\tfr(i,1,n+1)fa[i]=i;\n\tmemcpy(a+1,have+1,m*sizeof(int));\n\tcnt=0;\n\tbo=true;\n\twhile(bo)\n\t{\n\t\tbo=false;\n\t\tfor(i=Get_fa(1);i<=n;i=Get_fa(i+1))\n\t\t{\n\t\t\tfr(j,1,m)if(want[i][j]>a[j])break;\n\t\t\tif(j<=m)continue;\n\t\t\tcnt++;\n\t\t\tif(left[i]!=0)\n\t\t\t\tfr(j,1,m)a[j]+=ori[i][j]-want[i][j];\n\t\t\tbo=true;\n\t\t\tfa[i]=Get_fa(i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn cnt==n;\n}\nvoid Solve()\n{\n\tint le,ri,mi;\n\tle=0,ri=T;\n\tp=0;\n\twhile(le<=ri)\n\t{\n\t\tmi=(le+ri)>>1;\n\t\tif(mi>p)Go_up(p,mi);\n\t\telse Go_down(p,mi);\n\t\tp=mi;\n\t\tif(Check())le=mi+1;\n\t\telse ri=mi-1;\n\t}\n\tif(le>T)le=-1;\n\tprintf(\"%d\\n\",le);\n}\nint main()\n{\n\tRead();\n\tSolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nstruct Log {\n\tint p, r;\n};\n\ntypedef pair<int, int> Pair;\n\nint P, R, T;\nvector< vector<int> > p0;\nvector<int> r0;\nvector<Log> g;\nbool isAlive(int t) {\n\tvector< vector<int> > p = p0;\n\tvector<int> r = r0;\n\tfor (int i = 0; i < t; ++i) {\n\t\t--p[g[i].p][g[i].r];\n\t\t--r[g[i].r];\n\t}\n\tvector<bool> isFree(P, false);\n\tfor (int i = 0; i < P; ++i) {\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tcnt += p[i][j] == 0;\n\t\t}\n\t\tif (cnt == R) {\n\t\t\tisFree[i] = true;\n\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\tr[j] += p0[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> deadCount(P, 0);\n\tvector<bool> isDead(P, false);\n\tvector< set<Pair> > need(R);\n\tfor (int i = 0; i < P; ++i) {\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tif (p[i][j] > r[j]) {\n\t\t\t\tneed[j].insert( Pair(p[i][j], i) );\n\t\t\t\t++deadCount[i];\n\t\t\t\tisDead[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Pair> Q;\n\tfor (int i = 0; i < P; ++i) {\n\t\tif (!isFree[i] && !isDead[i]) {\n\t\t\tisFree[i] = true;\n\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\tQ.push( Pair(j, p0[i][j]) );\n\t\t\t}\n\t\t}\n\t}\n\twhile ( !Q.empty() ) {\n\t\tPair q = Q.front(); Q.pop();\n\t\tint rid = q.first, amount = q.second;\n\t\tr[rid] += amount;\n\t\twhile (need[rid].size() > 0) {\n\t\t\tset<Pair>::iterator it = need[rid].begin();\n\t\t\tif (it->first <= r[rid]) {\n\t\t\t\tif (--deadCount[it->second] == 0) {\n\t\t\t\t\tisDead[it->second] = false;\n\t\t\t\t\tisFree[it->second] = true;\n\t\t\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\t\t\tQ.push( Pair(j, p0[it->second][j]) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[rid].erase(it);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < P; ++i) {\n\t\tif (isDead[i]) return false;\n\t}\n\n\treturn true;\n}\n\nsigned main() {\n\tcin >> P >> R >> T;\n\tr0 = vector<int>(R);\n\tp0 = vector< vector<int> >(P, vector<int>(R));\n\tg.resize(T);\n\tfor (int i = 0; i < R; ++i) cin >> r0[i];\n\tfor (int i = 0; i < P; ++i) {\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tcin >> p0[i][j];\n\t\t}\n\t}\n\tfor (int t = 0; t < T; ++t) {\n\t\tcin >> g[t].p >> g[t].r; --g[t].p, --g[t].r;\n\t}\n\n\tint left = 0, right = T+1;\n\twhile ( right-left > 1 ) {\n\t\tint m = (left+right)/2;\n\t\tif ( isAlive(m) ) {\n\t\t\tleft = m;\n\t\t}\n\t\telse {\n\t\t\tright = m;\n\t\t}\n\t}\n\tif (left == T) cout << -1 << endl;\n\telse cout << left+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint main(){\n    iostream_init();\n    int P, R, K;\n    while(cin >> P >> R >> K) {\n        vector<int> all(R);\n        vector<vector<int>> need_(P, vector<int>(R, 0));\n        vector<bool> used(P, true);\n\n        REP(i, R) cin >> all[i];\n        REP(i, P) REP(j, R) cin >> need_[i][j];\n\n        vector<int> X(K);\n        vector<int> Y(K);\n        REP(i, K) cin >> X[i] >> Y[i];\n        REP(i, K) X[i]--;\n        REP(i, K) Y[i]--;\n\n        auto zero = [&]() {\n            REP(i, P) {\n                REP(j, R) if(need_[i][j] > all[j]) return true;\n            }\n            return false;\n        };\n\n        if(zero()) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        auto check = [&](int T) {\n            vector<int> cur = all;\n            vector<vector<int>> need = need_;\n            vector<vector<int>> take(P, vector<int>(R, 0));\n            vector<int> have(P);\n\n            REP(i, T) {\n                cur[ Y[i] ]--;\n                need[ X[i] ][ Y[i] ]--;\n                take[ X[i] ][ Y[i] ]++;\n                have[ X[i] ]++;\n            }\n\n            while(true) {\n                bool updated = false;\n                REP(i, P) if(have[i] > 0) {\n                    bool ok = true;\n                    REP(j, R) if(need[i][j] > cur[j]){ ok = false; break; }\n                    if(ok) {\n                        updated = true;\n                        have[i] = 0;\n                        REP(j, R) cur[j] += take[i][j];\n                    }\n                }\n                if(!updated) break;\n            }\n            bool ok = true;\n            REP(i, P) if(have[i]) ok = false;\n            return ok;\n        };\n\n        if(check(K)) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        int lb = 0, ub = K + 1;\n        // [lb, ub)\n        while(ub - lb > 1) {\n            int T = (lb + ub) / 2;\n            if(check(T)) {\n                lb = T;\n            } else {\n                ub = T;\n            }\n        }\n        cout << ub << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    \n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0){\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n    }\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n    assert(cnt[i]==0);\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint p,r,t;\nint L[333];\nint lmp[333];\nint tmp[333][333];\nint n[333][333];\nbool used[333];\nint C[333];\nvector<P> D;\n\nbool isRelease( int id ){\n  for(int i=0;i<r;i++)\n    if( n[id][i] > L[i] ) return false;\n  return true;\n}\n\nbool check(int h){\n\n  for(int i=0;i<r;i++) L[i] = lmp[i];\n  for(int i=0;i<p;i++){\n    C[i] = r;\n    for(int j=0;j<r;j++){\n      n[i][j] = tmp[i][j];\n      if( n[i][j] == 0 ) C[i]--;\n    }\n  }\n  \n  for(int i=0;i<h;i++){\n    if( L[ D[i].second ] == 0 ) return true;\n    L[ D[i].second ]--;    \n    n[ D[i].first ][ D[i].second ]--;\n    assert( n[ D[i].first ][ D[i].second ] >= 0 );    \n    if( n[ D[i].first ][ D[i].second ] == 0 ) C[ D[i].first ]--;\n\n    if( C[ D[i].first ] == 0 ) {\n      used[ D[i].first ] = true;\n      for(int j=0;j<r;j++)\n        L[ j ] += tmp[ D[i].first ][ j ];      \n    }\n  }\n\n  /*\n  cout << \"time : \" <<  h << endl;\n  for(int i=0;i<r;i++) cout << L[i]<< \" \";\n  cout << endl;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<r;j++) cout << n[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n\n  bool loop = true;\n  memset( used,0,sizeof( used ));\n  while( loop ){\n    loop = false;\n    for(int i=0;i<p;i++){\n      if( used[i] ) continue;\n      if( isRelease( i ) ) {\n        for(int j=0;j<r;j++)\n          L[ j ] += tmp[i][j] - n[i][j];\n        used[i] = true;\n        loop = true;\n      }\n    }\n  }\n\n  for(int i=0;i<p;i++)\n    if( !used[i] ) return true;\n  return false;\n  \n}\n\nint main(){\n  cin >> p >> r >> t;\n  D.resize( t );\n  for(int i=0;i<r;i++) {\n    cin >> L[i]; lmp[i] = L[i];\n  }\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++){\n      cin >> n[i][j];\n      tmp[i][j] = n[i][j];\n    }\n  for(int i=0;i<t;i++){\n    cin >> D[i].first >> D[i].second;\n    D[i].first--; D[i].second--;\n  }\n\n  int st = 0, ed = t;\n  int res = -1;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( check( h ) ) {\n      ed = h-1; res = h;\n    } else {\n      st = h+1;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 333, inf = 1000000000;\nint P, R, T, r[maxn], p[maxn][maxn], z[100086 * 2][2], nowr[maxn], nowp[maxn][maxn], cnt[maxn], sum, ok;\nbool flag, flag1, ilock[maxn][maxn], ban[maxn];\n\nvoid print()\n{\n    printf(\"nowp:\\n\");\n    for (int i = 1; i <= P; i++)\n    {\n        for (int j = 1; j <= R; j++)\n            printf(\"%d \", nowp[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"nowr:\\n\");\n    for (int i = 1; i <= R; i++) printf(\"%d \", nowr[i]); printf(\"\\n\");\n}\n\nint main()\n{\n    //freopen(\"F.out\", \"w\", stdout);\n    scanf(\"%d %d %d\", &P, &R, &T);\n    for (int i = 1; i <= R; i++)\n    {\n        scanf(\"%d\", &r[i]);\n        nowr[i] = r[i];\n    }\n\tfor (int i = 1; i <= P; i++)\n        for (int j = 1; j <= R; j++)\n            scanf(\"%d\", &p[i][j]);\n    for (int i = 1; i <= T; i++) scanf(\"%d %d\", &z[i][0], &z[i][1]);\n    for (int i = 1; i <= T; i++)\n    {\n        nowp[z[i][0]][z[i][1]]++;\n        nowr[z[i][1]]--;\n    }\n    for (int i = 1; i <= P; i++)\n    {\n        flag = 1;\n        for (int j = 1; j <= R; j++)\n            if (nowp[i][j] < p[i][j])\n            {\n                flag = 0;\n                break;\n            }\n        if (!flag) continue;\n        for (int j = 1; j <= R; j++)\n        {\n            nowr[j] += nowp[i][j];\n            nowp[i][j] = 0;\n        }\n        ban[i] = 1;\n        ok++;\n    }\n    flag = 1;\n    while (flag)\n    {\n        flag = 0;\n        for (int i = 1; i <= P; i++)\n        {\n            if (ban[i]) continue;\n            flag1 = 1;\n            for (int j = 1; j <= R; j++)\n                if (nowr[j] + nowp[i][j] < p[i][j])\n                {\n                    flag1 = 0;\n                    break;\n                }\n            flag |= flag1;\n            if (flag1)\n            {\n                for (int j = 1; j <= R; j++)\n                {\n                    nowr[j] += nowp[i][j];\n                    nowp[i][j] = 0;\n                }\n                ban[i] = 1;\n                ok++;\n            }\n            if (ok == P)\n            {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n    }\n    for (int i = 1; i <= P; i++)\n    {\n        if (ban[i]) continue;\n        for (int j = 1; j <= R; j++)\n            if (nowr[j] + nowp[i][j] < p[i][j])\n            {\n                ilock[i][j] = 1;\n                cnt[i]++;\n            }\n    }\n    for (int t = T; t >= 1; t--)\n    {\n        //printf(\"t : %d\\n\",t);\n        nowp[z[t][0]][z[t][1]]--;\n        nowr[z[t][1]]++;\n        flag = 0;\n        for (int i = 1; i <= P; i++)\n        {\n            if (ban[i]) continue;\n            if (nowr[z[t][1]] + nowp[i][z[t][1]] >= p[i][z[t][1]])\n                if (ilock[i][z[t][1]])\n                {\n                    ilock[i][z[t][1]] = 0;\n                    cnt[i]--;\n                    if (cnt[i] == 0)\n                    {\n                        flag = 1;\n                        for (int j = 1; j <= R; j++)\n                        {\n                            nowr[j] += nowp[i][j];\n                            nowp[i][j] = 0;\n                        }\n                        ban[i] = 1;\n                        ok++;\n                    }\n                }\n        }\n        while (flag)\n        {\n            flag = 0;\n            for (int i = 1; i <= P; i++)\n            {\n                if (ban[i]) continue;\n                flag1 = 1;\n                for (int j = 1; j <= R; j++)\n                    if (nowr[j] + nowp[i][j] < p[i][j])\n                    {\n                        flag1 = 0;\n                        break;\n                    }\n                flag |= flag1;\n                if (flag1)\n                {\n                    for (int j = 1; j <= R; j++)\n                    {\n                        nowr[j] += nowp[i][j];\n                        nowp[i][j] = 0;\n                    }\n                    ban[i] = 1;\n                    ok++;\n                }\n                if (ok == P)\n                {\n                    printf(\"%d\\n\", t);\n                    return 0;\n                }\n            }\n        }\n        for (int i = 1; i <= P; i++)\n        {\n            cnt[i] = 0;\n            for (int j = 1; j <= R; j++)\n                if (nowr[j] + nowp[i][j] < p[i][j])\n                {\n                    ilock[i][j] = 1;\n                    cnt[i]++;\n                }\n                else ilock[i][j] = 0;\n        }\n        //print();\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int p,r,t;\n    cin >> p >> r >> t;\n    vector<int> l(r);\n    for(int i=0;i<r;i++){\n        cin >> l[i];\n    }\n    vector<vector<int> > n(p,vector<int>(r));\n    for(int i=0;i<p;i++){\n        for(int j=0;j<r;j++){\n            cin >> n[i][j];\n        }\n    }\n    vector<int> P(t),R(t);\n    for(int i=0;i<t;i++){\n        cin >> P[i] >> R[i];\n        P[i]--;\n        R[i]--;\n    }\n    int ok = -1;\n    int ng = t+1;\n    while(abs(ok-ng)!=1){\n        int mid = (ok+ng)/2;\n        cout << mid << endl;\n        vector<int> x(r);\n        vector<vector<int> > y(p,vector<int>(r));\n        for(int i=0;i<r;i++){\n            x[i] = l[i];\n        }\n        for(int i=0;i<p;i++){\n            for(int j=0;j<r;j++){\n                y[i][j] = n[i][j];\n            }\n        }\n        for(int i=0;i<mid;i++){\n            x[R[i]]--;\n            y[P[i]][R[i]]--;\n        }\n        vector<bool> sss(p);\n        for(int z=0;z<p;z++){\n            for(int i=0;i<p;i++){\n                if(sss[i]==1)continue;\n                bool flag = 1;\n                for(int k=0;k<r;k++){\n                    //cout << i << \" \" << k << \" \" << y[i][k] << \" \" <<x[k] << endl;\n                    if(y[i][k]>x[k]){\n                        flag=0;\n                        break;\n                    }\n                }\n                if(flag){\n                    sss[i]=1;\n                    for(int k=0;k<r;k++){\n                        x[k] += n[i][k]-y[i][k];\n                    }\n                }\n            }\n        }\n        bool flag = 1;\n        for(int i=0;i<p;i++){\n            if(sss[i]==0){\n                flag = 0;\n            }\n        }\n        if(flag){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    if(ng==t+1){\n        cout << -1 << endl;\n    }else{\n    cout << ng << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N, r, t;\nint res[300];\nint need[300][300];\nint R[200000];\nint P[200000];\ntypedef pair<int, int> Pii;\nbool check(int x){\n\tint sum[300][300] = { 0 };\n\tint rem[300] = { 0 };\n\tmemcpy(rem, res, sizeof res);\n\n\tfor(int i = 0; i < x; i++){\n\t\tif(rem[R[i]] == 0) return false;\n\t\trem[R[i]]--;\n\t\tsum[P[i]][R[i]]++;\n\t}\n\tint fin[300] = { 0 };\n\n\tset<Pii> needrem[300];// rem, idx\n\tqueue<int> q;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < r; j++){\n\t\t\tint c = need[i][j] - sum[i][j];\n\t\t\tif(c <= rem[j]) fin[i]++;\n\t\t}\n\t\tif(fin[i] == r) q.push(i);\n\t\telse{\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tint c = need[i][j] - sum[i][j];\n\t\t\t\tif(c > rem[j]) needrem[j].insert({ c, i });\n\t\t\t}\n\t\t}\n\t}\n\twhile(q.size()){\n\t\tint id = q.front();\n\t\tq.pop();\n\t\tfor(int j = 0; j < r; j++){\n\t\t\tif(sum[id][j] == 0) continue;\n\t\t\trem[j] += sum[id][j];\n\t\t\twhile(needrem[j].size() && needrem[j].begin()->first <= rem[j]){\n\t\t\t\tauto it = needrem[j].begin();\n\t\t\t\tint id2 = it->second;\n\t\t\t\tfin[id2]++;\n\t\t\t\tif(fin[id2] == r) q.push(id2);\n\t\t\t\tneedrem[j].erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tif(fin[i] != r) return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> N >> r >> t){\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tcin >> res[i];\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tcin >> need[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tcin >> P[i] >> R[i];\n\t\t\tP[i]--, R[i]--;\n\t\t}\n\n\t\tfor(int i = 0; i <= t; i++){\n\t\t\t//cout << i << \" \" << check(i) << endl;\n\t\t}\n\n\t\tif(check(t)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ok = 0, ng = t;\n\t\twhile(abs(ok - ng) > 1){\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\n\t\tcout << ng << endl;\n\t\t//cout << \"---------------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    assert(B[p][q]>0);\n    \n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0)\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define N 300 + 5\n#define M 200000 + 5\n\nint p, r, t, Ret[N], _Ret[N], Acq[N][N], _Acq[N][N], P[M], R[M], q[N], Ok[N];\nbool Flag[N][N], Inq[N];\n\ninline bool Check(int k)\n{\n\tfor (int i = 1; i <= r; i ++)\n\t\tRet[i] = _Ret[i];\n\tfor (int i = 1; i <= p; i ++)\n\t\tfor (int j = 1; j <= r; j ++)\n\t\t\tAcq[i][j] = _Acq[i][j];\n\tfor (int i = 1; i <= k; i ++)\n\t{\n\t\tAcq[P[i]][R[i]] --;\n\t\tRet[R[i]] --;\n\t}\n\tint _l = 1, _r = 0;\n\tfor (int i = 1; i <= p; i ++)\n\t{\n\t\tOk[i] = Inq[i] = 0;\n\t\tfor (int j = 1; j <= r; j ++)\n\t\t{\n\t\t\tFlag[i][j] = (Ret[j] >= Acq[i][j]);\n\t\t\tOk[i] += Flag[i][j];\n\t\t}\n\t\tif (Ok[i] == r) q[++ _r] = i, Inq[i] = 1;\n\t}\n\twhile (_l <= _r)\n\t{\n\t\tint z = q[_l ++];\n\t\tfor (int i = 1; i <= r; i ++)\n\t\t\tRet[i] += _Acq[z][i] - Acq[z][i];\n\t\tfor (int i = 1; i <= p; i ++)\n\t\t{\n\t\t\tif (Inq[i]) continue ;\n\t\t\tfor (int j = 1; j <= r; j ++)\n\t\t\t\tif (!Flag[i][j] && Ret[j] >= Acq[i][j])\n\t\t\t\t{\n\t\t\t\t\tFlag[i][j] = 1;\n\t\t\t\t\tOk[i] ++;\n\t\t\t\t}\n\t\t\tif (Ok[i] == r) q[++ _r] = i, Inq[i] = 1;\n\t\t}\n\t}\n\treturn _r == p;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &p, &r, &t);\n\tfor (int i = 1; i <= r; i ++)\n\t{\n\t\tscanf(\"%d\", Ret + i);\n\t\t_Ret[i] = Ret[i];\n\t}\n\tfor (int i = 1; i <= p; i ++)\n\t\tfor (int j = 1; j <= r; j ++)\n\t\t{\n\t\t\tscanf(\"%d\", Acq[i] + j);\n\t\t\t_Acq[i][j] = Acq[i][j];\n\t\t}\n\tfor (int i = 1; i <= t; i ++)\n\t\tscanf(\"%d%d\", P + i, R + i);\n\tint _l = 0, _r = t + 1;\n\twhile (_l < _r)\n\t{\n\t\tint mid = (_l + _r) >> 1;\n\t\tif (Check(mid)) _l = mid + 1;\n\t\t\telse _r = mid;\n\t}\n\tif (_l == t + 1) puts(\"-1\");\n\t\telse printf(\"%d\\n\", _l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\nusing namespace std;\n\nint n, re, T, ini[305], need[305][305];\nint acq[200005][2];\n\nint cur[305], cneed[305][305];\nbool done[305];\n\nbool ok(int til){\n\tFI(i, 1, re) cur[i] = ini[i];\n\tFI(i, 1, n) FI(j, 1, re) cneed[i][j] = need[i][j];\n\tFI(i, 1, til){\n\t\tcur[acq[i][1]]--;\n\t\tcneed[acq[i][0]][acq[i][1]]--;\n\t}\n\tFI(i, 1, n) done[i] = false;\n\t//can avoid death?\n\tint cnt = 0;\n\twhile(cnt < n){\n\t\tbool lock = true;\n\t\tFI(i, 1, n) if(!done[i]){\n\t\t\tbool feasible = true;\n\t\t\tFI(j, 1, re) if(cneed[i][j] > cur[j]){\n\t\t\t\tfeasible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(feasible){\n\t\t\t\tdone[i] = true;\n\t\t\t\tlock = false;\n\t\t\t\tcnt++;\n\t\t\t\tFI(j, 1, re) cur[j] += need[i][j] - cneed[i][j];\n\t\t\t}\n\t\t}\n\t\tif(lock) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &re, &T);\n\tFI(i, 1, re) scanf(\"%d\", &ini[i]);\n\tFI(i, 1, n) FI(j, 1, re) scanf(\"%d\", &need[i][j]);\n\tFI(i, 1, T) scanf(\"%d %d\", &acq[i][0], &acq[i][1]);\n\tint l = 0, r = T + 1;\n\twhile(r - l > 1){\n\t\tint m = (l + r) >> 1;\n\t\tif(ok(m)) l = m;\n\t\telse r = m;\n\t}\n\tif(r == T + 1) r = -1;\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int p,r,t;\n    cin >> p >> r >> t;\n    vector<int> l(r);\n    for(int i=0;i<r;i++){\n        cin >> l[i];\n    }\n    vector<vector<int> > n(p,vector<int>(r));\n    for(int i=0;i<p;i++){\n        for(int j=0;j<r;j++){\n            cin >> n[i][j];\n        }\n    }\n    vector<int> P(t),R(t);\n    for(int i=0;i<t;i++){\n        cin >> P[i] >> R[i];\n        P[i]--;\n        R[i]--;\n    }\n    int ok = -1;\n    int ng = t+1;\n    while(abs(ok-ng)!=1){\n        int mid = (ok+ng)/2;\n        //cout << mid << endl;\n        vector<int> x(r);\n        vector<vector<int> > y(p,vector<int>(r));\n        for(int i=0;i<r;i++){\n            x[i] = l[i];\n        }\n        for(int i=0;i<p;i++){\n            for(int j=0;j<r;j++){\n                y[i][j] = n[i][j];\n            }\n        }\n        for(int i=0;i<mid;i++){\n            x[R[i]]--;\n            y[P[i]][R[i]]--;\n        }\n        vector<bool> sss(p);\n        for(int z=0;z<p;z++){\n            for(int i=0;i<p;i++){\n                if(sss[i]==1)continue;\n                bool flag = 1;\n                for(int k=0;k<r;k++){\n                    //cout << i << \" \" << k << \" \" << y[i][k] << \" \" <<x[k] << endl;\n                    if(y[i][k]>x[k]){\n                        flag=0;\n                        break;\n                    }\n                }\n                if(flag){\n                    sss[i]=1;\n                    for(int k=0;k<r;k++){\n                        x[k] += n[i][k]-y[i][k];\n                    }\n                }\n            }\n        }\n        bool flag = 1;\n        for(int i=0;i<p;i++){\n            if(sss[i]==0){\n                flag = 0;\n            }\n        }\n        if(flag){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    if(ng==t+1){\n        cout << -1 << endl;\n    }else{\n    cout << ng << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N=305;\nstruct erz{int p,r;}e[200005];\nint a[N][N],nd[N][N],lp[N],dn[N],bg[N],ed[N],nd0[N][N],lp0[N],q[N],J;\nbool cmp(int x,int y) {return(nd[x][J]<nd[y][J]);}\nint check(int n,int m,int t)\n{\n    int i,j,h,sl=n;\n    for (i=1;i<=n;i++) dn[i]=0;\n    for (i=1;i<=m;i++) lp[i]=lp0[i];\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n     {\n         if (nd0[i][j]) dn[i]++;\n         nd[i][j]=nd0[i][j];\n     }\n\n    for (i=1;i<=t;i++)\n    {\n        int pp=e[i].p,rr=e[i].r;\n        nd[pp][rr]--;lp[rr]--;\n        if (!nd[pp][rr]) dn[pp]--;\n        if (!dn[pp]) {sl--;for (j=1;j<=m;j++) lp[j]+=nd0[pp][j];}\n    }\n    if (!sl) return 1;\n    h=1,t=0;\n    for (j=1;j<=m;j++) ed[j]=0;\n    for (i=1;i<=n;i++)\n    {\n        if (!dn[i]) continue;\n        for (j=1;j<=m;j++) if (nd[i][j]>lp[j]) break;\n        if (j==m+1) {dn[i]=0;q[++t]=i;continue;}\n        for (j=1;j<=m;j++) if (nd[i][j]) a[j][++ed[j]]=i;\n    }\n    for (j=1;j<=m;j++) {J=j;bg[j]=1;sort(a[j]+1,a[j]+ed[j]+1,cmp);}\n    while (h<=t)\n    {\n        int x=q[h];sl--;if (!sl) return 1;\n        for (j=1;j<=m;j++)\n        {\n            lp[j]+=nd0[x][j]-nd[x][j];\n            for (i=bg[j];i<=ed[j];i++)\n            {\n                 if (nd[a[j][i]][j]>lp[j]) {bg[j]=i;break;}\n                 dn[a[j][i]]--;if (dn[a[j][i]]) continue;\n                 q[++t]=a[j][i];\n            }\n        }\n        h++;\n    }\n    return 0;\n}\nint main()\n{\n   // freopen(\"Z.in\",\"r\",stdin);freopen(\"Z.out\",\"w\",stdout);\n    int i,j,n,m,t;\n    scanf(\"%d%d%d\",&n,&m,&t);\n    for (i=1;i<=m;i++) scanf(\"%d\",&lp0[i]);\n    for (i=1;i<=n;i++)\n     for (j=1;j<=m;j++)\n      scanf(\"%d\",&nd0[i][j]);\n    for (i=1;i<=t;i++) scanf(\"%d%d\",&e[i].p,&e[i].r);\n    if (check(n,m,t)) {printf(\"-1\\n\");return 0;}\n    int l=1,r=t;\n    while (r-l>1)\n    {\n        int mid=(l+r)/2;\n        if (check(n,m,mid)) l=mid; else r=mid;\n    }\n    printf(\"%d\\n\",r);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    bool check_terminated(vector<int> &need) {\n        bool terminated = true;\n        rep(r, R) terminated &= need[r] == 0;\n        return terminated;\n    }\n    \n    bool is_avoidable(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left = L;\n\n        vector<bool> terminated(P);\n        int terminated_num = 0;\n\n        // O(t * R) ? \n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n            if(left[r] < 0) {\n                return false; // lack of resource !\n            }\n            if(need[p][r] == 0) {\n                if(check_terminated(need[p])) {\n                    rep(r, R) left[r] += N[p][r];\n                    terminated[p] = true;\n                    terminated_num++;                            \n                }\n            }\n        }            \n                \n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) {\n                    if(need[p][r] > left[r]) {\n                        terminatable = false;\n                        break;\n                    }\n                }\n                if(terminatable) {\n                    rep(r, R) {\n                        left[r] += N[p][r];\n                    }\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        // cerr << \"! \" << t << \" \" << terminated_num << endl;\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = 0, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            // cerr << m << \" \" << l << \" \" << r << endl;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int p, r, t;\n    cin >> p >> r >> t;\n    vector<int> l(r);\n    vector<vector<int>> n(p, vector<int>(r));\n    vector<int> P(t), R(t);\n    for(int i = 0; i < r; ++i) {\n        cin >> l[i];\n    }\n    for(int i = 0; i < p; ++i) {\n        for(int j = 0; j < r; ++j) {\n            cin >> n[i][j];\n        }\n    }\n    for(int i = 0; i < t; ++i) {\n        cin >> P[i] >> R[i];\n        P[i]--; R[i]--;\n    }\n\n    int lb = 0, ub = t + 1;\n    while(ub - lb > 1) {\n        int m = (lb + ub) / 2;\n        vector<int> available = l;\n        vector<vector<pii>> need_r(r, vector<pii>(p));\n        vector<vector<int>> used_r(p, vector<int>(r));\n        vector<int> pos(r), cnt(p);\n        queue<int> term_process;\n        for(int i = 0; i < r; ++i) {\n            for(int j = 0; j < p; ++j) {\n                need_r[i][j] = make_pair(n[j][i], j);\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            available[R[i]]--;\n            need_r[R[i]][P[i]].first--;\n            used_r[P[i]][R[i]]++;\n        }\n        for(int i = 0; i < r; ++i) {\n            sort(begin(need_r[i]), end(need_r[i]));\n        }\n        for(int i = 0; i < r; ++i) {\n            while(pos[i] < p && (need_r[i][pos[i]].first == 0 || available[i] >= need_r[i][pos[i]].first)) {\n                int process_id = need_r[i][pos[i]].second;\n                if(++cnt[process_id] == r) {\n                    term_process.push(process_id);\n                }\n                pos[i]++;\n            }\n        }\n        while(!term_process.empty()) {\n            int idx = term_process.front();\n            term_process.pop();\n            for(int i = 0; i < r; ++i) {\n                available[i] += used_r[idx][i];\n                while(pos[i] < p && available[i] >= need_r[i][pos[i]].first) {\n                    int process_id = need_r[i][pos[i]].second;\n                    if(++cnt[process_id] == r) {\n                        term_process.push(process_id);\n                    }\n                    pos[i]++;\n                }\n            }\n        }\n        if(count(begin(cnt), end(cnt), r) == p) {\n            lb = m;\n        } else {\n            ub = m;\n        }\n    }\n    if(ub == t + 1) {\n        cout << -1 << endl;\n    } else {\n        cout << ub << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint P,R,T;\nint init[303];\nint need[303][303];\nint p[200001],r[200001];\n\nbool f(int t){\n  vector<int> crtr(R);\n  vector<vector<int> > crtp(P,vector<int>(R));\n  vector<int> crtnz(P,0);\n  vector<bool> used(P,false);\n\n  rep(i,R)crtr[i]=init[i];\n  rep(i,P)rep(j,R)crtp[i][j]=need[i][j];\n  rep(i,P)rep(j,R)if(crtp[i][j]==0)crtnz[i]++;\n  rep(i,t){\n    crtr[r[i]]--;\n    crtp[p[i]][r[i]]--;\n    if(crtr[r[i]]<0)return false;\n    if(crtp[p[i]][r[i]]==0)crtnz[p[i]]++;\n    if(crtnz[p[i]]==R){\n      used[p[i]]=true;\n      rep(j,R)crtr[j]+=need[p[i]][j];\n    }\n  }\n\n  bool update=true;\n  while(update){\n    update=false;\n    rep(i,P){\n      if(used[i])continue;\n      bool ok=true;\n      rep(j,R)if(crtp[i][j]>crtr[j])ok=false;\n      if(!ok)continue;\n      rep(j,R)crtr[j]+=need[i][j]-crtp[i][j];\n      used[i]=true;\n      update=true;\n      break;\n    }\n  }\n  bool ok=true;\n  rep(i,P)if(!used[i])ok=false;\n  return ok;\n}\n\nint main(){\n  scanf(\"%d%d%d\",&P,&R,&T);\n  rep(i,R)scanf(\"%d\",init+i);\n  rep(i,P)rep(j,R)scanf(\"%d\",&need[i][j]);\n  rep(i,T){\n    scanf(\"%d%d\",p+i,r+i);\n    p[i]--;r[i]--;\n  }\n\n  int lb=0,ub=T+1;\n  while(ub-lb>1){\n    int mid=(lb+ub)/2;\n    if(f(mid))lb=mid;\n    else ub=mid;\n  }\n  if(ub==T+1)cout<<-1<<endl;\n  else cout<<ub<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N, r, t;\nint res[300];\nint need[300][300];\nint R[200000];\nint P[200000];\ntypedef pair<int, int> Pii;\n\nbool check(int x){\n\tint sum[300][300] = { 0 };\n\tint rem[300] = { 0 };\n\tmemcpy(rem, res, sizeof res);\n\n\tfor(int i = 0; i < x; i++){\n\t\t//if(rem[R[i]] == 0) return false;\n\t\trem[R[i]]--;\n\t\tsum[P[i]][R[i]]++;\n\t}\n\tint fin[300] = { 0 };\n\tfor(int i = 0; i < N; i++){\n\t\tint cnt = 0;\n\t\tfor(int j = 0; j < r; j++){\n\t\t\tif(sum[i][j] == need[i][j]) cnt++;\n\t\t}\n\t\tif(cnt == r){\n\t\t\tfin[i] = 1;\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\trem[j] += sum[i][j];\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tbool update = false;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(fin[i]) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tint c = need[i][j] - sum[i][j];\n\t\t\t\tif(c <= rem[j]) cnt++;\n\t\t\t}\n\t\t\tif(cnt == r){\n\t\t\t\tfin[i] = 1;\n\t\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\t\trem[j] += sum[i][j];\n\t\t\t\t}\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif(!update) break;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tif(fin[i] == 0) return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> N >> r >> t){\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tcin >> res[i];\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tcin >> need[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tcin >> P[i] >> R[i];\n\t\t\tP[i]--, R[i]--;\n\t\t}\n\n\t\tfor(int i = 0; i <= t; i++){\n\t\t\t//cout << i << \" \" << check(i) << endl;\n\t\t}\n\n\t\tif(check(t)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ok = 0, ng = t;\n\t\twhile(abs(ok - ng) > 1){\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\n\t\tcout << ng << endl;\n\t\t//cout << \"---------------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nint l[305];\nint n[305][305];\nint nn[305][305];\nint P[200005], R[200005];\nint bu[305];\nint z[305];\nint cnt = 0;\n\nint main() {\n    int p, t, r;\n    scanf(\"%d%d%d\",&p,&r,&t);\n    for(int i = 1; i <= r; i++) scanf(\"%d\",&l[i]);\n    for(int i = 1; i <= p; i++) {\n        for(int j = 1; j <= r; j++){\n            scanf(\"%d\",&n[i][j]);\n            nn[i][j] = n[i][j];\n            if(n[i][j] > l[j]) bu[i]++;\n            if(n[i][j]) z[i]++;\n        }\n        if(!bu[i]) cnt++;\n    }\n    for(int i = 1; i <= t; i++) scanf(\"%d%d\",&P[i],&R[i]);\n    if(!cnt) {\n        printf(\"0\\n\");\n        return 0;\n    }\n    for(int i = 1; i <= t; i++) {\n        if(!n[P[i]][R[i]]) {\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n        n[P[i]][R[i]]--;\n        l[R[i]]--;\n        if(!n[P[i]][R[i]]) z[P[i]]--;\n\n        if(!z[P[i]]) {\n            for(int j = 1; j <= r; j++) {\n                l[j] += nn[P[i]][j];\n\n                cnt = 0;\n                memset(bu,0,sizeof(bu));\n\n                for(int i = 1; i <= p; i++) {\n                    for(int j = 1; j <= r; j++){\n                        if(n[i][j] > l[j]) bu[i]++;\n                    }\n                    if(!bu[i]) cnt++;\n                }\n\n            }\n        }\n\n        for(int j = 1; j <= p; j++) {\n            if(n[j][R[i]] == l[R[i]] + 1) {\n                bu[j]++;\n                if(bu[j] == 1) cnt--;\n            }\n        }\n        if(!cnt) {\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n\n    }\n    printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int p,r,t;\n    cin >> p >> r >> t;\n    vector<int> l(r);\n    for(int i=0;i<r;i++){\n        cin >> l[i];\n    }\n    vector<vector<int> > n(p,vector<int>(r));\n    for(int i=0;i<p;i++){\n        for(int j=0;j<r;j++){\n            cin >> n[i][j];\n        }\n    }\n    vector<int> P(t),R(t);\n    for(int i=0;i<t;i++){\n        cin >> P[i] >> R[i];\n        P[i]--;\n        R[i]--;\n    }\n    int ok = -1;\n    int ng = t+1;\n    while(abs(ok-ng)!=1){\n        int mid = (ok+ng)/2;\n        //cout << mid << endl;\n        vector<int> x(r);\n        vector<vector<int> > y(p,vector<int>(r));\n        for(int i=0;i<r;i++){\n            x[i] = l[i];\n        }\n        for(int i=0;i<p;i++){\n            for(int j=0;j<r;j++){\n                y[i][j] = n[i][j];\n            }\n        }\n        for(int i=0;i<mid;i++){\n            x[R[i]]--;\n            y[P[i]][R[i]]--;\n            if(y[P[i]][R[i]]==0){\n                y[P[i]][R[i]]=n[P[i]][R[i]];\n                x[R[i]] += n[P[i]][R[i]];\n            }\n        }\n        vector<bool> sss(p);\n        for(int z=0;z<p;z++){\n            for(int i=0;i<p;i++){\n                if(sss[i]==1)continue;\n                bool flag = 1;\n                for(int k=0;k<r;k++){\n                    //cout << i << \" \" << k << \" \" << y[i][k] << \" \" <<x[k] << endl;\n                    if(y[i][k]>x[k]){\n                        flag=0;\n                        break;\n                    }\n                }\n                if(flag){\n                    sss[i]=1;\n                    for(int k=0;k<r;k++){\n                        x[k] += n[i][k]-y[i][k];\n                    }\n                }\n            }\n        }\n        bool flag = 1;\n        for(int i=0;i<p;i++){\n            if(sss[i]==0){\n                flag = 0;\n            }\n        }\n        if(flag){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    if(ng==t+1){\n        cout << -1 << endl;\n    }else{\n    cout << ng << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint p,r,t;\nint L[333];\nint lmp[333];\nint tmp[333][333];\nint n[333][333];\nbool used[333];\nint C[333];\nvector<P> D;\n\nbool isRelease( int id ){\n  for(int i=0;i<r;i++)\n    if( n[id][i] > L[i] ) return false;\n  return true;\n}\n\nbool check(int h){\n\n  for(int i=0;i<r;i++) L[i] = lmp[i];\n  for(int i=0;i<p;i++){\n    C[i] = r;\n    for(int j=0;j<r;j++){\n      n[i][j] = tmp[i][j];\n      if( n[i][j] == 0 ) C[i]--;\n    }\n  }\n  \n  for(int i=0;i<h;i++){\n    L[ D[i].second ]--;    \n    n[ D[i].first ][ D[i].second ]--;\n    if( n[ D[i].first ][ D[i].second ] == 0 ) C[ D[i].first ]--;\n\n    if( C[ D[i].first ] == 0 ) {\n      for(int j=0;j<r;j++)\n        L[ j ] += tmp[ D[i].first ][ j ];      \n    }\n  }\n\n  /*\n  cout << \"time : \" <<  h << endl;\n  for(int i=0;i<r;i++) cout << L[i]<< \" \";\n  cout << endl;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<r;j++) cout << n[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n  for(int i=0;i<r;i++)\n    if( L[i] < 0 ) return true;\n\n  bool loop = true;\n  memset( used,0,sizeof( used ));\n  while( loop ){\n    loop = false;\n    for(int i=0;i<p;i++){\n      if( used[i] ) continue;\n      if( isRelease( i ) ) {\n        for(int j=0;j<r;j++)\n          L[ j ] += tmp[i][j] - n[i][j];\n        used[i] = true;\n        loop = true;\n      }\n    }\n  }\n\n  for(int i=0;i<p;i++)\n    if( !used[i] ) return true;\n  return false;\n  \n}\n\nint main(){\n  cin >> p >> r >> t;\n  D.resize( t );\n  for(int i=0;i<r;i++) {\n    cin >> L[i]; lmp[i] = L[i];\n  }\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++){\n      cin >> n[i][j];\n      tmp[i][j] = n[i][j];\n    }\n  for(int i=0;i<t;i++){\n    cin >> D[i].first >> D[i].second;\n    D[i].first--; D[i].second--;\n  }\n\n  int st = 0, ed = t;\n  int res = -1;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( check( h ) ) {\n      ed = h-1; res = h;\n    } else {\n      st = h+1;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    if(B[p][q]==0)continue;\n    A[q]--;\n    if(A[q]<0)return false;\n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0)\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n  }\n\n\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint p,r,t;\nint l[333];\nint n[333][333];\nint P[214514],R[214514];\nvector<int> v[333][333];\nbool check(int T){\n  int x[333][333]={},y[333][333]={},z[333]={};\n  for(int j=0;j<r;j++) z[j]=l[j];\n  int cnt=0;\n  bool used[333]={};\n  for(int i=0;i<p;i++){\n    bool flg=1;\n    for(int j=0;j<r;j++){\n      //for(int k:v[i][j]) cout<<\"-\"<<k;cout<<endl;\n      int k=v[i][j].end()-upper_bound(v[i][j].begin(),v[i][j].end(),T);\n      //cout<<T<<\":\"<<*upper_bound(v[i][j].begin(),v[i][j].end(),T)<<endl;\n      x[i][j]=v[i][j].size()-k;\n      y[i][j]=n[i][j]-x[i][j];\n      //cout<<i<<\" \"<<j<<\":\"<<x[i][j]<<\" \"<<y[i][j]<<endl;\n      z[j]-=x[i][j];\n      flg&=x[i][j]==n[i][j];\n    }\n    if(flg){\n      for(int j=0;j<r;j++)\n\tz[j]+=x[i][j];\n      used[i]=1;\n      cnt++;\n    }\n  }\n  //for(int j=0;j<r;j++) cout<<z[j]<<\" \";cout<<endl;\n  while(1){\n    bool flg=0;\n    for(int i=0;i<p;i++){\n      if(used[i]) continue;\n      bool tmp=1;\n      for(int j=0;j<r;j++)\n\ttmp&=y[i][j]<=z[j];\n      if(!tmp) continue;\n      flg=used[i]=1;cnt++;\n      for(int j=0;j<r;j++) z[j]+=x[i][j];\n    }\n    if(!flg) break;\n  }\n  //cout<<T<<\":\"<<cnt<<\" \"<<p<<endl;\n  return cnt==p;\n}\nsigned main(){\n  scanf(\"%lld %lld %lld\",&p,&r,&t);\n  for(int i=0;i<r;i++) scanf(\"%lld\",l+i);\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++)\n      scanf(\"%lld\",n[i]+j);\n  for(int i=0;i<t;i++) scanf(\"%lld %lld\",P+i,R+i);\n  for(int i=0;i<t;i++){\n    P[i]--;R[i]--;\n    v[P[i]][R[i]].push_back(i+1);\n  }\n  if(check(t+1)){\n    puts(\"-1\");\n    return 0;\n  }\n  int X=0,Y=t+1;\n  while(X+1<Y){\n    int Z=(X+Y)/2;\n    if(check(Z)) X=Z;\n    else Y=Z;\n  }\n  printf(\"%lld\\n\",Y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint main(){\n    iostream_init();\n    int P, R, K;\n    while(cin >> P >> R >> K) {\n        vector<int> all(R);\n        vector<vector<int>> need_(P, vector<int>(R, 0));\n        vector<bool> used(P, true);\n\n        REP(i, R) cin >> all[i];\n        REP(i, P) REP(j, R) cin >> need_[i][j];\n\n        vector<int> X(K);\n        vector<int> Y(K);\n        REP(i, K) cin >> X[i] >> Y[i];\n        REP(i, K) X[i]--;\n        REP(i, K) Y[i]--;\n\n        auto check = [&](int T) {\n            vector<int> cur = all;\n            vector<vector<int>> need = need_;\n            vector<vector<int>> take(P, vector<int>(R, 0));\n            vector<int> have(P);\n\n            REP(i, T) {\n                cur[ Y[i] ]--;\n                need[ X[i] ][ Y[i] ]--;\n                take[ X[i] ][ Y[i] ]++;\n                have[ X[i] ]++;\n            }\n\n            while(true) {\n                bool updated = false;\n                REP(i, P) if(have[i] > 0) {\n                    bool ok = true;\n                    REP(j, R) if(need[i][j] > cur[j]){ ok = false; break; }\n                    if(ok) {\n                        updated = true;\n                        have[i] = 0;\n                        REP(j, R) cur[j] += take[i][j];\n                    }\n                }\n                if(!updated) break;\n            }\n            bool ok = true;\n            REP(i, P) if(have[i]) ok = false;\n            return ok;\n        };\n\n        if(check(K)) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        int lb = 0, ub = K + 1;\n        // [lb, ub)\n        while(ub - lb > 1) {\n            int T = (lb + ub) / 2;\n            if(check(T)) {\n                lb = T;\n            } else {\n                ub = T;\n            }\n        }\n        cout << ub << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    // O(t)\n    tuple<vector<vector<int>>, vector<int>> calc_state(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left;\n        left = L;\n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n        }\n        cerr << \"state t = \" << t << endl;\n        cerr << \"left \" << left << endl;\n        cerr << need << endl;\n        return make_tuple(need, left);\n    }\n\n    bool is_avoidable(int t) {\n        vector<vector<int>> need;\n        vector<int> left;\n        tie(need, left) = calc_state(t);\n        \n        // check lack of resource\n        for(int l : left) if(l < 0) return false;\n        \n        vector<bool> terminated(P);\n        int terminated_num = 0;\n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) {\n                    if(need[p][r] > left[r]) {\n                        terminatable = false;\n                        break;\n                    }\n                }\n                if(terminatable) {\n                    rep(r, R) {\n                        left[r] += N[p][r];\n                    }\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        cerr << \"! \" << t << \" \" << terminated_num << endl;\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = 0, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n\nint p, r, t;\nint L[320], tL[320], R[302][302], tR[302][302];\nint P[320][2];\nint End[320];\n\nbool is_dead(int tim){\n\trep(i, p)End[i] = 0;\n\trep(i, p){\n\t\trep(j, r)tR[i][j] = R[i][j];\n\t}\n\trep(i, r)tL[i] = L[i];\n\t\n\tfor(int i=0;i<tim;i++){\n\t\t\n\t\tint x = P[i][0], y = P[i][1];\n\t\ttR[x][y]--, tL[y]--;\n\t\tint c;\n\t\tfor(c=0;c<r;c++)if(tR[x][c] != 0)break;\n\t\t\n\t\tif(c == r){\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\ttL[j] += R[x][j];\n\t\t\t}\n\t\t\tEnd[x] = 1;\n\t\t}\n\t}\n\t\n\t\n\twhile(1){\n\t\tint changed = 0;\n\t\trep(i, p){\n\t\t\tif(End[i])continue;\n\t\t\tint c;\n\t\t\tfor(c=0;c<r;c++)if(tL[c] < tR[i][c])break;\n\t\t\t\n\t\t\tif(c == r){\n\t\t\t\trep(j, r){\n\t\t\t\t\ttL[j] += R[i][j] - tR[i][j];\n\t\t\t\t}\n\t\t\t\tEnd[i] = 1;\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t}\n\t\tif(changed == 0)break;\n\t}\n\t\n\t//rep(i, p)printf(\"%d\", End[i]);\n\t\n\tbool res = 0;\n\trep(i, p)res |= !End[i];\n\treturn res;\n}\n\nvoid solve(int tc){\n\tscanf(\"%d%d%d\", &p, &r, &t);\n\tfor(int i=0;i<r;i++)scanf(\"%d\", L+i);\n\tfor(int i=0;i<p;i++){\n\t\tfor(int j=0;j<r;j++)scanf(\"%d\", R[i]+j);\n\t}\n\tfor(int i=0;i<t;i++)scanf(\"%d%d\", P[i], P[i]+1);\n\tfor(int i=0;i<t;i++)P[i][0]--, P[i][1]--;\n\t\n\tint low = 1, high = t, ans = -1;\n\twhile(low <= high){\n\t\tint mid = (low + high) / 2;\n\t\tif(is_dead(mid))ans = mid, high = mid - 1;\n\t\telse low = mid + 1;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1;// scanf(\"%d\",&Tc);\n\tfor(int i=1;i<=Tc;i++){\n\t\tsolve(i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    \n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0){\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n    }\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n    assert(cnt[i]==0);\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++)scanf(\"%d\",&a[i]);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      scanf(\"%d\",&b[i][j]);\n\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  \n  if(check(K))left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    if(B[p][q]==0)continue;\n    \n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0)\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305, T = 2e5 + 5;\nint L[N], ava[N], need[N][N], has[N][N], a[T], b[T];\nbool done[N];\nint got[N];\nint main() {\n\tint p, r, t;\n\tscanf(\"%d%d%d\", &p, &r, &t);\n\tfor (int i = 1; i <= r; ++ i) scanf(\"%d\", &L[i]);\n\tfor (int i = 1; i <= p; ++ i) {\n\t\tfor (int j = 1; j <= r; ++ j) scanf(\"%d\", &need[i][j]);\n\t}\n\tfor (int i = 1; i <= t; ++ i) scanf(\"%d%d\", &a[i], &b[i]);\n\tint l = 1, R = t, ans = -1;\n\twhile (l <= R) {\n\t\tint mid = (l + R) / 2;\n\t\tmemset(has, 0, sizeof(has));\n\t\tmemset(ava, 0, sizeof(ava));\n\t\tmemset(got, 0, sizeof(got));\n\t\tmemset(done, 0, sizeof(done));\n\t\tfor (int i = 1; i <= r; ++ i) ava[i] = L[i];\n\t\tint dones = 0;\n\t\tfor (int i = 1; i <= p; ++ i) {\n\t\t\tfor (int j = 1; j <= r; ++ j) if (need[i][j] == 0) {\n\t\t\t\tgot[i] ++;\n\t\t\t\tif (got[i] == r) {\n\t\t\t\t\tdone[i] = 1;\n\t\t\t\t\tdones ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= mid; ++ i) {\n\t\t\thas[a[i]][b[i]] ++;\n\t\t\tava[b[i]] --;\n\t\t\tif (has[a[i]][b[i]] == need[a[i]][b[i]]) {\n\t\t\t\tgot[a[i]] ++;\n\t\t\t\tif (got[a[i]] == r) {\n\t\t\t\t\tdone[a[i]] = 1;\n\t\t\t\t\tdones ++;\n\t\t\t\t\tfor (int j = 1; j <= r; ++ j) ava[j] += need[a[i]][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = 1;\n\t\twhile (flag) {\n\t\t\tflag = 0;\n\t\t\tfor (int i = 1; i <= p; ++ i) {\n\t\t\t\tif (done[i]) continue;\n\t\t\t\tbool can = 1;\n\t\t\t\tfor (int j = 1; j <= r; ++ j) if (ava[j] + has[i][j] < need[i][j]) {\n\t\t\t\t\tcan = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (can) {\n\t\t\t\t\tdone[i] = 1;\n\t\t\t\t\tdones ++;\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tfor (int j = 1; j <= r; ++ j) ava[j] += has[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dones == p) {\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tR = mid - 1;\n\t\t\tans = mid;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n/*\n  ????????§????????§?????????????????????????????????????????????????????????\n  ??????????????????????????????????????????????????????, ?????¨??????????????????????????????????????°????±??????????????????°????????????\n  O(P)?¨??????§?????????????????????????????§????????????\n  ?§£?????§?????????????????????????§£??????????????¨, ????????????????¶???????????????????????????¨????????±\n  ????????????????????????\n */\n\nint P,R,T;\nint L[301];\nint N[301][301];\nint PS[200010];\nint RS[200010];\n\n// ??°????????????????????????????????????????????????\nint user[301][301];\n// ??????????????????????????????????????£????????????\nint leftr[301];\n\nbool check(int mid){\n    // mid???????????§, ??????????????????????????????????????§????????????\n    // ??????????????????????????????????´???????????????????????????????????????????\n    // resource??????????????????????????????????´????, ?????????resource????§£???????????????\n    memset(user,0,sizeof(user));\n    for(int i = 0; i < R; i++)\n        leftr[i] = L[i];\n    // mid???????´??????§, ?¨??????????\n    for(int i = 0; i <= mid; i++){\n        int who = PS[i];  who--;\n        int where = RS[i]; where--;\n        user[who][where]++;\n        leftr[where]--;\n    }\n    for(int i = 0; i < P; i++){\n        int cnt = 0;\n        for(int j = 0; j < R; j++) if(user[i][j] == N[i][j]) cnt++;\n        if(cnt == R){\n            for(int j = 0; j < R; j++){\n                user[i][j] = 0;\n                leftr[j] += N[i][j];\n            }\n        }\n    }\n    \n    // ???????????§, resource???????????????????????????????????????????±????, ??????????????????????§£?????§??????????????????\n    // ?§£?????§????????????ok\n    // ????????????ng\n    bool is_updated = true;\n    while(is_updated){\n        is_updated = false;\n        for(int i = 0; i < P; i++){\n            int cnt = 0;\n            for(int j = 0; j < R; j++)\n                cnt += user[i][j];\n            if(cnt != 0){\n                int free = 0;\n                // ?§£?????§??????????????????\n                for(int j = 0; j < R; j++){\n                    if(user[i][j] + leftr[j] >= N[i][j]){\n                        free++;\n                    }\n                }\n                if(free == R){\n                    is_updated = true;\n                    for(int j = 0; j < R; j++){\n                        leftr[j] += user[i][j];\n                        user[i][j] = 0;\n                    }\n                    break;\n                }\n                else{\n                    continue;\n                }\n            }\n\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < P; i++){\n        for(int j = 0; j < R; j++)\n            cnt += user[i][j];\n    }\n    return cnt > 0;\n}\n\nint main(){\n\n    cin>>P>>R>>T;\n    for(int i=0;i<R;i++)cin>>L[i];\n    for(int i=0;i<P;i++)\n        for(int j=0;j<R;j++)\n            cin>>N[i][j];\n    for(int i=0;i<T;i++)cin>>PS[i]>>RS[i];\n    \n    // ????????????????????????????????????????????§, ?????????????????§???????????????????????????????????????????????????????????¢?´¢\n    // ?????????????????????????????´???????????????\n    int lb = -1;\n    int ub = T;\n    while(ub - lb > 1){\n        int mid = (ub + lb) / 2;\n        if(check(mid)) ub = mid;\n        else lb = mid;\n    }\n    if(ub == T) cout<<-1<<endl;\n    else cout<<ub+1<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,r,t;\nint l[301];\nint p[200001],req[200001];\nint fie[301][301];\nint tmpf[301][301];\nint tmpl[301];\nint cnt[301];\nbool used[301];\n\nbool C(int vt){\n\tmemset(used,0,sizeof(used));\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<r;i++){\n\t\ttmpl[i]=l[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<r;j++){\n\t\t\ttmpf[i][j]=0;\n\t\t\tif(tmpf[i][j]==fie[i][j])cnt[i]++;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(cnt[i]==r){\n\t\t\tused[i]=true;\n\t\t}\n\t}\n\tint restcnt=n;\n\tfor(int i=0;i<vt;i++){\n\t\tif(tmpl[req[i]]==0)continue;\n\t\ttmpf[p[i]][req[i]]++;\n\t\ttmpl[req[i]]--;\n\t\tif(tmpf[p[i]][req[i]]==fie[p[i]][req[i]])cnt[p[i]]++;\n\t\tif(cnt[p[i]]==r){\n\t\t\tused[p[i]]=true;\n\t\t\trestcnt--;\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\ttmpl[j]+=tmpf[p[i]][j];\n\t\t\t}\n\t\t}\n\t}\n\tbool update=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\tif(fie[i][j]-tmpf[i][j]>tmpl[j])flag=false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tused[i]=true;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\trestcnt--;\n\t\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\t\ttmpl[j]+=tmpf[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (restcnt>0);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&r,&t);\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d\",&l[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<r;j++){\n\t\t\tscanf(\"%d\",&fie[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<t;i++){\n\t\tscanf(\"%d%d\",&p[i],&req[i]);\n\t\tp[i]--;\n\t\treq[i]--;\n\t}\n\tint l=0,r=t+1;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d\\n\",r==(t+1)?-1:r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int P, R, T, L[300], N[300][300];\n  int latte[200000], malta[200000];\n\n\n  cin >> P >> R >> T;\n  for(int i = 0; i < R; i++) {\n    cin >> L[i];\n  }\n  for(int i = 0; i < P; i++) {\n    for(int j = 0; j < R; j++) {\n      cin >> N[i][j];\n    }\n  }\n  for(int i = 0; i < T; i++) {\n    cin >> latte[i] >> malta[i];\n    --latte[i];\n    --malta[i];\n  }\n\n  int ok = -1, ng = T;\n  while(ng - ok > 1) {\n    int mid = (ok + ng) / 2;\n    ([&]\n     {\n       vector< vector< int > > need(P, vector< int >(R));\n       vector< int > available(R);\n       for(int i = 0; i < P; i++) {\n         for(int j = 0; j < R; j++) need[i][j] = N[i][j];\n       }\n       for(int i = 0; i < R; i++) available[i] = L[i];\n\n       for(int i = 0; i <= mid; i++) {\n         --need[latte[i]][malta[i]];\n         --available[malta[i]];\n       }\n\n       vector< int > live(P);\n       iota(begin(live), end(live), 0);\n\n       int sum = 0;\n       while(!live.empty()) {\n         vector< int > nxt;\n         bool update = false;\n         for(int i : live) {\n           bool f = true;\n           for(int j = 0; j < R; j++) f &= need[i][j] <= available[j];\n           if(f) {\n             update = true;\n             for(int j = 0; j < R; j++) available[j] += N[i][j] - need[i][j];\n           } else {\n             nxt.push_back(i);\n           }\n         }\n         if(!update) return (false);\n         swap(nxt, live);\n       }\n       return (true);\n     }() ? ok : ng) = mid;\n  }\n  if(ok >= T - 1) cout << -1 << endl;\n  else cout << ok + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n#define RREP(i, n) for(int i=n-1;i>=0;i--)\n#define RREPS(i, n) for(int i=n;i>0;i--)\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define pb push_back\n#define eb emplace_back\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint n, m, q;\n\nint check(const vector<vi> &req, const vector<vi> &rest, vi ave, int debug = 0){\n\tvi target;\n\tREP(i, n) if(accumulate(ALL(rest[i]), 0)) target.pb(i);\n\trandom_shuffle(ALL(target));\n\twhile(1){\n\t\tint update = false;\n\t\tREP(ii, target.size()){\n\t\t\tint i = target[ii];\n\t\t\tint ok = 1;\n\t\t\tREP(j, m)if(ave[j] < rest[i][j]){\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tREP(j, m) ave[j] += req[i][j] - rest[i][j];\n\t\t\t\tswap(target[ii], target.back());\n\t\t\t\ttarget.pop_back();\n\t\t\t\tii --;\n\t\t\t\tupdate = 1;\n\t\t\t}\n\t\t}\n\t\tif(!update) break;\n\t}\n\treturn target.empty();\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tvi res(m);\n\tvector<vi> req(n, vi(m));\n\tREP(i, m) scanf(\"%d\", &res[i]);\n\tREP(i, n)REP(j, m) scanf(\"%d\", &req[i][j]);\n\tvector<pii> query;\n\tREP(i, q){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);a --; b --;\n\t\tquery.eb(a, b);\n\t}\n\tint l = 0, r = q+1; // [0, l): ok, [0, r): NG\n\t\n\tvi checking(m);\n\tiota(ALL(checking), 0);\n\trandom_shuffle(ALL(checking));\n\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tauto rest = req;\n\t\tauto ave = res;\n\t\tREP(i, mid){\n\t\t\tint a, b;\n\t\t\ttie(a, b) = query[i];\n\t\t\trest[a][b] --;\n\t\t\tave[b] --;\n\t\t\tint f = 1;\n\t\t\tfor(int j : checking){\n\t\t\t\tif(rest[a][j]){\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tfor(int j : checking) ave[j] += req[a][j];\n\t\t\t}\n\t\t}\n\t\tif(check(req, rest, ave)) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == q) cout << -1 << endl;\n\telse cout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, e) for(int i = (s); i < (e); i++)\n#define FOE(i, s, e) for(int i = (s); i <= (e); i++)\n#define FOD(i, s, e) for(int i = (s); i >= (e); i--)\n\nint n, m, x, y, z, k, w, no_satis, t;\nint tot[305], A[305][305], resource[305], remain[305], have[305][305], tot_need[305], need[305][305], satis[305];\nint C[200005], D[200005];\n\nint main ()\n{\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\t\n\tFOE(i, 1, m) scanf(\"%d\", &resource[i]);\n\tFOE(i, 1, n) FOE(j, 1, m) scanf(\"%d\", &A[i][j]);\n\t\n\t\n\tFOE(i, 1, t) scanf(\"%d %d\", &C[i], &D[i]);\n\t\n\tint high = t + 1, low = -1, mid;\n\t\n\tFOE(i, 1, m) remain[i] = resource[i];\n\tFOE(i, 1, t)\n\t{\n\t\tremain[D[i]]--;\n\t\tif (remain[D[i]] < 0) { high = i; break; }\n\t}\n\t\n\twhile (high - low > 1)\n\t{\n\t\tmid = (high + low) / 2;\n\t\t\n\t\tFOE(i ,1, m) remain[i] = resource[i];\n\t\tFOE(i, 1, n) FOE(j, 1, m) { need[i][j] = A[i][j]; have[i][j] = 0; }\n\t\tFOE(i, 1, n) satis[i] = 0;\n\t\t\n\t\tFOE(i, 1, mid) \n\t\t{\n\t\t\tremain[D[i]]--;\n\t\t\tneed[C[i]][D[i]]--;\n\t\t\thave[C[i]][D[i]]++;\n\t\t}\n\t\t\n\t\tno_satis = 0;\n\t\t\n\t\tFOE(times, 1, n)\n\t\t{\n\t\t\tFOE(i, 1, n) \n\t\t\t{\n\t\t\t\tx = 1;\n\t\t\t\tif (satis[i] == 1) continue;\n\t\t\t\t\n\t\t\t\tFOE(j, 1, m) if (need[i][j] > remain[j]) { x = 0; break; }\n\t\t\t\tif (x == 0) continue;\n\t\t\t\t\n\t\t\t\tFOE(j, 1, m) remain[j] += have[i][j];\n\t\t\t\t\n\t\t\t\tno_satis++;\n\t\t\t\tsatis[i] = 1;\n\t\t\t}\n\t\t\t\n\t\t//\tprintf(\"sat: \");\n\t\t//\tFOE(i, 1, n) printf(\"%d \", satis[i]);\n\t\t}\n\t\t\n\t\tif (no_satis == n) low = mid;\n\t\telse high = mid;\t\n\t}\n\t\n\tif (high == t + 1) high = -1;\n\tprintf(\"%d\\n\", high);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\nusing namespace std;\n\nint n, re, T, ini[305], need[305][305];\nint acq[200005][2];\n\nint cur[305], cneed[305][305];\nbool done[305];\n\nbool ok(int til){\n\tFI(i, 1, re) cur[i] = ini[i];\n\tFI(i, 1, n) FI(j, 1, re) cneed[i][j] = need[i][j];\n\tFI(i, 1, til){\n\t\tcur[acq[i][1]]--;\n\t\tcneed[acq[i][0]][acq[i][1]]--;\n\t}\n\tFI(i, 1, n) done[i] = false;\n\t//can avoid death?\n\tint cnt = 0;\n\twhile(cnt < n){\n\t\tbool lock = true;\n\t\tFI(i, 1, n) if(!done[i]){\n\t\t\tbool feasible = true;\n\t\t\tFI(j, 1, re) if(cneed[i][j] > cur[j]){\n\t\t\t\tfeasible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(feasible){\n\t\t\t\tlock = false;\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(lock) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &re, &T);\n\tFI(i, 1, re) scanf(\"%d\", &ini[i]);\n\tFI(i, 1, n) FI(j, 1, re) scanf(\"%d\", &need[i][j]);\n\tFI(i, 1, T) scanf(\"%d %d\", &acq[i][0], &acq[i][1]);\n\tint l = -1, r = T + 1;\n\twhile(r - l > 1){\n\t\tint m = (l + r) >> 1;\n\t\tif(ok(m)) l = m;\n\t\telse r = m;\n\t}\n\tif(r == T + 1) r = -1;\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint change(char ch){\n  if('A'<=ch&&ch<='Z'){\n    return ch-'A';\n  }else{\n    return 26+ch-'a';\n  }\n}\n\nint N;\nlong double po[60];\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  long double cost;\n  int rev;\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nlong double h[MAX_V];\nlong double dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nlong double eps=0.00000001;\n\nvoid add_edge(int from,int to,int cap,long double cost){\n  G[from].push_back( (edge){to,cap,cost,(int)G[to].size() } );\n  G[to].push_back(   (edge){from,0,-cost,(int)G[from].size()-1 } );\n}\n\ntypedef pair< long double , int > P;\n\nlong double min_cost_flow(int s,int t,int f){\n  long double res=0;\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, po[59]);\n    dist[s]=0;\n    Q.push(P(0,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&dist[e.to]-eps>dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          Q.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==po[59])return -1;\n    for(int v=0;v<MAX_V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=(long double)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  po[0]=1;\n\n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< char , int > cnt;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      cnt[ change(ch) ]++;\n      mp[i][j]=ch;\n    }\n  }\n\n  po[0]=1;\n  for(int i=1;i<60;i++){\n    po[i]=po[i-1]*( long double)( cnt[i-1]+1 );\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      add_edge(i,N+j,1,po[ change(mp[i][j]) ]);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    add_edge(si,i,1,0);\n    add_edge(N+i,ti,1,0);\n  }\n\n  long double ansf=min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\nusing namespace std;\n\nint n, re, T, ini[305], need[305][305];\nint acq[200005][2];\n\nint cur[305], cneed[305][305];\nbool done[305];\n\nbool ok(int til){\n\tFI(i, 1, re) cur[i] = ini[i];\n\tFI(i, 1, n) FI(j, 1, re) cneed[i][j] = need[i][j];\n\tFI(i, 1, til){\n\t\tcur[acq[i][1]]--;\n\t\tcneed[acq[i][0]][acq[i][1]]--;\n\t}\n\tFI(i, 1, n) done[i] = false;\n\t//can avoid death?\n\tint cnt = 0;\n\twhile(cnt < n){\n\t\tbool lock = true;\n\t\tFI(i, 1, n) if(!done[i]){\n\t\t\tbool feasible = true;\n\t\t\tFI(j, 1, re) if(cneed[i][j] > cur[j]){\n\t\t\t\tfeasible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(feasible){\n\t\t\t\tdone[i] = true;\n\t\t\t\tlock = false;\n\t\t\t\tcnt++;\n\t\t\t\tFI(j, 1, re) cur[j] += need[i][j];\n\t\t\t}\n\t\t}\n\t\tif(lock) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &re, &T);\n\tFI(i, 1, re) scanf(\"%d\", &ini[i]);\n\tFI(i, 1, n) FI(j, 1, re) scanf(\"%d\", &need[i][j]);\n\tFI(i, 1, T) scanf(\"%d %d\", &acq[i][0], &acq[i][1]);\n\tint l = 0, r = T + 1;\n\twhile(r - l > 1){\n\t\tint m = (l + r) >> 1;\n\t\tif(ok(m)) l = m;\n\t\telse r = m;\n\t}\n\tif(r == T + 1) r = -1;\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 305\n#define M 201000\nusing namespace std;\n\nint n,m,p;\nint now[N],sum[N];\nint need[N][N],has[N];\nint sneed[N][N],remain[N];\nint ax[M],ay[M];\nbool inq[N];\n\nbool check(int t)\n{\n\tint i,j,k;\n\tint a,b;\n\n\tfor(i=1;i<=m;i++)remain[i]=has[i];\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)\n\t\tsneed[i][j]=need[i][j];\n\tfor(i=1;i<=n;i++)inq[i]=1;\n\t\n\tfor(i=1;i<=t;i++)\n\t{\n\t\ta=ax[i],b=ay[i];\n\t\tnow[a]++,sneed[a][b]--,remain[b]--;\n\t\tif(now[a]==sum[a])\n\t\t{\n\t\t\tfor(i=1;i<=m;i++)\n\t\t\t\tremain[i]+=need[a][i];\n\t\t\tinq[i]=0;\n\t\t}\n\t}\n\tbool flag=1;\n\twhile(flag)\n\t{\n\t\tflag=0;\n\t\tfor(i=1;i<=n;i++)if(inq[i])\n\t\t{\n\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\tif(sneed[i][j]>remain[j])\n\t\t\t\t\tbreak;\n\t\t\tif(j>m)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tremain[j]+=need[i][j];\n\t\t\t\tinq[i]=0;\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)if(inq[i])return 0;\n\treturn 1;\n}\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n\n\tint i,j;\n\n\tscanf(\"%d%d%d\",&n,&m,&p);\n\tfor(i=1;i<=m;i++)scanf(\"%d\",&has[i]);\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)\n\t\tscanf(\"%d\",&need[i][j]),sum[i]+=need[i][j];\n\tfor(i=1;i<=p;i++)scanf(\"%d%d\",&ax[i],&ay[i]);\n\t\n\tif(check(p))puts(\"-1\");\n\telse {\n\t\tint l=1,r=p,mid,ans=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tmid=l+r>>1;\n\t\t\tif(check(mid))ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d\\n\",ans+1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n \n\nsigned main(){\n\n  int p,r,t;\n  cin>>p>>r>>t;\n  \n  vector<int> LL(r);\n  for(int i=0;i<r;i++) cin>>LL[i];\n\n  vector<vector<int> > n(p,vector<int> (r));\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++) cin>>n[i][j];\n\n\n  vector<int> P(t),R(t);\n  for(int i=0;i<t;i++) cin>>P[i]>>R[i], P[i]--,R[i]--;\n  \n  \n  auto deadLock=[&](int x){\n    vector<int> L = LL;\n    vector<queue <int> > Q(r);\n    vector<vector<int> > cnt(p,vector<int> (r,0));\n    \n    auto ok = [&](int p){\n      for(int i=0;i<r;i++) if(n[p][i] != cnt[p][i]) return 0;\n      return 1;\n    };\n\n    auto freeL = [&](int p){\n      for(int i=0;i<r;i++) L[i] += cnt[p][i], cnt[p][i] = 0;\n    };\n    \n    auto use =[&](){\n      int res = 0;\n      for(int i=0;i<r;i++){\n\tif(Q[i].empty()) continue;\n\tif(L[i] == 0) continue;\n\tint process = Q[i].front(); Q[i].pop();\n\tL[i]--, cnt[process][i]++;\n\tif(!ok(process)) continue;\n\tfreeL(process);\n\tres = 1;\n      }\n      return res;\n    };\n    \n    for(int i=0;i<x;i++){\n      int pi = P[i];\n      int ri = R[i];\n      Q[ri].push(pi);\n      while(use());\n    }\n    \n    auto sum=[&](int p){\n      int res = 0;\n      for(int i=0;i<r;i++) res += cnt[p][i];\n      return res;\n    };\n\n    auto canFree=[&](int p){\n      for(int i=0;i<r;i++) if(n[p][i] - cnt[p][i] > L[i]) return 0;\n      return 1;\n    };\n\n    int update = 1;\n    while(update){\n      update = 0;\n      for(int i=0;i<p;i++){ //process\n\tif(sum(i) == 0) {continue;}\n\tif(!canFree(i)) continue;\n\tupdate = 1;\n\tfreeL(i);\n\twhile(use());\n      }\n    }\n\n    for(int i=0;i<p;i++) if(sum(i)) return 1;   \n    for(int i=0;i<r;i++) if(!Q[i].empty()) return 1;\n    return 0;\n  };\n\n  \n  int ans = -1;\n  {\n    int L = 1, R = t+1;\n    while(L+1<R){\n      int M = (L+R)/2;\n      if(deadLock(M)) R = M;\n      else L = M;\n    }\n    ans = R;\n    if(R == t+1) ans = -1;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint initNeed[300][300];\n\nclass State {\nprivate:\n\tint processNum;\n\tint resourceNum;\n\tint need[300][300];\n\tint needSum[300];\n\tint rest[300];\n\tint terminate[300];\npublic:\n\tvoid initialize(int p, int r){\n\t\tprocessNum = p;\n\t\tresourceNum = r;\n\t\tfor(int i=0;i<r;i++) cin >> rest[i];\n\t\tfor(int i=0;i<p;i++){\n\t\t\tfor(int j=0;j<r;j++) cin >> need[i][j];\n\t\t\tneedSum[i] = 0;\n\t\t\tfor(int j=0;j<r;j++) needSum[i] += need[i][j];\n\t\t}\n\t\tmemcpy(initNeed, need, sizeof(need));\n\t\tfor(int i=0;i<p;i++) terminate[i] = 0;\n\t}\n\tvoid progress(int P, int R){\n\t\t--need[P][R];\n\t\t--needSum[P];\n\t\t--rest[R];\n\t\tif(needSum[P] == 0){\n\t\t\tfor(int i=0;i<resourceNum;i++){\n\t\t\t\trest[i] += initNeed[P][i];\n\t\t\t}\n\t\t\tterminate[P] = 1;\n\t\t}\n\t}\n\tbool valid(){\n\t\twhile(true){\n\t\t\tbool update = false;\n\t\t\tfor(int i=0;i<processNum;++i){\n\t\t\t\tif(terminate[i]) continue;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int j=0;j<resourceNum;j++){\n\t\t\t\t\tif(need[i][j] > rest[j]){ ok = false; break; }\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tterminate[i] = 1;\n\t\t\t\t\tfor(int j=0;j<resourceNum;++j){\n\t\t\t\t\t\trest[j] += initNeed[i][j] - need[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\t\tfor(int i=0;i<processNum;++i) if(!terminate[i]) return false;\n\t\treturn true;\n\t}\n};\n\nint main(){\n\tint p, r, t;\n\twhile(cin >> p >> r >> t){\n\t\tState s; s.initialize(p, r);\n\t\tvector<int> P(t), R(t);\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> P[i]; --P[i];\n\t\t\tcin >> R[i]; --R[i];\n\t\t}\n\t\ts.progress(P[0], R[0]);\n\t\tState m, v;\n\t\tint low = 0, high = t;\n\t\twhile(high - low > 1){\n\t\t\tint mid = (low+high)/2;\n\t\t\tm = s;\n\t\t\tfor(int i=low+1;i<=mid;i++){\n\t\t\t\tm.progress(P[i], R[i]);\n\t\t\t}\n\t\t\tv = m;\n\t\t\tif(v.valid()){\n\t\t\t\tlow = mid;\n\t\t\t\ts = m;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\tcout << (low==t-1 ? -1 : low+2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 333, inf = 1000000000;\nint P, R, T, r[maxn], p[maxn][maxn], z[100086 * 2][2], nowr[maxn], nowp[maxn][maxn], cnt[maxn], sum, ok;\nbool flag, flag1, ilock[maxn][maxn], ban[maxn];\n\nvoid print()\n{\n    printf(\"nowp:\\n\");\n    for (int i = 1; i <= P; i++)\n    {\n        for (int j = 1; j <= R; j++)\n            printf(\"%d \", nowp[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"nowr:\\n\");\n    for (int i = 1; i <= R; i++) printf(\"%d \", nowr[i]); printf(\"\\n\");\n}\n\nint main()\n{\n    //freopen(\"F.in\", \"r\", stdin);\n    //freopen(\"F.out\", \"w\", stdout);\n    scanf(\"%d %d %d\", &P, &R, &T);\n    for (int i = 1; i <= R; i++)\n    {\n        scanf(\"%d\", &r[i]);\n        nowr[i] = r[i];\n    }\n\tfor (int i = 1; i <= P; i++)\n        for (int j = 1; j <= R; j++)\n            scanf(\"%d\", &p[i][j]);\n    for (int i = 1; i <= T; i++) scanf(\"%d %d\", &z[i][0], &z[i][1]);\n    for (int i = 1; i <= T; i++)\n    {\n        nowp[z[i][0]][z[i][1]]++;\n        nowr[z[i][1]]--;\n    }\n    for (int i = 1; i <= P; i++)\n    {\n        flag = 1;\n        for (int j = 1; j <= R; j++)\n            if (nowp[i][j] < p[i][j])\n            {\n                flag = 0;\n                break;\n            }\n        if (!flag) continue;\n        for (int j = 1; j <= R; j++)\n        {\n            nowr[j] += nowp[i][j];\n            nowp[i][j] = 0;\n        }\n        ban[i] = 1;\n        ok++;\n    }\n    flag = 1;\n    while (flag)\n    {\n        flag = 0;\n        for (int i = 1; i <= P; i++)\n        {\n            if (ban[i]) continue;\n            flag1 = 1;\n            for (int j = 1; j <= R; j++)\n                if (nowr[j] + nowp[i][j] < p[i][j])\n                {\n                    flag1 = 0;\n                    break;\n                }\n            flag |= flag1;\n            if (flag1)\n            {\n                for (int j = 1; j <= R; j++)\n                {\n                    nowr[j] += nowp[i][j];\n                    nowp[i][j] = 0;\n                }\n                ban[i] = 1;\n                ok++;\n            }\n            if (ok == P)\n            {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n    }\n    for (int i = 1; i <= P; i++)\n    {\n        if (ban[i]) continue;\n        for (int j = 1; j <= R; j++)\n            if (nowr[j] + nowp[i][j] < p[i][j])\n            {\n                ilock[i][j] = 1;\n                cnt[i]++;\n            }\n    }\n    for (int t = T; t >= 1; t--)\n    {\n        //printf(\"t : %d\\n\",t);\n        if (ban[z[t][0]]) continue;\n        nowp[z[t][0]][z[t][1]]--;\n        nowr[z[t][1]]++;\n        flag = 0;\n        for (int i = 1; i <= P; i++)\n        {\n            if (ban[i]) continue;\n            if (nowr[z[t][1]] + nowp[i][z[t][1]] >= p[i][z[t][1]])\n                if (ilock[i][z[t][1]])\n                {\n                    ilock[i][z[t][1]] = 0;\n                    cnt[i]--;\n                    if (cnt[i] == 0)\n                    {\n                        flag = 1;\n                        for (int j = 1; j <= R; j++)\n                        {\n                            nowr[j] += nowp[i][j];\n                            nowp[i][j] = 0;\n                        }\n                        ban[i] = 1;\n                        ok++;\n                    }\n                }\n        }\n        if (flag)\n        {\n            while (flag)\n            {\n                flag = 0;\n                for (int i = 1; i <= P; i++)\n                {\n                    if (ban[i]) continue;\n                    flag1 = 1;\n                    for (int j = 1; j <= R; j++)\n                        if (nowr[j] + nowp[i][j] < p[i][j])\n                        {\n                            flag1 = 0;\n                            break;\n                        }\n                    flag |= flag1;\n                    if (flag1)\n                    {\n                        for (int j = 1; j <= R; j++)\n                        {\n                            nowr[j] += nowp[i][j];\n                            nowp[i][j] = 0;\n                        }\n                        ban[i] = 1;\n                        ok++;\n                    }\n                    if (ok == P)\n                    {\n                        printf(\"%d\\n\", t);\n                        return 0;\n                    }\n                }\n            }\n            for (int i = 1; i <= P; i++)\n            {\n                cnt[i] = 0;\n                for (int j = 1; j <= R; j++)\n                    if (nowr[j] + nowp[i][j] < p[i][j])\n                    {\n                        ilock[i][j] = 1;\n                        cnt[i]++;\n                    }\n                    else ilock[i][j] = 0;\n            }\n        }\n        //print();\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for (int i=0;i<n;++i)\n#define REP(i,n) for (int i=1;i<=n;++i)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define read(x) scanf(\"%d\",&x)\nint P,R,T;\nint pp[305][305];\nint rr[305];\nclass state{\npublic:\n\tint p[305][305];\n\tint r[305];\n\tinline bool off(int i){\n\t\tfor (int j=1;j<=R;++j) if (p[i][j]) return 0;\n\t\treturn 1;\n\t}\n\tinline bool on(int i){\n\t\tfor (int j=1;j<=R;++j) if (p[i][j]) return 1;\n\t\treturn 0;\n\t}\n\tinline bool available(int i){\n\t\tfor (int j=1;j<=R;++j) if (p[i][j]>r[j]) return 0;\n\t\treturn 1;\n\t}\n\tinline void release(int i){\n\t\tfor (int j=1;j<=R;++j) r[j]+=pp[i][j];\n\t}\n\tinline bool judge(){// O(n^3)\n\t\tint p1[305][305],r1[305];\n\t\trep(i,305) rep(j,305) p1[i][j]=p[i][j];\n\t\trep(j,305) r1[j]=r[j];\n\t\twhile(1){\n\t\t\tint cnt=0;\n\t\t\tfor (int i=1;i<=P;++i) if (on(i)) ++cnt;\n\t\t\tif (!cnt){\n\t\t\t\trep(i,305) rep(j,305) p[i][j]=p1[i][j];\n\t\t\t\trep(j,305) r[j]=r1[j];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbool term=1;\n\t\t\tfor (int i=1;i<=P;++i){\n\t\t\t\tif (off(i)) continue;\n\t\t\t\tif (available(i)){\n\t\t\t\t\tterm=0;\n\t\t\t\t\tfor (int j=1;j<=R;++j){\n\t\t\t\t\t\tr[j]-=p[i][j];p[i][j]=0;r[j]+=pp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (term){\n\t\t\t\trep(i,305) rep(j,305) p[i][j]=p1[i][j];\n\t\t\t\trep(j,305) r[j]=r1[j];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tstate operator = (const state& st){\n\t\trep(i,305) rep(j,305) p[i][j]=st.p[i][j];\n\t\trep(j,305) r[j]=st.r[j];\n\t\treturn *this;\n\t}\n};\n\nint p_[200005],r_[200005];\nmap<int,state> m;\nmap<int,state>::iterator it;\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tcin>>P>>R>>T;\n\tfor (int i=1;i<=R;++i){\n\t\tcin>>rr[i];m[0].r[i]=rr[i];\n\t}\n\tfor (int i=1;i<=P;++i) for (int j=1;j<=R;++j){\n\t\tcin>>pp[i][j];m[0].p[i][j]=pp[i][j];\n\t}\n\tm[T]=m[0];\n\tfor (int i=1;i<=T;++i){\n\t\tcin>>p_[i]>>r_[i];\n\t\t--m[T].p[p_[i]][r_[i]];\n\t\t--m[T].r[r_[i]];\n\t}\n\tfor (int i=1;i<=P;++i) if (m[0].on(i)&&m[T].off(i)) m[T].release(i);\n\tif (m[T].judge()){\n\t\tcout<<-1<<endl;return 0;\n\t}\n\tif (!m[0].judge()){\n\t\tcout<<0<<endl;return 0;\n\t}\n\tint l=0,r=T;// l can, r can't\n\twhile(r-l>1){\n\t\tint t=(l+r)/2;\n\t\tm[t]=m[l];\n\t\tfor (int i=l+1;i<=t;++i){\n\t\t\t--m[t].p[p_[i]][r_[i]];\n\t\t\t--m[t].r[r_[i]];\n\t\t}\n\t\tfor (int i=1;i<=P;++i) if (m[l].on(i)&&m[t].off(i)) m[t].release(i);\n\t\tif (m[t].judge()) l=t;\n\t\telse r=t;\n\t}\n\tcout<<r<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint p, r, t;\n\tcin >> p >> r >> t;\n\tvi resource(r);\n\tREP(i, r) cin >> resource[i];\n\tvector<vi> need(p, vi(r));\n\tREP(i, p)REP(j, r) cin >> need[i][j];\n\tvector<pii> query;\n\tREP(i, t)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tquery.emplace_back(a, b);\n\t}\t\t\n\n\tint lb = 0, ub =  t + 1;\n\twhile (ub - lb > 1)\n\t{\n\t\tint time = (ub + lb) / 2;\n\t\tauto available = resource;\n\t\tauto tmp = need;\n\t\tREP(i, time)\n\t\t{\n\t\t\tint p = query[i].first, r = query[i].second;\n\t\t\tavailable[r]--;\n\t\t\ttmp[p][r]--;\n\t\t}\n\t\tvector<bool> f(p, true);\n\t\tREP(i, p)\n\t\t{\n\t\t\tbool ff = true;\n\t\t\tREP(j, r)\n\t\t\t{\n\t\t\t\tif (tmp[i][j] > 0) ff = false;\n\t\t\t}\n\t\t\tif (ff)\n\t\t\t{\n\t\t\t\tf[i] = false;\n\t\t\t\tREP(j, r) available[j] += need[i][j];\n\t\t\t}\n\t\t}\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tREP(i, p)\n\t\t\t{\n\t\t\t\tif (!f[i]) continue;\n\t\t\t\tbool ff = true;\n\t\t\t\tREP(j, tmp[i].size())\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i][j] > available[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tff = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ff)\n\t\t\t\t{\n\t\t\t\t\tREP(j, r) available[j] += need[i][j] - tmp[i][j];\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tf[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (f[i]) ok = false;\n\t\t}\n\t\tif (ok) lb = time;\n\t\telse ub = time;\n\t}\n\tif (ub == t + 1) cout << -1 << endl;\n\telse cout << ub << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,r,t;\nint l[301];\nint p[200001],req[200001];\nint fie[301][301];\nint tmpf[301][301];\nint tmpl[301];\nint cnt[301];\nbool used[301];\n\nbool C(int vt){\n\tmemset(used,0,sizeof(used));\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<r;i++){\n\t\ttmpl[i]=l[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<r;j++){\n\t\t\ttmpf[i][j]=0;\n\t\t\tif(tmpf[i][j]==fie[i][j])cnt[i]++;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(cnt[i]==r){\n\t\t\tused[i]=true;\n\t\t}\n\t}\n\tint restcnt=n;\n\tfor(int i=0;i<vt;i++){\n\t\tif(tmpl[req[i]]==0)continue;\n\t\ttmpf[p[i]][req[i]]++;\n\t\ttmpl[req[i]]--;\n\t\tif(tmpf[p[i]][req[i]]==0)cnt[p[i]]++;\n\t\tif(cnt[p[i]]==r){\n\t\t\tused[p[i]]=true;\n\t\t\trestcnt--;\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\ttmpl[j]+=tmpf[p[i]][j];\n\t\t\t}\n\t\t}\n\t}\n\tbool update=true;\n\twhile(update){\n\t\tupdate=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\tif(fie[i][j]-tmpf[i][j]>tmpl[j])flag=false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tused[i]=true;\n\t\t\t\t\tupdate=true;\n\t\t\t\t\trestcnt--;\n\t\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\t\ttmpl[j]+=tmpf[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (restcnt>0);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&r,&t);\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d\",&l[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<r;j++){\n\t\t\tscanf(\"%d\",&fie[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<t;i++){\n\t\tscanf(\"%d%d\",&p[i],&req[i]);\n\t\tp[i]--;\n\t\treq[i]--;\n\t}\n\tint l=0,r=t+1;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d\\n\",r==(t+1)?-1:r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <cassert>\nusing namespace std;\n\ntemplate<typename T>\nvoid fill_all(T& a, const T& b)\n{\n\ta = b;\n}\ntemplate<typename T, size_t N, typename U>\nvoid fill_all(T(& a)[N], const U& b)\n{\n\tfor (auto& i : a)\n\t{\n\t\tfill_all(i, b);\n\t}\n}\n\n#if 1\nint P, R, Q;\nint r_num[500];//r\nint cost[500][500];//i,r\nint rem[500][500];//i,r\nstd::list<int>::iterator resolved_iter[500][500];//r,i\nstd::list<int> resolved[500][501];//r,num\nstd::pair<int, int> Log[300000];\nbool ended[500];\nint ended_num;\n\nvoid run_end(int p)\n{\n\tassert(!ended[p]);\n\tended[p] = true;\n\t++ended_num;\n\t//for (int r = 0; r < R; r++)\n\t//{\n\t//\tresolved[r][rem[p][r]].erase(resolved_iter[r][p]);\n\t//}\n\tfor (int r = 0; r < R; r++)\n\t{\n\t\tr_num[r] += (cost[p][r] - rem[p][r]);\n\t}\n}\nvoid jump()\n{\n\tbool ok = false;\n\tfor (int p = 0; p < P; p++)\n\t{\n\t\tif (ended[p]) { continue; }\n\t\tok = true;\n\t\tfor (int r = 0; r < R; r++)\n\t\t{\n\t\t\tif (rem[p][r] > r_num[r]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trun_end(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ok) {\n\t\tjump();\n\t}\n}\n\nint main()\n{\n\tcin >> P >> R >> Q;\n\tfor (int i = 0; i < R; i++)\n\t{\n\t\tcin >> r_num[i];\n\t}\n\tfor (int i = 0; i < P; i++)\n\t{\n\t\tfor (int r = 0; r < R; r++)\n\t\t{\n\t\t\tcin >> cost[i][r];\n\t\t\trem[i][r] = cost[i][r];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tcin >> Log[i].first >> Log[i].second; --Log[i].first; --Log[i].second;\n\t\tauto p = Log[i].first;\n\t\tassert(!ended[p]);\n\t\t--rem[p][Log[i].second];\n\t\t--r_num[Log[i].second];\n\t\tassert(Log[i].second >= 0);\n\t\tassert(Log[i].second < 300);\n\t\tassert(r_num[Log[i].second] <= 100);\n\t\tassert(r_num[Log[i].second] >= 0);\n\n\t\tif (rem[p][Log[i].second] == 0) {\n\t\t\tbool ok = true;\n\t\t\tfor (int r = 0; r < R; r++)\n\t\t\t{\n\t\t\t\tif (rem[p][r] > 0) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tassert(!ended[p]);\n\t\t\t\tended[p] = true;\n\t\t\t\t++ended_num;\n\t\t\t\tfor (int r = 0; r < R; r++)\n\t\t\t\t{\n\t\t\t\t\tr_num[r] += cost[p][r];\n\t\t\t\t\tassert(r_num[r] <= 100);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < P; i++)\n\t{\n\t\tfor (int r = 0; r < R; r++)\n\t\t{\n\t\t\tassert(rem[i][r] >= 0);\n\t\t\tassert(rem[i][r] <= 100);\n\t\t\tresolved[r][rem[i][r]].push_front(i);\n\t\t\tresolved_iter[r][i] = resolved[r][rem[i][r]].begin();\n\t\t}\n\t}\n\tjump();\n\tif (ended_num == P) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint q = Q - 1;\n\tfor (; q >= 0; --q)\n\t{\n\t\tauto r = Log[q].second;\n\t\t{\n\t\t\tauto p = Log[q].first;\n\t\t\tif (!ended[p]) {\n\t\t\t\tresolved[r][rem[p][r]].erase(resolved_iter[r][p]);\n\t\t\t\t++rem[p][r];\n\t\t\t\tresolved[r][rem[p][r]].push_front(p);\n\t\t\t\tresolved_iter[r][p] = resolved[r][rem[p][r]].begin();\n\t\t\t\t++r_num[r];\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\tfor(auto& p : resolved[r][r_num[r]]) {\n\t\t\tif (ended[p]) { continue; }\n\t\t\tok = true;\n\t\t\tfor (int rr = 0; rr < R; rr++)\n\t\t\t{\n\t\t\t\tif (rem[p][rr] > r_num[rr]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\trun_end(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tjump();\n\t\t}\n\n\t\tif (ended_num >= P) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << (q+1) << endl;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nstruct Log {\n\tint p, r;\n};\n\ntypedef pair<int, int> Pair;\n\nint P, R, T;\nvector< vector<int> > p0;\nvector<int> r0;\nvector<Log> g;\nbool isAlive(int t) {\n\tvector< vector<int> > p = p0;\n\tvector<int> r = r0;\n\tfor (int i = 0; i < t; ++i) {\n\t\t--p[g[i].p][g[i].r];\n\t\t--r[g[i].r];\n\t}\n\tvector<bool> isFree(P, false);\n\tfor (int i = 0; i < P; ++i) {\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tcnt += p[i][j] == 0;\n\t\t}\n\t\tif (cnt == R) {\n\t\t\tisFree[i] = true;\n\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\tr[j] += p0[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> deadCount(P, 0);\n\tvector<bool> isDead(P, false);\n\tvector< set<Pair> > need(R);\n\tfor (int i = 0; i < P; ++i) {\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tif (p[i][j] > r[j]) {\n\t\t\t\tneed[j].insert( Pair(p[i][j], i) );\n\t\t\t\t++deadCount[i];\n\t\t\t\tisDead[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Pair> Q;\n\tfor (int i = 0; i < P; ++i) {\n\t\tif (!isFree[i] && !isDead[i]) {\n\t\t\tisFree[i] = true;\n\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\tQ.push( Pair(j, p0[i][j]-p[i][j]) );\n\t\t\t}\n\t\t}\n\t}\n\twhile ( !Q.empty() ) {\n\t\tPair q = Q.front(); Q.pop();\n\t\tint rid = q.first, amount = q.second;\n\t\tr[rid] += amount;\n\t\twhile (need[rid].size() > 0) {\n\t\t\tset<Pair>::iterator it = need[rid].begin();\n\t\t\tif (it->first <= r[rid]) {\n\t\t\t\tif (--deadCount[it->second] == 0) {\n\t\t\t\t\tisDead[it->second] = false;\n\t\t\t\t\tisFree[it->second] = true;\n\t\t\t\t\tfor (int j = 0; j < R; ++j) {\n\t\t\t\t\t\tQ.push( Pair(j, p0[it->second][j]-p[it->second][j]) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[rid].erase(it);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < P; ++i) {\n\t\tif (isDead[i]) return false;\n\t}\n\n\treturn true;\n}\n\nsigned main() {\n\tcin >> P >> R >> T;\n\tr0 = vector<int>(R);\n\tp0 = vector< vector<int> >(P, vector<int>(R));\n\tg.resize(T);\n\tfor (int i = 0; i < R; ++i) cin >> r0[i];\n\tfor (int i = 0; i < P; ++i) {\n\t\tfor (int j = 0; j < R; ++j) {\n\t\t\tcin >> p0[i][j];\n\t\t}\n\t}\n\tfor (int t = 0; t < T; ++t) {\n\t\tcin >> g[t].p >> g[t].r; --g[t].p, --g[t].r;\n\t}\n\n\tint left = 0, right = T+1;\n\twhile ( right-left > 1 ) {\n\t\tint m = (left+right)/2;\n\t\tif ( isAlive(m) ) {\n\t\t\tleft = m;\n\t\t}\n\t\telse {\n\t\t\tright = m;\n\t\t}\n\t}\n\tif (right == T+1) cout << -1 << endl;\n\telse cout << right << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    bool check_terminated(vector<int> &need) {\n        bool terminated = true;\n        rep(r, R) terminated &= need[r] == 0;\n        return terminated;\n    }\n    \n    // O(t)\n    tuple<bool, vector<vector<int>>, vector<int>> calc_state(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left = L;\n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n            if(left[r] < 0) {\n                return make_tuple(false, need, left);\n            }\n            if(need[p][r] == 0) {\n                if(check_terminated(need[p])) {\n                    rep(r, R) left[r] += N[p][r];\n                }\n            }\n        }\n        // cerr << \"state t = \" << t << endl;\n        // cerr << \"left \" << left << endl;\n        // cerr << need << endl;\n        return make_tuple(true, need, left);\n    }\n\n    bool is_avoidable(int t) {\n        bool reachable;\n        vector<vector<int>> need;\n        vector<int> left;\n        tie(reachable, need, left) = calc_state(t);\n        \n        // check lack of resource\n        if(not reachable) return false;\n        \n        vector<bool> terminated(P);\n        int terminated_num = 0;\n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) {\n                    if(need[p][r] > left[r]) {\n                        terminatable = false;\n                        break;\n                    }\n                }\n                if(terminatable) {\n                    rep(r, R) {\n                        left[r] += N[p][r];\n                    }\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        // cerr << \"! \" << t << \" \" << terminated_num << endl;\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = 0, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            // cerr << m << \" \" << l << \" \" << r << endl;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\nconst int maxN = 333;\nconst int maxO = 2e5 + 100;\nint n, m, t, l[maxN], rec2[maxN];\nint nd[maxN][maxN], rec[maxN][maxN];\nbool li[maxN];\npii ope[maxO];\n\n\nbool deadlock(int w) {\n\tmemcpy(rec, nd, sizeof nd);\n\tmemcpy(rec2, l, sizeof l);\n\tmemset(li, false, sizeof li);\n\tfor (int i = 1; i <= w; ++i) {\n\t\tnd[ope[i].x][ope[i].y]--;\n\t\tl[ope[i].y]--;\n\t}\n\tfor (int p = 1; p <= n; ++p)\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (li[i]) break;\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\tif (l[k] < nd[i][k]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfor (int k = 1; k <= m; ++k)\n\t\t\t\t\tl[k] += rec[i][k] - nd[i][k];\n\t\t\t\tli[i] = true;\n\t\t\t}\n\t\t}\n\tmemcpy(nd, rec, sizeof rec);\n\tmemcpy(l, rec2, sizeof rec2);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!li[i]) return true;\n\treturn false;\n}\n\nint main() {\n#ifdef lol\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tfor (int i = 1; i <= m; ++i)\n\t\tscanf(\"%d\", &l[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%d\", &nd[i][j]);\n\tfor (int i = 1; i <= t; ++i)\n\t\tscanf(\"%d %d\", &ope[i].x, &ope[i].y);\n\tif (!deadlock(t)) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= t; ++i) {\n\t\tif (deadlock(i)) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\treturn 0;\n\n\tint l = 1, r = t;\n\t//for (int i = 1; i <= t; ++i)\n\t//\tprintf(\"%d\", deadlock(i));\n\t//puts(\"\");\n\twhile (l != r) {\n\t//\tprintf(\"%d %d\\n\", l, r);\n\t\tint mid = (l + r) >> 1;\n\t\tif (!deadlock(mid))\n\t\t\tl = mid + 1;\n\t\telse r = mid;\n\t}\n\tprintf(\"%d\\n\", l >= t ? -1 : l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint p, r, t;\n\tcin >> p >> r >> t;\n\tif (t == 1) return 1;\n\tvi resource(r);\n\tREP(i, r) cin >> resource[i];\n\tvector<vi> need(p, vi(r));\n\tREP(i, p)REP(j, r) cin >> need[i][j];\n\tvector<pii> query;\n\tREP(i, t)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tquery.emplace_back(a, b);\n\t}\t\t\n\tauto available = resource;\n\tauto tmp = need;\n\tREP(i, t)\n\t{\n\t\tint p = query[i].first, r = query[i].second;\n\t\tavailable[r]--;\n\t\ttmp[p][r]--;\n\t}\n\tint lb = 0, ub = t + 1;\n\twhile (ub - lb > 1)\n\t{\n\t\tint time = (ub + lb) / 2;\n\t\tauto available = resource;\n\t\tauto tmp = need;\n\t\tREP(i, time)\n\t\t{\n\t\t\tint p = query[i].first, r = query[i].second;\n\t\t\tavailable[r]--;\n\t\t\ttmp[p][r]--;\n\t\t}\n\t\tvector<bool> f(p, true);\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tREP(i, p)\n\t\t\t{\n\t\t\t\tif (!f[i]) continue;\n\t\t\t\tbool ff = true;\n\t\t\t\tREP(j, tmp[i].size())\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i][j] > available[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tff = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ff)\n\t\t\t\t{\n\t\t\t\t\tREP(j, r) available[j] += need[i][j] - tmp[i][j];\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tf[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (f[i])\n\t\t\t{\n\t\t\t\tREP(j, r)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i][j] > available[j]) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) lb = time;\n\t\telse ub = time;\n\t}\n\tif (ub == t + 1) cout << -1 << endl;\n\telse cout << ub << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    int P, R, T;\n    vector<int> L;\n    vector<vector<int>> N;\n    vector<pii> PR;\n\n    bool check_terminated(vector<int> &need) {\n        bool terminated = true;\n        rep(r, R) terminated &= need[r] == 0;\n        return terminated;\n    }\n    \n    bool is_avoidable(int t) {\n        vector<vector<int>> need = N;\n        vector<int> left = L;\n\n        vector<bool> terminated(P);\n        int terminated_num = 0;\n\n        // O(t * R) ? \n        rep(i, t) {\n            int p = PR[i].first, r = PR[i].second;\n            left[r]--;\n            need[p][r]--;\n            if(left[r] < 0) {\n                return false; // lack of resource !\n            }\n            if(need[p][r] == 0) {\n                if(check_terminated(need[p])) {\n                    rep(r2, R) left[r2] += N[p][r2];\n                    terminated[p] = true;\n                    terminated_num++;                            \n                }\n            }\n        }            \n                \n        bool flg = true;\n        while(terminated_num < P and flg) {\n            flg = false;\n            rep(p, P) {\n                if(terminated[p]) continue;\n                bool terminatable = true;\n                rep(r, R) terminatable &= need[p][r] <= left[r];\n                if(terminatable) {\n                    rep(r, R) left[r] += N[p][r];\n                    terminated[p] = true;\n                    terminated_num++;\n                    flg = true;\n                }                \n            }\n        }\n        // cerr << \"! \" << t << \" \" << terminated_num << endl;\n        return terminated_num == P;\n    }\n    \n    bool solve() {\n        cin >> P >> R >> T;\n        L.resize(R); cin >> L;\n        N.resize(P, vector<int>(R)); cin >> N;\n        PR.resize(T);\n        rep(i, T) {\n            cin >> PR[i].first >> PR[i].second;\n            PR[i].first--;\n            PR[i].second--;\n        }\n\n        int l = -1, r = T + 1;\n        while(l + 1 < r) {\n            int m = (l + r) / 2;\n            // cerr << m << \" \" << l << \" \" << r << endl;\n            (is_avoidable(m) ? l : r) = m;            \n        }\n        cout << (r > T ? -1 : r) << endl;\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    if(A[q]<0)return false;\n    \n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0){\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n    }\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++){\n    if(cnt[i]>0)return false;\n    assert(cnt[i]==0);\n  }\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++)scanf(\"%d\",&a[i]);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<M;j++)\n      scanf(\"%d\",&b[i][j]);\n\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  \n  if(check(K))left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ms(x,y) memset(x,y,sizeof(x))\nusing namespace std;\nconst int N=305;\nconst int T=200005;\n\n\nint pn,rn,tn;\nint tp[T],tr[T];\nbool ter[N];\nint untercnt=0;\nint res[N],need[N][N],req[N][N];\nint tmpres[N],tmpneed[N][N];\nbool tmpter[N];\n\nbool terminate(int pi) {\n\tfor(int j=1;j<=rn;j++)\n\t\tif(need[pi][j])return false;\n\treturn true;\n}\n\nbool canter(int pi) {\n\tfor(int j=1;j<=rn;j++)\n\t\tif(tmpneed[pi][j]>tmpres[j])return false;\n\treturn true;\n}\nqueue<int> q;\nbool check() {\n\tmemcpy(tmpres,res,sizeof(res));\n\tmemcpy(tmpneed,need,sizeof(need));\n\tmemcpy(tmpter,ter,sizeof(ter));\n\t\n\tint cnt=0;\n\twhile(!q.empty())q.pop();\n\tfor(int i=1;i<=pn;i++) \n\t\tif(!tmpter[i])\n\t\t\tif(canter(i))\n\t\t\t\tq.push(i);\n\twhile(!q.empty()) {\n\t\twhile(!q.empty()){\n\t\t\tint now=q.front();\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\ttmpter[now]=true;\n\t\t\tfor(int j=1;j<=rn;j++)\n\t\t\t\ttmpres[j]+=req[now][j]-need[now][j];\n\t\t}\n\t\tfor(int i=1;i<=pn;i++) \n\t\t\tif(!tmpter[i])\n\t\t\t\tif(canter(i))\n\t\t\t\t\tq.push(i);\n\t}\n\tif(cnt<untercnt)return false;\n\treturn true;\n}\n\nvoid goup(int now,int tt) {\n\tfor(int t=now;t>tt;t--){\n\t\tif(ter[tp[t]])continue;\n\t\tres[tr[t]]++;\n\t\tneed[tp[t]][tr[t]]++;\n\t}\n}\nvoid godown(int now,int tt){\n\tfor(int t=now+1;t<=tt;t++) {\n\t\tif(ter[tp[t]])continue;\n\t\tres[tr[t]]--;\n\t\tneed[tp[t]][tr[t]]--;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&pn,&rn,&tn);\n\tuntercnt=pn;\n\tfor(int i=1;i<=rn;i++)\n\t\tscanf(\"%d\",&res[i]);\n\tfor(int i=1;i<=pn;i++)\n\t\tfor(int j=1;j<=rn;j++) {\n\t\t\tscanf(\"%d\",&req[i][j]);\n\t\t\tif(req[i][j]>res[j]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tneed[i][j]=req[i][j];\n\t\t}\n\tms(ter,0);\n\tfor(int i=1;i<=tn;i++){\n\t\tscanf(\"%d%d\",&tp[i],&tr[i]);\n\t\tneed[tp[i]][tr[i]]--;\n\t\tres[tr[i]]--;\t\t\n\t\tif(terminate(tp[i])){\n\t\t\tter[tp[i]]=true;\n\t\t\tuntercnt--;\n\t\t\tfor(int j=1;j<=rn;j++)\n\t\t\t\tres[j]+=req[tp[i]][j];\n\t\t}\n\t}\n\tif(check()){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint l=0,r=tn,now=tn;\n\twhile(l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif(mid<now) goup(now,mid);\n\t\telse if(mid>now) godown(now,mid);\n\t\tnow=mid;\n\t\tif(check())\n\t\t\tl=mid+1;\n\t\telse\n\t\t\tr=mid;\n\t}\n\tprintf(\"%d\\n\",l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nint a[300];\nint b[300][300];\nint cnt[300];\n\nint s[200000],t[200000];\n\nint A[300];\nint B[300][300];\nbool check(int x){\n  for(int i=0;i<M;i++){\n    A[i]=a[i];\n  }\n  for(int i=0;i<N;i++){\n    cnt[i]=0;\n    for(int j=0;j<M;j++){\n      B[i][j]=b[i][j];\n      cnt[i]+=b[i][j];\n    }\n  }\n  \n  for(int i=0;i<x;i++){\n    int p=s[i],q=t[i];\n    A[q]--;\n    assert(A[q]>=0);\n    B[p][q]--;\n    cnt[p]--;\n    if(cnt[p]==0)\n      for(int j=0;j<M;j++)\n        A[j]+=b[p][j];\n  }\n  \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<N;i++){\n      if(cnt[i]==0)continue;\n      bool flg=true;\n      for(int j=0;j<M;j++)\n        if(A[j]<B[i][j])flg=false;\n      if(!flg)continue;\n      \n      cnt[i]=0;\n      for(int j=0;j<M;j++)\n        A[j]+=(b[i][j]-B[i][j]);\n      update=true;\n\n    }\n  }\n  \n  for(int i=0;i<N;i++)\n    if(cnt[i]>0)return false;\n  return true;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=0;i<M;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      scanf(\"%d\",&b[i][j]);\n    }\n  }\n  for(int i=0;i<K;i++){\n    scanf(\"%d %d\",&s[i],&t[i]);\n    s[i]--;\n    t[i]--;\n  }\n\n  \n  int left=0,right=K,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(mid))left=mid+1;\n    else right=mid;\n  }\n  if(left==K)left=-1;\n  printf(\"%d\\n\",left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint p,r,t;\nint L[333];\nint lmp[333];\nint tmp[333][333];\nint n[333][333];\nbool used[333];\nint C[333];\nvector<P> D;\n\nbool isRelease( int id ){\n  for(int i=0;i<r;i++)\n    if( n[id][i] > L[i] ) return false;\n  return true;\n}\n\nbool check(int h){\n\n  for(int i=0;i<r;i++) L[i] = lmp[i];\n  for(int i=0;i<p;i++){\n    C[i] = r;\n    for(int j=0;j<r;j++){\n      n[i][j] = tmp[i][j];\n      if( n[i][j] == 0 ) C[i]--;\n    }\n  }\n  \n  for(int i=0;i<h;i++){\n    if( L[ D[i].second ] == 0 ) return true;\n    L[ D[i].second ]--;    \n    n[ D[i].first ][ D[i].second ]--;\n    if( n[ D[i].first ][ D[i].second ] == 0 ) C[ D[i].first ]--;\n\n    if( C[ D[i].first ] == 0 ) {\n      for(int j=0;j<r;j++)\n        L[ j ] += tmp[ D[i].first ][ j ];      \n    }\n  }\n\n  /*\n  cout << \"time : \" <<  h << endl;\n  for(int i=0;i<r;i++) cout << L[i]<< \" \";\n  cout << endl;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<r;j++) cout << n[i][j] << \" \";\n    cout << endl;\n  }\n  */\n\n\n  bool loop = true;\n  memset( used,0,sizeof( used ));\n  while( loop ){\n    loop = false;\n    for(int i=0;i<p;i++){\n      if( used[i] ) continue;\n      if( isRelease( i ) ) {\n        for(int j=0;j<r;j++)\n          L[ j ] += tmp[i][j] - n[i][j];\n        used[i] = true;\n        loop = true;\n      }\n    }\n  }\n\n  for(int i=0;i<p;i++)\n    if( !used[i] ) return true;\n  return false;\n  \n}\n\nint main(){\n  cin >> p >> r >> t;\n  D.resize( t );\n  for(int i=0;i<r;i++) {\n    cin >> L[i]; lmp[i] = L[i];\n  }\n  for(int i=0;i<p;i++)\n    for(int j=0;j<r;j++){\n      cin >> n[i][j];\n      tmp[i][j] = n[i][j];\n    }\n  for(int i=0;i<t;i++){\n    cin >> D[i].first >> D[i].second;\n    D[i].first--; D[i].second--;\n  }\n\n  int st = 0, ed = t;\n  int res = -1;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( check( h ) ) {\n      ed = h-1; res = h;\n    } else {\n      st = h+1;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\nusing namespace std;\n\nint n, re, T, ini[305], need[305][305];\nint acq[200005][2];\n\nint cur[305], cneed[305][305];\nbool done[305];\n\nbool ok(int til){\n\tFI(i, 1, re) cur[i] = ini[i];\n\tFI(i, 1, n) FI(j, 1, re) cneed[i][j] = need[i][j];\n\tFI(i, 1, til){\n\t\tcur[acq[i][1]]--;\n\t\tcneed[acq[i][0]][acq[i][1]]--;\n\t}\n\tFI(i, 1, n) done[i] = false;\n\t//can avoid death?\n\tint cnt = 0;\n\twhile(cnt < n){\n\t\tbool lock = true;\n\t\tFI(i, 1, n) if(!done[i]){\n\t\t\tbool feasible = true;\n\t\t\tFI(j, 1, re) if(cneed[i][j] > cur[j]){\n\t\t\t\tfeasible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(feasible){\n\t\t\t\tdone[i] = true;\n\t\t\t\tlock = false;\n\t\t\t\tcnt++;\n\t\t\t\tFI(j, 1, re) cur[j] += need[i][j];\n\t\t\t}\n\t\t}\n\t\tif(lock) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &re, &T);\n\tFI(i, 1, re) scanf(\"%d\", &ini[i]);\n\tFI(i, 1, n) FI(j, 1, re) scanf(\"%d\", &need[i][j]);\n\tFI(i, 1, T) scanf(\"%d %d\", &acq[i][0], &acq[i][1]);\n\tint l = -1, r = T + 1;\n\twhile(r - l > 1){\n\t\tint m = (l + r) >> 1;\n\t\tif(ok(m)) l = m;\n\t\telse r = m;\n\t}\n\tif(r == T + 1) r = -1;\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int p,r,t;\n    cin >> p >> r >> t;\n    vector<int> l(r);\n    for(int i=0;i<r;i++){\n        cin >> l[i];\n    }\n    vector<vector<int> > n(p,vector<int>(r));\n    for(int i=0;i<p;i++){\n        for(int j=0;j<r;j++){\n            cin >> n[i][j];\n        }\n    }\n    vector<int> P(t),R(t);\n    for(int i=0;i<t;i++){\n        cin >> P[i] >> R[i];\n        P[i]--;\n        R[i]--;\n    }\n    int ok = -1;\n    int ng = t+1;\n    while(abs(ok-ng)!=1){\n        int mid = (ok+ng)/2;\n        //cout << mid << endl;\n        vector<int> x(r);\n        vector<vector<int> > y(p,vector<int>(r));\n        for(int i=0;i<r;i++){\n            x[i] = l[i];\n        }\n        for(int i=0;i<p;i++){\n            for(int j=0;j<r;j++){\n                y[i][j] = n[i][j];\n            }\n        }\n        for(int i=0;i<mid;i++){\n            x[R[i]]--;\n            y[P[i]][R[i]]--;\n            if(y[P[i]][R[i]]==0){\n                bool flag = 1;\n                for(int j=0;j<r;j++){\n                    if(y[P[i]][j]!=0){\n                        flag = 0;\n                        break;\n                    }\n                }\n                if(flag){\n                    for(int j=0;j<r;j++){\n                        y[P[i]][j]=n[P[i]][j];\n                        x[j] += n[P[i]][j];\n                    }\n                }\n            }\n        }\n        vector<bool> sss(p);\n        for(int z=0;z<p;z++){\n            for(int i=0;i<p;i++){\n                if(sss[i]==1)continue;\n                bool flag = 1;\n                for(int k=0;k<r;k++){\n                    //cout << i << \" \" << k << \" \" << y[i][k] << \" \" <<x[k] << endl;\n                    if(y[i][k]>x[k]){\n                        flag=0;\n                        break;\n                    }\n                }\n                if(flag){\n                    sss[i]=1;\n                    for(int k=0;k<r;k++){\n                        x[k] += n[i][k]-y[i][k];\n                    }\n                }\n            }\n        }\n        bool flag = 1;\n        for(int i=0;i<p;i++){\n            if(sss[i]==0){\n                flag = 0;\n            }\n        }\n        if(flag){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    if(ng==t+1){\n        cout << -1 << endl;\n    }else{\n    cout << ng << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint p, r, t;\n\tcin >> p >> r >> t;\n\tvi resource(r);\n\tREP(i, r) cin >> resource[i];\n\tvector<vi> need(p, vi(r));\n\tREP(i, p)REP(j, r) cin >> need[i][j];\n\tvector<pii> query;\n\tREP(i, t)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tquery.emplace_back(a, b);\n\t}\t\t\n\tauto available = resource;\n\tauto tmp = need;\n\tREP(i, t)\n\t{\n\t\tint p = query[i].first, r = query[i].second;\n\t\tavailable[r]--;\n\t\ttmp[p][r]--;\n\t}\n\tint lb = 0, ub = t + 1;\n\twhile (ub - lb > 1)\n\t{\n\t\tint time = (ub + lb) / 2;\n\t\tauto available = resource;\n\t\tauto tmp = need;\n\t\tREP(i, time)\n\t\t{\n\t\t\tint p = query[i].first, r = query[i].second;\n\t\t\tavailable[r]--;\n\t\t\ttmp[p][r]--;\n\t\t}\n\t\tvector<bool> f(p, true);\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tREP(i, p)\n\t\t\t{\n\t\t\t\tif (!f[i]) continue;\n\t\t\t\tbool ff = true;\n\t\t\t\tREP(j, tmp[i].size())\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i][j] > available[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tff = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ff)\n\t\t\t\t{\n\t\t\t\t\tREP(j, r) available[j] += need[i][j] - tmp[i][j];\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tf[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i, p)\n\t\t{\n\t\t\tif (f[i])\n\t\t\t{\n\t\t\t\tREP(j, r)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i][j] > available[j]) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) lb = time;\n\t\telse ub = time;\n\t}\n\tif (ub == t + 1) cout << -1 << endl;\n\telse cout << ub << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N, r, t;\nint res[300];\nint need[300][300];\nint R[200000];\nint P[200000];\ntypedef pair<int, int> Pii;\n\nbool check(int x){\n\tint sum[300][300] = { 0 };\n\tint rem[300] = { 0 };\n\tmemcpy(rem, res, sizeof res);\n\n\tfor(int i = 0; i < x; i++){\n\t\t//if(rem[R[i]] == 0) return false;\n\t\trem[R[i]]--;\n\t\tsum[P[i]][R[i]]++;\n\t}\n\tint fin[300] = { 0 };\n\tfor(int i = 0; i < N; i++){\n\t\tint cnt = 0;\n\t\tfor(int j = 0; j < r; j++){\n\t\t\tif(sum[i][j] == need[i][j]) cnt++;\n\t\t}\n\t\tif(cnt == r){\n\t\t\tfin[i] = 1;\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\trem[j] += sum[i][j];\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tbool update = false;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(fin[i]) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tint c = need[i][j] - sum[i][j];\n\t\t\t\tif(c <= rem[j]) cnt++;\n\t\t\t}\n\t\t\tif(cnt == r){\n\t\t\t\tfin[i] = 1;\n\t\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\t\trem[j] += sum[i][j];\n\t\t\t\t}\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif(!update) break;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tif(fin[i] == 0) return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> N >> r >> t){\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tcin >> res[i];\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tcin >> need[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tcin >> P[i] >> R[i];\n\t\t\tP[i]--, R[i]--;\n\t\t}\n\n\t\tif(check(t)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ok = 0, ng = t;\n\t\twhile(abs(ok - ng) > 1){\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\n\t\tcout << ng << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200050;\n\nint p, r, t, a[510], m[510][510], s[510][510], b[510], u[N], v[N];\nbool vis[510];\n\nbool check(int mid) {\n    queue <int> q;\n    for (int i = 0; i < p; i++) {\n        vis[i] = false;\n        for (int j = 0; j < r; j++) {\n            s[i][j] = m[i][j];\n        }\n    }\n    for (int i = 0; i < r; i++) {\n        b[i] = a[i];\n    }\n    for (int i = 0; i <= mid; i++) {\n        b[v[i]]--;\n        s[u[i]][v[i]]--;\n        assert(u[i] < p);\n        assert(v[i] < r);\n        //assert(b[v[i]] >= 0);\n        assert(s[u[i]][v[i]] >= 0);\n    }\n    for (int i = 0; i < p; i++) {\n        bool ok = true;\n        for (int j = 0; j < r; j++) {\n            if (s[i][j] > b[j]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            vis[i] = true;\n            q.push(i);\n        }\n    }\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = 0; i < r; i++) {\n            b[i] += m[now][i] - s[now][i];\n        }\n        for (int i = 0; i < p; i++) {\n            if (vis[i]) {\n                continue;\n            }\n            bool ok = true;\n            for (int j = 0; j < r; j++) {\n                if (s[i][j] > b[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                vis[i] = true;\n                q.push(i);\n            }\n        }\n    }\n    for (int i = 0; i < p; i++) {\n        if (!vis[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n\n    while (scanf(\"%d %d %d\", &p, &r, &t) != EOF) {\n        for (int i = 0; i < r; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < r; j++) {\n                scanf(\"%d\", &m[i][j]);\n            }\n        }\n        for (int i = 0; i < t; i++) {\n            scanf(\"%d %d\", &u[i], &v[i]);\n            u[i]--;\n            v[i]--;\n        }\n        if (check(t - 1)) {\n            puts(\"-1\");\n            continue;\n        }\n        int lo = -1;\n        int hi = t - 1;\n        for (int i = 0; i < t && i < 100; i++) {\n            assert(check(i) >= check(i + 1));\n        }\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (check(mid)) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        printf(\"%d\\n\", lo + 1);\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    P, R, T = map(int, readline().split())\n    *L, = map(int, readline().split())\n    RS = [list(map(int, readline().split())) for i in range(P)]\n    LG = [list(map(int, input().split())) for i in range(T)]\n\n    prv = -1\n    K = [[0]*R for i in range(P)]\n    def check(t):\n        nonlocal prv\n        if prv < t:\n            for i in range(prv+1, t+1):\n                p, r = LG[i]\n                K[p-1][r-1] += 1\n                L[r-1] -= 1\n        else:\n            for i in range(t+1, prv+1):\n                p, r = LG[i]\n                K[p-1][r-1] -= 1\n                L[r-1] += 1\n        S = L[:]; U = [0]*P\n        updated = 1\n        while updated:\n            updated = 0\n            for i in range(P):\n                if U[i]:\n                    continue\n                for j in range(R):\n                    if RS[i][j] - K[i][j] > max(S[j], 0):\n                        break\n                else:\n                    U[i] = 1\n                    for j in range(R):\n                        S[j] += K[i][j]\n                    updated = 1\n        prv = t\n        return sum(U) == P\n\n    left = 0; right = T\n    while left+1 < right:\n        mid = (left + right) >> 1\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n    if right == T:\n        write(\"-1\\n\")\n    else:\n        write(\"%d\\n\" % (right+1))\nsolve()\n"
  }
]