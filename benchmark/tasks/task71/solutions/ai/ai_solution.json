[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_TOWNS 100\n\nint n, m;\nint reward;\nint cost[MAX_TOWNS][MAX_TOWNS];\nint dist[MAX_TOWNS];\nint visited[MAX_TOWNS];\n\nvoid dijkstra(int start) {\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n\n    for (int count = 0; count < n - 1; count++) {\n        int u = -1;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i] && (u == -1 || dist[i] < dist[u])) {\n                u = i;\n            }\n        }\n        if (u == -1 || dist[u] == INT_MAX) break;\n        visited[u] = 1;\n\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && cost[u][v] && dist[u] != INT_MAX && dist[u] + cost[u][v] < dist[v]) {\n                dist[v] = dist[u] + cost[u][v];\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%d\", &reward);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cost[i][j] = 0;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v, c;\n        scanf(\"%d %d %d\", &u, &v, &c);\n        cost[u-1][v-1] = c;\n        cost[v-1][u-1] = c;\n    }\n\n    dijkstra(0);\n    int to_mountain = dist[n-1];\n\n    dijkstra(n-1);\n    int to_town = dist[0];\n\n    if (to_mountain == INT_MAX || to_town == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        int total_cost = to_mountain + to_town;\n        int max_reward = reward - total_cost;\n        printf(\"%d\\n\", max_reward > 0 ? max_reward : -1);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:27:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PillarRoute {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt(); // Number of towns\n        int M = scanner.nextInt(); // Number of highways\n        int L = scanner.nextInt(); // Cost of pillar\n        int start = scanner.nextInt(); // Starting town\n        int mountain = scanner.nextInt(); // Mountain village town\n        int K = scanner.nextInt(); // Lord's budget\n        \n        // Create adjacency list to represent graph\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Read highway connections and travel costs\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            int cost = scanner.nextInt();\n            graph.get(a).add(new int[]{b, cost});\n            graph.get(b).add(new int[]{a, cost});\n        }\n        \n        // Dijkstra's algorithm to find shortest paths\n        int[][] distances = new int[N][K + 1];\n        for (int[] row : distances) Arrays.fill(row, Integer.MAX_VALUE);\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        pq.offer(new int[]{start, 0, 0});\n        distances[start][0] = 0;\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int town = current[0];\n            int budget = current[1];\n            int currentDist = current[2];\n            \n            if (currentDist > distances[town][budget]) continue;\n            \n            for (int[] neighbor : graph.get(town)) {\n                int nextTown = neighbor[0];\n                int travelCost = neighbor[1];\n                \n                // Travel without buying pillar\n                if (budget >= travelCost && currentDist + travelCost < distances[nextTown][budget - travelCost]) {\n                    distances[nextTown][budget - travelCost] = currentDist + travelCost;\n                    pq.offer(new int[]{nextTown, budget - travelCost, currentDist + travelCost});\n                }\n                \n                // Buy pillar and travel\n                if (budget >= travelCost + L && currentDist + travelCost < distances[nextTown][budget - travelCost - L]) {\n                    distances[nextTown][budget - travelCost - L] = currentDist + travelCost;\n                    pq.offer(new int[]{nextTown, budget - travelCost - L, currentDist + travelCost});\n                }\n            }\n        }\n        \n        // Find maximum reward\n        int maxReward = K - findMinDistance(distances, mountain);\n        System.out.println(maxReward);\n    }\n    \n    private static int findMinDistance(int[][] distances, int town) {\n        int minDist = Integer.MAX_VALUE;\n        for (int budget = 0; budget < distances[0].length; budget++) {\n            minDist = Math.min(minDist, distances[town][budget]);\n        }\n        return minDist;\n    }\n}",
    "timestamp": "2025-08-05 18:27:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvector<int> dijkstra(const vector<vector<pii>>& graph, int start) {\n    int n = graph.size();\n    vector<int> dist(n, INT_MAX);\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (current_dist > dist[u]) continue;\n\n        for (auto& edge : graph[u]) {\n            int v = edge.first;\n            int cost = edge.second;\n            if (dist[v] > dist[u] + cost) {\n                dist[v] = dist[u] + cost;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\nint main() {\n    int N, M, X, Y;\n    cin >> N >> M >> X >> Y;\n\n    vector<vector<pii>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v, cost;\n        cin >> u >> v >> cost;\n        graph[u].push_back({v, cost});\n        graph[v].push_back({u, cost});\n    }\n\n    vector<int> dist_from_town = dijkstra(graph, X);\n    vector<int> dist_from_mountain = dijkstra(graph, Y);\n\n    if (dist_from_town[Y] == INT_MAX || dist_from_mountain[X] == INT_MAX) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int total_cost = dist_from_town[Y] + dist_from_mountain[X];\n    int max_reward = Y - total_cost;\n\n    cout << max_reward << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:28:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_TOWNS 100\n\nint main() {\n    int n, m, start, end;\n    scanf(\"%d %d %d %d\", &n, &m, &start, &end);\n\n    int graph[MAX_TOWNS][MAX_TOWNS];\n    int pillar_cost[MAX_TOWNS];\n    int reward[MAX_TOWNS];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            graph[i][j] = (i == j) ? 0 : INT_MAX;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v, cost;\n        scanf(\"%d %d %d\", &u, &v, &cost);\n        graph[u-1][v-1] = cost;\n        graph[v-1][u-1] = cost;\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &pillar_cost[i]);\n    }\n\n    scanf(\"%d\", &reward[end-1]);\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (graph[i][k] != INT_MAX && graph[k][j] != INT_MAX &&\n                    graph[i][k] + graph[k][j] < graph[i][j]) {\n                    graph[i][j] = graph[i][k] + graph[k][j];\n                }\n            }\n        }\n    }\n\n    int max_carpenter_reward = INT_MIN;\n    for (int mountain_town = 0; mountain_town < n; mountain_town++) {\n        if (graph[start-1][mountain_town] != INT_MAX && \n            graph[mountain_town][end-1] != INT_MAX) {\n            int total_travel_cost = graph[start-1][mountain_town] + \n                                     graph[mountain_town][end-1];\n            int current_reward = reward[end-1] - pillar_cost[mountain_town] - \n                                 total_travel_cost;\n            \n            if (current_reward > max_carpenter_reward) {\n                max_carpenter_reward = current_reward;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_carpenter_reward);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:28:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge {\n    int to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n};\n\nint dijkstra(vector<vector<Edge>>& graph, int start, int end) {\n    int n = graph.size();\n    vector<int> dist(n, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    dist[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int curr_cost = pq.top().first;\n        int curr_node = pq.top().second;\n        pq.pop();\n        \n        if (curr_cost > dist[curr_node]) continue;\n        \n        for (auto& edge : graph[curr_node]) {\n            int next_node = edge.to;\n            int next_cost = curr_cost + edge.cost;\n            \n            if (next_cost < dist[next_node]) {\n                dist[next_node] = next_cost;\n                pq.push({next_cost, next_node});\n            }\n        }\n    }\n    \n    return dist[end];\n}\n\nint main() {\n    int n, m, pillar_cost, lord_reward;\n    cin >> n >> m >> pillar_cost >> lord_reward;\n    \n    vector<vector<Edge>> graph(n);\n    \n    for (int i = 0; i < m; i++) {\n        int u, v, cost;\n        cin >> u >> v >> cost;\n        u--; v--;\n        graph[u].push_back(Edge(v, cost));\n        graph[v].push_back(Edge(u, cost));\n    }\n    \n    int mountain_village = n - 1;\n    int round_trip_cost = dijkstra(graph, 0, mountain_village) * 2;\n    \n    int reward = lord_reward - round_trip_cost - pillar_cost;\n    \n    cout << reward << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:28:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Edge {\n        int town;\n        int cost;\n        \n        Edge(int town, int cost) {\n            this.town = town;\n            this.cost = cost;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int P = sc.nextInt();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int C = sc.nextInt();\n            graph.get(A).add(new Edge(B, C));\n            graph.get(B).add(new Edge(A, C));\n        }\n        \n        int[] toMountain = dijkstra(graph, 1, N);\n        int[] fromMountain = dijkstra(graph, N, N);\n        \n        int totalCost = toMountain[N] + fromMountain[1];\n        int maxReward = P - totalCost;\n        \n        System.out.println(Math.max(maxReward, 0));\n    }\n    \n    static int[] dijkstra(List<List<Edge>> graph, int start, int N) {\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.cost));\n        pq.add(new Edge(start, 0));\n        \n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int u = current.town;\n            if (current.cost > dist[u]) continue;\n            \n            for (Edge edge : graph.get(u)) {\n                int v = edge.town;\n                int cost = edge.cost;\n                if (dist[v] > dist[u] + cost) {\n                    dist[v] = dist[u] + cost;\n                    pq.add(new Edge(v, dist[v]));\n                }\n            }\n        }\n        \n        return dist;\n    }\n}",
    "timestamp": "2025-08-05 18:28:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef max_reward(num_towns, highways, cost_of_pillars, reward):\n    graph = {i: [] for i in range(num_towns)}\n    \n    for u, v, cost in highways:\n        graph[u].append((v, cost))\n        graph[v].append((u, cost))\n    \n    def dijkstra(source, target):\n        min_heap = [(0, source)]\n        distances = {i: float('inf') for i in range(num_towns)}\n        distances[source] = 0\n\n        while min_heap:\n            current_dist, current_town = heapq.heappop(min_heap)\n\n            if current_town == target:\n                return current_dist\n            \n            if current_dist > distances[current_town]:\n                continue\n            \n            for neighbor, weight in graph[current_town]:\n                distance = current_dist + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(min_heap, (distance, neighbor))\n\n        return float('inf')\n    \n    # Assuming town 0 is the starting town and town (num_towns-1) is the mountain village.\n    travel_cost = dijkstra(0, num_towns - 1) + dijkstra(num_towns - 1, 0)\n    \n    max_possible_reward = reward - (cost_of_pillars + travel_cost)\n    \n    return max_possible_reward\n\n# Example Usage\nnum_towns = 5\nhighways = [\n    (0, 1, 10),\n    (1, 2, 20),\n    (2, 3, 5),\n    (3, 4, 10),\n    (4, 0, 15),\n    (0, 3, 25)\n]\ncost_of_pillars = 100\nreward = 500\n\nprint(max_reward(num_towns, highways, cost_of_pillars, reward))",
    "timestamp": "2025-08-12 23:19:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CarpenterReward {\n\n    static class Edge {\n        int destination;\n        int cost;\n        \n        Edge(int destination, int cost) {\n            this.destination = destination;\n            this.cost = cost;\n        }\n    }\n\n    public static int maxReward(int numTowns, List<Edge>[] highways, int start, int end, int reward, int pillarCost) {\n        // Dijkstra's algorithm to find the shortest path cost\n        int[] minCost = new int[numTowns];\n        Arrays.fill(minCost, Integer.MAX_VALUE);\n        minCost[start] = 0;\n        \n        PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(Comparator.comparingInt(e -> e.cost));\n        priorityQueue.add(new Edge(start, 0));\n        \n        while (!priorityQueue.isEmpty()) {\n            Edge current = priorityQueue.poll();\n            \n            if (current.cost > minCost[current.destination]) continue;\n            \n            for (Edge neighbor : highways[current.destination]) {\n                int newCost = current.cost + neighbor.cost;\n                if (newCost < minCost[neighbor.destination]) {\n                    minCost[neighbor.destination] = newCost;\n                    priorityQueue.add(new Edge(neighbor.destination, newCost));\n                }\n            }\n        }\n        \n        int travelCost = minCost[end] * 2; // round trip\n        return reward - (pillarCost + travelCost);\n    }\n\n    public static void main(String[] args) {\n        int numTowns = 5;\n        List<Edge>[] highways = new List[numTowns];\n        for (int i = 0; i < numTowns; i++) {\n            highways[i] = new ArrayList<>();\n        }\n        \n        // Sample map data: highways between towns and their costs\n        highways[0].add(new Edge(1, 4));\n        highways[0].add(new Edge(2, 2));\n        highways[1].add(new Edge(2, 5));\n        highways[1].add(new Edge(3, 10));\n        highways[2].add(new Edge(3, 3));\n        highways[3].add(new Edge(4, 1));\n        highways[2].add(new Edge(4, 8));\n\n        int startTown = 0;\n        int mountainVillageTown = 4;\n        int reward = 1000; // Reward from the lord\n        int pillarCost = 200; // Cost of pillars\n        \n        int maximumReward = maxReward(numTowns, highways, startTown, mountainVillageTown, reward, pillarCost);\n        \n        System.out.println(\"Maximum Possible Reward: \" + maximumReward);\n    }\n}",
    "timestamp": "2025-08-12 23:20:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAXN 100\n\nint minCost[MAXN][MAXN];\nint visited[MAXN];\nint distance[MAXN];\n\nint findMinimumDistance(int n) {\n    int min = INT_MAX, index;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i] && distance[i] <= min) {\n            min = distance[i];\n            index = i;\n        }\n    }\n    return index;\n}\n\nvoid dijkstra(int graph[MAXN][MAXN], int source, int n) {\n    for (int i = 0; i < n; i++) {\n        distance[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    distance[source] = 0;\n    for (int i = 0; i < n - 1; i++) {\n        int minIndex = findMinimumDistance(n);\n        visited[minIndex] = 1;\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] &&\n                graph[minIndex][j] &&\n                distance[minIndex] != INT_MAX &&\n                distance[minIndex] + graph[minIndex][j] < distance[j]) {\n                distance[j] = distance[minIndex] + graph[minIndex][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, costOfPillars, reward;\n    int graph[MAXN][MAXN] = {0};\n\n    scanf(\"%d %d %d %d\", &n, &m, &costOfPillars, &reward);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, cost;\n        scanf(\"%d %d %d\", &u, &v, &cost);\n        graph[u][v] = cost;\n        graph[v][u] = cost;\n    }\n\n    int town = 0, village = n - 1; // assuming the source is 0 and village is n-1\n    dijkstra(graph, town, n);\n\n    int totalTravelCost = distance[village] * 2;\n    int maximumReward = reward - totalTravelCost - costOfPillars;\n\n    printf(\"%d\\n\", maximumReward);\n\n    return 0;\n}",
    "timestamp": "2025-08-12 23:20:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve_carpenter_route(N, M, start, mountain_village, highways):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    for u, v, cost in highways:\n        graph[u].append((v, cost))\n        graph[v].append((u, cost))\n\n    # Dijkstra's algorithm to find minimum cost path\n    def dijkstra(start, end):\n        distances = [float('inf')] * (N+1)\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n            \n            if current_node == end:\n                return current_dist\n            \n            if current_dist > distances[current_node]:\n                continue\n            \n            for neighbor, edge_cost in graph[current_node]:\n                distance = current_dist + edge_cost\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        \n        return float('inf')\n\n    # Get input parameters\n    lord_payment, pillar_cost, K = map(int, input().split())\n    \n    # Get town route options\n    routes = []\n    for _ in range(K):\n        route = list(map(int, input().split()))\n        routes.append(route)\n    \n    # Find maximum reward\n    max_reward = float('-inf')\n    for route in routes:\n        total_travel_cost = 0\n        current = start\n        \n        # Calculate travel cost for the route\n        for next_town in route:\n            path_cost = dijkstra(current, next_town)\n            total_travel_cost += path_cost\n            current = next_town\n        \n        # Add return trip from last town back to start\n        total_travel_cost += dijkstra(current, start)\n        \n        # Calculate reward\n        reward = lord_payment - pillar_cost - total_travel_cost\n        max_reward = max(max_reward, reward)\n    \n    return max_reward\n\n# Main input processing\nN, M = map(int, input().split())\nstart = int(input())\nmountain_village = int(input())\n\nhighways = []\nfor _ in range(M):\n    u, v, cost = map(int, input().split())\n    highways.append((u, v, cost))\n\nprint(solve_carpenter_route(N, M, start, mountain_village, highways))",
    "timestamp": "2025-08-12 23:20:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef max_reward(N, M, money, cost, roads):\n    # Dijkstra's algorithm to find the shortest path from town 1 to town N and back\n    def dijkstra(start):\n        dist = [float('inf')] * (N + 1)\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[u]:\n                continue\n            for v, w in roads[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(heap, (dist[v], v))\n        return dist\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for u, v, w in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    \n    roads = adj\n    dist_to = dijkstra(1)\n    dist_back = dijkstra(N)\n    total_cost = dist_to[N] + dist_back[1]\n    max_reward = money - cost - total_cost\n    return max_reward if max_reward > 0 else 0\n\n# Read input\nN, M = map(int, input().split())\nmoney, cost = map(int, input().split())\nroads = []\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    roads.append((u, v, w))\n\n# Compute and print result\nresult = max_reward(N, M, money, cost, roads)\nprint(result)",
    "timestamp": "2025-08-12 23:20:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nclass Graph {\npublic:\n    int V;\n    vector<vector<pii>> adj;\n    \n    Graph(int V) {\n        this->V = V;\n        adj.resize(V);\n    }\n    \n    void addEdge(int u, int v, int w) {\n        adj[u].push_back({v, w});\n        adj[v].push_back({u, w});\n    }\n    \n    int dijkstra(int src, int dest) {\n        // Min-heap priority queue\n        vector<int> dist(V, INT_MAX);\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        \n        dist[src] = 0;\n        pq.push({0, src});\n        \n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n            \n            for (auto &edge : adj[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n                \n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n        \n        return dist[dest];\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m; // n: number of towns, m: number of highways\n    \n    Graph g(n);\n    \n    for (int i = 0; i < m; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        g.addEdge(u, v, w);\n    }\n    \n    int town, village, reward, pillarCost, roundTripCost;\n    cin >> town >> village >> reward >> pillarCost;\n    \n    roundTripCost = g.dijkstra(town, village) * 2;\n    \n    int maxReward = reward - (pillarCost + roundTripCost);\n    \n    cout << maxReward << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:49:46"
  }
]